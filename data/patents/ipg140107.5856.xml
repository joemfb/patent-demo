<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08626965-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08626965</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13189801</doc-number>
<date>20110725</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<us-term-of-grant>
<us-term-extension>247</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>13</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>3</main-group>
<subgroup>00</subgroup>
<symbol-position>L</symbol-position>
<classification-value>N</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>710 23</main-classification>
<further-classification>710  2</further-classification>
<further-classification>710  5</further-classification>
<further-classification>710  8</further-classification>
<further-classification>710 15</further-classification>
</classification-national>
<invention-title id="d2e53">Using a DMA engine to automatically validate DMA data paths</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>2003/0093633</doc-number>
<kind>A1</kind>
<name>Thiesfeld et al.</name>
<date>20030500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711154</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>2008/0140977</doc-number>
<kind>A1</kind>
<name>Shimakura et al.</name>
<date>20080600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711169</main-classification></classification-national>
</us-citation>
</us-references-cited>
<number-of-claims>20</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>3</number-of-drawing-sheets>
<number-of-figures>3</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20130031281</doc-number>
<kind>A1</kind>
<date>20130131</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Feehrer</last-name>
<first-name>John R.</first-name>
<address>
<city>Westford</city>
<state>MA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Yan</last-name>
<first-name>Jane W.</first-name>
<address>
<city>Andover</city>
<state>MA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Noel</last-name>
<first-name>Matthew G.</first-name>
<address>
<city>Boulder Creek</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Feehrer</last-name>
<first-name>John R.</first-name>
<address>
<city>Westford</city>
<state>MA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Yan</last-name>
<first-name>Jane W.</first-name>
<address>
<city>Andover</city>
<state>MA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Noel</last-name>
<first-name>Matthew G.</first-name>
<address>
<city>Boulder Creek</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Park, Vaughan, Fleming &#x26; Dowler LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Spiller</last-name>
<first-name>Mark</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Oracle International Corporation</orgname>
<role>02</role>
<address>
<city>Redwood Shores</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Sun</last-name>
<first-name>Scott</first-name>
<department>2181</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">The disclosed embodiments provide a system that uses a DMA engine to automatically validate DMA data paths for a computing device. During operation, the system configures the DMA engine to perform a programmable DMA operation that generates a sequence of memory accesses which validate the memory subsystem and DMA paths of the computing device. For instance, the operation may include a sequence of reads and/or writes that generate sufficient data traffic to exercise the computing device's I/O controller interface and DMA data paths to memory to a specified level. The system initiates this programmable DMA operation, and then checks outputs for the operation to confirm that the operation executed successfully.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="129.03mm" wi="97.45mm" file="US08626965-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="231.06mm" wi="168.49mm" file="US08626965-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="141.73mm" wi="96.44mm" file="US08626965-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="186.10mm" wi="162.48mm" file="US08626965-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND</heading>
<p id="p-0002" num="0001">1. Field of the Invention</p>
<p id="p-0003" num="0002">This disclosure generally relates to techniques for testing I/O subsystems in a computing device. More specifically, this disclosure relates to techniques for using a DMA engine to automatically validate DMA data paths and expose any latent bugs or throughput bottlenecks in an I/O subsystem.</p>
<p id="p-0004" num="0003">2. Related Art</p>
<p id="p-0005" num="0004">Recent advances in computational technology have led to improved processor capabilities, increased memory sizes, and increasingly sophisticated storage devices and peripherals. However, as the complexity of computer systems grows, comprehensively testing each component becomes difficult, and testing the interactions among multiple components even more so.</p>
<p id="p-0006" num="0005">For instance, consider the process of developing and validating a high-performance I/O subsystem. A common challenge in validating an I/O subsystem in a lab is to create sufficient traffic to expose latent bugs or throughput bottlenecks, so that bug fixes or design modifications can be incorporated into the next version of a processor and/or chipset. Unfortunately, creating such traffic intensity can be difficult, because the needed leading-edge I/O devices and device drivers may also still be undergoing testing and may not yet be available. Earlier-generation devices can be used for testing purposes, but they may not generate enough traffic to adequately test a next-generation I/O subsystem. On the other hand, waiting until next-generation devices are available and fully supported potentially delays the discovery of some types of problems.</p>
<p id="p-0007" num="0006">Hence, what is needed are techniques for validating an I/O subsystem without the above-described problems.</p>
<heading id="h-0002" level="1">SUMMARY</heading>
<p id="p-0008" num="0007">The disclosed embodiments provide a system that uses a DMA engine to automatically validate DMA data paths for a computing device. During operation, the system configures the DMA engine to perform a programmable DMA operation that generates a sequence of memory accesses which validate the memory subsystem and DMA paths of the computing device. For instance, the operation may include a sequence of reads and/or writes that generate sufficient data traffic to exercise the computing device's I/O controller interface and DMA data paths to memory to a specified level. The system initiates this programmable DMA operation, and then checks outputs for the operation to confirm that the operation executed successfully.</p>
<p id="p-0009" num="0008">In some embodiments, generating sufficient data traffic to exercise the computing device's I/O host interface and DMA data paths involves generating data access patterns that exercise the I/O bandwidth of the computing device to the desired level and confirm memory system coherency for the computing device.</p>
<p id="p-0010" num="0009">In some embodiments, the system fully exercises the I/O bandwidth of the computing device to detect a mismatch between functional and performance (e.g., data throughput) capabilities of the computing device's I/O subsystem and the functional and performance capabilities of other (e.g., external) I/O devices which communicate with the computing device. Fully exercising the I/O bandwidth facilitates exposes latent bugs or throughput bottlenecks in the computing device's I/O subsystem.</p>
<p id="p-0011" num="0010">In some embodiments, traffic generated by the DMA engine is multiplexed with I/O traffic from one or more external I/O devices.</p>
<p id="p-0012" num="0011">In some embodiments, the programmable DMA operation is initiated for a processor in a chip testing environment, where driving and sampling the pins of the processor to exercise the I/O bandwidth of the processor at the desired level might otherwise not be possible.</p>
<p id="p-0013" num="0012">In some embodiments, the system configures and initiates the programmable DMA operation by configuring a set of control and status registers for the DMA engine to specify an I/O test pattern and a duration. In some embodiments, this I/O test pattern includes: (1) a revolving pattern of read operations that load a known pattern of distinctive data values from the memory subsystem into a set of data registers in the DMA engine; and/or (2) a revolving pattern of write operations that generate a known pattern of distinctive data values in the DMA engine and transfer them to cachelines in the memory subsystem. Note that this revolving pattern may include unaligned reads and/or writes that trigger read-modify-write sub-operations, thereby stressing the memory and cache coherency subsystem.</p>
<p id="p-0014" num="0013">In some embodiments, the computing device may not include a memory device. In such embodiments, the programmable DMA operation may involve sending a pseudo-random stream of data generated in a memory controller to the DMA engine. The DMA engine may then XOR this pseudo-random stream of data into one or more data registers, and then compare a resulting checksum with a known checksum value to confirm that the programmable DMA operation executed successfully.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE FIGURES</heading>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 1</figref> illustrates an exemplary computing device in which a DMA engine can initiate a set of memory accesses that exercise an I/O subsystem and validate DMA data paths in accordance with an embodiment.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 2</figref> presents a flow chart that illustrates the process of using a DMA engine to automatically validate DMA data paths for a computing device in accordance with an embodiment.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 3</figref> illustrates a computing environment in accordance with an embodiment.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0018" num="0017">The following description is presented to enable any person skilled in the art to make and use the invention, and is provided in the context of a particular application and its requirements. Various modifications to the disclosed embodiments will be readily apparent to those skilled in the art, and the general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the present invention. Thus, the present invention is not limited to the embodiments shown, but is to be accorded the widest scope consistent with the principles and features disclosed herein.</p>
<p id="p-0019" num="0018">The data structures and code described in this detailed description are typically stored on a non-transitory computer-readable storage medium, which may be any device or non-transitory medium that can store code and/or data for use by a computer system. The non-transitory computer-readable storage medium includes, but is not limited to, volatile memory, non-volatile memory, magnetic and optical storage devices such as disk drives, magnetic tape, CDs (compact discs), DVDs (digital versatile discs or digital video discs), or other media capable of storing code and/or data now known or later developed.</p>
<p id="p-0020" num="0019">The methods and processes described in the detailed description section can be embodied as code and/or data, which can be stored in a non-transitory computer-readable storage medium as described above. When a computer system reads and executes the code and/or data stored on the non-transitory computer-readable storage medium, the computer system performs the methods and processes embodied as data structures and code and stored within the non-transitory computer-readable storage medium.</p>
<p id="p-0021" num="0020">Furthermore, the methods and processes described below can be included in hardware modules. For example, the hardware modules can include, but are not limited to, application-specific integrated circuit (ASIC) chips, a full-custom implementation as part of an integrated circuit (or another type of hardware implementation on an integrated circuit), field-programmable gate arrays (FPGAs), a dedicated or shared processor that executes a particular software module or a piece of code at a particular time, and/or other programmable-logic devices now known or later developed. When the hardware modules are activated, the hardware modules perform the methods and processes included within the hardware modules.</p>
<p id="h-0005" num="0000">Challenges in Validating High-Performance I/O Paths</p>
<p id="p-0022" num="0021">The performance of a computing device typically depends on a range of factors, including both the rate at which its processor can execute instructions as well as the speed with which target data can be accessed from I/O (input/output) devices and a memory subsystem. Many modern I/O subsystems support a &#x201c;direct memory access&#x201d; (DMA) capability, which enables hardware subsystems such as external I/O cards in a computer to read and write to system memory directly. In such systems, a processor may initiate a set of memory reads or writes to set up the external I/O device, but does not directly manage the memory accesses done by that device, and hence is not occupied for the entire operation. Allowing memory accesses to occur independently of the processing unit reduces overhead, and allows the processor to execute other instructions while the memory operation proceeds in parallel. When the memory accesses complete, an interrupt is typically sent to the processor, which can then proceed to operate upon loaded data or perform other operations, depending on the program context.</p>
<p id="p-0023" num="0022">DMA allows a processor to perform useful work during I/O data transfers. However, the ability of a processor to perform useful work still depends on the availability of target data, and thus faster processor speeds typically motivate faster, and more complex, I/O subsystems. Unfortunately, increasing complexity and short development timeframes make sufficiently validating such I/O subsystems difficult. The validation process typically involves creating enough traffic intensity to expose any latent bugs or throughput bottlenecks, and needs to be completed quickly (and thoroughly) so that any resulting bug fixes or design modifications can be incorporated into the next &#x201c;spin&#x201d; (chip fabrication) of the processor and/or chipset.</p>
<p id="p-0024" num="0023">A number of factors make validating a high-performance I/O subsystem difficult. For instance:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0024">1. A high-performance I/O subsystem typically employs the latest technology standards and capabilities, in a timeframe when there is often a shortage (or absence) of I/O devices (e.g., plug-in cards) that are built to such standards. For example, an I/O subsystem may be designed to support a next-generation technology, but when the chipset is being developed and validated in the lab for the first time, most of the readily available I/O devices incorporate previous-generation technology that cannot exercise the data and control paths of the I/O subsystem and the memory hierarchy at the line rate (i.e., maximum data bandwidth) for which they were designed. For instance, such devices may only be able to generate or receive only half of the maximum data throughput supported by the new I/O subsystem.</li>
        <li id="ul0002-0002" num="0025">2. Any available next-generation devices may not be sufficient (and/or sufficiently supported) for validation purposes. In order to use a third-party I/O device, a computing device's software stack needs to be functional enough to load any needed device drivers. A typical server environment often also includes multiple software components (e.g., power-on self-test diagnostics, hypervisor functionality that interfaces directly with hardware and hosts multiple guest operating systems, etc.) that may need to be debugged before an I/O device driver can execute. Such software complexity often means that hardware validation work may need to rely on a partially functioning software stack and/or a primitive device driver that cannot fully exercise I/O paths.</li>
        <li id="ul0002-0003" num="0026">3. Sophisticated test equipment (e.g., a traffic generator that drives packets to and receives packets from the ports of an I/O subsystem) may be able to generate line-rate traffic intensity, but is typically expensive, and hence in short supply. For example, a validation lab may have only a single traffic generator that is shared among many different testbeds.
<br/>
Because of such factors, hardware bugs that would be exposed at full traffic intensity might not be exposed until later in the validation cycle, if at all. Thus, mismatches between the capabilities of the I/O subsystem and available I/O devices can add risk to product schedules and overall product quality.
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0025" num="0027">Embodiments of the present invention use a &#x201c;DMA engine&#x201d; that generates programmable sequences of reads and writes to exercise an I/O controller's host interface and DMA data paths to memory. This DMA engine can generate a set of memory accesses that exercise the full bandwidth of the I/O subsystem, and includes checking capabilities to validate data integrity and cache coherency.</p>
<p id="h-0006" num="0000">Using a DMA Engine to Validate DMA Data Paths</p>
<p id="p-0026" num="0028"><figref idref="DRAWINGS">FIG. 1</figref> illustrates an exemplary computing device <b>100</b> in which a DMA engine <b>102</b> can initiate a set of memory accesses that exercise an I/O subsystem and validate DMA data paths. Note that some components are shown in overly simplified fashion for the sake of illustration. For instance, in <figref idref="DRAWINGS">FIG. 1</figref>, computing device <b>100</b> illustrates a single CPU core <b>112</b> and a single memory <b>114</b> linked by a memory/coherency interconnect <b>116</b>. In some embodiments, computing device <b>100</b> might consist of multiple processor cores and multiple memories connected by a cache coherent interconnect that consists of multiple hierarchical levels.</p>
<p id="p-0027" num="0029">DMA engine <b>102</b> is integrated into I/O controller <b>120</b>, and includes a set of control and status registers (CSRs) <b>104</b>, a request controller <b>106</b>, an error checking module <b>108</b>, and a set of XOR trees <b>110</b>. The CSRs <b>104</b> are mapped to a non-cacheable memory space that can be read and written by CPU core <b>112</b>. More specifically, CPU core <b>112</b> can program DMA engine <b>102</b> by performing programmed I/O transactions (&#x201c;CSR requests&#x201d; in <figref idref="DRAWINGS">FIG. 1</figref>) that are routed through memory/coherency interconnect <b>116</b> and I/O host interface <b>118</b> into CSRs <b>104</b>. For instance, a processor thread running a testing program may load configuration values into CSRs <b>104</b> to configure a programmable test operation, invoke the operation, and then read resulting values (&#x201c;CSR Data&#x201d; in <figref idref="DRAWINGS">FIG. 1</figref>) stored in CSRs <b>104</b>. In some embodiments, depending on the level and type of testing desired, the testing program may comprise low-level software that runs before an operating system boots. In alternative embodiments, this testing program may execute in an operating system environment.</p>
<p id="p-0028" num="0030">Requests sent by request controller <b>106</b> are multiplexed with the normal ingress path <b>122</b> that routes data in from I/O links to third-party I/O devices <b>126</b> via the I/O link interface <b>124</b>. A set of scoreboard entries in the I/O host interface include tag bits <b>128</b> that track the source of a request. DMA read data received from memory/coherency interconnect <b>116</b> via I/O host interface <b>118</b> is demultiplexed and directed either to DMA engine <b>102</b> or to the normal egress path <b>130</b> depending on whether DMA engine <b>102</b> or an I/O device, respectively, issued the corresponding DMA read request. Note that DMA engine <b>102</b> can be located at a level in the I/O pipeline where the specific I/O packet format associated with the underlying I/O link technology (e.g., PCI-Express) has already been converted to a more generic format, thereby allowing DMA engine <b>102</b> to be designed independently of the underlying I/O technology.</p>
<p id="p-0029" num="0031">Note that in some embodiments DMA engine <b>102</b> and external I/O devices connected to I/O controller <b>120</b> may operate either in isolation (e.g., separately generating testing traffic) or may both operate simultaneously to increase the traffic through the DMA paths of computing device <b>100</b>. For instance, DMA engine <b>102</b> can be configured to complement the traffic generated by early development versions of I/O cards, devices, and drivers (and/or previous-generation devices) to ensure that a desired traffic level (e.g., the estimated capacity of the I/O subsystem) is achieved. Because the DMA engine <b>102</b> is native to I/O controller <b>120</b>, it can be configured to run at the maximum speed of the I/O subsystem; external I/O cards and devices often have constraints that prevent them from achieving similar bandwidths. Using DMA engine <b>102</b> in conjunction with other I/O devices also facilitates detecting unexpected design issues and interactions. Note also that traffic arriving from the two sets of sources may be multiplexed using a range of techniques. For example, a request multiplexer in I/O controller <b>120</b> may include a simple arbiter (e.g., a round-robin arbiter) that manages requests when the DMA engine and I/O devices connected to the I/O host controller are both generating traffic simultaneously.</p>
<p id="p-0030" num="0032">In some embodiments, the DMA engine may be used in a range of testing environments. For example, while the above examples describe using the DMA engine in a completely assembled computing device with I/O cards and devices, in other embodiments the DMA engine may be used in a chip testing environment where a chip is tested in stand-alone fashion. Testing software in a chip testing environment is typically not capable of driving and sampling the pins of a chip's I/O ports in a way that mimics real I/O devices; hence, in this environment the DMA engine may be the only means of creating line-rate DMA traffic between the I/O and memory subsystems. The DMA engine can also facilitate pre-silicon RTL (Register Transfer Language) simulation testing. I/O device simulation models attached to the I/O host controller's I/O ports sometimes slow down the simulation, and often have throughput-limiting shortcomings; in contrast, a DMA engine included in the same simulation model can be used to more easily simulate a high volume of I/O traffic and a large number of I/O transactions in pre-silicon simulations.</p>
<p id="p-0031" num="0033"><figref idref="DRAWINGS">FIG. 2</figref> presents a flow chart that illustrates the process of using a DMA engine to automatically validate DMA data paths for a computing device. During operation, the system configures the DMA engine to perform a programmable DMA operation that generates a sequence of memory accesses which validate the memory subsystem and DMA paths of the computing device (operation <b>200</b>). For instance, the operation may include a sequence of reads and/or writes that generate sufficient data traffic to exercise the computing device's I/O controller interface and DMA data paths to memory to a specified level. The system initiates this programmable DMA operation (operation <b>210</b>), and then checks outputs for the operation to confirm that the operation executed successfully (operation <b>220</b>). In some embodiments, the DMA engine may also be configured to report the operation's pass/fail status to a program that has initiated the programmable DMA operation.</p>
<p id="p-0032" num="0034">In some embodiments, the DMA engine may be implemented in a range of logical modules. For instance, in the exemplary computing device of <figref idref="DRAWINGS">FIG. 1</figref>, DMA engine <b>102</b> is incorporated into I/O controller <b>120</b>, which is an advantageous location for initiating operations that exercise the I/O and memory subsystems. For instance, one benefit of co-locating DMA engine <b>102</b> in the I/O subsystem is that this location facilitates thoroughly testing as many portions of the I/O path as possible without needing external cards and/or devices. However, a DMA engine may be co-located in other logical areas of a chip design. For example, some processor implementations include &#x201c;memory copy engines&#x201d; that facilitate copying values in one memory location to another memory location. Some or all portions of a DMA engine that focuses on testing memory coherency and some aspects of the I/O subsystem might also be included in such a memory copy engine, or elsewhere.</p>
<p id="h-0007" num="0000">Programmable I/O Test Patterns</p>
<p id="p-0033" num="0035">A DMA engine may be configured to generate a range of target addresses and data accesses that stress the desired aspects of the I/O and memory hierarchy (e.g., the I/O data paths and cache coherency). In some embodiments, configuring a DMA engine may involve selecting a test pattern and a duration (and/or memory interval) over which the test pattern should execute. The following list describes a set of exemplary programmable test patterns that could be used to approximate the behavior and traffic intensity produced by a high-performance I/O device. Note that memory subsystems typically operate at a cacheline-size granularity. While the disclosed embodiments support any cacheline size, the following description illustrates a set of exemplary test patterns for a computing device with a 64-byte cacheline size and a memory/coherency interconnect that transfers 64-byte cachelines in four 16-byte chunks.</p>
<p id="p-0034" num="0036">Exemplary programmable I/O test patterns may include one or more of the following (and/or combinations of one or more of the following):
<ul id="ul0003" list-style="none">
    <li id="ul0003-0001" num="0000">
    <ul id="ul0004" list-style="none">
        <li id="ul0004-0001" num="0037">1. Aligned Writes with Revolving Data Patterns: In some embodiments, the DMA engine performs a continuous stream of DMA cacheline writes to 64-byte incrementing addresses, with the writes containing a rotating 48-byte data pattern created from eight 8-byte data CSRs. For instance, a testing program may configure the CSRs with a count of cacheline requests that should be issued, a starting address, and a 64-byte data pattern. After this configuration, the testing program may then set a &#x201c;go&#x201d; command bit in a CSR to tell the DMA engine to begin the operation. In one exemplary test pattern, the first write pulls 48 bytes of data from 8-byte data registers <b>0</b>, <b>1</b>, <b>2</b>, <b>3</b>, <b>4</b>, and <b>5</b>, and fills in the remaining 16 bytes of the cacheline with a fixed pattern. The next write uses the 48 bytes of data from registers <b>6</b>, <b>7</b>, <b>0</b>, <b>1</b>, <b>2</b>, and <b>3</b>, and fills in the remainder of the cacheline with the same fixed pattern. The third write starts with registers <b>4</b>, <b>5</b>, etc., and the rotation continues in this fashion. This revolving pattern creates different data patterns in consecutive cachelines, which can be useful for catching memory addressing and/or cache coherency bugs. When the request counter reaches the programmed request count, the DMA engine sets a &#x201c;done&#x201d; bit in a CSR.</li>
        <li id="ul0004-0002" num="0038">2. Aligned Reads with Revolving Data Patterns: Another test pattern is substantially similar to test pattern #<b>1</b> above, but issues DMA reads instead of writes. For instance, a testing program may instead write an expected target data pattern to the data CSRs, write the same target data to a memory region that will be read by the DMA reads, and then initiate the read operations. For each DMA read, the DMA engine compares (e.g., using the error checking module <b>108</b> illustrated in <figref idref="DRAWINGS">FIG. 1</figref>) the received data with the appropriate registers corresponding to the read and the 16-byte fixed value. If there is a mismatch, the DMA engine increments an error counter in a CSR. The DMA engine also increments the error counter if there is an error signaled in the read completion header or an uncorrectable ECC (error control coding) error in the read data. When the request counter reaches the programmed request count and all of the requested read data has been received (e.g., the DMA engine and memory subsystem may allow a number of reads to be outstanding at any time), the DMA engine sets the &#x201c;done&#x201d; bit in the CSR.</li>
        <li id="ul0004-0003" num="0039">3. Unaligned Writes with Revolving Data Patterns: In some embodiments, a test pattern may use substantially similar data patterns as in test pattern #<b>1</b> above, but increment addresses in a manner such that writes are partial and/or unaligned. More specifically, DMA writes need not begin and/or end on cacheline boundaries. Crossing cacheline boundaries and/or writing only part of a cacheline incur additional complexity in the memory and cache coherency subsystem. For instance, the memory and/or I/O systems may need to load two cachelines, merge them, write in the changed values, split the merged lines into two separate lines again, and then write the two modified cachelines. Hence, the DMA engine may be configured to increment the target address by other than 64 bytes with each subsequent write to initiate such more-complex read-modify-write behavior and test a wider range of use cases. Ideally a DMA engine would generate requests that exercise every possible read-modify-write case, but because this may involve substantial additional hardware, a DMA engine implementation may instead select an address increment that generates an interesting variety of test cases with relatively minimal additional logic/hardware (e.g., incrementing the address by 48 bytes with each subsequent write).</li>
        <li id="ul0004-0004" num="0040">4. Unaligned Reads with Revolving Data Patterns: Another test pattern issues DMA reads (substantially similar to test pattern #<b>2</b> above), but uses an address increment interval that causes partial reads (e.g., by incrementing the target address by 48 bytes with each subsequent read, as in test pattern #<b>3</b> above). Note that partial reads exercise slightly different logic than the read-modify-write functionality described above, and thus this test pattern exercises another portion of hardware in the memory subsystem.</li>
        <li id="ul0004-0005" num="0041">5. Alternating Aligned Writes and Reads: Some test patterns may perform alternating writes and reads to 64-byte incrementing addresses, and perform checking on the read return data. For instance, a substantially similar data pattern (e.g., a rotating 48-byte value from registers and a fixed value, as described in test pattern #<b>1</b> above) can be used, where: (1) the write is issued using the current data pattern; (2) a read is issued for the same address; (3) the read return data is checked to confirm that it matches the write data; and (4) the target address is then incremented by 64 bytes. In this pattern, a CSR storing the request counter may reflect the number of remaining pairs of writes and reads that need to be issued.</li>
        <li id="ul0004-0006" num="0042">6. Aligned Read Data Generated by a Memory Controller and Stored as an XOR Checksum: Some test patterns may target a scenario where a hardware device is tested in a chip tester or in a system that does not currently have a memory device installed. Instead, a memory controller in the device may be modified to include a mode in which it can generate read data in response to a set of aligned read requests. For instance, the memory controller may generate data in the formats described above (e.g., in test pattern #<b>2</b> above). Alternatively, in some embodiments, the memory controller may also be initialized with a seed value (e.g., by a testing program), and then generate a pseudo-random stream of data in response to read requests based on the seed value. In such embodiments, each set of received data might not be stored (and checked) in the data CSRs, but may instead be XOR'd (e.g., using the XOR trees <b>110</b> illustrated in <figref idref="DRAWINGS">FIG. 1</figref>) into one or more CSR registers. When the read sequence completes, the &#x201c;done&#x201d; bit is set in a CSR, and the final value in the target data CSR(s) is a deterministic (for the specific seed) &#x201c;checksum&#x201d; for the complete read operation. The testing program initiating the test pattern may compare an expected (e.g., pre-computed during simulation) value for the checksum with the checksum value stored in the target data CSR(s) to confirm that the read result is correct. Alternatively, the testing program may also transfer the expected value to another CSR, so that the DMA engine can perform the comparison. Note that the testing program needs to ensure that the target data CSR(s) are cleared prior to an XOR operation, to ensure that residual data stored in the target data CSR(s) does not lead to false errors. Note also that, as described above, the DMA engine also increments the error counter if there is an error signaled in the read completion header or an uncorrectable ECC error in the read data.</li>
        <li id="ul0004-0007" num="0043">7. Unaligned Read Data Generated by a Memory Controller and Stored as an XOR Checksum: Another set of test patterns may use the same modified memory controller described in test pattern #<b>6</b>, but use an address increment interval that causes partial reads (e.g., by incrementing the target address by 48 bytes with each subsequent read).</li>
        <li id="ul0004-0008" num="0044">8. Additional Ssage of XOR Checksum: Note that a number of the above test patterns may reduce the number of register comparisons by using the above-described XOR checksum technique. For instance, a variation of test pattern #<b>5</b> above may replace the described read-data checking, instead generating an XOR checksum for the read data that is checked at the end of the test.
<br/>
Note that while many of the above test patterns imply a fixed testing duration, in some embodiments the DMA engine may also be configured to support a &#x201c;continuous mode&#x201d; where, instead of using a transaction counter, the DMA engine performs continuous reads and/or writes until a testing program (or other mechanism) signals it to stop.
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0035" num="0045">Note also that in the above-described test-patterns, the DMA engine does not generate an interrupt when a test pattern completes. Instead, the DMA engine sets a CSR bit which is polled by the testing program to determine whether a sequence of operations has completed. Not using an interrupt can simplify the hardware logic and software overhead associated with the DMA engine, and facilitates using the DMA engine in situations where interrupts may not be available and/or supported (e.g., in a tester environment, or in a scenario where low-level software that does not support interrupts is being used to test the DMA paths of a device). However, in some embodiments, the DMA engine may also be configured to generate interrupts when a testing operation completes. For instance, in some embodiments the DMA engine may be co-located in a portion of the I/O subsystem that generates interrupts, in which case configuring the DMA engine to also generate interrupts may involve very little additional effort and/or overhead.</p>
<p id="p-0036" num="0046">In some embodiments, the number of outstanding transactions allowed by the DMA engine can be configured to range arbitrarily between the maximum number allowed by the I/O host interface logic (e.g., as limited by scoreboard resources in the I/O host interface) and a single request. A single-request scenario may be useful for certain debug scenarios or for focused memory subsystem testing. Note that the DMA engine can be configured to issue requests as closely spaced as possible, to mimic the traffic generated by a high-performance I/O device capable of achieving line rate for the given I/O link technology.</p>
<p id="p-0037" num="0047">In some embodiments, memory may be interleaved across multiple chips in a multi-processor system, where large (e.g., multi-gigabyte) blocks of memory are owned by individual chips. In such embodiments, the DMA engine and/or the test patterns may include more elaborate control over address increments. For instance, the DMA engine may include an address stride mechanism that facilitates jumping to addresses managed by other nodes (e.g., other processor chips). Providing more elaborate control over address increments and allowing transactions that jump from chip to chip facilitate testing a more elaborate and sophisticated memory architecture and coherency interconnect.</p>
<p id="p-0038" num="0048">In summary, embodiments of the present invention use a DMA engine that generates programmable sequences of reads and writes to exercise an I/O controller's host interface and DMA data paths to memory. This DMA engine can generate a set of memory accesses that exercise the full bandwidth of the I/O subsystem, and includes checking capabilities to validate data integrity and cache coherency. Such DMA engines are applicable to a broad range of computer architectures that include an I/O controller that performs DMA reads and writes to memory on behalf of I/O devices.</p>
<p id="h-0008" num="0000">Computing Environment</p>
<p id="p-0039" num="0049">In some embodiments of the present invention, techniques for using a DMA engine to automatically validate DMA data paths can be incorporated into a wide range of computing devices in a computing environment. For example, <figref idref="DRAWINGS">FIG. 3</figref> illustrates a computing environment <b>300</b> in accordance with an embodiment of the present invention. Computing environment <b>300</b> includes a number of computer systems, which can generally include any type of computer system based on a microprocessor, a mainframe computer, a digital signal processor, a portable computing device, a personal organizer, a device controller, or a computational engine within an appliance. More specifically, referring to <figref idref="DRAWINGS">FIG. 3</figref>, computing environment <b>300</b> includes clients <b>310</b>-<b>312</b>, users <b>320</b> and <b>321</b>, servers <b>330</b>-<b>350</b>, network <b>360</b>, database <b>370</b>, devices <b>380</b>, and appliance <b>390</b>.</p>
<p id="p-0040" num="0050">Clients <b>310</b>-<b>312</b> can include any node on a network that includes computational capability and includes a mechanism for communicating across the network. Additionally, clients <b>310</b>-<b>312</b> may comprise a tier in an n-tier application architecture, wherein clients <b>310</b>-<b>312</b> perform as servers (servicing requests from lower tiers or users), and wherein clients <b>310</b>-<b>312</b> perform as clients (forwarding the requests to a higher tier).</p>
<p id="p-0041" num="0051">Similarly, servers <b>330</b>-<b>350</b> can generally include any node on a network including a mechanism for servicing requests from a client for computational and/or data storage resources. Servers <b>330</b>-<b>350</b> can participate in an advanced computing cluster, or can act as stand-alone servers. For instance, computing environment <b>300</b> can include a large number of compute nodes that are organized into a computing cluster and/or server farm. In one embodiment of the present invention, server <b>340</b> is an online &#x201c;hot spare&#x201d; of server <b>350</b>.</p>
<p id="p-0042" num="0052">Users <b>320</b> and <b>321</b> can include: an individual; a group of individuals; an organization; a group of organizations; a computing system; a group of computing systems; or any other entity that can interact with computing environment <b>300</b>.</p>
<p id="p-0043" num="0053">Network <b>360</b> can include any type of wired or wireless communication channel capable of coupling together computing nodes. This includes, but is not limited to, a local area network, a wide area network, or a combination of networks. In one embodiment of the present invention, network <b>360</b> includes the Internet. In some embodiments of the present invention, network <b>360</b> includes phone and cellular phone networks.</p>
<p id="p-0044" num="0054">Database <b>370</b> can include any type of system for storing data in non-volatile storage. This includes, but is not limited to, systems based upon magnetic, optical, or magneto-optical storage devices, as well as storage devices based on flash memory and/or battery-backed up memory. Note that database <b>370</b> can be coupled: to a server (such as server <b>350</b>), to a client, or directly to a network. In some embodiments of the present invention, database <b>370</b> is used to store information that may later be stored in unused bits of a memory pointer. Alternatively, other entities in computing environment <b>300</b> may also store such data (e.g., servers <b>330</b>-<b>350</b>).</p>
<p id="p-0045" num="0055">Devices <b>380</b> can include any type of electronic device that can be coupled to a client, such as client <b>312</b>. This includes, but is not limited to, cell phones, personal digital assistants (PDAs), smartphones, personal music players (such as MP3 players), gaming systems, digital cameras, portable storage media, or any other device that can be coupled to the client. Note that, in some embodiments of the present invention, devices <b>380</b> can be coupled directly to network <b>360</b> and can function in the same manner as clients <b>310</b>-<b>312</b>.</p>
<p id="p-0046" num="0056">Appliance <b>390</b> can include any type of appliance that can be coupled to network <b>360</b>. This includes, but is not limited to, routers, switches, load balancers, network accelerators, and specialty processors. Appliance <b>390</b> may act as a gateway, a proxy, or a translator between server <b>340</b> and network <b>360</b>.</p>
<p id="p-0047" num="0057">Note that different embodiments of the present invention may use different system configurations, and are not limited to the system configuration illustrated in computing environment <b>300</b>. In general, any device that includes memory and I/O pathways may incorporate elements of the present invention.</p>
<p id="p-0048" num="0058">Previously described <figref idref="DRAWINGS">FIG. 1</figref> illustrates a DMA engine that can automatically validate DMA data paths and memory coherency. In some embodiments of the present invention, some or all aspects of DMA engine <b>102</b> can be implemented as dedicated hardware modules in computing device <b>100</b>. For example, computing device <b>100</b> can include one or more specialized circuits for performing the operations of the mechanisms. Alternatively, some or all of the operations of DMA engine <b>102</b> may be performed using general-purpose circuits in computing device <b>100</b> that are configured using processor instructions.</p>
<p id="p-0049" num="0059">Although <figref idref="DRAWINGS">FIG. 1</figref> illustrates DMA engine <b>102</b> as being included in I/O controller <b>120</b>, in alternative embodiments some or all of the described mechanisms can be either external or internal to I/O controller <b>120</b>. For instance, these mechanisms may be incorporated into hardware modules that can include, but are not limited to, processor chips, application-specific integrated circuit (ASIC) chips, field-programmable gate arrays (FPGAs), memory chips, and other programmable-logic devices now known or later developed.</p>
<p id="p-0050" num="0060">In these embodiments, when the external hardware modules are activated, the hardware modules perform the methods and processes included within the hardware modules. For example, in some embodiments of the present invention, the hardware module includes one or more dedicated circuits for performing the operations described below. As another example, in some embodiments of the present invention, the hardware module is a general-purpose computational circuit (e.g., a microprocessor or an ASIC), and when the hardware module is activated, the hardware module executes program code (e.g., BIOS, firmware, etc.) that configures the general-purpose circuits to perform the operations described above.</p>
<p id="p-0051" num="0061">The foregoing descriptions of various embodiments have been presented only for purposes of illustration and description. They are not intended to be exhaustive or to limit the present invention to the forms disclosed. Accordingly, many modifications and variations will be apparent to practitioners skilled in the art. Additionally, the above disclosure is not intended to limit the present invention. The scope of the present invention is defined by the appended claims.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A computer-implemented method for using a DMA engine to automatically validate DMA data paths for a computing device, the method comprising:
<claim-text>configuring the DMA engine to perform a programmable DMA operation that generates a sequence of memory accesses which validate the memory subsystem and DMA paths of the computing device;</claim-text>
<claim-text>initiating the programmable DMA operation; and</claim-text>
<claim-text>checking an output for the programmable DMA operation to confirm that the programmable DMA operation executed successfully,</claim-text>
<claim-text>wherein configuring and initiating the programmable DMA operation comprises configuring a set of registers for the DMA engine to specify an I/O test pattern.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The computer-implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the programmable DMA operation initiates a programmable sequence of accesses that generates sufficient data traffic to exercise the computing device's I/O interface and DMA data paths to memory to a desired level.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The computer-implemented method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein generating the sufficient data traffic comprises generating data access patterns that exercise the I/O bandwidth of the computing device to the desired level and confirm memory system coherency for the computing device.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The computer-implemented method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein exercising the I/O bandwidth of the computing device to the desired level facilitates:
<claim-text>detecting a mismatch between functional and performance capabilities of the computing device's I/O subsystem and the functional and performance capabilities of other I/O devices configured to communicate with the computing device; and</claim-text>
<claim-text>exposing latent bugs or throughput bottlenecks in the computing device's I/O subsystem.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The computer-implemented method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein traffic generated by the DMA engine is multiplexed with I/O traffic from one or more external I/O devices.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The computer-implemented method of <claim-ref idref="CLM-00002">claim 2</claim-ref>,
<claim-text>wherein the computing device is a processor; and</claim-text>
<claim-text>wherein the programmable DMA operation is initiated in a chip testing environment.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The computer-implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the I/O test pattern comprises at least one of the following:
<claim-text>a revolving pattern of read operations that load a known pattern of distinctive data values from the memory subsystem into a set of data registers in the DMA engine; and</claim-text>
<claim-text>a revolving pattern of write operations that generate a known pattern of distinctive data values in the DMA engine and transfer them to cachelines in the memory subsystem.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The computer-implemented method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the revolving pattern includes unaligned accesses that trigger read-modify-write sub-operations, thereby stressing the memory and cache coherency subsystem.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The computer-implemented method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the computing device does not include a memory device, wherein initiating the programmable DMA operation comprises:
<claim-text>sending a pseudo-random stream of data generated in a memory controller to the DMA engine;</claim-text>
<claim-text>XORing the pseudo-random stream of data into one or more data registers in the DMA engine; and</claim-text>
<claim-text>comparing the resulting checksum in the one or more data registers with a known checksum value for the pseudo-random stream of data.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The computer-implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein configuring the set of registers comprises configuring a set of control and status registers for the DMA engine.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The computer-implemented method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein configuring and initiating the programmable DMA operation further comprises configuring the set of control and status registers to specify a duration.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. A computing device configured to use a DMA engine to automatically validate DMA data paths, comprising:
<claim-text>a processor;</claim-text>
<claim-text>a memory subsystem; and</claim-text>
<claim-text>a DMA engine configured to generate a programmable sequence of memory accesses for a programmable DMA operation;</claim-text>
<claim-text>wherein the DMA engine is further configured to receive an initiating signal that initiates the programmable DMA operation;</claim-text>
<claim-text>wherein, upon completing the programmable DMA operation, the DMA engine is further configured to check an output of the programmable DMA operation to confirm that the programmable DMA operation executed successfully;</claim-text>
<claim-text>wherein configuring and initiating the programmable DMA operation comprises configuring a set of registers for the DMA engine to specify an I/O test pattern; and</claim-text>
<claim-text>wherein successfully executing the programmable DMA operation automatically validates the memory subsystem and DMA paths of the computing device.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The computing device of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the programmable DMA operation initiates a programmable sequence of accesses that generates sufficient data traffic to exercise the computing device's I/O interface and DMA data paths to memory to a desired level.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The computing device of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein generating the sufficient data traffic intensity comprises generating data access patterns that exercise the I/O bandwidth of the computing device to the desired level and confirm memory system coherency for the computing device.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The computing device of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein exercising the I/O bandwidth of the computing device to the desired level facilitates:
<claim-text>detecting a mismatch between functional and performance capabilities of the computing device's I/O subsystem and the functional and performance capabilities of external I/O devices configured to communicate with the computing device; and</claim-text>
<claim-text>exposing latent bugs or throughput bottlenecks in the computing device's I/O subsystem.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The computing device of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein traffic generated by the DMA engine is multiplexed with I/O traffic from one or more external I/O devices.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The computing device of <claim-ref idref="CLM-00013">claim 13</claim-ref>,
<claim-text>wherein the DMA engine is incorporated into the processor; and</claim-text>
<claim-text>wherein the programmable DMA operation is initiated in a chip testing environment.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The computing device of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the I/O test pattern comprises at least one of the following:
<claim-text>a revolving pattern of read operations that load a known pattern of distinctive data values from the memory subsystem into a set of data registers in the DMA engine; and</claim-text>
<claim-text>a revolving pattern of write operations that generate a known pattern of distinctive data values in the DMA engine and transfer them to cachelines in the memory subsystem.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The computing device of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the revolving pattern includes unaligned accesses that trigger read-modify-write sub-operations, thereby stressing the memory and cache coherency subsystem.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. A non-transitory computer-readable storage medium storing instructions that when executed by a computer cause the computer to perform a method for using a DMA engine to automatically validate DMA data paths for a computing device, the method comprising:
<claim-text>configuring the DMA engine to perform a programmable DMA operation that generates a sequence of memory accesses which validate the memory subsystem and DMA paths of the computing device;</claim-text>
<claim-text>initiating the programmable DMA operation; and</claim-text>
<claim-text>checking an output for the programmable DMA operation to confirm that the programmable DMA operation executed successfully,</claim-text>
<claim-text>wherein configuring and initiating the programmable DMA operation comprises configuring a set of registers for the DMA engine to specify an I/O test pattern. </claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
