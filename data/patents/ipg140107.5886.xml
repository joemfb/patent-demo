<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08626995-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08626995</doc-number>
<kind>B1</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13595616</doc-number>
<date>20120827</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<us-term-of-grant>
<disclaimer>
<text>This patent is subject to a terminal disclaimer.</text>
</disclaimer>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>13</main-group>
<subgroup>14</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>711103</main-classification>
<further-classification>711154</further-classification>
</classification-national>
<invention-title id="d2e51">Flexible sequence design architecture for solid state memory controller</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>7930470</doc-number>
<kind>B2</kind>
<name>Brittain et al.</name>
<date>20110400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>8255615</doc-number>
<kind>B1</kind>
<name>Yoon et al.</name>
<date>20120800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711103</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>2002/0004878</doc-number>
<kind>A1</kind>
<name>Norman</name>
<date>20020100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711103</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2004/0044933</doc-number>
<kind>A1</kind>
<name>Jeddeloh</name>
<date>20040300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714718</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>2004/0187122</doc-number>
<kind>A1</kind>
<name>Gosalia et al.</name>
<date>20040900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2005/0018527</doc-number>
<kind>A1</kind>
<name>Gorobets</name>
<date>20050100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2009/0077305</doc-number>
<kind>A1</kind>
<name>Shin et al.</name>
<date>20090300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2009/0089492</doc-number>
<kind>A1</kind>
<name>Yoon et al.</name>
<date>20090400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2009/0172264</doc-number>
<kind>A1</kind>
<name>Chung et al.</name>
<date>20090700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2010/0043009</doc-number>
<kind>A1</kind>
<name>Marchand</name>
<date>20100200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2010/0058003</doc-number>
<kind>A1</kind>
<name>Goto et al.</name>
<date>20100300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2011/0145474</doc-number>
<kind>A1</kind>
<name>Intrater</name>
<date>20110600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711103</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>WO</country>
<doc-number>WO0028418</doc-number>
<kind>A1</kind>
<date>20000500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>WO</country>
<doc-number>WO2005098623</doc-number>
<kind>A3</kind>
<date>20070300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00015">
<othercit>Wikipedia entry for &#x201c;IEEE 1394 Interface&#x201d;, [online] Retrieved from the Internet&#x3c;URL:http://en.wikipedia.org/IEEE<sub>&#x2014;</sub>1394<sub>&#x2014;</sub>interface&#x3e;, [retrieved on Sep. 24, 2009], 9 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00016">
<othercit>Lee, Chi Kong et al., Descriptor Scheduler, U.S. Appl. No. 13/331,749, filed Dec. 30, 2011, 41 pages, to be published by USPTO.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00017">
<othercit>Bai, Lingfei, Authorized Officer, The International Bureau of WIPO, International Preliminary Report on Patentability, PCT Application No. PCT/US2011/065913, Jul. 4, 2013, 10 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00018">
<othercit>Eich, Martine, Authorized Officer, European Patent Office, International Search Report and Written Opinion, PCT Application No. PCT/US2011/065913, Aug. 8, 2012, 14 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>20</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>4</number-of-drawing-sheets>
<number-of-figures>4</number-of-figures>
</figures>
<us-related-documents>
<continuation>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>12569089</doc-number>
<date>20090929</date>
</document-id>
<parent-grant-document>
<document-id>
<country>US</country>
<doc-number>8255615</doc-number>
</document-id>
</parent-grant-document>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>13595616</doc-number>
</document-id>
</child-doc>
</relation>
</continuation>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61143386</doc-number>
<date>20090108</date>
</document-id>
</us-provisional-application>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Yoon</last-name>
<first-name>Tony</first-name>
<address>
<city>Cupertino</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Shin</last-name>
<first-name>Hyunsuk</first-name>
<address>
<city>Santa Clara</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Lee</last-name>
<first-name>Chi-Kong</first-name>
<address>
<city>Fremont</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Yoon</last-name>
<first-name>Tony</first-name>
<address>
<city>Cupertino</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Shin</last-name>
<first-name>Hyunsuk</first-name>
<address>
<city>Santa Clara</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Lee</last-name>
<first-name>Chi-Kong</first-name>
<address>
<city>Fremont</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Marvell International Ltd.</orgname>
<role>03</role>
<address>
<city>Hamilton</city>
<country>BM</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Nguyen</last-name>
<first-name>Than</first-name>
<department>2188</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">In some implementations, a method includes receiving commands from a host device, sending the commands to one or more flash memory devices, receiving information associated with at least one of the commands from the one or more flash memory devices, and selectively sending the information to the host device based on whether one or more parameters in the at least one command include a request to receive the information from the one or more flash memory devices.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="138.94mm" wi="116.33mm" file="US08626995-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="187.79mm" wi="150.79mm" file="US08626995-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="215.90mm" wi="197.53mm" orientation="landscape" file="US08626995-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="164.08mm" wi="193.72mm" file="US08626995-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="159.77mm" wi="123.87mm" file="US08626995-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<p id="p-0002" num="0001">This application claims the benefit of U.S. patent application Ser. No. 12/569,089, entitled &#x201c;Flexible Sequence Design Architecture for Solid State Memory Controller,&#x201d; filed Sep. 29, 2009, issued on Aug. 28, 2012, as U.S. Pat. No. 8,255,615, which claims the benefit of U.S. Provisional Patent Application No. 61/143,386, entitled &#x201c;Flexible Sequence Design Architecture for Solid State Memory Controller,&#x201d; filed Jan. 8, 2009, the disclosures of which are hereby expressly incorporated herein. The subject matter of this application is generally related to memory management.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">TECHNICAL FIELD</heading>
<heading id="h-0002" level="1">Background</heading>
<p id="p-0003" num="0002">Many electronic devices include embedded systems to control the operation of the underlying devices and to provide enhanced functionality and operational flexibility. Typically, non-volatile memory is included as a portion of the embedded system to store operating system program code, issued commands and critical data for operating the embedded system. Recently, embedded systems have begun to use solid state memory as non-volatile memory (e.g., electrically Erasable Read Only Memory (EEPROM)). Solid state memory may be used to accelerate applications to increase data access time, and may be advantageously programmed or re-programmed to provide non-volatile storage of information.</p>
<p id="p-0004" num="0003">Conventionally, internal firmware may be used for issuing commands to non-volatile memory. This process typically requires that the firmware issue one command at a time to the non-volatile memory before a next command can be issued. Specifically, the firmware may send a status inquiry to a flash memory device to check on the status with respect to the command. If the command is still in the process of completion, the firmware waits to receive the result before a next command can be issued. In this conventional process, the firmware is on standby at all times. Because the firmware is on standby, the firmware cannot process other commands or requests until the processing of the previous command is complete. Additionally, the delay associated with the standby cycle to receive the status of a given command increases the latency of the associated device, the effect of which can become pronounced when numerous commands are in a queue.</p>
<heading id="h-0003" level="1">SUMMARY</heading>
<p id="p-0005" num="0004">Methods, systems and computer program products for sending one or more commands to one or more flash memory devices using a solid state controller and receiving information associated with the commands from the flash memory devices are described. In some implementations, the solid state controller includes a sequencer to forward the commands to the flash memory devices on behalf of the firmware.</p>
<p id="p-0006" num="0005">In some implementations, a method can be used that includes receiving a command from a host, identifying one or more parameters in the received command, transmitting the command to a flash memory device, receiving information associated with the command from the flash memory device, and communicating the received information to the host when the identified parameters include a request to receive the information from the flash memory device.</p>
<p id="p-0007" num="0006">In some implementations, a system can be used that includes a host to issue one or more commands, and a controller including a processor with embedded firmware to receive the issued commands; and a sequencer to send the received commands to one or more flash memory devices and to receive information associated with the commands from the flash memory devices, the sequencer configured to communicate the information to the host if transmission parameters in a respective command include a request to receive the information from the respective flash memory device.</p>
<p id="p-0008" num="0007">In some implementations, a computer-readable medium can be used that includes instructions stored thereon, which, when executed by a processor, causes the processor to perform operations including receiving a command from a host, identifying one or more parameters in the received command, transmitting the command to a flash memory device, receiving information associated with the command from the flash memory device, and communicating the received information to the host when the identified parameters include a request to receive the information from the flash memory device.</p>
<p id="p-0009" num="0008">The details of one or more embodiments of the invention are set forth in the accompanying drawings and the description below. Other features, objects, and advantages of the invention will be apparent from the description and drawings, and from the claims.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">DESCRIPTION OF DRAWINGS</heading>
<p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. 1</figref> shows a block diagram of an embodiment of a flash memory device.</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 2</figref> shows an embodiment of a solid state drive system that includes one or more flash memory devices shown in <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 3</figref> shows an embodiment of an internal command queue with multiple pending commands each containing T-bits of information.</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 4</figref> shows an embodiment of a process for determining whether to communicate information received from one or more flash memory devices to a host.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<p id="p-0014" num="0013">Like reference symbols in the various drawings indicate like elements.</p>
<heading id="h-0005" level="1">DETAILED DESCRIPTION</heading>
<heading id="h-0006" level="1">Flash Memory Overview</heading>
<p id="p-0015" num="0014">Flash memory devices, such as flash electrically erasable programmable read only memory (EEPROM), are used in jump drives, memory cards, and other nonvolatile memory applications associated with cameras, video games, computers, and other electronic devices. <figref idref="DRAWINGS">FIG. 1</figref> shows a block diagram of a flash memory device <b>100</b></p>
<p id="p-0016" num="0015">As shown in <figref idref="DRAWINGS">FIG. 1</figref>, the flash memory device <b>100</b> may be organized in bits. For example, the memory device <b>100</b> may be of the form of an array that includes 8-bits in depth <b>108</b>. The flash memory device <b>100</b> also may be organized in bytes. For example, the flash memory device <b>100</b> may include a portion <b>104</b> containing 2K bytes, and a portion <b>106</b> containing 64 bytes. The flash memory device <b>100</b> further may be organized into pages. For example, the flash memory device <b>100</b> may include 512K pages <b>110</b> A single page <b>112</b> may be organized into two portions which may include portion <b>104</b> and portion <b>106</b> as a first portion, and a second portion <b>116</b>. The second portion <b>116</b> may correspond to an eight-bit wide data input/output (I/O) path (e.g., I/O [0]-I/O [7]). Even further, the flash memory device <b>100</b> may be arranged in blocks. For example, the flash memory device <b>100</b> may include a block <b>102</b>, which equals to 64 pages. The block may be sized to store one sector of user data and overhead data including information such as, without limitation, an error correction code (ECC) associated with the user data, a history of use of the block, defects and other physical information of the memory cell. The flash memory device <b>100</b> may be formed using the foregoing bits, bytes, pages and blocks.</p>
<p id="p-0017" num="0016">In some implementations, the flash memory device may be a &#x201c;NAND&#x201d; type flash memory. NAND flash memory generally has faster erase and program times, higher density, lower cost per bit, and more endurance than, for example, NOR-type flash memory. NAND flash memory may utilize series strings of more than two memory cells, such as 16 or 32, connected along with one or more select transistors between individual bit lines and a reference potential to form columns of cells. Word lines may extend across cells within such columns. An individual cell within a column may be read and verified during programming by causing the remaining cells in the string to be turned on so that the current flowing through a string may be dependent upon the level of charge stored in the addressed cell.</p>
<p id="p-0018" num="0017">A NAND flash I/O interface may be used for communicating with a NAND memory, and may allow only sequential access to data stored in the NAND flash memory. The NAND flash I/O interface may include multiple pins each corresponding to a specific function. While only NAND flash memory has been described, it should be noted that other memory types also may be used, such as, without limitation, NOR flash EEPROM, AND flash EEPROM, DiNOR flash EEPROM, serial flash EEPROM, DRAM, SRAM, ROM, EPROM, FRAM, MRAM, and PCRAM.</p>
<heading id="h-0007" level="1">Solid State Drive System</heading>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 2</figref> shows an embodiment of a solid state drive system <b>200</b> that includes one or more flash memory devices <b>100</b>, such as that shown in <figref idref="DRAWINGS">FIG. 1</figref>. As shown in <figref idref="DRAWINGS">FIG. 2</figref>, the system <b>200</b> includes a host <b>202</b> that communicates with a solid state drive <b>204</b> through a host interface <b>210</b>. The host interface <b>210</b>, in some implementations, may include a Serial Advanced Technology Attachment (SATA) interface or a Parallel Advanced Technology Attachment (PATA) interface. A SATA interface or PATA interface may be used to convert serial or parallel data into parallel or serial data, respectively. For example, if the host interface <b>210</b> includes a SATA interface, then the SATA interface may receive serial data transferred from the host <b>202</b> through a bus <b>203</b> (e.g., a SATA bus), and convert the received serial data into parallel data. In other implementations, the host interface <b>210</b> may include a hybrid interface. In these implementations, the hybrid interface may be used in conjunction with, for example, a serial interface.</p>
<p id="p-0020" num="0019">The host interface <b>210</b>, in some implementations, may include one or more registers in which operating commands and addresses from the host <b>202</b> may be temporarily stored. The host interface <b>210</b> may communicate a write or read operation to a solid state controller <b>208</b> in response to the stored information in the register(s).</p>
<p id="p-0021" num="0020">In some implementations, the solid state drive <b>204</b> may support one or more channels (e.g., eight channels), and each channel may be configured to receive one or more control signals (e.g., four chip enable signals) to accommodate more than one command pending in an internal command queue <b>217</b>, as will be discussed in greater detail below.</p>
<heading id="h-0008" level="1">Flash Memory Device</heading>
<p id="p-0022" num="0021">Each flash memory device <b>206</b>, in some implementations, may include a nonvolatile memory (e.g., a single-level flash memory or a multi-level flash memory). In some implementations, the nonvolatile memory may include a NAND-type flash memory module. A NAND-type flash memory module may include a command/address/data multiplexed interface such that commands, data, and addresses may be provided through corresponding input/output pins.</p>
<p id="p-0023" num="0022">In some implementations, each flash memory device may be connected to a channel <b>226</b>. Each channel may support, for example, one or more input and output lines, chip select signal lines, chip enable signal lines and the like. The channel also may support other signal lines such as write enable, read enable, read/busy output, and reset signal lines. In some implementations, the flash memory devices <b>206</b><i>a</i>-<b>206</b><i>d </i>may share a common channel. In other implementations, to increase the degree of parallelism, each flash memory device may have its own channel connected to the solid state drive <b>204</b>. For example, flash memory device <b>206</b><i>a </i>may be connected to the solid state drive <b>204</b> using channel <b>226</b><i>a</i>; flash memory device <b>206</b><i>b </i>may be connected to the solid state drive <b>204</b> using channel <b>226</b><i>b</i>; flash memory device <b>206</b><i>c </i>may be connected to the solid state drive <b>204</b> using channel <b>226</b><i>c</i>; and, flash memory device <b>206</b><i>d </i>may be connected to the solid state drive <b>204</b> using channel <b>226</b><i>d. </i></p>
<p id="p-0024" num="0023">In some implementations, the flash memory devices <b>206</b><i>a</i>-<b>206</b><i>d </i>may be detachable. In some implementations, the flash memory devices <b>206</b><i>a</i>-<b>206</b><i>d </i>may be connected to the solid state drive <b>204</b> using standard connectors. Examples of standard connectors may include, without limitation, SATA, USB (Universal Serial Bus), SCSI (Small Computer System Interface), PCMCIA (Personal Computer Memory Card International Association), and IEEE-1394 (Firewire).</p>
<p id="p-0025" num="0024">In some implementations, each flash memory device <b>206</b> may include one or more solid state storage elements arranged in a bank. A solid state storage element may be partitioned into pages. In some implementations, a solid state storage element may have a capacity of 2000 bytes (i.e., one page). A solid state storage element, in some implementations, may include two registers to provide a total capacity of 4000 bytes (i.e., 4 kB).</p>
<p id="p-0026" num="0025">In some implementations, each flash memory device <b>206</b> also may include one or more banks each being selected using a chip enable signal or chip select signal. The chip enable or chip select signal may select one or more solid state storage elements in response to a host command.</p>
<p id="p-0027" num="0026">In some implementations, each solid state storage element may include one or more single-level cell (&#x201c;SLC&#x201d;) devices. In some implementations, each sold state storage element may include one or more multi-level cell (&#x201c;MLC&#x201d;) devices. The SLC or MLC devices may be selected using a chip enable signal or chip select signal, which may be generated by the controller <b>208</b> using a combination of control and address information received from the host <b>202</b>.</p>
<p id="p-0028" num="0027">Where multiple banks are used, in some implementations, the solid state drive <b>208</b> may access more than one bank in a same flash memory device at the same time. In some implementations, the solid state drive <b>208</b> may access different banks in different flash memory devices at the same time. The capability to access more than one bank allows the solid state drive <b>204</b> to fully utilize the available resources and channels <b>226</b><i>a</i>-<b>226</b><i>d </i>to increase the overall performance of the solid state drive <b>204</b>. Furthermore, where the flash memory devices <b>206</b><i>a</i>-<b>206</b><i>d </i>share a same memory input/output line and control signal (e.g., chip enable signal), the number of pins of the controller <b>208</b> may be reduced to further minimize the cost for manufacturing the solid state drive <b>204</b>.</p>
<heading id="h-0009" level="1">Solid State Controller</heading>
<p id="p-0029" num="0028">The solid state controller <b>208</b> receives one or more service requests or commands (e.g., read and program requests). The controller <b>208</b> may be configured to handle any command, status, or control request for access to the flash memory devices <b>206</b><i>a</i>-<b>206</b><i>d</i>. For example, the controller <b>208</b> may be configured to manage and control storage and retrieval of data in the flash memory devices <b>206</b><i>a</i>-<b>206</b><i>d. </i></p>
<p id="p-0030" num="0029">In some implementations, the controller <b>208</b> may be a part of a microcomputer system under the control of a microprocessor (not shown). The controller <b>208</b> may control the flow of commands and data between the host <b>202</b> and the solid state drive <b>204</b>. In some implementations, the controller <b>208</b> may include read-only memory (ROM), random-access memory (RAM) and other internal circuits. The controller <b>208</b>, in some implementations, may be configured to support various functions associated with the flash memory devices <b>206</b>, such as, without limitation, diagnosing the flash memory devices <b>206</b>, sending commands (e.g., activation, read, program, erase, pre-charge and refresh commands) to the flash memory devices <b>206</b>, and receiving status from the flash memory devices <b>206</b>. The controller <b>208</b> may be formed on a different chip as the flash memory devices <b>206</b><i>a</i>-<b>206</b><i>d </i>(e.g., formed on a same chip as the solid state drive <b>204</b>) or on a same chip.</p>
<p id="p-0031" num="0030">As shown in <figref idref="DRAWINGS">FIG. 2</figref>, the controller <b>208</b> may include an error checking code (ECC) <b>212</b>, interface logic <b>214</b>, a sequencer <b>216</b> and a first-in-first-out (FIFO) <b>218</b>. In some implementations, the solid state drive <b>204</b> may include a central processor unit (CPU) <b>223</b> with embedded firmware <b>224</b> by which the controller <b>208</b> may be controlled. The CPU <b>223</b> may include a microprocessor, a signal processor (e.g., a digital signal processor) or microcontroller. In some implementations, the CPU <b>223</b> with the embedded firmware <b>224</b> may reside outside of the solid state drive <b>204</b>.</p>
<p id="p-0032" num="0031">In some implementations, the solid state drive <b>204</b> also may be connected to a hard disk drive (HDD) controller <b>220</b> for controlling one or more hard disks <b>222</b>. In some implementations, the HDD controller <b>220</b> may be used in conjunction with the controller <b>208</b> to manage and control the flash memory devices and the hard disks <b>222</b> to maximize the storage capacity of the solid state system <b>200</b>.</p>
<heading id="h-0010" level="1">Interface Logic Module</heading>
<p id="p-0033" num="0032">The interface logic <b>214</b> may send commands, address and control information from the controller <b>208</b> to the flash memory devices <b>206</b><i>a</i>-<b>206</b><i>d</i>. The interface logic <b>214</b> also may relay command status from the flash memory devices <b>206</b><i>a</i>-<b>206</b><i>d </i>to the controller <b>208</b>.</p>
<p id="p-0034" num="0033">In some implementations, the interface logic <b>214</b> may be configured to support NAND-type flash memory and NOR-type flash memory. The interface logic <b>214</b> may communicate with the flash memory devices <b>206</b><i>a</i>-<b>206</b><i>d </i>through channels <b>226</b><i>a</i>-<b>226</b><i>d</i>. Where different types of flash memory devices are used (e.g., NAND memories and NOR memories), channels <b>226</b><i>a</i>-<b>226</b><i>d </i>may be connected to the same or different types of memories. In some implementations, when read or program operations are carried out to different channels, the interface logic <b>214</b> may selectively perform, for example, software and hardware interleave operations. In other implementations, the interface logic <b>214</b> also can handle read and program operations for different channels concurrently.</p>
<p id="p-0035" num="0034">In some implementations, the interface logic <b>214</b> may include, without limitation, one or more data ports, signal detectors, encoders, decoders, interleavers, de-interleavers, comparators and the like. The interface logic <b>214</b> may serve as an interface between the controller <b>208</b> and the flash memory devices <b>206</b><i>a</i>-<b>206</b><i>d </i>for clocks, data masks, strobes, rank selects, memory address, memory commands, and read and program data. Where SLC or MLC devices (e.g., to store block and page buffers of data) are included in the flash memory devices <b>206</b><i>a</i>-<b>206</b><i>d</i>, the interface logic <b>214</b> may provide a lower-level memory interface for communicating with the SLC/MLC devices.</p>
<heading id="h-0011" level="1">FIFO</heading>
<p id="p-0036" num="0035">The FIFO <b>218</b> may operate using a first-in-first-out scheme, and may be configured to output data in a same order that is received (e.g., to output data that is received first). In some implementations, the FIFO <b>218</b> may include one or more registers each with a capacity of more than a virtual page of data segments. The FIFO <b>218</b> may be used to temporarily store data and commands that have not been processed while being transferred, for example, to the sequencer <b>216</b> and the flash memory devices <b>206</b> for execution. In some implementations, the EEC <b>212</b> and/or the interface logic <b>214</b> can utilize the FIFO <b>218</b> to buffer data transfer between the host <b>202</b> and the flash memory devices <b>206</b>, and to provide error correction for data received from or transmitted to the flash memory devices <b>206</b>. In some implementations, the FIFO <b>218</b> also can include an internal command queue (e.g., separate from internal command queue <b>217</b>) through which the sequencer <b>216</b> can store commands or control signals for commanding or controlling the flash memory devices <b>206</b>. The same or different internal command queue also can be used to store header and/or internal data between the embedded firmware (e.g., firmware <b>224</b>) and the flash memory devices <b>206</b>. In some implementations, the FIFO <b>218</b> may generate data and control signals for transferring data to and receiving data from the controller <b>208</b> through, for example, an internal command queue <b>217</b> (as will be discussed below in greater detail) of the sequencer <b>216</b>. The FIFO <b>218</b> may determine the transfer direction of the data stored in the internal command queue <b>217</b> based on, for example, commands from the host, the sequencer <b>204</b> or the flash memory devices <b>206</b><i>a</i>-<b>206</b><i>d. </i></p>
<p id="p-0037" num="0036">In some implementations, data processed by the ECC <b>212</b> may be stored in the FIFO <b>218</b>. In some implementations, the ECC <b>212</b> may release each data block stored in the FIFO <b>218</b> for code correction. Specifically, when the ECC <b>212</b> identifies errors in the data, correction may be applied to the data. The corrected data block may then be transferred from the FIFO <b>218</b> to a flash memory device selected by the sequencer <b>216</b> based on the command received from the host <b>202</b> after the ECC process on the data block is complete.</p>
<heading id="h-0012" level="1">Error Correction Code</heading>
<p id="p-0038" num="0037">The flash memory devices <b>206</b><i>a</i>-<b>206</b><i>d </i>are susceptible to defects and failures. A number of factors may give rise to such errors, including, for example, the gradual shifting of the threshold level of the memory states as a result of ambient conditions, stress from normal operations including programming, erasure, read operations and the like. Other errors may be contributed by, for example, a failing memory bit or bits in a flash device, faulty transmission to and from a flash device and the like. Thus, to prevent errors during operation, in some implementations, ECC <b>212</b> may be included in the controller <b>208</b> to ensure data integrity of the solid state drive system <b>200</b>. The ECC <b>212</b> may be configured to detect and correct data failures caused by, for example, soft errors and hard errors at read, erase or program time</p>
<p id="p-0039" num="0038">In some implementations, the ECC <b>212</b> may be used for checking and correcting errors associated with the data and commands stored in the internal command queue <b>217</b> of the sequencer <b>216</b> prior to being sent to the flash memory devices <b>206</b>. Additionally, the ECC <b>212</b> also may be used for checking and correcting errors associated with the data transmitted to and received from the flash memory devices <b>206</b>. For example, when data (e.g., a status command) is transferred from a flash memory device to the controller <b>208</b>, the ECC <b>212</b> may execute an error detecting operation to ensure the integrity of the transferred data. If an error is detected among the transferred data, the ECC <b>212</b> may promptly request error correction from the controller <b>208</b> and subsequently perform data correction. The corrected data may then be sent to the sequencer <b>216</b> for further processing.</p>
<p id="p-0040" num="0039">As an example operation, a read request may be queued by the sequencer <b>216</b> (as will be discussed in greater detail below) and sent to a flash memory device <b>206</b>. The data may then be returned from the flash memory device <b>206</b> to the ECC <b>212</b>. The ECC <b>212</b> may check the returned data for errors. If an error is detected but the error correction is disabled, then an error notification may be sent to the sequencer <b>216</b> in place of the data expected. The error notification may include an error report indicating that a data error has occurred. The failed location may then be disabled by moving the address of that location to a failed map. The routine may resume and wait for a next request. If the ECC <b>212</b> detects an error and the correction function is enabled, then the failed data may be corrected, verified and forwarded to the sequencer <b>216</b>.</p>
<p id="p-0041" num="0040">In some implementations, the controller <b>204</b> may generate redundant bits (e.g., parity bits) that may be appended to the data sectors during program operations. For example, a 512-byte data sector may include 16 bytes of ECC data appended, resulting in a 528-byte page. During read operations, the redundant data represented in the 16 bytes of ECC data may be utilized to detect and correct errors in the data read out from the flash memory device <b>206</b>.</p>
<p id="p-0042" num="0041">In some implementations, the ECC <b>212</b> also may be configured to detect and correct errors in the data flowing between the host <b>202</b> and the solid state device <b>204</b>. The ECC <b>212</b> may implement an error correction scheme including cyclic redundancy check (CRC), and parity and forward error correction (FEC) when checking and correcting errors.</p>
<heading id="h-0013" level="1">Sequencer</heading>
<p id="p-0043" num="0042">In some implementations, the sequencer <b>216</b> may be used to carry out the commands on behalf of the firmware <b>224</b>. The sequencer <b>216</b> may control, for example, an access process of writing to and or reading from one or more data sectors of the flash memory devices <b>206</b><i>a</i>-<b>206</b><i>d. </i></p>
<p id="p-0044" num="0043">In some implementations, the sequencer <b>216</b> may store the commands received from the firmware <b>224</b> (or the host <b>202</b>) in an internal command queue <b>217</b>. The internal command queue <b>217</b> allows the controller <b>208</b> to perform multiple-block data access. In some implementations, the flash memory device (e.g., flash memory device <b>206</b><i>a</i>-<i>d</i>) includes a 512-byte page register built-in such that when data write to the flash memory device is performed, the data is written to the page register first before being written to the flash memory cell. Conventional flash controllers control the flash memory access cycles by transferring one single block (512 bytes) of data to the page register of the flash memory device at a time. Thus, no other access to the flash memory device is allowed once the 512-byte page register is filled. Consequently, the conventional flash controllers, which use a single-block data access methodology, limit the performance of storing and retrieving data to and from the flash memory devices.</p>
<p id="p-0045" num="0044">The internal command queue <b>217</b> may store one or more pending commands. In some implementations, the internal command queue <b>217</b> may have a capacity suited to store thirty-two commands each representing one page of information. The host <b>202</b> may send multiple commands each containing unique data simultaneously to the controller <b>208</b>, and the controller <b>208</b> may store such commands in the internal command queue <b>217</b> for simultaneous or sequential transmission to the flash memory devices <b>206</b><i>a</i>-<b>206</b><i>d</i>. Unlike the conventional single-block data-transfer controllers which transfer a single data block at a time, the controller <b>208</b>, which utilizes the sequencer <b>216</b> and the internal command queue <b>217</b>, allows more than one command to be sent to the flash memory devices <b>206</b><i>a</i>-<b>206</b><i>d</i>, thus improving the data transfer performance significantly.</p>
<p id="p-0046" num="0045">As an example, the host <b>202</b> may issue a read command, and send the read command to the sequencer <b>216</b>. When the sequencer <b>216</b> receives the read command, the sequencer <b>216</b> may place the command in the internal command queue <b>217</b>. The sequencer <b>216</b> then may identify the flash memory device to which the command is to be sent, and the address of the identified flash memory device at which data is to be read. After verifying that the identified flash memory device may be accessed at the address, the sequencer <b>216</b> may gate the address and the command to the identified flash memory device by selecting the identified flash memory device using a chip enable (or chip select) signal, and sending the address and the command out to the selected flash memory device. Upon receiving the read command (or a control signal indicating the read command) from the sequencer <b>216</b>, the identified flash memory device may process the read command, and subsequently send serial data or command status information back to the sequencer <b>216</b>. This process may continue until the last bit of the addressed data has been transmitted by the identified flash device and received by the sequencer <b>216</b>.</p>
<p id="p-0047" num="0046">In some implementations, the data received from the identified flash memory device may first be stored in the FIFO <b>218</b>. If the data transmitted by the identified flash memory device contains a bad bit, the bad bit/bits may be replaced by a corrected bit/bits before sending the data to the sequencer <b>216</b>. Alternatively, the data received from the identified flash memory device may be sent to the sequencer <b>216</b>, after which the data is forwarded to the FIFO <b>218</b> to be sent out to the host <b>202</b>. While the data waits in the FIFO <b>218</b>, ECC processing may be performed on the data. After the command or sets of commands have been executed, the sequencer <b>216</b> may load a next command or set of commands in the internal command queue <b>217</b> for processing.</p>
<p id="p-0048" num="0047">Similarly, when the host <b>202</b> issues a program command, the sequencer <b>216</b> may fetch the write data from the firmware <b>224</b> (or from the host <b>202</b>). The firmware <b>224</b> may be embedded in the CPU <b>223</b> of the solid state drive <b>204</b> used for controlling the controller <b>208</b>. Upon receipt of the data, the sequencer <b>216</b> may request the ECC <b>212</b> to perform an ECC error correction procedure. This allows errors that arise during transmission to be detected and corrected prior to being written into the identified flash memory device. The write data may be stored in the FIFO <b>218</b> while an ECC error correction procedure is performed, and subsequently routed to the designated flash device after correction.</p>
<p id="p-0049" num="0048">In some implementations, data (e.g., which may include command, address and control information) may be formatted into serial data prior to being sent to the flash memory devices <b>206</b><i>a</i>-<b>206</b><i>d</i>. A pipeline architecture also may be used to provide efficient throughput as the data is gated from interface logic <b>214</b> to the identified flash memory device. The data gated out of the interface logic <b>214</b>, in some implementations, may first be verified prior to being sent to the identified flash memory device. After the data has been loaded into the identified flash memory device, the flash memory device may process the data including the command.</p>
<p id="p-0050" num="0049">In some implementations, the sequencer <b>216</b> may execute each command on a rolling basis (e.g., execute each command as it is received). In other implementations, the sequencer <b>216</b> may determine whether the internal command queue <b>217</b> is full or nearly full (e.g., includes a predetermined number of commands). In some implementations, when the internal command queue <b>217</b> is full or nearly full, the sequencer <b>216</b> may execute the commands simultaneously (e.g., all of the pending commands currently stored in the command queue <b>217</b> simultaneously).</p>
<p id="p-0051" num="0050">For example, assuming that the internal command queue <b>217</b> can accommodate thirty-two commands, the sequencer <b>216</b> may monitor the internal command queue <b>217</b> to determine whether there are thirty two pending commands stored in the internal command queue <b>217</b>. If there are thirty two pending commands, the sequencer <b>216</b> may execute all thirty two commands at the same time, and report the status of each executed command to the firmware <b>224</b> as the request associated with the command is being fulfilled. In some implementations, the sequencer <b>216</b> can issue one or more commands or control signals to the interface logic <b>214</b> such that the channels <b>226</b><i>a</i>-<b>226</b><i>d </i>can begin the data transfer process simultaneously.</p>
<p id="p-0052" num="0051">Upon receiving one or more commands from the sequencer <b>216</b>, the selected flash devices may perform the requested operations (e.g., read or program operations) associated with the commands. In some implementations, the firmware <b>224</b> need not poll the status of a command as the command is being carried out. In these implementations, the flash memory devices <b>206</b><i>a</i>-<b>206</b><i>d </i>may forward command status information to the sequencer <b>216</b> through the interface logic <b>214</b>, which may trigger an interrupt routine. When the interrupt routine is triggered, an interrupt (or other form of a message) may be sent to the firmware <b>224</b> to notify the firmware <b>224</b> of the command status information.</p>
<p id="p-0053" num="0052">In some implementations, the sequencer <b>216</b> may report the status of a command to the firmware <b>224</b> in real time as the status is being sent from the corresponding flash memory device. In some implementations, the sequencer <b>216</b> may be configured so that the sequencer <b>216</b> reports the command status only when a specific condition is met. The specific condition may include an error detection, an error correction, a program delay and the like. In some implementations, the specific condition may depend on the information supplied by a T-bit in the command. <figref idref="DRAWINGS">FIG. 3</figref> illustrates an example internal command queue <b>300</b> with multiple pending commands each containing T-bit information.</p>
<p id="p-0054" num="0053">As shown in <figref idref="DRAWINGS">FIG. 3</figref>, a command <b>302</b> is currently stored in the internal command queue <b>300</b> to be executed. The command <b>302</b> may be received, for example, from the host <b>202</b>. Each command may include information associated with a command number field <b>308</b>, a command type field <b>310</b>, a channel field <b>318</b>, a chip enable field <b>312</b>, a T-Bit field <b>314</b> and a memory field <b>316</b>.</p>
<p id="p-0055" num="0054">The command number field <b>308</b> may be used to indicate the number of commands currently stored in the internal command queue <b>300</b>. The command type field <b>310</b> may indicate the type of command associated with each command. For example, command <b>302</b> has a command type &#x201c;read&#x201d;, which indicates that command <b>302</b> is a read command. As another example, command <b>304</b> has a command type &#x201c;program&#x201d;, which indicates that command <b>304</b> is a program command.</p>
<p id="p-0056" num="0055">The channel field <b>318</b> may define the channel (e.g., one of channels <b>226</b><i>a</i>-<b>226</b><i>d</i>) through which the corresponding command is to be sent. As an example, command <b>302</b> is to be sent to the 3<sup>rd </sup>flash memory device (as indicated in the memory field <b>316</b>) in an array of flash memory devices through channel &#x201c;1&#x201d;. As another example, command <b>304</b> is to be sent to the 6<sup>th </sup>flash memory device through channel &#x201c;2&#x201d;. As yet another example, command <b>306</b> is to be sent to the 7<sup>th </sup>flash memory device through channel &#x201c;3&#x201d;.</p>
<p id="p-0057" num="0056">In some implementations, the firmware <b>224</b> may define the T-bit information of the T-bit field <b>314</b> for each command. In some implementations, the T-bit information serves as an indicator as to whether an interrupt routine for notifying the firmware <b>224</b> of command status information is to be triggered. For example, as shown in <figref idref="DRAWINGS">FIG. 3</figref>, the firmware <b>224</b> may designate the T-bit field <b>314</b> of command <b>306</b> as &#x201c;1&#x201d;, indicating that the sequencer <b>216</b> is to send an interrupt to the firmware <b>224</b> when the status associated with command <b>306</b> is available from the 7<sup>th </sup>flash memory device. As another example, the firmware <b>224</b> may designate the T-bit field <b>314</b> of command <b>302</b> as &#x201c;0&#x201d;, indicating that the sequencer <b>216</b> need not send an interrupt to the firmware <b>224</b> when the status associated with command <b>302</b> is available from the 3<sup>rd </sup>flash memory device. Similarly, the firmware <b>224</b> may designate the T-bit field <b>314</b> of command <b>304</b> as &#x201c;0&#x201d;, indicating that the sequencer <b>216</b> need not send an interrupt to the firmware <b>224</b> when the status associated with command <b>304</b> is available from the 6<sup>th </sup>flash memory device. The T-bit field <b>314</b>, in general, may provide the firmware <b>224</b> the flexibility to define when and how often the firmware <b>224</b> is to be called upon so that unnecessary computing resources and latency associated with receiving status information may be reduced to a minimum.</p>
<p id="p-0058" num="0057">In some implementations, the firmware <b>224</b> may provide the T-bit information together with the commands received from the host <b>202</b> to the sequencer <b>216</b>. In other implementations, the firmware <b>224</b> may provide the T-bit information and the commands received from the host <b>202</b> to the sequencer <b>216</b> separately.</p>
<p id="p-0059" num="0058">The sequencer <b>216</b> may facilitate the overall processing of the pending commands including, without limitation, storing one or more pending commands received from the firmware <b>224</b>, transferring a pending command to a corresponding flash memory device, coordinating the status polling of the command as the command is being processed by the flash memory device, and reporting the status of the command to the firmware <b>224</b>.</p>
<p id="p-0060" num="0059">In some implementations, the solid state drive <b>204</b> (and/or the host <b>202</b>) may be mounted on a system on-chip (SOC). The SOC, in these implementations, may be fabricated using, for example, a semiconductor process. The SOC may include an embedded process system (e.g., an embedded CPU) separate from that in the solid state drive <b>204</b>. The SOC also may include a SRAM, system logic, cache memory and cache controller for processing program code and data. The program code and data associated with the embedded process system may be stored in the flash device <b>206</b>, and communicated to the SOC through, for example, an interface. This interface may be used by a translator (not shown) for translating information flowing between the interface and the internal bus structure of the SOC. Control signals may flow from the SOC to the flash memory devices <b>206</b><i>a</i>-<b>206</b><i>d </i>while instructions and data may flow from the flash memory devices <b>206</b><i>a</i>-<b>206</b><i>d </i>to the SOC during, for example, read operations. Of course, instructions and data also may flow towards the flash memory devices <b>206</b><i>a</i>-<b>206</b><i>d </i>during, for example, erase operations.</p>
<heading id="h-0014" level="1">Example Process</heading>
<p id="p-0061" num="0060"><figref idref="DRAWINGS">FIG. 4</figref> is a flow diagram of an embodiment of a process <b>400</b> for determining whether to communicate information received from one or more flash memory devices to a host. The process <b>400</b> may be performed, for example, by the solid state system <b>200</b>, and for clarity of presentation, the description that follows uses that system as the basis of examples for describing the process <b>400</b>. However, another system, or combination of systems, may be used to perform the process <b>400</b>.</p>
<p id="p-0062" num="0061">Process <b>400</b> begins at <b>402</b> with receiving a command from a host. The command may include a read, erase or program service request. Upon receiving the command from the host, at <b>404</b>, one or more parameters associated with the received command may be identified. In some implementations, the identified parameters may be stored in an internal command queue so that upon receiving information (e.g., status information) from the flash memory device to which the command is to be sent, the stored parameters may be retrieved and examined to determine whether the information received from the flash memory device should be forwarded to the host.</p>
<p id="p-0063" num="0062">At <b>406</b>, the command may be transmitted to a flash memory device. Where more than one flash memory devices are provided, the command may include information indicating a particular flash memory device to which the command is to be sent. Once the flash memory device has received the command, the command is processed. In some implementations, the flash memory device may generate information such as status information regarding the execution progress, and forward the information to the host.</p>
<p id="p-0064" num="0063">In some implementations, the flash memory device may send the information to a sequencer (e.g., sequencer <b>216</b>) instead of the host. At <b>408</b>, after receiving the information associated with the command from the flash memory device, at <b>410</b>, the sequencer may determine whether to communicate the received information to the host. In some implementations, the determination may be based whether the command sent to the flash memory device contains a request from the host to receive the information (e.g., by referencing to the identified parameters stored in the internal command queue). If a request is not included, then the sequencer may forego relaying the information to the host. Conversely, if a request is included, the sequencer may send an interrupt to the host notifying the host of the information received from the flash memory device.</p>
<p id="p-0065" num="0064">Operations <b>402</b>-<b>410</b> may be performed in the order listed, in parallel (e.g., by the same or a different process, substantially or otherwise non-serially), or in reverse order to achieve the same result. In other implementations, operations <b>402</b>-<b>410</b> may be performed out of the order shown. For example, one or more parameters from the received command may be identified at <b>404</b> after receiving information associated with the command from the flash memory device at <b>408</b>.</p>
<p id="p-0066" num="0065">The features described can be implemented in digital electronic circuitry, or in computer hardware, firmware, software, or in combinations of them. The apparatus can be implemented in a computer program product tangibly embodied in an information carrier, e.g., in a machine-readable storage device or in a propagated signal, for execution by a programmable processor; and method steps can be performed by a programmable processor executing a program of instructions to perform functions of the described implementations by operating on input data and generating output. The described features can be implemented advantageously in one or more computer programs that are executable on a programmable system including at least one programmable processor coupled to receive data and instructions from, and to transmit data and instructions to, a data storage system, at least one input device, and at least one output device. A computer program is a set of instructions that can be used, directly or indirectly, in a computer to perform a certain activity or bring about a certain result. A computer program can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment.</p>
<p id="p-0067" num="0066">Suitable processors for the execution of a program of instructions include, by way of example, both general and special purpose microprocessors, and the sole processor or one of multiple processors of any kind of computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memories for storing instructions and data. Generally, a computer will also include, or be operatively coupled to communicate with, one or more mass storage devices for storing data files; such devices include magnetic disks, such as internal hard disks and removable disks; magneto-optical disks; and optical disks. Storage devices suitable for tangibly embodying computer program instructions and data include all forms of non-volatile memory, including by way of example semiconductor memory devices, such as EPROM, EEPROM, and flash memory devices; magnetic disks such as internal hard disks and removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, ASICs (application-specific integrated circuits).</p>
<p id="p-0068" num="0067">To provide for interaction with a user, the features can be implemented on a computer having a display device such as a CRT (cathode ray tube) or LCD (liquid crystal display) monitor for displaying information to the user and a keyboard and a pointing device such as a mouse or a trackball by which the user can provide input to the computer.</p>
<p id="p-0069" num="0068">The features can be implemented in a computer system that includes a back-end component, such as a data server, or that includes a middleware component, such as an application server or an Internet server, or that includes a front-end component, such as a client computer having a graphical user interface or an Internet browser, or any combination of them. The components of the system can be connected by any form or medium of digital data communication such as a communication network. Examples of communication networks include, e.g., a LAN, a WAN, and the computers and networks forming the Internet.</p>
<p id="p-0070" num="0069">The computer system can include clients and servers. A client and server are generally remote from each other and typically interact through a network, such as the described one. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.</p>
<p id="p-0071" num="0070">In addition, the logic flows depicted in the figures do not require the particular order shown, or sequential order, to achieve desirable results. In addition, other steps may be provided, or steps may be eliminated, from the described flows, and other components may be added to, or removed from, the described systems. Accordingly, other implementations are within the scope of the following claims.</p>
<p id="p-0072" num="0071">A number of embodiments of the invention have been described. Nevertheless, it will be understood that various modifications may be made without departing from the spirit and scope of the invention. Accordingly, other embodiments are within the scope of the following claims.</p>
<p id="p-0073" num="0072">A few embodiments have been described in detail above, and various modifications are possible. The disclosed subject matter, including the functional operations described in this specification, can be implemented in electronic circuitry, computer hardware, firmware, software, or in combinations of them, such as the structural means disclosed in this specification and structural equivalents thereof, including potentially a program operable to cause one or more data processing apparatus to perform the operations described (such as a program encoded in a computer-readable medium, which can be a memory device, a storage device, a machine-readable storage substrate, or other physical, machine-readable medium, or a combination of one or more of them).</p>
<p id="p-0074" num="0073">A program (also known as a computer program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, or declarative or procedural languages, and it can be deployed in any form, including as a stand alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A program does not necessarily correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub programs, or portions of code). A program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.</p>
<p id="p-0075" num="0074">While this specification contains many specifics, these should not be construed as limitations on the scope of what may be claimed, but rather as descriptions of features that may be specific to particular embodiments. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a sub combination.</p>
<p id="p-0076" num="0075">Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. An apparatus, comprising:
<claim-text>circuitry that:
<claim-text>processes commands received from a host device through a host interface, and</claim-text>
<claim-text>sends the commands to one or more flash memory devices through interface logic; and</claim-text>
</claim-text>
<claim-text>circuitry that:
<claim-text>identifies information received from the one or more flash memory devices through the interface logic, the information being associated with at least one of the commands,</claim-text>
<claim-text>sends the information to the host device through the host interface if one or more parameters of the at least one command include a request to receive the information, and</claim-text>
<claim-text>does not send the information to the host device through the host interface if the one or more parameters of the at least one command do not include the request.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the circuitry that processes the commands received from the host device through the host interface comprises:
<claim-text>circuitry that stores the commands received from the host device through the host interface.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The apparatus of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the circuitry that sends the commands to the one or more flash memory devices through the interface logic comprises:
<claim-text>circuitry that sends the commands to the one or more flash memory devices through the interface logic when a number of stored commands have reached a predetermined threshold number.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the circuitry that sends the commands to the one or more flash memory devices through the interface logic comprises:
<claim-text>circuitry that sends the commands to the one or more flash memory devices through the interface logic simultaneously.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the circuitry that processes the commands received from the host device through the host interface comprises:
<claim-text>circuitry that prioritizes the commands prior to sending the commands to the one or more flash memory devices.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the information received from the one or more flash memory devices includes status information indicating a status of the at least one command.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the circuitry that processes the commands received from the host device through the host interface comprises:
<claim-text>circuitry that checks the one or more parameters of the at least one command for the request as the at least one command is received from the host device.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the one or more parameters include a field indicating whether an interrupt is to be sent to the host device when the information is available from the one or more flash memory devices.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The apparatus of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the circuitry that processes the commands received from the host device through the host interface comprises:
<claim-text>circuitry that modifies the field with a value indicative of a request to transmit the interrupt to the host device when the information is available from the one or more flash memory devices.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. A method, comprising:
<claim-text>receiving commands from a host device;</claim-text>
<claim-text>sending the commands to one or more flash memory devices;</claim-text>
<claim-text>receiving information associated with at least one of the commands from the one or more flash memory devices; and</claim-text>
<claim-text>selectively sending the information to the host device based on whether one or more parameters in the at least one command include a request to receive the information from the one or more flash memory devices.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, further comprising:
<claim-text>storing the commands received from the host device.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein sending the commands to the one or more flash memory devices comprises:
<claim-text>sending the commands to the one or more flash memory devices when a number of stored commands have reached a predetermined threshold number.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein selectively sending the information to the host device based on whether the one or more parameters in the at least one command include the request to receive the information from the one or more flash memory devices comprises:
<claim-text>sending the information to the host device if the one or more parameters in the at least one command include the request.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein selectively sending the information to the host device based on whether the one or more parameters in the at least one command include the request to receive the information from the one or more flash memory devices comprises:
<claim-text>foregoing sending the information to the host device if the one or more parameters in the at least one command does not include the request.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the information received from the one or more flash memory devices includes status information indicating a status of the at least one command.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, further comprising:
<claim-text>checking the one or more parameters in the at least one command for the request as the at least one command is received from the host device.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the one or more parameters include a field indicating whether an interrupt is to be transmitted to the host device when the information is available from the one or more flash memory devices.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The method of <claim-ref idref="CLM-00017">claim 17</claim-ref>, further comprising:
<claim-text>modifying the field with a value indicative of a request to transmit the interrupt to the host device when the information is available from the one or more flash memory devices.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. A method, comprising:
<claim-text>receiving a command from a host device;</claim-text>
<claim-text>transmitting the received command to a flash memory device;</claim-text>
<claim-text>receiving status information associated with the received command from the flash memory device;</claim-text>
<claim-text>determining that one or more parameters in the received command include a request from the host device to receive the status information from the flash memory device; and</claim-text>
<claim-text>transmitting the status information to the host device in response to determining that the one or more parameters in the received command include the request from the host device to receive the status information.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The method of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein the status information indicates execution progress of the received command by the flash memory device.</claim-text>
</claim>
</claims>
</us-patent-grant>
