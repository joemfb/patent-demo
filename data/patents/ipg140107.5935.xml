<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627044-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627044</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12899369</doc-number>
<date>20101006</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<rule-47-flag/>
<us-term-of-grant>
<us-term-extension>626</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>30</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>712216</main-classification>
</classification-national>
<invention-title id="d2e55">Issuing instructions with unresolved data dependencies</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6098166</doc-number>
<kind>A</kind>
<name>Leibholz et al.</name>
<date>20000800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712216</main-classification></classification-national>
</us-citation>
<us-citation>
<nplcit num="00002">
<othercit>Chaudhry et al., &#x201c;Rock: A High-Performance SPARC CMT Processor&#x201d;, 2009, IEEE.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00003">
<othercit>Hilton et al., &#x201c;iCFP: Tolerating All-Level Cache Misses in In-Order Processors&#x201d;, 2008, IEEE.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00004">
<othercit>Nekkalapu et al., &#x201c;A Simple Latency Tolerant Processor&#x201d;, 2008, IEEE.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00005">
<othercit>Barnes et al., &#x201c;Beating in-order stalls with &#x201c;flea-flicker&#x201d; two-pass pipelining&#x201d;, 2003, IEEE.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00006">
<othercit>Mutlu et al., &#x201c;Runahead Execution: An Alternative to Very Large Instruction Windows for Out-of-Order Processors&#x201d;, 2002, IEEE.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
</us-references-cited>
<number-of-claims>18</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>7</number-of-drawing-sheets>
<number-of-figures>9</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20120089819</doc-number>
<kind>A1</kind>
<date>20120412</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Chaudhry</last-name>
<first-name>Shailender</first-name>
<address>
<city>San Francisco</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Van</last-name>
<first-name>Richard Thuy</first-name>
<address>
<city>San Jose</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Cypher</last-name>
<first-name>Robert E.</first-name>
<address>
<city>Saratoga</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="004" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Chandra</last-name>
<first-name>Debasish</first-name>
<address>
<city>Cupertino</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Chaudhry</last-name>
<first-name>Shailender</first-name>
<address>
<city>San Francisco</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Van</last-name>
<first-name>Richard Thuy</first-name>
<address>
<city>San Jose</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Cypher</last-name>
<first-name>Robert E.</first-name>
<address>
<city>Saratoga</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="004" designation="us-only">
<addressbook>
<last-name>Chandra</last-name>
<first-name>Debasish</first-name>
<address>
<city>Cupertino</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Park, Vaughan, Fleming &#x26; Dowler LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Oracle International Corporation</orgname>
<role>02</role>
<address>
<city>Redwood Shores</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Caldwell</last-name>
<first-name>Andrew</first-name>
<department>2183</department>
</primary-examiner>
<assistant-examiner>
<last-name>Geib</last-name>
<first-name>Benjamin</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">The described embodiments include a processor that determines instructions that can be issued based on unresolved data dependencies. In an issue unit in the processor, the processor keeps a record of each instruction that is directly or indirectly dependent on a base instruction. Upon determining that the base instruction has been deferred, the processor monitors instructions that are being issued from an issue queue to an execution unit for execution. Upon determining that an instruction from the record has reached a head of the issue queue, the processor immediately issues the instruction from the issue queue.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="104.31mm" wi="163.83mm" file="US08627044-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="209.55mm" wi="163.41mm" file="US08627044-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="184.57mm" wi="178.82mm" file="US08627044-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="113.54mm" wi="156.46mm" file="US08627044-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="227.58mm" wi="167.81mm" file="US08627044-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="214.71mm" wi="106.34mm" file="US08627044-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="166.79mm" wi="185.17mm" file="US08627044-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="231.31mm" wi="189.65mm" file="US08627044-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND</heading>
<p id="p-0002" num="0001">1. Field</p>
<p id="p-0003" num="0002">The described embodiments relate to computer systems. More specifically, the described embodiments relate to techniques for issuing instructions with unresolved data dependencies.</p>
<p id="p-0004" num="0003">2. Related Art</p>
<p id="p-0005" num="0004">Some modern microprocessors are &#x201c;in-order&#x201d; processors that issue instructions for execution in program order. These in-order processors typically include an issue unit that manages instruction issue as part of the enforcement of program ordering. In most of these processors, the issue unit includes a scoreboard mechanism for keeping track of dependencies between instructions in the processor. Generally, for each instruction being executed in the processor, the scoreboard holds a record that includes information about the instruction (e.g., a destination register identifier and other attributes) that the processor can use to determine when an instruction should be issued relative to other instructions.</p>
<p id="p-0006" num="0005">In many of these processors, the issue unit can use a record in the scoreboard to delay the issuance of a given instruction until a prior instruction has had a chance to produce a result. In other words, the issue unit may stall the issuance of an instruction by holding the instruction at the head of a first-in-first-out issue queue until a prior instruction (upon which the instruction depends) has had a chance to output a value into its destination register. For instructions that interact with off-processor devices (e.g., a memory system or an I/O device), these delays can be dozens or even hundreds of processor clock cycles, which can cause significant delays in issuing subsequent instructions because the dependent instruction is stalled at the head of the issue queue.</p>
<p id="p-0007" num="0006">To avoid some of these delays, some processor designs support the speculative execution of program code past the stalled instruction. Speculative execution involves executing instructions speculatively while preserving a pre-speculation architectural state of the processor. In these processors, the processor can discard speculative results and return to the pre-speculation architectural state if certain conditions occur during speculative execution (e.g., encountering an error/trap, a coherence violation, unavailability of processor hardware resources, executing certain types of instructions, etc.). However, if a speculative execution episode completes without encountering one of the conditions, the processor can commit the speculative results to the architectural state and continue with normal, non-speculative execution.</p>
<p id="p-0008" num="0007">For example, some processors support an &#x201c;execute-ahead&#x201d; mode for speculatively executing instructions. In these processors, upon encountering an instruction with an unresolved data dependency while executing instructions in the non-speculative normal-execution mode, the processor defers the instruction by placing the instruction into a deferred queue and marking the destination register of the instruction &#x201c;not-there&#x201d; to indicate that the register is awaiting a result from a deferred instruction. The processor then transitions to the execute-ahead mode to speculatively execute subsequent instructions. During the execute-ahead mode, instructions with unresolved dependencies are deferred (and their destination registers are marked not-there), but instructions without unresolved data dependencies are executed in program order. In execute-ahead mode, instructions can be deferred if their source registers are not-there. However, these processors do not check the status of a source register until the processor is retrieving input operands in an execute unit while executing the instruction. In addition, as described above, the processor may automatically delay the issuance of an instruction for a given number of cycles to enable a prior instruction upon which the instruction depends to output a result to a destination register. Thus, an instruction that depends on prior instruction with an unresolved data dependency can be stalled at the head of the issue queue, awaiting the result of a prior instruction, despite the fact that the instruction is going to be deferred and will therefore not require the result of the prior instruction.</p>
<heading id="h-0002" level="1">SUMMARY</heading>
<p id="p-0009" num="0008">The described embodiments include a processor that determines instructions that can be issued based on unresolved data dependencies. In an issue unit in the processor, the processor keeps a record of each instruction that is directly or indirectly dependent on a base instruction. Upon determining that the base instruction has been deferred, the processor monitors instructions that are being issued from an issue queue to an execution unit for execution. Upon determining that an instruction from the record has reached a head of the issue queue, the processor issues the instruction from the issue queue.</p>
<p id="p-0010" num="0009">In some embodiments, when issuing the instruction from the issue queue, the processor issues the instruction without stalling the instruction at the head of the issue queue to await a return of a result from a prior instruction upon which the instruction depends.</p>
<p id="p-0011" num="0010">In some embodiments, the processor adds an entry for each in-flight instruction in the processor to a scoreboard in the issue unit. In these embodiments, when keeping the record of each instruction that is directly or indirectly dependent on the base instruction, the processor asserts a speculative not-there indicator in each entry in the scoreboard for an instruction that is directly or indirectly dependent on the base instruction. While determining that an instruction from the record has reached the head of the issue queue, the processor determines whether the instruction is an instruction for which the speculative not-there bit was set.</p>
<p id="p-0012" num="0011">In some embodiments, upon determining that the base instruction was deferred, for each entry in the scoreboard for which the speculative not-there indicator is asserted, the processor asserts a not-there indicator in the entry in the scoreboard and then clears the speculative not-there indicator. In these embodiments, to determine that the instruction is an instruction for which the speculative not-there bit was set, the processor determines that the not-there indicator is asserted in a corresponding entry in the scoreboard.</p>
<p id="p-0013" num="0012">In some embodiments, the processor clears each of the not-there indicators as a corresponding instruction completes execution without being deferred.</p>
<p id="p-0014" num="0013">In some embodiments, the processor clears each of the speculative not-there indicators in the scoreboard when the base instruction completes execution without being deferred.</p>
<p id="p-0015" num="0014">In some embodiments, the processor selects the base instruction. The base instruction can be an instruction that modifies a value in a processor register. In addition, the base instruction can be one of: (1) a predetermined type of instruction; (2) an instruction selected from a predetermined subset of instruction types; or (3) a randomly selected instruction. Moreover, when selecting the base instruction, the processor can: (1) select an instruction randomly or pseudo-randomly; (2) select a first instruction encountered after a given time; or (3) select an instruction based on a predetermined event.</p>
<p id="p-0016" num="0015">In some embodiments, the processor receives decoded instructions forwarded from a decode unit to the issue unit to be issued to one or more execution units.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE FIGURES</heading>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 1</figref> presents a block diagram illustrating a computer system in accordance with the described embodiments.</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 2</figref> presents a block diagram illustrating a processor with an expanded view of a pipeline in accordance with the described embodiments.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 3</figref> presents a state diagram that includes a normal-execution mode, an execute-ahead mode, a deferred-execution mode, and a scout mode in accordance with the described embodiments.</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 4</figref> presents a block diagram illustrating an expanded view of an issue unit in accordance with the described embodiments.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 5</figref> presents a block diagram illustrating an expanded view of a scoreboard in accordance with the described embodiments.</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 6</figref> presents a block diagram illustrating an expanded view of a scoreboard in accordance with the described embodiments.</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 7</figref> presents a flowchart illustrating a process for resolving data dependencies in accordance with the described embodiments.</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 8</figref> presents a flowchart illustrating a process for resolving data dependencies in accordance with the described embodiments.</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 9</figref> presents a flowchart illustrating a process for determining a base instruction in accordance with the described embodiments.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<p id="p-0026" num="0025">In the figures, matching reference numbers refer to the same figure elements.</p>
<heading id="h-0004" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0027" num="0026">The following description is presented to enable any person skilled in the art to make and use the described embodiments, and is provided in the context of a particular application and its requirements. Various modifications to the described embodiments will be readily apparent to those skilled in the art, and the general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the described embodiments. Thus, the described embodiments are not limited to the embodiments shown, but are to be accorded the widest scope consistent with the principles and features disclosed herein.</p>
<p id="h-0005" num="0000">Terminology</p>
<p id="p-0028" num="0027">The following description includes a number of terms for which the definitions are generally known in the art. However, the following definition is provided to clarify the subsequent description.</p>
<p id="p-0029" num="0028">The &#x201c;architectural state&#x201d; of a processor includes the architecturally-visible values, state, and settings that have been committed to corresponding structures on the processor. The values, state, and settings from the architectural state can be freely used by the processor to perform operations. Generally, a processor's architectural state includes the values in all processor structures, memories, registers, flags, variables, counters, and other hardware structures and software variables.</p>
<p id="h-0006" num="0000">Computer System</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 1</figref> presents a block diagram illustrating a computer system <b>100</b> in accordance with the described embodiments. Computer system <b>100</b> includes processor <b>102</b>, L2 cache <b>106</b>, memory <b>108</b>, and mass-storage device <b>110</b>. Processor <b>102</b> includes L1 cache <b>104</b> and pipeline <b>112</b>.</p>
<p id="p-0031" num="0030">Processor <b>102</b> can include any device that is configured to perform computational operations. For example, processor <b>102</b> can be a central processing unit (CPU) such as a microprocessor. As another example, processor <b>102</b> can be a controller or an application-specific integrated circuit (ASIC).</p>
<p id="p-0032" num="0031">Mass-storage device <b>110</b>, memory <b>108</b>, L2 cache <b>106</b>, and L1 cache <b>104</b> are computer-readable storage mediums that collectively form a memory hierarchy in a memory subsystem that stores data and instructions for processor <b>102</b>. Generally, mass-storage device <b>110</b> is a high-capacity, non-volatile memory, such as a disk drive or a large flash memory, with a large access time, while L1 cache <b>104</b>, L2 cache <b>106</b>, and memory <b>108</b> are smaller, faster memories that store copies of frequently used data. For example, memory <b>108</b> can be a dynamic random access memory (DRAM) structure that is larger than L1 cache <b>104</b> and L2 cache <b>106</b>, whereas L1 cache <b>104</b> and L2 cache <b>106</b> can include smaller static random access memories (SRAMs).</p>
<p id="p-0033" num="0032">Computer system <b>100</b> can be incorporated into many different types of electronic devices. For example, computer system <b>100</b> can be part of a desktop computer, a laptop, netbook, or tablet computer, a server, a media player, an appliance, a cellular phone, a piece of testing equipment, a network appliance, a calculator, a personal digital assistant (PDA), a hybrid device (i.e., a &#x201c;smart phone&#x201d;), a guidance system, a toy, audio/video electronics, a video game system, a control system (e.g., an automotive control system), or another electronic device.</p>
<p id="p-0034" num="0033">Although we use specific components to describe computer system <b>100</b>, in alternative embodiments, different components can be present in computer system <b>100</b> or can be arranged differently. For example, computer system <b>100</b> can include video cards, network cards, optical drives, network controllers, I/O devices, and/or other peripheral devices that are coupled to some or all of the elements in computer system <b>100</b> using a bus, a network, or another suitable communication channel. In addition, computer system <b>100</b> may include more or fewer of the elements shown in <figref idref="DRAWINGS">FIG. 1</figref>. For example, computer system <b>100</b> may include additional processors <b>102</b>, and the processors <b>102</b> may share some or all of L2 cache <b>106</b>, memory <b>108</b>, and mass-storage device <b>110</b> and/or may include some or all of their own memory hierarchy. As another example, L1 cache <b>104</b> can include a separate data cache and instruction cache.</p>
<p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. 2</figref> presents a block diagram illustrating a processor <b>102</b> with an expanded view of pipeline <b>112</b> in accordance with the described embodiments. Generally, pipeline <b>112</b> is an instruction execution pipeline that includes a number of stages for executing program code. The stages in pipeline <b>112</b> are coupled in series, with the output of a given stage coupled to the input of a next stage. Instructions progress through each stage of the pipeline to complete a corresponding part of executing the instruction.</p>
<p id="p-0036" num="0035">Pipeline <b>112</b> includes fetch unit <b>200</b>, decode unit <b>202</b>, issue unit <b>204</b>, execution unit <b>206</b>, and commit/trap unit <b>208</b>. Fetch unit <b>200</b> fetches instructions from L1 cache <b>104</b> (or, if necessary, from other levels of the memory hierarchy) for execution. Decode unit <b>202</b> decodes the fetched instructions and prepares the instructions for execution by execution unit <b>206</b>. Issue unit <b>204</b> handles the issue of decoded instructions to individual execution units in execution unit <b>206</b>. Execution unit <b>206</b> executes the instructions forwarded from issue unit <b>204</b>. Execution unit <b>206</b> can include one or more separate floating point execution units, integer execution units/arithmetic logic units (ALUs), branch execution units, and/or memory execution units (e.g., load/store execution units) for executing the instructions. Commit/trap unit <b>208</b> retires successfully executed instructions (i.e., commits the results to the architectural state of processor <b>102</b> and computer system <b>100</b>) and handles traps/errors that arise during the execution of instructions.</p>
<p id="p-0037" num="0036">Pipeline <b>112</b> also includes deferred buffer <b>210</b>. In the described embodiments, if an instruction cannot be executed due to an unresolved data dependency, such as an operand that has not returned from a load operation or a translation lookaside buffer miss, processor <b>102</b> defers execution of the instruction and places the instruction into deferred buffer <b>210</b>. In other words, because the instruction with the unresolved dependency cannot yet be executed by execution unit <b>206</b> due to the unresolved data dependency, the instruction is forwarded from execution unit <b>206</b> along the path shown in <figref idref="DRAWINGS">FIG. 2</figref> to deferred buffer <b>210</b>. When the data dependency is eventually resolved, instructions from deferred buffer <b>210</b> are forwarded to execution unit <b>206</b> to be executed in program order with respect to other deferred instructions, but not with respect to other previously executed non-deferred instructions. This process is described in more detail below with reference to <figref idref="DRAWINGS">FIG. 3</figref>.</p>
<p id="p-0038" num="0037">Note that pipeline <b>112</b> is simplified for the purposes of illustration. In alternative embodiments, pipeline <b>112</b> can contain other stages (units), functional blocks, mechanisms, and/or circuits. Generally, the units, functional blocks, mechanisms, and/or circuits that can be used in a pipeline are known in the art and hence are not described in detail.</p>
<p id="p-0039" num="0038">In addition, although described separately for clarity, in some embodiments, some of the units in pipeline <b>112</b> are included in one or more of the other units. For example, in some embodiments, fetch unit <b>200</b> includes some or all of decode unit <b>202</b> and issue unit <b>204</b>. As another example, in some embodiments, decode unit <b>202</b> includes some or all of issue unit <b>204</b>.</p>
<p id="p-0040" num="0039">In some embodiments, processor <b>102</b> includes a checkpoint-generation mechanism (not shown). This checkpoint-generation mechanism includes one or more register files, memories, tables, lists, or other structures that facilitate preserving a copy of the architectural state of processor <b>102</b>. In these embodiments, when commencing speculative execution (e.g., execution in execute-ahead mode <b>302</b>, or scout mode <b>306</b> (see <figref idref="DRAWINGS">FIG. 3</figref>), the checkpoint-generation mechanism can perform operations to checkpoint/preserve the architectural state of processor <b>102</b>. Generally, the architectural state can include copies of all processor <b>102</b>'s hardware structures, memories, registers, flags, variables, counters, etc., that are useful or necessary for restarting processor <b>102</b> from the pre-speculation architectural state.</p>
<p id="p-0041" num="0040">In some embodiments, computer system <b>100</b> further includes mechanisms (functional blocks, circuits, etc.) for operating in an execute-ahead mode <b>302</b>, a deferred-execution mode <b>304</b>, and a scout mode <b>306</b> (see <figref idref="DRAWINGS">FIG. 3</figref>). Exemplary embodiments of a system that supports an execute-ahead mode and a deferred-execution mode are described in U.S. Pat. No. 7,114,060, entitled &#x201c;Selectively Deferring Instructions Issued in Program Order Utilizing a Checkpoint and Multiple Deferral Scheme,&#x201d; by inventors Shailender Chaudhry and Marc Tremblay, which is hereby incorporated by reference to describe some mechanisms and processes of operating in execute-ahead mode and deferred-execution mode. Exemplary embodiments of a system that supports a scout mode are described in more detail in U.S. Pat. No. 6,415,356, entitled &#x201c;Method and Apparatus for Using an Assist Processor to Pre-Fetch Data Values for a Primary Processor,&#x201d; by inventors Shailender Chaudhry and Marc Tremblay, which is hereby incorporated by reference to describe some mechanisms and processes of operating in scout mode.</p>
<p id="p-0042" num="0041">Note that, although we provide the above-described references as examples of a system that supports execute-ahead mode and deferred-execution mode, numerous other publications, conference papers, patent publications, and issued patents describe additional aspects of the execute-ahead mode and the deferred-execution mode. See, for example, U.S. Pat. No. 7,293,161, entitled &#x201c;Deferring Loads and Stores When a Load Buffer or Store Buffer Fills During Execute-Ahead Mode,&#x201d; by inventors Shailender Chaudhry, Marc Tremblay, and Paul Caprioli, or U.S. Pat. No. 7,487,335, entitled &#x201c;Method and Apparatus for Accessing Registers During Deferred Execution,&#x201d; by inventors Shailender Chaudhry, Syed I. Hac, Mohammed M. Rahman, and Khanh Luu.</p>
<p id="p-0043" num="0042">In addition, although we provide the above-described references as examples of a system that supports scout mode, numerous other publications, conference papers, patent publications, and issued patents describe additional aspects of the scout mode. See, for example, U.S. patent publication no. 2004/0133769, entitled &#x201c;Generating Prefetches by Speculatively Executing Code through Hardware Scout Threading,&#x201d; by inventors Shailender Chaudhry and Marc Tremblay, or U.S. patent publication no. 2004/0133767, entitled &#x201c;Performing Hardware Scout Threading in a System that Supports Simultaneous Multithreading,&#x201d; by inventors Shailender Chaudhry and Marc Tremblay.</p>
<p id="h-0007" num="0000">Speculative Execution</p>
<p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. 3</figref> presents a state diagram that includes a normal-execution mode <b>300</b>, an execute-ahead mode <b>302</b>, a deferred-execution mode <b>304</b>, and a scout mode <b>306</b> in accordance with the described embodiments. Generally, the described embodiments can operate in execute-ahead mode <b>302</b> or deferred-execution mode <b>304</b> to speculatively execute program code following a data-dependent stall condition in normal-execution mode <b>300</b>. In addition, the described embodiments can operate in scout mode <b>306</b> to speculatively execute program code following a non-data-dependent stall condition in normal-execution mode <b>300</b>, execute-ahead mode <b>302</b>, or deferred-execution mode <b>304</b>. Using speculative execution, these embodiments can perform useful computational work in cases where some existing processors are stalled, waiting for a stall condition to be resolved so that subsequent instructions can be executed.</p>
<p id="p-0045" num="0044">As shown in <figref idref="DRAWINGS">FIG. 3</figref>, processor <b>102</b> initially executes program code in normal-execution mode <b>300</b>. In normal-execution mode <b>300</b>, processor <b>102</b> executes instructions from program code in program order and commits results from executing instructions to the architectural state of processor <b>102</b>.</p>
<p id="p-0046" num="0045">Upon encountering an unresolved data dependency during execution of an instruction in normal-execution mode <b>300</b>, processor <b>102</b> transitions to execute-ahead mode <b>302</b>. In the described embodiments, an unresolved data dependency can include, but is not limited to: (1) a use of an operand that has not returned from a preceding load miss (e.g., an I-cache or D-cache miss); (2) a use of an operand that has not returned from a preceding translation lookaside buffer (ITLB or DTLB) miss; (3) a use of an operand that has not returned from a preceding full or partial read-after-write (RAW) from store buffer operation; and (4) a use of a result from a prior instruction (as an operand) that was subject to an unresolved data dependency.</p>
<p id="p-0047" num="0046">When transitioning to execute-ahead mode <b>302</b>, processor <b>102</b> generates a checkpoint that can be used to restore a pre-speculation architectural state to processor <b>102</b>. Generating the checkpoint involves preserving the architectural state of processor <b>102</b> to facilitate subsequent recovery should a need arise to return to the pre-speculation state during execute-ahead mode <b>302</b>, deferred-execution mode <b>304</b>, or scout mode <b>306</b>.</p>
<p id="p-0048" num="0047">In addition, because the instruction with the unresolved data dependency cannot be executed until the data dependency is resolved, execution unit <b>206</b> forwards the instruction to deferred buffer <b>210</b>. The instruction is then stored in deferred buffer <b>210</b> until the data dependency is resolved. (We call this operation &#x201c;deferring&#x201d; the instruction, and refer to such an instruction as a &#x201c;deferred instruction.&#x201d;) If the instruction writes an output to a destination register, processor <b>102</b> can also set a &#x201c;not there&#x201d; attribute bit in the register to indicate that the register is dependent on a deferred instruction.</p>
<p id="p-0049" num="0048">By deferring the instruction with the unresolved data dependency, processor <b>102</b> frees execution unit <b>206</b> to speculatively execute subsequent non-dependent instructions. Hence, in execute-ahead mode <b>302</b>, processor <b>102</b> continues to execute subsequent instructions in program order. While executing subsequent instructions, any instructions that cannot be executed because of an unresolved data dependency or a dependency on a result of a prior deferred instruction are not executed, but are instead also deferred and placed in deferred buffer <b>210</b> and a not there bit is set in the destination register for the instruction (if the instruction writes an output to a destination register). Note that processor <b>102</b> can detect the dependency on the prior deferred instruction using the not there attribute bit in the processor register.</p>
<p id="p-0050" num="0049">As described in more detail below, processor <b>102</b> includes mechanisms for detecting when a processor register has been marked not-there for a base instruction and issuing subsequent dependent instructions as soon as possible (i.e., as soon as these instructions reach the head/first-out position of an issue queue <b>404</b> (see <figref idref="DRAWINGS">FIG. 4</figref>)). In these embodiments, unlike in existing systems, issue unit <b>204</b> need not hold instructions at the head of the issue queue <b>404</b> awaiting a designated delay to give a prior instruction a chance to produce a result, but instead can immediately issue the instruction as the instruction arrives at the head of the issue queue <b>404</b>.</p>
<p id="p-0051" num="0050">When operating in execute-ahead mode <b>302</b>, processor <b>102</b> monitors for data returns (e.g., a cache line or a DTLB translation returned to processor <b>102</b> from computer system <b>100</b> in response to a request, etc.). Upon detecting a data return, processor <b>102</b> transitions to deferred-execution mode <b>304</b>.</p>
<p id="p-0052" num="0051">In deferred-execution mode <b>304</b>, processor <b>102</b> attempts to execute deferred instructions from deferred buffer <b>210</b> in program order. Processor <b>102</b> attempts to execute these instructions in program order with respect to other deferred instructions in deferred buffer <b>210</b> (i.e., deferred buffer <b>210</b> is a first-in-first-out buffer), but not with respect to other previously executed non-deferred instructions (and not with respect to deferred instructions executed in previous passes through deferred buffer <b>210</b>). More specifically, during a deferred-execution mode episode, processor <b>102</b> issues each instruction from deferred buffer <b>210</b> to execution unit <b>206</b> in the order in which they were stored in deferred buffer <b>210</b>. Note that, while issuing instructions from deferred buffer <b>210</b>, processor <b>102</b> prevents the front end of pipeline <b>112</b> (i.e., instruction fetch unit <b>200</b> and instruction decode unit <b>202</b>) from forwarding instructions to instruction execution unit <b>206</b>, so that the only instructions executed by execution unit <b>206</b> during the deferred-execution mode <b>304</b> are issued from deferred buffer <b>210</b>.</p>
<p id="p-0053" num="0052">While attempting to execute each instruction from deferred buffer <b>210</b> in deferred-execution mode <b>304</b>, upon encountering an instruction for which the data dependency has not yet been resolved, processor <b>102</b> re-defers execution and places the re-deferred instruction back into deferred buffer <b>210</b>. (Note that processor <b>102</b> executes the other instructions that can be executed in program order with respect to each other.)</p>
<p id="p-0054" num="0053">After the system completes a pass through deferred buffer <b>210</b>, if deferred buffer <b>210</b> is empty, the system transitions to normal-execution mode <b>300</b>. This may involve committing changes made during execute-ahead mode <b>302</b> and deferred-execution mode <b>304</b> to the architectural state of the processor, if such changes have not been already committed. Returning to normal-execution mode <b>300</b> can also involve deleting the checkpoint generated when the system moved into execute-ahead mode <b>302</b>.</p>
<p id="p-0055" num="0054">On the other hand, if deferred buffer <b>210</b> is not empty after the system completes a pass through deferred buffer <b>210</b>, the system returns to execute-ahead mode <b>302</b> to execute instructions from the point where the execute-ahead mode <b>302</b> left off (i.e., processor <b>102</b> resumes fetching and executing instructions from the last instruction executed in execute-ahead mode <b>302</b> before the deferred-execution mode episode was started). Note that in some embodiments processor <b>102</b> does not resume execute-ahead mode <b>302</b>, but instead stalls until another data return occurs (and then starts another deferred-execution mode episode).</p>
<p id="p-0056" num="0055">Some embodiments also support a scout mode <b>306</b>. If a non-data-dependent stall condition arises during normal-execution mode <b>300</b>, execute-ahead mode <b>302</b>, or deferred-execution mode <b>304</b>, these embodiments can transition to scout mode <b>306</b> to speculatively execute instructions. In these embodiments, upon resolving the non-data-dependent stall condition, processor <b>102</b> restores the checkpointed architectural state and resumes operation in normal-execution mode <b>300</b>. Note that restoring the checkpointed architectural state and resuming operation in normal-execution mode <b>300</b> involves overwriting or ignoring the speculative results generated during execute-ahead mode <b>302</b> and deferred-execution mode <b>304</b>.</p>
<p id="p-0057" num="0056">In some embodiments, although not shown in <figref idref="DRAWINGS">FIG. 3</figref>, upon encountering certain operating conditions and/or instructions while speculatively executing program code, processor <b>102</b> can immediately restore the most-recently generated checkpoint and resume operation in normal-execution mode <b>300</b>. For example, in some embodiments, upon determining that a hardware resource is unavailable (busy, overflowed, etc.) while speculatively executing instructions, processor <b>102</b> can immediately restore the checkpoint. In some embodiments, this can happen when the store buffer overflows and/or when the deferred queue overflows.</p>
<p id="h-0008" num="0000">Issue Unit</p>
<p id="p-0058" num="0057">The described embodiments include a mechanism in issue unit <b>204</b> that is used to determine when a given instruction is dependent on a prior instruction that encountered an unresolved data dependency. In these embodiments, if the mechanism detects such a dependency, the mechanism can signal issue unit <b>204</b> to issue the instruction as soon as possible while still maintaining program ordering for the instruction.</p>
<p id="p-0059" num="0058">Generally, in the described embodiments, an instruction can be held in the issue unit, waiting for a given number of processor clock cycles for a prior instruction upon which the instruction is dependent to produce a result before the instruction is issued. For example, an ADD instruction that follows a MUL (multiply) instruction with a dependency on the MUL instruction can be held in the issue unit for N processor clock cycles to allow the multi-cycle MUL instruction to produce a result. However, if the prior instruction (the MUL instruction in the example case) depends on a not-there register, the time spent waiting before issuing the instruction (the ADD instruction) can be wasted because the instruction will simply be deferred. In this case, the instruction does not need to await the result from the prior instruction. Therefore, the mechanism in issue unit <b>204</b> determines when a prior instruction upon which the instruction is dependent has an unresolved data dependency and signals issue unit <b>204</b> to issue the instruction as soon as possible while still maintaining program ordering.</p>
<p id="p-0060" num="0059">The mechanism in issue unit <b>204</b> can include one or more hardware structures or circuits that are used for keeping track of dependencies for instructions. For example, in the described embodiments, an instruction scoreboard <b>402</b> in the issue unit can include mechanisms for keeping track of the dependencies for each instruction that is in-flight in processor <b>102</b>. Note that the term &#x201c;in-flight&#x201d; indicates any instruction being executed in processor <b>102</b> from decoded instructions that have been forwarded to issue unit <b>204</b> for issuance to, but not including, instructions that have passed the commit/trap unit <b>208</b> and have been retired.</p>
<p id="p-0061" num="0060">The described embodiments are not limited to keeping track of dependencies for single instructions; the mechanism in issue unit <b>204</b> can keep a record of all instructions with a dependency on a given instruction. For convenience, we call the record a &#x201c;dependency chain&#x201d; and call the given instruction, which is the first instruction in the dependency chain, the &#x201c;base instruction.&#x201d; For example, assuming a LOAD instruction is the base instruction, the mechanism in issue unit <b>204</b> can keep track of each instruction that depends from the LOAD instruction&#x2014;including instructions with dependencies on instructions that are dependent on the LOAD instructions, but that are not directly dependent on the LOAD instruction (i.e., instructions with &#x201c;indirect&#x201d; dependencies).</p>
<p id="p-0062" num="0061">The described embodiments can use the recorded dependency chain to issue any dependent instructions as soon as possible in program order when a base instruction is determined to be subject to an unresolved data dependency. For example, assuming that the above-described LOAD instruction misses in L1 cache <b>104</b> and is sent to L2 cache <b>106</b> (and perhaps to further levels in the memory hierarchy), the LOAD instruction is deferred. The mechanism in issue unit <b>204</b> can detect that the LOAD instruction has been deferred and use the dependency chain to issue any dependent instructions as soon as possible while maintaining program order.</p>
<p id="p-0063" num="0062"><figref idref="DRAWINGS">FIG. 4</figref> presents a block diagram illustrating an expanded view of issue unit <b>204</b> in accordance with the described embodiments. As can be seen in <figref idref="DRAWINGS">FIG. 4</figref>, issue unit <b>204</b> includes control logic <b>400</b>, scoreboard <b>402</b>, and issue queues <b>404</b>. As described above, issue unit <b>204</b> accepts decoded instructions output from decode unit <b>202</b>, and forwards the decoded instructions to appropriate execution units in execution unit <b>206</b> for execution.</p>
<p id="p-0064" num="0063">Control logic <b>400</b> includes one or more circuits, controllers, devices, or mechanisms for controlling the forwarding of decoded instructions from decode unit <b>202</b> to corresponding execution units in execution unit <b>206</b>. In these embodiments, given a decoded instruction of a particular type, such as a branch address calculation or a floating-point operation, control logic <b>400</b> can forward the decoded instruction to the issue queue <b>404</b> associated with the corresponding execution unit. In the described embodiments, control logic <b>400</b> can include grouping/steering logic, monitoring logic, detection logic, and/or other types of logic for directing decoded instructions to an instruction queue for a corresponding execution unit and controlling the issue of the instructions.</p>
<p id="p-0065" num="0064">Issue queues <b>404</b> are first-in-first-out (FIFO) buffers that include a number of entries for receiving instructions forwarded from control logic <b>400</b>, and issuing instructions for execution in the order in which the instructions were received from control logic <b>400</b>. For example, in some embodiments, each issue queue <b>404</b> includes two entries, each of which holds one instruction.</p>
<p id="p-0066" num="0065">As described above, each issue queue <b>404</b> is used to handle instructions for a corresponding execution unit in execution unit <b>206</b>. In one exemplary embodiment, from the five issue queues <b>404</b> shown in issue unit <b>204</b>, two of the issue queues <b>404</b> can handle integer instructions, one of the issue queues <b>404</b> can handle floating-point instructions, another of the issue queues <b>404</b> can handle branch address calculation instructions, and the fifth issue queue <b>404</b> can handle memory instructions.</p>
<p id="p-0067" num="0066">Although each issue queue <b>404</b> issues instructions in order with respect to other instructions in the same issue queue <b>404</b>, the issue queue <b>404</b> may issue instructions out of order with respect to other issue queues <b>404</b>. In addition, although each of the issue queues <b>404</b> handles a particular type of instructions, dependencies can occur between instructions in the issue queues <b>404</b> (i.e., an instruction in a given issue queue <b>404</b> can use the result of an instruction in a different issue queue <b>404</b> as an input). For example, a floating-point instruction in the corresponding issue queue <b>404</b> can have a dependency on an integer instruction in one of the other issue queues <b>404</b>.</p>
<p id="p-0068" num="0067">In the described embodiments, the issue queues <b>404</b> can issue an instruction per processor clock cycle to the corresponding execution units, and each execution unit in execution unit <b>206</b> can accept up to an instruction per cycle from the corresponding issue queue <b>404</b>. Although the issue queues <b>404</b> can issue an instruction per cycle as described, control logic <b>400</b> monitors the instructions in each of the issue queues <b>404</b> to determine when an instruction should be held at the head of a given issue queue <b>404</b> and not issued because a prior instruction upon which the instruction depends has not yet produced a result.</p>
<p id="p-0069" num="0068">For example, assume a CAS (compare-and-swap) instruction uses as an input a result value output from an immediately prior multi-cycle DIV (divide) instruction. In this case, control logic <b>400</b> detects that the CAS instruction is dependent on the DIV instruction and stalls the CAS instruction until the DIV instruction produces a result. When stalling the CAS instruction, control logic <b>400</b> stalls the corresponding issue queue <b>404</b> to hold the CAS instruction at the head of the issue queue <b>404</b>, thereby preventing the CAS instruction and any subsequent instructions in the issue queue <b>404</b> from issuing.</p>
<p id="p-0070" num="0069">Control logic <b>400</b> typically stalls an instruction in this way for a given number of cycles based on the type of prior instruction upon which the instruction is dependent. For example, assuming that a DIV instruction takes X cycles to produce a result, control logic <b>400</b> can stall subsequent dependent instructions for up to X-N cycles from the issue cycle of the DIV instruction.</p>
<p id="p-0071" num="0070">Scoreboard <b>402</b> is a hardware structure that is used for keeping track of the dependencies between instructions being executed in processor <b>102</b>. Scoreboard <b>402</b> includes a record structure or mechanism that includes a set of entries that can each hold a record of an instruction that is in-flight in processor <b>102</b>. The record in scoreboard <b>402</b> can include an identifier of the destination register for the instruction as well as attribute information for the instruction.</p>
<p id="p-0072" num="0071">The attribute information for an entry in scoreboard <b>402</b> can include an identifier of the type of instruction for which the record is being kept. Control logic <b>400</b> can use the type information to determine the number of cycles that a subsequent instruction is to be held (i.e., stalled at the head of an issue queue <b>404</b>) so that the instruction can produce a result.</p>
<p id="p-0073" num="0072">In addition, the attribute information can include an indication of a dependency between the instruction and an earlier instruction. For example, in some embodiments, each entry in scoreboard <b>402</b> includes an attribute field that can be used to keep track of an earlier instruction from which the output/result is used as an input for the entry's instruction. In some embodiments, this information can include an identifier such as a pointer that indicates another entry in the scoreboard <b>402</b> upon which a given entry is dependent.</p>
<p id="p-0074" num="0073">The attribute information can also include a field for recording whether the associated instruction is part of a dependency chain. As described in more detail with respect to <figref idref="DRAWINGS">FIG. 5</figref>, starting from a base instruction, as entries for dependent instructions are added to scoreboard <b>402</b>, this field can be used to keep track of a sequence or &#x201c;chain&#x201d; of instructions that are directly or indirectly dependent on the base instruction. If the base instruction is subsequently determined to have encountered an unresolved data dependency and been deferred (and hence the destination register for the prior instruction has been marked not-there), the described embodiments can use the records in scoreboard <b>402</b> to issue instructions in the dependency chain as soon as the instructions arrive at the head of the corresponding issue queue <b>404</b> (i.e., in program order) if they were yet to be issued.</p>
<p id="p-0075" num="0074">Note that although we describe issue unit <b>204</b> using the embodiment shown in <figref idref="DRAWINGS">FIG. 4</figref>, in alternative embodiments, issue unit <b>204</b> can include more, fewer, or different mechanisms. Generally, issue unit <b>204</b> includes circuits, structures, and/or mechanisms for issuing decoded instructions from decode unit <b>202</b> to corresponding execution units in execution unit <b>206</b> in accordance with the operating mode of processor <b>102</b>. In addition, issue unit <b>204</b> includes one or more circuits, structures, and/or mechanisms for keeping track of dependencies for in-flight instructions in processor <b>102</b> that can be used to identify any instructions that are dependent on a given base instruction so that the instructions can be issued immediately upon the base instruction being discovered to have an unresolved data dependency. Although we describe embodiments where the mechanism is in scoreboard <b>402</b>, in alternative embodiments, the mechanism can be in a different location (i.e., can be in a circuit structure in control logic <b>400</b>, etc.).</p>
<p id="p-0076" num="0075">Recall that in existing/prior processors, the determination of whether or not an instruction attempts to read input data from a not-there register is not made until a stage in an execution unit where the instruction's input data is read from source registers. This means that in existing processors, instructions must be processed normally until that point, despite the fact that the instruction may eventually be deferred. As part of the normal processing of instructions, existing processors may stall the instructions at the head of an issue queue, awaiting the return of a result from a prior instruction upon which the instruction was dependent. Because the instruction may eventually arrive at the execution unit only to discover that one of the instruction's source registers had previously been marked not-there (and hence the instruction needs to be deferred), a stall at the issue queue awaiting the result from the prior instruction can turn out to be time wasted in executing the instruction, and can unnecessarily block subsequent instructions from proceeding to issue from the issue queue <b>404</b>.</p>
<p id="p-0077" num="0076">In contrast, in the described embodiments, the above-described dependency chain record enables the resolution of instructions that will be affected by deferred instructions for which the destination register will be marked not-there in issue unit <b>204</b>. In other words, in these embodiments, immediately upon discovering that a base instruction has encountered an unresolved data dependency, the dependency chain record in scoreboard <b>402</b> can be used to determine each of the subsequent instructions that will encounter an unresolved data dependency caused by the deferral of the base instruction. These instructions can be issued immediately upon arriving at the head of the issue queue <b>404</b>, instead of being stalled and held, waiting for a result from a prior instruction. This not only speeds execution of the instruction itself, but also prevents the instruction from unnecessarily blocking other instructions from issuing from the issue queue <b>404</b>.</p>
<p id="h-0009" num="0000">Scoreboard</p>
<p id="p-0078" num="0077"><figref idref="DRAWINGS">FIG. 5</figref> presents a block diagram illustrating an expanded view of scoreboard <b>402</b> in accordance with the described embodiments. As can be seen in <figref idref="DRAWINGS">FIG. 5</figref>, scoreboard <b>402</b> includes a set of entries <b>500</b> and logic <b>512</b>. Generally, the entries <b>500</b> are used to keep track of relationships between in-flight instructions in processor <b>102</b> and logic <b>512</b> manages entries <b>500</b> (i.e., adding/removing/reading entries, etc.).</p>
<p id="p-0079" num="0078">In some embodiments, entries <b>500</b> are stored in a memory structure within scoreboard <b>402</b>. For example, scoreboard <b>402</b> can include a register file, a content addressable memory (CAM), and/or another type of memory structure. Generally, the described embodiments can use any type of hardware and/or software structure that enables issue unit <b>204</b> to store and access (read, compare, update, invalidate, etc.) records for in-flight instructions.</p>
<p id="p-0080" num="0079">Each entry <b>500</b> includes a set of fields that are used to keep track of information about a corresponding in-flight instruction. As shown in <figref idref="DRAWINGS">FIG. 5</figref>, the fields include: (1) register number <b>502</b>; (2) attribute <b>504</b>; (3) rename <b>506</b>; (4) speculative not-there (NT) <b>508</b>; and (5) not-there (NT) <b>510</b>.</p>
<p id="p-0081" num="0080">Register number <b>502</b> holds an identifier of the destination register to which the corresponding in-flight instruction writes its result. For example, assuming that an entry is added for a LOAD instruction that writes to register &#x201c;R7,&#x201d; the entry would indicate register R7 in the register number <b>502</b> field in the entry. Note that the register number can be a number (e.g., 7) or may be another value computed or determined by logic <b>512</b>. Generally, the value stored in register number can be any value that can be used by logic <b>512</b> or issue unit <b>204</b> to identify the destination register.</p>
<p id="p-0082" num="0081">Attribute <b>504</b> is used to keep track of whether a subsequent instruction is dependent on the value to be written to the destination register by the corresponding in-flight instruction. For example, assume that scoreboard <b>402</b> includes an entry <b>500</b> for a LOAD instruction writes to register &#x201c;R7.&#x201d; If an instruction is subsequently encountered that reads from register R7, attribute <b>504</b> for the entry <b>500</b> for the LOAD instruction is updated to indicate that the value is read.</p>
<p id="p-0083" num="0082">Rename <b>506</b> is used to keep track of an entry in scoreboard <b>402</b> upon which a given entry is dependent. In some embodiments, the entries in scoreboard <b>402</b> are assigned a rename value. For example, the first entry in the scoreboard can be given a value of &#x201c;0,&#x201d; whereas the second entry is given a value of &#x201c;1,&#x201d; etc. These values are then used in subsequent dependent entries to indicate dependence on another entry. For example, assume a LOAD instruction is placed in an entry numbered &#x201c;0&#x201d; by logic <b>512</b>. When a subsequent ADD instruction is encountered that depends upon the LOAD instruction, rename <b>506</b> for the entry for the ADD instruction in scoreboard <b>402</b> is set to 0, thereby indicating the dependency on the LOAD instruction.</p>
<p id="p-0084" num="0083">Speculative not-there (spec NT) <b>508</b> is used to keep track of instructions that depend directly or indirectly from a given base instruction. As described above, the resulting chain of dependencies can be used in the issue unit to determine instructions that are dependent on an instruction with an unresolved data dependency and can therefore be issued as soon as possible in program order. More specifically, in the described embodiments, spec NT <b>508</b> can be used to determine instructions that depend upon a previous instruction that has an unresolved data dependency. Instructions with such dependencies can be issued without being stalled a given number of cycles in the corresponding issue queue <b>404</b> awaiting a result from the previous instruction.</p>
<p id="p-0085" num="0084">During operation, while executing instructions, issue unit <b>204</b> can start keeping a record of a dependency chain. In keeping the record of the dependency chain, issue unit <b>204</b> first selects an instruction as a base instruction. Generally, the base instruction can be any instruction that writes to or otherwise changes the value in a register in processor <b>102</b>. For example, a memory operation instruction such as a LOAD instruction, a computational instruction such as an ADD instruction, a register manipulation instruction such as a MOV or CAS (compare-and-swap), or another instruction that alters the value in a destination register. The base instruction can be selected randomly, can be the first of a given type of instructions encountered, can be selected at or near a given time, or can be selected using another criterion.</p>
<p id="p-0086" num="0085">Then, while updating an available entry in scoreboard <b>402</b> to include a record of the selected base instruction, issue unit <b>204</b> asserts (or causes logic <b>512</b> to assert) spec NT <b>508</b> for the entry. By asserting spec NT <b>508</b> for the entry, issue unit <b>204</b> establishes that a base instruction is in-flight, and that subsequent directly or indirectly dependent instructions are to have their spec NT <b>508</b> asserted so that a dependency chain from the base instruction is recorded. Note that for a &#x201c;direct&#x201d; dependency, a subsequent instruction (&#x201c;INST<b>2</b>&#x201d;) can read the value from the destination register for the base instruction (&#x201c;INSTB&#x201d;). In the case of an &#x201c;indirect&#x201d; dependency, a later instruction (INST<b>3</b>) can read the value from the destination register from INST<b>2</b>. In this case, because INST<b>2</b> is dependent on INSTB, if INSTB is determined to have an unresolved data dependency (and be deferred), INST<b>2</b> will also have an unresolved data dependency, which leads to INST<b>3</b> having an unresolved data dependency.</p>
<p id="p-0087" num="0086">As long as the base instruction remains in-flight (i.e., before the base instruction retires), for each entry <b>500</b> updated with a record for a corresponding instruction in scoreboard <b>402</b>, if that instruction is directly or indirectly dependent on the base instruction, spec NT <b>508</b> is asserted for the entry. For example, assume that the base instruction is a LOAD instruction. Further assume that the LOAD instruction is followed by a directly dependent ADD instruction and an indirectly dependent MUL instruction (e.g., where the MUL is dependent on the ADD). Along with asserting spec NT <b>508</b> for the LOAD instruction, logic <b>512</b> asserts spec NT <b>508</b> for the entries for both the ADD instruction and the MUL instruction.</p>
<p id="p-0088" num="0087">If the base instruction retires without encountering an unresolved data dependency, logic <b>512</b> can deassert spec NT <b>508</b> for each of the entries for which spec NT <b>508</b> was asserted while the base instruction was in flight. Using the example above, when the LOAD instruction retires, spec NT <b>508</b> can be deasserted for the ADD and the MUL instructions. In this way, issue unit <b>204</b> clears the dependency chain when a base instruction retires. In addition, any other NT information for that entry for the base instruction can be cleared.</p>
<p id="p-0089" num="0088">In some embodiments, logic <b>512</b> can use a signal returned by processor <b>102</b> to determine when the base instruction has retired. In alternative embodiments, processor <b>102</b> can include one or more monitoring mechanisms that are used to keep track of when instructions are past commit/trap unit <b>208</b> or have otherwise left the pipeline (i.e., been flushed from the pipeline, etc.).</p>
<p id="p-0090" num="0089">In some embodiments, the base instruction need not completely retire before logic <b>512</b> can clear the dependency chain (i.e., deassert spec NT <b>508</b> for each affected entry). Generally, when a base instruction can no longer be deferred, the dependency chain can be cleared (and, as described below a new dependency chain can be started). For example, in some embodiments, processor <b>102</b> includes monitoring mechanisms that determine when each instruction proceeds past a stage in execute unit where the input registers are checked, in these embodiments, after checking the input registers and finding all input registers are &#x201c;there,&#x201d; processor <b>102</b> can send a signal to logic <b>512</b> that causes logic <b>512</b> to clear a corresponding dependency chain.</p>
<p id="p-0091" num="0090">On the other hand, if processor <b>102</b> encounters an unresolved data dependency and/or another condition that causes the base instruction to be deferred, processor <b>102</b> can signal logic <b>512</b> to set NT <b>510</b> for the corresponding entry <b>500</b> in scoreboard <b>402</b>, thereby recording that the instruction was deferred. Because spec NT <b>508</b> is also set in the entry in scoreboard <b>402</b> for the base instruction, logic <b>512</b> searches the remaining entries and sets NT <b>510</b> for each entry for which spec NT <b>508</b> is asserted, and then deasserts spec NT <b>508</b> for the entry. By &#x201c;changing&#x201d; the spec NTs <b>508</b> to NTs <b>510</b> in this way, logic <b>512</b> signals issue unit <b>204</b> that the issue unit <b>204</b> can issue any of the entries for which NT <b>510</b> is set as soon as possible in program order (i.e., as soon as these instructions reach the head of the corresponding issue queue <b>404</b>).</p>
<p id="p-0092" num="0091">In addition to updating the NTs <b>510</b>, processor <b>102</b> can clear the register scoreboard (i.e., clear information in the scoreboard which causes issue unit <b>204</b> to stall subsequent instructions at the head of the issue queue) for entries which become NT due to the merge. This prevents any of the entries for which the spec NT <b>508</b> is converted/merged to NT <b>510</b> from causing subsequent instructions to be delayed at the head of the issue queues, waiting for a prior instruction to produce a result.</p>
<p id="p-0093" num="0092">In the described embodiments, the corresponding instruction need not be stalled in the issue window for a number of cycles based on a prior instruction, but instead can be issued at once. More specifically, recall that the issue queues <b>404</b> are FIFO buffers from which one instruction can issue for execution per processor clock cycle. Because one or more instructions can be queued in a given issue queue <b>404</b> for issue before an instruction from the dependency chain, one or more processor clock cycles may pass before an instruction advances to the head of the queue to be issued. However, when the instruction arrives at the head of the queue, issue unit <b>204</b> can check the entry in scoreboard <b>402</b> and determine that the instruction can be issued immediately. As described above, this can mean that issue unit <b>204</b> does not stall the instruction in the issue queue <b>404</b> a number of clock cycles before issue to allow a result to be returned from a prior instruction upon which the instruction is dependent, but instead immediately issues the instruction when the instruction reaches the head of the issue queue <b>404</b>.</p>
<p id="p-0094" num="0093">Issue unit <b>204</b> (logic <b>512</b>) can then clear NT <b>510</b> for each entry when the instructions have been deferred. Alternatively, issue unit <b>204</b> can clear NT <b>510</b> for each entry when the instructions successfully complete execution in deferred mode. By clearing NT <b>510</b>, issue unit <b>204</b> can remove the record of the dependency chain from the scoreboard when the record has been used to enable the issue of instructions as soon as the instructions were ready.</p>
<p id="p-0095" num="0094">When the base instruction retires or is deferred and spec NT <b>508</b> is cleared for each of the affected entries, no dependency chain is being tracked by issue unit <b>204</b>. Issue unit <b>204</b> can therefore select a new base instruction and begin the process of recording a dependency chain anew. These operations may be performed an unlimited number of times while the processor operates. Specifically, the described embodiments can: (1) select a base instruction; (2) keep track of a dependency chain from the base instruction; (3) clear the dependency chain either when base instruction retires or when spec NTs <b>508</b> are converted to NTs <b>510</b> following the deferral of the base instruction; and (4) select a new base instruction to start the process again.</p>
<p id="p-0096" num="0095">Note that having a second dependency record being tracked while the first dependency record still has its NTs <b>510</b> asserted is not incorrect, because even if multiple dependency chains have NTs <b>510</b> asserted at the same time, the NTs <b>510</b> still apply to entries that are dependent on a deferred instruction.</p>
<p id="p-0097" num="0096">Although we describe embodiments where only one dependency chain is kept, alternative embodiments can keep track of multiple dependency chains simultaneously. For example, <figref idref="DRAWINGS">FIG. 6</figref> presents a block diagram illustrating an expanded view of scoreboard <b>402</b> in accordance with the described embodiments.</p>
<p id="p-0098" num="0097">As can be seen in <figref idref="DRAWINGS">FIG. 6</figref>, spec NT <b>508</b> has been replaced with spec NT <b>602</b> and spec NT <b>604</b>. Each of the spec NTs <b>602</b> and <b>604</b> can be used in keeping a record of a separate dependency chain. In other words, issue unit <b>204</b> can select two different base instructions and logic <b>512</b> can keep track of the instructions that are directly or indirectly dependent on each of the base instructions using spec NT <b>602</b> for the first base instruction and using spec NT <b>604</b> for the second base instruction. Aside from the selection of multiple base instructions and keeping track of associated dependency chains, these embodiments otherwise function similarly to the embodiments described above with respect to <figref idref="DRAWINGS">FIG. 5</figref>. Although we show an embodiment in <figref idref="DRAWINGS">FIG. 6</figref> that includes two spec NTs, <b>602</b> and <b>604</b>, alternative embodiments can include any number of spec NTs.</p>
<p id="p-0099" num="0098">In the described embodiments, the determination whether a given instruction has a dependency on a not-there register (i.e., a destination register for a deferred instruction) is made in issue unit <b>204</b>. In addition, the determination can be made for all the instructions in the dependency chain at once, enabling the earlier issue of any number of dependent instructions as soon as possible while maintaining program order, an operation that was not possible in previous processors that supported execute-ahead mode <b>302</b> and deferred mode <b>304</b>.</p>
<p id="p-0100" num="0099">Note that although we use the fields shown in <figref idref="DRAWINGS">FIGS. 5 and 6</figref> for explaining some of the operations that can be performed by the scoreboard and/or using information in the scoreboard, in alternative embodiments, more, fewer, or different fields can be present in scoreboard <b>402</b>. Generally, in the described embodiments, the fields in scoreboard <b>402</b> enable the tracking of dependencies between instructions as well as the determination of one or more dependency chains for corresponding base instruction(s).</p>
<p id="p-0101" num="0100">In some embodiments, entries in the scoreboard for instructions other than base instructions are handled as follows. If an instruction that is not a base instruction is determined by processor <b>102</b> to be not-there (i.e., is found to have an unresolved data dependency and is therefore deferred), issue unit <b>204</b> can update the entry for the instruction in scoreboard <b>402</b> and the entries for any dependent instructions so that they cannot cause instructions to be deferred (which can involve updating one or more of the fields in the entry to prevent instructions from being deferred). On the other hand, if an instruction that is not a base instruction is determined by processor <b>102</b> to have retired (or passed a pipeline stage where deferral is possible), processor <b>102</b> can clear the spec NT <b>508</b> and the NT <b>510</b> for the entry (e.g., set these values to zero, regardless as to whether a non-zero value was previously present in the fields of the entry or not).</p>
<p id="h-0010" num="0000">Process for Issuing an Instruction with an Unresolved Data Dependency</p>
<p id="p-0102" num="0101"><figref idref="DRAWINGS">FIG. 7</figref> presents a flowchart illustrating a process for resolving data dependencies in accordance with the described embodiments. The process shown in <figref idref="DRAWINGS">FIG. 7</figref> starts when decode unit <b>202</b> forwards a decoded instruction that alters data in a processor register to issue unit <b>204</b> (step <b>700</b>). Generally, any instruction that alters (writes, changes, or updates) the data in a processor register can be encountered; a LOAD instruction, an ADD instruction, a MOV instruction, a CMP instruction, or another instruction.</p>
<p id="p-0103" num="0102">Issue unit <b>204</b> then selects the instruction as a base instruction (step <b>702</b>). By selecting the instruction as the base instruction, issue unit <b>204</b> selects the instruction to be the first instruction in a dependency chain, which is a record of a sequence of instructions that are directly or indirectly dependent on the base instructions. Note that although we describe the selection of a particular instruction as a base instruction, in the described embodiments, issue unit <b>204</b> need not select a particular instruction. In some embodiments, issue unit <b>204</b> can select the first of a given type of instructions, can select an instruction at a given time (e.g., after M processor clock cycles) or after a given event, according to a hardware or software configuration switch, or as determined using another criterion. In some embodiments, when selecting an instruction, issue unit <b>204</b> can select a predetermined type of instruction, an instruction selected from a predetermined subset of instruction types, or can randomly select an instruction. In addition, in some embodiments, when selecting an instruction, issue unit <b>204</b> can select an instruction randomly or pseudo-randomly, select a first instruction encountered after a given time, or select an instruction based on a predetermined event.</p>
<p id="p-0104" num="0103">Issue unit <b>204</b> then updates an entry in scoreboard <b>402</b> in issue unit <b>204</b> with a record of the base instruction, including setting a speculative not-there (spec NT <b>508</b>) indicator in the entry (step <b>704</b>). As described above, setting the spec NT <b>508</b> in the entry causes issue unit <b>204</b> to begin keeping track of a dependency chain starting from the base instruction.</p>
<p id="p-0105" num="0104">For each subsequent instruction that is directly or indirectly dependent on the base instruction, when adding an entry to scoreboard <b>402</b>, set spec NT <b>508</b> in the entry (step <b>706</b>). By having the spec NT <b>508</b> set in the entry, each dependent instruction is added to the record of the dependency chain in issue unit <b>204</b>.</p>
<p id="p-0106" num="0105">Upon determining that the base instruction cannot be deferred, clear spec NT <b>508</b> for all the entries in the scoreboard that are directly or indirectly dependent on the base instruction (step <b>708</b>). Although different embodiments can be configured in different ways, determining that the base instruction cannot be deferred generally involves determining that the base instruction has reached a stage in the pipeline where deferring the instruction is no longer possible. In some embodiments, this can mean that the instruction has passed commit/trap unit <b>208</b> and is being retired (i.e., is out of the pipeline). However, in alternative embodiments, this determination can be made in any of the other stages of the processor.</p>
<p id="p-0107" num="0106">By clearing spec NT <b>508</b> for the entries in this way, issue unit <b>204</b> deletes the record of the dependency chain and clears the scoreboard to enable issue unit <b>204</b> to select a new base instruction and begin tracking a new dependency chain.</p>
<p id="p-0108" num="0107"><figref idref="DRAWINGS">FIG. 8</figref> presents a flowchart illustrating a process for resolving data dependencies in accordance with the described embodiments. The process shown in <figref idref="DRAWINGS">FIG. 8</figref> starts when decode unit <b>202</b> forwards a decoded instruction that alters data in a processor register to issue unit <b>204</b> (step <b>800</b>). Generally, any instruction that alters (writes, changes, or updates) the data in a processor register can be encountered; a LOAD instruction, an ADD instruction, a MOV instruction, a CMP instruction, or another instruction.</p>
<p id="p-0109" num="0108">Issue unit <b>204</b> then selects the instruction as a base instruction (step <b>802</b>). By selecting the instruction as the base instruction, issue unit <b>204</b> selects the instruction to be the first instruction in a dependency chain, which is a record of a sequence of instructions that are directly or indirectly dependent on the base instructions. Note that although we describe the selection of a particular instruction as a base instruction, in the described embodiments, issue unit <b>204</b> need not select a particular instruction. In some embodiments, issue unit <b>204</b> can select the first of a given type of instructions, can select an instruction at a given time (e.g., after M processor clock cycles) or after a given event, according to a hardware or software configuration switch, or as determined using another criterion. Moreover, issue unit <b>204</b> can select a predetermined type of instruction, an instruction selected from a predetermined subset of instruction types, or can randomly select an instruction.</p>
<p id="p-0110" num="0109">Issue unit <b>204</b> then updates an entry in scoreboard <b>402</b> in issue unit <b>204</b> with a record of the base instruction, including setting a speculative not-there (spec NT <b>508</b>) indicator in the entry (step <b>804</b>). As described above, setting the spec NT <b>508</b> in the entry causes issue unit <b>204</b> to begin keeping track of a dependency chain starting from the base instruction.</p>
<p id="p-0111" num="0110">For each subsequent instruction that is directly or indirectly dependent on the base instruction, when adding an entry to scoreboard <b>402</b>, set spec NT <b>508</b> in the entry (step <b>806</b>). By having the spec NT <b>508</b> set in the entry, each dependent instruction is added to the record of the dependency chain in issue unit <b>204</b>.</p>
<p id="p-0112" num="0111">Upon determining that the base instruction has encountered an unresolved data dependency (or another operating condition) and has been deferred, for each entry for which spec NT <b>508</b> is set, issue unit <b>204</b> sets NT <b>510</b> and then clears spec NT <b>508</b> (step <b>808</b>). As described above, by adjusting the NTs <b>508</b> in this way, issue unit <b>204</b> records that the affected entries should issue as soon as possible while maintaining program order (e.g., immediately upon reaching the head of the corresponding issue queue <b>404</b>).</p>
<p id="p-0113" num="0112">While subsequently issuing instructions, issue unit <b>204</b> issues instructions for which a NT <b>510</b> is set in a corresponding entry in the scoreboard as soon as the instructions reach the head of the corresponding issue queue <b>404</b> (step <b>810</b>).</p>
<p id="p-0114" num="0113">Upon issuing the last of the instructions in the dependency chain, issue unit <b>204</b> can clear the NTs <b>510</b> for each of the instructions. Alternatively, issue unit <b>204</b> can clear the NTs <b>510</b> for each of the instructions at another time, such as when the instructions retire.</p>
<p id="p-0115" num="0114">Note that embodiments that track multiple dependency chains may function similarly to the embodiments shown in <figref idref="DRAWINGS">FIGS. 6-7</figref>, but with some significant differences. Specifically, these embodiments can select at least two base instructions, and can use distinct spec NTs (e.g., spec NTs <b>602</b> and <b>604</b>) to keep the dependency chain record for each base instruction. In addition, each base instruction can separately be determined not to be deferrable, and the corresponding spec NTs can be cleared or the instructions can be issued as soon as possible in program order using NTs <b>510</b>.</p>
<p id="p-0116" num="0115"><figref idref="DRAWINGS">FIG. 9</figref> presents a flowchart illustrating a process for determining a base instruction in accordance with the described embodiments. The process shown in <figref idref="DRAWINGS">FIG. 9</figref> starts when decode unit <b>202</b> forwards a decoded instruction that alters data in a processor register to issue unit <b>204</b> (step <b>900</b>). Generally, any instruction that alters (writes, changes, or updates) the data in a processor register can be encountered; a LOAD instruction, an ADD instruction, a MOV instruction, a CMP instruction, or another instruction.</p>
<p id="p-0117" num="0116">Issue unit <b>204</b> then determines if any source operand of the instruction is marked not-there (&#x201c;NT&#x201d;) in scoreboard <b>402</b> (i.e., if the NT <b>510</b> is set for any source operand) (step <b>902</b>). If so, issue unit <b>204</b> sets the NT <b>510</b> for the instruction in scoreboard <b>402</b> (step <b>904</b>). Note that the NT is set in the event that an earlier instruction upon which the instruction is directly or indirectly dependent has been determined by processor <b>102</b> to have an unresolved dependency and been deferred (and hence the destination register for the instruction is marked NT). In addition, as described herein, a scoreboard entry can be marked not-there (i.e., have the NT <b>510</b> set for the entry) upon issue unit <b>204</b> determining that the spec NTs <b>508</b> within the scoreboard are to be merged into the NT <b>510</b>.</p>
<p id="p-0118" num="0117">Otherwise, if no source operand is marked NT, issue unit <b>204</b> determines if any source operand of the instruction is marked speculatively not-there (&#x201c;NT&#x201d;) in scoreboard <b>402</b> (i.e., if the spec NT <b>508</b> is set for any source operand) (step <b>906</b>). If so, issue unit <b>204</b> sets the spec NT <b>508</b> for an entry for the instruction in scoreboard <b>402</b> (step <b>908</b>). Issue unit <b>204</b> then continues register scoreboarding based on instruction latency (as is described above) (step <b>910</b>).</p>
<p id="p-0119" num="0118">Otherwise, if none of the source operands for the instruction are marked NT or speculatively NT, the instruction is a candidate to be a base instruction. In this case, issue unit <b>204</b> determines if the instruction is to be a base instruction. Specifically, the issue unit determines if the instruction can cause an NT (i.e., if the instruction can be deferred and have it and its dependent instructions marked not-there) and if there is sufficient room to track the NT in scoreboard <b>402</b> (step <b>912</b>). Note that checking if there is sufficient room involves determining if one or more of the dependency chain tracking mechanisms is available/is not currently being used to track NT for a different base instruction. If the instruction can cause an NT and space is available in scoreboard <b>402</b> for tracking a dependency chain based on the instruction, issue unit <b>204</b> marks the instruction as a base instruction (step <b>914</b>). Issue unit <b>204</b> then sets the speculative NT for the destination register (step <b>908</b>). Note that marking the instruction as a base instruction can involve an operation as simple as setting the speculative NT for the destination register alone (i.e., performing the operation in step <b>908</b>), or can involve updating one or more processor tracking mechanisms, variables, pipeline structures, etc. to record that the instruction is the base instruction. Issue unit <b>204</b> then continues register scoreboarding based on instruction latency (as is described above) (step <b>910</b>).</p>
<p id="p-0120" num="0119">The foregoing descriptions of embodiments have been presented only for purposes of illustration and description. They are not intended to be exhaustive or to limit the embodiments to the forms disclosed. Accordingly, many modifications and variations will be apparent to practitioners skilled in the art. Additionally, the above disclosure is not intended to limit the embodiments. The scope of the embodiments is defined by the appended claims.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for issuing instructions with unresolved data dependencies in a processor, comprising:
<claim-text>adding an entry for each in-flight instruction in the processor to a scoreboard;</claim-text>
<claim-text>within an issue unit in the processor,
<claim-text>keeping a record of each instruction that is directly or indirectly dependent on a base instruction by asserting a speculative not-there indicator in each entry in the scoreboard for an instruction that is directly or indirectly dependent on the base instruction; and</claim-text>
<claim-text>upon determining that the base instruction has been deferred,
<claim-text>monitoring instructions that are being issued from an issue queue to an execution unit for execution; and</claim-text>
<claim-text>upon determining that an instruction from the record has reached a head of the issue queue, immediately issuing the instruction from the issue queue, wherein determining that the instruction from the record has reached the head of the issue queue comprises determining that the instruction from the record is an instruction for which the speculative not-there bit was set.</claim-text>
</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein immediately issuing the instruction from the issue queue includes:
<claim-text>issuing the instruction without stalling the instruction at the head of the issue queue to await a return of a result from a prior instruction upon which the instruction depends.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein upon determining that the base instruction was deferred, the method further comprises:
<claim-text>for each entry in the scoreboard for which the speculative not-there indicator is asserted, asserting a not-there indicator in the entry in the scoreboard and clearing the speculative not-there indicator;</claim-text>
<claim-text>wherein determining that the instruction is an instruction for which the speculative not-there bit was set includes determining that the not-there indicator is asserted in a corresponding entry in the scoreboard.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the method further comprises clearing each of the not-there indicators as a corresponding instruction is issued for execution.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the method further comprises clearing each of the not-there indicators as a corresponding instruction completes execution.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the method further comprises clearing each of the speculative not-there indicators in the scoreboard when the base instruction completes execution without being deferred.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the method further comprises:
<claim-text>selecting the base instruction, wherein the base instruction is an instruction that modifies a value in a processor register;</claim-text>
<claim-text>wherein the base instruction is one of: a predetermined type of instruction, an instruction selected from a predetermined subset of instruction types, or a randomly selected instruction; and</claim-text>
<claim-text>wherein selecting the base instruction includes one of: selecting an instruction randomly or pseudo-randomly, selecting a first instruction encountered after a given time, or selecting an instruction based on a predetermined event.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the method further comprises:
<claim-text>receiving decoded instructions forwarded from a decode unit to the issue unit for issue to one or more execution units.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. A processor for issuing instructions based on unresolved data dependencies, comprising:
<claim-text>an issue unit in the processor, wherein the issue unit is configured to:
<claim-text>add an entry for each in-flight instruction in the processor to a scoreboard;</claim-text>
<claim-text>keep a record of each instruction that is directly or indirectly dependent on a base instruction by asserting a speculative not-there indicator in each entry in the scoreboard for an instruction that is directly or indirectly dependent on the base instruction;</claim-text>
<claim-text>upon determining that the base instruction has been deferred, monitor instructions that are being issued from an issue queue to an execution unit for execution; and</claim-text>
<claim-text>upon determining that an instruction from the record has reached a head of the issue queue, immediately issue the instruction from the issue queue, wherein determining that an instruction from the record has reached the head of the issue queue includes determining that the instruction is an instruction for which the speculative not-there bit was set.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The processor of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein when immediately issuing the instruction from the issue queue, the issue unit is configured to issue the instruction without stalling the instruction at the head of the issue queue to await a return of a result from a prior instruction upon which the instruction depends.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The processor of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein upon determining that the base instruction was deferred, for each entry in the scoreboard for which the speculative not-there indicator is asserted, the issue unit is configured to assert a not-there indicator in the entry in the scoreboard and clear the speculative not-there indicator; and
<claim-text>wherein when determining whether the instruction is an instruction for which the speculative not-there bit was set, the issue unit is configured to determine that the not-there indicator is asserted in a corresponding entry in the scoreboard.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The processor of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the issue unit is configured to clear each of the not-there indicators as a corresponding instruction is issued for execution.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The processor of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the issue unit is configured to clear each of the not-there indicators as a corresponding instruction completes execution.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The processor of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the issue unit is configured to clear each of the speculative not-there indicators in the scoreboard when the base instruction completes execution without being deferred.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The processor of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the issue unit is configured to select the base instruction, wherein the base instruction is an instruction that modifies a value in a processor register;
<claim-text>wherein when selecting the base instruction, the issue unit is configured to select a base instruction that is one of: a predetermined type of instruction, an instruction selected from a predetermined subset of instruction types, or a randomly selected instruction; and</claim-text>
<claim-text>wherein when selecting the base instruction, the issue unit is further configured to select a base instruction randomly or pseudo-randomly, select a first instruction encountered after a given time, or select an instruction based on a predetermined event.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The processor of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the issue unit is further configured to receive decoded instructions forwarded from a decode unit and issue decoded instructions to one or more execution units.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. A computer system for issuing instructions based on unresolved data dependencies, comprising:
<claim-text>a processor;</claim-text>
<claim-text>a memory coupled to the processor, wherein the memory stores instructions and data for the processor; and</claim-text>
<claim-text>an issue unit in the processor, wherein the issue unit is configured to:</claim-text>
<claim-text>add an entry for each in-flight instruction in the processor to a scoreboard;
<claim-text>keep a record of each instruction that is directly or indirectly dependent on the base instruction by asserting a speculative not-there indicator in each entry in the scoreboard for an instruction that is directly or indirectly dependent on the base instruction;</claim-text>
<claim-text>upon determining that the base instruction has been deferred, monitor instructions that are being issued from an issue queue to an execution unit for execution; and</claim-text>
<claim-text>upon determining that an instruction from the record has reached a head of the issue queue, immediately issue the instruction from the issue queue, wherein determining that an instruction from the record has reached the head of the issue queue includes determining that the instruction is an instruction for which the speculative not-there bit was set.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The computer system of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein when immediately issuing the instruction from the issue queue, the issue unit is configured to issue the instruction without stalling the instruction at the head of the issue queue to await a return of a result from a prior instruction upon which the instruction depends.</claim-text>
</claim>
</claims>
</us-patent-grant>
