<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627329-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627329</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12822615</doc-number>
<date>20100624</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>397</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>46</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>54</subgroup>
<symbol-position>L</symbol-position>
<classification-value>N</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>718105</main-classification>
<further-classification>719313</further-classification>
</classification-national>
<invention-title id="d2e53">Multithreaded physics engine with predictive load balancing</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6734853</doc-number>
<kind>B2</kind>
<name>Heim et al.</name>
<date>20040500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>7796135</doc-number>
<kind>B1</kind>
<name>Diard et al.</name>
<date>20100900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>2008/0192054</doc-number>
<kind>A1</kind>
<name>Fowler et al.</name>
<date>20080800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>345427</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2008/0231627</doc-number>
<kind>A1</kind>
<name>Shearer</name>
<date>20080900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>2009/0172014</doc-number>
<kind>A1</kind>
<name>Huetter</name>
<date>20090700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707103 R</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2010/0114633</doc-number>
<kind>A1</kind>
<name>Sislak et al.</name>
<date>20100500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>705  7</main-classification></classification-national>
</us-citation>
<us-citation>
<nplcit num="00007">
<othercit>U.S. Appl. No. 12/778,390, filed May 12, 2010 by Eric O. Mejdrich, Paul E. Schardt and Robert A. Shearer and entitled &#x201c;Streaming Physics Collision Detection in Multithreaded Rendering Software Pipeline.&#x201d;</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00008">
<othercit>U.S. Patent and Trademark Office, Office Action issued in related U.S. Appl. No. 12/778,390, dated Feb. 15, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00009">
<othercit>U.S. Patent and Trademark Office, Notice of Allowance issued in related U.S. Appl. No. 12/778,390, dated Jun. 10, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>1</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>718105</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>15</number-of-drawing-sheets>
<number-of-figures>24</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20110321057</doc-number>
<kind>A1</kind>
<date>20111229</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Mejdrich</last-name>
<first-name>Eric O.</first-name>
<address>
<city>Rochester</city>
<state>MN</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Schardt</last-name>
<first-name>Paul E.</first-name>
<address>
<city>Stewartville</city>
<state>MN</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Shearer</last-name>
<first-name>Robert A.</first-name>
<address>
<city>Rochester</city>
<state>MN</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="004" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Tubbs</last-name>
<first-name>Matthew R.</first-name>
<address>
<city>Rochester</city>
<state>MN</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Mejdrich</last-name>
<first-name>Eric O.</first-name>
<address>
<city>Rochester</city>
<state>MN</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Schardt</last-name>
<first-name>Paul E.</first-name>
<address>
<city>Stewartville</city>
<state>MN</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Shearer</last-name>
<first-name>Robert A.</first-name>
<address>
<city>Rochester</city>
<state>MN</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="004" designation="us-only">
<addressbook>
<last-name>Tubbs</last-name>
<first-name>Matthew R.</first-name>
<address>
<city>Rochester</city>
<state>MN</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Wood, Herron &#x26; Evans, LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Ho</last-name>
<first-name>Andy</first-name>
<department>2194</department>
</primary-examiner>
<assistant-examiner>
<last-name>Seye</last-name>
<first-name>Abdou</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A circuit arrangement and method utilize predictive load balancing to allocate the workload among hardware threads in a multithreaded physics engine. The predictive load balancing is based at least in part upon the detection of predicted future collisions between objects in a scene, such that the reallocation of respective loads of a plurality of hardware threads may be initiated prior to detection of the actual collisions, thereby increasing the likelihood that hardware threads will be optimally allocated when the actual collisions occur.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="231.31mm" wi="181.27mm" file="US08627329-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="224.96mm" wi="182.03mm" file="US08627329-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="235.20mm" wi="189.65mm" file="US08627329-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="240.96mm" wi="194.14mm" file="US08627329-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="226.82mm" wi="183.90mm" file="US08627329-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="212.77mm" wi="193.55mm" file="US08627329-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="248.58mm" wi="175.77mm" orientation="landscape" file="US08627329-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="214.04mm" wi="198.63mm" file="US08627329-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="175.60mm" wi="191.60mm" file="US08627329-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="256.03mm" wi="190.67mm" orientation="landscape" file="US08627329-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="255.52mm" wi="187.71mm" orientation="landscape" file="US08627329-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="214.29mm" wi="158.75mm" file="US08627329-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="252.48mm" wi="196.09mm" file="US08627329-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="235.20mm" wi="185.17mm" file="US08627329-20140107-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="177.55mm" wi="133.94mm" file="US08627329-20140107-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="238.42mm" wi="191.01mm" file="US08627329-20140107-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">FIELD OF THE INVENTION</heading>
<p id="p-0002" num="0001">The invention is generally related to data processing, and in particular to graphical imaging processing and rendering and physics collision detection in connection therewith.</p>
<heading id="h-0002" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0003" num="0002">The process of rendering two-dimensional images from three-dimensional scenes is commonly referred to as image processing. As the modern computer industry evolves image processing evolves as well. One particular goal in the evolution of image processing is to make two-dimensional simulations or renditions of three-dimensional scenes as realistic as possible.</p>
<p id="p-0004" num="0003">In addition, image processing is often used in connection with modeling or simulating real world scenarios where virtual or simulated objects representing physical, real world objects interact with one another in the simulated scenes. Video games, for example, are increasingly capable of depicting more and more realistic virtual environments, be it through the flight of a golf ball, the real world performance characteristics of a race car, the flight of an aircraft or the result of an explosion in a warfare game. In other commercial and scientific applications of image processing, e.g., flight simulation, ballistics simulation, etc., accurate modeling of the interactions of objects in a virtual environment is an even greater concern.</p>
<p id="p-0005" num="0004">In many modern data processing systems, the modeling of the real world interaction of objects is handled by computer software commonly referred to as a physics engine. A physics engine attempts to simulate physical phenomena though the use of rigid body dynamics, soft body dynamics and/or fluid dynamics principles. A key component of most physics engines is a collision detection/collision response system, which seeks to detect when objects in a virtual environment collide with one another. Based upon detected collisions, dynamics simulation is typically performed to resolve the forces and motions applied to the objects subsequent to the collisions.</p>
<p id="p-0006" num="0005">While some higher precision physics engines are not constrained by time, many others, particularly those used in interactive video gaming applications, are required to operate in &#x201c;real time.&#x201d; Consequently, the operations performed in connection with physics calculations, e.g., collision detection, often need to be completed quickly and efficiently.</p>
<p id="p-0007" num="0006">Conventional collision detection techniques typically operate in a serial, single threaded application were each object in motion is tested against all other objects in the scene. In some instances, collision detection may utilize spatial culling to reduce the number of required collision calculations. Furthermore, objects may be modeled using level of detail (LOD) models to simplify objects down to more easily calculable shapes for the purpose of detecting when two objects come in contact. For example, many collision detection techniques use simple shapes such as spheres and other cubic volumes to represent more complex objects. More detailed bounding volumes can be devised in some applications to increase collision precision, however, doing so usually comes at the expense of more processing time and/or hardware requirements.</p>
<p id="p-0008" num="0007">With continued improvements in semiconductor technology in terms of clock speed and increased use of parallelism, the capabilities of real time physics engines will inevitably increase. At the chip level, multiple processor cores are often disposed on the same chip, functioning in much the same manner as separate processor chips, or to some extent, as completely separate computers. In addition, even within cores, parallelism is employed through the use of multiple execution units that are specialized to handle certain types of operations. Hardware-based pipelining is also employed in many instances so that certain operations that may take multiple clock cycles to perform are broken up into stages, enabling other operations to be started prior to completion of earlier operations. Multithreading is also employed to enable multiple instruction streams to be processed in parallel, enabling more overall work to performed in any given clock cycle.</p>
<p id="p-0009" num="0008">However, even with increased clock speed and parallelization, conventional collision detection techniques still present bottlenecks to performance in most conventional architectures. In particular, conventional techniques often require large numbers of random memory accesses in order to retrieve and manage objects in a scene, which has been found to cause low cache utilization and other performance related bottlenecks.</p>
<p id="p-0010" num="0009">Furthermore, distributing the workload among multiple parallel threads of execution can be problematic in many dynamic, real-time environments. In particular, the number of objects, and the distribution of those objects, within a given scene, can vary over time. Whereas at one point in time collisions between multiple objects, requiring substantial processing resources, may occur in one region of a scene, at a different time more extensive collisions, and thus, heavier processing workload, may occur in other regions of the scene.</p>
<p id="p-0011" num="0010">A need therefore continues to exist in the art for a manner of efficiently handing physics collision detection in a physics engine.</p>
<heading id="h-0003" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0012" num="0011">The invention addresses these and other problems associated with the prior art by providing a circuit arrangement and method that utilize predictive load balancing to allocate the workload among hardware threads in a multithreaded physics engine. The predictive load balancing is based at least in part upon the detection of predicted future collisions between objects in a scene, such that the reallocation of respective loads of a plurality of hardware threads may be initiated prior to detection of the actual collisions, thereby increasing the likelihood that hardware threads will be optimally allocated when the actual collisions occur. Put another way, embodiments consistent with the invention look ahead one or more steps in time in an attempt to ensure that an optimal allocation of hardware threads is available when a collision does occur.</p>
<p id="p-0013" num="0012">Therefore, consistent with one aspect of the invention, load balancing is performed among a plurality of hardware threads in a multithreaded physics engine by allocating workload among the plurality of hardware threads in the multithreaded physics engine, detecting a future collision between objects in a scene, and initiating a workload reallocation among the plurality of hardware threads in response to detecting the future collision.</p>
<p id="p-0014" num="0013">These and other advantages and features, which characterize the invention, are set forth in the claims annexed hereto and forming a further part hereof. However, for a better understanding of the invention, and of the advantages and objectives attained through its use, reference should be made to the Drawings, and to the accompanying descriptive matter, in which there is described exemplary embodiments of the invention.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram of exemplary automated computing machinery including an exemplary computer useful in data processing consistent with embodiments of the present invention.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram of an exemplary NOC implemented in the computer of <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 3</figref> is a block diagram illustrating in greater detail an exemplary implementation of a node from the NOC of <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 4</figref> is a block diagram illustrating an exemplary implementation of an IP block from the NOC of <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 5</figref> is a block diagram of a thread pipelined software engine suitable for implementation in the NOC of <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 6</figref> is a block diagram of an exemplary software pipeline suitable for implementation in the thread pipelined software engine of <figref idref="DRAWINGS">FIG. 5</figref>.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 7</figref> is a block diagram of an exemplary rendering software pipeline suitable for implementation in the thread pipelined software engine of <figref idref="DRAWINGS">FIG. 5</figref>.</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 8</figref> is a diagram of an exemplary scene for illustrating the generation of a geometry internal representation using the GIR generator of <figref idref="DRAWINGS">FIG. 7</figref>.</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 9</figref> is a block diagram of a geometry internal representation generated for the exemplary scene of <figref idref="DRAWINGS">FIG. 9</figref>.</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 10</figref> is a flowchart illustrating the program flow of a geometry placement routine executed by the GIR generator of <figref idref="DRAWINGS">FIG. 7</figref>.</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 11</figref> is a flowchart illustrating the program flow of an add geometry routine executed by the GIR generator of <figref idref="DRAWINGS">FIG. 7</figref>.</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 12</figref> is a block diagram of an exemplary implementation of the streaming geometry frontend referenced in <figref idref="DRAWINGS">FIG. 7</figref>.</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 13</figref> is a block diagram of an exemplary implementation of the ray tracing backend referenced in <figref idref="DRAWINGS">FIG. 7</figref>.</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIGS. 14A and 14B</figref> collectively illustrate in greater detail an implementation of the rendering software pipeline of <figref idref="DRAWINGS">FIG. 7</figref>.</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 15</figref> a diagram of an exemplary scene for illustrating collision detection in a manner consistent with the invention.</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 16</figref> is a block diagram of an exemplary NOC suitable for implementing collision detection in a manner consistent with the invention.</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 17</figref> is flowchart illustrating the program flow of an exemplary collision detection routine executed by a master thread in the NOC of <figref idref="DRAWINGS">FIG. 16</figref>.</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 18</figref> is flowchart illustrating the program flow of an exemplary collision detection routine executed by a slave thread in the NOC of <figref idref="DRAWINGS">FIG. 16</figref>.</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 19</figref> is a diagram of an exemplary scene for illustrating predictive load balancing in a manner consistent with the invention.</p>
<p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. 20</figref> is a flowchart illustrating the program flow of an exemplary physics engine incorporating predictive load balancing in a manner consistent with the invention.</p>
<p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. 21</figref> is a flowchart illustrating the program flow of the predictive load balancing routine referenced in <figref idref="DRAWINGS">FIG. 20</figref>.</p>
<p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. 22</figref> is flowchart illustrating the program flow of an exemplary collision detection routine executed by a master thread in the NOC of <figref idref="DRAWINGS">FIG. 16</figref>, and utilizing predictive load balancing consistent with the invention.</p>
<p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. 23</figref> is flowchart illustrating the program flow of an exemplary collision detection routine executed by a slave thread in the NOC of <figref idref="DRAWINGS">FIG. 16</figref>, and utilizing predictive load balancing consistent with the invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0038" num="0037">Embodiments consistent with the invention implement predictive load balancing in a multithreaded physics engine to initiate an early reallocation of workload among a plurality of hardware threads based upon predicted future collisions between objects in a scene. A scene, within the context of the invention, refers to the &#x201c;world&#x201d; or multidimensional space within which objects are placed prior to rendering of an image frame. Typically, a scene is a three dimensional object space; however, to simplify the discussion hereinafter, many of the examples illustrate a two dimensional scene. It will be appreciated however that a scene may be any number of dimensions consistent with the invention.</p>
<p id="p-0039" num="0038">In some embodiments, a physics engine with predictive load balancing may implement physics collision detection by streaming level of detail components between hardware threads in a multithreaded circuit arrangement, e.g., as disclosed in U.S. patent application Ser. No. 12/778,390, filed May 12, 2010 and assigned to the same assignee as the present application, which is incorporated by reference herein. In such embodiments, a component loader hardware thread, operating as a master thread, is used to retrieve level of detail data for an object from a memory and stream the data to one or more collision detection threads, operating as slave hardware threads. Slave hardware threads may also stream level of detail data to other slave hardware threads, e.g., slave hardware threads arranged further down a software pipeline. Because the slave hardware threads receive level of detail data from the master thread, typically the slave hardware threads are not required to load the data from the memory, thereby reducing memory bandwidth requirements and accelerating performance.</p>
<p id="p-0040" num="0039">Other variations and modifications will be apparent to one of ordinary skill in the art. Therefore, the invention is not limited to the specific implementations discussed herein.</p>
<heading id="h-0006" level="1">Hardware and Software Environment</heading>
<p id="p-0041" num="0040">Now turning to the drawings, wherein like numbers denote like parts throughout the several views, <figref idref="DRAWINGS">FIG. 1</figref> illustrates exemplary automated computing machinery including an exemplary computer <b>10</b> useful in data processing consistent with embodiments of the present invention. Computer <b>10</b> of <figref idref="DRAWINGS">FIG. 1</figref> includes at least one computer processor <b>12</b> or &#x2018;CPU&#x2019; as well as random access memory <b>14</b> (&#x2018;RAM&#x2019;), which is connected through a high speed memory bus <b>16</b> and bus adapter <b>18</b> to processor <b>12</b> and to other components of the computer <b>10</b>.</p>
<p id="p-0042" num="0041">Stored in RAM <b>14</b> is an application program <b>20</b>, a module of user-level computer program instructions for carrying out particular data processing tasks such as, for example, word processing, spreadsheets, database operations, video gaming, stock market simulations, atomic quantum process simulations, or other user-level applications. Also stored in RAM <b>14</b> is an operating system <b>22</b>. Operating systems useful in connection with embodiments of the invention include UNIX&#x2122;, Linux&#x2122; Microsoft Windows XP&#x2122;, AIX&#x2122;, IBM's i5/OS&#x2122;, and others as will occur to those of skill in the art. Operating system <b>22</b> and application <b>20</b> in the example of <figref idref="DRAWINGS">FIG. 1</figref> are shown in RAM <b>14</b>, but many components of such software typically are stored in non-volatile memory also, e.g., on a disk drive <b>24</b>.</p>
<p id="p-0043" num="0042">As will become more apparent below, embodiments consistent with the invention may be implemented within Network On Chip (NOC) integrated circuit devices, or chips, and as such, computer <b>10</b> is illustrated including two exemplary NOCs: a video adapter <b>26</b> and a coprocessor <b>28</b>. NOC video adapter <b>26</b>, which may alternatively be referred to as a graphics adapter, is an example of an I/O adapter specially designed for graphic output to a display device <b>30</b> such as a display screen or computer monitor. NOC video adapter <b>26</b> is connected to processor <b>12</b> through a high speed video bus <b>32</b>, bus adapter <b>18</b>, and the front side bus <b>34</b>, which is also a high speed bus. NOC Coprocessor <b>28</b> is connected to processor <b>12</b> through bus adapter <b>18</b>, and front side buses <b>34</b> and <b>36</b>, which is also a high speed bus. The NOC coprocessor of <figref idref="DRAWINGS">FIG. 1</figref> may be optimized, for example, to accelerate particular data processing tasks at the behest of the main processor <b>12</b>.</p>
<p id="p-0044" num="0043">The exemplary NOC video adapter <b>26</b> and NOC coprocessor <b>28</b> of <figref idref="DRAWINGS">FIG. 1</figref> each include a NOC, including integrated processor (&#x2018;IP&#x2019;) blocks, routers, memory communications controllers, and network interface controllers, the details of which will be discussed in greater detail below in connection with <figref idref="DRAWINGS">FIGS. 2-3</figref>. The NOC video adapter and NOC coprocessor are each optimized for programs that use parallel processing and also require fast random access to shared memory. It will be appreciated by one of ordinary skill in the art having the benefit of the instant disclosure, however, that the invention may be implemented in devices and device architectures other than NOC devices and device architectures. The invention is therefore not limited to implementation within an NOC device.</p>
<p id="p-0045" num="0044">Computer <b>10</b> of <figref idref="DRAWINGS">FIG. 1</figref> includes disk drive adapter <b>38</b> coupled through an expansion bus <b>40</b> and bus adapter <b>18</b> to processor <b>12</b> and other components of the computer <b>10</b>. Disk drive adapter <b>38</b> connects non-volatile data storage to the computer <b>10</b> in the form of disk drive <b>24</b>, and may be implemented, for example, using Integrated Drive Electronics (&#x2018;IDE&#x2019;) adapters, Small Computer System Interface (&#x2018;SCSI&#x2019;) adapters, and others as will occur to those of skill in the art. Non-volatile computer memory also may be implemented for as an optical disk drive, electrically erasable programmable read-only memory (so-called &#x2018;EEPROM&#x2019; or &#x2018;Flash&#x2019; memory), RAM drives, and so on, as will occur to those of skill in the art.</p>
<p id="p-0046" num="0045">Computer <b>10</b> also includes one or more input/output (&#x2018;I/O&#x2019;) adapters <b>42</b>, which implement user-oriented input/output through, for example, software drivers and computer hardware for controlling output to display devices such as computer display screens, as well as user input from user input devices <b>44</b> such as keyboards and mice. In addition, computer <b>10</b> includes a communications adapter <b>46</b> for data communications with other computers <b>48</b> and for data communications with a data communications network <b>50</b>. Such data communications may be carried out serially through RS-232 connections, through external buses such as a Universal Serial Bus (&#x2018;USB&#x2019;), through data communications data communications networks such as IP data communications networks, and in other ways as will occur to those of skill in the art. Communications adapters implement the hardware level of data communications through which one computer sends data communications to another computer, directly or through a data communications network. Examples of communications adapters suitable for use in computer <b>10</b> include modems for wired dial-up communications, Ethernet (IEEE 802.3) adapters for wired data communications network communications, and 802.11 adapters for wireless data communications network communications.</p>
<p id="p-0047" num="0046">For further explanation, <figref idref="DRAWINGS">FIG. 2</figref> sets forth a functional block diagram of an example NOC <b>102</b> according to embodiments of the present invention. The NOC in <figref idref="DRAWINGS">FIG. 2</figref> is implemented on a &#x2018;chip&#x2019; <b>100</b>, that is, on an integrated circuit. NOC <b>102</b> includes integrated processor (&#x2018;IP&#x2019;) blocks <b>104</b>, routers <b>110</b>, memory communications controllers <b>106</b>, and network interface controllers <b>108</b> grouped into interconnected nodes. Each IP block <b>104</b> is adapted to a router <b>110</b> through a memory communications controller <b>106</b> and a network interface controller <b>108</b>. Each memory communications controller controls communications between an IP block and memory, and each network interface controller <b>108</b> controls inter-IP block communications through routers <b>110</b>.</p>
<p id="p-0048" num="0047">In NOC <b>102</b>, each IP block represents a reusable unit of synchronous or asynchronous logic design used as a building block for data processing within the NOC. The term &#x2018;IP block&#x2019; is sometimes expanded as &#x2018;intellectual property block,&#x2019; effectively designating an IP block as a design that is owned by a party, that is the intellectual property of a party, to be licensed to other users or designers of semiconductor circuits. In the scope of the present invention, however, there is no requirement that IP blocks be subject to any particular ownership, so the term is always expanded in this specification as &#x2018;integrated processor block.&#x2019; IP blocks, as specified here, are reusable units of logic, cell, or chip layout design that may or may not be the subject of intellectual property. IP blocks are logic cores that can be formed as ASIC chip designs or FPGA logic designs.</p>
<p id="p-0049" num="0048">One way to describe IP blocks by analogy is that IP blocks are for NOC design what a library is for computer programming or a discrete integrated circuit component is for printed circuit board design. In NOCs consistent with embodiments of the present invention, IP blocks may be implemented as generic gate netlists, as complete special purpose or general purpose microprocessors, or in other ways as may occur to those of skill in the art. A netlist is a Boolean-algebra representation (gates, standard cells) of an IP block's logical-function, analogous to an assembly-code listing for a high-level program application. NOCs also may be implemented, for example, in synthesizable form, described in a hardware description language such as Verilog or VHDL. In addition to netlist and synthesizable implementation, NOCs also may be delivered in lower-level, physical descriptions. Analog IP block elements such as SERDES, PLL, DAC, ADC, and so on, may be distributed in a transistor-layout format such as GDSII. Digital elements of IP blocks are sometimes offered in layout format as well. It will also be appreciated that IP blocks, as well as other logic circuitry implemented consistent with the invention may be distributed in the form of computer data files, e.g., logic definition program code, that define at various levels of detail the functionality and/or layout of the circuit arrangements implementing such logic. Thus, while the invention has and hereinafter will be described in the context of circuit arrangements implemented in fully functioning integrated circuit devices, data processing systems utilizing such devices, and other tangible, physical hardware circuits, those of ordinary skill in the art having the benefit of the instant disclosure will appreciate that the invention may also be implemented within a program product, and that the invention applies equally regardless of the particular type of computer readable storage medium or computer readable signal bearing medium being used to distribute the program product. Examples of computer readable storage media include, but are not limited to, physical, recordable type media such as volatile and non-volatile memory devices, floppy disks, hard disk drives, CD-ROMs, and DVDs (among others), while examples of computer readable signal bearing media include, but are not limited to, transmission type media such as digital and analog communication links.</p>
<p id="p-0050" num="0049">Each IP block <b>104</b> in the example of <figref idref="DRAWINGS">FIG. 2</figref> is adapted to a router <b>110</b> through a memory communications controller <b>106</b>. Each memory communication controller is an aggregation of synchronous and asynchronous logic circuitry adapted to provide data communications between an IP block and memory. Examples of such communications between IP blocks and memory include memory load instructions and memory store instructions. The memory communications controllers <b>106</b> are described in more detail below with reference to <figref idref="DRAWINGS">FIG. 3</figref>. Each IP block <b>104</b> is also adapted to a router <b>110</b> through a network interface controller <b>108</b>, which controls communications through routers <b>110</b> between IP blocks <b>104</b>. Examples of communications between IP blocks include messages carrying data and instructions for processing the data among IP blocks in parallel applications and in pipelined applications. The network interface controllers <b>108</b> are also described in more detail below with reference to <figref idref="DRAWINGS">FIG. 3</figref>.</p>
<p id="p-0051" num="0050">Routers <b>110</b>, and the corresponding links <b>118</b> therebetween, implement the network operations of the NOC. The links <b>118</b> may be packet structures implemented on physical, parallel wire buses connecting all the routers. That is, each link may be implemented on a wire bus wide enough to accommodate simultaneously an entire data switching packet, including all header information and payload data. If a packet structure includes 64 bytes, for example, including an eight byte header and 56 bytes of payload data, then the wire bus subtending each link is 64 bytes wide, 512 wires. In addition, each link may be bi-directional, so that if the link packet structure includes 64 bytes, the wire bus actually contains 1024 wires between each router and each of its neighbors in the network. In such an implementation, a message could include more than one packet, but each packet would fit precisely onto the width of the wire bus. In the alternative, a link may be implemented on a wire bus that is only wide enough to accommodate a portion of a packet, such that a packet would be broken up into multiple beats, e.g., so that if a link is implemented as 16 bytes in width, or <b>128</b> wires, a 64 byte packet could be broken into four beats. It will be appreciated that different implementations may used different bus widths based on practical physical limits as well as desired performance characteristics. If the connection between the router and each section of wire bus is referred to as a port, then each router includes five ports, one for each of four directions of data transmission on the network and a fifth port for adapting the router to a particular IP block through a memory communications controller and a network interface controller.</p>
<p id="p-0052" num="0051">Each memory communications controller <b>106</b> controls communications between an IP block and memory. Memory can include off-chip main RAM <b>112</b>, memory <b>114</b> connected directly to an IP block through a memory communications controller <b>106</b>, on-chip memory enabled as an IP block <b>116</b>, and on-chip caches. In NOC <b>102</b>, either of the on-chip memories <b>114</b>, <b>116</b>, for example, may be implemented as on-chip cache memory. All these forms of memory can be disposed in the same address space, physical addresses or virtual addresses, true even for the memory attached directly to an IP block. Memory addressed messages therefore can be entirely bidirectional with respect to IP blocks, because such memory can be addressed directly from any IP block anywhere on the network. Memory <b>116</b> on an IP block can be addressed from that IP block or from any other IP block in the NOC. Memory <b>114</b> attached directly to a memory communication controller can be addressed by the IP block that is adapted to the network by that memory communication controller&#x2014;and can also be addressed from any other IP block anywhere in the NOC.</p>
<p id="p-0053" num="0052">NOC <b>102</b> includes two memory management units (&#x2018;MMUs&#x2019;) <b>120</b>, <b>122</b>, illustrating two alternative memory architectures for NOCs consistent with embodiments of the present invention. MMU <b>120</b> is implemented within an IP block, allowing a processor within the IP block to operate in virtual memory while allowing the entire remaining architecture of the NOC to operate in a physical memory address space. MMU <b>122</b> is implemented off-chip, connected to the NOC through a data communications port <b>124</b>. The port <b>124</b> includes the pins and other interconnections required to conduct signals between the NOC and the MMU, as well as sufficient intelligence to convert message packets from the NOC packet format to the bus format required by the external MMU <b>122</b>. The external location of the MMU means that all processors in all IP blocks of the NOC can operate in virtual memory address space, with all conversions to physical addresses of the off-chip memory handled by the off-chip MMU <b>122</b>.</p>
<p id="p-0054" num="0053">In addition to the two memory architectures illustrated by use of the MMUs <b>120</b>, <b>122</b>, data communications port <b>126</b> illustrates a third memory architecture useful in NOCs capable of being utilized in embodiments of the present invention. Port <b>126</b> provides a direct connection between an IP block <b>104</b> of the NOC <b>102</b> and off-chip memory <b>112</b>. With no MMU in the processing path, this architecture provides utilization of a physical address space by all the IP blocks of the NOC. In sharing the address space bi-directionally, all the IP blocks of the NOC can access memory in the address space by memory-addressed messages, including loads and stores, directed through the IP block connected directly to the port <b>126</b>. The port <b>126</b> includes the pins and other interconnections required to conduct signals between the NOC and the off-chip memory <b>112</b>, as well as sufficient intelligence to convert message packets from the NOC packet format to the bus format required by the off-chip memory <b>112</b>.</p>
<p id="p-0055" num="0054">In the example of <figref idref="DRAWINGS">FIG. 2</figref>, one of the IP blocks is designated a host interface processor <b>128</b>. A host interface processor <b>128</b> provides an interface between the NOC and a host computer <b>10</b> in which the NOC may be installed and also provides data processing services to the other IP blocks on the NOC, including, for example, receiving and dispatching among the IP blocks of the NOC data processing requests from the host computer. A NOC may, for example, implement a video graphics adapter <b>26</b> or a coprocessor <b>28</b> on a larger computer <b>10</b> as described above with reference to <figref idref="DRAWINGS">FIG. 1</figref>. In the example of <figref idref="DRAWINGS">FIG. 2</figref>, the host interface processor <b>128</b> is connected to the larger host computer through a data communications port <b>130</b>. The port <b>130</b> includes the pins and other interconnections required to conduct signals between the NOC and the host computer, as well as sufficient intelligence to convert message packets from the NOC to the bus format required by the host computer <b>10</b>. In the example of the NOC coprocessor in the computer of <figref idref="DRAWINGS">FIG. 1</figref>, such a port would provide data communications format translation between the link structure of the NOC coprocessor <b>28</b> and the protocol required for the front side bus <b>36</b> between the NOC coprocessor <b>28</b> and the bus adapter <b>18</b>.</p>
<p id="p-0056" num="0055"><figref idref="DRAWINGS">FIG. 3</figref> next illustrates a functional block diagram illustrating in greater detail the components implemented within an IP block <b>104</b>, memory communications controller <b>106</b>, network interface controller <b>108</b> and router <b>110</b> in NOC <b>102</b>, collectively illustrated at <b>132</b>. IP block <b>104</b> includes a computer processor <b>134</b> and I/O functionality <b>136</b>. In this example, computer memory is represented by a segment of random access memory (&#x2018;RAM&#x2019;) <b>138</b> in IP block <b>104</b>. The memory, as described above with reference to <figref idref="DRAWINGS">FIG. 2</figref>, can occupy segments of a physical address space whose contents on each IP block are addressable and accessible from any IP block in the NOC. The processors <b>134</b>, I/O capabilities <b>136</b>, and memory <b>138</b> in each IP block effectively implement the IP blocks as generally programmable microcomputers. As explained above, however, in the scope of the present invention, IP blocks generally represent reusable units of synchronous or asynchronous logic used as building blocks for data processing within a NOC. Implementing IP blocks as generally programmable microcomputers, therefore, although a common embodiment useful for purposes of explanation, is not a limitation of the present invention.</p>
<p id="p-0057" num="0056">In NOC <b>102</b> of <figref idref="DRAWINGS">FIG. 3</figref>, each memory communications controller <b>106</b> includes a plurality of memory communications execution engines <b>140</b>. Each memory communications execution engine <b>140</b> is enabled to execute memory communications instructions from an IP block <b>104</b>, including bidirectional memory communications instruction flow <b>141</b>, <b>142</b>, <b>144</b> between the network and the IP block <b>104</b>. The memory communications instructions executed by the memory communications controller may originate, not only from the IP block adapted to a router through a particular memory communications controller, but also from any IP block <b>104</b> anywhere in NOC <b>102</b>. That is, any IP block in the NOC can generate a memory communications instruction and transmit that memory communications instruction through the routers of the NOC to another memory communications controller associated with another IP block for execution of that memory communications instruction. Such memory communications instructions can include, for example, translation lookaside buffer control instructions, cache control instructions, barrier instructions, and memory load and store instructions.</p>
<p id="p-0058" num="0057">Each memory communications execution engine <b>140</b> is enabled to execute a complete memory communications instruction separately and in parallel with other memory communications execution engines. The memory communications execution engines implement a scalable memory transaction processor optimized for concurrent throughput of memory communications instructions. Memory communications controller <b>106</b> supports multiple memory communications execution engines <b>140</b> all of which run concurrently for simultaneous execution of multiple memory communications instructions. A new memory communications instruction is allocated by the memory communications controller <b>106</b> to a memory communications engine <b>140</b> and memory communications execution engines <b>140</b> can accept multiple response events simultaneously. In this example, all of the memory communications execution engines <b>140</b> are identical. Scaling the number of memory communications instructions that can be handled simultaneously by a memory communications controller <b>106</b>, therefore, is implemented by scaling the number of memory communications execution engines <b>140</b>.</p>
<p id="p-0059" num="0058">In NOC <b>102</b> of <figref idref="DRAWINGS">FIG. 3</figref>, each network interface controller <b>108</b> is enabled to convert communications instructions from command format to network packet format for transmission among the IP blocks <b>104</b> through routers <b>110</b>. The communications instructions may be formulated in command format by the IP block <b>104</b> or by memory communications controller <b>106</b> and provided to the network interface controller <b>108</b> in command format. The command format may be a native format that conforms to architectural register files of IP block <b>104</b> and memory communications controller <b>106</b>. The network packet format is typically the format required for transmission through routers <b>110</b> of the network. Each such message is composed of one or more network packets. Examples of such communications instructions that are converted from command format to packet format in the network interface controller include memory load instructions and memory store instructions between IP blocks and memory. Such communications instructions may also include communications instructions that send messages among IP blocks carrying data and instructions for processing the data among IP blocks in parallel applications and in pipelined applications.</p>
<p id="p-0060" num="0059">In NOC <b>102</b> of <figref idref="DRAWINGS">FIG. 3</figref>, each IP block is enabled to send memory-address-based communications to and from memory through the IP block's memory communications controller and then also through its network interface controller to the network. A memory-address-based communications is a memory access instruction, such as a load instruction or a store instruction, that is executed by a memory communication execution engine of a memory communications controller of an IP block. Such memory-address-based communications typically originate in an IP block, formulated in command format, and handed off to a memory communications controller for execution.</p>
<p id="p-0061" num="0060">Many memory-address-based communications are executed with message traffic, because any memory to be accessed may be located anywhere in the physical memory address space, on-chip or off-chip, directly attached to any memory communications controller in the NOC, or ultimately accessed through any IP block of the NOC&#x2014;regardless of which IP block originated any particular memory-address-based communication. Thus, in NOC <b>102</b>, all memory-address-based communications that are executed with message traffic are passed from the memory communications controller to an associated network interface controller for conversion from command format to packet format and transmission through the network in a message. In converting to packet format, the network interface controller also identifies a network address for the packet in dependence upon the memory address or addresses to be accessed by a memory-address-based communication. Memory address based messages are addressed with memory addresses. Each memory address is mapped by the network interface controllers to a network address, typically the network location of a memory communications controller responsible for some range of physical memory addresses. The network location of a memory communication controller <b>106</b> is naturally also the network location of that memory communication controller's associated router <b>110</b>, network interface controller <b>108</b>, and IP block <b>104</b>. The instruction conversion logic <b>150</b> within each network interface controller is capable of converting memory addresses to network addresses for purposes of transmitting memory-address-based communications through routers of a NOC.</p>
<p id="p-0062" num="0061">Upon receiving message traffic from routers <b>110</b> of the network, each network interface controller <b>108</b> inspects each packet for memory instructions. Each packet containing a memory instruction is handed to the memory communications controller <b>106</b> associated with the receiving network interface controller, which executes the memory instruction before sending the remaining payload of the packet to the IP block for further processing. In this way, memory contents are always prepared to support data processing by an IP block before the IP block begins execution of instructions from a message that depend upon particular memory content.</p>
<p id="p-0063" num="0062">In NOC <b>102</b> of <figref idref="DRAWINGS">FIG. 3</figref>, each IP block <b>104</b> is enabled to bypass its memory communications controller <b>106</b> and send inter-IP block, network-addressed communications <b>146</b> directly to the network through the IP block's network interface controller <b>108</b>. Network-addressed communications are messages directed by a network address to another IP block. Such messages transmit working data in pipelined applications, multiple data for single program processing among IP blocks in a SIMD application, and so on, as will occur to those of skill in the art. Such messages are distinct from memory-address-based communications in that they are network addressed from the start, by the originating IP block which knows the network address to which the message is to be directed through routers of the NOC. Such network-addressed communications are passed by the IP block through I/O functions <b>136</b> directly to the IP block's network interface controller in command format, then converted to packet format by the network interface controller and transmitted through routers of the NOC to another IP block. Such network-addressed communications <b>146</b> are bi-directional, potentially proceeding to and from each IP block of the NOC, depending on their use in any particular application. Each network interface controller, however, is enabled to both send and receive such communications to and from an associated router, and each network interface controller is enabled to both send and receive such communications directly to and from an associated IP block, bypassing an associated memory communications controller <b>106</b>.</p>
<p id="p-0064" num="0063">Each network interface controller <b>108</b> in the example of <figref idref="DRAWINGS">FIG. 3</figref> is also enabled to implement virtual channels on the network, characterizing network packets by type. Each network interface controller <b>108</b> includes virtual channel implementation logic <b>148</b> that classifies each communication instruction by type and records the type of instruction in a field of the network packet format before handing off the instruction in packet form to a router <b>110</b> for transmission on the NOC. Examples of communication instruction types include inter-IP block network-address-based messages, request messages, responses to request messages, invalidate messages directed to caches; memory load and store messages; and responses to memory load messages, etc.</p>
<p id="p-0065" num="0064">Each router <b>110</b> in the example of <figref idref="DRAWINGS">FIG. 3</figref> includes routing logic <b>152</b>, virtual channel control logic <b>154</b>, and virtual channel buffers <b>156</b>. The routing logic typically is implemented as a network of synchronous and asynchronous logic that implements a data communications protocol stack for data communication in the network formed by the routers <b>110</b>, links <b>118</b>, and bus wires among the routers. Routing logic <b>152</b> includes the functionality that readers of skill in the art might associate in off-chip networks with routing tables, routing tables in at least some embodiments being considered too slow and cumbersome for use in a NOC. Routing logic implemented as a network of synchronous and asynchronous logic can be configured to make routing decisions as fast as a single clock cycle. The routing logic in this example routes packets by selecting a port for forwarding each packet received in a router. Each packet contains a network address to which the packet is to be routed.</p>
<p id="p-0066" num="0065">In describing memory-address-based communications above, each memory address was described as mapped by network interface controllers to a network address, a network location of a memory communications controller. The network location of a memory communication controller <b>106</b> is naturally also the network location of that memory communication controller's associated router <b>110</b>, network interface controller <b>108</b>, and IP block <b>104</b>. In inter-IP block, or network-address-based communications, therefore, it is also typical for application-level data processing to view network addresses as the location of an IP block within the network formed by the routers, links, and bus wires of the NOC. <figref idref="DRAWINGS">FIG. 2</figref> illustrates that one organization of such a network is a mesh of rows and columns in which each network address can be implemented, for example, as either a unique identifier for each set of associated router, IP block, memory communications controller, and network interface controller of the mesh or x, y coordinates of each such set in the mesh.</p>
<p id="p-0067" num="0066">In NOC <b>102</b> of <figref idref="DRAWINGS">FIG. 3</figref>, each router <b>110</b> implements two or more virtual communications channels, where each virtual communications channel is characterized by a communication type. Communication instruction types, and therefore virtual channel types, include those mentioned above: inter-IP block network-address-based messages, request messages, responses to request messages, invalidate messages directed to caches; memory load and store messages; and responses to memory load messages, and so on. In support of virtual channels, each router <b>110</b> in the example of <figref idref="DRAWINGS">FIG. 3</figref> also includes virtual channel control logic <b>154</b> and virtual channel buffers <b>156</b>. The virtual channel control logic <b>154</b> examines each received packet for its assigned communications type and places each packet in an outgoing virtual channel buffer for that communications type for transmission through a port to a neighboring router on the NOC.</p>
<p id="p-0068" num="0067">Each virtual channel buffer <b>156</b> has finite storage space. When many packets are received in a short period of time, a virtual channel buffer can fill up&#x2014;so that no more packets can be put in the buffer. In other protocols, packets arriving on a virtual channel whose buffer is full would be dropped. Each virtual channel buffer <b>156</b> in this example, however, is enabled with control signals of the bus wires to advise surrounding routers through the virtual channel control logic to suspend transmission in a virtual channel, that is, suspend transmission of packets of a particular communications type. When one virtual channel is so suspended, all other virtual channels are unaffected&#x2014;and can continue to operate at full capacity. The control signals are wired all the way back through each router to each router's associated network interface controller <b>108</b>. Each network interface controller is configured to, upon receipt of such a signal, refuse to accept, from its associated memory communications controller <b>106</b> or from its associated IP block <b>104</b>, communications instructions for the suspended virtual channel. In this way, suspension of a virtual channel affects all the hardware that implements the virtual channel, all the way back up to the originating IP blocks.</p>
<p id="p-0069" num="0068">One effect of suspending packet transmissions in a virtual channel is that no packets are ever dropped. When a router encounters a situation in which a packet might be dropped in some unreliable protocol such as, for example, the Internet Protocol, the routers in the example of <figref idref="DRAWINGS">FIG. 3</figref> may suspend by their virtual channel buffers <b>156</b> and their virtual channel control logic <b>154</b> all transmissions of packets in a virtual channel until buffer space is again available, eliminating any need to drop packets. The NOC of <figref idref="DRAWINGS">FIG. 3</figref>, therefore, may implement highly reliable network communications protocols with an extremely thin layer of hardware.</p>
<p id="p-0070" num="0069">The example NOC of <figref idref="DRAWINGS">FIG. 3</figref> may also be configured to maintain cache coherency between both on-chip and off-chip memory caches. Each NOC can support multiple caches each of which operates against the same underlying memory address space. For example, caches may be controlled by IP blocks, by memory communications controllers, or by cache controllers external to the NOC. Either of the on-chip memories <b>114</b>, <b>116</b> in the example of <figref idref="DRAWINGS">FIG. 2</figref> may also be implemented as an on-chip cache, and, within the scope of the present invention, cache memory can be implemented off-chip also.</p>
<p id="p-0071" num="0070">Each router <b>110</b> illustrated in <figref idref="DRAWINGS">FIG. 3</figref> includes five ports, four ports <b>158</b>A-D connected through bus wires <b>118</b> to other routers and a fifth port <b>160</b> connecting each router to its associated IP block <b>104</b> through a network interface controller <b>108</b> and a memory communications controller <b>106</b>. As can be seen from the illustrations in <figref idref="DRAWINGS">FIGS. 2 and 3</figref>, the routers <b>110</b> and the links <b>118</b> of the NOC <b>102</b> form a mesh network with vertical and horizontal links connecting vertical and horizontal ports in each router. In the illustration of <figref idref="DRAWINGS">FIG. 3</figref>, for example, ports <b>158</b>A, <b>158</b>C and <b>160</b> are termed vertical ports, and ports <b>158</b>B and <b>158</b>D are termed horizontal ports.</p>
<p id="p-0072" num="0071"><figref idref="DRAWINGS">FIG. 4</figref> next illustrates in another manner one exemplary implementation of an IP block <b>104</b> consistent with the invention, implemented as a processing element partitioned into an instruction unit (IU) <b>162</b>, execution unit (XU) <b>164</b> and auxiliary execution unit (AXU) <b>166</b>. In the illustrated implementation, IU <b>162</b> includes a plurality of instruction buffers <b>168</b> that receive instructions from an L1 instruction cache (iCACHE) <b>170</b>. Each instruction buffer <b>168</b> is dedicated to one of a plurality, e.g., four, symmetric multithreaded (SMT) hardware threads. An effective-to-real translation unit (iERAT) <b>172</b> is coupled to iCACHE <b>170</b>, and is used to translate instruction fetch requests from a plurality of thread fetch sequencers <b>174</b> into real addresses for retrieval of instructions from lower order memory. Each thread fetch sequencer <b>174</b> is dedicated to a particular hardware thread, and is used to ensure that instructions to be executed by the associated thread is fetched into the iCACHE for dispatch to the appropriate execution unit. As also shown in <figref idref="DRAWINGS">FIG. 4</figref>, instructions fetched into instruction buffer <b>168</b> may also be monitored by branch prediction logic <b>176</b>, which provides hints to each thread fetch sequencer <b>174</b> to minimize instruction cache misses resulting from branches in executing threads.</p>
<p id="p-0073" num="0072">IU <b>162</b> also includes a dependency/issue logic block <b>178</b> dedicated to each hardware thread, and configured to resolve dependencies and control the issue of instructions from instruction buffer <b>168</b> to XU <b>164</b>. In addition, in the illustrated embodiment, separate dependency/issue logic <b>180</b> is provided in AXU <b>166</b>, thus enabling separate instructions to be concurrently issued by different threads to XU <b>164</b> and AXU <b>166</b>. In an alternative embodiment, logic <b>180</b> may be disposed in IU <b>162</b>, or may be omitted in its entirety, such that logic <b>178</b> issues instructions to AXU <b>166</b>.</p>
<p id="p-0074" num="0073">XU <b>164</b> is implemented as a fixed point execution unit, including a set of general purpose registers (GPR's) <b>182</b> coupled to fixed point logic <b>184</b>, branch logic <b>186</b> and load/store logic <b>188</b>. Load/store logic <b>188</b> is coupled to an L1 data cache (dCACHE) <b>190</b>, with effective to real translation provided by dERAT logic <b>192</b>. XU <b>164</b> may be configured to implement practically any instruction set, e.g., all or a portion of a 32b or 64b PowerPC instruction set.</p>
<p id="p-0075" num="0074">AXU <b>166</b> operates as an auxiliary execution unit including dedicated dependency/issue logic <b>180</b> along with one or more execution blocks <b>194</b>. AXU <b>166</b> may include any number of execution blocks, and may implement practically any type of execution unit, e.g., a floating point unit, or one or more specialized execution units such as encryption/decryption units, coprocessors, vector processing units, graphics processing units, XML processing units, etc. In the illustrated embodiment, AXU <b>166</b> includes a high speed auxiliary interface to XU <b>164</b>, e.g., to support direct moves between AXU architected state and XU architected state.</p>
<p id="p-0076" num="0075">Communication with IP block <b>104</b> may be managed in the manner discussed above in connection with <figref idref="DRAWINGS">FIG. 2</figref>, via network interface controller <b>108</b> coupled to NOC <b>102</b>. Address-based communication, e.g., to access L2 cache memory, may be provided, along with message-based communication. For example, each IP block <b>104</b> may include a dedicated in box and/or out box in order to handle inter-node communications between IP blocks.</p>
<p id="p-0077" num="0076">Embodiments of the present invention may be implemented within the hardware and software environment described above in connection with <figref idref="DRAWINGS">FIGS. 1-4</figref>. However, it will be appreciated by one of ordinary skill in the art having the benefit of the instant disclosure that the invention may be implemented in a multitude of different environments, and that other modifications may be made to the aforementioned hardware and software embodiment without departing from the spirit and scope of the invention. As such, the invention is not limited to the particular hardware and software environment disclosed herein.</p>
<heading id="h-0007" level="1">Software Pipelining</heading>
<p id="p-0078" num="0077">Turning now to <figref idref="DRAWINGS">FIG. 5</figref>, NOC <b>102</b> may be used in some embodiments to implement a software-based pipeline. In particular, <figref idref="DRAWINGS">FIG. 5</figref> illustrates an exemplary processing unit <b>200</b> incorporating a thread pipelined software engine <b>202</b> that may be used to implement and execute one or more software pipelines <b>204</b> on top of an NOC architecture. Each pipeline <b>204</b> is typically allocated one or more data structures <b>206</b> in a shared memory <b>208</b> to enable different stages of a pipeline to exchange data. Furthermore, an interrupt mechanism <b>210</b> is provided to enable stages of a pipeline to notify one another of pending work to be performed.</p>
<p id="p-0079" num="0078">One or more host interface processors (HIP's) <b>212</b> are also provided in engine <b>202</b> to handle the issue of work to software pipelines <b>204</b>. One or more push buffers <b>214</b> are provided to interface each HIP <b>212</b> with a software application <b>216</b> and driver <b>218</b>, which are resident outside of the engine. In order to initiate work in a pipeline, a software application <b>216</b> issues requests through an appropriate driver <b>218</b> in the form of API calls, which then generates appropriate requests for the HIP and stores the requests in a push buffer <b>214</b>. The HIP <b>212</b> for the relevant pipeline pulls work requests off of push buffer <b>214</b> and initiates processing of the request by the associated pipeline.</p>
<p id="p-0080" num="0079">In the illustrated embodiment, and as implemented on a NOC <b>102</b>, a software pipeline <b>204</b> implements a function that is segmented into a set of modules or &#x2018;stages&#x2019; of computer program instructions that cooperate with one another to carry out a series of data processing tasks in sequence. Each stage in a pipeline is composed of a flexibly configurable module of computer program instructions identified by a stage <b>1</b>D with each stage executing on a thread of execution on an IP block <b>104</b> of a NOC <b>102</b>. The stages are flexibly configurable in that each stage may support multiple instances of the stage, so that a pipeline may be scaled by instantiating additional instances of a stage as needed depending on workload. Because each stage is implemented by computer program instructions executing on an IP block <b>104</b> of a NOC <b>102</b>, each stage is capable of accessing addressed memory through a memory communications controller <b>106</b>. At least one stage, moreover, is capable of sending network-address based communications among other stages, where the network-address based communications maintain packet order.</p>
<p id="p-0081" num="0080">The network-address based communications, for example, may be implemented using &#x201c;inboxes&#x201d; in each stage that receive data and/or commands from preceding stages in the pipeline. The network-address based communications maintain packet order, and are communications of a same type which are able to flow through the same virtual channel as described above. Each packet in such communications is routed by a router <b>110</b> in the manner described above, entering and leaving a virtual channel buffer in sequence, in FIFO order, thereby maintaining strict packet order and preserving message integrity.</p>
<p id="p-0082" num="0081">Each stage implements a producer/consumer relationship with a next stage. The first stage receives work instructions and work piece data through a HIP <b>212</b>, carries out its designated data processing tasks on the work piece, produces output data, and sends the produced output data to the next stage in the pipeline, which consumes the produced output data from the first stage by carrying out its designated data processing tasks on the produced output data from the first stage, thereby producing output data that is subsequently sent on to a next stage in the pipeline. This sequence of operations continues to the last stage of the pipeline, which then stores its produced output data in an output data structure for eventual return through the HIP <b>212</b> to the originating application <b>216</b>.</p>
<p id="p-0083" num="0082">The arrangement of stages in a pipeline may vary in different embodiments, as well as for performing different functions in different applications. <figref idref="DRAWINGS">FIG. 6</figref>, for example, illustrates an exemplary software pipeline <b>220</b> including a plurality of stage instances <b>222</b>, also separately designated as instances A-I, each of which representing a thread of execution implemented on an IP block in NOC <b>102</b>. The stage instances <b>222</b> are arranged in pipeline <b>220</b> into five stages, a first stage with instance A, a second stage with instances B and C, a third stage with instances D, E and F, a fourth stage with instances G and H, and a fifth stage with instance I. As can be seen from <figref idref="DRAWINGS">FIG. 6</figref>, instances may have a one-to-one, a one-to-many and/or a many-to-one relationship with other instances in the pipeline. Instances may operate collectively with one another in a particular stage to perform parallel tasks and share the workload, thus improving the overall throughput of the stage in performing the task. Instances in a stage may also perform different tasks from one another to enable the parallel performance of different tasks. Instances can supply data to more than one instance, while other instances may collect data and process data from multiple instances.</p>
<p id="p-0084" num="0083">In the illustrated embodiment, each instance of each stage of a pipeline is typically implemented as an application-level module of computer program instructions executed on a separate IP block on a NOC, and each stage is assigned to a thread of execution on an IP block of a NOC. Each stage is assigned a stage <b>1</b>D, and each instance of a stage is assigned an identifier. HIP <b>212</b> (<figref idref="DRAWINGS">FIG. 5</figref>) typically sets up the pipeline by configuring each stage with a desired number of instances, with the network location of each instance of each stage provided to other instances of other stages to enable each instance to send its resultant workload to the proper instance in the next stage. earlier and/or later stage <b>3</b> to which an instance of stage <b>2</b> is authorized to send its resultant workload. Multiple instances may be assigned to a particular stage to provide additional processing resources relative to other stages, e.g., so work flows through the pipeline as efficiently as possible, and no single stage presents a bottleneck to performance. It will also be appreciated that workload monitoring may be performed during runtime, and that instances may be dynamically added or removed from a stage as needed for balancing the load among the stages of the pipeline.</p>
<p id="p-0085" num="0084">Each stage is configured with a stage <b>1</b>D for each instance of a next stage, which may also include the number of instances in the next stage as well as the network location of each instance of that. Configuring a stage with IDs for instances of a next stage provides the stage with the information needed to carry out load balancing across stages. Such load balancing can be carried out, for example, by monitoring the performance of the stages and instantiating a number of instances of each stage in dependence upon the performance of one or more of the stages. Monitoring the performance of the stages can be carried out by configuring each stage to report performance statistics to a separate monitoring application that in turn is installed and running on another thread of execution on an IP block or HIP. Performance statistics can include, for example, time required to complete a data processing task, a number of data processing tasks completed within a particular time period, and so on, as will occur to those of skill in the art. Instantiating a number of instances of each stage in dependence upon the performance of one or more of the stages can be carried out by instantiating, by an HIP, a new instance of a stage when monitored performance indicates a need for a new instance.</p>
<heading id="h-0008" level="1">Pipeline Rendering Architecture</heading>
<p id="p-0086" num="0085">Now turning to <figref idref="DRAWINGS">FIG. 7</figref>, this figure illustrates an implementation of processing unit <b>200</b> configured to implement a pipeline rendering architecture that may be used in connection with a physics engine consistent with the invention. In particular, <figref idref="DRAWINGS">FIG. 7</figref> illustrates a hybrid rendering software pipeline <b>230</b> incorporating a streaming geometry frontend <b>232</b> interfaced with a ray tracing backend <b>234</b> via a GIR generator <b>236</b>. Streaming geometry frontend <b>232</b> may be implemented, for example, as an OpenGL or DirectX compatible frontend, e.g., as is used in a number of different raster-based techniques, that streams a set of primitives for a scene. Frontend <b>232</b> also may natively support the OpenGL or DirectX API's, and as such, may be accessed by an application <b>216</b> developed for use with a raster-based rendering algorithm via API calls that are converted by driver <b>218</b> into work requests, which are sent to HIP <b>212</b> via push buffer <b>214</b> to initiate implementation of those API calls by frontend <b>232</b>.</p>
<p id="p-0087" num="0086">GIR generator <b>236</b>, in turn, processes the stream of primitives output by streaming geometry frontend <b>232</b> to dynamically generate and store a geometry internal representation (GIR) data structure <b>238</b> in memory <b>208</b>. GIR <b>238</b> functions as an accelerated data structure (ADS), and as such is used by ray tracing backend <b>234</b> to render a frame of image data for a scene to a frame buffer <b>240</b>. GIR generator <b>236</b> dynamically generates the GIR using a plurality of parallel threads of execution, or hardware threads, and as such, reduces the likelihood of GIR generation serving as a bottleneck on overall performance. In addition, if desired, backend <b>234</b> is permitted to begin accessing the GIR in parallel with the GIR generator dynamically building the GIR, and prior to the GIR generator completing the GIR. As an alternative, backend <b>234</b> may not operate on the GIR until after construction of the GIR is complete. As yet another alternative, frontend <b>232</b> and backend <b>234</b> may operate on different frames of data, such that frontend <b>232</b> streams primitive data to GIR generator <b>236</b> to build a GIR for one frame while backend <b>234</b> is processing the GIR for an earlier generated frame.</p>
<p id="p-0088" num="0087">So configured, streaming frontend <b>232</b>, GIR generator <b>236</b> and ray tracing backend <b>234</b> are each amenable to execution by a plurality of parallel threads of execution. Furthermore, GIR generator <b>236</b> serves to adapt the output of a streaming geometry frontend, ordinarily configured for use with a raster-based backend, for use with a physical rendering backend such as a ray tracing or photon mapping backend. As such, the same API as would be used for a raster-based rendering technique may be repurposed for physical rendering, often without requiring changes to the API or to an application that makes calls to the API.</p>
<heading id="h-0009" level="1">Dynamic ADS Generation</heading>
<p id="p-0089" num="0088">An ADS may be used to enable a physical rendering algorithm such as a ray tracing algorithm to quickly and efficiently determine with which regions of a scene an issued ray intersects any objects within a scene to be rendered. An ADS may be implemented, for example, as a spatial index, which divides a three-dimensional scene or world into smaller volumes (smaller relative to the entire three-dimensional scene) which may or may not contain primitives. An image processing system can then use the known boundaries of these smaller volumes to determine if a ray may intersect primitives contained within the smaller volumes. If a ray does intersect a volume containing primitives, then a ray intersection test can be run using the trajectory of the ray against the known location and dimensions of the primitives contained within that volume. If a ray does not intersect a particular volume then there is no need to run ray-primitive intersection tests against the primitives contained within that volume. Furthermore, if a ray intersects a bounding volume that does not contain primitives then there is no need to run ray-primitive intersections tests against that bounding volume. Thus, by reducing the number of ray-primitive intersection tests that may be necessary, the use of a spatial index greatly increases the performance of a ray tracing image processing system. Some examples of different spatial index acceleration data structures are oct-trees, k dimensional Trees (kd-Trees), and binary space partitioning trees (BSP trees). While several different spatial index structures exist, and may be used in connection with the physical rendering techniques disclosed herein, the illustrated embodiments rely on a branch tree implemented as a base b tree split up into smaller trees of depth k.</p>
<p id="p-0090" num="0089">By way of example, <figref idref="DRAWINGS">FIGS. 8 and 9</figref> illustrate a relatively simple branch tree implementation that uses axis aligned bounding volumes to partition the entire scene or space into smaller volumes. That is, the branch tree may divide a three-dimensional space encompassed by a scene through the use of splitting planes which are parallel to known axes. The splitting planes partition a larger space into smaller bounding volumes. Together the smaller bounding volumes make up the entire space in the scene. The determination to partition (divide) a larger bounding volume into two smaller bounding volumes may be made by the image processing system through the use of a branch tree construction algorithm.</p>
<p id="p-0091" num="0090">One criterion for determining when to partition a bounding volume into smaller volumes may be the number of primitives contained within the bounding volume. That is, as long as a bounding volume contains more primitives than a predetermined threshold, the tree construction algorithm may continue to divide volumes by drawing more splitting planes. Another criterion for determining when to partition a bounding volume into smaller volumes may be the amount of space contained within the bounding volume. Furthermore, a decision to continue partitioning the bounding volume may also be based on how many primitives may be intersected by the plane which creates the bounding volume.</p>
<p id="p-0092" num="0091">The partitioning of the scene may be represented, for example, by a binary tree structure made up of nodes, branches and leaves. Each internal node within the tree may represent a relatively large bounding volume, while the node may contain branches to sub-nodes which may represent two relatively smaller partitioned volumes resulting after a partitioning of the relatively large bounding volume by a splitting plane. In an axis-aligned branch tree, each internal node may contain only two branches to other nodes. The internal node may contain branches (i.e., pointers) to one or two leaf nodes. A leaf node is a node which is not further sub-divided into smaller volumes and contains pointers to primitives. An internal node may also contain branches to other internal nodes which are further sub-divided. An internal node may also contain the information needed to determine along what axis the splitting plane was drawn and where along the axis the splitting plane was drawn.</p>
<p id="p-0093" num="0092"><figref idref="DRAWINGS">FIG. 8</figref>, for example, illustrates an example two dimensional space to be rendered by an image processing system, while <figref idref="DRAWINGS">FIG. 9</figref> illustrates a corresponding branch tree <b>258</b>, comprising nodes <b>260</b>-<b>268</b>, for the primitives shown in <figref idref="DRAWINGS">FIG. 8</figref>. For simplicity, a two dimensional scene is used to illustrate the building of a branch tree, however branch trees may also be used to represent three-dimensional scenes. In the two dimensional illustration of <figref idref="DRAWINGS">FIG. 8</figref>, for example, splitting lines are illustrated instead of splitting planes, and bounding areas are illustrated instead of bounding volumes as would be used in a three-dimensional structure. However, one skilled in the art will quickly recognize that the concepts may easily be applied to a three-dimensional scene containing objects.</p>
<p id="p-0094" num="0093"><figref idref="DRAWINGS">FIG. 8</figref> illustrates a two dimensional scene <b>250</b> containing primitives <b>252</b>A, <b>252</b>B and <b>252</b>C to be rendered in the final image. The largest volume which represents the entire volume of the scene is encompassed by bounding volume <b>1</b> (BV<sub>1</sub>) (which is not shown separately in <figref idref="DRAWINGS">FIG. 8</figref> because it encompasses the entire scene). In the corresponding branch tree this may be represented by the top level node <b>260</b>, also known as the root or world node. In one embodiment, an image processing system may continue to partition bounding volumes into smaller bounding volumes when the bounding volume contains, for example, more than two primitives. As noted earlier the decision to continue partitioning a bounding volume into smaller bounding volumes may be based on many factors, however for ease of explanation in this example the decision to continue partitioning a bounding volume is based only on the number of primitives.</p>
<p id="p-0095" num="0094">Thus, for example, as can be seen in <figref idref="DRAWINGS">FIG. 8</figref>, BV<sub>1 </sub>may be broken into two smaller bounding volumes BV<sub>2 </sub>and BV<sub>3 </sub>by drawing a splitting plane <b>254</b> along the x-axis at point X<sub>1</sub>. This partitioning of BV<sub>1 </sub>is also reflected in the branch tree as the two nodes <b>262</b> and <b>264</b>, corresponding to BV<sub>2 </sub>and BV<sub>3 </sub>respectively, under the internal (interior) or parent node BV<sub>1 </sub><b>260</b>. The internal node representing BV<sub>1 </sub>may now store information such as, but not limited to, pointers to the two nodes beneath BV<sub>1 </sub>(e.g., BV<sub>2 </sub>and BV<sub>3</sub>), along which axis the splitting plane was drawn (e.g., x-axis), and where along the axis the splitting plane was drawn (e.g., at point x<sub>1</sub>).</p>
<p id="p-0096" num="0095">Bounding volume BV<sub>3 </sub>may then be broken into two smaller bounding values BV<sub>4 </sub>and BV<sub>5 </sub>by drawing a splitting plane <b>256</b> along the y-axis at point Y<sub>1</sub>. Since BV<sub>3 </sub>has been partitioned into two sub-nodes it may now be referred to as an internal node. The partitioning of BV<sub>3 </sub>is also reflected in the branch tree as the two leaf nodes <b>266</b> and <b>268</b>, corresponding to BV<sub>4 </sub>and BV<sub>5</sub>, respectively. BV<sub>4 </sub>and BV<sub>5 </sub>are leaf nodes because the volumes they represent are not further divided into smaller bounding volumes. The two leaf nodes, BV<sub>4 </sub>and BV<sub>5</sub>, are located under the internal node BV<sub>3 </sub>which represents the bounding volume which was partitioned in the branch tree.</p>
<p id="p-0097" num="0096">The internal node representing BV<sub>3 </sub>may store information such as, but not limited to, pointers to the two leaf nodes (i.e., BV<sub>4 </sub>and BV<sub>5</sub>), along which axis the splitting plane was drawn (i.e., y-axis), and where along the axis the splitting plane was drawn (i.e., at point Y<sub>1</sub>).</p>
<p id="p-0098" num="0097">Thus, if a traced ray is projected through a point (X, Y) in bounding volume BV<sub>5</sub>, a ray tracing algorithm may quickly and efficiently determine what primitives need to be checked for intersection by traversing through the tree starting at node <b>260</b>, determining from the X coordinate of the point that the point is in bounding volume BV<sub>3 </sub>and traversing to node <b>264</b>, determining from the Y coordinate of the point that the point is in bounding volume BV<sub>5 </sub>and traversing to node <b>268</b>. Node <b>268</b> provides access to the primitive data for primitives <b>252</b>C, and thus, the ray tracing algorithm can perform intersection tests against those primitives.</p>
<p id="p-0099" num="0098"><figref idref="DRAWINGS">FIGS. 10 and 11</figref> next illustrate a branch tree generation algorithm suitable for use in GIR generator <b>236</b> to generate a GIR implemented as a form of branch tree that is capable of being generated in a highly parallel manner. The herein-described branch tree generation algorithm generates a dynamically built accelerated data structure (ADS) for streaming data on a highly parallel machine, based upon a relatively building and traversal algorithm, that uses minimal memory and memory bandwidth, and that typically requires no additional information than common rendering API's such as DirectX and OpenGL currently supply.</p>
<p id="p-0100" num="0099">A branch tree generated by the herein-described embodiment is implemented as a base b tree split up into smaller trees of depth k, where each small tree may be referred to as a branch. If a leaf node in the branch is an interior node of the larger tree it will contain a pointer to another branch continuing the tree. If objects are only allowed to be placed at leaf nodes of the smaller trees there is no need to contain the upper levels of the depth k tree and the tree can therefore be looked at as a base b<sup>k </sup>tree. In one embodiment, the branch tree is an oct-tree split up into small trees of depth 2 that allows data to be stored only at even levels, which is essentially equivalent to a base 64 tree.</p>
<p id="p-0101" num="0100">The branch tree may also be considered as an expanding grid. An initial grid of 64 voxels is made. If small enough geometry exists inside one of these voxels, another 64 voxel grid, or branch, is made inside it. The pattern is continued until a significant or maximum depth of grids/branches is reached. From the standpoint of storage, however, each branch is stored simply as 64 nodes, as shown below:</p>
<p id="p-0102" num="0101">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="left"/>
<colspec colname="3" colwidth="133pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>&#x2003;</entry>
<entry>struct branch{</entry>
</row>
<row>
<entry/>
<entry/>
<entry>&#x2003; node nodes[64];</entry>
</row>
<row>
<entry/>
<entry/>
<entry>};</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0103" num="0102">In the illustrated embodiment, the nodes of the branch are 4-byte words that either contain a pointer to geometry, list of geometry, a null value, or an indexed offset to another branch. If a node in the branch contains one or more pieces of geometry it will contain a pointer to the geometry or list of geometry. It is desirable for the address of the geometry or geometry list to be larger than the number of branches that will make the tree as the node data type may be determined by the node's unsigned integer value being larger or smaller than this threshold. If a node is empty it contains a null value. If it is an interior node it contains an offset to the branch that continues the tree beyond it. The offset is an index into a list of branches that is built during the construction process of the tree. For example, a node may have a structure such as:</p>
<p id="p-0104" num="0103">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="28pt" align="left"/>
<colspec colname="3" colwidth="147pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>&#x2003;</entry>
<entry>struct node{</entry>
</row>
<row>
<entry/>
<entry/>
<entry>&#x2003;union {</entry>
</row>
<row>
<entry/>
<entry/>
<entry>&#x2003;&#x2003;uint offset;</entry>
</row>
<row>
<entry/>
<entry/>
<entry>&#x2003;&#x2003;geometry *geo;</entry>
</row>
<row>
<entry/>
<entry/>
<entry>&#x2003;&#x2003;geometry_list * geo_list;</entry>
</row>
<row>
<entry/>
<entry/>
<entry>&#x2003;};</entry>
</row>
<row>
<entry/>
<entry/>
<entry>}</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
while a geometry list may have a structure such as:
</p>
<p id="p-0105" num="0104">
<tables id="TABLE-US-00003" num="00003">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="49pt" align="left"/>
<colspec colname="2" colwidth="28pt" align="left"/>
<colspec colname="3" colwidth="140pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>&#x2003;</entry>
<entry>struct geometry_list{</entry>
</row>
<row>
<entry/>
<entry/>
<entry>&#x2003;uint num_geometry;</entry>
</row>
<row>
<entry/>
<entry/>
<entry>&#x2003;geometry * geo_ptr;</entry>
</row>
<row>
<entry/>
<entry/>
<entry>};</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0106" num="0105">In the illustrated embodiment, the construction of the branch tree is designed to be performed dynamically and in parallel. The algorithm relies on two global variables, a pointer to the memory allocated for the tree and an integer next_offset that stores an index into this memory where a newly built branch can be stored. The index can either be shared globally or reserved memory can be split into groups to allow multiple next_offset pointers to be used. For simplicity of description, a single next_offset will be assumed; however, multiple offsets may be desirable in some embodiments to reduce memory conflicts.</p>
<p id="p-0107" num="0106">The algorithm also is provided with the maximum depth allowed by the tree. Because float numbers have a 24 bit significand, it may be desirable to enable each depth of a base 64 tree to use two bits in each direction, such that a maximum depth of max_d=12 may be used. A depth twelve base 64 branch tree has the equivalent precision to a 64<sup>12 </sup>voxel grid.</p>
<p id="p-0108" num="0107">To initialize the tree, the next_offset is set to 65 and a branch with all empty nodes (null value) is written to the first branch (top branch) in the memory allocation. No other steps are required.</p>
<p id="p-0109" num="0108">Thereafter, each streamed geometry primitive from the streaming geometry frontend is placed into the scene, using an instance of a routine such as routine <b>270</b> of <figref idref="DRAWINGS">FIG. 10</figref>. Thus, the GIR generator is configured to execute an instance of a placement routine in each of the plurality of parallel threads of execution allocated to the GIR generator to insert a plurality of primitives into the branch tree in parallel.</p>
<p id="p-0110" num="0109">The placement function receives as input a pointer to the geometry and the three dimensional mins and maxs converted from float world coordinates to integer grid coordinates. The grid coordinates assume a step size of one at the maximum depth. In addition, by using a few compares instead of masks, the tree building process can typically be performed without float to integer conversion.</p>
<p id="p-0111" num="0110">Routine <b>270</b> begins in block <b>272</b> by deciding at which nodes to place the geometry primitive. This process typically involves building keys from the min and max values. The keys can be built either with compares or from floats converted to integer values. In the illustrated embodiment, a compare with integer values is used. A 6 bit key is the node index in the current branch and is built of a set of x, y and z integer values for a point. The equation for building the tree is:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>node_key[0:5<i>]={x[</i>2*(max<sub>&#x2014;</sub><i>d&#x2212;d</i>):+1<i>],y[</i>2*(max<sub>&#x2014;</sub><i>d&#x2212;d</i>):+1<i>],z[</i>2*(max<sub>&#x2014;</sub><i>d&#x2212;d</i>):+1]};<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
where d is the current depth of the branch and max_d is the maximum depth of the tree where the nodes are cubes of integer volume <b>1</b>.
</p>
<p id="p-0112" num="0111">The algorithm can find all nodes relating to the geometry primitive by finding the x, y, and z components of the keys for the geometry's min and max points, and generating all possible keys between and including the min and max values. More precise methods may be used in the alternative.</p>
<p id="p-0113" num="0112">Thus, block <b>274</b> initiates a FOR loop, and for each node, retrieves the node in block <b>276</b>, determines whether the node is an interior node in block <b>278</b>, and if not, jumps to the next branch in block <b>280</b>.</p>
<p id="p-0114" num="0113">If, however, a node is determined to be a leaf node, rather than an interior node, block <b>278</b> passes control to block <b>282</b> to determine whether to place the geometry primitive at the current depth in the tree. Two factors may be used to make this determination. The first is what type of node it is in. If the node is an interior node then geometry exists below it and it will not be placed at that level, which is determined in block <b>278</b>. The second factor is the size of the geometry primitive. In the illustrated embodiment, the geometry primitive is placed if the node width is greater than four times the magnitude of the vector from the geometry primitive's min to max.</p>
<p id="p-0115" num="0114">If the decision is made to place the geometry primitive, control passes to tag and add the geometry primitive in block <b>284</b>, whereby the primitive is placed and the current iteration of routine <b>270</b> is complete. If it is decided to not place the geometry primitive at the current depth, the node is expanded in blocks <b>286</b>, <b>288</b>, <b>290</b> and <b>292</b>. Specifically, block <b>288</b> recursively calls routine <b>270</b> to place the geometry primitive in the new branch. Block <b>290</b> determines if any other geometry exists in the node, and if so, passes control to block <b>292</b> to recursively place the other geometry in the node by calling routine <b>270</b> for each tagged geometry primitive in the node. Upon completion of block <b>292</b>, or if the node is otherwise empty as determined in block <b>290</b>, routine <b>270</b> is complete.</p>
<p id="p-0116" num="0115">Thus, in the case of the node being an empty node, a new empty branch is created at the location indicated by *next_offset. The value of *next_offset is then stored in the expanding node and is incremented. This is how the tree is expanded and built. If the node contains existing tagged geometry primitives, the geometry is buried in order to turn the current node into an interior node. The existing geometry is buried after placing the new geometry primitive as it is smaller and will go deeper than the tagged geometry. As such, routine <b>270</b> ensures that all geometry gets pushed to the leaf nodes as they are expanded. Routine <b>270</b> therefore dynamically expands the branch tree whenever a primitive needs to be inserted into a full branch.</p>
<p id="p-0117" num="0116"><figref idref="DRAWINGS">FIG. 11</figref> illustrates an add geometry routine <b>300</b> that may be called, for example, in block <b>284</b> of routine <b>270</b> (<figref idref="DRAWINGS">FIG. 10</figref>). Routine <b>300</b> first determines what state (empty, single geometry, geometry list) the node is in using blocks <b>302</b> and <b>304</b> and acts accordingly.</p>
<p id="p-0118" num="0117">If the node's value is 0, the node is empty, and as such, block <b>302</b> passes control to block <b>306</b> to link to the new geometry by replacing the value in the node with a pointer to the geometry primitive being placed, whereby routine <b>300</b> will be complete. If the node has a non-zero value, block <b>304</b> determines whether the node stores a pointer to a single geometry primitive or a list of geometry, by loading the value at the pointed to address as an unsigned integer. If this integer value is inclusively between one and the maximum number of primitives allowed (e.g., 15), the pointer is determined to be a geometry_list pointer, as the value is the num_geometry component of a geometry_list. Otherwise, the value is considered to be a single geometry primitive.</p>
<p id="p-0119" num="0118">It is important to note that float values or binary values equal to integer values of 1 through 15 are permitted. In addition, by avoiding processing of a list when only a single geometry primitive exists in a node can save a significant amount of time and memory but is only applicable if either only one type of geometry primitive exists in a scene or if the geometry primitive is provided with a type header. Otherwise some sort of list will be required for all primitives.</p>
<p id="p-0120" num="0119">Geometry lists in the illustrated embodiment have an integer num_geometry indicating how many pieces of geometry are in the list, and a list of pointers to geometry. The allocated space for the number of pointers is even to lower the number of reallocations necessary. Therefore when a new piece of geometry is added to the list, if the num_geometry value is even, new memory space is allocated. If it is not even, a pointer to the geometry is simply appended to the end of the pointer list. Num_geometry is incremented in both cases.</p>
<p id="p-0121" num="0120">As such, if block <b>304</b> determines the node includes a single geometry primitive, control passes to block <b>308</b> to make a geometry list and add a link for the new geometry primitive to the new list. Otherwise, block <b>304</b> passes control to block <b>310</b> to determine if the list is full. If not, block <b>312</b> adds the geometry primitive to the list. If the list is full, block <b>314</b> determines if there are too many primitives in the node. If not, a new list is created with two additional spaces in block <b>316</b>, and the new geometry primitive is linked into the list. If the node is too full, however, block <b>318</b> buries the new and existing geometry primitives by recursively calling routine <b>270</b>.</p>
<p id="p-0122" num="0121">Of note, routines <b>270</b> and <b>300</b> are capable of being used in a parallel hardware architecture, as multiple instantiations of such routines may be used to concurrently place different primitives in the same branch tree. Consequently, assuming sufficient numbers of parallel threads of execution are allocated to an ADS generator that implements such routines, the generation of an ADS may occur at the same rate as primitives are streamed from the streaming geometry frontend, and once all of the primitive data has been streamed for a scene from the streaming geometry frontend, a fully constructed ADS is almost immediately available for use by a physical rendering backend.</p>
<p id="p-0123" num="0122">Now turning to <figref idref="DRAWINGS">FIG. 12</figref>, as noted above, a number of streaming geometry frontends may be used consistent with the invention. <figref idref="DRAWINGS">FIG. 12</figref>, for example illustrates a raster-based streaming geometry frontend <b>330</b> including a grouper <b>332</b>, geometry engine <b>334</b> and post geometry engine module <b>336</b>. Grouper <b>332</b> groups data for streaming down the pipeline, while geometry engine <b>334</b> performs object transformations and generates the geometry primitives. Module <b>336</b> performs operations such as perspective divides, culling, sorting, or breaking up geometry, and the end result output of module <b>336</b> is a stream of geometry primitives. It will be appreciated that a wide variety of streaming geometry frontend architectures may be used consistent with the invention, and as such, the invention is not limited to the particular architecture illustrated in <figref idref="DRAWINGS">FIG. 12</figref>.</p>
<p id="p-0124" num="0123"><figref idref="DRAWINGS">FIG. 13</figref> next illustrates a ray tracing implementation of a physical rendering backend <b>340</b> consistent with the invention. Backend <b>340</b> includes a master ray management module <b>342</b> that handles interfacing with the rendering front end, initiating and synchronizing all initial rays, performing performance monitoring and dynamic (or static) load balancing. One or more other ray management modules <b>344</b> functions as a slave ray manager that receives rays from the master or other slaves and traverses the ADS until determining if the ray intersects with a full leaf node or not. If not, the default background color is applied. If so, the ray is sent to a ray primitive intersect module <b>346</b>, which determines the intersections between rays and primitives. A color update module <b>348</b> updates pixels in a scene based upon the intersections detected between rays and primitives. It will be appreciated that a wide variety of ray tracing backend architectures may be used consistent with the invention, and as such, the invention is not limited to the particular architecture illustrated in <figref idref="DRAWINGS">FIG. 13</figref>.</p>
<p id="p-0125" num="0124">Implementation of a software pipeline to implement the aforementioned hybrid rendering functionality is illustrated at <b>400</b> in <figref idref="DRAWINGS">FIGS. 14A and 14B</figref>. <figref idref="DRAWINGS">FIG. 14A</figref>, in particular primarily illustrates the frontend aspects of the architecture, while <figref idref="DRAWINGS">FIG. 14B</figref> primarily illustrates the backend aspects of the architecture. Software pipeline <b>400</b> is implemented by a NOC resident in a graphics processor unit (GPU) coupled to a host processor (CPU) via a bus, e.g., a PCI express bus <b>414</b>.</p>
<p id="p-0126" num="0125">As shown in <figref idref="DRAWINGS">FIG. 14A</figref>, an application <b>402</b> utilizes a driver <b>404</b> to submit work requests to the software pipeline via a push buffer <b>406</b>. Application <b>402</b> and driver <b>404</b> are executed on the CPU, while push buffer <b>406</b> is resident in shared memory accessible to both the CPU and the GPU. Work requests are pulled from push buffer <b>406</b> by command processing logic, and in particular a host interface processor (HIP) <b>408</b>. In addition, driver state information is maintained in allocated memory <b>410</b>, <b>412</b> in the CPU and GPU, respectively. The states of the push buffer head and tail pointers for push buffer <b>406</b> are maintained at <b>416</b> and <b>418</b> in memory <b>410</b> while the state of the tail pointer is maintained at <b>420</b> in memory <b>420</b>.</p>
<p id="p-0127" num="0126">HIP <b>408</b> sets up the software pipeline, assigns threads of execution to stage instances in the pipeline, issues work requests to the pipeline, and monitors workflow to dynamically reallocate threads of execution to different stages of the pipeline to maximize throughput and minimize bottlenecks. In this regard, HIP <b>408</b>, which is itself typically implemented in an IP block from a NOC, assigns one or more IP blocks to handle each stage of the pipeline, as well as other supporting logic that may be required to manage operation of the pipeline. A thread of execution in this regard constitutes a hardware thread implemented within an IP block, it being understood that in IP blocks that support multiple hardware threads, multiple stage instances in a pipeline may be assigned to different threads in the same IP block.</p>
<p id="p-0128" num="0127">Examples of supporting logic include DMA engines <b>422</b>, <b>424</b>, which are respectively used to DMA vertex data from a vertex buffer <b>426</b> and compressed texture data from a texture data buffer <b>428</b>. A scratch memory <b>430</b>, including an index array <b>432</b>, vertex buffer <b>434</b> and compressed texture data <b>436</b>, serves as a destination for DMA engines <b>422</b>, <b>424</b>. HIP <b>408</b> sets up a set of inboxes <b>437</b> in DMA engines <b>422</b>, <b>424</b> to receive work requests from the HIP. One inbox <b>437</b> is provided for each DMA engine activated in the pipeline.</p>
<p id="p-0129" num="0128">An interrupt mechanism <b>441</b> is used in software pipeline <b>400</b> to enable inter-node communication between logical units in the pipeline. Nodes, e.g., HIP <b>408</b> and DMA engines <b>422</b>, <b>424</b> receive interrupts from mechanism <b>441</b>, and are capable of issuing interrupts to other nodes via memory mapped input/output (MMIO) requests issued to the interrupt mechanism.</p>
<p id="p-0130" num="0129">The frontend of pipeline <b>400</b> is implemented by a vertex processor including a first unit <b>450</b> configured as a grouper and a second unit <b>452</b> configured as a geometry shader, and a texture processor <b>454</b>.</p>
<p id="p-0131" num="0130">HIP <b>408</b> initiates work in the vertex processor <b>450</b>, <b>452</b> and texture processor <b>454</b> using inboxes <b>438</b>, <b>440</b>. At least one inbox <b>438</b> is allocated for each unit in the vertex processor, and at least one inbox <b>440</b> is allocated for each unit in texture processor <b>454</b>. In addition, HIP is capable of writing data to a render context table <b>442</b>, vertex sort table <b>444</b>, primitive sort table <b>446</b> and texture context table <b>48</b>. Vertex processor unit <b>450</b> is responsive to requests fed to an inbox <b>438</b>, and retrieves working data from index array <b>432</b> and vertex buffer <b>434</b>. Unit <b>450</b> communicates with vertex processor unit <b>452</b> via an inbox <b>456</b> and unit <b>452</b> outputs primitives to an array of inboxes <b>458</b>, <b>460</b>. Texture processor <b>454</b> receives requests from an inbox <b>440</b>, reads texture data <b>436</b> from scratch memory <b>430</b> and outputs to a texture memory <b>462</b>.</p>
<p id="p-0132" num="0131">As shown in <figref idref="DRAWINGS">FIG. 14B</figref>, a set of inboxes <b>458</b>, <b>460</b> is allocated for each of a plurality of GIR generator elements <b>464</b> that collectively implement a GIR generator, enabling the frontend of the pipeline to provide primitive data for use in building a GIR <b>472</b>. As noted above, a plurality of parallel threads of execution, e.g. one or more per element <b>464</b>, is used to generate the GIR in the manner described above.</p>
<p id="p-0133" num="0132">One or more master ray management elements <b>466</b>, one or more ray management elements <b>468</b>, one or more ray primitive intersect elements <b>470</b> and one or more color update elements <b>471</b> respectively implement a ray tracing backend. A variable number of threads of execution may be allocated for each type of element <b>466</b>, <b>468</b>, <b>470</b>, <b>471</b> in order to optimize throughput through the software pipeline. Elements <b>466</b>, <b>468</b> and <b>470</b> use the GIR <b>472</b> to perform ray tracing operations, while elements <b>470</b> retrieves texture data from texture memory <b>462</b>. Communication between stages of the backend is provided by inboxes <b>474</b>, <b>476</b> and <b>478</b>, respectively allocated to elements <b>468</b>, <b>470</b> and <b>471</b>. Color update elements <b>471</b> output image data to a render target <b>480</b>, e.g., an image buffer, which is then output via digital video out circuit <b>482</b>.</p>
<p id="p-0134" num="0133">It will be appreciated that the implementation of a streaming geometry frontend and a ray tracing backend into the software pipeline elements and underlying NOC architecture would be well within the abilities of one of ordinary skill in the art having the benefit of the instant disclosure. It will also be appreciated that different numbers of elements may be used to implement each stage of the software pipeline, and that different stages may be used to implement the frontend and/or backend of the pipeline based upon the particular algorithms used thereby. Furthermore, by actively monitoring the workload of each stage of the pipeline, it may be desirable in some embodiments to dynamically change the allocation of IP blocks and threads of execution to different stages of the pipeline, thus providing optimal throughput for different types of tasks.</p>
<heading id="h-0010" level="1">Multithreaded Rendering Software Pipeline for Physics Collision Detection</heading>
<p id="p-0135" num="0134">As noted above, in some embodiments, a multithreaded rendering software pipeline may be used to perform physics collision detection by streaming level of detail (LOD) components for objects in a scene between a plurality of slave, collision detection threads. <figref idref="DRAWINGS">FIG. 15</figref>, for example, illustrates an example two dimensional scene <b>490</b> to be rendered by an image processing system. It will be appreciated that a scene is typically representative of the physical world, and is thus typically defined in three dimensions. Two dimensions are illustrated in <figref idref="DRAWINGS">FIG. 15</figref>, however, for the sake of simplicity.</p>
<p id="p-0136" num="0135">Scene <b>490</b> includes a plurality of objects <b>492</b>, and may be broken into a plurality of spatial regions <b>494</b>, which may also be referred to as Bounding Volumes (BV's). As illustrated in the figure, the spatial regions <b>494</b> may be differently sized and may be defined hierarchically such that some spatial regions represent regions of other spatial regions. Furthermore, spatial regions may be defined in a similar manner to the bounding volumes utilized for ray tracing, e.g., such that each spatial region may be defined so as to balance workload, with areas of a scene containing greater numbers of objects <b>492</b> broken into smaller spatial regions to better balance workload among the hardware threads assigned to perform collision detection for such regions.</p>
<p id="p-0137" num="0136">Collision detection typically involves the detection of collisions between objects that are moving in a scene with other objects, both moving and fixed objects. Thus, as shown in <figref idref="DRAWINGS">FIG. 15</figref>, collision detection may be used to detect a collision between two moving objects <b>496</b>, <b>498</b> with one another, as well as the other objects <b>492</b> in the scene.</p>
<p id="p-0138" num="0137">In some embodiments consistent with the invention, physics collision detection is implemented using a plurality of hardware threads of execution that stream level of detail components between one another to detect collisions between objects in a scene. As shown in <figref idref="DRAWINGS">FIG. 16</figref>, for example, physics collision detection may be implemented in a circuit arrangement <b>500</b> including a NOC <b>502</b> coupled to a memory subsystem <b>504</b>, both of which may be integrated onto the same integrated circuit, or alternatively implemented on separate integrated circuits. NOC <b>502</b> may include IP blocks <b>506</b> coupled to one another via a network <b>508</b>, which may include the networking logic discussed above in connection with NOC <b>102</b> of <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0139" num="0138">As noted above, various subsets of IP blocks <b>506</b> may be allocated to different functionality, and in connection with physics collision detection one or more IP blocks may host a physics engine comprising a master, or component loader thread <b>510</b>, which is used to retrieve level of detail data for an object from memory <b>504</b> and stream the data to one or more collision detection threads <b>512</b>, operating as slave hardware threads and resident on one or more other IP blocks <b>506</b>. Slave hardware threads may also stream level of detail data to other slave hardware threads, e.g., slave hardware threads arranged further down a software pipeline.</p>
<p id="p-0140" num="0139">Because the slave hardware threads receive level of detail data from the master thread, typically the slave hardware threads are not required to load the data from memory subsystem <b>504</b>, thereby reducing memory bandwidth requirements, lowering communication costs, and accelerating performance. As such, it may be desirable to physically locate master thread <b>510</b> on an IP block <b>506</b> that is proximate to memory <b>504</b> (i.e., with minimal network latency), as well as to locate slave threads <b>512</b> on IP blocks <b>506</b> proximate to master thread <b>510</b> as well as to one another, again to minimize network latency when passing data from thread to thread.</p>
<p id="p-0141" num="0140">Physics collision detection may also be implemented in a software pipeline similar to that described above in connection with <figref idref="DRAWINGS">FIG. 5</figref>, and as illustrated by the arrows in <figref idref="DRAWINGS">FIG. 16</figref>, level of detail data may be streamed from master thread <b>510</b> to slave threads <b>512</b>, and with the results of the collision detection streamed from the last slave thread <b>512</b> back to master thread <b>510</b>, all via network <b>508</b>. A HIP (not shown in <figref idref="DRAWINGS">FIG. 16</figref>) may be used to manage the work passed to the master and slave threads, similar to the manner in which a HIP manages work in connection with rendering. Each master and slave thread may implement a stage of the pipeline, although it will be appreciated that in some embodiments, multiple hardware threads may implement a stage, and in other embodiments, one hardware thread may implement multiple stages.</p>
<p id="p-0142" num="0141">Moreover, the arrangement of threads and assignment of same to spatial regions to perform collision detection may be similar in many respects to the manner in which threads are arranged in connection with ray tracing as described above. As such, it may also be desirable to utilize an accelerated data structure as described above to store the objects in a scene for the purposes of performing collision detection consistent with the invention.</p>
<p id="p-0143" num="0142"><figref idref="DRAWINGS">FIG. 17</figref> next illustrates an exemplary routine <b>520</b> executed by a master thread. Routine <b>520</b> executes for each time interval for which collision detection is to be performed, which may or may not be the same time interval between image frames depending upon the accuracy required in connection with collision detection. Routine <b>520</b> begins in block <b>522</b> by initiating a FOR loop to process each moving object in the scene. For each such object, block <b>524</b> determines first whether any level of detail component has already been created for the object. If not, a suitable level of detail component is created in block <b>526</b>. As noted above, creation of a level of detail component may involve creating a component of varying complexity based upon factors such as system resources and desired accuracy. The simpler the level of detail component, and less processor intensive level of detail calculations are required, the less accuracy is typically obtained. Therefore, when available system resources are greater and accuracy is desired, more complex level of detail components may be created in some embodiments.</p>
<p id="p-0144" num="0143">Once created, the level of detail component is streamed to one or more slave threads, along with the &#x201c;sweep&#x201d; of the object, in block <b>528</b>. Also, if it is determined in block <b>524</b> that a level of detail component already exists for the object, block <b>526</b> is bypassed, and block <b>524</b> passes control directly to block <b>526</b>. In the illustrated embodiment, the sweep of an object represents the movement of the object from a starting position to an ending position across the current interval. Thus, the sweep may be represented by a vector and starting and ending voxels representing the direction and distance an object moves over a given interval.</p>
<p id="p-0145" num="0144">Once the data for an object is streamed in block <b>528</b>, control returns to block <b>522</b> to process additional objects. Once all objects have been processed, block <b>522</b> passes control to block <b>530</b> to await the collision data generated by the slave threads, and process accordingly when it is received. For example, the slave threads may return data indicating (1) what objects have collided, and (2) when those collisions occurred in the interval. Routine <b>520</b> is then complete.</p>
<p id="p-0146" num="0145"><figref idref="DRAWINGS">FIG. 18</figref> next illustrates an exemplary routine <b>540</b> executed by a slave thread during collision detection. Routine <b>540</b> begins in block <b>542</b> by receiving the stream data from the prior stage in the pipeline (master or slave). Block <b>544</b> then determines whether the object sweep intersects the region to which the thread is assigned. If not, control passes to block <b>546</b> to stream the level of detail component, object sweep and any collision data generated by prior slave threads to one or more subsequent slave threads in the pipeline, or alternatively, if this is the last slave thread in the pipeline, back to the master thread for further processing. Routine <b>540</b> is then complete.</p>
<p id="p-0147" num="0146">If the object sweep does intersect the region assigned to the thread, block <b>544</b> passes control to block <b>548</b> to determine whether the time at which the intersection occurs (e.g., relative to the time interval) is earlier than a marked collision detected by a prior slave thread. If not, any intersection occurring in the region would only occur after another collision, so there is no reason to perform further collision detection in this thread. Control therefore passes to block <b>546</b>.</p>
<p id="p-0148" num="0147">Otherwise, control passes to block <b>550</b> to perform deep collision detection to determine whether any objects (moving or static) are in the region that intersect with the object in question. Control then passes to block <b>552</b> to determine whether a collision was detected. If not, control passes to block <b>546</b>. If, however, a collision is detected, control passes to block <b>556</b> to update the collision data to indicate the time and the object with which the object in question has collided. Control then passes to block <b>546</b> to stream the updated collision data, along with the level of detail component and object sweep, to one or more slave threads, or alternatively, back to the master thread with the results of collision detection.</p>
<p id="p-0149" num="0148">Implementation of a physics collision detection software pipeline in the NOC architecture described herein, e.g., as illustrated in <figref idref="DRAWINGS">FIGS. 14A-14B</figref>, would be within the abilities of one of ordinary skill in the art having the benefit of the instant disclosure. In addition, it will be appreciated that additional routines, e.g., to assign threads to spatial regions, to load level of detail components for static objects in a scene, to load balance threads for optimal performance, etc., may also be utilized in embodiments consistent with the invention.</p>
<heading id="h-0011" level="1">Physics Engine with Predictive Load Balancing</heading>
<p id="p-0150" num="0149">As noted above, in some embodiments of the invention, it may also be desirable to utilize predictive load balancing to better allocate the workload among hardware threads in a multithreaded physics engine.</p>
<p id="p-0151" num="0150">The predictive load balancing is based, at least in part upon the movement of objects in a scene, and more particularly, upon the detection of predicted future collisions between the objects in a scene, i.e., collisions that have not yet occurred during the current time interval or step, but that are likely to occur in an upcoming time interval or step. Furthermore, while predictive load balancing may be performed in some embodiments any time a future collision is detected, it may be desirable in other embodiments to perform predictive load balancing only in circumstances where the collision is expected to have a substantial effect on hardware thread workloads.</p>
<p id="p-0152" num="0151"><figref idref="DRAWINGS">FIG. 19</figref>, for example, illustrates an exemplary scene <b>600</b> in which a projectile <b>602</b> is moving through the scene toward a wall <b>604</b> containing a plurality of bricks <b>606</b>. The current position of projectile <b>602</b> at a current point in time is illustrated by line t<sub>0</sub>. The direction of movement for projectile <b>602</b> is illustrated by vector <b>608</b>, and the expected positions of projectile <b>602</b> in three subsequent points in time are illustrated by lines t<sub>1</sub>, t<sub>2</sub>, and t<sub>3</sub>. Also illustrated is a predicted collision <b>610</b> between projectile <b>602</b> and wall <b>604</b> at time t<sub>3</sub>.</p>
<p id="p-0153" num="0152">Assuming for the purposes of this example that wall <b>604</b>, and thus its component bricks, are fixed in the scene, it would not be unreasonable to expect that the workload of any hardware threads allocated to perform either collision detection or impulse propagation would not be particularly great, and as such, the number of hardware threads allocated to the region encompassing wall <b>604</b> may be desirably low.</p>
<p id="p-0154" num="0153">On the other hand, a realistic simulation of the collision of projectile <b>602</b> with wall <b>604</b> may involve substantially greater processing overhead, as impulses and collisions between multiple bricks <b>606</b> would likely occur. Keeping the workload allocation static therefore would likely overburden the threads allocated to the region encompassing the wall and lead to decreased performance. Moreover, reallocating the workload upon detection of the collision may improve performance; however, there is typically an overhead associated with reallocating workloads, as data necessary for performing the work previously allocated to certain threads typically must be transferred to new threads in order for those new threads to perform the work.</p>
<p id="p-0155" num="0154">Embodiments consistent with the invention therefore attempt to predict the occurrence of future collisions and initiate a reallocation of workload among hardware threads prior to the actual collisions, such that some, if not all, of the overhead associated with the reallocation is incurred prior to the detecting current collisions corresponding to the detected future collisions, and such that an optimal allocation of threads is available once the collisions do occur.</p>
<p id="p-0156" num="0155">It will be appreciated that, by predictively initiating a reallocation of hardware threads, the reallocation desirably, but not necessarily, will be complete when a predicted collision ultimately occurs. Even in instances where the reallocation does not complete, however, the reallocation will typically complete earlier than if the reallocation was initiated in response to a detected collision. It will also be appreciated that, in some instances, a predictive load balancing operation may result in a temporary sub-optimal allocation of work between hardware threads until a predicted collision is finally detected, in contrast with many load balancing algorithms that attempt to create optimal allocations of resources based upon current workload requirements.</p>
<p id="p-0157" num="0156">Now turning to <figref idref="DRAWINGS">FIG. 20</figref>, this figure illustrates a high level routine <b>620</b> for a physics engine incorporating predictive load balancing consistent with the invention. A physics engine, in this context, may be considered any software configured to perform physics-related calculations, and as such, the invention applies to any physics-related calculation software irrespective of whether that software is considered to be a distinct &#x201c;engine.&#x201d; In this embodiment, the physics engine is a multithreaded physics engine in which multiple hardware threads, disposed, for example, in one or more processing cores, and in one or more integrated circuit chips, share the workload of the physics engine.</p>
<p id="p-0158" num="0157">A typical physics engine at a high level executes a loop that sequences between processing movements of objects over a given time interval or step (block <b>622</b>), detecting collisions (block <b>624</b>), and propagating impulses based upon any detected collisions (block <b>626</b>). In the illustrated embodiment, however, an additional step of performing predictive load balancing is preformed in block <b>628</b>, typically after collision detection and before impulse propagation. It will be appreciated that predictive load balancing may be performed at different points in routine <b>620</b>, or may be considered to be incorporated into one of blocks <b>622</b>-<b>626</b>, in other embodiments of the invention.</p>
<p id="p-0159" num="0158">A pool of hardware threads (not shown) may be allocated to handle various functions in the physics engine. For example, separate pools of threads may be utilized to handle the movement processing, collision detection and impulse propagation functions of the physics engine. One or more master threads may also be used to coordinate the activities of these various pools of threads. In alternative embodiments, individuals threads may handle multiple functions among those performed in blocks <b>622</b>, <b>624</b> and <b>626</b>. These threads are typically allocated in a manner that attempts to evenly distribute the workload among the threads, e.g., by assigning threads to particular regions of a scene, or assigning threads to particular collections of objects.</p>
<p id="p-0160" num="0159">In the illustrated embodiment, step <b>622</b> of routine <b>620</b> processes movement by calculating, for each object in a scene, an object sweep over a plurality of time intervals. Step <b>624</b>, as in a conventional physics engine, detects &#x201c;current&#x201d; collisions at the first time interval or step, representing the movement that has occurred in the scene during the current time interval. In addition, step <b>624</b> also attempts to detect &#x201c;future&#x201d; collisions, representing intersections of object sweeps projected over multiple time intervals, i.e., beyond the first time interval.</p>
<p id="p-0161" num="0160">Based upon these future collisions, and illustrated in greater detail by predictive load balancing routine <b>630</b> of <figref idref="DRAWINGS">FIG. 21</figref>, hardware threads may be predictively reallocated. In particular, routine <b>630</b> begins in block <b>632</b> by determining, based upon the analysis performed in collision detection step <b>624</b>, whether any future collisions have been predicted. If not, no load balancing is required, and routine <b>630</b> is complete.</p>
<p id="p-0162" num="0161">On the other hand, if any future collisions are detected/predicted, control passes to block <b>634</b> to analyze the characteristics of each future collision to determine whether load balancing is required. Based upon this analysis, block <b>636</b> determines whether rebalancing of the load is required, and if so, passes control to block <b>638</b> to rebalance the load (i.e., reallocate the hardware threads), whereby routine <b>630</b> is complete. Otherwise, block <b>638</b> is bypassed, and routine <b>630</b> terminates.</p>
<p id="p-0163" num="0162">The analysis of whether rebalancing is required for a future detected collision may vary in different embodiments. Two factors that may be considered, for example, include the number of objects potentially involved in the collisions, and the properties of the objects potentially involved in the collisions. As to the number of objects involved, as discussed above in connection with <figref idref="DRAWINGS">FIG. 19</figref>, the collision of a projectile with a brick wall may involve the interaction of a large number of bricks as the wall deforms and ultimately explodes. Likewise, when objects are complex and involve numerous graphical primitives (which themselves may be considered to be objects) that may be involved in collisions, more involved processing may be required to handle these objects.</p>
<p id="p-0164" num="0163">As to the object properties, the simulated physical nature of the objects involved may necessitate greater or lesser processing by hardware threads assigned to such objects. For example, a rubber ball bouncing harmlessly off of a wall, which does not cause the bricks of the wall to become dislodged, would likely not require substantial additional processing allocation. Likewise, two rigid objects colliding with one another with insufficient force to break them apart would not require additional processing allocation. In contrast. an energetic collision between brittle and/or complex objects would likely result in (at least during the duration of the collision) substantial additional processing requirements in order to manage the collisions and/or impulse propagation associated with such objects. Therefore, object properties such as rigidity, deformability, elasticity, speed, mass, spring constants, object complexity, etc., may be considered when determining whether reallocation is desirable for a particular detected future collision.</p>
<p id="p-0165" num="0164">The reallocation of hardware threads during predictive load balancing may occur in a number of manners consistent with the invention. For example, in embodiments where collision detection and impulse propagation are performed by different pools of threads, predictive load balancing may be performed for threads performing collision detection, for threads performing impulse propagation, or for both.</p>
<p id="p-0166" num="0165">In addition, while predictive load balancing may be implemented in other multithreaded physics engine designs based upon other hardware architectures, one exemplary implementation of predictive load balancing may be for the purpose of load balancing slave collision detection threads in a NOC such as NOC <b>500</b> illustrated in <figref idref="DRAWINGS">FIG. 16</figref> and described above, and using a streaming, multithreaded software pipeline architecture that streams level of detail components from a master, component loader hardware thread to a plurality of slave collision detection threads. <figref idref="DRAWINGS">FIGS. 22 and 23</figref>, for example, illustrate collision detection routines <b>640</b>, <b>660</b> respectively executed by master and slave threads, and similar to routines <b>520</b>, <b>540</b> illustrated in <figref idref="DRAWINGS">FIGS. 17 and 18</figref>.</p>
<p id="p-0167" num="0166">Routine <b>640</b> of <figref idref="DRAWINGS">FIG. 22</figref> executes for each time interval for which collision detection is to be performed, and begins in block <b>642</b> by initiating a FOR loop to process each moving object in the scene. For each such object, block <b>644</b> determines first whether any level of detail component has already been created for the object. If not, a suitable level of detail component is created in block <b>646</b>. Once created, the level of detail component is streamed to one or more slave threads, along with the &#x201c;sweep&#x201d; of the object, in block <b>648</b>. Also, if it is determined in block <b>644</b> that a level of detail component already exists for the object, block <b>646</b> is bypassed, and block <b>644</b> passes control directly to block <b>648</b>. Unlike routine <b>520</b>, where the sweep of an object represents the movement of the object from a starting position to an ending position across the current interval, however, the object sweep calculated and streamed in block <b>648</b> of routine <b>640</b> represents the movement of the object from a starting position to an ending position across a plurality of time intervals, so that both current and future collisions may be detected.</p>
<p id="p-0168" num="0167">Once the data for an object is streamed in block <b>648</b>, control returns to block <b>642</b> to process additional objects. Once all objects have been processed, block <b>642</b> passes control to block <b>650</b> to await the collision data generated by the slave threads, and process accordingly when it is received. As with routine <b>520</b> of <figref idref="DRAWINGS">FIG. 17</figref>, the slave threads may return data indicating (1) what objects have collided, and (2) when those collisions occurred in the interval. In block <b>650</b>, however, the slave threads may also return a request or recommendation for a rebalancing of load among the slave threads.</p>
<p id="p-0169" num="0168">As such, block <b>650</b> passes control to block <b>652</b> to determine whether a rebalancing has been recommended by any slave thread. If not, no rebalancing is performed, and routine <b>640</b> is complete. If, however, a rebalancing is recommended, rebalancing is performed in block <b>654</b> to reallocate the slave threads, e.g., to provide additional threads to handle predicted future collisions in particular regions of a scene.</p>
<p id="p-0170" num="0169"><figref idref="DRAWINGS">FIG. 23</figref> next illustrates an exemplary routine <b>660</b> executed by a slave thread during collision detection. Routine <b>660</b> begins in block <b>662</b> by receiving the stream data from the prior stage in the pipeline (master or slave). Block <b>664</b> then determines whether the object sweep intersects the region to which the thread is assigned. If not, control passes to block <b>666</b> to stream the level of detail component, object sweep and any collision data generated by prior slave threads to one or more subsequent slave threads in the pipeline, or alternatively, if this is the last slave thread in the pipeline, back to the master thread for further processing. Routine <b>660</b> is then complete.</p>
<p id="p-0171" num="0170">If the object sweep does intersect the region assigned to the thread, block <b>664</b> passes control to block <b>668</b> to determine whether the time at which the intersection occurs (e.g., relative to the time interval) is earlier than a marked collision detected by a prior slave thread. If not, any intersection occurring in the region would only occur after another collision, so there is no reason to perform further collision detection in this thread. Control therefore passes to block <b>666</b>.</p>
<p id="p-0172" num="0171">Otherwise, control passes to block <b>670</b> to perform deep collision detection to determine whether any objects (moving or static) are in the region that intersect with the object in question. Control then passes to block <b>672</b> to determine whether a collision was detected. If a collision is detected, control passes to block <b>674</b> to update the collision data to indicate the time and the object with which the object in question has collided. Control then passes to block <b>666</b> to stream the updated collision data, along with the level of detail component and object sweep, to one or more slave threads, or alternatively, back to the master thread with the results of collision detection.</p>
<p id="p-0173" num="0172">If, however, block <b>672</b> does not detect a collision, control passes to block <b>676</b> to determine whether a future collision has been detected, based upon the movement of the object (as represented by the object sweep) one or more time intervals in the future. If not, control returns to block <b>666</b>. If, however, a future collision is detected, control passes to block <b>678</b> to analyze the characteristics of the future collision. While a number of different characteristics of the collision may be analyzed, as noted above, routine <b>660</b> illustrates two related factors: whether the future collision involves numerous objects, e.g., a number of objects that exceeds a particular threshold (block <b>680</b>), and whether the properties of the colliding objects are likely to require additional processing load (block <b>682</b>). If neither factor is found, control passes to block <b>666</b>. If, however, either determination comes out in the affirmative, control passes to block <b>684</b> to update the collision data streamed to the next slave threads or to the master thread to recommend a load rebalance. Control then passes to block <b>666</b>, whereby routine <b>660</b> is complete.</p>
<p id="p-0174" num="0173">It should be noted that, in this embodiment, slave threads recommend rebalancing, although the actual rebalancing is managed by the master thread. In other embodiments, however, the determination of when rebalancing is required, and performing the actual rebalancing, may be implemented solely within a master thread, solely within a slave thread, or by an entirely different thread.</p>
<p id="p-0175" num="0174">Therefore, by initiating a load balancing operation responsive to predicted future collisions between objects, the allocation of threads within a physics engine may be optimized in advance of events that are likely to significantly alter the workload distribution in the physics engine, and as such, the physics engine is more likely to be optimally configured when such events later occur, i.e., when current collisions corresponding to the future collisions are detected.</p>
<p id="p-0176" num="0175">It will be appreciated that implementation of predictive load balancing in the NOC architecture described herein would be within the abilities of one of ordinary skill in the art having the benefit of the instant disclosure. In addition, it will be appreciated that suitable algorithms for allocating and reallocating threads to spatial regions based upon predicted workloads would also be within the abilities of one of ordinary skill in the art having the benefit of the instant disclosure.</p>
<p id="p-0177" num="0176">Various modifications may be made to the disclosed embodiments without departing from the spirit and scope of the invention. For example, predictive load balancing may also be used to reallocate other hardware resources, e.g., memory, I/O resources, etc. Other modifications will be apparent to one of ordinary skill in the art. Therefore, the invention lies in the claims hereinafter appended.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A circuit arrangement, comprising:
<claim-text>network on chip hardware logic including a plurality of processing cores defining a plurality of hardware threads and an on chip network coupling the plurality of processing cores to one another;</claim-text>
<claim-text>a memory subsystem coupled to the plurality of processing cores and storing a plurality of level of detail components for a plurality of objects in a scene;</claim-text>
<claim-text>a physics engine executed by at least a portion of the plurality of hardware threads, the physics engine including a multithreaded software pipeline including a plurality of stages configured to detect collisions between objects from among the plurality of objects; and</claim-text>
<claim-text>at least one component loader hardware thread and a plurality of collision detection hardware threads defined among the plurality of stages, the component loader hardware thread configured to retrieve level of detail components for objects in the scene from the memory subsystem and stream each level of detail component to sequences of collision detection hardware threads among the plurality of collision detection hardware threads such that the collision detection hardware threads are able to access the level of detail components streamed thereto without directly accessing the memory subsystem, each collision detection hardware thread allocated to a spatial region of the scene and configured to perform collision detection for the spatial region using the level of detail components streamed thereto, and at least one collision detection hardware thread configured to stream level of detail components to another collision detection hardware disposed later in the multithreaded software pipeline, wherein the plurality of collision detection hardware threads are further configured to detect future collisions between objects in the scene, and wherein the component loader hardware thread is configured to initiate a workload reallocation among the plurality of collision detection hardware threads in response to a detected future collision such that additional hardware resources are allocated to handle the future collision when the future collision occurs. </claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
