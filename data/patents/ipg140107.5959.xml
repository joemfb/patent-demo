<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627071-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627071</doc-number>
<kind>B1</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>11118665</doc-number>
<date>20050429</date>
</document-id>
</application-reference>
<us-application-series-code>11</us-application-series-code>
<us-term-of-grant>
<us-term-extension>1775</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>H</section>
<class>04</class>
<subclass>L</subclass>
<main-group>9</main-group>
<subgroup>32</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>713168</main-classification>
</classification-national>
<invention-title id="d2e53">Insuring integrity of remote procedure calls used in a client and server storage system</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5778228</doc-number>
<kind>A</kind>
<name>Wei</name>
<date>19980700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>719328</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6671773</doc-number>
<kind>B2</kind>
<name>Kazar</name>
<date>20031200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6959384</doc-number>
<kind>B1</kind>
<name>Serret-Avila</name>
<date>20051000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713176</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2004/0015724</doc-number>
<kind>A1</kind>
<name>Pham et al.</name>
<date>20040100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713201</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>2004/0078568</doc-number>
<kind>A1</kind>
<name>Pham et al.</name>
<date>20040400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713165</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2004/0098599</doc-number>
<kind>A1</kind>
<name>Bentley</name>
<date>20040500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713187</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2004/0139167</doc-number>
<kind>A1</kind>
<name>Edsall et al.</name>
<date>20040700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>JP</country>
<doc-number>10003440</doc-number>
<kind>A</kind>
<date>19980600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>WO</country>
<doc-number>WO 00/07101</doc-number>
<kind>A1</kind>
<date>20000200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00010">
<othercit>Atomic Remote Procedure Call by Kwei-Jay Lin and John D. Gannon published by IEEE 1985.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00011">
<othercit>Eisler, M. Request for Comments 2203, entitled &#x201c;RPCSEC<sub>&#x2014;</sub>GSS Protocol Specification&#x201d; Sep. 1997.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00012">
<othercit>Linn, J. Request for Comments 2078, entitled &#x201c;Generic Services Generic Security Service Application Program Interface, Version 2.&#x201d; OpenVision Technologies, Jan. 1997.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00013">
<othercit>Srinivasan R.; Request for Comments 1831, entitled &#x201c;RPC: Remote Procedure Call Protocol Specification Version 2&#x201d; Sun Microsystems, Aug. 1995.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00014">
<othercit>Tanenbaum, Andrew S.; <i>Computer Networks 3</i><sup>rd </sup><i>Edition</i>; Prentice Hall, 1996. pp. 521-542.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>21</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>713181</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>713168</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>713170</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>713179</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>10</number-of-drawing-sheets>
<number-of-figures>10</number-of-figures>
</figures>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Corbett</last-name>
<first-name>Peter F.</first-name>
<address>
<city>Lexington</city>
<state>MA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Corbett</last-name>
<first-name>Peter F.</first-name>
<address>
<city>Lexington</city>
<state>MA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Cesari and McKenna, LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>NetApp, Inc.</orgname>
<role>02</role>
<address>
<city>Sunnyvale</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Tran</last-name>
<first-name>Ellen</first-name>
<department>2433</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A system and method generates a message integrity check. The message integrity check value is computed by hashing one or more block checksums from procedure specific parameters of an RPC and then encrypting the resulting hash value. The one or more block checksums may be quickly computed using conventional data checksumming procedures for the data contained within the RPC. As such, the computations to hash the block checksums is minimal. The computed message integrity check is appended to the RPC to thereby provide a level of security approaching or equal to the level of Integrity defined by the RPCSEC_GSS protocol specification.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="198.29mm" wi="131.66mm" file="US08627071-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="197.44mm" wi="144.44mm" orientation="landscape" file="US08627071-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="187.96mm" wi="149.52mm" orientation="landscape" file="US08627071-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="224.11mm" wi="149.18mm" orientation="landscape" file="US08627071-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="121.92mm" wi="150.28mm" file="US08627071-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="180.42mm" wi="141.82mm" orientation="landscape" file="US08627071-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="110.24mm" wi="120.65mm" file="US08627071-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="158.58mm" wi="85.17mm" orientation="landscape" file="US08627071-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="146.22mm" wi="73.15mm" orientation="landscape" file="US08627071-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="159.68mm" wi="133.43mm" file="US08627071-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="210.14mm" wi="140.38mm" file="US08627071-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">FIELD OF THE INVENTION</heading>
<p id="p-0002" num="0001">The present invention is directed to network protocols and, in particular, to a technique for providing a message integrity check for data transmissions.</p>
<heading id="h-0002" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0003" num="0002">A storage system typically comprises one or more storage devices into which information may be entered, and from which information may be obtained, as desired. The storage system includes a storage operating system that functionally organizes the system to by, inter alia, invoking storage operations in support of a storage service implemented by the system. The storage system may be implemented in accordance with a variety of storage architectures including, but not limited to, a network-attached storage environment, a storage area network and a disk assembly directly attached to a client or host computer. The storage devices are typically disk drives organized as a disk array, wherein the term &#x201c;disk&#x201d; commonly describes a self-contained rotating magnetic media storage device. The term disk in this context is synonymous with hard disk drive (HDD) or direct access storage device (DASD).</p>
<p id="p-0004" num="0003">The storage system may be further configured to operate according to a client/server model of information delivery to thereby allow many clients to access data containers, such as files and logical units, stored on the system. In this model, the client may comprise an application, such as a database application, executing on a computer that &#x201c;connects&#x201d; to the storage system over a computer network, such as a point-to-point link, shared local area network (LAN), wide area network (WAN), or virtual private network (VPN) implemented over a public network such as the Internet. Each client may request the services of the storage system by issuing file-based and block-based protocol messages (in the form of packets) to the system over the network.</p>
<p id="p-0005" num="0004">A plurality of storage systems may be interconnected to provide a storage system cluster configured to service many clients. Each storage system or node may be configured to service one or more volumes, wherein each volume stores one or more data containers. Communication among the nodes involves the exchange of information between two or more entities interconnected by communication links. These entities are typically software programs executing on the nodes. The nodes communicate by exchanging discrete packets or messages of information according to predefined protocols. In this context, a protocol consists of a set of rules defining how the nodes interact with each other.</p>
<p id="p-0006" num="0005">Each node generally provides its services through the execution of software modules, such as processes. A process is a software program that is defined by a memory address space. For example, an operating system of the node may be implemented as a single process with a large memory address space, wherein pieces of code within the process is provide operating system services, such as process management. Yet, the node's services may also be implemented as separately-scheduled processes in distinct, protected address spaces. These separate processes, each with its own process address space, execute on the node to manage resources internal to the node and, in the case of a database or network protocol, to interact with users.</p>
<p id="p-0007" num="0006">Services that are part of the same process address space communicate by accessing the same memory space. That is, information exchanged between services implemented in the same process address space is not transferred, but rather may be accessed in a common memory. However, communication among services that are implemented as separate processes is typically effected by the exchange of messages. For example, information exchanged between different addresses spaces of processes is transferred as one or messages between different memory spaces of the processes. A known message-passing mechanism provided by an operating system to transfer information between process address spaces is the Inter Process Communication (IPC) mechanism.</p>
<p id="p-0008" num="0007">Resources internal to the node may include communication resources that enable a process on one node to communicate over the communication links or network with another process on a different node. The communication resources include the allocation of memory and data structures, such as messages, as well as a network protocol stack. The network protocol stack, in turn, comprises layers of software, such as a session layer, a transport layer and a network layer. The Internet protocol (IP) is a network layer protocol that provides network addressing between nodes, whereas the transport layer provides a port service that identifies each process executing on the nodes and creates a connection between those processes that indicate a willingness to communicate. Examples of conventional transport layer protocols include the reliable connection (RC) protocol and the Transmission Control Protocol (TCP).</p>
<p id="p-0009" num="0008">Broadly stated, the connection provided by the transport layer, such as TCP, is a reliable, securable logical circuit between pairs of processes. A TCP process executing on each node establishes the TCP connection in accordance with a conventional &#x201c;3-way handshake&#x201d; arrangement involving the exchange of TCP message or segment data structures. The resulting TCP connection is identified by port numbers and IP addresses of the nodes. The TCP transport service provides reliable delivery of a message using a TCP transport header. The TCP protocol and establishment of a TCP connection are described in <i>Computer Networks, </i>3<i>rd Edition</i>, particularly at pgs. 521-542, which is hereby incorporated by reference as though fully set forth herein.</p>
<p id="p-0010" num="0009">Messages passed between nodes of a cluster are typically implemented as remote procedure calls (RPCs). One format for RPCs is defined in Request for Comments 1831, entitled <i>RPC: Remote Procedure Call Protocol Specification Version </i>2 by R. Srinivasan dated August 1995, the contents of which are hereby incorporated by reference. Generally a RPC comprises a header portion and a set of procedure specific parameters. The procedure specific parameters may include a set of control information and data associated with the message.</p>
<p id="p-0011" num="0010">In systems using RPCs, it is desirous that data is secure and not vulnerable to a network security attack. The Generic Security Service application program interface (GSS-API), described in Request for Comments 2078, entitled <i>Generic Security Service Application Program Interface, Version </i>2, by J. Linn dated January 1997, the contents of which are hereby incorporated by reference, provides a set of security services in a generic fashion for a variety of transport mechanisms. The GSS-API defines its services and primitives independently of the underlying transport mechanism and/or programming language environment.</p>
<p id="p-0012" num="0011">To utilize the GSS-API within a RPC protocol environment, the RPCSEC_GSS protocol, defined in Request for Comments 2203, entitled <i>RPCSEC</i><sub>&#x2014;</sub><i>GSS Protocol Specification</i>, by M. Eisler dated September 1997 and hereby incorporated by reference, is to typically employed. The RPCSEC_GSS protocol defines a variety of levels of protection including an Authentication level and an Integrity level. In the Authentication level, the credential within a message is hashed and then encrypted to form an Authentication verifier. In the Integrity level, a hash is executed over the procedure specific parameters contained within a RPC and the resulting hash value is encrypted to produce a message verifier, which is then appended to the RPC.</p>
<p id="p-0013" num="0012">However, a disadvantage associated with both of these protection levels involves the computational overhead required to perform the necessary calculation. For example, the entire procedure specific parameters section, including any data contained therein, must be hashed in the Integrity level. This introduces substantial overhead in terms of time as well as a concomitant reduction in available processing resources for performing other tasks. Moreover, this additional overhead may result in additional latency when retrieving data in a storage system environment.</p>
<heading id="h-0003" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0014" num="0013">The present invention overcomes the disadvantages of the prior art by providing a system and method for generating a message integrity check for use in a data transmissions, including, e.g., remote procedure call (RPC) based network protocols executing on storage systems or nodes of a cluster. Each node is generally organized as a network element (N-blade) and a disk element (D-blade). Each element includes a cluster fabric interface module adapted to implement a network protocol that enables intra-cluster communication among the elements. The network protocol is a multi-layered protocol that integrates a session infrastructure and an application operation set into a session layer that obviates encapsulation and buffering overhead typically associated with protocol layering. The network protocol is illustratively a request/response protocol wherein an element (requester) receiving a data access request from a client redirects that request to another element (responder) that services the request and, upon completion, returns a response.</p>
<p id="p-0015" num="0014">All network protocol communication in the cluster occurs via connections, which to provide a network transport for sessions between the requesters/responders. At least one connection is required for each session, wherein the connection is used for both requests and responses. Each request/response is embodied as an RPC that is transmitted over one of the connections. Each RPC comprises a header and a set of procedure specific parameters. For network protocol RPCs, the procedure specific parameters include a control portion and the data associated with the RPC.</p>
<p id="p-0016" num="0015">In one illustrative embodiment of the invention, one or more block checksums are generated in the control portion of the RPC. These block checksums may be quickly computed using conventional data checksumming procedures for the data contained within the RPC. In addition, block sizes of the checksums are illustratively selected so that the checksum may be utilized at multiple stages of processing. For example, assume a file system executing on the D-blade utilizes 4 kilobyte (KB) blocks for internal operations and for writing to disk. Accordingly, the block size for the block checksums may be selected as 4 KB in size. This permits the use of the checksum for end-to-end data protection, e.g., from N-blade to D-blade to disk or vice versa.</p>
<p id="p-0017" num="0016">According to the invention, the block checksum(s) of the data portion that is stored in the control portion of the RPC are hashed and the resulting hash value encrypted to generate the message integrity check. This aspect of the invention contemplates use of a strong data checksum, such as the well-known MD-5, to provide a high confidence that the transmitted data is valid without checksumming the same data twice, as is required in prior GSS-API levels of security. It is noted that a block checksum may not be removed without detection; accordingly, by utilizing a sufficiently secure checksumming algorithm, an attacker would be required to modify the data in a way that does not modify the block checksum.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0018" num="0017">The above and further advantages of invention may be better understood by referring to the following description in conjunction with the accompanying drawings in which like reference numerals indicate identical or functionally similar elements:</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 1</figref> is a schematic block diagram of a plurality of nodes interconnected as a cluster in accordance with an embodiment of the present invention;</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 2</figref> is a schematic block diagram of a node in accordance with an embodiment of the present invention;</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 3</figref> is a schematic block diagram of a storage operating system that may be advantageously used with the present invention;</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 4</figref> is a schematic block diagram illustrating the format of a SpinNP message in accordance with an embodiment of with the present invention;</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 5</figref> is a schematic block diagram illustrating the organization of cluster fabric interface modules adapted to implement a SpinNP protocol in accordance with the present invention;</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 6</figref> is a schematic block diagram of an exemplary remote procedure call header in accordance with an embodiment of the present invention;</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 7</figref> is a schematic block diagram of an exemplary message integrity check protected remote procedure call in accordance with an embodiment of the present invention;</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 8</figref> is a schematic block diagram of an exemplary message integrity check protected data transmission in accordance with an embodiment of the present invention;</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 9</figref> is a flowchart detailing the steps of a procedure for preparing a message integrity check protected remote procedure call in accordance with an embodiment of the present invention; and</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 10</figref> is a flowchart detailing the steps of a procedure for processing a message integrity check protected remote procedure call in accordance with an embodiment of the present invention</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION OF AN ILLUSTRATIVE EMBODIMENT</heading>
<p id="p-0029" num="0028">A. Cluster Environment</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 1</figref> is a schematic block diagram of a plurality of nodes <b>200</b> interconnected as a cluster <b>100</b> and configured to provide storage service relating to the organization of information on storage devices. The nodes <b>200</b> comprise various functional components that cooperate to provide a distributed storage system architecture of the cluster <b>100</b>. To that end, each node <b>200</b> is generally organized as a network element (N-blade <b>310</b>) and a disk element (D-blade <b>350</b>). The N-blade <b>310</b> includes functionality that enables the node <b>200</b> to connect to clients <b>180</b> over a computer network <b>140</b>, while each D-blade <b>350</b> connects to one or more storage devices, such as disks <b>130</b> of a disk array <b>120</b>. The nodes <b>200</b> are interconnected by a cluster switching fabric <b>150</b> which, in the illustrative embodiment, may be embodied as a Gigabit Ethernet switch. An exemplary distributed file system architecture is generally described in U.S. Patent Application Publication No. US 2002/0116593 titled METHOD AND SYSTEM FOR RESPONDING TO FILE SYSTEM REQUESTS, by M. Kazar et al. published Aug. 22, 2002. It should be noted that while there is shown an equal number of N and D-blades in the illustrative cluster <b>100</b>, there may be differing numbers of N and/or D-blades in accordance with various embodiments of the present invention. For example, there may be a plurality of N-blades and/or D-blades interconnected in a cluster configuration <b>100</b> that does not reflect a oneto-one correspondence between the N and D-blades. As such, the description of a node <b>200</b> comprising one N-blade and one D-blade should be taken as illustrative only.</p>
<p id="p-0031" num="0030">The clients <b>180</b> may be general-purpose computers configured to interact with the node <b>200</b> in accordance with a client/server model of information delivery. That is, each client may request the services of the node, and the node may return the results of the services requested by the client, by exchanging packets over the network <b>140</b>. The client may issue packets including file-based access protocols, such as the Common Internet File System (CIFS) protocol or Network File System (NFS) protocol, over the Transmission Control Protocol/Internet Protocol (TCP/IP) when accessing information in the form of files and directories. Alternatively, the client may issue packets including block-based access protocols, such as the Small Computer Systems Interface (SCSI) protocol encapsulated over TCP (iSCSI) and SCSI encapsulated over Fibre Channel (FCP), when accessing information in the form of blocks.</p>
<p id="p-0032" num="0031">B. Storage System Node</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 2</figref> is a schematic block diagram of a node <b>200</b> that is illustratively embodied as a storage system comprising a plurality of processors <b>222</b><i>a,b</i>, a memory <b>224</b>, a network adapter <b>225</b>, a cluster access adapter <b>226</b>, a storage adapter <b>228</b> and local storage <b>230</b> interconnected by a system bus <b>223</b>. The local storage <b>230</b> comprises one or more storage devices, such as disks, utilized by the node to locally store configuration information (e.g., in configuration table <b>235</b>) provided by one or more management processes that execute as user mode applications. The cluster access adapter <b>226</b> comprises a plurality of ports adapted to couple the node <b>200</b> to other nodes of the cluster <b>100</b>. In the illustrative embodiment, Ethernet is used as the clustering protocol and interconnect media, although it will be apparent to those skilled in the art that other types of protocols and interconnects may be utilized within the cluster architecture described herein. In alternate embodiments where the N-blades and D-blades are implemented on separate storage systems or computers, the cluster access adapter <b>226</b> is utilized by the N/D-blade for communicating with other N/D-blades in the cluster <b>100</b>.</p>
<p id="p-0034" num="0033">Each node <b>200</b> is illustratively embodied as a dual processor storage system executing a storage operating system <b>300</b> that preferably implements a high-level module, such as a file system, to logically organize the information as a hierarchical structure of named directories, files and special types of files called virtual disks (hereinafter generally &#x201c;blocks&#x201d;) on the disks. However, it will be apparent to those of ordinary skill in the art that the node <b>200</b> may alternatively comprise a single or more than two processor systern. Illustratively, one processor <b>222</b><i>a </i>executes the functions of the N-blade <b>310</b> on the node, while the other processor <b>222</b><i>b </i>executes the functions of the D-blade <b>350</b>.</p>
<p id="p-0035" num="0034">The memory <b>224</b> illustratively comprises storage locations that are addressable by the processors and adapters for storing software program code and data structures associated with the present invention. The processor and adapters may, in turn, comprise processing elements and/or logic circuitry configured to execute the software code and manipulate the data structures. The storage operating system <b>300</b>, portions of which is typically resident in memory and executed by the processing elements, functionally organizes the node <b>200</b> by, inter alia, invoking storage operations in support of the storage service implemented by the node. It will be apparent to those skilled in the art that other processing and memory means, including various computer readable media, may be used for storing and executing program instructions pertaining to the invention described herein.</p>
<p id="p-0036" num="0035">The network adapter <b>225</b> comprises a plurality of ports adapted to couple the node <b>200</b> to one or more clients <b>180</b> over point-to-point links, wide area networks, virtual private networks implemented over a public network (Internet) or a shared local area network. The network adapter <b>225</b> thus may comprise the mechanical, electrical and signaling circuitry needed to connect the node to the network. Illustratively, the computer network <b>140</b> may be embodied as an Ethernet network or a Fibre Channel (FC) network. Each client <b>180</b> may communicate with the node over network <b>140</b> by exchanging discrete frames or packets of data according to pre-defined protocols, such as TCP/IP.</p>
<p id="p-0037" num="0036">The storage adapter <b>228</b> cooperates with the storage operating system <b>300</b> executing on the node <b>200</b> to access information requested by the clients. The information may be stored on any type of attached array of writable storage device media such as video tape, optical, DVD, magnetic tape, bubble memory, electronic random access memory, micro-electro mechanical and any other similar media adapted to store information, including data and parity information. However, as illustratively described herein, the information is preferably stored on the disks <b>130</b> of array <b>120</b>. The storage adapter comprises a plurality of ports having input/output (I/O) interface circuitry that couples to the disks over an I/O interconnect arrangement, such as a conventional high-performance, FC link topology.</p>
<p id="p-0038" num="0037">Storage of information on each array <b>120</b> is preferably implemented as one or more storage &#x201c;volumes&#x201d; that comprise a collection of physical storage disks <b>130</b> cooperating to define an overall logical arrangement of volume block number (vbn) space on the volume(s). Each logical volume is generally, although not necessarily, associated with its own file system. The disks within a logical volume/file system are typically organized as one or more groups, wherein each group may be operated as a Redundant Array of Independent (or Inexpensive) Disks (RAID). Most RAID implementations, such as a RAID-4 level implementation, enhance the reliability/integrity of data storage through the redundant writing of data &#x201c;stripes&#x201d; across a given number of physical disks in the RAID group, and the appropriate storing of parity information with respect to the striped data. An illustrative example of a RAID implementation is a RAID-4 level implementation, although it should be understood that other types and levels of RAID implementations may be used in accordance with the inventive principles described herein.</p>
<p id="p-0039" num="0038">C. Storage Operating System</p>
<p id="p-0040" num="0039">To facilitate access to the disks <b>130</b>, the storage operating system <b>300</b> implements a write-anywhere file system that cooperates with one or more virtualization modules to &#x201c;virtualize&#x201d; the storage space provided by disks <b>130</b>. The file system logically organizes the information as a hierarchical structure of named directories and files on the disks. Each &#x201c;on-disk&#x201d; file may be implemented as set of disk blocks configured to store information, such as data, whereas the directory may be implemented as a specially formatted file in which names and links to other files and directories are stored. The virtualization module(s) allow the file system to further logically organize information as a hierarchical structure of blocks on the disks that are exported as named logical unit numbers (luns).</p>
<p id="p-0041" num="0040">In the illustrative embodiment, the storage operating system is preferably the NetApp&#xae; Data ONTAP&#x2122; operating system available from Network Appliance, Inc., Sunnyvale, Calif. that implements a Write Anywhere File Layout (WAFL&#x2122;) file system. However, it is expressly contemplated that any appropriate storage operating system may be enhanced for use in accordance with the inventive principles described herein. As such, where the term &#x201c;WAFL&#x201d; is employed, it should be taken broadly to refer to any storage operating system that is otherwise adaptable to the teachings of this invention.</p>
<p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. 3</figref> is a schematic block diagram of the storage operating system <b>300</b> that may be advantageously used with the present invention. The storage operating system comprises a series of software layers organized to form an integrated network protocol stack or, more generally, a multi-protocol engine <b>325</b> that provides data paths for clients to access information stored on the node using block and file access protocols. The multi-protocol engine includes a media access layer <b>312</b> of network drivers (e.g., gigabit Ethernet drivers) that interfaces to network protocol layers, such as the IP layer <b>314</b> and its supporting transport mechanisms, the TCP layer <b>316</b> and the User Datagram Protocol (UDP) layer <b>315</b>. A file system protocol layer provides multi-protocol file access and, to that end, includes support for the Direct Access File System (DAFS) protocol <b>318</b>, the NFS protocol <b>320</b>, the CIFS protocol <b>322</b> and the Hypertext Transfer Protocol (HTTP) is protocol <b>324</b>. A VI layer <b>326</b> implements the VI architecture to provide direct access transport (DAT) capabilities, such as RDMA, as required by the DAFS protocol <b>318</b>. An iSCSI driver layer <b>328</b> provides block protocol access over the TCP/IP network protocol layers, while a FC driver layer <b>330</b> receives and transmits block access requests and responses to and from the node. The FC and iSCSI drivers provide FC-specific and iSCSIspecific access control to the blocks and, thus, manage exports of luns to either iSCSI or FCP or, alternatively, to both iSCSI and FCP when accessing the blocks on the node <b>200</b>.</p>
<p id="p-0043" num="0042">In addition, the storage operating system includes a series of software layers organized to form a storage server <b>365</b> that provides data paths for accessing information stored on the disks <b>130</b> of the node <b>200</b>. To that end, the storage server <b>365</b> includes a file system module <b>360</b> in cooperating relation with a volume striping module (VSM) <b>370</b>, a RAID system module <b>380</b> and a disk driver system module <b>390</b>. The RAID system <b>380</b> manages the storage and retrieval of information to and from the volumes/disks in accordance with I/O operations, while the disk driver system <b>390</b> implements a disk access protocol such as, e.g., the SCSI protocol. The VSM <b>370</b> illustratively implements a striped volume set (SVS) and cooperates with the file system <b>360</b> to enable storage server <b>365</b> to service a volume of the SVS. In particular, the VSM <b>370</b> implements a Locate( ) function <b>375</b> to compute the location of data container content in the SVS volume to thereby ensure consistency of such content served by the cluster.</p>
<p id="p-0044" num="0043">The file system <b>360</b> implements a virtualization system of the storage operating system <b>300</b> through the interaction with one or more virtualization modules illustratively embodied as, e.g., a virtual disk (vdisk) module (not shown) and a SCSI target module <b>335</b>. The vdisk module enables access by administrative interfaces, such as a user interface of a management framework (not shown), in response to a user (system administrator) issuing commands to the node <b>200</b>. The SCSI target module <b>335</b> is generally disposed between the FC and iSCSI drivers <b>328</b>, <b>330</b> and the file system <b>360</b> to provide a translation layer of the virtualization system between the block (lun) space and the file system space, where luns are represented as blocks.</p>
<p id="p-0045" num="0044">The file system <b>360</b> is illustratively a message-based system that provides logical volume management capabilities for use in access to the information stored on the storage devices, such as disks. That is, in addition to providing file system semantics, the file system <b>360</b> provides functions normally associated with a volume manager. These functions include (i) aggregation of the disks, (ii) aggregation of storage bandwidth of the disks, and (iii) reliability guarantees, such as mirroring and/or parity (RAID). The file system <b>360</b> illustratively implements the WAFL file system (hereinafter generally the &#x201c;write-anywhere file system&#x201d;) having an on-disk format representation that is block-based using, e.g., 4 kilobyte (kB) blocks and using index nodes (&#x201c;inodes&#x201d;) to identify files and file attributes (such as creation time, access permissions, size and block location). The file system uses files to store meta-data describing the layout of its file system; these meta-data files include, among others, an mode file. A file handle, i.e., an identifier that includes an Mode number, is used to retrieve an Mode from disk.</p>
<p id="p-0046" num="0045">Broadly stated, all Modes of the write-anywhere file system are organized into the mode file. A file system (fs) info block specifies the layout of information in the file system and includes an Mode of a file that includes all other modes of the file system. Each logical volume (file system) has an fsinfo block that is preferably stored at a fixed location within, e.g., a RAID group. The inode of the inode file may directly reference (point to) data blocks of the inode file or may reference indirect blocks of the inode file that, in turn, reference data blocks of the inode file. Within each data block of the inode file are embedded inodes, each of which may reference indirect blocks that, in turn, reference data blocks of a file.</p>
<p id="p-0047" num="0046">Operationally, a request from the client <b>180</b> is forwarded as a packet over the computer network <b>140</b> and onto the node <b>200</b> where it is received at the network adapter <b>225</b>. A network driver (of layer <b>312</b> or layer <b>330</b>) processes the packet and, if appropriate, passes it on to a network protocol and file access layer for additional processing prior to to forwarding to the write-anywhere file system <b>360</b>. Here, the file system generates operations to load (retrieve) the requested data from disk <b>130</b> if it is not resident &#x201c;in core&#x201d;, i.e., in memory <b>224</b>. If the information is not in memory, the file system <b>360</b> indexes into the inode file using the inode number to access an appropriate entry and retrieve a logical vbn. The file system then passes a message structure including the logical vbn to the RAID system <b>380</b>; the logical vbn is mapped to a disk identifier and disk block number (disk,dbn) and sent to an appropriate driver (e.g., SCSI) of the disk driver system <b>390</b>. The disk driver accesses the dbn from the specified disk <b>130</b> and loads the requested data block(s) in memory for processing by the node. Upon completion of the request, the node (and operating system) returns a reply to the client <b>180</b> over the network <b>140</b>.</p>
<p id="p-0048" num="0047">It should be noted that the software &#x201c;path&#x201d; through the storage operating system layers described above needed to perform data storage access for the client request received at the node may alternatively be implemented in hardware. That is, in an alternate embodiment of the invention, a storage access request data path may be implemented as logic circuitry embodied within a field programmable gate array (FPGA) or an application specific integrated circuit (ASIC). This type of hardware implementation increases the performance of the storage service provided by node <b>200</b> in response to a request issued by client <b>180</b>. Moreover, in another alternate embodiment of the invention, the processing elements of adapters <b>225</b>, <b>228</b> may be configured to offload some or all of the packet processing and storage access operations, respectively, from processor <b>222</b>, to thereby increase the performance of the storage service provided by the node. It is expressly contemplated that the various processes, architectures and procedures described herein can be implemented in hardware, firmware or software.</p>
<p id="p-0049" num="0048">As used herein, the term &#x201c;storage operating system&#x201d; generally refers to the computer-executable code operable on a computer to perform a storage function that manages data access and may, in the case of a node <b>200</b>, implement data access semantics of a general purpose operating system. The storage operating system can also be implemented as a microkernel, an application program operating over a general-purpose operating system, such as UNIX&#xae; or Windows NT&#xae;, or as a general-purpose operating system with configurable functionality, which is configured for storage applications as described herein.</p>
<p id="p-0050" num="0049">In addition, it will be understood to those skilled in the art that the invention described herein may apply to any type of special-purpose (e.g., file server, filer or storage serving appliance) or general-purpose computer, including a standalone computer or portion thereof, embodied as or including a storage system. Moreover, the teachings of this invention can be adapted to a variety of storage system architectures including, but not limited to, a network-attached storage environment, a storage area network and disk assembly directly-attached to a client or host computer. The term &#x201c;storage system&#x201d; should therefore be taken broadly to include such arrangements in addition to any subsystems configured to perform a storage function and associated with other equipment or systems. It should be noted that while this description is written in terms of a write any where file system, the teachings of the present invention may be utilized with any suitable file system, including a write in place file system.</p>
<p id="p-0051" num="0050">D. SpinNP Network Protocol</p>
<p id="p-0052" num="0051">In the illustrative embodiment, the storage server <b>365</b> is embodied as D-blade <b>350</b> of the storage operating system <b>300</b> to service one or more volumes of array <b>120</b>. In addition, the multi-protocol engine <b>325</b> is embodied as N-blade <b>310</b> to (i) perform protocol termination with respect to a client issuing incoming data access request packets over the network <b>140</b>, as well as (ii) redirect those data access requests to any storage server <b>365</b> of the cluster <b>100</b>. Moreover, the N-blade <b>310</b> and D-blade <b>350</b> cooperate to provide a highly-scalable, distributed storage system architecture of the cluster <b>100</b>. To that end, each blade includes a cluster fabric (CF) interface module <b>500</b><i>a,b </i>adapted to implement a network protocol that enables intra-cluster communication among the blades, as described herein.</p>
<p id="p-0053" num="0052">The protocol layers, e.g., the NFS/CIFS layers and the iSCSI/FC layers, of the N-blade <b>310</b> function as protocol servers that translate file-based and block based data access requests from clients into network protocol messages used for communication with the D-blade <b>350</b>. That is, the N-blade servers convert the incoming data access requests into primitive operations (commands) that are embedded within messages by the CF interface module <b>500</b> for transmission to the D-blades <b>350</b> of the cluster <b>100</b>. Notably, the CF interface modules <b>500</b> cooperate to provide a single file system image across all Dblades <b>350</b> in the cluster <b>100</b>. Thus, any network port of an N-blade that receives a client request can access any data container within the single file system image located on any D-blade <b>350</b> of the cluster.</p>
<p id="p-0054" num="0053">Further to the illustrative embodiment, the N-blade <b>310</b> and D-blade <b>350</b> are implemented as separately-scheduled processes of storage operating system <b>300</b>; however, in an alternate embodiment, the blades may be implemented as pieces of code within a single operating system process. Communication between an N-blade and D-blade is thus illustratively effected through the use of message passing between the blades although, in the case of remote communication between an N-blade and D-blade of different nodes, such message passing occurs over the cluster switching fabric <b>150</b>. A known message-passing mechanism provided by the storage operating system to transfer information between blades (processes) is the Inter Process Communication (IPC) mechanism.</p>
<p id="p-0055" num="0054">The network protocol illustratively described herein is the Spin network protocol (SpinNP) that comprises a collection of methods/functions constituting a SpinNP application programming interface (API). The SpinNP API, in this context, is a set of software calls and routines that are made available (exported) by a process and that can be referenced by other processes. As described herein, all SpinNP protocol communication in the cluster occurs via connections. Communication is illustratively effected by the D-blade exposing the SpinNP API to which an N-blade (or another D-blade) issues calls. To that end, the CF interface module <b>500</b> is organized as a CF encoder and CF decoder. The CF encoder of, e.g., CF interface <b>500</b><i>a </i>on N-blade <b>310</b> encapsulates a SpinNP message as (i) a local procedure call (LPC) when communicating a command to a D-blade <b>350</b> residing on the same node <b>200</b> or (ii) a remote procedure call (RPC) when communicating the command to a D-blade residing on a remote node of the cluster <b>100</b>. As used herein, the term RPC shall be taken to mean both LPCs and RPCs. In either case, the CF decoder of CF interface <b>500</b><i>b </i>on D-blade <b>350</b> de-encapsulates the SpinNP message and processes the command. In accordance with the illustrative embodiment of the present invention, the CF encoder implements that message integrity check of the present invention.</p>
<p id="p-0056" num="0055"><figref idref="DRAWINGS">FIG. 4</figref> is a schematic block diagram illustrating the format of a SpinNP message <b>400</b> in accordance with an embodiment of with the present invention. The SpinNP message <b>400</b> is illustratively used for RPC communication over the switching fabric <b>150</b> between remote blades of the cluster <b>100</b>; however, it should be understood that the term &#x201c;SpinNP message&#x201d; may be used generally to refer to LPC and RPC communication between blades of the cluster. The SpinNP message <b>400</b> includes a media access layer <b>402</b>, an IP layer <b>404</b>, a UDP layer <b>406</b>, a reliable transport layer, such as a reliable connection (RC) layer <b>408</b>, and a SpinNP protocol layer <b>410</b>. As noted, the SpinNP protocol conveys commands related to operations contained within, e.g., client requests to access data containers stored on the cluster <b>100</b>; the SpinNP protocol layer <b>410</b> is that portion of message <b>400</b> that carries those commands. Illustratively, the SpinNP protocol is datagram based and, as such, involves transmission of messages or &#x201c;envelopes&#x201d; in a reliable manner from a sender (e.g., an N-blade <b>310</b>) to a receiver (e.g., a D-blade <b>350</b>). The RC layer <b>408</b> implements a reliable transport protocol that is adapted to process such envelopes in accordance with a connectionless protocol, such as UDP <b>406</b>.</p>
<p id="p-0057" num="0056">The SpinNP network protocol is illustratively a multi-layered protocol that integrates a session infrastructure and an application operation set into a session layer. The session layer manages the establishment and termination of sessions between blades in the cluster and is illustratively built upon a connection layer that defines a set of functionality or services provided by a connection-oriented protocol. The connection-oriented protocol may include a framing protocol layer over a network transport, such as RC and/or TCP, or a memory-based IPC protocol. These connections are formed via the network transport, or via the local memory-to-memory or adapter-to-memory transport, and provide a packet/message transport service with flow control. It should be noted that other connection-oriented protocols, perhaps over other transports, can be used, as long as those transports provide the same minimum guaranteed functionality, e.g., reliable message delivery.</p>
<p id="p-0058" num="0057">The SpinNP network protocol is illustratively a request/response protocol wherein to a blade (requester) receiving a data access request from a client redirects that request to another blade (responder) that services the request and, upon completion, returns a response. The network protocol is illustratively implemented by the CF interface modules <b>500</b> and, as such, a SpinNP session provides a context for the flow of request messages (requests) and a reverse direction flow of corresponding response messages (responses) to those requests. Each request consists of one SpinNP message and generates one response, unless the connection is lost or the session terminates abnormally. <figref idref="DRAWINGS">FIG. 5</figref> is a schematic block diagram illustrating the organization of the CF interface modules <b>500</b><i>a,b </i>adapted to implement the SpinNP protocol in accordance with the present invention. Each module <b>500</b><i>a,b </i>comprises a SpinNP session layer <b>510</b><i>a,b </i>and a connection layer <b>550</b><i>a,b. </i></p>
<p id="p-0059" num="0058">As noted, the SpinNP network protocol <b>410</b> relies on connections for reliable message delivery. As such, a session <b>580</b> is disposed over one or more connections <b>560</b> and is illustratively established between a pair of blades or other participants. For example, a session can be established between D-blades, between an N-blade and a D-blade, and between N-blades (if there proves to be a need for N-blade-to-N-blade SpinNP calls). The session can also be used to inter-connect other entities or agents, including userspace processes and services, to blades or to each other. Each pair of blades typically requires only one session to communicate; however, multiple sessions can be opened simultaneously between the same pair of blades. Each session requires bi-directional request flow over the same connection. The session <b>580</b> also provides an infrastructure that makes messages secure and supports recovery without requiring an additional protocol layer between the network transport layer (RC or TCP) and the application layer (e.g., file access operations). Each session is independently negotiated and initiated to thereby enable a high level of message concurrency and asynchrony.</p>
<p id="p-0060" num="0059">The connections <b>560</b> are established by the connection layers <b>510</b><i>a,b </i>and provide the network transport for the sessions between the blades. At least one connection is required for each session, wherein the connection is used for both requests and responses. Although more than one connection can be bound to a session, only connections that are bound to the session can be used to carry the requests and responses for that session. The connections <b>560</b> are bi-directional, allowing message flow in each direction. For example, requests flow in both directions on each session, thereby allowing forward (operational) and reverse (callback) flows to be sent through the same session. Responses for both directions of request flow are also carried in the session. Connections that are bound to sessions cannot be shared by multiple sessions; however, multiple sessions may be is multiplexed onto a single connection. That is, operational and callback sessions between an N-blade/D-blade pair can be multiplexed onto a single connection. Sessions can also multiplex operations for different clients and different users.</p>
<p id="p-0061" num="0060">Each session <b>580</b> is illustratively identified by a globally unique identifier (id) formed of the universal unique ids (UUIDs) of its two participant blades, with the session initiator's UUID listed first. The globally unique id is combined with a 64-bit uniquifier that is unique for all concurrent sessions between the pair of blades, regardless of which blade is the initiator, as well as for any dormant recoverable session for which any state is still stored on either of the two blades. The uniquifier may be generated using the current time, indicating the time of constructing a session initiation operation, i.e., CREATE_SESSION, conveyed within an appropriate request. The resulting session id uniquifier is then confirmed to be unique by the receiver blade. Note that the id uniquifier should be unique unless both blades are trying to create a session to each other simultaneously. If so, each blade can counter-propose a different session id, possibly by simply adding a small random number to the original proposed session id uniquifier.</p>
<p id="p-0062" num="0061">Illustratively, GSS security is performed on a per session basis. During session initialization, a secure GSS-API key exchange is performed. The exchanged keys are utilized for subsequent encryption of a message integrity check, described further below. It should be noted that while, in the illustrative embodiment, the participants to a GSS security session are the blades of a node, the principles of the present invention may be utilized in other contexts. As such, the use of the message integrity check between blades of a node should be taken as exemplary only.</p>
<p id="p-0063" num="0062">E. Message Integrity Check</p>
<p id="p-0064" num="0063">The present invention is directed to a system and method for generating a message integrity check for use in data transmissions, including, e.g., RPC-based network protocols executing on nodes of a cluster. All network protocol communication in the cluster occurs via connections, which provide a network transport for sessions between the requesters/responders. At least one connection is required for each session, wherein the connection is used for both requests and responses. Each request/response is embodied as a RPC that is transmitted over one of the connections. Each RPC comprises a header and a set of procedure specific parameters. For network protocol RPCs, the procedure specific parameters include a control portion and the data associated with the RPC.</p>
<p id="p-0065" num="0064">In the illustrative embodiment of the invention, one or more block checksums are generated in the control portion of the RPC. These block checksums may be quickly computed using conventional data checksumming procedures for the data contained within the RPC. In addition, block sizes of the checksums are illustratively selected so that the checksum may be utilized at multiple stages of processing. For example, assume a file system executing on the D-blade utilizes 4 kilobyte (KB) blocks for internal operations and for writing to disk. Accordingly, the block size for the block checksums may be selected as 4 KB in size. This permits the use of the checksum for end-to-end data protection, e.g., from N-blade to D-blade to disk or vice versa. It should be noted that the block checksum(s) would typically be computed by either the sender and/or recipient.</p>
<p id="p-0066" num="0065">According to one embodiment of the invention, the block checksum(s) of the control portion of the RPC are hashed and the resulting hash value encrypted to generate the message integrity check. This aspect of the invention contemplates use of a strong data checksum, such as the well-known MD-5, to provide a high confidence that the transmitted data is valid without checksumming the same data twice. It is noted that a block checksum may not be removed without detection; accordingly, an attacker would only be able to modify the data in a way that does not modify the block checksum. By using a sufficiently strong hashing algorithm, the probability of successfully modifying the data while maintaining the proper checksum is greatly reduced.</p>
<p id="p-0067" num="0066"><figref idref="DRAWINGS">FIG. 6</figref> is a schematic block diagram of an exemplary RPC header data structure <b>600</b> as described in the above-incorporated <i>RPC: Remote Procedure Call Specification Version </i>2. The RPC header data structure <b>600</b> includes a RPC version field <b>605</b>, a program field <b>610</b>, a version field <b>615</b>, a process field <b>620</b>, a credential field <b>625</b> and, in alternate embodiments, additional fields <b>630</b>. The RPC version field <b>605</b> identifies the version of the RPC specification used within the RPC. The program field <b>610</b> identifies the program originating the RPC, whereas the version field <b>615</b> identifies the version of the program identified in the program field <b>610</b>. The process field <b>620</b> identifies the process to be performed by the RPC and the credential field <b>625</b> contains an authentication credential for the RPC.</p>
<p id="p-0068" num="0067"><figref idref="DRAWINGS">FIG. 7</figref> is a schematic block diagram of an exemplary RPC data structure <b>900</b> showing an RPC protected using the message integrity check of the present invention. The RPC data structure <b>700</b> includes a RPC header data structure <b>600</b>, a set of procedure specific parameters <b>740</b> and the novel message integrity check <b>725</b>. The procedure specific parameters <b>740</b> include a control portion <b>705</b> and a set of data <b>720</b>. The control portion <b>705</b> includes one or more block checksums <b>715</b> and additional operation specific fields <b>710</b>. In accordance with the illustrative embodiment of the present invention, the block checksum(s) <b>715</b> is hashed along with the other control and header portions of the message to be integrity protected and the resulting value encrypted to form the message integrity check <b>725</b>. As the block checksum(s) may not be removed or modified without detection, the data itself may only be modified in ways that do not change the block checksum. Using a sufficiently strong data checksum technique, such as MD-5, makes it highly improbable that an attacker could maliciously modify the data and still produce the proper block checksum and message integrity check.</p>
<p id="p-0069" num="0068"><figref idref="DRAWINGS">FIG. 8</figref> is a schematic block diagram of an exemplary data transmission <b>800</b> protested by the message integrity check of the present invention. The data transmission <b>800</b> comprises one or more block checksums <b>805</b>, data <b>810</b> and the novel message integrity check <b>815</b>. The block checksum(s) <b>805</b> are computed of the data <b>810</b>. In accordance with the present invention, the block checksum(s) is then hashed to obtain the message integrity check <b>815</b>. Illustratively, the data transmission may be a single element of a data to stream. Or may comprise any other form of data transmission that incorporates a block checksum.</p>
<p id="p-0070" num="0069"><figref idref="DRAWINGS">FIG. 9</figref> is a flowchart detailing the steps of procedure <b>1000</b> for generating a message integrity check in accordance with an embodiment of the present invention. The procedure <b>900</b> begins in step <b>905</b> and continues to step <b>910</b> where the RPC header is generated by the session layer <b>510</b>. Illustratively, GSS security is associated with a particular session <b>580</b>; however in alternate embodiments, GSS security may be associated with individual users and/or nodes. As such the description of GSS associated with a session should be taken as exemplary only. In step <b>915</b> the data is checksummed using the appropriate checksumming algorithm to generate the block checksums. As noted above, it is advantageous to checksum in block sizes that are used throughout the data pathways to prevent the need for checksumming the data twice (or more). In step <b>920</b>, the other fields of the control portion are generated. The message integrity check is then generated in step <b>925</b> by hashing the block checksum(s) and control portion and then encrypting the resulting hash values. In step <b>930</b>, the message integrity check is appended to the RPC data structure before the RPC is transmitted to the destination in step <b>935</b>. The procedure then completes in step <b>940</b>.</p>
<p id="p-0071" num="0070"><figref idref="DRAWINGS">FIG. 10</figref> is a flowchart detailing the steps of a procedure for processing a received RPC that is protected with a message integrity check of the present invention. The procedure <b>1000</b> begins in step <b>1005</b> and continues to step <b>1010</b> where an RPC that is protected by a message integrity check is received by, e.g., a CF decoder. In step <b>1015</b>, the CF decoder hashes the block checksum(s) of the received RPC and encrypts the resulting value. The resulting encrypted value is compared with the received message integrity check in step <b>1020</b> and, in step <b>1025</b>, a determination is made as to whether there is a match. If so, the procedure continues to step <b>1027</b> where the block checksum(s) are validated against the stored data by, e.g., recomputing the checksum(s) using the received data. In step <b>1029</b>, a determination is made whether the block checksum(s) match. If so, the procedure continues to step <b>1030</b> where the operation contained within the RPC is processed before the procedure completes in step <b>1035</b>. However, if there is no match, the procedure branches to step <b>1040</b> where the RPC is rejected. It should be noted that the block checksums may also be utilized for storing the data on storage devices, such as disks.</p>
<p id="p-0072" num="0071">Advantageously, use of a hash of the block checksum preserves the integrity of the data within the protocol specific parameters of a RPC. An attempt to compromise the integrity of the data by, e.g., a network attacker, would require modifying the data in a meaningful way that does not modify the block checksum. As noted above, the use of a sufficiently strong hashing algorithm provides a high degree of security by rendering it highly improbable that an attacker could succeed in modifying the data while maintaining the proper block checksum. Additionally, it is highly improbable that the checksums could be removed or modified without detection via the message integrity check.</p>
<p id="p-0073" num="0072">It is important to note that the system would typically compute the block checksum even if the present invention was not utilized. As such, the added computations to hash the block checksums is minimal compared to the processing required to hash the data to generate the block checksums. Thus, the message integrity check of the present invention may be utilized with any data transmission, including, RPCs, data streams, file-level protocols, etc. To compute the message integrity check of the data transmission, one only needs to compute the message integrity of the block checksums and any header information, which may be performed substantially faster than conventional Integrity verification.</p>
<p id="p-0074" num="0073">The foregoing description has been directed to particular embodiments of this invention. It will be apparent, however, that other variations and modifications may be made to the described embodiments, with the attainment of some or all of their advantages. The present invention may be applied to any wire protocol or other form of data transmission. While the present invention has been written in terms of protection of file protocols or RPCs, the teachings of the present invention may be applied to any form of data transmission that includes block checksums. Additionally, the procedures, processes, layers and/or modules described herein may be implemented in hardware, software, embodied as a computer-readable medium having program instructions, firmware, or a combination thereof. Therefore, it is the object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the invention.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for generating a message integrity check for a data transmission between a plurality of nodes of a cluster, the method comprising:
<claim-text>generating a single remote procedure call (RPC) data structure at a source node of the cluster to transmit data of the data transmission, wherein each node includes a memory and processor and wherein requests and responses between the nodes include RPC data structures;</claim-text>
<claim-text>computing one or more block checksums from the data of the data transmission to be included in the single RPC data structure;</claim-text>
<claim-text>hashing the computed one or more block checksums in the single RPC data structure to generate a hash value;</claim-text>
<claim-text>encrypting the hash value to generate the message integrity check;</claim-text>
<claim-text>appending the message integrity check to the single RPC data structure, wherein the single RPC data structure includes a header section, a control portion maintaining the one or more block checksums, a data section maintaining the data, and a message integrity section maintaining the message integrity check; and</claim-text>
<claim-text>transmitting, over a computer network, the single RPC data structure To a destination node of the cluster of the plurality of nodes, wherein the destination node processes an operation contained within the control portion of the single RPC data structure based on a second message integrity check computed by the destination node and associated with the RPC data structure matching the message integrity check appended to the RPC data structure.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein each node includes a network element and a disk element.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising:
<claim-text>receiving, at the destination node, the single RPC data structure;</claim-text>
<claim-text>hashing the one or more block checksums to generate a second hash value;</claim-text>
<claim-text>encrypting the second hash value to form the second message integrity check; and</claim-text>
<claim-text>comparing the message integrity check appended to the RPC data structure with the second message integrity check.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref> further comprising:
<claim-text>rejecting, in response to determining that the second message integrity check is not identical to the message integrity check appended to the RPC data structure, the operation contained within the control portion of the single RPC data structure.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein computing the one or more block checksums from the data of the data transmission utilizes a MD-5 hashing algorithm.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the one or more block checksums are computed on a specified block size of the data.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the single RPC data structure comprises a data stream.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the single RPC data structure comprises a file-level protocol.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the one or more block checksums are utilized to perform a subsequent validation of the data.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref> wherein the subsequent validation occurs when the data is read from a storage device after being previously written to the storage device with the one or more block checksums.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. A system, comprising:
<claim-text>one or more network elements and one or more disk elements organized as a cluster; and</claim-text>
<claim-text>a cluster fabric module of each of the network and the disk elements configured to:
<claim-text>send requests and responses that include remote procedure call (RPC) data structures,</claim-text>
<claim-text>generate a single RPC data structure to transmit data to a destination element,</claim-text>
<claim-text>compute one or more block checksums of from data in a data transmission of the single RPC data structure to be included in the single RPC data structure,</claim-text>
<claim-text>hash the computed one or more block checksums to generate a hash value,</claim-text>
<claim-text>encrypt the hash value to generate a message integrity check,</claim-text>
<claim-text>append the message integrity check to the single RPC data structure, and</claim-text>
<claim-text>transmit, over a computer network, the single RPC data structure including the one or more block checksums and the data, with the appended integrity check, to the destination element wherein the destination element processes an operation contained within the single RPC data structure based on a is second integrity check computed by the destination element matching the message integrity check appended to the RPC data structure.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The system of <claim-ref idref="CLM-00011">claim 11</claim-ref> wherein the single RPC data structure comprises a data stream.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The system of <claim-ref idref="CLM-00011">claim 11</claim-ref> wherein the single RPC data structure comprises a file-level protocol.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The system of <claim-ref idref="CLM-00011">claim 11</claim-ref> wherein the one or more block checksums are utilized to perform a subsequent validation of the data.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The system of <claim-ref idref="CLM-00014">claim 14</claim-ref> wherein the subsequent validation occurs when the data is read from a storage device after being previously written to the storage device with the one or more block checksums.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. A system for generating a message integrity check for a data transmission between a plurality of nodes of a cluster, comprising:
<claim-text>means for generating a single remote procedure call (RPC) data structure at a source node of the cluster, to transmit data of the data transmission, wherein each node comprises a memory and processor and wherein requests and responses between the nodes include RPC data structures;</claim-text>
<claim-text>means for computing one or more block checksums of from the data in the data transmission to be included in the sing RPC data structure;</claim-text>
<claim-text>means for hashing the computed one or more block checksums in the single RPC data structure to generate a hash value;</claim-text>
<claim-text>means for encrypting the hash value to generate the message integrity check;</claim-text>
<claim-text>means for appending the message integrity check to the single RPC data structure,</claim-text>
</claim-text>
<claim-text>wherein the single RPC data structure includes a header section, a control portion maintaining the one or more block checksums, a data section maintaining the data, and a message integrity section maintaining the message integrity check; and
<claim-text>means for transmitting, over a computer network, the single RPC data structure to a destination node of the cluster of the plurality of nodes, wherein the destination node processes an operation contained within the control portion of the single RPC data structure based on a second message integrity check computed by the destination node and associated with the RPC data structure matching the message integrity check appended to the RPC data structure.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The system of <claim-ref idref="CLM-00016">claim 16</claim-ref> wherein the single RPC data structure comprises a data stream.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The system of <claim-ref idref="CLM-00016">claim 16</claim-ref> wherein the single RPC data structure comprises a file-level protocol.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The system of <claim-ref idref="CLM-00016">claim 16</claim-ref> wherein the one or more block checksums are utilized to perform a subsequent validation of the data.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The system of <claim-ref idref="CLM-00019">claim 19</claim-ref> wherein the subsequent validation occurs when the data is read from a storage device after being previously written to the storage device with the one or more block checksums.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. A computer readable medium for containing executable program instructions executed by a processor, comprising:
<claim-text>program instructions that generate a single remote procedure call (RPC) data structure for a source node of a cluster of a plurality of nodes, to transmit data of a data transmission, wherein each node comprises a memory and processor and wherein requests and responses between the nodes include RPC data structures;</claim-text>
<claim-text>program instructions that compute one or more block checksums of from the data in the data transmission to be included in the RPC data structure;</claim-text>
<claim-text>program instructions that hash the computed one or more block checksums in the single RPC data structure to generate a hash value;</claim-text>
<claim-text>program instructions that encrypt the hash value to generate the message integrity check;</claim-text>
<claim-text>program instructions that append the message integrity check to the single RPC data structure, wherein the single RPC data structure includes a header section, a control portion maintaining the one or more block checksums, a data section maintaining the data, and a message integrity section maintaining the message integrity check; and</claim-text>
<claim-text>program instructions that transmit, over a computer network, the single RPC data structure, to a destination node of the cluster of the plurality of nodes, wherein the destination node processes an operation contained within the control portion of the single RPC data structure in response to the destination node determining a second message integrity check associated with the RPC data structure and calculated by the destination node is identical to the message integrity check.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
