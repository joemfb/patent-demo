<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627008-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627008</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12700043</doc-number>
<date>20100204</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>886</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>12</main-group>
<subgroup>08</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>12</main-group>
<subgroup>00</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>711121</main-classification>
<further-classification>711144</further-classification>
<further-classification>711146</further-classification>
<further-classification>711E12033</further-classification>
<further-classification>711E12041</further-classification>
</classification-national>
<invention-title id="d2e53">Memory access prediction</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5761715</doc-number>
<kind>A</kind>
<name>Takahashi</name>
<date>19980600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5875468</doc-number>
<kind>A</kind>
<name>Erlichson</name>
<date>19990200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6557080</doc-number>
<kind>B1</kind>
<name>Burger et al.</name>
<date>20030400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711137</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6571315</doc-number>
<kind>B2</kind>
<name>Campbell</name>
<date>20030500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>7206902</doc-number>
<kind>B2</kind>
<name>Hakura et al.</name>
<date>20070400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>7243195</doc-number>
<kind>B2</kind>
<name>O'Brien et al.</name>
<date>20070700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>7266642</doc-number>
<kind>B2</kind>
<name>Shen et al.</name>
<date>20070900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>7308538</doc-number>
<kind>B2</kind>
<name>Shen</name>
<date>20071200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>7360032</doc-number>
<kind>B2</kind>
<name>Cantin et al.</name>
<date>20080400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>7363435</doc-number>
<kind>B1</kind>
<name>Stenstrom</name>
<date>20080400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>7437517</doc-number>
<kind>B2</kind>
<name>da Silva et al.</name>
<date>20081000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2009/0024835</doc-number>
<kind>A1</kind>
<name>Fertig et al.</name>
<date>20090100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712207</main-classification></classification-national>
</us-citation>
</us-references-cited>
<number-of-claims>20</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>4</number-of-drawing-sheets>
<number-of-figures>5</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20110191546</doc-number>
<kind>A1</kind>
<date>20110804</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Qureshi</last-name>
<first-name>Moinuddin Khalil Ahmed</first-name>
<address>
<city>White Plains</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Qureshi</last-name>
<first-name>Moinuddin Khalil Ahmed</first-name>
<address>
<city>White Plains</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Law Offices of Ira D. Blecker, P.C.</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Bragdon</last-name>
<first-name>Reginald</first-name>
<department>2189</department>
</primary-examiner>
<assistant-examiner>
<last-name>Loonan</last-name>
<first-name>Eric</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">An apparatus for memory access prediction which includes a plurality of processors, a plurality of memory caches associated with the processors, a plurality of saturation counters associated with the processors, each of the saturation counters having an indicator bit, and a physical memory shared with the processors, saturation counters and memory caches. Upon a cache miss for a data item, a cache snoop and access to physical memory are initiated in parallel for the data item if the indicator bit is a first predetermined bit (one (1) or zero (0)) whereas a cache snoop is initiated if the most significant bit is a second predetermined bit (zero (0) or one (1)).</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="151.47mm" wi="155.36mm" file="US08627008-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="191.01mm" wi="181.36mm" file="US08627008-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="211.50mm" wi="167.22mm" file="US08627008-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="214.04mm" wi="158.24mm" file="US08627008-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="233.26mm" wi="161.46mm" file="US08627008-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0002" num="0001">The present invention relates to multiprocessor systems having caches and physical memory and, more particularly, relates to prediction in a multiprocessor system of whether a data item responsive to a cache miss can be found in cache or physical memory.</p>
<p id="p-0003" num="0002">In a multiprocessor system, when there is a cache miss in one of the processors, the data item may be available in the cache of another processor. If the data item is not available in any of the other processors, then memory is accessed and the data item is obtained from memory.</p>
<p id="p-0004" num="0003">On a cache miss in one of the processors, it would be desirable to get the data item with the lowest latency while keeping the number of memory accesses as low as possible. Reduced latency increases processor performance, whereas, reducing memory accesses reduces the contention for off-chip bandwidth and or ports in the memory banks, and also reduces power consumption in the memory system. However, the two objectives of reduced memory latency and fewer memory accesses may contradict each other. Current processors typically employ a LateAccess policy, which waits for a cache snoop response from other processors before accessing memory. If the data item is not present in the multiprocessor system, then memory is accessed. This policy avoids extraneous memory fetches albeit at increased latency for memory accesses. Processors can also employ an EarlyAccess policy which reduces memory latency by accessing memory in parallel with snooping the other processors. If the data item is already present in other processors, then the data item obtained from memory is discarded. These extraneous fetches from memory cause contention in the memory system and increase power consumption.</p>
<heading id="h-0002" level="1">BRIEF SUMMARY OF THE INVENTION</heading>
<p id="p-0005" num="0004">It would be desirable to have an EarlyAccess policy for data items likely to be present in memory and a LateAccess policy for data items likely to be present in the processors. To this end, the present inventor presents a prediction mechanism that predicts when the processors should use LateAccess policy and when the processors should use EarlyAccess policy to fetch a data item responsive to a cache miss.</p>
<p id="p-0006" num="0005">The various advantages and purposes of the present invention as described above and hereafter are achieved by providing, according to a first aspect of the invention, an apparatus for memory access prediction which includes a plurality of processors, a plurality of memory caches associated with the processors, a physical memory, and a plurality of saturation counters associated with the processors, each of the saturation counters having an indicator bit for predicting whether a data item may be found by a cache snoop or by accessing physical memory in parallel with a cache snoop. Upon a cache miss for a data item, a cache snoop and access to the physical memory are initiated in parallel for the data item if the indicator bit is a first predetermined bit (one (1) or zero (0)) whereas a cache snoop is initiated if the most significant bit is a second predetermined bit (zero (0) or one (1)).</p>
<p id="p-0007" num="0006">According to a second aspect of the invention, there is provided an apparatus for memory access prediction which includes a cluster which further includes a plurality of processors, a plurality of memory caches associated with the processors, a physical memory, and a plurality of saturation counters associated with the processors, each of the saturation counters having an indicator bit for predicting whether a data item may be found by a cache snoop or by accessing physical memory in parallel with a cache snoop. Upon a cache miss for a data item, a cache snoop and access to the physical memory are initiated in parallel for the data item if the indicator bit is a first predetermined bit (one (1) or zero (0)) whereas a cache snoop is initiated if the most significant bit is a second predetermined bit (zero (0) or one (1)).</p>
<p id="p-0008" num="0007">According to a third aspect of the invention, there is provided a method for memory access prediction in multiprocessors including a plurality of processors, a plurality of memory caches associated with the processors, a plurality of saturation counters associated with the processors, and a physical memory shared with the processors, saturation counters and memory caches. The method includes the steps of, responsive to a cache miss for a data item, consulting by a computer processor a saturation counter to predict whether a data item will be fetched from a cache of a processor or physical memory wherein the saturation counter keeps track of data items actually obtained in a previous cache miss from a cache of a processor of the plurality of processors or from physical memory and the saturation counter has an indicator bit such that if the indicator bit in the saturation counter is a first predetermined bit (one (1) or zero (0)), a cache snoop and access to physical memory in parallel is predicted for the data item and if the indicator bit is a second predetermined bit (zero (0) or one (1)), a cache snoop is predicted for the data item, and initiating by a computer processor a cache snoop and access to physical memory in parallel for the data item if the indicator bit is the first predetermined bit or initiating by a computer processor a cache snoop if the indicator bit is the second predetermined bit.</p>
<p id="p-0009" num="0008">According to a fourth aspect of the invention, there is provided a computer program product for memory access prediction in multiprocessors comprising a plurality of processors, a plurality of memory caches associated with the processors, a plurality of saturation counters associated with the processors, and a physical memory shared with the processors, saturation counters and memory caches, and including a computer readable storage medium having computer readable program code embodied therewith, the computer readable program code which further includes, responsive to a cache miss for a data item, computer readable program code configured to consult a saturation counter to predict whether a data item may be fetched from a cache or physical memory wherein the saturation counter keeps track of data items actually obtained in a previous cache miss from a cache of a processor or from physical memory and the saturation counter has an indicator bit such that if the indicator bit in the saturation counter is a first predetermined number, a cache snoop and access to physical memory in parallel is predicted for the data item and if the indicator bit is a second predetermined number, a cache snoop is predicted for the data item, and computer readable program code configured to initiate a cache snoop and access to physical memory in parallel for the data item if the indicator bit is the first predetermined bit or to initiate a cache snoop if the indicator bit is the second predetermined bit.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0010" num="0009">The features of the invention believed to be novel and the elements characteristic of the invention are set forth with particularity in the appended claims. The Figures are for illustration purposes only and are not drawn to scale. The invention itself, however, both as to organization and method of operation, may best be understood by reference to the detailed description which follows taken in conjunction with the accompanying drawings in which:</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram of a multiprocessor system according to the present invention.</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram of a portion of a multiprocessor system showing a saturation counter as used in the present invention.</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 3</figref> is a representation of a 4-bit and 5-bit saturation counter.</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 4</figref> is a flow chart illustrating an implementation of the method of the present invention.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 5</figref> is a block diagram illustrating an exemplary hardware environment of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION OF THE INVENTION</heading>
<p id="p-0016" num="0015">Referring to the Figures in more detail, and particularly referring to <figref idref="DRAWINGS">FIG. 1</figref>, there is shown a chip multiprocessor (CMP) system <b>10</b> having a plurality of processors or cores <b>12</b>, each with a private cache <b>14</b>. Processor and core may be used interchangeably throughout the discussion of the present invention. Connecting caches <b>14</b> is a snoop bus <b>18</b> which is used to maintain cache coherence. A shared memory (e.g., RAM) <b>20</b>, also called physical memory, is coupled to the processors <b>12</b> and caches <b>14</b> by a bus <b>28</b>. Each cache <b>14</b> has a cache controller <b>16</b> to handle movement of cache lines between the cache and memory for cache misses. The group of processors <b>12</b>, caches <b>14</b>, cache controllers, <b>16</b>, snoop bus <b>18</b>, bus <b>28</b> and memory <b>20</b> constitute a cluster <b>24</b>. There may be one or a plurality of such clusters <b>24</b> connected by a high speed bus <b>26</b> to make up the CMP. Other features inherent in a CMP system are not shown as they are not relevant to the present invention. While there are four processors and caches shown in cluster <b>24</b> in <figref idref="DRAWINGS">FIG. 1</figref>, there may be more or less than four processors and caches depending on the computer architecture.</p>
<p id="p-0017" num="0016">For purposes of illustration and not limitation, the Figures and the discussion use a CMP system to describe the various embodiments of the present invention. However, the present invention is applicable to any multiprocessor organization, such as CMP or SMP (Symmetric Multiprocessing system), using snoopy protocols to maintain cache coherence.</p>
<p id="p-0018" num="0017">The problem addressed by the current invention can be framed in the following manner. If a memory request for a data item from core A does not find the data item in cache A, there is a cache miss which is broadcast to all the other caches (B, C, and D in <figref idref="DRAWINGS">FIG. 1</figref>) in the CMP system <b>10</b>. If one of the other caches (B, C, and D in <figref idref="DRAWINGS">FIG. 1</figref>) in the system has a copy of the requested data item, the corresponding cache line is sent to cache A, and the data item requested is sent to core A. Cache line and data item may be used interchangeably herein. If the requested data item is not present in any of the caches, the corresponding cache line is fetched from memory <b>20</b> (in <figref idref="DRAWINGS">FIG. 1</figref>), and installed in cache A, and core A's request is satisfied. If it is possible to predict whether the data item may be found in the caches in cluster <b>24</b> or in memory <b>20</b>, reduced latency while keeping the number of memory accesses as low as possible may be advantageously achieved.</p>
<p id="p-0019" num="0018">In one preferred embodiment of the present invention, a saturation counter is associated with each processor <b>12</b> in the cluster <b>24</b>. In one preferred embodiment, the saturation counter is located in the cache controller <b>16</b>.</p>
<p id="p-0020" num="0019">Referring now to <figref idref="DRAWINGS">FIG. 2</figref>, a portion of cluster <b>24</b> is shown in greater detail. Cache controller <b>16</b> is connected by a data bus <b>32</b> to cache <b>14</b>. Located within cache controller <b>16</b> is saturation counter <b>30</b>. The location of saturation counter <b>30</b> is preferably within cache controller <b>16</b> but its location is a matter of design and may be located in other portions of cluster <b>24</b>. Each processor <b>12</b> and cache <b>14</b> may have a saturation counter <b>30</b> associated with it. The saturation counter <b>30</b> keeps track of whether past cache misses have been serviced by cache <b>14</b> from other processors <b>12</b> or by memory <b>20</b>.</p>
<p id="p-0021" num="0020">A saturation counter has a maximum value and a minimum value. When the saturation counter reaches its maximum value, incrementing the saturation counter will not change the maximum value and when the saturation counter reaches its minimum value, decrementing the saturation counter will not change the minimum value.</p>
<p id="p-0022" num="0021">Referring now to <figref idref="DRAWINGS">FIG. 3</figref>, there is shown an exemplary embodiment of the saturation counter <b>30</b>. For purposes of illustration and not limitation, saturation counter <b>30</b> is a 4-bit counter having a minimum value of zero (0) and a maximum value of fifteen (15). In general, the saturation counter may have 4 or 5 bits although saturation counters having fewer or greater numbers of bits are within the scope of the present invention. Saturation counter <b>30</b> also has a &#x201c;most significant bit&#x201d; (MSB) which is defined as the farthest left bit <b>38</b> as indicated in <figref idref="DRAWINGS">FIG. 3</figref>. For the 4-bit saturation counter <b>30</b> shown in <figref idref="DRAWINGS">FIG. 3</figref>, for values of zero (0) to 7 the MSB will be zero (0) while for values of eight (8) to fifteen (15) the MSB will be one (1). For a 5-bit saturation counter <b>30</b>, the fifth bit, which is also the MSB of the 5-bit saturation counter <b>30</b>, is shown in phantom.</p>
<p id="p-0023" num="0022">Referring now also to <figref idref="DRAWINGS">FIG. 2</figref>, when there is a cache miss in a given processor, for example core A, and the cache line (data item) is obtained from other processors in the system, then the saturation counter <b>30</b> for core A is decremented, as indicated by negative sign <b>34</b> in saturation counter <b>30</b>. If the cache line (data item) is obtained from physical memory <b>20</b>, then the saturation counter <b>30</b> for core A is incremented, as indicated by positive sign <b>36</b> in saturation counter <b>30</b>. An indicator bit in saturation counter <b>30</b> may be used to predict EarlyAccess or LateAccess policy. It is most preferred that the indicator bit is the MSB for both the 4-bit and 5-bit saturation counters. Thus, if the indicator bit of the saturation counter <b>30</b> for core A is 1, then most of the cache misses of core A were serviced by memory and hence an EarlyAccess policy is predicted for future memory requests. If the indicator bit of the saturation counter <b>30</b> for core A is 0, then most misses of core A were satisfied by other processors in cluster <b>24</b>, and hence a LateAccess policy is predicted for future memory requests. Therefore, if the indicator bit of the saturation counter <b>30</b> for core A is one (1), core A is predicted to use an EarlyAccess policy while if the indicator bit of the saturation counter <b>30</b> for core A is zero (0), core A is predicted to use a LateAccess policy. The decision of whether an EarlyAccess policy or LateAccess policy should be used is determined for each processor independently using a saturation counter for each processor.</p>
<p id="p-0024" num="0023">In a further embodiment of the present invention, the function of the indicator bit could be reversed such that when a cache miss is serviced by other processors in the system, the saturation counter <b>30</b> for the core requesting the information is incremented while if the cache miss is serviced by memory <b>20</b>, then the saturation counter <b>30</b> for the core requesting the information is decremented. It follows then that if the indicator bit of the saturation counter <b>30</b> for core A is zero (0) in this embodiment, core A is predicted to use an EarlyAccess policy for future memory requests while if the indicator bit of the saturation counter <b>30</b> for core A is one (1), core A is predicted to use a LateAccess policy for future memory requests.</p>
<p id="p-0025" num="0024">In a further embodiment of the present invention, each cache controller <b>16</b> in cluster <b>24</b> may include more than one saturation counter <b>30</b>. For example, in one preferred embodiment, there may be two saturation counters <b>30</b> for each cache controller <b>16</b> in cluster <b>24</b>. In operation, one saturation counter <b>30</b> may predict EarlyAccess or LateAccess policy for cache lines (data items) have an odd address while another saturation counter <b>30</b> may predict EarlyAccess or LateAccess policy for cache lines (data items) have an even address.</p>
<p id="p-0026" num="0025">The method of the present invention may be illustrated by the flow chart in <figref idref="DRAWINGS">FIG. 4</figref>. In block <b>40</b>, there is a cache miss for a data item. In block <b>42</b>, the cache controller consults a saturation counter to predict whether the data item may be found in a cache of another processor in the cluster or in physical memory. The saturation counter keeps track of where data items were actually obtained in previous cache misses, that is, from a cache of a processor in the cluster or from physical memory. The saturation counter has an indicator bit which preferably is the most significant bit in the saturation counter. It is most preferred that the saturation counter be a 4-bit or 5-bit saturation counter. In block <b>44</b>, the cache controller keeps track of the indicator bit of the saturation counter based on past cache misses. If the indicator bit is a first predetermined number (1 if the saturation counter is incremented for data items fetched from memory or 0 if the saturation counter is decremented for data items fetched from memory), then accessing physical memory in parallel with a cache snoop (EarlyAccess policy) is predicted for the data item. If the indicator bit is a second predetermined number (0 if the saturation counter is decremented for data items fetched from cache or 1 if the saturation counter is incremented for data items fetched from cache), then first access to a cache snoop (LateAccess policy) is predicted to be performed for the data item. In block <b>44</b>, a cache controller may determine that the indicator bit predicts an EarlyAccess policy so then in block <b>46</b>, a cache controller initiates accessing physical memory and cache snooping in parallel. Then, in block <b>52</b>, the cache controller increments or decrements according to whether the data item was found in another cache in the cluster or in memory. That is, in one embodiment of the present invention, the saturation counter decrements for data items fetched from another cache in the cluster and increments for data items fetched from memory. In another embodiment of the present invention, the saturation counter increments for data items fetched from another cache in the cluster and decrements for data items fetched from memory. The important point is that the saturation counter keeps track of where previous data items have been fetched. <figref idref="DRAWINGS">FIG. 4</figref> illustrates one embodiment of the present invention wherein the cache controller decrements the saturation counter for data items fetched from another cache in the cluster and increments the saturation counter for data items fetched from memory.</p>
<p id="p-0027" num="0026">Returning to block <b>44</b>, a cache controller may determine that the indicator bit predicts that the data item may be fetched by performing a cache snoop (LateAccess policy) so then in block <b>48</b>, a cache controller initiates a cache snoop to fetch the data item from a cache of another processor in the cluster. It may happen that the data item is not actually in another cache in the cluster so in that case, in block <b>50</b>, the data item is fetched from physical memory by the cache controller. Thereafter, in block <b>52</b>, the cache controller decrements or increments according to whether the data item is found in another cache in the cluster or in memory as discussed above. Again, <figref idref="DRAWINGS">FIG. 4</figref> illustrates one embodiment of the present invention wherein the cache controller decrements the saturation counter for data items fetched from another cache in the cluster and increments the saturation counter for data items fetched from memory.</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 5</figref> is a block diagram that illustrates an exemplary hardware environment of the present invention. The present invention is typically implemented using a computer <b>60</b> comprised of microprocessor means, random access memory (RAM), read-only memory (ROM) and other components. The computer may be a personal computer, mainframe computer or other computing device. Resident in the computer <b>60</b>, or peripheral to it, will be a storage device <b>64</b> of some type such as a hard disk drive, floppy disk drive, CD-ROM drive, tape drive or other storage device.</p>
<p id="p-0029" num="0028">Generally speaking, the software implementation of the present invention, program <b>62</b> in <figref idref="DRAWINGS">FIG. 5</figref>, is tangibly embodied in a computer-readable medium such as one of the storage devices <b>64</b> mentioned above. The program <b>62</b> comprises instructions which, when read and executed by the microprocessor of the computer <b>60</b> causes the computer <b>60</b> to perform the steps necessary to execute the steps or elements of the present invention.</p>
<p id="p-0030" num="0029">As will be appreciated by one skilled in the art, aspects of the present invention may be embodied as a system, method or computer program product. Accordingly, aspects of the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a &#x201c;circuit,&#x201d; &#x201c;module&#x201d; or &#x201c;system.&#x201d; Furthermore, aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium(s) having computer readable program code embodied thereon.</p>
<p id="p-0031" num="0030">Any combination of one or more computer readable medium(s) may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be, for example, but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, or device, or any suitable combination of the foregoing. More specific examples (a non-exhaustive list) of the computer readable storage medium would include the following: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), an optical fiber, a portable compact disc read-only memory (CD-ROM), an optical storage device, a magnetic storage device, or any suitable combination of the foregoing. In the context of this document, a computer readable storage medium may be any tangible medium that can contain, or store a program for use by or in connection with an instruction execution system, apparatus, or device.</p>
<p id="p-0032" num="0031">A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein, for example, in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms, including, but not limited to, electro-magnetic, optical, or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate, propagate, or transport a program for use by or in connection with an instruction execution system, apparatus, or device.</p>
<p id="p-0033" num="0032">Program code embodied on a computer readable medium may be transmitted using any appropriate medium, including but not limited to wireless, wireline, optical fiber cable, RF, etc., or any suitable combination of the foregoing.</p>
<p id="p-0034" num="0033">Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages, including an object oriented programming language such as Java, Smalltalk, C++ or the like and conventional procedural programming languages, such as the &#x201c;C&#x201d; programming language or similar programming languages. The program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).</p>
<p id="p-0035" num="0034">Aspects of the present invention are described above in with reference to flowchart illustrations and/or block diagrams of methods, apparatus (systems) and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and/or block diagrams, and combinations of blocks in the flowchart illustrations and/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions/acts specified in the flowchart and/or block diagram block or blocks.</p>
<p id="p-0036" num="0035">These computer program instructions may also be stored in a computer readable medium that can direct a computer, other programmable data processing apparatus, or other devices to function in a particular manner, such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function/act specified in the flowchart and/or block diagram block or blocks.</p>
<p id="p-0037" num="0036">The computer program instructions may also be loaded onto a computer, other programmable data processing apparatus, or other devices to cause a series of operational steps to be performed on the computer, other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions/acts specified in the flowchart and/or block diagram block or blocks.</p>
<p id="p-0038" num="0037">The flowchart and block diagrams in the Figures illustrate the architecture, functionality, and operation of possible implementations of systems, methods and computer program products according to various embodiments of the present invention. In this regard, each block in the flowchart or block diagrams may represent a module, segment, or portion of code, which comprises one or more executable instructions for implementing the specified logical function(s). It should also be noted that, in some alternative implementations, the functions noted in the block may occur out of the order noted in the Figures. For example, two blocks shown in succession may, in fact, be executed substantially concurrently, or the blocks may sometimes be executed in the reverse order, depending upon the functionality involved. It will also be noted that each block of the block diagrams and/or flowchart illustration, and combinations of blocks in the block diagrams and/or flowchart illustration, can be implemented by special purpose hardware-based systems that perform the specified functions or acts, or combinations of special purpose hardware and computer instructions.</p>
<p id="p-0039" num="0038">It will be apparent to those skilled in the art having regard to this disclosure that other modifications of this invention beyond those embodiments specifically described here may be made without departing from the spirit of the invention. Accordingly, such modifications are considered within the scope of the invention as limited solely by the appended claims.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>I claim:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. An apparatus for memory access prediction comprising:
<claim-text>a plurality of processors;</claim-text>
<claim-text>a plurality of private memory caches associated with the processors such that there is at least one private memory cache associated with each processor;</claim-text>
<claim-text>a physical memory; and</claim-text>
<claim-text>a plurality of saturation counters associated with the processors such that there is at least one saturation counter associated with each processor, each of the saturation counters having an indicator bit for predicting whether a data item may be found by just a cache snoop or by accessing the physical memory in parallel with the cache snoop;</claim-text>
<claim-text>wherein responsive to a cache miss in one of the private memory caches associated with one of the processors for a data item, the cache snoop and access to the physical memory are initiated in parallel for the data item if the indicator bit is a first predetermined value (one (1) or zero (0)) whereas just the cache snoop is initiated if the indicator bit is a second predetermined value (zero (0) or one (1)) wherein the cache snoop is to each of the plurality of private memory caches other than the one of the private memory caches.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the saturation counters keep track of data items actually obtained from the cache snoop or from the physical memory and wherein the data items actually obtained from the cache snoop cause the saturation counter for the one of the private memory caches in which there is the cache miss to be one of decremented or incremented and the data items actually obtained from the physical memory cause the saturation counter to be an other one of decremented or incremented.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein each of the saturation counters is a counter that has a maximum value and a minimum value and wherein when the saturation counter reaches the maximum value, incrementing the saturation counter will not change the maximum value and when the saturation counter reaches the minimum value, decrementing the saturation counter will not change the minimum value.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the indicator bit is a most significant bit.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref> where there is a plurality of saturation counters physically associated with each processor.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising a plurality of cache controllers associated with the processors such that there is one cache controller associated with each processor and each of the plurality of cache controllers having a saturation counter located within the cache controller.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. An apparatus for memory access prediction comprising:
<claim-text>a cluster comprising:</claim-text>
<claim-text>a plurality of processors;</claim-text>
<claim-text>a plurality of private memory caches and cache controllers associated with the processors such that there is one cache controller associated with each processor and at least one private memory cache associated with each processor;</claim-text>
<claim-text>a physical memory; and</claim-text>
<claim-text>a plurality of saturation counters associated with the cache controllers such that there is at least one saturation counter located within each cache controller, each of the saturation counters having an indicator bit for predicting whether a data item may be found by just a cache snoop or by accessing physical memory in parallel with the cache snoop;</claim-text>
<claim-text>wherein responsive to a cache miss in one of the private memory caches associated with one of the processors for a data item, the cache snoop and access to the physical memory are initiated in parallel for the data item if the indicator bit is a first predetermined value (one (1) or zero (0)) whereas just the cache snoop is initiated if the indicator bit is a second predetermined value (zero (0) or one (1)) wherein the cache snoop is to each of the plurality of private memory caches other than the one of the private memory caches.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The apparatus of <claim-ref idref="CLM-00007">claim 7</claim-ref> comprising a plurality of clusters connected by a bus.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. A method for memory access prediction in multiprocessors comprising a plurality of processors, a plurality of private memory caches associated with the processors such that there is at least one private memory cache associated with each processor, a plurality of saturation counters associated with the processors such that there is at least one saturation counter associated with each processor, and a physical memory shared with the processors, the saturation counters and the private memory caches, the method comprising the steps of:
<claim-text>responsive to a cache miss in one of the private memory caches associated with one of the processors for a data item, consulting by a computer processor a saturation counter for the one of the private memory caches to predict whether the data item may be fetched from a cache snoop to each of the plurality of private memory caches other than the one of the private memory caches or the physical memory wherein the saturation counter keeps track of data items actually obtained in a previous cache miss from the one of the private memory caches by the cache snoop or from the physical memory and the saturation counter has an indicator bit such that when the indicator bit in the saturation counter is a first predetermined value (one (1) or zero (0)), the cache snoop and access to the physical memory in parallel is predicted for the data item and when the indicator bit is a second predetermined value (zero (0) or one (1)), just the cache snoop is predicted for the data item; and</claim-text>
<claim-text>initiating by the computer processor the cache snoop and access to the physical memory in parallel for the data item if the indicator bit is the first predetermined value or initiating by the computer processor just the cache snoop if the indicator bit is the second predetermined value.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref> wherein if the indicator bit is the second predetermined value, further comprising initiating by the computer processor access to the physical memory when the data item is not in the private memory caches.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref> further comprising the step of:
<claim-text>decrementing by the computer processor the saturation counter for the one of the private memory caches when the data item is actually obtained from the cache snoop or incrementing by the computer processor the saturation counter for the one of the private memory caches when the data item is actually obtained from the physical memory.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref> further comprising the step of:
<claim-text>incrementing by the computer processor the saturation counter for the one of the private memory caches when the data item is actually obtained from the cache snoop or decrementing by the computer processor the saturation counter for the one of the private memory caches when the data item is actually obtained from the physical memory.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref> wherein the indicator bit is a most significant bit.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref> wherein each of the saturation counters is a counter that has a maximum value and a minimum value and wherein when the saturation counter reaches the maximum value, incrementing the saturation counter will not change the maximum value and when the saturation counter reaches the minimum value, decrementing the saturation counter will not change the minimum value.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. A computer program product for memory access prediction in multiprocessors comprising a plurality of processors, a plurality of private memory caches associated with the processors such that there is at least one private memory cache associated with each processor, a plurality of saturation counters associated with the processors such that there is at least one saturation counter associated with each processor, and a physical memory shared with the processors, the saturation counters and the private memory caches, and comprising:
<claim-text>a non-transitory computer readable storage medium having computer readable program code embodied therewith, the computer readable program code comprising:</claim-text>
<claim-text>responsive to a cache miss in one of the private memory caches associated with one of the processors for a data item, the computer readable program code configured to consult a saturation counter for the one of the private memory caches to predict whether the data item may be fetched only from a cache snoop to each of the plurality of private memory caches other than the one of the private memory caches or the physical memory wherein the saturation counter keeps track of data items actually obtained in a previous cache miss from the one of the private memory caches by the cache snoop or from the physical memory and the saturation counter has an indicator bit such that when the indicator bit in the saturation counter is a first predetermined value, the cache snoop and access to the physical memory in parallel is predicted for the data item and when the indicator bit is a second predetermined value, just the cache snoop is predicted for the data item; and</claim-text>
<claim-text>the computer readable program code configured to initiate the cache snoop and access to the physical memory in parallel for the data item when the indicator bit is the first predetermined value or to initiate just the cache snoop when the indicator bit is the second predetermined value.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The computer program product of <claim-ref idref="CLM-00015">claim 15</claim-ref> wherein when the indicator bit is the second predetermined value, further comprising the computer readable program code configured to initiate access to the physical memory when the data item is not in the private memory caches.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The computer program product of <claim-ref idref="CLM-00016">claim 16</claim-ref> further comprising:
<claim-text>the computer readable program code configured to decrement the saturation counter for the one of the private memory caches when the data item is actually obtained from the cache snoop or increment the saturation counter for the one of the private memory caches when the data item is actually obtained from the physical memory.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The computer program product of <claim-ref idref="CLM-00016">claim 16</claim-ref> further comprising:
<claim-text>the computer readable program code configured to increment the saturation counter for the one of the private memory caches when the data item is actually obtained from the cache snoop private memory caches of the plurality of processors or decrement the saturation counter for the one of the private memory caches when the data item is actually obtained from the physical memory.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The computer program product of <claim-ref idref="CLM-00015">claim 15</claim-ref> wherein the indicator bit is a most significant bit.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The computer program product of <claim-ref idref="CLM-00015">claim 15</claim-ref> wherein each of the saturation counters is a counter that has a maximum value and a minimum value and wherein when the saturation counter reaches the maximum value, incrementing the saturation counter will not change the maximum value and when the saturation counter reaches the minimum value, decrementing the saturation counter will not change the minimum value. </claim-text>
</claim>
</claims>
</us-patent-grant>
