<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08625794-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08625794</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13378891</doc-number>
<date>20100617</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<priority-claims>
<priority-claim sequence="01" kind="regional">
<country>EP</country>
<doc-number>09163250</doc-number>
<date>20090619</date>
</priority-claim>
</priority-claims>
<us-term-of-grant>
<us-term-extension>16</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>H</section>
<class>04</class>
<subclass>K</subclass>
<main-group>1</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>380255</main-classification>
</classification-national>
<invention-title id="d2e71">White-box cryptographic system with configurable key using intermediate data modification</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>2004/0071291</doc-number>
<kind>A1</kind>
<name>Romain et al.</name>
<date>20040400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>380 43</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>2006/0140401</doc-number>
<kind>A1</kind>
<name>Johnson</name>
<date>20060600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>2010/0303231</doc-number>
<kind>A1</kind>
<name>Gorissen et al.</name>
<date>20101200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>380210</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>FR</country>
<doc-number>2820577</doc-number>
<kind>A1</kind>
<date>20020800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>WO</country>
<doc-number>20080142612</doc-number>
<kind>A2</kind>
<date>20081100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00006">
<othercit>Chow et al: &#x201c;White-Box Cryptography and an AES Implementation&#x201d; Selected Areas in Cryptograpy: 9th Annual International Workshop; Revised Papers/SAC 2002, St John's, Newfoundland, Canada, Aug. 15, 2002; Aug. 15-16, 2002 Springer Verlag, Berlin (DE), vol. 2595, pp. 25-270, XP002521155 ISBN: 978-3-540-00622-0.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00007">
<othercit>Chow et al: &#x201c;A White-Box Des Implementation for DRM Applications&#x201d;, Pre-proceedings for CM DRM-2002 workshop, Version: Oct. 15, 2002, 16 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>20</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>380255</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>12</number-of-drawing-sheets>
<number-of-figures>14</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20120093313</doc-number>
<kind>A1</kind>
<date>20120419</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Michiels</last-name>
<first-name>Wilhelmus Petrus Adrianus Johannus</first-name>
<address>
<city>Hoofddorp</city>
<country>NL</country>
</address>
</addressbook>
<residence>
<country>NL</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Michiels</last-name>
<first-name>Wilhelmus Petrus Adrianus Johannus</first-name>
<address>
<city>Hoofddorp</city>
<country>NL</country>
</address>
</addressbook>
</inventor>
</inventors>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Irdeto Corporate B.V.</orgname>
<role>03</role>
<address>
<city>Hoofddorp</city>
<country>NL</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Zand</last-name>
<first-name>Kambiz</first-name>
<department>2434</department>
</primary-examiner>
<assistant-examiner>
<last-name>Getachew</last-name>
<first-name>Abiy</first-name>
</assistant-examiner>
</examiners>
<pct-or-regional-filing-data>
<document-id>
<country>WO</country>
<doc-number>PCT/EP2010/058590</doc-number>
<kind>00</kind>
<date>20100617</date>
</document-id>
<us-371c124-date>
<date>20111216</date>
</us-371c124-date>
</pct-or-regional-filing-data>
<pct-or-regional-publishing-data>
<document-id>
<country>WO</country>
<doc-number>WO2010/146139</doc-number>
<kind>A </kind>
<date>20101223</date>
</document-id>
</pct-or-regional-publishing-data>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A white-box cryptographic system (<b>600</b>) is presented for performing a key-dependent cryptographic operation, such as AES. The system comprises a network of a plurality of look-up tables (<b>640</b>) arranged for collectively performing the cryptographic operation, the network being adapted for a particular cryptographic key. By sending a key substitute (<b>664</b>) which represents to the network a further cryptographic key a key translation unit can arrange the effect of the network on the cryptographic operation such that is adapted for a further cryptographic key. In this way the system can be updated to use the further key instead of the particular key.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="115.74mm" wi="144.70mm" file="US08625794-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="140.97mm" wi="102.11mm" file="US08625794-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="169.50mm" wi="162.05mm" file="US08625794-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="125.31mm" wi="170.18mm" file="US08625794-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="118.45mm" wi="147.74mm" file="US08625794-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="157.99mm" wi="150.45mm" file="US08625794-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="240.28mm" wi="157.23mm" file="US08625794-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="127.34mm" wi="152.48mm" file="US08625794-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="224.71mm" wi="174.33mm" file="US08625794-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="238.93mm" wi="138.85mm" file="US08625794-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="153.84mm" wi="138.18mm" file="US08625794-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="224.71mm" wi="164.76mm" file="US08625794-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="108.97mm" wi="152.48mm" file="US08625794-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">FIELD OF THE INVENTION</heading>
<p id="p-0002" num="0001">The invention relates to a white-box cryptographic system for performing a keyed cryptographic operation mapping an input-message to an output-message, the system comprising a network of a plurality of look-up tables arranged for collectively performing the cryptographic operation, the network being adapted for a particular cryptographic key.</p>
<p id="p-0003" num="0002">The invention further relates to a cryptographic method for performing a keyed cryptographic operation and corresponding computer program.</p>
<heading id="h-0002" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0004" num="0003">The Internet provides users with convenient and ubiquitous access to digital content. Because of the potential of the Internet as a powerful distribution channel, many consumer electronics (CE) products strive to directly access the Internet or to interoperate with the PC platform, the predominant portal to the Internet. The CE products include, but are not limited to, digital set top boxes, digital TVs, game consoles, PCs and, increasingly, hand-held devices such as PDAs, mobile phones, and mobile storage and rendering devices, such as Apple's iPod. The use of the Internet as a distribution medium for copyrighted content creates the compelling challenge to secure the interests of the content provider. In particular it is required to warrant the copyrights and business models of the content providers. Increasingly, CE platforms are operated using a processor loaded with suitable software. Such software may include the main part of functionality for rendering (playback) of digital content, such as audio and/or video. Control of the playback software is one way to enforce the interests of the content owner including the terms and conditions under which the content may be used. Where traditionally many CE platforms (with the exception of a PC and PDA) used to be closed, nowadays more and more platforms at least partially are open. In particular for the PC platform, some users may be assumed to have complete control over the hardware and software that provides access to the content and a large amount of time and resources to attack and bypass any content protection mechanisms. As a consequence, content providers must deliver content to legitimate users across a hostile network to a community where not all users or devices can be trusted.</p>
<p id="p-0005" num="0004">Typically, digital rights management systems use an encryption technique based on block ciphers that process the data stream in blocks using a sequence of encryption/decryption steps, referred to as rounds. During each round, a round-specific function is performed. The round-specific function may be based on a same round function that is executed under control of a round-specific sub-key.</p>
<p id="p-0006" num="0005">Content providers must deliver content to legitimate users across a hostile network to a community where not all users or devices can be trusted. In particular for the PC platform, the user must be assumed to have complete control of the hardware and software that provides access to the content, and an unlimited amount of time and resources to attack and bypass any content protection mechanisms. The software code that enforces the terms and conditions under which the content may be used must not be tampered with. The general approach in digital rights management for protected content distributed to PCs is to encrypt the digital content, for instance DES (Data Encryption Standard), AES (Advanced Encryption Standard), or using the method disclosed in WO9967918, and to use decryption keys.</p>
<p id="p-0007" num="0006">The two main areas of vulnerability of digital rights management relying on encryption are the software plug-ins which enforce the terms and conditions under which the content may be used, and the key distribution and handling.</p>
<p id="p-0008" num="0007">After the key used to encrypt content is comprised, it can be distributed over the Internet with comparative ease. One way to avoid this is to use white-box cryptography, wherein a key dependent cryptographic operation is performed in such a way that the key cannot be recovered, not even by attacker having full access to the implementation. In white-box cryptography it is assumed that an attacker has full access to the implementation. Apart from analyzing the input and output behavior of a system, in the white box context an attacker may also analyze the internal behavior of a system. Usually it is the goal of a white box attack to recover in a useable form the key that corresponds to particular encryption or decryption operation.</p>
<p id="p-0009" num="0008">Most white-box implementations use techniques based on hiding the cryptographic key by adding a veil of randomness, such as random encodings, and complexity in both the control and the data path of the software application. The idea behind this is that it becomes more difficult to extract information merely by code inspection.</p>
<p id="p-0010" num="0009">&#x201c;White-Box Cryptography and an AES Implementation&#x201d;, by Stanley Chow, Philip Eisen, Harold Johnson, and Paul C. Van Oorschot, in Selected Areas in Cryptography: 9th Annual International Workshop, SAC 2002, St. John's, Newfoundland, Canada, Aug. 15-16, 2002, referred to hereinafter as &#x201c;Chow 1&#x201d;, and &#x201c;A White-Box DES Implementation for DRM Applications&#x201d;, by Stanley Chow, Phil Eisen, Harold Johnson, and Paul C. van Oorschot, in Digital Rights Management: ACM CCS-9 Workshop, DRM 2002, Washington, D.C., USA, Nov. 18, 2002, referred to hereinafter as &#x201c;Chow 2&#x201d;, disclose methods with the intend to hide the key by a combination of encoding its tables with random bijections, and extending the cryptographic boundary by pushing it out further into the containing application.</p>
<p id="p-0011" num="0010">In Chow's white-box implementations, the key is not explicitly present in the implementation. This reduces the risk of the key being found by inspection of the implementation. Instead, the key is only present implicitly. Chow uses the method of partial evaluation to hide a key in a cryptographic system, therein a look-up table which needs key input is evaluated in-so-far it depends on the key and does not depend on the input-message. For example, a basic operation wherein an input-value, a key-value, and a masking value which does not depend on the input-message, e.g. a value from an s-box needs to be xor-ed can be partially evaluated by xor-ing the key value and the masking value together beforehand. In this way the operation still depends on the key-value although the key-value is not explicitly present in the implementation. Instead, only the xor between the key-value and masking-value is present in the implementation.</p>
<heading id="h-0003" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0012" num="0011">A problem with the approach taken in Chow 1 and Chow 2 is that the key is embedded in the white-box implementation. All operations that depend on the key are simplified to depend on one particular key. In this way that particular key is spread throughout the implementation making hiding through obfuscation of the key easier. Instead of having a key schedule in the implementation, the approach taken in Chow 1 and 2 pre-calculates all round keys. There is therefore no need for a separate key schedule, which is therefore also dispensed with.</p>
<p id="p-0013" num="0012">A disadvantage of this approach is that the white-box implementation can only be used for one cryptographic key. This is considered a disadvantage for some applications. For example, for security reasons one may want to frequently update the key used. If at some point, for whatever reason the particular key is leaked, then it is only of use to an attacker for a limited amount of time, until the next key-update. Moreover, having the possibility of using multiple keys makes it easier to do key management. For example: First content intended for a first group of people can be encrypted with a first key, and second content intended for a second group of people can be encrypted with a second key. A user who is in the intersection of the first group and the second group may access both the first and the second content using a single white-box system whose key can be reconfigured for both the first key and the second key. Moreover, there exist a number of protocols and cryptographic standards which make it impossible or impractical to fix the used key beforehand. For example, key negotiation protocols cannot be used with cryptographic operations using a fixed key. Also DRM standards, such as OMA DRM, assume that different keys are used for content keys, right keys etc.</p>
<p id="p-0014" num="0013">One solution to update the key used in white box implementation is to update the entire white box implementation, or at least all of its tables, this may however be impractical as the size of white box implementations is often rather large, especially when compared with the size of a typical key. For example, a white-box implementation may be tens or even hundreds of kilobytes, whereas a single AES key is only 16 bytes. Even an AES key which is expanded into its corresponding round keys is only 160 bytes.</p>
<p id="p-0015" num="0014">It would be advantageous to have an improved white-box cryptographic system for performing a keyed cryptographic operation mapping an input-message to an output-message. The system comprises a network of a plurality of look-up tables arranged for collectively performing the cryptographic operation, the network being adapted for a particular cryptographic key. Note that the network may also be used with independent round keys, which are not obtained through a key schedule from a single AES key. In this way, the amount of key material on which the operation depends can be greatly increased. For the case of AES, for example, one may have 10 time 128 bit of independent key material instead of 128 bit. The system is configured to receive a key substitute which represents to the network a further cryptographic key. The system comprises at least one key translation unit configured for receiving a first input depending on an intermediate cryptographic result in the network and a second input depending on the key substitute. The system is arranged for mapping the input-message to the output-message via the network and the key translation unit to arrange the effect of the network on the cryptographic operation to being adapted for the further cryptographic key.</p>
<p id="p-0016" num="0015">The cryptographic system performs the key-dependent cryptographic operation by using look-up tables to map the input message to intermediate processing data and eventually to the output-message. The look-up tables that are used to do the mapping represent the key on which the cryptographic operation depends. The system maps input messages to output messages via the key translation unit. One of the inputs of the key translation unit is an intermediate cryptographic result in the network which is arranged for collectively performing the cryptographic operation. As the mapping is performed via the key translation unit, it has the opportunity to influence the way in which the cryptographic operation is performed. Although the look-up tables in the network need not be changed, the effect that they have on the cryptographic operation can be changed by the key translation unit, by affecting intermediate results in the network. The effect of the network on the cryptographic operation may be arranged such that it is adapted to a further cryptographic key.</p>
<p id="p-0017" num="0016">A second input of the key translation unit is a key substitute. Since the key substitute represents to the system the further cryptographic key the system can adapt the effect of the network of look-up tables on the cryptographic operation such that it is adapted for the further cryptographic key.</p>
<p id="p-0018" num="0017">There may be multiple look-up tables that are adapted to a particular key, whose behavior may be changed by one or more key translation units. For example, there may be key translation unit for each look-up table that is specific for a particular key.</p>
<p id="p-0019" num="0018">As the system can receive a key substitute, the key can be updated from outside the system, and in particular, even after the cryptographic operation has been implemented as a white-box.</p>
<p id="p-0020" num="0019">As noted, for many cryptographic operations it is desired to have a white-box implementation. The invention may be applied, for example, to symmetric and asymmetric cryptographic operations. Also, the invention may be applied to table ciphers, stream ciphers, message authentication schemes, signature schemes, etc. Note that the invention may also be applied to hash functions. The latter is especially useful if the hash function is used as a building table which processes secret information, e.g., a secret key, secret data, etc. For example, the invention may be applied to a hash function used in a keyed-Hash Message Authentication Code (HMAC or KHMAC). Well known table ciphers include Advanced Encryption Standard (AES), Secure And Fast Encryption Routine, (SAFER, and variants SAFER+ and SAFER++), Blowfish, Data Encryption Standard (DES), etc. A well known stream cipher is RC4. Moreover any table cipher can be used as stream cipher using an appropriate mode of operation, e.g., Cipher feedback (CFB), Counter mode (CTR), etc.</p>
<p id="p-0021" num="0020">The input message can represent, e.g., encrypted content data, such as multi-media data, including audio and/or video data. The encrypted content data may also comprise encrypted software, e.g., encrypted computer code representing some computer application, e.g., a computer game, or an office application. The input message may also represent a key for use in a further cryptographic operation. The latter may be used, for example, in a key exchange protocol, wherein a white-box implementation according to the invention encrypts and/or decrypts data representing a new key. The input data may also be plain data, for example, plain user data. The latter is especially advantageous in message authentication schemes. A white-box implementation according to the invention may have the property that the implementation may only be used for encryption, only be used for decryption, but not for both. For example, this property can be achieved if the implementation uses look-up tables which are not bijective, for example, a look-up table having more input bits than output bits. Accordingly, if a user only has a white-box decryptor, he may verify a MAC code but not create new MACs. This strengthens the non-repudiation properties of such a message authentication scheme.</p>
<p id="p-0022" num="0021">The plurality of look-up tables are interconnected, in the sense that some of the outputs obtained from some look-up tables are used as inputs, or as part of inputs, for other look-up tables. A look-up table manager may be used to manage the receiving and forwarding of intermediate result from and to the look-up tables. The look-up tables therefore build on the results of one or more of the previous tables. In this way the look-up tables can be said to form a network of look-up tables that together represent the cryptographic operation. A look up table is a type of basic block which can be used to compute a part of the cryptographic operation, e.g., to produce an intermediate result. The system may comprise further basic computing blocks, e.g., formula's implemented in computer software, which may also be used, together with the network. The network of look-up tables may depend on each other directly, e.g., some look-up table may receive directly as input an output of another look-up table. The dependency may also be indirectly, e.g., via some type of basic block which is arranged in-between two look-up tables. For example, the white-box cryptographic system may comprise a number of, possibly parallel, table lookups, followed by an XOR operation which is not implemented as a table look-up, followed by further table lookups, etc.</p>
<p id="p-0023" num="0022">A look-up table may be implemented in hardware, for example, as a computer chip. A look-up table may use a switch board, a state machine or any other suitable construction for implementing functions in computer hardware. A look-up table may also be implemented in software running on a general purpose computer chip, e.g. a microprocessor. For example, a look-up table may use a plurality of computer instructions, including arithmetical instructions, which together implement the functionality of the look-up table. A preferred implementation for the key translation unit, which may be used both in software and hardware, is a look-up table. A look-up table implementation comprises a list which lists for possible input values, an output value. The input value may be explicit in the lookup table. In that situation the look-up table implementation could map a particular input to a particular output by searching in the list of input values for the particular input. When the particular input is found the particular output is then also found. For example, the particular output may be stored alongside the particular input. Preferably, the input values are not stored explicitly, but only implicitly. For example, if the possible inputs are a consecutive range, e.g. of numbers or bit-strings, the look-up table may be restricted to storing a list of the output values. A particular input number may, e.g., be mapped to the particular output which is stored at a location indicated by the number. Note that a loop-up table may also be implemented in hardware gates by converting the look-up table to a Boolean function. Several techniques to do this are known, e.g., using Karnaugh maps.</p>
<p id="p-0024" num="0023">Using look-up tables has the advantage that they can be obfuscated relatively straightforwardly. For example, the output values of a table may be encoded in some manner, by replacing the un-encoded values with the encoded values.</p>
<p id="p-0025" num="0024">A look-up table for a function may, for example, be created by computing the output value of the function for its possible inputs and storing the outputs in a list. If the function depends on multiple inputs the outputs may be computed and stored for all possible combinations of the multiple inputs. Look-up tables are especially suited to implement non-linear functions, which map inputs to output in irregular ways. A white-box implementation can be further obfuscated, as is explained below, by applying to one or more of its look-up tables a fixed obfuscating input encoding and a fixed output encodings. The results of applying a fixed obfuscating input encoding and output encodings is then fully pre-evaluated. Using this technique, a look-up table would be replaced by an obfuscated look-up table which may have the same dimensions and may take the same number of input bits to produce the same number of output bits. The input encoding and output encoding used in such obfuscation are not explicit in the final white-box implementation.</p>
<p id="p-0026" num="0025">The network of look-up tables are arranged to compute an output message when they are presented with an input message. Typically, the input message is operated upon by a number of basic input tables. A number of further look-up tables may take input from one or more of the basic input tables and/or from the input message. Yet further look-up tables can take input in any combination of the input message, the output of basic input tables and the output of the further look-up tables. Finally some set of basic exit tables, i.e., at least one, produce as output all or part of the output-message. In this manner a network of look-up tables emerges which collectively computes the mapping from the input message to the output message.</p>
<p id="p-0027" num="0026">The key used is preferably a cryptographic key, and preferably contains sufficient entropy to withstand an anticipated brute force attack. The key may be taken to be a collection of round keys.</p>
<p id="p-0028" num="0027">One or more of the intermediate results used during the computation of the cryptographic results, for example, intermediate results in the network, are encoded using one or more internal encodings. Encoding of intermediate results contributes to the strength of the white-box implementation. That is, internal encodings, especially if these encodings are chosen randomly and/or specifically for a particular white-box implementation, make it harder to recover the particular key and/or further key for which the system is configured.</p>
<p id="p-0029" num="0028">In an embodiment, at least one specific look-up table of the plurality of look-up tables is adapted for the particular cryptographic key. The system is arranged for mapping the input-message to the output-message via at least the specific look-up table to arrange the effect of the specific look-up table on the cryptographic operation to being adapted for the further cryptographic key.</p>
<p id="p-0030" num="0029">The content of some of the look-up tables depends on the particular key. For example, during the construction of the white box implementation they are specifically adapted for the particular key. For example, they may contain a key addition, possibly, along with other operations with which the key addition is combined. This gives the possibility of adapting a specific key translation table specifically for the specific look-up table. This decreases its complexity.</p>
<p id="p-0031" num="0030">A specific look-up table depending on the key, has the advantage that the number of key bits, i.e., the amount key-data, on which the specific look-up table depends may be smaller than the total number of key bits. For example, the block cipher DES needs 768 key bits (16 rounds with a round key of 48 bit). However, one key addition may be as small as 6 bit. A key translation table adapted for such a small key addition is of less complexity than a key addition for a larger (sub) keys. It is observed that many block ciphers, including DES and AES, can be specified with a key schedule which computes round keys from one smaller key. For example, the 768 bit of rounds keys for DES can be computed from a single 56 bit key. However, the representation in round keys may be more convenient for white-box cryptography, as it avoids the problem of obfuscating the key schedule. Moreover, a key schedule represents additional logic which might provide an attacker with a new attack vector. However, it is noted that this is not necessarily the case, and the white-box system could employ an obfuscated key schedule to further reduce key length.</p>
<p id="p-0032" num="0031">In an embodiment, the specific lookup table has the property that a specific lookup table adapted for the further key can be obtained by adding a, possibly encoded, offset to the input and/or by adding a, possibly encoded, offset to its output. That is by adding a fixed number to all inputs of the specific lookup table, before the input is processed using the specific lookup table, and/or adding a further fixed number to all the outputs of the specific lookup table, after the specific look-up table has processed its input, the same effect is achieved as would be achieved if the specific lookup table were replaced with a different look-up table adapted for the further cryptographic key.</p>
<p id="p-0033" num="0032">The key translation unit can be embodied in a variety of ways. For example, the key translation unit may comprise one or more look-up tables. For example, the key translation table may comprise an XOR table, e.g. a type IV table. To XOR larger keys, the key translation unit may also be two or more of these tables. Furthermore, the key translation unit may be implemented in software. To express more complicated relationships between intermediate data adapted for the particular key or for the further key, this type of key translation table is well suited. The key translation unit may also be expressed in one or more formulas. For example, the key translation unit may be addition which is not expressed as look-up table but which is done using, e.g., hardware gates or commands for a microprocessor.</p>
<p id="p-0034" num="0033">In an embodiment, the first input of the key translation unit depends on the input message by means of one or more of the plurality of look-up tables and wherein the system is arranged for the specific look-up table to receive an input depending on an output of the key translation unit. For example, the input of the specific look-up table may comprise the output of the key translation unit.</p>
<p id="p-0035" num="0034">By making the input of the specific look-up table dependent on the output of the key translation unit the effect is achieved that inputs to the specific table are directly influenced. In this way the inputs intended for the specific look-up table can be pre-transformed so that the total effect of the key translation unit and the specific look-up table is as if the specific look-up table has been adapted for the further key.</p>
<p id="p-0036" num="0035">For example, suppose a first input value is mapped by the specific look-up table to a first output value, which is consistent with the mapping that corresponds to the particular key. Also suppose that according to the mapping corresponding to the further key, the first input value should be mapped to a second output value. The key translation unit maps may then map the first input value to a second input value, which is chosen such that the specific look-up table maps the second input value to the second output value according to the mapping corresponding to the particular key. The effect which is achieved when the key translation unit and the specific look-up table are combined is that the effect of the specific look-up table on the cryptographic operation is adapted for the further cryptographic key, at least in so far as the first input value is concerned. To recapitulate, the first input value is mapped to the second input value, by the key translation unit, which is mapped to the second output value, by the specific look-up table. Together this mapping amounts to mapping the first input value to the second output value. This mapping may also be done for the other input values of the specific table, that is, translating input values meant for the further cryptographic key to input values for the particular cryptographic key. In other words, even though the specific table itself is adapted to the particular key, to the network, and to the system, it seems as if the specific table is adapted for the further key.</p>
<p id="p-0037" num="0036">The key substitute does not need to have a direct relation with the further cryptographic key. Rather the key substitute instructs the system how to reconfigure the system to re-use operations adapted to the particular key as operations adapted for the further key. Hence the value to an attacker of the key substitute is limited. Moreover, the key translation unit may be configured to receive the second input, i.e., the key substitute, encoded according to a key substitute encoding. As the key substitute encoding can be chosen in any way, e.g., linear and/or non-linear, e.g. as a random encoding, this further obfuscates the relation between the key substitute and the further cryptographic key.</p>
<p id="p-0038" num="0037">In a preferred embodiment, the key translation look-up table is configured with an output-encoding, and wherein the specific look-up table is configured with an input encoding corresponding to the output encoding.</p>
<p id="p-0039" num="0038">If the input of the specific look-up table were not encoded, than an attacker could theoretically compare the processing of the cryptographic system with and without a key update. He could then observe how the inputs to the specific look-up table change. From this observation he may derive information on the difference between the particular key and the further key. Even though the particular key is secret and should be unknown to an attacker, revealing this information may be an undesirable situation. To avoid this, the interface between the key translation unit and the specific look-up table is further obfuscating using an encoding. Just as the key substitute encoding, this encoding may be chosen in any desired way. It has the effect that an offset which is introduced by the key translation unit is obfuscated through the encoding.</p>
<p id="p-0040" num="0039">In an embodiment, the system is configured for the first input to depend on an output data of the specific look-up table. For example, the first input may comprise output data of the specific look-up table.</p>
<p id="p-0041" num="0040">The output message depends on the key translation unit which processes the output data of the specific look-up table. Hence the way the output message depends on the output of the specific look-up table can be modified via the key translation unit and thus via the key substitute.</p>
<p id="p-0042" num="0041">An example, analogous to the example above can clarify how the key translation unit can change the effect of the specific look up table by processing output data of the specific lookup table. For example, suppose a first input value is mapped by the specific look-up table to a first output value, which is consistent with the mapping that corresponds to the particular key. Also suppose that according to the mapping corresponding to the further key, the first input value should be mapped to a second output value. The key translation unit may then map the first output value to the second output value. The effect which is achieved when the specific look-up table and the key translation unit are combined is that the effect of the specific look-up table on the cryptographic operation is adapted for the further cryptographic key. To recapitulate, the first input value is mapped to the first output value which is mapped to the second output value. Together this mapping amounts to mapping the first input value to the second output value. The key translation unit may perform this translation of outputs of the specific table adapted for the particular key to outputs that correspond to the further key for all output values. In other words, even though the specific table itself is adapted to the particular key, to the network, and to the system, it seems as if the specific table is adapted for the further key.</p>
<p id="p-0043" num="0042">In a preferred embodiment, the specific look-up table is configured with an output-encoding, and the key translation unit is configured with an input encoding corresponding to the output encoding of the specific look-up table.</p>
<p id="p-0044" num="0043">Also the interface between the output of the specific look-up table and the key translation unit may be obfuscated further. This has the advantage that the relation between outputs of the specific look-up tables for different keys, even if it were observed by an attacker does not leak any information, since the output encoding is not known to him.</p>
<p id="p-0045" num="0044">In a preferred embodiment, the key substitute comprises a difference between the further cryptographic key and the particular cryptographic key.</p>
<p id="p-0046" num="0045">The key substitute represents to the network the further cryptographic key. This representation may be unique for the particular implementation of the network. That is, sending the same key substitute to a different network may not have the effect of updating the key of the different network. One way to achieve this is by representing the difference between the particular and the further key in the key substitute. If the specific look-up table of the other network corresponds to a different particular key, than the key substitute will not have the anticipated key-updating effect. Note that the use of a key substitute encoding also achieves this advantage, if the other network is implemented using a different key encoding. Using both measures further strengthens the binding between the key substitute and the particular white-box system for which it is intended.</p>
<p id="p-0047" num="0046">In a preferred embodiment, the key translation look-up table is configured for adding the second input to the first input.</p>
<p id="p-0048" num="0047">It is advantageous if the mapping that the key translation unit performs for input and/or output values of the specific table can be represented in an efficient manner. This reduces the space requirements of the key translation unit and the key substitute considerably, as there may be many possible inputs of the specific table. For example, a particular efficient way of mapping the values is by introducing an offset. Note that the first input may have to be encoded in case the key translation unit expects to receive encoded inputs.</p>
<p id="p-0049" num="0048">Adding, e.g. of inputs, and computing of differences can be done with respect to various types of addition, for example, integer arithmetic, possibly using two's complement representation. Additions and subtractions are preferably performed using the XOR operation. It is noted that the sum and the difference of two bit-strings are computed in the same manner and produce the same result if XOR is used.</p>
<p id="p-0050" num="0049">In a preferred embodiment, the specific look-up table comprises a cryptographic key addition operation of a sub-key depending on the particular key. The specific look-up table may be constructed by composing various operations together. For example, in case of AES, the specific look-up table may be composed of a key-addition and part of a MixColumn operation. Moreover, typically input and output encodings will be used. In case the specific look-up table comprises a key addition the modifications to inputs and/or outputs may be represented by the key substitution as an offset with respect to the key addition. This reduces complexity and size requirements, both for the key substitute and for the key translation unit.</p>
<p id="p-0051" num="0050">In a preferred embodiment, the cryptographic sub-key addition operation and the addition in the key translation look-up table of the second input to the first input are arranged to compose into a cryptographic key addition operation a further sub-key depending on the further cryptographic key.</p>
<p id="p-0052" num="0051">If the operation performed by the key translation unit on its first input, in dependency on its second input, is composed as a function composition with the operation of the specific look-up table, then it is efficient if the two additions, the addition in the key translation unit and the addition in the specific-lookup table combine to produce a key addition of the intended key. The key translation look-up table may be implemented as a single table. However, the key translation unit may also be distributed over multiple look-up tables. For example, the key translation unit may be distributed over a table that affects the inputs of the specific look-up table and over a table that affects the output of the specific look-up table.</p>
<p id="p-0053" num="0052">In an embodiment, the key translation look-up table is arranged to receive the second input encoded with a second input encoding, and wherein the system is configured to receive a key substitute at least part of which is encoded with the second input encoding.</p>
<p id="p-0054" num="0053">As noted above it is preferred if the relation between the key substitute and an unobfuscated key which would produce the same cryptographic operation in a non-white-box implementation is as tenuous as possible. One way to achieve this is by representing not the further cryptographic key itself but a difference, e.g. an offset, between the particular cryptographic key and the further cryptographic key. A further way to achieve this is to encode the key substitute using a secret encoding which is embedded in the key translation unit. One further way to accomplish this aim is to have input encoding and/or output encodings on the specific look-up table which makes it necessary to modify the inputs and/or outputs in an obfuscated manner according to the input encoding of the specific look-up table.</p>
<p id="p-0055" num="0054">A further aspect of the invention is a cryptographic method for performing a keyed cryptographic operation mapping an input-message to an output-message.</p>
<p id="p-0056" num="0055">The method comprises performing the cryptographic operation using a network of a plurality of look-up tables arranged for cryptographic operation, the network being adapted for a particular cryptographic key. The method comprises receiving a key substitute which represents to the network a further cryptographic key, and providing the a key translation unit with a first input depending on an intermediate cryptographic result of the network and a second input depending on the key substitute. Performing the cryptographic operation using the network comprises mapping the input-message to the output-message via the network and the key translation unit to arrange the effect of the network on the cryptographic operation to being adapted for the further cryptographic key.</p>
<p id="p-0057" num="0056">A method according to the invention may be implemented on a computer as a computer implemented method, or in dedicated hardware, or in a combination of both. Executable code for a method according to the invention may be stored on a computer program product. Examples of computer program products include memory devices, optical storage devices, integrated circuits, servers, online software, etc.</p>
<p id="p-0058" num="0057">In a preferred embodiment, the computer program comprises computer program code means adapted to perform all the steps of a method according to the invention when the computer program is run on a computer. Preferably, the computer program is embodied on a computer readable medium.</p>
<p id="p-0059" num="0058">A white-box cryptographic system is presented for performing a key-dependent cryptographic operation, such as AES. The system comprises a network of a plurality of look-up tables arranged for collectively performing the cryptographic operation, the network being adapted for a particular cryptographic key. By sending a key substitute which represents to the network a further cryptographic key a key translation unit can arrange the effect of the network on the cryptographic operation such that is adapted for a further cryptographic key. In this way the system can be updated to use the further key instead of the particular key.</p>
<p id="p-0060" num="0059">Another white-box using an updatable key is given in a patent application of the same applicant and same inventor as the current applicant, with Ser. No. WO2010146140, and title &#x2018;White-box cryptographic system with configurable key using block selection&#x2019; which was first filed on 19 Jun. 2009, incorporated herein by reference.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0061" num="0060">These and other aspects of the invention will be elucidated hereinafter by reference to the drawings, wherein</p>
<p id="p-0062" num="0061"><figref idref="DRAWINGS">FIG. 1</figref> is a diagram illustrating operations in a round of AES,</p>
<p id="p-0063" num="0062"><figref idref="DRAWINGS">FIG. 2</figref> is a diagram illustrating an example of obfuscating tables,</p>
<p id="p-0064" num="0063"><figref idref="DRAWINGS">FIG. 3</figref> is a diagram illustrating a round for a column in a white-box AES implementation,</p>
<p id="p-0065" num="0064"><figref idref="DRAWINGS">FIG. 4</figref> is a diagram illustrating mappings incorporated in a type Ia table,</p>
<p id="p-0066" num="0065"><figref idref="DRAWINGS">FIG. 5</figref> is a diagram illustrating mappings incorporated in a type II table,</p>
<p id="p-0067" num="0066"><figref idref="DRAWINGS">FIG. 6</figref> is a diagram illustrating mappings incorporated in a type III table,</p>
<p id="p-0068" num="0067"><figref idref="DRAWINGS">FIG. 7</figref> is a diagram illustrating mappings incorporated in a type IV table,</p>
<p id="p-0069" num="0068"><figref idref="DRAWINGS">FIG. 8</figref> is a diagram illustrating mappings incorporated in a type Ib table,</p>
<p id="p-0070" num="0069"><figref idref="DRAWINGS">FIG. 9</figref> is a diagram illustrating a white box implementation with an updatable key,</p>
<p id="p-0071" num="0070"><figref idref="DRAWINGS">FIGS. 10</figref><i>a</i>, <b>10</b><i>b </i>and <b>10</b><i>c </i>are diagrams illustrating a key dependent look-up table and a key translation unit,</p>
<p id="p-0072" num="0071"><figref idref="DRAWINGS">FIG. 11</figref> is a diagram illustrating a round of white-box AES,</p>
<p id="p-0073" num="0072"><figref idref="DRAWINGS">FIG. 12</figref> is a diagram illustrating an embodiment.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION OF EMBODIMENTS</heading>
<p id="p-0074" num="0073">We will describe the workings of the invention using as an example a block cipher, the block cipher AES. However, this is done as an illustrative example only, as the invention can be more generally applied, to other block ciphers, e.g. DES, but more generally also to other cryptographic primitives, for example, hash functions.</p>
<p id="p-0075" num="0074">In overview the following may be done. The block cipher AES is first converted into a form using only a network of look-up tables for its computations. Converting all cryptographic primitives to look-up tables is not necessary. In fact some of the computation may be performed using primitives in other forms than look-up tables. Below we will show how AES may be performed using only look-up tables, but not all conversions need to be adopted. The conversion to a network of look-up tables is done for a particular key. The precise key can, for example, be chosen to be the all zero key, or any random key. Although explicit reference to the key will disappear in this process, it will turn out that the contents of some look-up tables will depend on the key. Some look-up tables only depend on implementation choices, e.g., the obfuscating encodings that are used, etc, whereas other look-up tables also depend on the key.</p>
<p id="p-0076" num="0075">One way to make the key for which the white-box implementation is adapted updatable is by introducing key translation units. A key translation unit may be placed in front of a look-up table. The inputs that are to be sent to the key dependent look-up table are routed through the key translation unit so that the key translation unit may modify them. The modifications that are performed on the data before they are passed to the key-dependent look-up table are dependent on a key substitute. The specific look-up table may continue to perform the same mapping, but, in a manner of speaking, the mapping is translated to the remainder of the network of look-up tables.</p>
<p id="p-0077" num="0076">The key substitute represents, at least to the network, the further cryptographic key. A key substitute may be entirely different from another key substitute that represents the same further cryptographic key but to another white-box implementation of the cryptographic implementation. The reason behind this is that the key substitute may be represented with respect to the particular cryptographic key for which the network is adapted, and these may be chosen differently for different white-box networks. Moreover, the key substitute may be obfuscated using encodings, which may also be chosen different in the other white-box. Finally, the key substitute may have to take into account the encodings used for inputs and/or outputs of the specific look-up table.</p>
<p id="p-0078" num="0077">Another possibility is to position a key translation unit after the key-dependent look-up table. The outputs of the key-dependent look-up table that are to be sent to the remainder of the network of look-up tables are routed through the key translation unit so that the key translation unit may modify them. The modifications that are performed on the data after they are passed through the key-dependent look-up table are dependent on a key substitute.</p>
<p id="p-0079" num="0078">Modifying the inputs and outputs of key-dependent look-up tables may be combined. For each key-dependent look-up table that is to be updatable a key translation unit may be used. However, one key translation unit may be re-used for multiple key-dependent look-up tables. For example, re-use is possible if two tables are adapted for the same key, e.g., same part of a round key, and use the same encodings. To make the implementation fully key-updateable all key dependent look-up tables must be updateable. However, it is not necessary that all tables are made updateable in the manner described herein. Other techniques may be combined, for example, some look-up tables may be adapted to a new key by replacing them entirely. It is also possible to construct multiple copies of some key-dependent look-up tables before-hand, each one adapted to a different key. Later a table selection string may be received selecting the key-dependent table which is to be used. Combining different techniques has the advantage of further obfuscating the key updating procedure.</p>
<p id="p-0080" num="0079">AES is a block cipher with a block size of 128 bits or 16 bytes. The plaintext is divided in blocks of 16 bytes which form the initial state of the encoding algorithm, and the final state of the encoding algorithm is the cipher text. To conceptually explain AES, the bytes of the state are organized as a matrix of 4&#xd7;4 bytes. AES consists of a number of rounds. Each round is composed of similar processing steps operating on bytes, rows, or columns of the state matrix, each round using a different round key in these processing steps.</p>
<p id="p-0081" num="0080"><figref idref="DRAWINGS">FIG. 1</figref> illustrates some main processing steps of a round of AES. The processing steps include:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0081">AddRoundKey <b>802</b>&#x2014;each byte of the state is XOR'ed with a byte of the round key.</li>
        <li id="ul0002-0002" num="0082">SubBytes <b>804</b>&#x2014;A byte-to-byte permutation using a lookup table.</li>
        <li id="ul0002-0003" num="0083">ShiftRows <b>806</b>&#x2014;Each row of the state is rotated a fixed number of bytes.</li>
        <li id="ul0002-0004" num="0084">MixColumns <b>808</b>&#x2014;Each column is processed using a modulo multiplication in GF(2<sup>8</sup>).</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0082" num="0085">The steps SubBytes <b>804</b>, ShiftRows <b>806</b>, and MixColumns <b>808</b> are independent of the particular key used. The key is applied in the step AddRoundKey <b>802</b>. Except for the step ShiftRows <b>806</b>, the processing steps can be performed on each column of the 4&#xd7;4 state matrix without knowledge of the other columns. Therefore, they can be regarded as 32-bit operations as each column consists of 4 8-bit values. Dashed line <b>810</b> indicates that the process is repeated until the required number of rounds has been performed.</p>
<p id="p-0083" num="0086">Each of these steps or a combination of steps may be represented by a lookup table or by a network of lookup tables. If the AddRoundKey step were implemented by XOR'ing with the round key, then the key is visible to the attacker in the white-box attack context. The AddRoundKey step can also be embedded in lookup tables, which makes it less obvious to find out the key. In fact, it is possible to replace a full round of AES by a network of lookup tables. For example, the SubBytes, ShiftRows, and MixColumns steps may be implemented using table lookups. Below we will discuss a possible white-box implementation of AES more fully. First we will present white box implementation techniques with respect to a fixed key, then we will describe how to extend the implementation to an updatable implementation. It is noted that one may also choose to create an updatable implementation directly, without going through the intermediate step of producing a white-box implementation adapted to a single fixed key.</p>
<p id="p-0084" num="0087"><figref idref="DRAWINGS">FIG. 2</figref> illustrates a way to make it even more difficult to extract the key. After a cryptographic operation, such as an AES encryption, has been transformed into a network of basic operations, further obfuscation is possible. Let X and Y be two functions, i.e., basic operations. Consider the composite operation Y&#x2218;X=Y(X(c)), illustrated as diagram <b>812</b>, that is, to obtain the composite operation, Y is performed after X. Here c is an input value, for example, a 4-byte state column. However, the approach applies to any type of input value c. Mappings X and Y can be implemented as look-up tables which can be stored in memory, however, when they are stored in memory the values can be read by an attacker. Diagram <b>814</b> illustrates how the contents of the look-up tables can be obfuscated by using an input encoding F and an output encoding H. Look-up tables corresponding to X&#x2218;F<sup>&#x2212;1 </sup>and H&#x2218;Y are stored as illustrated instead of X and Y, making it more difficult to extract X and Y. Diagram <b>816</b> shows how to add an additional, for example, random, bijective function G, such that the intermediate result of the two tables is also encoded. In this case, two tables are stored in memory: X&#x2032;=G&#x2218;X&#x2218;F<sup>&#x2212;1 </sup>and Y&#x2032;=H&#x2218;Y&#x2218;G<sup>&#x2212;1</sup>. This is illustrated once more in diagram 18:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>Y&#x2032;&#x2218;X&#x2032;=</i>(<i>H&#x2218;Y&#x2218;G</i><sup>&#x2212;1</sup>)&#x2218;(<i>G&#x2218;X&#x2218;F</i><sup>&#x2212;1</sup>)<i>=H&#x2218;</i>(<i>Y&#x2218;X</i>)<i>&#x2218;F</i><sup>&#x2212;1</sup>,<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0085" num="0088">where &#x2218; denotes function composition as usual (i.e., for any two functions &#x192;(x) and g(x), &#x192;&#x2218;g(x)=&#x192;(g(x)) by definition), X and Y are functions suitable for implementation by means of look-up tables. Likewise a network consisting of more than two functions can be encoded. The actual tables encoding X and Y are obfuscated by combining H&#x2218;Y&#x2218;G<sup>&#x2212;1 </sup>in a single look-up table and combining G&#x2218;X&#x2218;F<sup>&#x2212;1 </sup>in a single look-up table. As long as F, G, and/or H remain unknown, the attacker cannot extract information about X and/or Y from the look-up tables, and hence the attacker cannot extract the key that is the basis for X and/or Y. Other cryptographic algorithms, including DES and Rijndael (of which AES is a particular instantiation), may also be encoded as a cascade or network of look-up tables that may be obfuscated in a way similar to the above. The invention is not limited to the exemplary cryptographic algorithms mentioned.</p>
<p id="p-0086" num="0089">Chow 1 discloses a method with the intend to hide the key by encoding its tables with random bijections representing compositions rather than individual steps. Preventing secret-key extraction has the advantage that an attacker is prevented from extracting keying material which would allow software protection goals to be bypassed on other machines, or from publishing keying material effectively creating &#x2018;global cracks&#x2019; which defeat security measures across large user-bases of installed software. It provides an increased degree of protection given the constraints of a software-only solution and the hostile-host reality. In the approach of Chow 1, the key is hidden by (1) using tables for compositions rather than individual steps; (2) encoding these tables with random bijections; and (3) extending the cryptographic boundary beyond the crypto algorithm itself further out into the containing application, forcing attackers (reverse engineers) to understand significantly larger code segments to achieve their goals. Chow 1 discusses a fixed key approach: the key(s) are embedded in the implementation by partial evaluation with respect to the key(s), so that key input is unnecessary. Partial evaluation means that expressions involving the key are evaluated as much as reasonably possible, and the result is put in the code rather than the full expressions. This in itself somewhat hides the key as it now resides throughout the implementation, but furthermore, the efficient techniques of obfuscating look-up tables can be applied to hide the key.</p>
<p id="p-0087" num="0090">A possible attack-scenario is for an attacker to extract a key-specific implementation and use it instead of the key. This problem can be mitigated by designing the key-specific implementation tailored to function as a component of a larger containing system. The larger system can be arranged to provide the component with input in a manipulated or encoded form. When the key-specific implementation is removed by an attacker and inserted in a different larger system, the key-specific implementation will not function properly since the different larger system will not provide its input in the manipulated form expected by the key-specific implementation.</p>
<p id="p-0088" num="0091">Referring to the step of encoding tables, since encodings are arbitrary, results are meaningful only if the output encoding of one step matches the input encoding of the next. For example, if step X is followed by step Y (resulting in computation of Y&#x2218;X), the computation could be encoded as
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>Y&#x2032;&#x2218;X&#x2032;=</i>(<i>H&#x2218;Y&#x2218;G</i><sup>&#x2212;1</sup>)&#x2218;(<i>G&#x2218;X&#x2218;F</i><sup>&#x2212;1</sup>)<i>=H&#x2218;</i>(<i>Y&#x2218;X</i>)<i>&#x2218;F</i><sup>&#x2212;1</sup>.<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0089" num="0092">This way, Y&#x2218;X is properly computed albeit that the input needs to be encoded with F and the output needs to be decoded with H<sup>&#x2212;1</sup>. The steps are separately represented as tables corresponding to Y&#x2032; and X&#x2032;, so that F, G, and H are hidden as well as X and Y.</p>
<p id="p-0090" num="0093">Apart from such confusion steps, Chow 1 uses diffusion steps by means of linear transformations to further disguise the underlying operations. The term mixing bijection is used to describe a linear bijection, used in the above sense. The implementation of Chow 1 takes input in a manipulated form, and produces output in a differently manipulated form, thereby making the white-box AES implementation difficult to separate from its containing application. Note that the mixing bijection represents additional obfuscating means and are not necessary to implement AES functionality. If more obfuscation is necessary then a white-box according to the invention may also be combined with other obfuscation techniques.</p>
<p id="p-0091" num="0094">Chow 2 discusses a cryptographic implementation of DES designed to withstand white-box attacks that aim at extracting secret keys from the program. The techniques discussed in this paper about obfuscating look-up table networks apply for a large part also to other cryptographic algorithm including AES and others. While an attacker controlling the execution environment can clearly make use of the software itself (e.g. for decryption) without explicitly extracting the key, forcing an attacker to use the installed instance at hand is often of value to digital rights management (DRM) systems providers. In general, the approach in Chow 2 is to work towards an implementation consisting entirely of substitution boxes, none of which implement affine transformations. A number of techniques, described in Chow 2, support the general approach. Some of these techniques are I/O-blocked encoding, combined function encoding, by-pass encoding, split-path encoding, and output splitting.</p>
<p id="p-0092" num="0095">Partial evaluation means that expressions based on values (partially) known at the time of implementation are pre-evaluated. In a simplified example, when the key is &#x2018;5&#x2019;, and the original implementation contains the expression &#x2018;2*key&#x2019;, then rather than incorporating &#x2018;2*5&#x2019; in the implementation, the pre-evaluated expression &#x2018;10&#x2019; is put in the implementation. This way, the key &#x2018;5&#x2019; is not directly present in the code. In the case of DES with a fixed key, this involves replacing standard S-boxes with key-specific pre-evaluated S-boxes, e.g., computed from the key at or before compilation time. A mixing bijection according to Chow 2 is a bijective linear transformation designed such that each output bit depends on a large number of input bits. I/O-blocked encoding is an encoding method for handling large numbers of input and output bits. In this case, the encoding/decoding can be formed as a concatenation of encodings, where each encoding deals with a subset of the input/output bits. Combined function encoding means that if two or more operations can be processed in parallel, a single encoding function is applied to the concatenation of the inputs (respectively outputs) of the parallel operations. It is more or less the opposite of I/O-blocked encoding. By-pass encoding means that the encoding transformation adds a number of superfluous bits of entropy to the input and/or output of the transform to be obfuscated, and redesign the transform to be obfuscated to &#x201c;by-pass&#x201d; the superfluous bits such that they do not affect the final output of the procedure. Split-path encoding means that a function is modified to provide additional output bits for obfuscating the essential information bits. Output splitting means that the output of a function is distributed over several partial functions, where the output of all partial functions must be combined, preferably in a non-obvious way, in order to obtain the original output of the function.</p>
<p id="p-0093" num="0096">Chow 2 proposes building encoded networks to construct S-boxes with wide input of, say, 32 bits or even 96 bits. Such a wide-input S-box is divided into a network of S-boxes each having a more narrow input and output; each of the S-boxes is encoded by incorporating an encoding function in the S-box. The inverse of the encoding function is incorporated in the further S-box processing the output of the S-box. To put this in other words, the further S-box has an input encoding which is the inverse of the output encoding of the S-box.</p>
<p id="h-0006" num="0000">A White Box Implementation of AES</p>
<p id="p-0094" num="0097">To improve to clarity of the exposition, we will first describe a possible white-box implementation of a block cipher, in this case AES. Below we will indicate how the white-box may be adapted such that the precise cryptographic operation that it performs may be changed afterwards by sending it an updating string. It is noted, that the problem the invention seeks to solve is not just restricted to the particular implementation given below, but is endemic to white-box implementations in general. We refer to Chow 1, in particular section 2.2 to section 3.6, for more details on known white-box implementations.</p>
<p id="p-0095" num="0098">A White-box AES implementation can be sketched as follows. The input to the AES encryption and decryption algorithm is a single 128-bit block. This block is represented by a 4&#xd7;4 matrix consisting of 16 bytes. AES usually consists of 10 rounds for AES-128. Each round updates a set of sixteen bytes which form the state of AES, thus each AES round processes 128 bits. AES-128 uses a key of 128 bits. This key serves as input for an algorithm which converts the key into different round keys of 128 bits. A basic round consists of four parts:
<ul id="ul0003" list-style="none">
    <li id="ul0003-0001" num="0000">
    <ul id="ul0004" list-style="none">
        <li id="ul0004-0001" num="0099">SubBytes</li>
        <li id="ul0004-0002" num="0100">ShiftRows</li>
        <li id="ul0004-0003" num="0101">MixColumns</li>
        <li id="ul0004-0004" num="0102">AddRoundKey.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0096" num="0103">This order of operations applies to AES encryption. Although the standard order of operations in AES decryption is different, it is possible to rewrite the AES decryption algorithm to have the same order of operations as for AES encryption.</p>
<p id="p-0097" num="0104">Before the first round, an extra AddRoundKey operation occurs, and from round ten the MixColumns operation is omitted. The only part that uses the key is AddRoundKey, the other three parts do nothing with the key. In the implementation the boundaries of the rounds are changed to integrate the AddRoundKey step and the SubBytes step of the next round into one step. A round begins with AddRoundKey and SubBytes followed by ShiftRows and finally MixColumns.</p>
<p id="p-0098" num="0105">First, the key is hidden by composing the SubBytes step and the AddRoundKey together into one step. This makes the key no longer visible on its own. Because the key is known in advance, the operations involving the key can be pre-evaluated. This means that the standard S-Boxes which are used in the step SubBytes can be replaced with key-specific S-Boxes. To generate key-specific instances of AES-128, the key is integrated into the SubBytes transformations by creating sixteen 8&#xd7;8 (i.e. 8-bit input, 8-bit output) lookup tables T<sub>i,j</sub><sup>r </sup>which are defined as follows:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>T</i><sub>i,j</sub><sup>r</sup>(<i>x</i>)<i>=S</i>(<i>x&#x2295;k</i><sub>i,j</sub><sup>r-1</sup>),<i>i</i>=0, . . . ,3; <i>j</i>=0, . . . ,3; <i>r</i>=1, . . . ,9,<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
where S is the AES S-box (an invertible 8-bit mapping), and k<sub>i,j</sub><sup>r </sup>is the AES sub-key byte at position i, j of the 4&#xd7;4 matrix which represents the round key for round r. These T-boxes compose the SubBytes step with the previous round's AddRoundKey step. The round 10 T-boxes absorb the post-whitening key as follows:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>T</i><sub>i,j</sub><sup>10</sup>(<i>x</i>)<i>=S</i>(<i>x&#x2295;k</i><sub>i,j</sub><sup>9</sup>)<i>&#x2295;k</i><sub>sr(i,j)</sub><sup>10</sup><i>,i</i>=0, . . . ,3; <i>j</i>=0, . . . ,3,<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0099" num="0106">where sr(i,j) denotes the new location of cell i,j after the ShiftRows step. The total number of T-boxes is 10&#xd7;16=160. However, the key can easily be recovered from T-boxes because S is publicly known. This makes additional encodings necessary. Linear transformations are used for diffusing the inputs to the T-boxes. These linear transformations are called mixing bijections and can be represented as 8&#xd7;8 matrices over GF(2). The mixing bijections are inverted by an earlier computation to undo their effect.</p>
<p id="p-0100" num="0107"><figref idref="DRAWINGS">FIG. 3</figref> illustrates the tables involved in a round of white-box AES for one 32-bit column of the state (after applying ShiftRows). The three other 32-bit columns are handled in the same way, although the tables have a different content since for those columns different key values may be used. Moreover, different encoding may be applied to the other columns.</p>
<p id="p-0101" num="0108">The names of the different types of tables are introduced here. They are discussed in more detail hereinafter. Before the rounds, each byte of the 128-bit state is applied to a respective type Ia table. This results in respective 128-bit values which are XOR'ed using a network of type IV tables to provide a 128-bit output that is divided into four 32-bit values. The processing steps of each 32-bit value are outlined here. The four bytes of the 32-bit value are input to four respective type II tables <b>20</b>. Each of the four type II tables <b>20</b> result in a 32-bit output. These outputs are bitwise XOR'ed using type IV tables <b>22</b>. Each type IV table 22 performs a 4-bit bitwise XOR. By properly connecting inputs and outputs of type IV tables, the bitwise XOR of the four 32-bit outputs can be realized as will be understood by the skilled artisan. The result of this step is a 32-bit value. Each of the four bytes of this value is applied to a respective type III table <b>24</b>. Each type III table provides a 32-bit output. These outputs are again bitwise XOR'ed using a network of type IV tables <b>26</b> similar to the network of type IV tables <b>22</b>. The output is a 32-bit value indicative of a column of the state. This is repeated for each round.</p>
<p id="p-0102" num="0109">After the rounds have been performed for each of the four 32-bit values, the outputs are combined into a 128-bit value. Each byte of the 128-bit value is applied to a type Ib table; the results are XOR'ed using a network of type IV tables.</p>
<p id="p-0103" num="0110"><figref idref="DRAWINGS">FIG. 4</figref> illustrates a type Ia table <b>100</b>. <figref idref="DRAWINGS">FIG. 5</figref> illustrates a type II table <b>200</b>. <figref idref="DRAWINGS">FIG. 6</figref> illustrates a type III table <b>300</b>. <figref idref="DRAWINGS">FIG. 7</figref> illustrates a type IV table <b>400</b>. <figref idref="DRAWINGS">FIG. 8</figref> illustrates a type Ib table <b>500</b>.</p>
<p id="p-0104" num="0111">An AES state is represented by a 4&#xd7;4 matrix consisting of bytes. The MixColumns step operates on a column (four 8-bit cells) at a time. Consider a 32&#xd7;32 matrix MC, which implements the MixColumns operation. If this is represented by a table, this table would cost 2<sup>32</sup>&#xd7;32=137438953472 bits=16 GB. In order to avoid such large tables the matrix is blocked into four sections.</p>
<p id="p-0105" num="0112">MC is blocked into four 32&#xd7;8 sections, MC<b>0</b>, MC<b>1</b>, MC<b>2</b>, MC<b>3</b> (block <b>208</b>). Multiplication of a <b>32</b>-bit vector x=(x<b>0</b>, . . . , x<b>31</b>) by MC is done by dividing the bits of x into four bytes and multiplying each of the sections of MC with one of the bytes, yielding four 32-bit vectors (z<b>0</b>, . . . , z<b>3</b>). This is followed by three 32-bits XORs giving the final 32-bit result z. The four tables together only cost 4&#xd7;2<sup>8</sup>&#xd7;32=32768 bits=4 KB.</p>
<p id="p-0106" num="0113">The three XORs will be divided into 24 4-bit XORs, each represented by a possibly encoded look-up table, with appropriate concatenation (e.g. ((z[0, 0], z[0, 1], z[0, 2], z[0, 3])+(z[1, 0], z[1, 1], z[1, 2], z[1, 3]))&#x2225;((z[0, 4], z[0, 5], z[0, 6], z[0, 7])+(z[1, 4], z[1, 5], z[1, 6], z[1, 7]))&#x2225; . . . ), where &#x2225; denotes concatenation and + denotes XOR. By using these strips and subdivided XORs, each step is represented by a small lookup table. In particular, for i=0, . . . , 3 the zi are computed using 8&#xd7;32-bit tables. An 8&#xd7;32-bit table has an 8-bit input and a 32-bit output. Such a table may be implemented by listing 2<sup>8 </sup>output values of 32 bit each. The 4-bit XORs become 24 8&#xd7;4-bit tables. <figref idref="DRAWINGS">FIG. 7</figref> illustrates how input decodings <b>402</b> and output encodings <b>406</b> can be put around the XORs <b>404</b>. These encodings are usually randomly chosen non-linear 4&#xd7;4 bijections. The XOR tables are called type IV tables <b>400</b>. The type IV tables take as input 4 bits from each of two previous computations. The output encodings <b>212</b> of those computations are matched with the input decodings <b>402</b> for the type IV tables to undo each other. The choice for 4&#xd7;4 non-linear bijections depended on the size of the tables. In this situation a type IV table is only 2<sup>8</sup>&#xd7;4 bits=128 bytes. 24 tables are needed which cost together 3 KB. If the XORs were not divided, three XOR tables would be needed which computed 32-bit XORs. The T-boxes <b>206</b> and the 8&#xd7;32-bit tables <b>208</b> could be represented as separate lookup tables. Instead, they can be composed creating new 8&#xd7;32-bit tables <b>200</b> computing the SubBytes and AddRoundKey transformations as well as part of MixColumns. This saves both space (to store the T-boxes) and time (to perform the table lookups).</p>
<p id="p-0107" num="0114">Before splitting MC into MCi as above, MC will be left-multiplied by a 32&#xd7;32 mixing bijection MB, illustratively indicated in <figref idref="DRAWINGS">FIG. 5</figref> at reference numeral <b>210</b>, chosen as a non-singular matrix with 4&#xd7;4 sub-matrices of full rank. The use of mixing bijections increases the number of possible constructions for a particular table.</p>
<p id="p-0108" num="0115"><figref idref="DRAWINGS">FIG. 5</figref> illustrates an 8&#xd7;32 type II table <b>200</b> including 4&#xd7;4 input decodings <b>202</b> and 4&#xd7;4 output encodings <b>212</b>. These output encodings and input decodings are non-linear 4&#xd7;4 bijections which must match the input decodings and output encodings of the type IV tables <b>400</b>. The type II tables <b>200</b> are followed by type IV tables <b>400</b>. In order to invert MB, an extra set of tables is used for calculating MB<sup>&#x2212;1</sup>. Let (x&#x2032;<sub>0</sub>, . . . , x&#x2032;<sub>31</sub>) be the input to MixColumns, and let (z<sub>0</sub>, . . . , z<sub>31</sub>) be the output after MixColumns. Let (z&#x2032;<sub>0</sub>, . . . , z&#x2032;<sub>31</sub>)<sup>T </sup>be the result after multiplication with MB. (z&#x2032;<sub>0</sub>, . . . , z&#x2032;<sub>31</sub>)<sup>T </sup>serves as input to the type III tables <b>300</b>. Note that the input decodings and the output encodings need not be considered here because the output encoding of a table is undone by the input decoding of a next table. In the type III tables <b>300</b>, MB<sup>&#x2212;1 </sup>is applied <b>304</b> and the inverses <b>308</b> of the four input mixing bijections <b>204</b> of the next round's four type II tables <b>200</b>.</p>
<p id="p-0109" num="0116"><figref idref="DRAWINGS">FIG. 6</figref> illustrates an 8&#xd7;32 type III table <b>300</b> including 4&#xd7;4 non-linear input decodings and 4&#xd7;4 non-linear output encodings. These tables are followed by corresponding type IV tables <b>400</b>.</p>
<p id="p-0110" num="0117">One round of data operations involves an operation on a 128-bit state matrix. The data operations performed on each of four strips of 32 bits of the 128-bit state matrix is as follows. The 32-bit strip is divided into four 8-bit bytes. Each of the four bytes is fed into a distinct type II table <b>200</b>, resulting in four 32-bit output values. These values have to be XOR'ed using obfuscated type IV tables <b>400</b>. To that end, each 32-bit output value is divided into eight 4-bit nibbles, and appropriate pairs of nibbles are input to respective type IV tables, such that the XOR of the four 32-bit output values is obtained in encoded form.</p>
<p id="p-0111" num="0118">This 32-bit resulting encoded XOR'ed result is again divided into bytes, and each byte is input to a distinct type III table <b>300</b>. The input decoding of each nibble of the type III tables corresponds to the output encoding of the last applied type IV tables. The type III tables again result in four 32-bit output values that are again XOR'ed using obfuscated type IV tables <b>400</b>.</p>
<p id="p-0112" num="0119">In summary, the rounds are implemented by lookup tables. The lookup tables of a single round are networked as follows. The data is fed into Type II tables. The output of these tables is fed to a network of Type IV tables representing encoded XORs. The output of this network is fed to Type III tables canceling the mixing bijection encoding that is inserted by the Type II tables. The encoded output of the round is finally derived by feeding the output of the Type III tables into, again, a network of Type IV tables representing encoded XORs.</p>
<p id="p-0113" num="0120">Furthermore, the white-box implementation contains Type I tables at the beginning (type Ia table <b>100</b>) and the end (type Ib table <b>500</b>) for respectively canceling out and inserting external encodings. The type Ia table <b>100</b> can be used to apply a concatenation of mappings as illustrated in <figref idref="DRAWINGS">FIG. 4</figref> by applying a single table look-up. In the concatenation, a 4-bit nibble input decoding <b>102</b> appears first. Then, an 8-bit to 128-bit mapping <b>104</b> appears; this mapping is part of an encoding of the input and output of the network; this mapping can be undone elsewhere in the program. Apart from the linear 8 bit to 128 bit mapping, also other tables may be part of the external encoding. For example, if Table <b>100</b> is comprised in the first round, then <b>102</b> may be included. Similarly, if Table <b>500</b> is in the last round encoding <b>212</b> may be included. The result of mapping <b>104</b> is split in 16 eight-bit pieces to which respective 8-bit bijections <b>106</b> are applied. Finally, the output nibble encoding <b>108</b> is applied. As mentioned, the cascade of mappings <b>102</b>, <b>104</b>, <b>106</b>, and <b>108</b> is pre-evaluated and the final result is tabulated in a look-up table. This results in a table with at most 256 entries of 128 bits each. The concatenation of mappings incorporated in a type Ib table <b>500</b> is schematically displayed in <figref idref="DRAWINGS">FIG. 8</figref>. The first mapping is the input nibble decoding <b>502</b>, which is followed by an 8-bit bijection <b>504</b>, a T-box T<sub>i,j</sub><sup>r </sup><b>506</b>, where r corresponds to the last round, an 8-bit to 128 bit mapping for providing output encoding, and output nibble encodings <b>510</b>. The 128-bit output of this kind of table is XOR'ed with the output of other type Ib tables, again making use of nibble input and output encoded type IV tables <b>400</b>. The output encoding <b>508</b> is undone elsewhere in the program, i.e., outside the cryptographic part of the program. This makes it more difficult for an attacker to break the encodings of the tables by analyzing only an input and an output of the cryptographic part of the program.</p>
<p id="h-0007" num="0000">An Improved White-Box Implementation of AES</p>
<p id="p-0114" num="0121">White-box techniques, such as described, e.g., in Chow 1 and Chow 2 can be combined with each other in various ways to obtain white-box implementation of a wide variety of cryptographic operations, including block-ciphers, especially substitution-affine-transformation ciphers, streams ciphers, message authentication codes (MAC), etc. To convert AES into lookup tables the technique of partial evaluation was used. As a consequence the key has spread over the whole of the implementation. To make the white box implementation updatable the following changes can be made.</p>
<p id="p-0115" num="0122">Referring again to <figref idref="DRAWINGS">FIG. 3</figref>, only the type II tables and the Type 1b tables depend on the key, since they incorporate a T-box. The other tables depend on the details of the cipher algorithm, (in this case AES), and the encodings chosen.</p>
<p id="p-0116" num="0123"><figref idref="DRAWINGS">FIG. 3</figref> shows all Type II tables needed for one column, i.e., 32 bits of intermediate data of one round of AES. One Type II table depends on 8 key-bits, that is, on 8 bit of one AES round-key. When viewed as a function composition this key dependency is done at the beginning of the function sequence, directly after the encodings, see <figref idref="DRAWINGS">FIG. 5</figref>. For this reason a convenient place to make type II tables updateable is to place a key translation units before the type II tables. A key translation unit that performs an XOR operation suffices in this case, since the key addition in a type II table is placed such that it can combine with an addition in the key translation unit. The key translation unit takes as a first input the output of a table, that is to be routed to an input of the type II table and as a second input a byte of the key substitute that corresponds to the type II table. It is noted that the input of a table, in particular a type II table, may come from multiple tables. For example, in an embodiment the input of a type II table comes from the outputs of two type IV tables. In this case both inputs of the type II table may be routed through a key translation unit. The key translation unit performs an XOR addition on the two inputs. Performing an XOR can be done be using, or reusing, two type IV tables. Each type IV table may perform an XOR on a nibble of the inputs of the first and second input.</p>
<p id="p-0117" num="0124"><figref idref="DRAWINGS">FIG. 9</figref> illustrates cryptographic system <b>600</b>. The system comprises a plurality of look-up tables <b>640</b>. Of plurality <b>640</b> look-up tables <b>610</b>, <b>620</b> and <b>630</b> are shown. Look-up table <b>630</b> is a specific look-up table that is adapted to a particular key. For example, look-up table <b>630</b> may be constructed by composing a T-box with one or more other operations. Look-up table <b>620</b> is a key translation unit. Look-up table <b>610</b> may for example provide inputs for look-up table <b>630</b>. A look-up table takes one or more inputs and produces one or more outputs. Cryptographic system <b>600</b> comprises a look-up table manager <b>650</b> which has access to the blocks in plurality <b>640</b>. The tables <b>640</b> may be stored in a memory to which manager <b>650</b> has access. Alternatively, the tables can be implemented as hardware chips using e.g. CMOS technology. Manager <b>650</b> may, for example, have access to the look-up tables via a bus. Manager <b>650</b> itself may be implemented as a software program stored in a memory and executed using a general purpose processor (not shown). Alternatively, manager <b>650</b> may be implemented as a finite state machine in hardware. Manager <b>650</b> may have access to other cryptographic primitives, e.g., formulas implemented in software, during execution of a cryptographic operation.</p>
<p id="p-0118" num="0125">Manager <b>650</b> is adapted to receive an input-message <b>662</b> and a key substitute <b>664</b>. The key substitute <b>664</b> represents to the network the key that is to be used during the computation. For example, key substitute <b>664</b> may comprise multiple parts, each part corresponding to a key dependent look-up table of the plurality <b>640</b>. Manager <b>650</b> may be configured to parse key substitute <b>664</b> and use different parts for different key translation units. For example, key substitute <b>664</b> may comprise 16 times 1 sub-key substitute. One sub-key substitute for each T-box which may be used in an AES white-box implementation. Key substitute <b>664</b> may be represented as bit string, or converted to an ASCII string if that is convenient.</p>
<p id="p-0119" num="0126">There does not need to be a direct relation between the eventual key that will be used and the key substitute <b>664</b>. Only the combination of the tables and the key substitute determine the key. Access to the key substitute <b>664</b> alone does not suffice to derive the key used in the cryptographic operation for which it configures the cryptographic system <b>600</b>.</p>
<p id="p-0120" num="0127">During operation, manager <b>650</b> receives key substitute <b>664</b> and input-message <b>662</b>. Manager <b>650</b> parses key substitute <b>664</b> and determines which parts of key substitute <b>664</b> are needed for which key translation unit. A look-up table produces an output which comprises an intermediate result and/or whole or part of the output message (not shown). The output message may be formed by combining, e.g., concatenating, the output of multiple specific look-up tables. Intermediate data, and combinations thereof, are used as inputs to further look-up tables in an iterative fashion until the look-up tables together have performed the cryptographic operation, or at least a substantive part thereof. The key translations table is provided with at least a part of the key substitute <b>664</b>.</p>
<p id="p-0121" num="0128">A key translation unit can be integrated with a key-dependent look-up table in various ways. A few examples are illustrated in <figref idref="DRAWINGS">FIGS. 10</figref><i>a</i>, <b>10</b><i>b </i>and <b>10</b><i>c. </i></p>
<p id="p-0122" num="0129"><figref idref="DRAWINGS">FIG. 10</figref><i>a </i>shows two look-up tables <b>612</b> and <b>614</b> which are located in the network of look-up tables before a key dependent table <b>630</b>. For example, tables <b>612</b> and <b>614</b> are type IV tables, and look-up table <b>630</b> is a type II table. The outputs of tables <b>612</b> and <b>614</b> are used as a first input to key translation unit <b>620</b>. Key translation unit receives a key substitute <b>665</b> as a second input, which is derived from key substitute <b>664</b>. Key substitute <b>665</b> represents to the network the key on which table <b>630</b> depends. Before table <b>620</b> forwards the output of <b>612</b> and <b>614</b> they are translated such that the combination of tables <b>620</b> and <b>630</b> together perform the same cryptographic operation as table <b>630</b> but for a different key.</p>
<p id="p-0123" num="0130"><figref idref="DRAWINGS">FIG. 10</figref><i>b </i>elaborates on the situation in <figref idref="DRAWINGS">FIG. 10</figref><i>a</i>. Key translation unit <b>620</b> is distributed over two smaller key translation units <b>622</b> and <b>624</b> who receive key substitutes <b>666</b> and <b>667</b> respectively as second input. For example, tables <b>622</b> and <b>624</b> are type IV tables, and table <b>622</b> XORs together key substitute <b>666</b> and the output of table <b>612</b>. For example, table <b>624</b> XORs together key substitute <b>667</b> and the output of table <b>614</b>.</p>
<p id="p-0124" num="0131"><figref idref="DRAWINGS">FIG. 10</figref><i>c </i>represents a further possibility. Here key dependent table <b>630</b> receives his input directly from tables <b>612</b> and <b>614</b>. A key translation unit <b>620</b> is placed to receive as first input the output of table <b>630</b> and as second input key substitute <b>668</b> to translate his results for a new key.</p>
<p id="p-0125" num="0132">It is preferred to place the key translation unit after the key-dependent look-up table. This has the advantage that the effect of a key addition has influenced further intermediate results. As more bits depend on the key addition that one wishes to correct it becomes harder for an attacker to figure out how the key dependencies work. For example, part of the network may look as follows: type II tables, followed by a type IV network, followed by key translation units, followed by type III tables. One byte of intermediate data after the type IV network depends on 4 key bytes, instead of only one directly after the type II network. An operator who has access to the full round key can still express the necessary change to the byte as a single one byte offset, since the type IV network is linear.</p>
<p id="p-0126" num="0133">We continue our description with respect to <figref idref="DRAWINGS">FIG. 9</figref>. After manager <b>650</b> has received input message <b>662</b> and key substitute <b>664</b>, he forwards parts of the message to look-up tables. The results of those look-up tables are inputs for yet new look-up tables. When a key-dependent look-up table is needed, a corresponding key translation unit is provided with a corresponding key substitute, e.g., part of key substitute <b>664</b>. At some point outputs of look-up tables are collected as the output message (not shown) of system <b>600</b>.</p>
<p id="p-0127" num="0134">Recall from <figref idref="DRAWINGS">FIG. 5</figref> that a type II table starts with a T-box, which in turn starts with a key addition. This can be exploited to efficiently create key translation units of the type described in <figref idref="DRAWINGS">FIG. 10</figref><i>a </i>or <b>10</b><i>b</i>. By adding an offset to the first input, the offset will combine with the key addition in the T-box. By choosing the offset to be the difference between the particular key for which the type II table is adapted and the further cryptographic key which is desired, a type II block can be used for any key. The type II block shown in <figref idref="DRAWINGS">FIG. 5</figref> also has an input encoding. The offset may be encoded with the inverse of the encoding. The offset may also be encoded with a different encoding and the key translation unit may be configured to remove or recoded the different encoding.</p>
<p id="p-0128" num="0135">The last key-dependent table in the AES implementation shown is a type Ib table. This table depends on two key bytes. A first key addition is done before the S-box, a second is done after the S-box. The first key can be updated by introducing a key translation unit before the type Ib table, for example, as in <figref idref="DRAWINGS">FIG. 10</figref><i>a </i>or <b>10</b><i>b</i>. The second key can be updated by introducing a key translation unit after the type Ib block, for example, as in <figref idref="DRAWINGS">FIG. 10</figref><i>c. </i></p>
<p id="p-0129" num="0136">Combinations of the described techniques are also possible. For example, system <b>600</b> may be configured for some key value by replacing a type II table, etc. It is not necessary that system <b>600</b> supports all possible AES keys. For example, only part of the round keys can be made updateable. This has the advantage that the cryptographic operations can be customized somewhat, yet reduces the length of the key substitute further.</p>
<p id="p-0130" num="0137">Note that operations may be done, at least partially, in parallel, in so far as data dependency allows.</p>
<p id="h-0008" num="0000">Detailed Description of the Improved White-Box Implementation</p>
<p id="p-0131" num="0138">We continue with a more detailed description of an embodiment of a white-box implementation. We describe an efficient approach for replacing the cryptographic key implemented by a white-box implementation. For every possible key K of the implemented cipher we may specify a small certificate, comprising the key substitute, such that, based on this certificate, a device can derive a white-box implementation that implements key K for that cipher. The certificate is small with respect to the size of the white-box implementation, and can be made to be only a fraction of a kilobyte.</p>
<p id="p-0132" num="0139">We do not discuss this complete white-box implementation here, but only the part that is most relevant for explaining the invention. We refer to <figref idref="DRAWINGS">FIG. 11</figref>. The approach to reconfiguring the key in white-box implementation may parameterize a white-box implementation with an encoding of the round keys. That is, the input of the white-box implementation can be represented as pair (x, y), where x represents the data to be encrypted/decrypted and y represents the key with which the data need to be encrypted/decrypted. Both x and y are used as input to lookup tables in the white-box implementation. Hence, y does not need to contain a specification of the content of the lookup tables.</p>
<p id="p-0133" num="0140">After optional preceding transformations, such as initial transformations or the previous rounds, a round of AES starts. The beginning of an AES-round is as follows. The input to a round r is split into 16 bytes, the first two of which are indicated with <b>910</b> and <b>911</b>. Byte <b>910</b> is the result of block <b>980</b> in the preceding round or in initial transformations. Each byte i is XORed with a byte k<sub>i</sub><sup>(r) </sup>of the 16-byte round key k<sup>(r)</sup>. The first such addition is indicated with <b>920</b>. The result of this XOR is used as input to an S-box. The S-Box for byte <b>910</b> is indicated with <b>930</b>. In the construction of a white-box implementation, these two operations are merged into a single so-called T-box operation. This means that for each input byte i to the round we define an 8-to-8-bit bijective mapping T<sub>i,k</sub><sub><sub2>i</sub2></sub><sup><sub2>(r&#x2212;2)</sub2></sup><sup>(r) </sup>by
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>T</i><sub>i,k</sub><sub><sub2>i</sub2></sub><sup><sub2>(r&#x2212;2)</sub2></sup><sup>(r)</sup>(<i>x</i>)<i>=S</i>(<i>x&#x2295;k</i><sub>i</sub><sup>(r&#x2212;1)</sup>).<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0134" num="0141">In the construction of a white-box implementation, this T-box is implemented by a lookup table. The lookup table not only implements the T-box operation, but a function U<sub>i,k</sub><sub><sub2>i</sub2></sub><sup><sub2>(r&#x2212;2)</sub2></sup><sup>(r)</sup>(x)=&#x3b1;<sub>i,2</sub><sup>(r)</sup>&#x2218;T<sub>i,k</sub><sub><sub2>i</sub2></sub><sup>(r)</sup>(r&#x2212;2)&#x2218;(&#x3b1;<sub>i,1</sub><sup>(4)</sup>)<sup>&#x2212;1</sup>, where &#x3b1;<sub>i,1</sub><sup>(r) </sup>is a bijective 8 to 8-bit mapping and &#x3b1;<sub>i,2</sub><sup>(r) </sup>is an 8 to 32 bit mapping that is not necessarily bijective. The functions &#x3b1;<sub>i,1</sub><sup>(r) </sup>&#x3b1;<sub>i,2</sub><sup>(r) </sup>may differ for different T-boxes. Function &#x3b1;<sub>1</sub><sup>&#x2212;1 </sup>is indicated with <b>925</b>, and may represent, e.g., an input encoding. The lookup tables that implement a T-box are the only lookup tables in the implementation that depend on the AES key. The operations that follow the T-box and which together with T form operation U are indicated for byte <b>910</b> with <b>950</b>. Basic block <b>950</b> implements at least the MixColumn operation.</p>
<p id="p-0135" num="0142">Let I<sub>K </sub>be a white-box AES implementation according to Chow et al. for AES key K. The construction of this white-box AES implementation can be divided into two parts. In the first part, a white-box implementation is constructed that only uses linear encodings to obfuscate the implementation. The embodiment uses only such obfuscation. However it is noted that in a second part non-linear encodings may also be added. Further obfuscation, for example, using non-linear encodings is preferred, but to simplify the exposition these encodings are not included here. Hence, in the discussion, we can assume that no non-linear encodings are applied. As a consequence, we have that the functions &#x3b1;<sub>i,1</sub><sup>(r) </sup>and &#x3b1;<sub>i,2</sub><sup>(r) </sup>in U<sub>i,k</sub><sub><sub2>i</sub2></sub><sup><sub2>(r&#x2212;2)</sub2></sup><sup>(r)</sup>(x)=&#x3b1;<sub>i,2</sub><sup>(r)</sup>&#x2218;T<sub>i,k</sub><sub><sub2>i</sub2></sub><sub><sub2>i</sub2></sub><sup><sub2>(r&#x2212;2)</sub2></sup><sup>(r)</sup>&#x2218;(&#x3b1;<sub>i,1</sub><sup>(r)</sup>)<sup>&#x2212;1 </sup>are both linear.</p>
<p id="p-0136" num="0143">Suppose that we want the white-box implementation to implement AES with key {circumflex over (K)} instead of AES key K. Then this can be realized as follows. Let the r<sup>th </sup>round key for K and {circumflex over (K)} be given by k<sup>(r) </sup>and {circumflex over (k)}<sup>(r)</sup>, respectively, and let for each input i byte of a round r, and L<sub>i,1</sub><sup>(r) </sup>and L<sub>i,2</sub><sup>(r) </sup>be two lookup tables that implement the XOR, e.g., type IV tables. Furthermore, let byte t=&#x3b1;<sub>i,1</sub><sup>(r)</sup>(k<sub>i</sub><sup>(r&#x2212;1)</sup>&#x2295;{circumflex over (k)}<sub>i</sub><sup>(r&#x2212;1)</sup>) be added to the input of the white-box implementation of U<sub>i,k</sub><sub><sub2>i</sub2></sub><sup><sub2>(r&#x2212;2)</sub2></sup><sup>(r)</sup>. For r=1 the round keys k<sup>(r) </sup>and {circumflex over (k)}<sub>i</sub><sup>(r&#x2212;1) </sup>are associated with the initial key addition of AES. The addition of t, which acts as the key substitute for table U<sub>i,k</sub><sub><sub2>i</sub2></sub><sup><sub2>(r&#x2212;2)</sub2></sup><sup>(r) </sup>is indicated with numeral <b>990</b>. Then, we use table L<sub>i,1</sub><sup>(r) </sup>to XOR the first nibble of &#x3b1;<sub>i,1</sub><sup>(r)</sup>(x) with the first nibble of &#x3b1;<sub>i,1</sub><sup>(r)</sup>(k<sub>i</sub><sup>(r&#x2212;1)</sup>&#x2296;{circumflex over (k)}<sub>i</sub><sup>(r&#x2212;1)</sup>) and table L<sub>i,2</sub><sup>(r) </sup>is used to XOR the second nibble of &#x3b1;<sub>i,1</sub><sup>(r)</sup>(x) with the second nibble of &#x3b1;<sub>i,1</sub><sup>(r)</sup>(k<sub>i</sub><sup>(r&#x2212;1)</sup>&#x2296;{circumflex over (k)}<sub>i</sub><sup>(r&#x2212;1)</sup>). Hence, these lookup tables compute &#x3b1;<sub>i,1</sub><sup>(r)</sup>(x&#x2296;k<sub>i</sub><sup>(r&#x2212;1)</sup>&#x2296;{circumflex over (k)}<sub>i</sub><sup>(r&#x2212;1)</sup>) from &#x3b1;<sub>i,1</sub><sup>(r)</sup>(x). If we precede each lookup table U<sub>i,k</sub><sub><sub2>i</sub2></sub><sup><sub2>(r&#x2212;2)</sub2></sup><sup>(r)</sup>(x)=&#x3b1;<sub>i,2</sub><sup>(r)</sup>&#x2218;T<sub>i,k</sub><sub><sub2>i</sub2></sub><sup><sub2>(r&#x2212;2)</sub2></sup><sup>(r)</sup>&#x2218;(&#x3b1;<sub>i,1</sub><sup>(r)</sup>)<sup>&#x2212;1 </sup>in I<sub>K </sub>by lookup tables L<sub>i,1</sub><sup>(r) </sup>and L<sub>i,2</sub><sup>(r)</sup>, then it is verified that AES key {circumflex over (K)} is implemented instead of AES key K. If we consider the input notation (x, y) used above, then y is given by all the bytes &#x3b1;<sub>i,1</sub><sup>(r)</sup>(k<sub>i</sub><sup>(r&#x2212;1)</sup>&#x2295;{circumflex over (k)}<sub>i</sub><sup>(r&#x2212;1)</sup>).</p>
<p id="p-0137" num="0144"><figref idref="DRAWINGS">FIG. 12</figref> illustrates an embodiment of the invention. The Figure shows a communication port <b>895</b> such as a connection to the Internet for connecting with a provider of digital content. The content can also be obtained from medium <b>896</b> such as a DVD or CD. Digital content on the PC is typically rendered using media players being executed by processor <b>892</b> using memory <b>891</b>. Such players can execute, for a specific content format, a respective plug-in for performing the format-specific decoding corresponding to content obtained via communication port <b>895</b> and/or medium <b>896</b>. Those content formats may include AVI, DV, Motion JPEG, MPEG-1, MPEG-2, MPEG-4, WMV, Audio CD, MP3, WMA, WAV, AIFF/AIFC, AU, etc. For digital rights management purposes, a secure plug-in may be used that not only decodes the content but also decrypts the content. This plug-in comprises processor instructions and parameters stored in memory <b>891</b>. Processor instructions may cause the process to perform a method according to the invention. The parameters comprise look-up tables and/or look-up tables as set forth herein. A user input <b>894</b> may be provided to obtain commands from a user to indicate content to be rendered, and display <b>893</b> and/or speakers are provided for rendering the decoded and/or decrypted content.</p>
<p id="p-0138" num="0145">It will be appreciated that the invention also extends to computer programs, particularly computer programs on or in a carrier, adapted for putting the invention into practice. The program may be in the form of source code, object code, a code intermediate source and object code such as partially compiled form, or in any other form suitable for use in the implementation of the method according to the invention. The carrier may be any entity or device capable of carrying the program. For example, the carrier may include a storage medium, such as a ROM, for example, a CD ROM or a semiconductor ROM, or a magnetic recording medium, for example, a floppy disc or hard disk. Further the carrier may be a transmissible carrier such as an electrical or optical signal, which may be conveyed via electrical or optical cable or by radio or other means. When the program is embodied in such a signal, the carrier may be constituted by such cable or other device or means. Alternatively, the carrier may be an integrated circuit in which the program is embedded, the integrated circuit being adapted for performing, or for use in the performance of, the relevant method.</p>
<p id="p-0139" num="0146">It should be noted that the above-mentioned embodiments illustrate rather than limit the invention, and that those skilled in the art will be able to design many alternative embodiments without departing from the scope of the appended claims. In the claims, any reference signs placed between parentheses shall not be construed as limiting the claim. Use of the verb &#x201c;comprise&#x201d; and its conjugations does not exclude the presence of elements or steps other than those stated in a claim. The article &#x201c;a&#x201d; or &#x201c;an&#x201d; preceding an element does not exclude the presence of a plurality of such elements. The invention may be implemented by means of hardware comprising several distinct elements, and by means of a suitably programmed computer. In the device claim enumerating several means, several of these means may be embodied by one and the same item of hardware. The mere fact that certain measures are recited in mutually different dependent claims does not indicate that a combination of these measures cannot be used to advantage.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>The invention claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A white-box cryptographic system for performing a keyed cryptographic operation mapping an input-message to an output-message, the system comprising:
<claim-text>a network of a plurality of look-up tables arranged for collectively performing the cryptographic operation, the network being adapted for a particular cryptographic key,</claim-text>
<claim-text>wherein,</claim-text>
<claim-text>the system is configured to:
<claim-text>receive a key substitute which represents to the network a further cryptographic key, and</claim-text>
<claim-text>parse the key substitute into a plurality of second key substitutes,</claim-text>
</claim-text>
<claim-text>the system comprises at least one key translation unit configured for receiving a first input depending on an intermediate cryptographic result in the network and a second input depending on one of the second key substitutes,</claim-text>
<claim-text>the system is arranged for mapping the input-message to the output-message via the network and the key translation unit to arrange the effect of the network on the cryptographic operation to being adapted for the further cryptographic key.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. A white-box cryptographic system as in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein at least one specific look-up table of the plurality of look-up tables is adapted for the particular cryptographic key, the system is arranged for mapping the input-message to the output-message via at least the specific look-up table and the key translation unit to arrange the effect of the specific look-up table on the cryptographic operation to being adapted for the further cryptographic key.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. A white-box cryptographic system as in <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the first input depends on the input message by means of one or more of the plurality of look-up tables and wherein the system is arranged for the specific look-up table to receive as an input depending on an output of the key translation unit.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. A white-box cryptographic system as in <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the key translation unit is configured with an output-encoding, and wherein the specific look-up table is configured with an input encoding corresponding to the output encoding.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. A white-box cryptographic system as in <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the system is configured for the first input to depend on an output data of the specific look-up table.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. A white-box cryptographic system as in <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the specific look-up table is configured with an output-encoding, and wherein the key translation unit is configured with an input encoding corresponding to the output encoding of the specific look-up table.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. A white-box cryptographic system as in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the key substitute comprises a difference between the further cryptographic key and the particular cryptographic key.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. A cryptographic system as in <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the key translation unit is configured for adding the second input to the first input.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. A cryptographic system as in <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the specific look-up table comprises a cryptographic key addition operation of a sub-key depending on the particular key.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. A cryptographic system as in <claim-ref idref="CLM-00009">claim 9</claim-ref> wherein the cryptographic sub-key addition operation and the addition in the key translation unit of the second input to the first input are arranged to compose into a cryptographic key addition operation of a further sub-key depending on the further cryptographic key.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. A cryptographic system as in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the key translation unit is arranged to receive the second input encoded with a key substitute encoding, and wherein the system is configured to receive a key substitute at least part of which is encoded with the second input encoding.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. A cryptographic method for performing a keyed cryptographic operation mapping an input-message to an output-message, the method comprising
<claim-text>performing the cryptographic operation using a network of plurality of look-up tables arranged for the cryptographic operation, the network being adapted for a particular cryptographic key, wherein the method comprises</claim-text>
<claim-text>receiving a key substitute which represents to the network a further cryptographic key,</claim-text>
<claim-text>parsing the key substitute into a plurality of second key substitute; and</claim-text>
<claim-text>providing a key translation unit with a first input depending on an intermediate cryptographic result of the network and a second input depending on one of the second key substitutes,</claim-text>
</claim-text>
<claim-text>wherein
<claim-text>performing the cryptographic operation using the network comprises mapping the input-message to the output-message via the network and the key translation unit to arrange the effect of the network on the cryptographic operation to being adapted for the further cryptographic key.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. A computer program comprising computer program code means adapted to perform all the steps of the cryptographic method of <claim-ref idref="CLM-00012">claim 12</claim-ref> when the computer program is run on a computer.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. A computer program as claimed in <claim-ref idref="CLM-00013">claim 13</claim-ref> embodied on a computer readable medium.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. A cryptographic system as in <claim-ref idref="CLM-00008">claim 8</claim-ref> wherein the cryptographic sub-key addition operation and the addition in the key translation unit of the second input to the first input are arranged to compose into a cryptographic key addition operation of a further sub-key depending on the further cryptographic key.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. A cryptographic system as in <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the specific look-up table comprises a cryptographic key addition operation of a sub-key depending on the particular key.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the system is configured for:
<claim-text>selecting one of the second key substitutes to provide the one of the second key substitutes to the key translation unit.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the system is configured for:
<claim-text>selecting one of the second key substitutes for a first look-up table of the plurality of look-up tables and selecting the other second key substitute for a second look-up table of the plurality of look-up tables.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The method according to <claim-ref idref="CLM-00012">claim 12</claim-ref>, comprising:
<claim-text>selecting one of the second key substitutes to provide the one of the second key substitutes to the key translation unit.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The method according to <claim-ref idref="CLM-00012">claim 12</claim-ref>, comprising:
<claim-text>selecting one of the second key substitutes for a first look-up table of the plurality of look-up tables, and selecting the other second key substitute for a second look-up table of the plurality of look-up tables.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
