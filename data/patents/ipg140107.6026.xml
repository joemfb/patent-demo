<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627149-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627149</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10929878</doc-number>
<date>20040830</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<us-term-extension>1970</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>11</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>714 472</main-classification>
<further-classification>714  41</further-classification>
</classification-national>
<invention-title id="d2e53">Techniques for health monitoring and control of application servers</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5805785</doc-number>
<kind>A</kind>
<name>Dias et al.</name>
<date>19980900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
<classification-national><country>US</country><main-classification>714  4</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6219719</doc-number>
<kind>B1</kind>
<name>Graf</name>
<date>20010400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
<classification-national><country>US</country><main-classification>710  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6594784</doc-number>
<kind>B1</kind>
<name>Harper et al.</name>
<date>20030700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6609213</doc-number>
<kind>B1</kind>
<name>Nguyen et al.</name>
<date>20030800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714  4</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>6629266</doc-number>
<kind>B1</kind>
<name>Harper et al.</name>
<date>20030900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
<classification-national><country>US</country><main-classification>714 38</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>6898556</doc-number>
<kind>B2</kind>
<name>Smocha et al.</name>
<date>20050500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>702186</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>6996751</doc-number>
<kind>B2</kind>
<name>Harper et al.</name>
<date>20060200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714 48</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>7100079</doc-number>
<kind>B2</kind>
<name>Gross et al.</name>
<date>20060800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714 23</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>7243265</doc-number>
<kind>B1</kind>
<name>Wookey et al.</name>
<date>20070700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714 37</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2002/0087612</doc-number>
<kind>A1</kind>
<name>Harper et al.</name>
<date>20020700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709100</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2003/0079154</doc-number>
<kind>A1</kind>
<name>Park et al.</name>
<date>20030400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2003/0212928</doc-number>
<kind>A1</kind>
<name>Srivastava et al.</name>
<date>20031100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714 47</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>JP</country>
<doc-number>2002252614</doc-number>
<kind>A</kind>
<date>20020900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00014">
<othercit>Huang, Y., et al., &#x201c;Software rejuvenation: analysis, module and applications&#x201d; Twenty-fifth International Symposium on Fault-tolerant Computing, Digest of Papers 27-30, Pasadena, CA, USA, pp. 381-390 (Jun. 1995).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00015">
<othercit>Brewer E.A., &#x201c;Lessons from Giant-Scale Services,&#x201d; IEEE Internet Computing, pp. 46-55 (2001).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00016">
<othercit>Gamache et al., &#x201c;Windows NT Clustering Service,&#x201d; IEEE Computer, pp. 55-62 (Oct. 1998).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00017">
<othercit>Garg et al., &#x201c;On the Analysis of Software Rejuvenation Policies,&#x201d; IEEE, pp. 88-96 (1997).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00018">
<othercit>Huang et al., &#x201c;Software Rejuvenation: Analysis, Module and Applications,&#x201d; IEEE Twenty-Fifth International Symposium on Fault-Tolerant Computing, pp. 381-390 (1995).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>21</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>7</number-of-drawing-sheets>
<number-of-figures>12</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20060048017</doc-number>
<kind>A1</kind>
<date>20060302</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Anerousis</last-name>
<first-name>Nikolaos</first-name>
<address>
<city>Chappaqua</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Black-Ziegelbein</last-name>
<first-name>Elizabeth Ann</first-name>
<address>
<city>Austin</city>
<state>TX</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Hanson</last-name>
<first-name>Susan Maureen</first-name>
<address>
<city>Cary</city>
<state>NC</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="004" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Mummert</last-name>
<first-name>Lily Barkovic</first-name>
<address>
<city>Mahopac</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="005" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Pacifici</last-name>
<first-name>Giovanni</first-name>
<address>
<city>New York</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Anerousis</last-name>
<first-name>Nikolaos</first-name>
<address>
<city>Chappaqua</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Black-Ziegelbein</last-name>
<first-name>Elizabeth Ann</first-name>
<address>
<city>Austin</city>
<state>TX</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Hanson</last-name>
<first-name>Susan Maureen</first-name>
<address>
<city>Cary</city>
<state>NC</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="004" designation="us-only">
<addressbook>
<last-name>Mummert</last-name>
<first-name>Lily Barkovic</first-name>
<address>
<city>Mahopac</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="005" designation="us-only">
<addressbook>
<last-name>Pacifici</last-name>
<first-name>Giovanni</first-name>
<address>
<city>New York</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Ryan, Mason &#x26; Lewis, LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Maskulinski</last-name>
<first-name>Michael</first-name>
<department>2113</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Techniques for improving application server performance and availability are provided. In one aspect, a method of monitoring the health of one or more application servers comprises the following steps. One or more health classes are specified, each of the one or more health classes defining one or more health policies for the one or more application servers. At least one of the one or more health policies is monitored. Violations, if any, of the one or more health policies are detected.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="128.10mm" wi="145.03mm" file="US08627149-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="237.66mm" wi="165.69mm" file="US08627149-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="185.17mm" wi="117.86mm" file="US08627149-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="247.90mm" wi="113.79mm" file="US08627149-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="207.94mm" wi="130.89mm" file="US08627149-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="223.60mm" wi="143.93mm" file="US08627149-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="240.20mm" wi="123.78mm" file="US08627149-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="105.58mm" wi="137.75mm" file="US08627149-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">FIELD OF THE INVENTION</heading>
<p id="p-0002" num="0001">The present invention relates to improved application server performance and availability and, more particularly, to techniques for monitoring the health of application servers.</p>
<heading id="h-0002" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0003" num="0002">Application server environments are prone to a variety of problems, e.g., malfunctions, caused by the inefficient design of hosted applications. Typical problems include memory leaks, deadlocks, inconsistent state and user errors. These deficiencies have an adverse effect on the near-term performance and/or availability of the application. In most cases, these conditions can be detected through appropriate instrumentation by a human administrator, who in turn decides on the best course of action to correct the problem.</p>
<p id="p-0004" num="0003">Each condition requires a particular corrective action that ranges from non-intrusive software reconfiguration to more drastic techniques, such as restarting the application server and its hosted applications. The latter is also known as &#x201c;software rejuvenation,&#x201d; and is commonly used to remedy many software problems, including, memory leaks and deadlocks. See, for example, Y. Huang, et al., <i>Software Rejuvenation: Analysis, Module and Applications</i>, IEEE Twenty-Fifth International Symposium on Fault-Tolerant Computing, 381-390 (1995), the disclosure of which is incorporated herein by reference. A system can selectively rejuvenate software based on measurements that indicate an impending outage. See, for example, U.S. Pat. No. 6,629,266 issued to R. E. Harper et al., entitled &#x201c;Method and System for Transparent Symptom-Based Selective Software Rejuvenation,&#x201d; the disclosure of which is incorporated herein by reference. If the system is part of a cluster, the system may determine whether another cluster member can accept the workload serviced by the application requiring rejuvenation. If so, the system can interact with a cluster manager to start an instance of the application on another node.</p>
<p id="p-0005" num="0004">In cluster systems, such as the Windows NT&#xae; cluster system, failure detection is provided for applications running unmodified on a cluster. See, for example, R. Gamache et al., <i>Windows NT Clustering Service</i>, IEEE COMPUTER, 55-62 (October 1998), the disclosure of which is incorporated herein by reference. An application-specific cluster interface layer, through which an application can be started, stopped and monitored for failures, may also be provided. For example, a monitor may include application requests that serve as probes to determine if the application is operating correctly.</p>
<p id="p-0006" num="0005">An extensible infrastructure for detecting and recovering from failures in a cluster system is described, for example, in U.S. Pat. No. 5,805,785 issued to D. Dias et al., entitled &#x201c;Method for Monitoring and Recovery of Subsystems in a Distributed/Clustered System,&#x201d; the disclosure of which is incorporated herein by reference. Basic failure detection using heartbeating (e.g., noting nodes that have gone down or come up on a particular network) is augmented by user-defined monitors to detect failures in specific subsystems, and user-defined recovery programs to recover from the failures detected. A &#x201c;rolling upgrade&#x201d; in which upgrades in a cluster are performed in a wave so that only one node is unavailable at a time is described, for example, in E. A. Brewer et al., <i>Lessons from Giant</i>-<i>Scale Services</i>, IEEE INTERNET COMPUTING, 46-55 (July/August 2001), the disclosure of which is incorporated herein by reference.</p>
<p id="p-0007" num="0006">Despite the recent progress in application server failure detection and rejuvenation, there exists a need for improved techniques for efficiently and effectively monitoring application server environments and addressing errors occurring therein.</p>
<heading id="h-0003" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0008" num="0007">The present invention provides techniques for improving application server performance and availability. In one aspect of the invention, a method of monitoring the health of one or more application servers comprises the following steps. One or more health classes are specified, each of the one or more health classes defining one or more health policies for the one or more application servers. At least one of the one or more health policies is monitored. Violations, if any, of the one or more health policies are detected.</p>
<p id="p-0009" num="0008">A more complete understanding of the present invention, as well as further features and advantages of the present invention, will be obtained by reference to the following detailed description and drawings.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. 1</figref> is a diagram illustrating an exemplary system for monitoring the health of an application server according to an embodiment of the present invention;</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 2</figref> is a diagram illustrating an exemplary application server environment according to an embodiment of the present invention;</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 3</figref> is a diagram illustrating an exemplary computer system comprising application servers and clusters according to an embodiment of the present invention;</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 4</figref> is a diagram illustrating an exemplary system for defining a health policy according to an embodiment of the present invention;</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 5</figref> is a diagram illustrating an exemplary health class according to an embodiment of the present invention;</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 6</figref> is a diagram illustrating an exemplary detection only reaction according to an embodiment of the present invention;</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 7</figref> is a diagram illustrating an exemplary supervised reaction according to an embodiment of the present invention;</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 8</figref> is a diagram illustrating an exemplary automatic reaction according to an embodiment of the present invention;</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 9</figref> is a diagram illustrating an exemplary health subsystem configuration according to an embodiment of the present invention;</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 10</figref> is a diagram illustrating an exemplary health subsystem runtime operation according to an embodiment of the present invention;</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 11</figref> is a diagram illustrating an exemplary health sensor operation according to an embodiment of the present invention; and</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 12</figref> is a diagram illustrating an exemplary system for monitoring the health of one or more application servers according to an embodiment of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS</heading>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 1</figref> is a diagram illustrating an exemplary system <b>100</b> for monitoring the health of an application server. The term &#x201c;health,&#x201d; as used herein denotes the overall well-being and performance of the system and is defined by one or more health classes that are applied to servers of the system. System <b>100</b> comprises manager <b>102</b>, policy database <b>104</b>, health controller <b>106</b>, reaction manager <b>108</b>, health sensors <b>110</b>, user applications <b>112</b>, <b>114</b> and <b>116</b> and system management agent <b>118</b>. Health sensors <b>110</b>, user applications <b>112</b>, <b>114</b> and <b>116</b> and system management agent <b>118</b> comprise an application server of system <b>100</b>. In an exemplary embodiment, system <b>100</b> comprises one or more application servers, each of which host J2EE applications.</p>
<p id="p-0023" num="0022">According to an exemplary embodiment of the present invention, system <b>100</b> is configured to implement a methodology for monitoring the health of an application server, which may include detecting and/or reacting to specific health problems. Namely, in step <b>1</b>, manager <b>102</b> initially specifies a health class. As will be described in detail below, a given health class can define one or more health monitoring policies for the application server, using a rule-based description. In step <b>2</b>, the configuration of the specified health class is stored, e.g., in policy database <b>104</b>.</p>
<p id="p-0024" num="0023">In step <b>3</b>, optional health sensors are configured to monitor the health of an application server. Namely, the health policies specify what attributes of the operating environment will be monitored, the particular boundary health conditions that will trigger a policy violation, e.g., health exception, and/or the operations that are to be performed to correct the condition that triggered the violation. Therefore, in step <b>4</b>, the health policies are monitored. Monitoring the health policies involves first reading the health policies, e.g., from policy database <b>104</b>, as in step <b>5</b><i>a</i>, and then, if a violation of a health policy is detected, initiate a corrective action, as in step <b>5</b><i>b</i>. An exemplary corrective action may include, but is not limited to, executing a restart of the application server, as in step <b>6</b>.</p>
<p id="p-0025" num="0024">A condition that will trigger a health exception (a triggering condition), e.g., a health policy violation, for example, may be a generalized attribute-value assertion on data observed from health sensors <b>110</b>, e.g., sensor data. Namely, the triggering condition can be a simple equality clause, or, alternatively, a complex processing operation on multiple pieces of sensor data (for example, in an exemplary embodiment an error condition is detected when about ten percent threshold crossings are observed over about a 60 minute period). Processing sensor data, e.g., against policy database <b>104</b>, may include, but is not limited to, applying statistical functions, applying assertions on the ordering (partial or total) of system events and scoping (including or excluding parts of the system under observation).</p>
<p id="p-0026" num="0025">The health policy for a particular system is expressed in a policy specification language, and is then passed to a health controller, e.g., health controller <b>106</b>. Health controller <b>106</b> is responsible for implementing that health policy during normal operation of the system. Health controller <b>106</b> stores the health policy in policy database <b>104</b> (a local repository) and configures the appropriate health sensors <b>110</b> within the managed system to obtain the relevant system data. The identification of what health sensors <b>110</b> to configure, and with what parameters, can be expressed in the health policy itself, or alternatively, can be derived automatically from the health policy specification after a compilation process.</p>
<p id="p-0027" num="0026">During system operation, health controller <b>106</b> periodically collects data from health sensors <b>110</b>, performs the required aggregations and statistical processing of the data and verifies the data against the stored health policies, e.g., in policy database <b>104</b>. If a health violation is detected, a reaction to the violation may be issued. The reaction will reconfigure and tune the system <b>100</b> in such a way, e.g., that service is maintained.</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 2</figref> is a diagram illustrating an exemplary application server environment <b>200</b>. Application server environment <b>200</b> comprises nodes <b>202</b>, <b>204</b> and <b>206</b> connected via network interconnect <b>208</b>. According to an exemplary embodiment of the present invention, each of nodes <b>202</b>, <b>204</b> and <b>206</b> contains a copy of the application server software according to the type of function that the node performs.</p>
<p id="p-0029" num="0028">Application server environment <b>200</b> comprises the following exemplary types of nodes. Node <b>202</b> comprises an administrative node responsible for performing management functionality for the rest of the application server environment. Nodes <b>204</b> and <b>206</b> comprise application server nodes. According to the teachings presented herein, application server environment <b>200</b> comprises a plurality of application server nodes. Each application server node can host one or more application server instances. In turn, each application server instance can host zero or more enterprise application modules (also referred to herein as &#x201c;applications&#x201d;).</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 3</figref> is a diagram illustrating exemplary computer system <b>300</b> comprising application servers and clusters. Namely, computer system <b>300</b> comprises application server nodes <b>302</b> and <b>304</b>. Application server node <b>302</b> hosts application server instances <b>306</b> and <b>308</b>. Application server instance <b>306</b> hosts applications <b>312</b> and <b>314</b>. Application server instance <b>308</b> hosts applications <b>316</b> and <b>318</b>. Application server node <b>304</b> hosts application server instance <b>310</b>. Application server instance <b>310</b> hosts applications <b>320</b> and <b>322</b>. Application server instances <b>308</b> and <b>310</b> form cluster <b>324</b>.</p>
<p id="p-0031" num="0030">The environment of computer system <b>300</b> allows the following groupings of application server instances. &#x201c;Singleton&#x201d; application server instances, e.g., application server instance <b>306</b>, run independently of other application server instances and contain a single copy of an application. &#x201c;Clustered&#x201d; application server instances (&#x201c;clusters&#x201d;), e.g., application server instances <b>308</b> and <b>310</b>, run multiple copies of an application server instance on one or more nodes. Clusters can be further distinguished into static clusters and dynamic clusters. Specifically, the number of running application server instances in a dynamic cluster is determined at runtime and is based on an observed demand for an application, whereas with static clusters the number of servers is set at configuration.</p>
<p id="p-0032" num="0031">The health controller, e.g., health controller <b>106</b>, as described in conjunction with the description of <figref idref="DRAWINGS">FIG. 1</figref> above, is responsible for monitoring the health status of application server instances. There are two aspects of a health controller operation, namely, a configuration phase and a runtime phase. In the configuration phase, a health policy is defined. <figref idref="DRAWINGS">FIG. 4</figref> is a diagram illustrating an exemplary system <b>400</b> for defining a health policy.</p>
<p id="p-0033" num="0032">Namely, as shown in <figref idref="DRAWINGS">FIG. 4</figref>, administrator <b>402</b>, using administrator console <b>404</b>, defines a number of health classes <b>406</b>. Each health class <b>406</b> contains a set of targets (e.g., members of one or more health classes) and a health policy to be applied to the targets. The targets and the health policies can be modified dynamically. The health policy includes one or more health conditions to be monitored, the corrective action to be taken and the reaction mode. This information becomes part of policy database <b>104</b> and is stored into health controller <b>106</b>, which in turn monitors the respective health classes.</p>
<p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. 5</figref> is a diagram illustrating an exemplary health class. Namely, health class <b>406</b> is shown to contain targets <b>502</b>, <b>504</b> and <b>506</b> and health policies <b>508</b>, <b>510</b> and <b>512</b>, e.g., representing a health condition, a reaction mode and a reaction, respectively. The target of a health class, e.g., targets <b>502</b>, <b>504</b> and <b>506</b>, can include one or more individual application servers (S), clusters or dynamic clusters (DC). When a cluster or dynamic cluster is specified as a target, the health class automatically applies to all application servers that are members of that cluster or dynamic cluster, including application servers added to that cluster or dynamic cluster after the health class is created. The target of a health class can include all the nodes in the administrative domain. In the instance wherein the target of a health class includes all the nodes in the administrative domain, the health class would only have a single target and the health class would automatically apply to any application servers added after creation of the health class.</p>
<p id="p-0035" num="0034">A health condition is an erroneous state in hardware and/or software that indicates a present or anticipated malfunction. Examples of health conditions include, but are not limited to, very high memory usage or high percentages of requests encountering internal server errors. In conventional systems, during the course of operation of application server environments, the operator would monitor the system for such conditions, and when detected take corrective action. The present techniques provide a fully automated way of reacting to such problems.</p>
<p id="p-0036" num="0035">According to an exemplary embodiment of the present invention, one or more of the following health conditions are monitored, which include, but are not limited to, the age of an application server (e.g., the time since startup), the work performed (e.g., the number of served requests), a memory usage pattern indicating an impending resource problem and unusually long response times of requests indicating internal server errors (such as deadlocks).</p>
<p id="p-0037" num="0036">A health class monitors exactly one health condition, e.g., health condition <b>508</b>, the health condition itself being tied to one or more low-level health parameters, including, but not limited to, memory heap size and request response time. For detection purposes, the health class specifies the desired boundaries for these low-level health parameters. The low-level health parameters are evaluated periodically and, if a violation is detected, the health condition is triggered. The health controller then takes the corrective action specified by the health class.</p>
<p id="p-0038" num="0037">The reaction mode, e.g., reaction mode <b>510</b>, defines how the system reacts in the presence of a detected health condition, e.g., health condition <b>508</b>. In this exemplary embodiment, the reaction mode is used to execute the corrective action in one of three possible ways: (1) detection only, wherein a diagnostic message is produced upon detection of the condition, (2) supervised reaction, wherein a message is sent to the administrator with a suggestion of a corrective action or (3) automatic reaction, wherein a reaction to the condition is scheduled for execution immediately.</p>
<p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. 6</figref> is a diagram illustrating an exemplary detection only reaction. In the detection only reaction <b>600</b> shown in <figref idref="DRAWINGS">FIG. 6</figref>, one or more health conditions <b>602</b> are detected, collected by health controller <b>106</b> and then a log entry <b>604</b> is made.</p>
<p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. 7</figref> is a diagram illustrating an exemplary supervised reaction. In the supervised reaction <b>700</b> shown in <figref idref="DRAWINGS">FIG. 7</figref>, one or more health conditions <b>602</b> are detected and then collected by health controller <b>106</b> which submits a request to an activity engine, e.g., activity engine <b>702</b>. Activity engine <b>702</b> is a component which receives actionable messages from within the application server environment that require the attention of a human administrator and provides the option of acknowledging the reception and/or approving corrective action(s). Activity engine <b>702</b> then makes a request <b>704</b> for confirmation of a reaction, e.g., request user to approve corrective action. If the reaction is confirmed, then execution of the reaction <b>706</b> is conducted. Alternatively, if the reaction is not confirmed, then a log entry <b>604</b>, as in the detection only reaction, above, is made.</p>
<p id="p-0041" num="0040">According to the exemplary embodiment shown in <figref idref="DRAWINGS">FIG. 7</figref>, reactions are limited to restarting the application server on which the erroneous condition was observed. This process is also known as software rejuvenation. The system architecture however, is not limited solely to rejuvenation actions, but can be used to signal any kind of automatic or supervised corrective action.</p>
<p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. 8</figref> is a diagram illustrating an exemplary automatic reaction. In the automatic reaction <b>800</b> shown in <figref idref="DRAWINGS">FIG. 8</figref>, one or more health conditions <b>602</b> are detected and then collected by health controller <b>106</b>, as in the detection only and the supervised reactions, described above. An automatic reaction <b>802</b> is then initiated.</p>
<p id="p-0043" num="0042">Regarding the runtime phase of a health controller operation, the health controller, e.g., health controller <b>106</b> of <figref idref="DRAWINGS">FIG. 4</figref>, described above, reads each defined health class, e.g., health class <b>406</b> of <figref idref="DRAWINGS">FIG. 5</figref>, described above, and configures a health subsystem for every target, e.g., targets <b>502</b>, <b>504</b> and <b>506</b> of <figref idref="DRAWINGS">FIG. 5</figref>, above, of the health class. The health subsystem is a high-level construct responsible for monitoring the health condition specified in the health class.</p>
<p id="p-0044" num="0043">The health subsystem hides the low-level details of health data collection by presenting a simple application program interface (API) to the health controller to determine if the health condition has been violated for the health class. In turn, the health subsystem configures one or more low-level sensors to obtain the necessary health data.</p>
<p id="p-0045" num="0044"><figref idref="DRAWINGS">FIG. 9</figref> is a diagram illustrating an exemplary health subsystem configuration. In <figref idref="DRAWINGS">FIG. 9</figref>, health subsystem <b>900</b> is configured to implement health class A <b>902</b> and health class B <b>904</b>.</p>
<p id="p-0046" num="0045">For the targets of health class A <b>902</b>, health controller <b>106</b> instantiates age subsystem <b>906</b>, which in turn configures age sensor <b>910</b> with the desired boundary (e.g., the maximum allowed age). Similarly, every target of health class B <b>904</b> requires the configuration of memory subsystem <b>908</b> to detect erroneous memory usage patterns. Memory subsystem <b>908</b> in turn initializes memory heap size sensor <b>912</b>, heap growth rate sensor <b>914</b> and memory leak sensor <b>916</b>. The sensors continuously compute these quantities, e.g., memory heap size, heap growth rate and memory leak, using instrumentation available through the operating system or the application server environment. If the configured boundary conditions for any one of sensors <b>912</b>, <b>914</b> or <b>916</b> are violated, memory subsystem <b>908</b> will raise a flag, which will subsequently trigger the reaction specified in the health class (e.g., an application server restart).</p>
<p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. 10</figref> is a diagram illustrating exemplary health subsystem runtime operation <b>1000</b>. Specifically, health subsystem <b>1002</b> periodically checks the health sensors, e.g., sensors <b>1004</b> and <b>1006</b>, for violations of boundary health conditions. For conditions involving single sensors, the subsystem can check for a violation by performing an assertion on the triggered condition (is Triggered) on its health sensors. For conditions involving multiple sensors, the subsystem may require a multitude of health sensors to be in the triggered state for a violation to occur, or it may poll sensors for data to determine if the condition is violated.</p>
<p id="p-0048" num="0047">Once configured, each health sensor operates independently, and periodically collects health-related data from the target using communication mechanisms specific to application server environment <b>1008</b>. The health-related data obtained is checked with respect to the boundary parameters specified in the health class.</p>
<p id="p-0049" num="0048">Exemplary health sensor boundary health conditions include, but are not limited to, maximum allowed server age (e.g., up to about 48 hours), maximum work performed (e.g., up to about 100,000 requests), maximum heap size (e.g., up to about 200 megabytes) and maximum response time allowed (e.g., up to about five seconds for about 95 percent of incoming requests).</p>
<p id="p-0050" num="0049"><figref idref="DRAWINGS">FIG. 11</figref> is a diagram illustrating an exemplary health sensor operation. In <figref idref="DRAWINGS">FIG. 11</figref>, boundary health conditions <b>1104</b> are checked by health sensors <b>1102</b>. If a violation of a boundary health condition is detected, a flag (trigger) <b>1106</b> is raised within the sensor and low-level health data <b>1108</b> is collected. Alternatively, if no violation of a boundary health condition is detected, then only low-level health data <b>1108</b> is collected.</p>
<p id="p-0051" num="0050">The health controller periodically polls its subsystems, which in turn check the sensors. If the subsystem for a server is determined to be unhealthy, the health monitor initiates a reaction. This process is performed for all configured subsystems and sensors.</p>
<p id="p-0052" num="0051">Of particular importance are the runtime characteristics of the health controller. In a live application server environment, configurations may constantly change. For example, nodes may be added and/or removed, application server instances may be installed and/or removed from nodes and cluster membership may change.</p>
<p id="p-0053" num="0052">A component within the health controller, e.g., a topology manager, can be employed to observe the application server environment by &#x2018;listening&#x2019; to configuration events from selected components and reacting appropriately. For example, when a new health class is created, the health controller creates a number of subsystems and sensors to obtain data from the class targets. When a health class is deleted, the corresponding health subsystems are destroyed by the health controller and observation of the health parameters from the corresponding targets stops. When a new target is added to a health class, the appropriate health subsystem is configured for that server and added to the list of health subsystems under observation. When a target is removed from a health class, the corresponding health subsystem is destroyed. When the membership of a target changes (e.g., as is applicable to cluster systems), the appropriate health subsystems are added and/or removed.</p>
<p id="p-0054" num="0053">Because a target of a health class can be a server or a group of servers, it is possible to create multiple health classes on a server at different levels that monitor the same health conditions. For example, one can create a health class A that monitors the age of a cluster, with an instruction to restart if the age exceeds some value Y. Another class B may be created that monitors the age of a server that is a member of the cluster in health class A, with an instruction to restart if the age exceeds some other value X. In this case, the health classes conflict. The health controller detects such conflicts and uses a precedence rule to determine which health class to apply. According to the teachings herein, a conflict occurs when multiple health classes with the same condition type (e.g., age or work), corrective action and reaction mode are defined for a given server.</p>
<p id="p-0055" num="0054">When a conflict occurs, the health controller applies the health class with the narrowest scope. In an exemplary embodiment, a single server is the narrowest scope, followed by a cluster and then an administrative domain. Additionally, users are prevented from defining classes that conflict at the same scope. For example, a non-conflicting set of conditions according to this definition would be an administrative domain health class that sends a notification on violation of a memory condition, and a cluster health class that automatically restarts servers on violation of a memory condition. If both of these health classes had automatic restarts as the reaction, they would conflict, and the cluster health class would apply to servers in the cluster.</p>
<p id="p-0056" num="0055">The health controller operates according to a set of configuration parameters that govern its runtime behavior. These configuration parameters include, but are not limited to, length of the control cycle (e.g., the time period between successive polling of the health subsystems), restart timeout (e.g., the maximum time allowed for a restart to occur; if the timeout is exceeded the restart is deemed as failed and the health controller retries the operation), maximum number of server restarts (e.g., the maximum number of unsuccessful tries to restart a server, after which, an error is logged), minimum restart interval (e.g., the minimum time between consecutive attempts to restart a server, which prevents unnecessary frequent restarts) and constraining restart times (e.g., a list of time periods during which a restart is prohibited, such as, during peak business hours).</p>
<p id="p-0057" num="0056">The restart timeout, maximum number of server restarts, minimum restart interval and prohibited restart times parameters control the behavior of the server restart reaction. However, in cluster server applications, at least one running instance is preferably always preserved, and in dynamic cluster applications, a user-specified minimum number of instances is preferably always preserved.</p>
<p id="p-0058" num="0057"><figref idref="DRAWINGS">FIG. 12</figref> is a diagram illustrating an exemplary system for monitoring the health of one or more application servers. Apparatus <b>1220</b> comprises a computer system <b>1221</b> that interacts with media <b>1227</b>. Computer system <b>1221</b> comprises a processor <b>1222</b>, a network interface <b>1225</b>, a memory <b>1223</b>, a media interface <b>1226</b> and an optional display <b>1224</b>. Network interface <b>1225</b> allows computer system <b>1221</b> to connect to a network, while media interface <b>1226</b> allows computer system <b>1221</b> to interact with media <b>1227</b>, such as a Digital Versatile Disk (DVD) or a hard drive.</p>
<p id="p-0059" num="0058">As is known in the art, the methods and apparatus discussed herein may be distributed as an article of manufacture that itself comprises a computer-readable medium having computer-readable code means embodied thereon. The computer-readable program code means is operable, in conjunction with a computer system such as computer system <b>1221</b>, to carry out all or some of the steps to perform one or more of the methods or create the apparatus discussed herein. For example, the computer-readable code is configured to implement a method of monitoring the health of one or more application servers by the steps of: monitoring at least one of one or more health policies for the one or more application servers, the one or more health policies being defined by one or more specified health classes; and detecting violations, if any, of the one or more health policies. The computer-readable medium may be a recordable medium (e.g., floppy disks, hard drive, optical disks such as a DVD, or memory cards) or may be a transmission medium (e.g., a network comprising fiber-optics, the world-wide web, cables, or a wireless channel using time-division multiple access, code-division multiple access, or other radio-frequency channel). Any medium known or developed that can store information suitable for use with a computer system may be used. The computer-readable code means is any mechanism for allowing a computer to read instructions and data, such as magnetic variations on a magnetic medium or height variations on the surface of a compact disk.</p>
<p id="p-0060" num="0059">Memory <b>1223</b> configures the processor <b>1222</b> to implement the methods, steps, and functions disclosed herein. The memory <b>1223</b> could be distributed or local and the processor <b>1222</b> could be distributed or singular. The memory <b>1223</b> could be implemented as an electrical, magnetic or optical memory, or any combination of these or other types of storage devices. Moreover, the term &#x201c;memory&#x201d; should be construed broadly enough to encompass any information able to be read from or written to an address in the addressable space accessed by processor <b>1222</b>. With this definition, information on a network, accessible through network interface <b>1225</b>, is still within memory <b>1223</b> because the processor <b>1222</b> can retrieve the information from the network. It should be noted that each distributed processor that makes up processor <b>1222</b> generally contains its own addressable memory space. It should also be noted that some or all of computer system <b>1221</b> can be incorporated into an application-specific or general-use integrated circuit.</p>
<p id="p-0061" num="0060">Optional video display <b>1224</b> is any type of video display suitable for interacting with a human user of apparatus <b>1220</b>. Generally, video display <b>1224</b> is a computer monitor or other similar video display.</p>
<p id="p-0062" num="0061">Although illustrative embodiments of the present invention have been described herein, it is to be understood that the invention is not limited to those precise embodiments, and that various other changes and modifications may be made by one skilled in the art without departing from the scope or spirit of the invention.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method of monitoring the health of one or more application servers, the method comprising the steps of:
<claim-text>specifying one or more health classes, each of the one or more health classes defining one or more health policies for the one or more application servers, wherein each health policy comprises one or more health conditions to he monitored, a boundary health condition that will trigger a policy violation, a corrective action to be taken and a reaction mode;</claim-text>
<claim-text>configuring multiple health sensors, wherein each of the multiple health sensors is configured to correspond to a single respective health condition from a collection of health conditions including at least maximum allowed server age, maximum work performed, maximum heap size and maximum response time allowed, and wherein each of the multiple health sensors operates independently to collect data;</claim-text>
<claim-text>defining one or more targets of the one or more health classes;</claim-text>
<claim-text>applying the one or more health policies to the one or more targets;</claim-text>
<claim-text>monitoring at least one of the one or more health policies that have been applied to the one or more targets, wherein monitoring comprises using the multiple configured health sensors to collect data pertaining to each of the multiple respective health conditions; and</claim-text>
<claim-text>detecting violations, if any, of the one or more health policies, wherein detecting violations comprises verifying the data collected against the boundary health condition.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising the step of storing configurations of the health classes.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising the step of taking corrective action based on the violations detected.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the step of taking corrective action based on the violations detected further comprises rejuvenation of at least one of the one or more application servers.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising the step of taking automatic corrective action based on the violation detected.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising the step of requesting user approval to take corrective action based on the violation detected.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the step of monitoring at least one of the one or more health policies comprises monitoring one or more predetermined attributes of the one or more application servers.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the step of detecting violations comprises detecting violations based on one or more health conditions.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the step of detecting violations comprises detecting violations based on one or more health conditions selected from the group comprising of age of an application server, work performed, memory usage patterns and unusually long response times of request.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising the step of implementing the one or more health policies on a computer system.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the step of implementing the one or more health policies on a computer system comprises use of a health controller.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the step of monitoring at least one of the one or more health policies comprises use of one or more health sensors automatically configured to monitor the one or more health policies.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the step of detecting violations further comprises the step of producing a diagnostic message.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising the step of employing a topology manager to monitor one or more of an addition of a health class, a deletion of a health class and a modification of a health class.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising the step of employing a topology manager to monitor one or more of an addition of a target and a deletion of a target.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising the step of employing a topology manager to monitor changes in cluster membership.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising the step of resolving conflicts between health classes by selecting the health class with the narrowest scope.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. An apparatus for monitoring the health of one or more application servers, the apparatus comprising:
<claim-text>a memory; and</claim-text>
<claim-text>at least one processor, coupled to the memory, operative to:
<claim-text>specify one or more health classes, each at the one or more health classes defining one or more health policies for the one or more application servers, wherein each health policy comprises one or more health conditions to be monitored, a boundary health condition that will trigger a policy violation, a corrective action to be taken and a reaction mode;</claim-text>
<claim-text>configure multiple health sensors, wherein each of the multiple health sensors is configured to correspond to a single respective health condition from a collection of health conditions including at least maximum allowed server age, maximum work performed, maximum heap size and maximum response time allowed, and wherein each of the multiple health sensors operates independently to collect data;</claim-text>
<claim-text>define one or more targets of the one or more health classes;</claim-text>
<claim-text>apply the one or more health policies to the one or more targets;</claim-text>
<claim-text>monitor at least one of the one or more health policies that have been applied to the one or more targets, wherein monitoring comprises using the multiple configured health sensors to collect data pertaining to each of the multiple respective health conditions; and</claim-text>
<claim-text>detect violations, if any, of the one or more health policies, wherein detecting violations comprises verifying the data collected against the boundary health condition.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The apparatus of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the at least one processor is further operative to take corrective action based on the violations detected.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. An article of manufacture for monitoring the health of one or more application servers, comprising a machine readable recordable medium containing one or more programs which when executed implement the steps of:
<claim-text>specifying one or more health classes, each of the one or more health classes defining one or more health policies for the one or more application servers, wherein each health policy comprises one or more health conditions to be monitored, a boundary health condition that wilt trigger a policy violation, a corrective action to be taken and a reaction mode;</claim-text>
<claim-text>configuring multiple health sensors, wherein each of the multiple health sensors is configured to correspond to a single respective health condition from a collection of health conditions including at least maximum allowed server age, maximum work performed, maximum heap size and maximum response time allowed, and wherein each of the multiple health sensors operates independently to collect data;</claim-text>
<claim-text>defining one or more targets of the one or more health classes;</claim-text>
<claim-text>applying the one or more health policies to the one or more targets;</claim-text>
<claim-text>monitoring at least one of the one or more health policies that have been applied to the one or more targets, wherein monitoring comprises using the multiple configured health sensors to collect data pertaining to each of the multiple respective health conditions; and</claim-text>
<claim-text>detecting violations, if any, of the one or more health policies, wherein detecting violations comprises verifying the data collected against the boundary health condition.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The article of manufacture of <claim-ref idref="CLM-00020">claim 20</claim-ref>, further comprising the step of taking corrective action based on the violations detected.</claim-text>
</claim>
</claims>
</us-patent-grant>
