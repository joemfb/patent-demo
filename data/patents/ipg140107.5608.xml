<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08626709-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08626709</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12568629</doc-number>
<date>20090928</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>869</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>30</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>707613</main-classification>
</classification-national>
<invention-title id="d2e53">Scalable relational database replication</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5764903</doc-number>
<kind>A</kind>
<name>Yu</name>
<date>19980600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709208</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>8037024</doc-number>
<kind>B1</kind>
<name>Bozkaya et al.</name>
<date>20111000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707637</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>2005/0021567</doc-number>
<kind>A1</kind>
<name>Holenstein et al.</name>
<date>20050100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707200</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2005/0283522</doc-number>
<kind>A1</kind>
<name>Parkkinen et al.</name>
<date>20051200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>2006/0047819</doc-number>
<kind>A1</kind>
<name>Caddes et al.</name>
<date>20060300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709227</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2007/0043749</doc-number>
<kind>A1</kind>
<name>Gerber et al.</name>
<date>20070200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707101</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2007/0124348</doc-number>
<kind>A1</kind>
<name>Claborn et al.</name>
<date>20070500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2007/0226220</doc-number>
<kind>A1</kind>
<name>Aronoff et al.</name>
<date>20070900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2007/0226277</doc-number>
<kind>A1</kind>
<name>Holenstein et al.</name>
<date>20070900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707204</main-classification></classification-national>
</us-citation>
<us-citation>
<nplcit num="00010">
<othercit>Veritas Software Corporation, Veritas Volume Replicator in an Oracle Environment, Technical Catalog, Jun. 2000, 6 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00011">
<othercit>International Preliminary Report on Patentability (Preliminary Report), International Application No. PCT/US2009/058672, International Filing Date Sep. 28, 2009, Date of Mailing Preliminary Report Apr. 7, 2011, 2 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00012">
<othercit>International Search Report (ISR), International Application No. PCT/US2009/058672, International Filing Date Sep. 28, 2009, Date of Mailing ISR Jun. 9, 2010, 3 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00013">
<othercit>Written Opinion (WO), International Application No. PCT/US2009/058672, International Filing Date Sep. 28, 2009, Date of Mailing WO Jun. 9, 2010, 5 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>19</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>707613</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>9</number-of-drawing-sheets>
<number-of-figures>9</number-of-figures>
</figures>
<us-related-documents>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61100669</doc-number>
<date>20080926</date>
</document-id>
</us-provisional-application>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61164857</doc-number>
<date>20090330</date>
</document-id>
</us-provisional-application>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20100082540</doc-number>
<kind>A1</kind>
<date>20100401</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Isaacson</last-name>
<first-name>Cory M.</first-name>
<address>
<city>Broomfield</city>
<state>CO</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Grove</last-name>
<first-name>Andrew F.</first-name>
<address>
<city>Broomfield</city>
<state>CO</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Isaacson</last-name>
<first-name>Cory M.</first-name>
<address>
<city>Broomfield</city>
<state>CO</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Grove</last-name>
<first-name>Andrew F.</first-name>
<address>
<city>Broomfield</city>
<state>CO</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<last-name>Osborne, Jr.</last-name>
<first-name>Thomas J.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<orgname>Thomas J. Osborne, Jr., PC</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Codefutures Corporation</orgname>
<role>02</role>
<address>
<city>Broomfield</city>
<state>CO</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Phillips, III</last-name>
<first-name>Albert</first-name>
<department>2155</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A relational database replication system includes a client, at least one primary database, a plurality of secondary databases and replication agents which coordinate database transactions. The system provides a high level of performance, reliability, and scalability with an end result of efficient and accurate duplication of transactions between the primary and secondary databases. In one implementation, the client transmits sets of database update statements to the primary database and primary agent in parallel; the primary agent replicates the statements to at least one secondary agent. A transaction prepare and commit process is coordinated between the primary database and the primary agent, which in turn coordinates with the at least one secondary agent. Databases can be partitioned into individual smaller databases, called shards, and the system can operate in a linearly scalable manner, adding clients, databases and replication agents without requiring central coordination or components that cause bottlenecks.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="196.51mm" wi="196.85mm" file="US08626709-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="186.35mm" wi="188.55mm" file="US08626709-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="224.71mm" wi="197.02mm" file="US08626709-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="213.11mm" wi="183.81mm" file="US08626709-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="212.60mm" wi="201.68mm" file="US08626709-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="211.24mm" wi="206.84mm" file="US08626709-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="214.80mm" wi="195.24mm" file="US08626709-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="220.39mm" wi="154.35mm" orientation="landscape" file="US08626709-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="244.43mm" wi="171.62mm" file="US08626709-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="166.62mm" wi="173.82mm" file="US08626709-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">This application claims the benefit of U.S. provisional application No. 61/100,669, filed 26 Sep. 2008 and U.S. provisional application No. 61/164,857, filed 30 Mar. 2009, each of which is hereby incorporated by reference as though fully set forth herein.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">BACKGROUND</heading>
<p id="p-0003" num="0002">1. Field</p>
<p id="p-0004" num="0003">The disclosed technology is in the field of relational database replication, more particularly, the disclosed technology is in the field of scalable relational database replication.</p>
<p id="p-0005" num="0004">2. Background</p>
<p id="p-0006" num="0005">Aspects of a typical database replication system include the following:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0006">Ensuring that all transactions written to the primary database are replicated in full to a secondary database.</li>
        <li id="ul0002-0002" num="0007">Committing (or finalizing) transactions in the secondary database in exactly the same order as the commit action of each transaction in the primary database.</li>
        <li id="ul0002-0003" num="0008">Recovery in the event of a failure, by switching the role of a database to either primary or secondary (as determined by the failure situation).</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0007" num="0009">Several forms of database replication exist, with the three most common methods described here. <figref idref="DRAWINGS">FIG. 1A</figref> shows an asynchronous log replication system that utilizes a database transaction log to perform replication asynchronously to secondary databases. In such a system, a primary database (<b>103</b>) and its transaction log (<b>104</b>) reside on a primary server (<b>102</b>). Transactions are written by a client program (<b>101</b>) to the primary database (<b>103</b>) and its transaction log (<b>104</b>) in a first operation. A separate process monitors the transaction log (<b>104</b>) and replicates transactions to a secondary database (<b>106</b>) residing on a secondary server (<b>105</b>) in a second operation. This method is the most commonly employed, and suffers from significant replication lag under high transaction rates, and cannot guarantee that all transactions are written to the secondary database (<b>106</b>). If for example a backlog of thousands of transactions are stored in the transaction log (<b>104</b>) awaiting replication, and the primary database experiences a failure, a portion or all of the pending transactions are lost. Thus when the system fails over to a secondary database, making it now the primary database, it has an incomplete copy of the original primary database, a condition that is intolerable for most commercial database applications.</p>
<p id="p-0008" num="0010"><figref idref="DRAWINGS">FIG. 1B</figref> shows a two-phase commit synchronous replication system in which any single transaction must be written and committed successfully to both the primary and secondary databases before a transaction is considered successful. In this process, a client (<b>107</b>) sends all database write statements (shown as a first operation) to a primary database (<b>109</b>), residing on a primary server (<b>108</b>), and to a secondary database (<b>111</b>), residing on a secondary server (<b>110</b>). The client (<b>107</b>) then sends a commit request to a transaction coordinator (<b>112</b>) (shown as a second operation). The transaction coordinator (<b>112</b>) then sends a prepare message (shown as a third operation) to the primary database (<b>109</b>) and the secondary database (<b>111</b>), each of which must acknowledge in turn. Then the transaction coordinator (<b>112</b>) sends a commit message (shown as a fourth operation) to the primary database (<b>109</b>) and the secondary database (<b>111</b>), each of which must acknowledge in turn. The transaction coordinator (<b>112</b>) then sends an acknowledgement of a final commit message to the client (<b>107</b>) (shown as a fifth operation). This mechanism guarantees in most cases that the transaction fails or succeeds on both the primary and secondary database, however there is significant overhead introduced. The transaction coordinator (<b>112</b>) must wait for the all databases participating in the transaction to complete all processing and respond. Further the use of a centralized transaction coordinator (<b>112</b>) creates a bottleneck, limiting scalability as client processes are added to the system, further slowing performance. Lastly, this mechanism requires at least two databases be available at all times for a transaction to be performed reliably. If a failure of one of the participating database occurs, it must be rebuilt on a standby server, which can incur a significant time delay (minutes, hours or longer). Alternatively there can be at least three running servers, each participating in a two-phase commit transaction, but this further adds to system overhead, processing delays and adds significant cost to the system.</p>
<p id="p-0009" num="0011"><figref idref="DRAWINGS">FIG. 1C</figref> shows a middle-tier replication system that normally requires at least one middle-tier server and process (<b>114</b>) located between a client (<b>113</b>) and a primary database (<b>116</b>) and a secondary database (<b>118</b>). The middle-tier server (<b>114</b>) receives and relays all transactions from the client (<b>114</b>) to the participating databases in a synchronous manner. This approach adds both overhead and cost to the system, as the middle-tier must be redundant (requiring at least two middle-tier servers), and acts as a bottleneck which cannot scale effectively as additional clients (<b>114</b>) are added to the system.</p>
<p id="p-0010" num="0012">There are several drawbacks in these replication systems. Synchronous replication mechanisms cause a significant degradation in overall database performance, by enforcing the completion of an entire transaction on both the primary and secondary databases. In these systems a centralized transaction coordinator is often required, which must ensure that transactions complete fully across all participating databases. This limits scalability by creating a bottleneck at this centralized component, and also requires additional complexity to ensure that this single component does not experience a failure, as the system cannot operate without it.</p>
<p id="p-0011" num="0013">Asynchronous replication systems avoid the performance penalty, but do not guarantee the success of transactions on the secondary databases, and can experience major delays (referred to as &#x201c;replication lag&#x201d;) between transactional writes to the secondary database after transactions are performed on the primary database. Further, replicated transactions must be committed in the exact order performed on the source database. This requires writing one transaction at a time on the replicated database, which slows performance and increases replication lag.</p>
<p id="p-0012" num="0014">If a failure occurs, in either a synchronous or asynchronous replication system, a database system ideally should continue to operate in a reliable fashion. Some systems only support continued operation after a failure on the single remaining operating member of the system (such as the primary or secondary database that is still operational). In this case, there is no protection against a succeeding failure of the remaining components until the original failed component has been recovered. Alternatively, some systems require at least two active secondary databases in the system which is costly.</p>
<p id="p-0013" num="0015">These conditions limit the effectiveness and usefulness of database replication systems, particularly when high-performance transactions and high-availability are required. Each of the prior methods possess one or more drawbacks for high-performance systems that must be process a large volume of transactions, must be reliable, and scalable without a reliance on centralized components.</p>
<heading id="h-0003" level="1">SUMMARY</heading>
<p id="p-0014" num="0016">In one implementation, a high-performance, reliable and fully scalable replication method is provided. In this implementation, a transaction written to a primary database is reliably replicated to one or more secondary databases without requiring centralized components that limit scalability as the number of system participants expand. One highly efficient replication mechanism utilizes synchronous characteristics for highly reliable transaction replication, and a highly efficient parallel asynchronous mechanism for replication to secondary databases for minimal and controllable replication lag without loss of transactions.</p>
<p id="p-0015" num="0017">A first variation provides a highly efficient replication system between a primary database and at least one secondary database. In this variation, this allows the client to interact directly with the primary database, sending one or a plurality of database write statements as part of a single atomic transaction with no intermediary server or process. In substantially the same time period, the client sends the database write statements to a primary replication agent, co-located on the primary database server. The primary agent in turn sends each database write statement after received to a primary agent in memory and asynchronously in log file for reliability, and to at least one secondary agent which in turn stores the transaction in memory and asynchronously in a log file for reliability. When sending of database write statements to the primary database and primary agent is complete, the client sends a prepare request to the primary agent. The primary agent sends a prepare request to the secondary agents, and acknowledges the client when successful, generating a sequence number and optionally holding a sequence semaphore or other lock in the primary agent for the transaction (the optional semaphore or other lock may be used to guarantee a strict order of processing). The client then sends a commit request to the primary database, and if successful sends a commit to the primary agent, which in turn sends a commit request to the secondary agent. The secondary agent sends an acknowledgement to the primary agent, the primary agent sends an acknowledgement to the client, and the sequence semaphore or other lock in the primary agent is released if such lock was utilized. The secondary agent then replicates the transaction to the secondary database. If a failure occurs at any point in the process, up to and including the commit to the primary database, a rollback message is sent to the primary agent, which in turn sends the rollback to the secondary agent, and the transaction is ignored by the secondary agent.</p>
<p id="p-0016" num="0018">This method is highly efficient as the majority of the processing time incurred by a database transaction is during the sending of the database write statements to a database. In this variation, the client, in substantially the same time period, sends the database write statements to the primary agent, which forwards them as received to the secondary agent. The agents can receive and process database write statements generally faster than the primary database, and therefore no extraneous overhead is added to the process. The write to the secondary database is not required within this timeframe, eliminating the major inefficiency of prior mechanisms, yet maintaining reliability of all transactions on at least two servers. The prepare and commit messages sent by the client to the primary agent, and in turn forwarded to the secondary agent, are very small messages and can be processed very efficiently, adding the minimum possible delay to the process.</p>
<p id="p-0017" num="0019">A second variation involves parallel replication of transactions to at least one secondary database, to minimize replication lag while still guaranteeing the sequence of transactions. The method supports multiple client processes or threads sending transactions to the primary database and primary agent. The primary agent receives a discrete sequence of transactions from each individual client process or thread, and forwards them to the secondary agent, also in a discrete sequence for each client process or thread. The secondary agent then applies the database write statements from each discrete client sequence to the secondary database in parallel. The client process or thread then sends a prepare and commit message, coordinated with the primary database, maintaining exactly sequence control of all transactions across all participating client processes or threads only where such transactions require such sequencing. The secondary agent then applies each transaction in the secondary database in the exact sequence that the transactions were applied to the primary database, ensuring overall sequence across all participating client processes or threads. The application of the transaction to the secondary database by the secondary agent determines the actual order in which transactions are applied to the secondary database when contention between two or more transactions occurs, ensuring that the secondary database is an accurate copy of the primary database.</p>
<p id="p-0018" num="0020">In this variation, it is possible for the application of the database write statements to the secondary database to experience an occasional failure due to a referential integrity violation. A referential integrity violation occurs when a transaction depends on a related value from an earlier transaction, and this variation is applying the database write statements in sequence by client process or thread, rather than the overall sequence applied to the primary database to gain efficiency. If the secondary agent experiences a referential integrity violation on a transaction, it utilizes two recovery mechanisms. In the first mechanism the secondary agent waits for a specified period and reapplies the database write statement, with the likely occurrence that the required data dependency has been performed by a parallel database write for another client process or thread during the wait period. This process is repeated if necessary for a predetermined number of recovery attempts. If this mechanism fails, the transaction is marked as failed and awaits intervention by an administrator of the system. This variation improves efficiency and performance of the application of replicated transactions to the secondary database, by performing transactions in parallel according to client process or thread and managing contention between client processes only when required. This allows the system to maintain a very close level of synchronization between the primary and secondary databases, even when an efficient asynchronous approach is utilized.</p>
<p id="p-0019" num="0021">In a third variation, a system and method of providing parallel replication is provided. A plurality of client processes or threads send database write messages and prepare messages to a primary agent. The primary agent receives transactions in a discrete sequence for each client process or thread. The primary agent relays the database write statements and prepare messages for each client process or thread to a secondary agent, preserving sequence for each client process or thread. The secondary agent asynchronously performs the database write transactions on a secondary database after the prepare message has been received and acknowledged. The client sends a commit message to the primary agent, which in turn relays the commit message to the secondary agent, and the secondary agent sends an acknowledgement to the primary agent which in turn sends the acknowledgement to the client. The secondary agent applies the transactions in parallel to the secondary database for each client process or thread in prepare message order. The primary agent and the secondary agent maintain the sequence of prepare messages across all transactions for all client participants, ensuring the sequence of commit messages matches the commit action to the primary database. The secondary agent then performs the commit messages on the secondary database in the same sequence as performed on the primary database.</p>
<p id="p-0020" num="0022">A fourth variation supports scalability of replication processing for databases which utilize a technique called database sharding. Database sharding is an established technique in which a single large database is portioned into many smaller individual databases, called shards, across a plurality of servers, dividing the data horizontally or by row. Database sharding allows client processes or threads to write and read transactions and data to and from individual shards. This can support scalable replication across any number of shards, by providing a primary agent and secondary agent for each database shard, performing the replication process as described earlier. Each database shard operates in independent primary and secondary databases, where replication is performed to the secondary database by the secondary agent as described in other variations. Any number of client processes or threads accesses each primary database shard and primary agent directly.</p>
<p id="p-0021" num="0023">The performance scales in a near-linear fashion using this method, as the number of database shards, primary agents, and secondary agents are expanded together, allowing full scalability without a dependency on centralized components which create bottlenecks. Each database shard, its primary database, secondary database, primary agent and secondary agent operate as an independent group without sharing resources or limits from other similar groups. Each client process or thread accesses the primary database and primary agent of each database shard directly without dependency on other client processes or threads, allowing the system to scale as any number of client processes or threads are added to the system.</p>
<p id="p-0022" num="0024">A fifth variation provides an efficient mechanism for failover in the event of a failure of a primary database or agent in the system. In the event of a database or agent failure, another agent is immediately started or is already operational on a standby or other available server. Once the agent is operational, the client process is informed of the new agent, and resumes sending transactions using the new secondary agent instance. The secondary agent instance then rebuilds a new instance of the secondary database while it continues receiving transactions without further system interruption.</p>
<p id="p-0023" num="0025">A benefit of this approach is that the failover mechanism can be initiated very rapidly, allowing operation to continue without an operational secondary agent or database, or causing the system to experience significant delays while a secondary database is rebuilt.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0024" num="0026"><figref idref="DRAWINGS">FIGS. 1A</figref>, <b>1</b>B, and <b>1</b>C illustrate examples of typical relational database replications systems.</p>
<p id="p-0025" num="0027"><figref idref="DRAWINGS">FIG. 2</figref> illustrates a first variation of a relational database replication system.</p>
<p id="p-0026" num="0028"><figref idref="DRAWINGS">FIG. 2B</figref> illustrates an alternative implementation of the relational database replication system shown in <figref idref="DRAWINGS">FIG. 2A</figref>.</p>
<p id="p-0027" num="0029"><figref idref="DRAWINGS">FIG. 3</figref> illustrates a second variation of a relational database replication system.</p>
<p id="p-0028" num="0030"><figref idref="DRAWINGS">FIG. 4</figref> illustrates the third variation of a relational database replication system.</p>
<p id="p-0029" num="0031"><figref idref="DRAWINGS">FIG. 5</figref> illustrates the fourth variation of a relational database replication system.</p>
<p id="p-0030" num="0032"><figref idref="DRAWINGS">FIG. 6</figref> illustrates an example implementation of a relational database replication system.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS</heading>
<p id="p-0031" num="0033">Efficient and scalable relational database replication systems and methods for efficiently and scalably replicating relational databases are provided. Database replication is the ability to reproduce transactions written to a primary database into one or more replicated secondary databases. An accurate and complete secondary database allows a computer system to support high availability, by switching operations to a secondary database if a failure occurs. Further, a replicated database system supports distribution of read-only operations across the primary and one or more secondary databases as a means of spreading the load and improving performance.</p>
<p id="p-0032" num="0034">Referring to <figref idref="DRAWINGS">FIG. 2A</figref>, a client (<b>201</b>) (defined as an originator or forwarder of write statements to a database) sends one or a plurality of database write statements (<b>21</b>A) (e.g., SQL database write statements) in substantially the same time period to a primary database (<b>204</b>) and a primary agent (<b>205</b>). In one implementation, the primary database (<b>204</b>) and the primary agent (<b>205</b>) reside on a primary server (<b>202</b>), and a secondary database (<b>207</b>) and a secondary agent (<b>206</b>) reside on a secondary server (<b>203</b>), but this is not required. The primary agent (<b>205</b>) relays the one or a plurality of database write messages (<b>21</b>A) to one or more the secondary agent(s) (<b>206</b>) (e.g., as soon as each database write message is received). The database write messages (<b>21</b>A) are stored at least in memory on the secondary agent (<b>206</b>), and are asynchronously written to a log file of the secondary agent (<b>206</b>) without adding delay to the process. The client (<b>201</b>) then sends a prepare message (<b>22</b>A) to the primary agent (<b>205</b>). The primary agent (<b>205</b>) generates a sequence number and sets a semaphore to enforce sequence and prevent a future prepare from other client processes, and in turn sends the prepare message (<b>22</b>A) to the secondary agent (<b>206</b>). The secondary agent (<b>206</b>) acknowledges the prepare message (<b>22</b>A) in an acknowledgement (<b>23</b>A) to the primary agent (<b>205</b>) and the primary agent sends an acknowledgment (<b>23</b>A) to the client (<b>201</b>).</p>
<p id="p-0033" num="0035">The client (<b>201</b>) then immediately sends a commit message (<b>24</b>A) to the primary database (<b>204</b>) and determines that the commit (<b>24</b>A) is successfully performed. The client (<b>201</b>) then sends the commit message (<b>25</b>A) to the primary agent (<b>205</b>), the primary agent releases the semaphore allowing other prepare messages to be received, and relays the commit message (<b>25</b>A) to the secondary agent (<b>206</b>). The secondary agent (<b>206</b>) sends an acknowledgment (<b>26</b>A) to the primary agent (<b>205</b>), which in turn sends an acknowledgment (<b>26</b>A) to the client (<b>201</b>). The client (<b>201</b>) is then free to perform an additional transaction. The secondary agent (<b>206</b>) then asynchronously performs the write transaction (<b>27</b>A) on the secondary database (<b>207</b>) in exactly the same sequence as the write transaction was performed on the primary database (<b>204</b>).</p>
<p id="p-0034" num="0036">In an alternative implementation of the system shown in <figref idref="DRAWINGS">FIG. 2A</figref>, the client (<b>201</b>) sends one or a plurality of database write statements (<b>21</b>A) in substantially the same time period to the primary database (<b>204</b>) and the primary agent (<b>205</b>). In this implementation, for example, the primary database (<b>204</b>) and the primary agent (<b>205</b>) may reside on the primary server (<b>202</b>), and the secondary database (<b>207</b>) and the secondary agent (<b>206</b>) may reside on a secondary server (<b>203</b>), but again this is not required. The primary agent (<b>205</b>) relays the one or a plurality of database write messages (<b>21</b>A) to one or more the secondary agent(s) (<b>206</b>) (e.g., as soon as each database write message (<b>21</b>A) is received). The database write messages (<b>21</b>A) are stored at least in memory on the secondary agent (<b>206</b>), and are asynchronously written to a log file of the secondary agent (<b>206</b>) without adding delay to the process. The client (<b>201</b>) then sends a prepare message (<b>22</b>A) to the primary agent (<b>205</b>). The primary agent (<b>205</b>) generates a sequence number to enforce sequence where there is a conflict with one or more other client transactions, and in turn sends the prepare message and sequence number (<b>22</b>A) to the secondary agent (<b>206</b>). The secondary agent (<b>206</b>) acknowledges the prepare message with an acknowledgement (<b>23</b>A) to the primary agent (<b>205</b>) and the primary agent sends an acknowledgment (<b>23</b>A) to the client (<b>201</b>). The client (<b>201</b>) then immediately sends a commit message (<b>24</b>A) to the primary database (<b>204</b>) and determines that the commit is successfully performed. The client (<b>201</b>) then sends a commit message (<b>25</b>A) to the primary agent (<b>205</b>), which relays the commit message (<b>25</b>A) to the secondary agent (<b>206</b>). The secondary agent (<b>206</b>) optionally sends an acknowledgment (<b>26</b>A) to the primary agent (<b>205</b>), which in turn optionally sends an acknowledgment (<b>26</b>A) to the client (<b>201</b>). The client (<b>201</b>) is then free to perform an additional transaction. The secondary agent (<b>206</b>) then asynchronously performs the write transaction (<b>27</b>A) on the secondary database (<b>207</b>) in accordance with the sequence number(s) generated by one or more primary agent(s).</p>
<p id="p-0035" num="0037">The sequence number, for example, is used to govern the overall order of applying transactions to the secondary database, and explicitly guarantees sequence between conflicting client processes (e.g., where the conflicting client processes attempt to write to the same record or field of a database). In one particular implementation, for example, the secondary agent may be able to perform write operations out of order if the operations do not conflict (e.g., are directed to different or non-related records within a database). The secondary agent uses the sequence numbers generated by the primary agents to apply all transactions, guaranteeing transaction sequence when there is a direct conflict between write operations. In this manner, the primary and secondary agents and the database may proceed more quickly by using this sequence mechanism, with strict sequential control over conflicting transactions, and approximate sequence control with non-conflicting transactions (without the need to hold an explicit lock for the entire commit time). This may greatly increase the speed of the process. In an alternative implementation, the secondary agent may use the sequence numbers for each write operation. In this manner, complete control of write sequences can be maintained without requiring a lock on the primary agent.</p>
<p id="p-0036" num="0038"><figref idref="DRAWINGS">FIG. 2B</figref> illustrates an alternative implementation of the relational database replication system shown in <figref idref="DRAWINGS">FIG. 2A</figref>. The same reference numbers, where used, indicate the same or a similar structure or operation. In this implementation, for example, a client (<b>201</b>) sends one or a plurality of database write statements (<b>21</b>B) to a primary database (<b>204</b>). A database trigger (<b>208</b>) of the primary database (<b>204</b>) provides at least one data value as a result of the database write statement. A function (e.g., a user defined function (<b>209</b>) or other function) captures the at least one data value from the database trigger (<b>208</b>) and passes the at least one data value to a primary agent (<b>205</b>). In one particular implementation, for example, the user-defined function (<b>209</b>) forwards actual value(s) captured from the database trigger (<b>208</b>) to a primary agent (<b>205</b>). In another implementation, the user-defined function (<b>209</b>) captures the data value(s) from the database trigger (<b>208</b>) and rebuilds a database write statement to be forwarded to the primary agent (<b>205</b>).</p>
<p id="p-0037" num="0039">A &#x201c;database data modification&#x201d; collectively refers to a database statement (e.g., a database statement specifying inserting, updating, or deleting) or a database data value that specifies an insert, update or delete operation to a database row of a relational database. Thus, for example, the database write statement or the captured data value described above may be collectively referred to as a database data modification.</p>
<p id="p-0038" num="0040">In the implementation shown in <figref idref="DRAWINGS">FIG. 2B</figref>, the primary database (<b>204</b>) and the primary agent (<b>205</b>) reside on a primary server (<b>202</b>), and a secondary database (<b>207</b>) and a secondary agent (<b>206</b>) reside on a secondary server (<b>203</b>), but this is not required.</p>
<p id="p-0039" num="0041">The primary agent (<b>205</b>) relays the one or a plurality of database write messages (<b>21</b>B) and/or data values captured from the database trigger (<b>208</b>) of the primary database (<b>204</b>) to one or more of the secondary agent(s) (<b>206</b>) (e.g., as soon as each database write message is received). The database write messages (<b>21</b>B) (or captured data values) are stored at least in memory on the secondary agent (<b>206</b>), and are asynchronously written to a log file of the secondary agent (<b>206</b>) without adding delay to the process. The client (<b>201</b>) then sends a prepare message (<b>22</b>B) to the primary agent (<b>205</b>). The primary agent (<b>205</b>) generates a sequence number and sets a semaphore to enforce sequence and prevent a future prepare from other client processes, and in turn sends the prepare message (<b>22</b>B) to the secondary agent (<b>206</b>). The secondary agent (<b>206</b>) acknowledges the prepare message (<b>22</b>BA) in an acknowledgement (<b>23</b>BA) to the primary agent (<b>205</b>) and the primary agent sends an acknowledgment (<b>23</b>B) to the client (<b>201</b>).</p>
<p id="p-0040" num="0042">The client (<b>201</b>) then immediately sends a commit message (<b>24</b>B) to the primary database (<b>204</b>) and determines that the commit (<b>24</b>B) is successfully performed. The client (<b>201</b>) then sends the commit message (<b>25</b>B) to the primary agent (<b>205</b>), the primary agent releases the semaphore allowing other prepare messages to be received, and relays the commit message (<b>25</b>B) to the secondary agent (<b>206</b>). The secondary agent (<b>206</b>) sends an acknowledgment (<b>26</b>B) to the primary agent (<b>205</b>), which in turn sends an acknowledgment (<b>26</b>B) to the client (<b>201</b>). The client (<b>201</b>) is then free to perform an additional transaction. The secondary agent (<b>206</b>) then asynchronously performs the write transaction (<b>27</b>BA) on the secondary database (<b>207</b>) in exactly the same sequence as the write transaction was performed on the primary database (<b>204</b>).</p>
<p id="p-0041" num="0043">In an alternative implementation of the system shown in <figref idref="DRAWINGS">FIG. 2B</figref>, the client (<b>201</b>) sends one or a plurality of database write statements (<b>21</b>A) to the primary database (<b>204</b>). A database trigger (<b>208</b>) of the primary database (<b>204</b>) provides at least one data value as a result of the database write statement. A function (e.g., a user defined function (<b>209</b>) or other function) captures the at least one data value from the database trigger (<b>208</b>) and passes the at least one data value to a primary agent (<b>205</b>). In one particular implementation, for example, the user-defined function (<b>209</b>) forwards actual value(s) captured from the database trigger (<b>208</b>) to a primary agent (<b>205</b>). In another implementation, the user-defined function (<b>209</b>) captures the data value(s) from the database trigger (<b>208</b>) and rebuilds a database write statement to be forwarded to the primary agent (<b>205</b>). Again, for example, such a database write statement or a captured data value described above may be collectively referred to as a database data modification. In this implementation, for example, the primary database (<b>204</b>), database trigger (<b>208</b>), user-defined function (<b>209</b>), and the primary agent (<b>205</b>) may reside on the primary server (<b>202</b>), and the secondary database (<b>207</b>) and the secondary agent (<b>206</b>) may reside on a secondary server (<b>203</b>), but again this is not required.</p>
<p id="p-0042" num="0044">The primary agent (<b>205</b>) relays the one or a plurality of database write messages (<b>21</b>B) and/or data values captured from the database trigger (<b>208</b>) of the primary database (<b>204</b>) to one or more of the secondary agent(s) (<b>206</b>) (e.g., as soon as each database write message (<b>21</b>B) is received). The database write messages (<b>21</b>B) are stored at least in memory on the secondary agent (<b>206</b>), and are asynchronously written to a log file of the secondary agent (<b>206</b>) without adding delay to the process. The client (<b>201</b>) then sends a prepare message (<b>22</b>B) to the primary agent (<b>205</b>). The primary agent (<b>205</b>) generates a sequence number to enforce sequence where there is a conflict with one or more other client transactions, and in turn sends the prepare message (<b>22</b>B) to the secondary agent (<b>206</b>). The secondary agent (<b>206</b>) acknowledges the prepare message with an acknowledgement (<b>23</b>B) to the primary agent (<b>205</b>) and the primary agent sends an acknowledgment (<b>23</b>B) to the client (<b>201</b>). The client (<b>201</b>) then immediately sends a commit message (<b>24</b>B) to the primary database (<b>204</b>) and determines that the commit is successfully performed. The client (<b>201</b>) then sends a commit message (<b>25</b>B) to the primary agent (<b>205</b>), which relays the commit message (<b>25</b>B) to the secondary agent (<b>206</b>). The secondary agent (<b>206</b>) optionally sends an acknowledgment (<b>26</b>B) to the primary agent (<b>205</b>), which in turn optionally sends an acknowledgment (<b>26</b>BA) to the client (<b>201</b>). The client (<b>201</b>) is then free to perform an additional transaction. The secondary agent (<b>206</b>) then asynchronously performs the write transaction (<b>27</b>A) on the secondary database (<b>207</b>) in accordance with the sequence number(s) generated by one or more primary agent(s).</p>
<p id="p-0043" num="0045">The sequence number, for example, is used to govern the overall order of applying transactions to the secondary database, and explicitly guarantees sequence between conflicting client processes (e.g., where the conflicting client processes attempt to write to the same record or field of a database). In one particular implementation, for example, the secondary agent may be able to perform write operations out of order if the operations do not conflict (e.g., are directed to different or non-related records within a database). The secondary agent uses the sequence numbers generated by the primary agents to apply all transactions, guaranteeing transaction sequence when there is a direct conflict between write operations. In this manner, the primary and secondary agents and the database may proceed more quickly by using this sequence mechanism, with strict sequential control over conflicting transactions, and approximate sequence control with non-conflicting transactions (without the need to hold an explicit lock for the entire commit time). This may greatly increase the speed of the process. In an alternative implementation, the secondary agent may use the sequence numbers for each write operation. In this manner, complete control of write sequences can be maintained without requiring a lock on the primary agent.</p>
<p id="p-0044" num="0046">Referring to <figref idref="DRAWINGS">FIG. 3</figref>, a plurality of client processes or threads (<b>301</b>) send database write messages (<b>31</b>) and prepare messages to a primary agent (<b>302</b>). For purposes of clarity, the primary database is left out of this diagram. The primary agent (<b>302</b>) receives transactions in a discrete sequence for each client process or thread (<b>301</b>). The primary agent (<b>302</b>) relays the database write statements (<b>31</b>) and prepare messages for each client process or thread (<b>301</b>) to a secondary agent (<b>303</b>), preserving sequence for each client process or thread (<b>301</b>). The secondary agent (<b>303</b>) asynchronously performs the database write transactions (<b>31</b>) on a secondary database (<b>304</b>) after the prepare message has been received and acknowledged. The client (<b>301</b>) sends a commit message (<b>32</b>) to the primary agent (<b>302</b>), which in turn relays the commit message (<b>32</b>) to the secondary agent (<b>303</b>), and the secondary agent (<b>303</b>) sends an acknowledgement to the primary agent (<b>302</b>) which in turn sends the acknowledgement to the client (<b>301</b>). The secondary agent (<b>303</b>) applies the transactions (<b>31</b>) in parallel to the secondary database (<b>304</b>) for each client process or thread (<b>301</b>) in prepare message order. The primary agent (<b>302</b>) and the secondary agent (<b>303</b>) maintain the sequence of prepare messages (<b>31</b>) across all transactions for all client (<b>301</b>) participants, ensuring the sequence of commit messages (<b>32</b>) matches the commit action to the primary database. The secondary agent (<b>303</b>) then performs the commit messages (<b>32</b>) on the secondary database (<b>304</b>) in the same sequence as performed on the primary database.</p>
<p id="p-0045" num="0047">Referring to <figref idref="DRAWINGS">FIG. 4</figref>, a plurality of database shards are configured. Each shard comprises a group of components containing a primary agent (<b>402</b>), a primary database (<b>403</b>), a secondary agent (<b>404</b>), and a secondary database (<b>405</b>). Each database shard contains a specific segment group of database rows, and the client (<b>401</b>) is configured to send messages to the appropriate shard based on the specific database rows related to any transaction. The client (<b>401</b>) sends database write statements in substantially the same time period to the primary database (<b>403</b>) and the primary agent (<b>402</b>) of a particular shard. The primary agent relays the database write messages to the secondary agent (<b>404</b>) which asynchronously performs the database writes on the secondary database (<b>405</b>). The client (<b>401</b>) sends a prepare message to the primary agent (<b>402</b>), which in turn relays the prepare message to the secondary agent (<b>404</b>). The secondary agent (<b>404</b>) then sends an acknowledgment to the primary agent (<b>402</b>), which in turn sends an acknowledgment to the client (<b>401</b>). The client (<b>401</b>) then sends a commit to the primary database (<b>403</b>). The client then sends a commit message to the primary agent (<b>402</b>) which relays the commit message to the secondary agent (<b>404</b>). The secondary agent (<b>404</b>) then commits the transaction to the secondary database (<b>405</b>). As the number of database shards expands, the number of primary databases, primary agents, secondary agents and secondary databases also grows, providing near-linear scalability of the replication process.</p>
<p id="p-0046" num="0048">Referring to <figref idref="DRAWINGS">FIG. 5</figref>, under normal operation a client (<b>501</b>) interacts with a primary database (<b>503</b>), a primary agent (<b>504</b>), and a primary agent (<b>504</b>) in turn interacts with a secondary agent (<b>506</b>) which in turn interacts with a secondary database (<b>507</b>). If a failure occurs in the secondary server (<b>505</b>), the secondary agent (<b>506</b>) and the secondary database (<b>507</b>) may be unavailable for processing. Note that a similar failure can occur in any of the primary server (<b>502</b>), the primary database (<b>503</b>), the primary agent (<b>504</b>), the secondary agent (<b>506</b>) or the secondary database (<b>507</b>). The primary agent (<b>504</b>), for example, may determine that one or more components on the secondary server (<b>505</b>) have failed and initiate a failover process. Alternatively, a planned failover process may be initiated and implemented. In these examples, a new secondary agent (<b>509</b>) is started on a failover server (<b>508</b>) after a determination of a failure or, in the case of a planned failover, the primary agent and secondary agents switch roles. The client (<b>501</b>) then continues sending database write transactions to the primary database (<b>503</b>) and the primary agent (<b>504</b>). The secondary agent (<b>509</b>) stores database write transactions, prepare messages and commit messages at least in system memory, and asynchronously writes them to a persistent log file. A secondary database (<b>510</b>) is not required immediately for reliable operation to continue, as the secondary agent (<b>509</b>) ensures transaction reliability. The secondary agent (<b>509</b>) then initiates a recovery or rebuild of the secondary database (<b>510</b>) from a backup copy on the failover server (<b>508</b>), which occurs over a period of time that may be from minutes to hours or longer. The secondary agent (<b>509</b>) then replicates transactions received during the secondary database (<b>510</b>) recovery period to the secondary database (<b>510</b>). Normal operation then continues.</p>
<p id="p-0047" num="0049"><figref idref="DRAWINGS">FIG. 6</figref> illustrates one example implementation of a relational database replication system that may be used as described above with respect to <figref idref="DRAWINGS">FIGS. 2A through 5</figref>. Other implementations are possible, however. In this implementation, a client server (<b>601</b>), a primary server (<b>607</b>), and a secondary server (<b>611</b>) are provided. Each server comprises a central processing unit (CPU) (<b>602</b>), a memory (<b>603</b>), and a storage device (e.g., a disk drive (<b>604</b>)), as well as various processes running on the particular server. The client server (<b>601</b>), for example, comprises an application server process (<b>605</b>) and a client driver (<b>606</b>) that is used by the client application server process to communicate with an agent or database application residing on the primary server (<b>607</b>) and/or the secondary server (<b>611</b>). The primary server (<b>607</b>) and the secondary server (<b>611</b>) also comprise a database process (<b>608</b>) and an agent process (<b>610</b>) executing on the respective servers.</p>
<p id="p-0048" num="0050">The servers may, for example, comprise a general purpose computer system configured to execute a computer program product to execute a computer process. Data and program files may be input to the computer system, which reads the files and executes the programs therein. Some of the elements of a general purpose computer system are shown in <figref idref="DRAWINGS">FIG. 6</figref> wherein a processor has an input/output (I/O) section, a CPU (<b>602</b>), and a memory section (<b>603</b>). There may be one or more processors, such that the processor of the computer system comprises a single central-processing unit, or a plurality of processing units, commonly referred to as a parallel processing environment. Although described as a server, the computer system may be a conventional computer, a distributed computer, or any other type of computer. The described technology is optionally implemented in software devices loaded in memory (<b>603</b>), stored on a configured DVD/CD-ROM or storage unit (e.g., disk drive (<b>604</b>), and/or communicated via a wired or wireless network link on a carrier signal, thereby transforming the computer system to a special purpose machine for implementing the described operations. In addition, some or all of the system may be implemented through hardware, such as a field programmable gate array (FPGA), application specific integrated circuit (ASIC), or other custom hardware.</p>
<p id="p-0049" num="0051">The servers may also include a network adapter capable of connecting the computer system to a network via a network link, through which the computer system can receive instructions and data embodied in a carrier wave. Examples of such systems include Intel and PowerPC systems offered by Apple Computer, Inc., personal computers offered by Dell Corporation and by other manufacturers of Intel-compatible personal computers, AMD-based computing systems and other systems running a Windows-based, UNIX-based, or other operating system.</p>
<p id="p-0050" num="0052">The servers (<b>601</b>), (<b>607</b>), and (<b>611</b>), for example, may be connected via a network, such as a local area network (LAN), a wide area network (WAN), the Internet, an intranet, or the like. When used in a LAN-networking environment, for example, the computer system is connected (by wired connection or wirelessly) to a local network through a network interface or adapter, which is one type of communications device. When used in a WAN-networking environment, the computer system typically includes a modem, a network adapter, or any other type of communications device for establishing communications over the wide area network. In a networked environment, program modules or processes depicted relative to the computer system or portions thereof, may be stored in a remote memory storage device. It is appreciated that the network connections shown are exemplary and other means of and communications devices for establishing a communications link between the computers may be used.</p>
<p id="p-0051" num="0053">The implementations described herein are implemented as logical steps in one or more computer systems. The logical operations of are implemented (1) as a sequence of processor-implemented steps executing in one or more computer systems and (2) as interconnected machine or circuit modules within one or more computer systems. The implementation is a matter of choice, dependent on the performance requirements of the computer system implementing the invention. Accordingly, the logical operations making up the embodiments of the invention described herein are referred to variously as operations, steps, objects, or modules. Furthermore, it should be understood that logical operations may be performed in any order, unless explicitly claimed otherwise or a specific order is inherently necessitated by the claim language.</p>
<p id="p-0052" num="0054">Although several implementations and variations have been described above with a certain degree of particularity, those skilled in the art could make numerous alterations to the disclosed implementations and variations without departing from the spirit or scope of this invention. In addition, certain features are described in implementations and variations for ease of understanding. These features may be interchanged with features of other implementations and variations or may be added to other implementations and variations. All directional references (e.g., upper, lower, upward, downward, left, right, leftward, rightward, top, bottom, above, below, vertical, horizontal, clockwise, and counterclockwise) are only used for identification purposes to aid the reader's understanding of the present invention, and do not create limitations, particularly as to the position, orientation, or use of the invention. Joinder references (e.g., attached, coupled, connected, and the like) are to be construed broadly and may include intermediate members between a connection of elements and relative movement between elements. As such, joinder references do not necessarily infer that two elements are directly connected and in fixed relation to each other. It is intended that all matter contained in the above description or shown in the accompanying drawings shall be interpreted as illustrative only and not limiting. Changes in detail or structure may be made without departing from the spirit of the invention as defined in the appended claims.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>We claim:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method of replicating a relational database comprising:
<claim-text>receiving, by a primary database and a primary replication agent of the primary database, at least one database write statement from a client;</claim-text>
<claim-text>receiving by a secondary replication agent of a secondary database, the at least one database write statement from the primary replication agent;</claim-text>
<claim-text>storing the database write statement to a transaction log at the secondary replication agent;</claim-text>
<claim-text>sending, by the primary replication agent, the prepare message to the secondary replication agent;</claim-text>
<claim-text>sending, by the secondary replication agent, an acknowledgment of the prepare message to the primary replication agent;</claim-text>
<claim-text>sending, by the primary replication agent, an acknowledgment of the prepare message to the client;</claim-text>
<claim-text>receiving, by the primary database, a first commit message from the client;</claim-text>
<claim-text>receiving, by the primary replication agent, a second commit message from the client upon determination that the first commit message has been successfully performed at the primary database;</claim-text>
<claim-text>sending, by the primary replication agent, the second commit message to the secondary replication agent;</claim-text>
<claim-text>sending, by the secondary replication agent, an acknowledgment to the primary replication agent;</claim-text>
<claim-text>sending, by the primary replication agent, an acknowledgment to the client;</claim-text>
<claim-text>asynchronously performing, by the secondary replication agent, the at least one database write statement on the secondary database.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the transaction log is stored in at least one of a memory and a log file.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the database write statement is received in substantially the same time period from a client at a primary database and a primary replication agent, and wherein the database write statement is included in a transaction.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising providing a sequence number and lock for a transaction in the primary replication agent to maintain an identical transaction sequence in the primary database, the primary replication agent, the secondary replication agent and the secondary database.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref> wherein the lock in the primary replication agent is released after the first commit message is provided to the primary database and the primary replication agent and the second commit message is provided to the secondary replication agent.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising generating a sequence number for a transaction in the primary agent to maintain sequence for transactions competing to update the primary database, the primary replication agent, the secondary replication agent and the secondary database.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref> wherein, in the operation of applying the database write statement and the second commit message to the secondary database, a sequence of the database write statement is controlled at least in part by the sequence number.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00007">claim 7</claim-ref> wherein the sequence of the database write statement is controlled at least in part by the sequence number when the database write statement is in direct conflict with another database data modification.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref> wherein the direct conflict comprises one or more of an attempt to write to a same row of the secondary database and an attempt to write to a same field on the same row of the secondary database.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. A relational database replication system comprising:
<claim-text>a primary database configured to receive a database write statement of a transaction from a client;</claim-text>
<claim-text>a primary replication agent of the primary database adapted to execute on at least one primary processor in communication with the primary database;</claim-text>
<claim-text>a secondary database; and</claim-text>
<claim-text>a secondary replication agent of the secondary database adapted to execute on at least one secondary processor in communication with the primary replication agent and the secondary database,</claim-text>
<claim-text>wherein the primary database, the primary replication agent, the secondary database and the secondary replication agent are configured to:</claim-text>
<claim-text>receive, by the secondary replication agent of the secondary database, the at least one database write statement from the primary replication agent;</claim-text>
<claim-text>store the database write statement to a transaction log at the secondary replication agent;</claim-text>
<claim-text>receive, by the primary replication agent, a prepare message from the client;</claim-text>
<claim-text>send, by the primary replication agent, the prepare to commit message to the secondary replication agent;</claim-text>
<claim-text>send, by the secondary replication agent, an acknowledgment of the prepare to commit message to the primary replication agent;</claim-text>
<claim-text>send, by the primary replication agent, an acknowledgment of the prepare to commit message to the client;</claim-text>
<claim-text>receive, by the primary database, a first commit message from the client;</claim-text>
<claim-text>receive, by the primary replication agent, a second commit message from the client upon determination that the first commit message has been successfully performed at the primary database;</claim-text>
<claim-text>send, by the primary replication agent, the second commit message to the secondary replication agent;</claim-text>
<claim-text>send, by the secondary replication agent, an acknowledgment to the primary replication agent;</claim-text>
<claim-text>send, by the primary replication agent, an acknowledgment to the client;</claim-text>
<claim-text>asynchronously perform, by the secondary replication agent, the at least one database write statement on the secondary database.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The system of <claim-ref idref="CLM-00010">claim 10</claim-ref> wherein the transaction log is stored in at least one of a memory and a log file.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The system of <claim-ref idref="CLM-00010">claim 10</claim-ref> wherein the primary replication agent is configured to receive the database write statement of a transaction in substantially a same time period as the primary database.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The system of <claim-ref idref="CLM-00010">claim 10</claim-ref> wherein the primary replication agent is further configured to enable a lock for a transaction to maintain a transaction sequence in the primary database, the primary replication agent, the secondary replication agent, and the secondary database.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The system of <claim-ref idref="CLM-00013">claim 13</claim-ref> wherein the primary replication agent is further configured to have the lock released.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The system of <claim-ref idref="CLM-00010">claim 10</claim-ref> wherein the primary replication agent is further configured to generate a sequence number for the transaction to maintain sequence for transactions competing to update the primary database and the secondary database.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The system of <claim-ref idref="CLM-00015">claim 15</claim-ref> wherein the secondary replication agent controls a sequence of the database write statement applied to the secondary database at least in part based upon the sequence number.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The system of <claim-ref idref="CLM-00016">claim 16</claim-ref> wherein the secondary replication agent controls a sequence of the database write statement at least in part by the sequence number when the database write statement is in direct conflict with another database write statement.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The system of <claim-ref idref="CLM-00017">claim 17</claim-ref> wherein the direct conflict comprises one or more of an attempt to write to a same row of the secondary database and an attempt to write to a same field on the same row of the secondary database.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. A system for scalable replication of a relational database comprising:
<claim-text>a first independent shard database comprising a first shard primary database adapted to receive a database data modification of a transaction from a client, wherein the first shard primary database includes a segment group of database rows and is configured to receive messages from a client based on the specific database rows related to a transaction;</claim-text>
<claim-text>a first shard primary replication agent adapted to execute on at least one first shard primary processor in communication with the first shard primary database;</claim-text>
<claim-text>a first shard secondary database adapted to receive the database modification of the transaction from the client, wherein the first shard secondary database includes a segment group of database rows and is configured to receive messages to an appropriate shard based on the specific database rows related to a transaction; and</claim-text>
<claim-text>a first shard secondary replication agent adapted to execute on at least one first shard secondary processor in communication with the first shard primary replication agent,</claim-text>
<claim-text>wherein the first independent shard database, the first shard primary replication agent, the first shard secondary database and the first shard secondary replication agent are configured to:</claim-text>
<claim-text>receive, by the first shard database and the first shard primary replication agent, at least one database write statement from a client;</claim-text>
<claim-text>relay, by the first shard primary replication agent, the at least one database write statement to the first secondary shard replication agent wherein the first secondary shard replication agent asynchronously performs the at least one database write statement on the first shard secondary database;</claim-text>
<claim-text>receive, by the first shard primary replication agent, a prepare to commit message from the client;</claim-text>
<claim-text>relay, by the first shard primary replication agent, the prepare to commit message to the first shard secondary replication agent;</claim-text>
<claim-text>send, by the first shard secondary replication agent, an acknowledgment to the first shard primary replication agent;</claim-text>
<claim-text>send, by the first shard primary replication agent, an acknowledgment to the client;</claim-text>
<claim-text>receive by the first shard primary database and the first shard primary replication agent, a commit message from the client;</claim-text>
<claim-text>relay, by the first shard primary replication agent, the commit message to the first shard secondary replication agent;</claim-text>
<claim-text>asynchronously perform, by the first shard secondary replication agent, the at least one database write statement on the first shard secondary database; and</claim-text>
<claim-text>commit, by the first shard secondary replication agent, the database write statement to the first shard secondary replication database. </claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
