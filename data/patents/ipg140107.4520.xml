<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08625604-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08625604</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12957995</doc-number>
<date>20101201</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>372</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>H</section>
<class>04</class>
<subclass>L</subclass>
<main-group>12</main-group>
<subgroup>28</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>37039531</main-classification>
</classification-national>
<invention-title id="d2e53">Hash-based prefix-compressed trie for IP route lookup</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6067574</doc-number>
<kind>A</kind>
<name>Tzeng</name>
<date>20000500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709247</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6385649</doc-number>
<kind>B1</kind>
<name>Draves et al.</name>
<date>20020500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709224</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6993025</doc-number>
<kind>B1</kind>
<name>Montuno et al.</name>
<date>20060100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370392</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>7274697</doc-number>
<kind>B2</kind>
<name>Ji et al.</name>
<date>20070900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>7519733</doc-number>
<kind>B1</kind>
<name>Thubert et al.</name>
<date>20090400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709238</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>7539153</doc-number>
<kind>B1</kind>
<name>Liang et al.</name>
<date>20090500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370255</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>7764687</doc-number>
<kind>B1</kind>
<name>Gao et al.</name>
<date>20100700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370392</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>7852852</doc-number>
<kind>B2</kind>
<name>Lynch et al.</name>
<date>20101200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>37039532</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>7990893</doc-number>
<kind>B1</kind>
<name>Singh</name>
<date>20110800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>8089961</doc-number>
<kind>B2</kind>
<name>Sahni et al.</name>
<date>20120100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>8375141</doc-number>
<kind>B2</kind>
<name>Rowstron et al.</name>
<date>20130200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709238</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2002/0023089</doc-number>
<kind>A1</kind>
<name>Woo</name>
<date>20020200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707101</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2002/0129086</doc-number>
<kind>A1</kind>
<name>Garcia-Luna-Aceves et al.</name>
<date>20020900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709200</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2004/0006639</doc-number>
<kind>A1</kind>
<name>Mathew et al.</name>
<date>20040100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>2004/0100960</doc-number>
<kind>A1</kind>
<name>Mehta</name>
<date>20040500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370392</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>2004/0111439</doc-number>
<kind>A1</kind>
<name>Richardson et al.</name>
<date>20040600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707200</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>2004/0114587</doc-number>
<kind>A1</kind>
<name>Huang et al.</name>
<date>20040600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370389</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00018">
<document-id>
<country>US</country>
<doc-number>2005/0038774</doc-number>
<kind>A1</kind>
<name>Lillibridge et al.</name>
<date>20050200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00019">
<document-id>
<country>US</country>
<doc-number>2005/0091443</doc-number>
<kind>A1</kind>
<name>Hershkovich et al.</name>
<date>20050400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711100</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00020">
<document-id>
<country>US</country>
<doc-number>2005/0149513</doc-number>
<kind>A1</kind>
<name>Karlsson</name>
<date>20050700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  3</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00021">
<document-id>
<country>US</country>
<doc-number>2005/0171959</doc-number>
<kind>A1</kind>
<name>Deforche et al.</name>
<date>20050800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707100</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00022">
<document-id>
<country>US</country>
<doc-number>2007/0094313</doc-number>
<kind>A1</kind>
<name>Bolotin</name>
<date>20070400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707205</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00023">
<document-id>
<country>US</country>
<doc-number>2009/0327316</doc-number>
<kind>A1</kind>
<name>Sahni et al.</name>
<date>20091200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00024">
<document-id>
<country>US</country>
<doc-number>2010/0316061</doc-number>
<kind>A1</kind>
<name>Rojas-Cessa et al.</name>
<date>20101200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370417</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00025">
<document-id>
<country>US</country>
<doc-number>2011/0044351</doc-number>
<kind>A1</kind>
<name>Punati et al.</name>
<date>20110200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00026">
<document-id>
<country>US</country>
<doc-number>2011/0128960</doc-number>
<kind>A1</kind>
<name>Bando et al.</name>
<date>20110600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00027">
<document-id>
<country>US</country>
<doc-number>2011/0137930</doc-number>
<kind>A1</kind>
<name>Hao et al.</name>
<date>20110600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707769</main-classification></classification-national>
</us-citation>
</us-references-cited>
<number-of-claims>23</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>370254-256</main-classification>
<additional-info>unstructured</additional-info>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>370389-39532</main-classification>
<additional-info>unstructured</additional-info>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>709200</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>709212</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>709238-247</main-classification>
<additional-info>unstructured</additional-info>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>34</number-of-drawing-sheets>
<number-of-figures>41</number-of-figures>
</figures>
<us-related-documents>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61265397</doc-number>
<date>20091201</date>
</document-id>
</us-provisional-application>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20110128959</doc-number>
<kind>A1</kind>
<date>20110602</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Bando</last-name>
<first-name>Masanori</first-name>
<address>
<city>Cupertino</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Chao</last-name>
<first-name>Hung-Hsiang Jonathan</first-name>
<address>
<city>Holmdel</city>
<state>NJ</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Bando</last-name>
<first-name>Masanori</first-name>
<address>
<city>Cupertino</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Chao</last-name>
<first-name>Hung-Hsiang Jonathan</first-name>
<address>
<city>Holmdel</city>
<state>NJ</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<last-name>Pokotylo</last-name>
<first-name>John C.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<orgname>Straub &#x26; Pokotylo</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Polytechnic Institute of New York University</orgname>
<role>02</role>
<address>
<city>Brooklyn</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Yao</last-name>
<first-name>Kwang B</first-name>
<department>2473</department>
</primary-examiner>
<assistant-examiner>
<last-name>Loo</last-name>
<first-name>Juvena</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A method and apparatus for performing an Internet Protocol (IP) network lookup in a forwarding device including an internal processor memory storing a first next hop information table and membership query information, and an external processor memory storing a plurality of prefix-compressed trees and a second next hop information table is described. In another embodiment consistent with present invention, a method (and apparatus) for creating stored data structures representing network forwarding information used for network route lookup is described.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="219.63mm" wi="203.28mm" file="US08625604-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="238.25mm" wi="205.74mm" file="US08625604-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="251.38mm" wi="198.71mm" file="US08625604-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="210.82mm" wi="189.74mm" file="US08625604-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="229.79mm" wi="143.59mm" orientation="landscape" file="US08625604-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="207.60mm" wi="152.48mm" orientation="landscape" file="US08625604-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="214.12mm" wi="152.48mm" orientation="landscape" file="US08625604-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="252.98mm" wi="183.30mm" orientation="landscape" file="US08625604-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="214.12mm" wi="181.69mm" orientation="landscape" file="US08625604-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="245.70mm" wi="148.42mm" orientation="landscape" file="US08625604-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="185.67mm" wi="158.75mm" orientation="landscape" file="US08625604-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="219.79mm" wi="156.55mm" file="US08625604-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="252.98mm" wi="181.69mm" orientation="landscape" file="US08625604-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="121.67mm" wi="171.96mm" orientation="landscape" file="US08625604-20140107-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="244.09mm" wi="171.11mm" orientation="landscape" file="US08625604-20140107-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="231.14mm" wi="113.54mm" orientation="landscape" file="US08625604-20140107-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00016" num="00016">
<img id="EMI-D00016" he="213.28mm" wi="137.84mm" orientation="landscape" file="US08625604-20140107-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00017" num="00017">
<img id="EMI-D00017" he="250.61mm" wi="141.14mm" orientation="landscape" file="US08625604-20140107-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00018" num="00018">
<img id="EMI-D00018" he="246.55mm" wi="209.21mm" orientation="landscape" file="US08625604-20140107-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00019" num="00019">
<img id="EMI-D00019" he="230.29mm" wi="183.30mm" orientation="landscape" file="US08625604-20140107-D00019.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00020" num="00020">
<img id="EMI-D00020" he="186.01mm" wi="158.75mm" file="US08625604-20140107-D00020.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00021" num="00021">
<img id="EMI-D00021" he="229.53mm" wi="193.80mm" file="US08625604-20140107-D00021.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00022" num="00022">
<img id="EMI-D00022" he="218.69mm" wi="158.75mm" file="US08625604-20140107-D00022.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00023" num="00023">
<img id="EMI-D00023" he="221.40mm" wi="162.22mm" file="US08625604-20140107-D00023.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00024" num="00024">
<img id="EMI-D00024" he="226.23mm" wi="165.44mm" file="US08625604-20140107-D00024.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00025" num="00025">
<img id="EMI-D00025" he="164.59mm" wi="133.77mm" file="US08625604-20140107-D00025.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00026" num="00026">
<img id="EMI-D00026" he="167.05mm" wi="133.01mm" orientation="landscape" file="US08625604-20140107-D00026.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00027" num="00027">
<img id="EMI-D00027" he="134.62mm" wi="160.61mm" file="US08625604-20140107-D00027.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00028" num="00028">
<img id="EMI-D00028" he="116.76mm" wi="158.16mm" file="US08625604-20140107-D00028.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00029" num="00029">
<img id="EMI-D00029" he="133.01mm" wi="171.11mm" file="US08625604-20140107-D00029.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00030" num="00030">
<img id="EMI-D00030" he="108.71mm" wi="154.09mm" file="US08625604-20140107-D00030.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00031" num="00031">
<img id="EMI-D00031" he="227.08mm" wi="122.43mm" orientation="landscape" file="US08625604-20140107-D00031.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00032" num="00032">
<img id="EMI-D00032" he="244.09mm" wi="120.82mm" orientation="landscape" file="US08625604-20140107-D00032.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00033" num="00033">
<img id="EMI-D00033" he="244.94mm" wi="127.34mm" orientation="landscape" file="US08625604-20140107-D00033.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00034" num="00034">
<img id="EMI-D00034" he="115.99mm" wi="158.92mm" file="US08625604-20140107-D00034.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">&#xa7;0. RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">This application claims the benefit of U.S. Provisional Patent Application Ser. No. 61/265,397 (incorporated herein by reference and referred to as &#x201c;the '397 provisional&#x201d;), titled &#x201c;FLASH TRIE: HASH-BASED COMPACT TRIE FOR IP ROUTE LOOKUP BEYOND 100 Gbps,&#x201d; filed on Dec. 1, 2009 and listing Masanori BANDO and H. Jonathan CHAO as the inventors. The present invention is not limited to requirements of the particular embodiments described in the '397 provisional.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">&#xa7;1. BACKGROUND OF THE INVENTION</heading>
<p id="p-0003" num="0002">&#xa7;1.1. Field of the Invention</p>
<p id="p-0004" num="0003">Embodiments consistent with the claimed invention concern Internet Protocol (&#x201c;IP&#x201d;) networks. In particular, embodiments consistent with the claimed invention concern hash-based route lookup methods and apparatus.</p>
<p id="p-0005" num="0004">&#xa7;1.2. Background Information</p>
<p id="p-0006" num="0005">In IP route lookup, a system (such as a router, for example) extracts each incoming packet's destination IP address and performs a longest prefix match with stored routes. Ternary content-addressable memory (&#x201c;TCAM&#x201d;) based schemes are widely used in midrange routers. (See, e.g., the articles: F. Zane, G. Narlikar and A. Basu, &#x201c;CoolCAMs: Power-Efficient TCAMs for Forwarding Engines,&#x201d; in <i>Proc of INFOCOM</i>, Vol. 1, pp. 42-52, (2003); and K. Zheng, C. Hu, H. Lu and B. Liu, &#x201c;A TCAM-Based Distributed Parallel IP Lookup Scheme and Performance Analysis,&#x201d; <i>IEEE/ACM Transactions on Networking</i>, Vol. 14, No. 4, pp. 863-875 (2006), each of which is incorporated herein by reference.) Unfortunately, however, their high cost and large power consumption make them unattractive for high-end routers such as so-called core routers.</p>
<p id="p-0007" num="0006">Direct lookup schemes can use standard SRAM or DRAM to store the next hop for each prefix, in a table or multiple tables that are addressed by the prefix. However, such schemes are only effective for short address lookups (e.g., less than 16 bits), and are not practical for longer lookups due to prefix expansion. (See, e.g., the articles: P. Gupta, S. Lin and N. McKeown, &#x201c;Routing Lookups in Hardware at Memory Access Speeds,&#x201d; in <i>Proc of the IEEE Computer and Communications Societies </i>(<i>INFOCOM </i>1998), Vol. 3, pp. 1240-1247 (March/April 1998); N.-F. Huang and S.-M. Zhao, &#x201c;A Novel IP-Routing Lookup Scheme and Hardware Architecture for Multigigabit Switching Routers,&#x201d; <i>IEEE Journal on Selected Areas in Comm</i>, Vol. 17, No. 6, pp. 1093-1104 (June 1999); N.-F. Huang, S.-M. Zhao, J.-Y. Pan and C.-A. Su, &#x201c;A Fast IP Routing Lookup Scheme for Gigabit Switching Routers,&#x201d; in <i>Proc. of the IEEE Computer and Communications Societies </i>(<i>INFOCOM </i>1999), Vol. 3, pp. 1429-1436, (March 1999); and V. Srinivasan and G. Varghese, &#x201c;Fast Address Lookups using Controlled Prefix Expansion,&#x201d; <i>ACM Transactions on Computer Systems</i>, Vol. 17, No. 1, pp. 1-40, (1999), each of which is incorporated herein by reference.)</p>
<p id="p-0008" num="0007">To avoid the prohibitively large memory requirements of direct lookup schemes due to prefix expansion, hash-based lookup schemes have been proposed. (See, e.g., the articles: S. Cadambi, S. Chakradhar, and H. Shibata, &#x201c;Prefix Processing Technique for Faster IP Routing,&#x201d; U.S. Pat. No. 7,398,278; S. Kaxiras and G. Keramidas, &#x201c;IPStash: A Set-associative Memory Approach for Efficient IP-Lookup,&#x201d; in <i>Proc. of INFOCOM</i>, Vol. 2, pp. 992-1001 (2005); J. Hasan, S. Cadambi, V. Jakkula and S. Chakradhar, &#x201c;Chisel: A Storage-efficient, Collision-free Hash-based Network Processing Architecture,&#x201d; in <i>Proc of ISCA</i>, pp. 203-215 (2006); H. Song, S. Dharmapurikar, J. Turner, and J. Lockwood, &#x201c;Fast Hash Table Lookup Using Extended Bloom Filter: An Aid to Network Processing,&#x201d; in <i>Proc. of SIGCOMM</i>, pp. 181-192 (2005); S. Dharmpurikar, P. Krishnamurthy and D. E. Taylor, &#x201c;Longest Prefix Matching Using Bloom Filters,&#x201d; <i>IEEE/ACM Transactions on Networking</i>, Vol. 14, No. 2, pp. 397-409 (2006); H. Song, F. Hao, M. Kodialam and T. Lakshman, &#x201c;IPv6 Lookups using Distributed and Load Balanced Bloom Filters for 100 Gbps Core Router Line Cards,&#x201d; in <i>Proc of INFOCOM</i>, pp. 2518-2526 (2009); and M. Bando, N. S. Artan, and H. J. Chao, &#x201c;FlashLook: 100 Gbps Hash-Tuned Route Lookup Architecture,&#x201d; in <i>Proc. of HPSR, </i>2009, each of which is incorporated herein by reference.) Whether applying a hash function to each prefix length or to a certain prefix length (e.g., /16, /24 and /32 for IPv4), those prefixes are hashed to a table. Various methods have been proposed to reduce the number of prefixes hashed to the same entry of the hash table. Bloom filters are sometimes used to query the existence of the prefix before finding the next hop information (&#x201c;NHI&#x201d;) of the prefix.</p>
<p id="p-0009" num="0008">Hardware trie-based schemes can achieve high throughput. However, they require many memory chips in parallel to accommodate the pipelined stages required by the many levels of the trie (which has a height proportional to the number of bits in the IP address). (See, e.g., the articles: W. Eatherton, G. Varghese and Z. Dittia, &#x201c;Tree Bitmap: Hardware/Software IP Lookups with Incremental Updates,&#x201d; <i>ACM SIGCOMM Computer Communication Review</i>, Vol. 34, No. 2, pp. 97-122 (2004); S. Sikka and G. Varghese, &#x201c;Memory-Efficient State Lookups with Fast Updates,&#x201d; in <i>Proc. of SIGCOMM </i>2000 pp. 335-347 (2000); R. Sangireddy, N. Futamura, S. Aluru and A. K. Somani, &#x201c;Scalable, Memory Efficient, High-Speed IP Lookup Algorithms,&#x201d; <i>IEEE/ACM Transactions on Networking</i>, Vol. 13, No. 4, pp. 802-812 (2005); H. Song, J. Turner, and J. Lockwood, &#x201c;Shape Shifting Tries for Faster IP Route Lookup,&#x201d; in <i>Proc. of ICNP, </i>2005; A. Basu and G. Narlikar, &#x201c;Fast Incremental Updates for Pipelined Forwarding Engines,&#x201d; <i>IEEE/ACM Transactions on Networking</i>, Vol. 13, No. 3, pp. 690-703 (2005); and W. Jiang and V. K. Prasanna, &#x201c;Multi-Terabit IP Lookup Using Parallel Bidirectional Pipelines,&#x201d; in <i>Proc. of CF</i>, pp. 241-250 (2008), each of which is incorporated by reference.) This is especially a problem for IPv6, which has a larger number of bits in the address.</p>
<p id="p-0010" num="0009">Multibit-trie architectures, such as Tree Bitmap, have gained much attention because they can reduce the number of pipeline stages, and because of their efficient data structures. Each Tree Bitmap node contains two pieces of information: (1) an Internal Bitmap of the sub-trie and a pointer for the NHI; and (2) an External Bitmap for a head pointer to the block of child nodes and a bitmap for child sub-tries. As a result, one lookup requires multiple off-chip memory accesses. To reduce the number of off-chip memory accesses, H. Song et al. proposed Shape Shift Tries (&#x201c;SST&#x201d;), which allow the number of trie levels in each access to be flexible. (H. Song et al, <i>Proc. of ICNP, </i>2005) SST can achieve approximately 50% reduction in memory accesses compared to the Tree Bitmap. Although this reduction is significant, the number of memory accesses required by the SST is still considerable. In addition, SST is only suitable for sparse tries, limiting its application to future routers.</p>
<p id="p-0011" num="0010">A different way to reduce memory accesses in the Tree Bitmap architecture is to increase the &#x201c;stride size&#x201d;. The stride of an array of data refers to the number of locations in memory between successive array elements, measured in bytes or in units of the size of the array's elements. However, increasing the stride size will increase the bitmap size exponentially and result in more off-chip memory accesses, which limit system performance. Another disadvantage for choosing a large stride size is that update speed may be degraded. This is because there will be more child nodes in each trie, and they are stored in consecutive memory locations. Whenever a new child node is added, many other child nodes are moved to other memory locations. In the worst case, an entire block of child nodes is relocated.</p>
<p id="p-0012" num="0011">Another typical drawback of trie-based schemes is their uneven distribution of data structures in memory. Usually in the tries, the lower level contains many more prefixes than the higher level. Each pipeline stage consists of either one level or multiple levels in the trie, and typically stores the information of its prefixes in a memory bank. As the number of prefixes differs drastically from stage to stage, the loading among memory modules is quite uneven, resulting in low memory utilization. In W. Jiang, et al, the authors proposed a solution to balance the pipeline memory. (W. Jiang, et al, <i>Proc. of CF, </i>2008, pp. 241-250) However, their scheme uses twenty-five independent memory chips resulting in a high cost. The number of memory chips required is even more when IPv6 is to be supported.</p>
<p id="p-0013" num="0012">In view of the foregoing, it would be useful to provide a route lookup system that overcomes one or more of the above-described limitations.</p>
<heading id="h-0003" level="1">&#xa7;2. SUMMARY OF THE INVENTION</heading>
<p id="p-0014" num="0013">In one exemplary embodiment consistent with present invention, a method (and apparatus) for performing an Internet Protocol (IP) network lookup in a forwarding device including an internal processor memory storing a first next hop information table and membership query information, and an external processor memory storing a plurality of prefix-compressed trees and a second next hop information table is described. The exemplary method includes (1) receiving, as input by the forwarding device, an IP network address of a destination device, to determine next hop information indicating a network address of a next hop device to which a data packet is to be sent on the way to the data packet's final destination; (2) determining, by the forwarding device, a first set of next hop information using the received IP network address by performing a direct memory lookup of a first next hop information table stored in the internal processing memory of the forwarding device; (3) determining, by the forwarding device, a location of a prefix-compressed trie, stored in external processor memory, using the received network address by performing a query of membership query information stored in internal processor memory; (4) searching, by the forwarding device, the prefix-compressed trie at the determined location using the received IP network address, to determine a location and an offset within a second next hop information table, stored in external processor memory, which stores the desired next hop information; (5) determining, by the forwarding device, a second set of next hop information using (i) the determined location and (ii) the offset within the second next hop information table; and (6) determining, by the forwarding device, which of the first set of next hop information and the second set of next hop information has a longest match of the received IP network address.</p>
<p id="p-0015" num="0014">In another embodiment consistent with present invention, a method (and apparatus) for creating stored data structures representing network forwarding information used for network route lookup is described. The exemplary method includes (1) accepting, by a first device, a routing table including one or more sets of forwarding information, wherein each set of forwarding information includes at least (A) a prefix of destination addresses and (B) next hop information associated with the prefix; (2) creating, by the first device, a first next hop information lookup table, using the accepted routing table; (3) creating, by the first device, a plurality of prefix-compressed tries using the accepted routing table; (4) creating, by the first device, membership query information using the plurality of prefix-compressed tries; (5) creating, by the first device, a second next hop information lookup table using the plurality of the prefix-compressed tries; (6) storing, by the first device, the first next hop information lookup table in an internal processor memory of a first forwarding device; (7) storing, by the first device, the plurality of prefix-compressed tries in an external processor memory of the first forwarding device; (8) storing, by the first device, the membership query information in the internal processor memory of the first forwarding device; and (9) storing, by the first device, the second next hop information lookup table in the external processor memory of the first forwarding device.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">&#xa7;3. BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 1</figref> illustrates an overview of an exemplary FlashTrie architecture with an example routing table which may be used in exemplary embodiments consistent with the present invention.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 2</figref> includes <figref idref="DRAWINGS">FIGS. 2A and 2B</figref> and illustrates a bitmap transformation from Binary-Trie to (a) Tree Bitmap, (b) Prefix-Compressed Trie 2, and (c) Prefix-Compressed Trie 4, in accordance with at least one exemplary embodiment consistent with the present invention.</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 3</figref> illustrates a block diagram of an exemplary Membership Query Module consistent with the present invention.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 4</figref> illustrates a HashTune example in accordance with at least one exemplary embodiment consistent with the present invention.</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 5</figref> illustrates IPv4 prefix distribution from 2003 to 2010.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 6</figref> illustrates synthesized IPv6 prefix distribution (based on IPv4 routing tables).</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 7</figref> includes <figref idref="DRAWINGS">FIGS. 7A and 7B</figref> and illustrates an architecture and lookup operation in accordance with at least one exemplary embodiment consistent with the present invention.</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 8</figref> illustrates an on-chip memory update for (a) Direct NHI Programming, and (b) Indirect NHI Programming in accordance with at least one exemplary embodiment consistent with the present invention.</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 9</figref> illustrates an on-chip memory update detail (a) before an update is applied, and (b) after an update is applied in Level 1 in accordance with at least one exemplary embodiment consistent with the present invention.</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 10</figref> illustrates a DRAM memory data allocation in accordance with at least one exemplary embodiment consistent with the present invention.</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 11</figref> illustrates off-chip memory requirements of TreeBitmap versus a FlashTrie architecture consistent with the present invention.</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 12</figref> includes <figref idref="DRAWINGS">FIGS. 12A and 12B</figref> and illustrates a DRAM memory access timing diagram.</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 13</figref> illustrates a DRAM memory access timing diagram for Tree Bitmap versus a FlashTrie architecture consistent with the present invention.</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 14</figref> illustrates an exemplary incremental verify bits optimization consistent with the present invention.</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 15</figref> illustrates an exemplary incremental verify bits optimization for IPV6 consistent with the present invention.</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 16</figref> is hardware block diagram of an exemplary embodiment consistent with the present invention.</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 17</figref> illustrates an exemplary membership query module consistent with the present invention.</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 18</figref> illustrates details of an exemplary PC-Trie address generator consistent with the present invention.</p>
<p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. 19</figref> illustrates a block diagram of an exemplary PC-Trie processing unit consistent with the present invention.</p>
<p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. 20</figref> is a block diagram of an exemplar NHI processing unit consistent with the present invention.</p>
<p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. 21</figref> is a flow diagram of an exemplary Internet Protocol (IP) network lookup method consistent with the present invention.</p>
<p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. 22</figref> is a flow diagram of an exemplary method for creating and storing data structures representing network forwarding information used for network route lookup consistent with the present invention.</p>
<p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. 23</figref> is a flow diagram of an exemplary method for creating and storing data structures representing network forwarding information used for network route lookup consistent with the present invention.</p>
<p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. 24</figref> is a flow diagram of a first exemplary method for updating data structures representing network forwarding information used for network route lookup consistent with the present invention.</p>
<p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. 25</figref> is a flow diagram of a second exemplary method for updating data structures representing network forwarding information used for network route lookup consistent with the present invention.</p>
<p id="p-0041" num="0040"><figref idref="DRAWINGS">FIG. 26</figref> is a flow diagram of a third exemplary method for updating data structures representing network forwarding information used for network route lookup consistent with the present invention.</p>
<p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. 27</figref> is a block diagram of an exemplary apparatus that may be used to practice at least some aspects of the invention.</p>
<p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. 28</figref> presents Table I, which includes the number of sub-tries in each level and the total sub-tries for the three routing tables used in discussing the performance evaluation of an exemplary embodiment consistent with the present invention.</p>
<p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. 29</figref> presents Table II, which includes on-chip memory requirements for: (1) storing information required for direct lookup for up to /15(IPv4) or /12(IPv6), (2) storing hash tables used for membership queries, (3) storing a hash ID table (storing a hash ID for each group), and (4) Black Sheep memories for storing collided items in the hash table.</p>
<p id="p-0045" num="0044"><figref idref="DRAWINGS">FIG. 30</figref> presents Table III, which summarizes the on-chip memory configurations for the determined the number of groups and bins in each group, which were determined from simulation results dining performance evaluation of an exemplary embodiment consistent with the present invention.</p>
<p id="p-0046" num="0045"><figref idref="DRAWINGS">FIG. 31</figref> presents Table IV, which summarizes PC-Trie bitmap off-chip memory requirements compared with Tree Bitmap memory requirements.</p>
<p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. 32</figref> presents Table V, which summarizes Next Hop Information (NHI) off-chip memory requirements compared with Tree Bitmap memory requirements.</p>
<p id="p-0048" num="0047"><figref idref="DRAWINGS">FIG. 33</figref> presents Table VI, which summarizes on-chip memory requirements of using multiple keys per bin.</p>
<p id="p-0049" num="0048"><figref idref="DRAWINGS">FIG. 34</figref> presents Table VII, which summarizes on-chip memory requirements of multi-keys and verify bits bypassing.</p>
<p id="p-0050" num="0049"><figref idref="DRAWINGS">FIG. 35</figref> presents Table VIII, which summarizes hardware resource requirements of an exemplary embodiment consistent with the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">&#xa7;4. DETAILED DESCRIPTION</heading>
<p id="p-0051" num="0050">Embodiments consistent with the claimed invention may involve novel methods, apparatus, message formats, and/or data structures for providing low-cost, high-speed, next generation route lookup architecture that can support two million (2M) IPv4, and 318 thousand (318K) IPv6, routes simultaneously. The following description is presented to enable one skilled in the art to make and use the invention, and is provided in the context of particular applications and their requirements. Thus, the following description of embodiments consistent with the claimed invention provides illustration and description, but is not intended to be exhaustive or to limit the present invention to the precise form disclosed. Various modifications to the disclosed embodiments will be apparent to those skilled in the art, and the general principles set forth below may be applied to other embodiments and applications. For example, although a series of acts may be described with reference to a flow diagram, the order of acts may differ in other implementations when the performance of one act is not dependent on the completion of another act. Further, non-dependent acts may be performed in parallel. Also, as used herein, the article &#x201c;a&#x201d; is intended to include one or more items. Where only one item is intended, the term &#x201c;one&#x201d; or similar language is used. In the following, &#x201c;information&#x201d; may refer to the actual information, or a pointer to, identifier of, or location of such information. No element, act or instruction used in the description should be construed as critical or essential to the present invention unless explicitly described as such. Thus, the present invention is not intended to be limited to the embodiments shown and the inventors regard their invention to include any patentable subject matter described.</p>
<heading id="h-0006" level="1">&#xa7;4.1 Flashtrie Overview</heading>
<p id="p-0052" num="0051">An overview of an exemplary FlashTrie architecture, with an exemplary routing table, is shown in <figref idref="DRAWINGS">FIG. 1</figref>. The routing table has ten (10) routes for which corresponding prefixes and next hop information (&#x201c;NHI&#x201d;) are shown in the table. The binary trie for this routing table is constructed next to the routing table. The binary trie is divided into different &#x201c;levels&#x201d; based on these k-bit sub-tries (k=4 in this example). Thus, Level 0 contains prefixes of prefix length 0 to prefix length 3, Level 1 contains prefixes of prefix length 4 to prefix length 7, and so on. Each level contains one or more sub-tries.</p>
<p id="p-0053" num="0052">All sub-tries should be independent among different levels in the FlashTrie architecture so that off-chip memory access is reduced (e.g., such that only one is needed). For example, in <figref idref="DRAWINGS">FIG. 1</figref>, the sub-trie that contains prefixes P7 and P9 does not have NHI in the root node. This means, empty nodes (e.g., nodes that are not related to P7 and P9) in this sub-trie depend on the node present one level up (P4 in the example). To remove this dependency, the NHI of P4 is copied to the root of the sub-trie (ST3) illustrated as an arrow.</p>
<p id="p-0054" num="0053">The sub-tries are converted to a new compressed trie called &#x201c;Prefix-Compressed Trie&#x201d; (or &#x201c;PC-Trie&#x201d;), described in &#xa7;4.1.1 below, which is then stored in off-chip memory. In the actual system, all root nodes may be stored in on-chip memory, which facilitates easy updating. The top level (Level 0) uses a direct lookup approach, so ST0 is not a PC-Trie and is stored in on-chip memory.</p>
<p id="p-0055" num="0054">One advantage of the exemplary FlashTrie architecture is that it uses only one off-chip memory access to resolve IPv4/IPv6 trie. To ensure only one off-chip memory access, lightweight, on-chip hash modules are deployed to perform membership queries. An optimized hash data structure, called HashTune (described in M. Bando, N. S. Artan, and H. J. Chao, &#x201c;FlashLook: 100 Gbps Hash-Tuned Route Lookup Architecture,&#x201d; in Proc. of HPSR, 2009, which is incorporated by reference), may be used for the hash function. An exemplary hash data structure is discussed in &#xa7;4.1.2 below.</p>
<p id="p-0056" num="0055">The hash tables are queried to find the existence of a sub-trie at each level in parallel. Since there are multiple levels, there could be matches in more than one level at a time. This is resolved based on prioritizing the matches such that the longest prefix has the highest priority. Thus, only the longest matching sub-trie is accessed from off-chip memory. The number of off-chip memory accesses is limited by this on-chip membership operation. This operation is illustrated on the right side of <figref idref="DRAWINGS">FIG. 1</figref>. Section 4.1.1 explains an exemplary compressed data structure Prefix-Compressed Trie (PC-Trie) and exemplary membership query operations.</p>
<p id="p-0057" num="0056">&#xa7;4.1.1 Exemplary Prefix-Compressed Trie</p>
<p id="p-0058" num="0057">The number of memory accesses per lookup (ideally, one memory access) is also controlled by managing bitmap size. Current DRAMs have, at most, a 16-bit data bus and a burst size of 8, so one DRAM access can read or write, at most, 128 bits. Thus, any bitmap size exceeding 128 bits requires multiple memory accesses to a current DRAM. This significantly degrades lookup performance (speed). In Tree Bitmap, the internal bitmap has (2<sup>stride</sup>&#x2212;1) bits and the external bitmap consumes 2<sup>stride </sup>bits. Thus, the 9-bit stride size requires more than 1 k bits, which requires multiple off-chip memory accesses. The Tree Bitmap scheme (supra paragraph [0007]) does not involve any bitmap compression technique. Hence, the bitmap size increases exponentially. Although the Tree Bitmap scheme proposes two optimizations&#x2014;split tree bitmap and segmented bitmap&#x2014;they are not sufficient. Using split tree bitmap, the internal and external bitmaps are stored in separate memories. This way, the Tree Bitmap node is reduced to nearly half the actual size. Still, one bitmap size is too big to be fetched from an off-chip memory access. With segmented bitmap, the original bitmap is cut in half each time it is segmented. However, each segmented node must have a pointer, which eventually creates considerable overhead. As a result, segmented bitmap optimization actually increases the total memory requirement. These two optimizations, as well as other Tree Bitmap types of data structures, suffer from the same problem.</p>
<p id="p-0059" num="0058">To overcome these problems, the PC-Trie data structure is proposed as illustrated in <figref idref="DRAWINGS">FIG. 2</figref>. The main difference between Tree Bitmap and the PC-Trie data structure is that a bit in the Tree Bitmap represents only one node, while a bit in a PC-Trie represents more than one node. More specifically, one bit of the PC-Trie can represent consecutive nodes (called &#x201c;siblings&#x201d;) in the same prefix length.</p>
<p id="p-0060" num="0059">The example in <figref idref="DRAWINGS">FIG. 2</figref> shows one sub-trie that includes five prefixes (*, 1*, 00*, 11*, 100*) and the corresponding NHI (A, B, C, D, E). In Step <b>1</b> of <figref idref="DRAWINGS">FIG. 2</figref>, the routing table is simply translated into a binary trie representation. <figref idref="DRAWINGS">FIG. 2(</figref><i>a</i>) shows Tree Bitmap for the given routing table. Since Tree Bitmap simply converts the binary trie representation to the bitmap representation, Step <b>2</b> and Step <b>3</b> of <figref idref="DRAWINGS">FIG. 2</figref> are the same as in the binary trie. Bit positions in the bitmap are set to &#x201c;1&#x201d; at the locations that have a prefix, and set to &#x201c;0&#x201d; otherwise, as shown in the Final Data Structure in <figref idref="DRAWINGS">FIG. 2</figref>. PC-Trie2 in <figref idref="DRAWINGS">FIG. 2(</figref><i>b</i>) illustrates the conversion process from a binary trie to PC-Trie2. The suffix (i.e., the number) represents the compression degree. PC-Trie2 means the compression of two sibling nodes into one. The two sibling bits that are compressed are marked by a dotted circle. This set of nodes is denoted as a node set.</p>
<p id="p-0061" num="0060">Construction of the PC-Trie has two rules: (1) all sibling nodes must be filled with NHI if at least one node in the node set contains NHI; and (2) the parents node set can be deleted if all child node sets exist. The first rule requires that if the sibling is not present, NHIs are copied and filled with either the parent's or the ancestor's NHI. (See for example, the PC-Trie in Step <b>2</b> of <figref idref="DRAWINGS">FIG. 2</figref>.) Prefixes C, D, and E are the only children with an empty sibling. The empty siblings of C, D, and E need to be filled with their respective parent's or ancestor's NHI. In the example shown in <figref idref="DRAWINGS">FIG. 2</figref>, A is the parent of empty sibling C, and B is the parent of empty sibling D and the grandparent of empty sibling E. Thus, Step <b>3</b> of <figref idref="DRAWINGS">FIG. 2</figref> shows all the empty siblings filled with their respective parent's or ancestor's NHI. Applying the second rule, a node set that contains A and B can be eliminated. In the Final Data Structure step, the bitmap is constructed from the PC-Trie.</p>
<p id="p-0062" num="0061">Only one bit is required to represent two nodes. As a result, the bitmap size is reduced from 15 bits to 7 bits (a reduction of more than half). Similarly, a higher degree of compression can be achieved to further reduce the bitmap size. The bitmap size for the n degree of compression can be formulated as PC-Trie n=2<sup>(s-log 2(n)-1) </sup>bits where s is the stride size (in bits). Thus, for a PC-Trie 8 and 9-bit stride (n=8, s=9), the PC-Trie requires 63 bits as compared to 511 bits for the Tree Bitmap. Construction procedures of PC-Trie4 (i.e., the compression of four sibling nodes into one) are also illustrated in <figref idref="DRAWINGS">FIG. 2(</figref><i>c</i>).</p>
<p id="p-0063" num="0062">Although <figref idref="DRAWINGS">FIG. 2</figref> shows that NHI may need to be duplicated (for example, six NHIs are needed for the compressed PC-Trie2, while the original number of NHIs is five), the number of memory slots needed for the NHI table is reduced. For example, as shown in <figref idref="DRAWINGS">FIG. 2</figref>, Tree Bitmap needs five slots while PC-Trie2 needs only three. The size of an NHI is so small (e.g. 8 bits) that multiple NHIs can be stored into a single memory slot. A single DRAM read (e.g., 128 bits) for a memory slot effectively fetches multiple NHIs. This not only results in a more compact memory footprint, but more importantly, the number of memory accesses required is the same as that before compression, if not fewer. Both IPv4 and IPv6 NHI can simultaneously be fit in one bank of a DRAM chip after compressing the bitmap. A high compression rate is also available in PC-Trie. Algorithm 1 shows pseudo-code to construct a PC-Trie as explained above.</p>
<p id="p-0064" num="0063">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Algorithm 1 Prefix-Compressed Trie Construction</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="42pt" align="center"/>
<colspec colname="2" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry>&#x2002;1:</entry>
<entry>Prefix-Compressed Trie (SubTrie[ ], stride, compSize)</entry>
</row>
<row>
<entry>&#x2002;2:</entry>
<entry>//All Sub-Tries</entry>
</row>
<row>
<entry>&#x2002;3:</entry>
<entry>for (i=0 to SubTrie.Length; i++) do</entry>
</row>
<row>
<entry>&#x2002;4:</entry>
<entry>&#x2003;//All PC-Trie node</entry>
</row>
<row>
<entry>&#x2002;5:</entry>
<entry>&#x2003;for (s=compSize-1 to 2<sup>Stride</sup>; s=s+compSize) do</entry>
</row>
<row>
<entry>&#x2002;6:</entry>
<entry>&#x2003;&#x2003;//All nodes in a PC-Trie node</entry>
</row>
<row>
<entry>&#x2002;7:</entry>
<entry>&#x2003;&#x2003;for (t=s to s+compSize-1: t++) do</entry>
</row>
<row>
<entry>&#x2002;8:</entry>
<entry>&#x2003;&#x2003;&#x2003;if (At least one prefix exist in an CompNode) then</entry>
</row>
<row>
<entry>&#x2002;9:</entry>
<entry>&#x2003;&#x2003;&#x2003;&#x2003;[Fill the PC-Trie node with proper NHI]</entry>
</row>
<row>
<entry>10:</entry>
<entry>&#x2003;&#x2003;&#x2003;end if</entry>
</row>
<row>
<entry>11:</entry>
<entry>&#x2003;&#x2003;end for</entry>
</row>
<row>
<entry>12: </entry>
<entry>&#x2003;end for</entry>
</row>
<row>
<entry>13:</entry>
<entry>&#x2003;//Eliminate Redundancy</entry>
</row>
<row>
<entry>14:</entry>
<entry>&#x2003;for (ns=0 to ns=compSize; ns++) do</entry>
</row>
<row>
<entry>15:</entry>
<entry>&#x2003;&#x2003;if (A PC-Trie node has both child PC-Trie nodes.)</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;then</entry>
</row>
<row>
<entry>16:</entry>
<entry>&#x2003;&#x2003;&#x2003;[Remove the PC-Trie node.]</entry>
</row>
<row>
<entry>17:</entry>
<entry>&#x2003;&#x2003;end if</entry>
</row>
<row>
<entry>18:</entry>
<entry>&#x2003;end for</entry>
</row>
<row>
<entry>19:</entry>
<entry>end for</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0065" num="0064">&#xa7;4.1.2 Membership Queries</p>
<p id="p-0066" num="0065">As mentioned above, one of the features of the exemplary FlashTrie data structure is that only one off-chip memory access for an IPv4/IPv6 trie is required. To ensure this, each off-chip memory access must return the intended PC-Trie for the queried input IP address. Otherwise, additional memory accesses would be required to determine the longest matching prefix in the upper level of the sub-trie. FlashTrie performs on-chip membership queries to achieve this. The most popular architecture to perform membership queries is the bloom filter. (See, e.g., B. Bloom, &#x201c;Space/Time Trade-offs in Hash Coding with Allowable Errors,&#x201d; <i>Communications of the ACM</i>, Vol. 13, No. 7 (1970), which is incorporated by reference.) The most recognized advantage of the bloom filter is that the result is free from false negatives.</p>
<p id="p-0067" num="0066">However, the result still contains false positives. False positives can be reduced by increasing the number of hash functions per lookup, the size of the hash table, or both. Achieving a lower false-positive rate requires a considerable amount of resources and many parallel hash functions that increase system complexity and downgrade system performance. Even after all the effort, the false-positive rate will still not converge at zero. This issue is solved by using an exact match operation along with a hash function. Each entry of the hash table holds all or a portion of the root IP address of the programmed sub-trie. This entry is referred to as &#x201c;verify bits&#x201d; and performs an exact matching operation with the input IP address. Hash functions inherently do not have any false negatives. By means of an exact matching operation, the elimination of false positives is ensured as well. This operation is discussed below in &#xa7;4.1.2.1.</p>
<p id="p-0068" num="0067">&#xa7;4.1.2.1 Exemplary Membership Query Module</p>
<p id="p-0069" num="0068">The basic function of the membership query module is to take an IP address as input, process it, and return a corresponding PC-Trie address. A block diagram of an exemplary membership query module is shown in <figref idref="DRAWINGS">FIG. 3</figref>. In a programming phase, all sub-tries are hashed and the contents of hash tables are constructed off-line. HashTune (supra paragraph [0048], infra &#xa7;4.1.2.2) may be used as the hash function. Using HashTune is advantageous because it has a compact data structure and better memory utilization. Since a hash function is used, there are possible collisions. Therefore, the hash table has two different entries: one each for collision cases and another for non-collision cases as shown in <figref idref="DRAWINGS">FIG. 3</figref>. If the hash table entry has a collision, then its Least-Significant Bit (&#x201c;LSB&#x201d;) is set to &#x201c;1&#x201d;; otherwise, it is set to &#x201c;0&#x201d; for no collision. The collided items are stored in Black Sheep (&#x201c;BS&#x201d;) memory located in the membership query module.</p>
<p id="p-0070" num="0069">Under a querying operation, the input IP address is hashed. Whether this hash entry has a collision or not is determined by checking the LSB of the hash table entry. In the non-collision case, the hash table entry contains Verify Bits and Root node NHI. If the Verify Bits are matched with the input IP address, then the hash result becomes the PC-Trie address for the input IP address. Thus, the PC-Trie addresses are not stored in the hash tables. In the collision case, the hash table entry has a pointer to BS memory. Since a hash may result in one or more collisions, the number of BS collisions is stored for each hash table entry. In the case of more than one collision, the BS memory accessed multiple times if only one BS memory module is used. This can become a bottleneck in the system. Instead, multiple on-chip BS memory modules are used which are accessed in parallel. Based on simulation results, three BS memory modules are needed for IPv4 and fourteen BS memory modules are needed for IPv6.</p>
<p id="p-0071" num="0070"><figref idref="DRAWINGS">FIG. 3</figref> also shows BS memory entry contents that are Verify Bits, Root Node NHI, and PC-Trie Address. Thus, whichever Verify Bits of the BS memory entry are matched with the input IP address, the corresponding PC-Trie address is retrieved from the BS memory entry. With the on-chip memory-based collision resolving architecture, using area- and power-consuming TCAMs or CAMs can be avoided. By this membership query operation, only one PC-Trie address is resolved.</p>
<p id="p-0072" num="0071">&#xa7;4.1.2.2 Exemplary Hashing Using HashTune</p>
<p id="p-0073" num="0072">In FlashTrie, memory efficient Hash-Tune may be used for hashing operations. In contrast with a naive hash function, HashTune has two important advantages: (1) key distribution is more uniform over the entire hash table; and (2) the size of Verify Bits can be reduced. <figref idref="DRAWINGS">FIGS. 4</figref> (<i>a</i>) and (<i>b</i>) show key distribution using a naive hash approach. Each row represents a bin and each dark square in the row shows a key hashed to that bin. Typically, a naive hash function leads to the non-uniform distribution of prefixes in the hash table. This non-uniformity causes unnecessarily large bin sizes. Even when a good hash function is found for a particular table, after some updates, the distribution of prefixes in the hash table can still become non-uniform.</p>
<p id="p-0074" num="0073"><figref idref="DRAWINGS">FIG. 4</figref> (<i>c</i>) shows key distribution using HashTune. In HashTune, the entire hash table is segmented into multiple small hash tables called groups. All groups have the same number of bins. In <figref idref="DRAWINGS">FIG. 4</figref> (<i>c</i>), there are 12 bins segmented into 3 groups and each group has 4 bins (Group A: bin A1-bin A4, Group B: bin B1-bin B4 and Group C: bin C1-bin C4). Each group may select a different hash function from the pool of hash functions. In the example in <figref idref="DRAWINGS">FIG. 4</figref>, Group A uses Hash 1, and Groups B and C use Hash 2. The selected hash function ID is stored in a Hash ID table, which is also stored in on-chip memory and used for query operations. After applying different hash functions, occupancy of bins in each group, and hence in the entire hash table, becomes even. Because of the balanced key distribution, the hash table size is smaller than in naive approaches, as indicated by shaded areas in <figref idref="DRAWINGS">FIG. 4</figref>.</p>
<p id="p-0075" num="0074">Another advantage is also derived from grouping. Each group is assigned an ID called Group ID and the ID is selected from several bits of the root node in each sub-trie. For example, an 8-bit group ID will be selected for 256 groups. The group ID from the LSBs of the root node is selected because this balances the number of keys per group. The bits assigned for the group ID can be taken out from the Verify Bits because all items in the group have the same the group ID. For example, resolving 17 bits input and choosing 8 LSBs as the group ID permits the remaining 9 bits to be stored as Verify Bits. As a result, the Verify Bit size and on-chip memory requirements are reduced.</p>
<heading id="h-0007" level="1">&#xa7;4.2 Exemplary Flashtrie Architecture and Lookup</heading>
<p id="p-0076" num="0075">In this section, the construction of an exemplary FlashTrie architecture using an actual routing table as input is described. Prefix distributions of routing tables and determination of the coverage and size (stride size) of sub-tries is first considered. <figref idref="DRAWINGS">FIG. 5</figref> shows an example of actual prefix distribution for IPv4 based on the length of the prefix from the years 2003-2010 (obtained from the University of Oregon Route Views Project).</p>
<p id="p-0077" num="0076">One of the characteristics of the distribution is the number of prefixes in /24, which is more than 50% of the total number of prefixes. Any multibit-trie based architecture attempts to maintain fewer sub-tries so that memory consumption is less. Assigning /24 in a root of the sub-trie is not a good idea because it requires the number of sub-tries to be equal to the number of prefixes in /24. Thus, /24 is placed at the bottom of the sub-trie. Three levels are selected based on the prefix distribution of <figref idref="DRAWINGS">FIG. 5</figref>. They are IPv4/15 (15 Most-Significant Bits (MSB) of an IPv4 address), IPv4/16 (MSB 16 bits to 24 bits), and IPv4/25 (MSB 25 bits to 32 bits). IPv6 prefix distribution is also considered using real routing tables and expected future IPv6 routing tables. (See, e.g., M. Wang, S. Deering, T. Hain, and L. Dunn, &#x201c;Non-Random Generator for IPv6 Tables,&#x201d; in <i>Proc of the IEEE Symposium on High Performance Interconnects</i>, pp. 35-40 (2004), which is incorporated by reference.) Prefix distribution of the expected future IPv6 routing tables is shown in <figref idref="DRAWINGS">FIG. 6</figref>. As can be appreciated from <figref idref="DRAWINGS">FIG. 6</figref>, the majority of IPv6 prefixes is in /48. Thus, /48 is placed at the bottom of the sub-trie. Next, the overall FlashTrie architecture and the IP route lookup process are described.</p>
<p id="p-0078" num="0077">&#xa7;4.2.1 Exemplary Architecture and Lookup Operation</p>
<p id="p-0079" num="0078"><figref idref="DRAWINGS">FIG. 7</figref> illustrates the flow of an exemplary IPv4 lookup procedure. The IPv6 lookup procedure is similar except that there are more levels. For example, IPv4 lookup may require the use of two sub-trie levels while IPv6 lookup may require the use of six sub-trie levels.</p>
<p id="p-0080" num="0079">The input 32-bit IPv4 address is categorized in IPv4/15, IPv4/16, and IPv4/25. IPv4/15 is resolved using Direct Lookup (on-chip), and IPv4/16 and IPv4/25 are resolved using the membership query module (on-chip) and PC-Trie (off-chip). The PC-Trie address, marked *<b>1</b> in <figref idref="DRAWINGS">FIG. 7</figref>, is resolved from the output of the membership query module.</p>
<p id="p-0081" num="0080">Suppose &#x201c;1 0 0&#x201d; (in binary notation) is the input to this PC-Trie. The PC-Trie bitmap can be traversed as done in a binary trie. That is, traverse to the left child if the bit is &#x201c;0&#x201d;, otherwise traverse to the right child. Traversing begins from the MSB of input. The aim is to find the longest matching prefix in the PC-Trie. In <figref idref="DRAWINGS">FIG. 7</figref>, the third bit in the bottom (dark square in the PC-Trie) is reached after traversing &#x201c;1&#x201d; (Right) and &#x201c;0&#x201d; (Left). The contents of the bitmap is &#x201c;1&#x201d;, which means NHI exists for the input &#x201c;100&#x201d;. Since this is the longest matching prefix, the address of NHI memory is resolved for this node set.</p>
<p id="p-0082" num="0081">The address is resolved by a pointer stored with the PC-Trie node and offset calculated from the bitmap. The offset is the number of 1's starting from the root of the PC-Trie until the longest matching location. In this case, the offset is 2 (as there are two 1's before the final location). The pointer is pointing to the beginning of NHI entries in the memory for this PC-Trie. In the example of <figref idref="DRAWINGS">FIG. 7</figref>, the pointer points to the memory location of CA. The offset is added to this memory location to get the exact NHI set EB. Finally, the NHI is selected from the NHI set by the LSB of the input. Since the LSB of the input is &#x201c;0&#x201d;, E is selected as the final NHI. If LSB is &#x201c;1&#x201d;, B is selected. For PC-Trie n or a higher Prefix-Compressed Trie, one NHI set contains four or more NHIs. In this case, more than one (log 2(n)) bit from the input destination IP address is used to find the final NHI.</p>
<heading id="h-0008" level="1">&#xa7;4.3 Exemplary Flashtrie Update</heading>
<p id="p-0083" num="0082">Online update capability is important for routers in general and is becoming a more critical issue for future routers. As of March 2009, there were four updates observed per second on average but 25,000 updates per second during peak periods (information obtained from Classless Inter-Domain Routing (&#x201c;CIDR&#x201d;) reports publicly available on the Internet). For the update analysis, peak rate is used to demonstrate worst-case update capability. The anticipated growth in routing table entries is 2 million, which is approximately 6.3 times the current amount of routing table entries. If updates also increase proportionately, there would be around 160 k (=25K*6.3) updates per second during peak periods. To support this kind of growth, 10 Mpps (million packets per second) is reserved for lookup operations. This is sufficient for both on-chip and off-chip memory updates, as the next section explains.</p>
<p id="p-0084" num="0083">&#xa7;4.3.1 Exemplary on-Chip Memory Update</p>
<p id="p-0085" num="0084">Next hop information (NHI) of the root at each sub-trie is stored in on-chip memory as described above. <figref idref="DRAWINGS">FIG. 8</figref> shows two types of exemplary update methods: (1) Direct NHI programming; and (2) Indirect NHI programming. The example in <figref idref="DRAWINGS">FIG. 8</figref> shows four root nodes of sub-tries represented as I, J, K and L. For direct NHI programming, since there is no intermediate node between each sub-trie root, NHI A of root node I is simply copied to the root nodes, J, K, L of the following level. A problem occurs when an update is required at some upper stream along the path. For instance, if a new route X is to be added in the sub-trie that has a root node I on the path, then all the following root nodes (J, K, L) also need to be updated. The number of updates might be excessively high, especially for IPv6 because of longer addresses (more levels). To avoid this problem, indirect NHI programming is proposed as shown in example (b). In indirect NHI programming, a null value is stored at a root node which doesn't have NHI. This is done to indicate that the actual NM is located in the root node of upper level. By doing so, the update of X only needs to traverse one level down. Thus, the new X only affects the root node J, but not nodes K and L. By making sure there is only one level of dependency, all root nodes of the intermediate sub-tries are maintained in the on-chip membership query module. In other words, if some intermediate sub-tries do not exist, only root node NHI is created and stored in the membership query module (i e, if a sub-trie exists at Level(l), root NHIs of the upper level from Level(l&#x2212;1) to Level(1) exist in the membership query module).</p>
<p id="p-0086" num="0085">An example of an on-chip update using the indirect NHI programming method is illustrated in <figref idref="DRAWINGS">FIG. 9</figref>. <figref idref="DRAWINGS">FIG. 9</figref> illustrates four levels of sub-tries and the root NHI which is stored in on-chip memory. In the example shown, an update is applied in the sub-trie in Level 1, and a new route B is added. The update to sub-tries is one level down (Level 2), so the root node of ST2 is modified from null to B. Any update only affects one level below and the far level does not have any influence. Indeed, the root node of ST3 located in Level 3 maintains the same NHI, null.</p>
<p id="p-0087" num="0086">In the worst case for a 9-bit stride, there can be 511 updates (if the node below the root node has to be updated). Therefore, for future 160 k updates with each update requiring 511 memory accesses, the total updates, in the worst case, will be 81.8 million (=511*160 k), which is less likely to happen. Since this is an on-chip hash table update, 10 Mpps is still sufficient because the on-chip hash table is segmented and stored in individual on-chip memories. Multiple hash tables can be updated independently.</p>
<p id="p-0088" num="0087">&#xa7;4.3.2 Exemplary Off-Chip Memory Update</p>
<p id="p-0089" num="0088">There are two independent off-chip memories: (1) one for Prefix-Compressed Trie (PCTrie); and (2) another for NHI. For PC-Trie, eight memory accesses per update are used because the same PC-Trie is duplicated among all eight banks. This requires 1.28 million packets per second (&#x201c;Mpps&#x201d;) (=8 banks*160 k updates). For NHI, the worst-case number of memory accesses needed per update is (Stride&#x2212;log<sub>2 </sub>(Degree of Compression))*(number of bins). For example, for PC-Trie8 with 9-bit stride, 6 memory accesses are required. If PC-Trie8 is used for all sub-tries, then 7.68 Mpps are needed (6 memory access*8 banks*160 k updates) in the worst case. Thus, 10 Mpps is more than enough to update both on-chip and off-chip memory in real time.</p>
<p id="p-0090" num="0089">By contrast, Tree Bitmap update is not trivial, especially when inserting new child nodes. This operation requires multiple memory accesses to arrange all child nodes in consecutive memory locations. Moreover, after multiple updates, Tree Bitmap typically performs de-fragmentation to make consecutive memory space available. Meanwhile, the FlashTrie embodiments consistent with the present invention do not have these problems because they systematically organize hash-based addressing. Items stored in Black Sheep memory hold individual pointers and, therefore, PC-Trie can be allocated without any constraint.</p>
<heading id="h-0009" level="1">&#xa7;4.4 Performance Evaluation of an Exemplary Embodiment</heading>
<p id="p-0091" num="0090">For evaluation purposes, a routing table containing 318,043 routes is used. Two million routes are generated for the future routing table based on the prefix distribution trend. An anticipated IPv6 routing table is synthesized following the methods presented in M. Wang, et al (supra paragraph [0065]). It uses IPv4 routes and an Autonomous System (&#x201c;AS&#x201d;) number, giving a more realistic routing table as compared to a randomly generated table. Thus, the synthesized IPv6 routing table contains 318,043 routes (same as the IPv4 routing table size).</p>
<p id="p-0092" num="0091">First, sub-tries are extracted to generate the FlashTrie data structure. Table I of <figref idref="DRAWINGS">FIG. 28</figref> shows the number of sub-tries in each level and the total sub-tries for all three routing tables. A 9-bit stride size is used for the entire evaluation, and detail stride settings are listed in Table I of <figref idref="DRAWINGS">FIG. 28</figref>. Following this setting, performance is evaluated in terms of memory requirements and lookup speed for the IPv4 and IPv6 routing tables. The evaluation is based on the results of simulation and hardware implementation.</p>
<p id="p-0093" num="0092">&#xa7;4.4.1 Memory Requirements of Exemplary Embodiment</p>
<p id="p-0094" num="0093">In at least some FlashTrie embodiments consistent with the present invention, two types of memory are used: (1) on-chip memory, and (2) off-chip memory. The data that is stored in memory and the memory size used to support IPv4 and IPv6 simultaneously is described below.</p>
<p id="p-0095" num="0094">&#xa7;4.4.1.1 On-Chip Memory</p>
<p id="p-0096" num="0095">FlashTrie pushes most of the memory-consuming operation outside of the chip (off-chip memory). Some operations, however, are kept on-chip to enhance lookup performance and on-line updatability. On-chip memory is used for: (1) storing information required for direct lookup for up to /15(IPv4) or /12(IPv6), (2) storing hash tables used for membership queries, (3) storing a hash ID table (storing a hash ID for each group), and (4) Black Sheep memories for storing collided items in the hash table. The on-chip memory requirements are shown in Table II of <figref idref="DRAWINGS">FIG. 29</figref>. The first 15 bits are resolved by the direct lookup approach in IPv4 with 8 bits NHI (256 kbits=2<sup>15</sup>*8 bits). Sixty-four (64) hash functions are used for all tables and levels. Taking IPv4/16 from the real routing table as an example, the hash table is segmented into 2,048 groups. Therefore, the hash ID table size will be 12K bits (=2048*log<sub>2</sub>(64) bits). The simulation result determines the number of groups and bins in each group. The configurations are summarized in Table III of <figref idref="DRAWINGS">FIG. 30</figref>.</p>
<p id="p-0097" num="0096">As shown by the results in Table II of <figref idref="DRAWINGS">FIG. 29</figref>, to support 2M IPv4 routes (1.47 Mbits) and 318 k IPv6 routes (8.17 Mbits) simultaneously, 9.64 Mbits of on-chip memory is needed. Thus, three copies of this data can be stored in the on-chip memory of a state-of-the-art FPGA that has 38 Mbits on-chip memory capacity. Also, all on-chip memory has independent dual-ports. Therefore, six FlashTrie lookup engines can fit on one chip.</p>
<p id="p-0098" num="0097">&#xa7;4.4.1.2 Off-Chip Memory</p>
<p id="p-0099" num="0098">The off-chip memory (DRAM) in FlashTrie includes two independent memory chips: (1) PCTrie; and (2) NHI memory. The off-chip memory (DRAM) and the processor(s) have direct independent connection which provides each DRAM exclusive access to the processor as required. Table IV of <figref idref="DRAWINGS">FIG. 31</figref> shows memory requirements for PC-Trie. The sub-trie size for Tree Bitmap is 1063 bits (internal bitmap+external bitmap+two pointers), and for FlashTrie it is 83 bits (PC-Trie bitmap+pointer) for 9-bits strides PC-Trie8 (20 bits for each pointer). This significant reduction is because of bitmap compression and the elimination of the external bitmap. Table V of <figref idref="DRAWINGS">FIG. 32</figref> shows memory requirements for the NHI (assuming 8 bits NHI). The PC-Trie for every level can fit in one bank of DRAM as shown in <figref idref="DRAWINGS">FIG. 10</figref> (<i>a</i>). Even if NHI is duplicated, IPv4 and IPv6 NHI can easily be fit into one bank of DRAM as shown in <figref idref="DRAWINGS">FIG. 10</figref> (<i>b</i>). The data allocation in <figref idref="DRAWINGS">FIG. 10</figref> (<i>b</i>) is based on a 1-Gbit memory (each bank has 128 Mbits with 8 banks). The graph in <figref idref="DRAWINGS">FIG. 11</figref> shows the off-chip memory required for bitmap and NHI for different degrees of compression of PC-Trie in the FlashTrie as compared to the Tree Bitmap. The result indicates that the reduction in bitmap size is more than 80% (for higher compression degree of PC-Trie).</p>
<p id="p-0100" num="0099">&#xa7;4.4.2 Lookup Speed and Timing Analysis</p>
<p id="p-0101" num="0100">One on-chip FlashTrie lookup engine running at 200-MHz can process one lookup in 5 nsec, which is equivalent to 200 Mpps. By contrast, off-chip memory access is a little more restricted and requires some analysis. Before the timing analysis is discussed in detail below, a quick review of DRAM technology is presented below.</p>
<p id="p-0102" num="0101">Driven by an enormous market demand, DRAM speed and capacity are increasing rapidly while their power consumption and price are decreasing significantly. DRAMs may reach 12.80 GB/sec of throughput and 4 Gbits of capacity, and it has 8 banks on a chip. Using commercially available DRAM technology (DDR3-1600 with a memory clock of 200 MHz and bus clock 800 MHz), only 5 nsec is required to read 8 burst data (128 bits with 16-bit data bus). Thus, accessing 8 banks takes 40 nsec, which satisfies the timing restriction tRC (38 nsec).</p>
<p id="p-0103" num="0102"><figref idref="DRAWINGS">FIG. 12</figref> illustrates how 128 bits is continuously read every 5 nsec with a detailed timing diagram. Row activate (&#x201c;ACT&#x201d;) and read (&#x201c;RD&#x201d;) commands are sent sequentially following the timing specification of DDR3 SDRAM. For clarity, commands are presented for each bank. It is clear from <figref idref="DRAWINGS">FIG. 12</figref> that data from each bank are output, back-to-back, after the tRCD+CL cycle from ACT command.</p>
<p id="p-0104" num="0103">By using on-chip membership query, FlashTrie needs only one PC-Trie memory access and one independent NHI memory access. These accesses can be pipelined. Hence, the minimum lookup time of the system reaches 5 nsec per lookup, which is equivalent to 200 Mpps in the worst-case (for the minimum packet size, which is 40 bytes in IPv4). Therefore, two FlashTrie engines with two sets of DRAM chips (two PC-Trie and two NHI memories) can reach 400 Mpps. Worst-case IPv6 performance is 50% more than IPv4. The reason is that in FlashTrie, IPv4 and IPv6 have the same number of memory accesses per lookup. Even if update time (10 Mpps per engine) is considered, lookup speed exceeds 100-Gbps (250 Mpps). Moreover, field programmable gate arrays (FPGAs, such as Xilinx Virtex-6), which contain 38 Mbits of block RAM, can have six (6) engines in a single FPGA chip. With a single Virtex-6 FPGA and six (6) sets of DDR3-1600 DRAM chips, FlashTrie can reach 1.2 Bpps, which is more than 480-Gbps for IPv4 and more than 720-Gbps for IPv6 in the worst-case (for a minimum IPv6 packet size of 60 bytes).</p>
<p id="p-0105" num="0104">Tree Bitmap and FlashTrie timing analyses are presented in <figref idref="DRAWINGS">FIG. 13</figref> with the IPv6 lookup example (considering that only the first 64 bits of IPv6 are used for lookup). The timing diagram compares the Tree Bitmap and FlashTrie schemes using the same resources. The Tree Bitmap uses the first 12 bits for direct lookup, and the remaining bits are traversed in 6-bit strides. Assume that the Tree Bitmap uses optimization to fit the bitmap into one burst and ignores the DRAM read latency and processing time between levels. In this case, the Tree Bitmap approach requires 10 off-chip DRAM memory accesses (nine external bitmap and one internal bitmap accesses) for one lookup. Therefore, one IPv6 route lookup takes 50 nsec, whereas FlashTrie can perforin one lookup per 5 nsec. Therefore, FlashTrie can finish 10 route lookups during the same period (50 nsec). Hence, using the same number of memory chips, FlashTrie can perform ten times faster compared to the Tree Bitmap. In other words, to achieve the same throughput, ten times the amount of memory chips would be needed for Tree Bitmap, which makes Tree Bitmap not feasible for high speed route lookups.</p>
<heading id="h-0010" level="1">&#xa7;4.5 Exemplary Optimizations</heading>
<p id="p-0106" num="0105">The amount of on-chip memory is usually limited compared to off-chip memory. Efficient usage of on-chip memory can achieve even higher throughput by duplicating multiple lookup engines. As shown in &#xa7;4.3 above, Hash Table and Black Sheep memory consume the dominant portion of on-chip memory. In this section, two optimization methods are discussed that will reduce the memory requirements of these two modules.</p>
<p id="p-0107" num="0106">&#xa7;4.5.1 Multiple Keys Per Bin</p>
<p id="p-0108" num="0107">This optimization contributes to reducing the Black Sheep (&#x201c;BS&#x201d;) memory requirement. The bin of the hash table takes two types of entries: (1) one for the collision (overflow); and (2) another for the non-collision (non-overflow) cases. It contains root NHI and Verify Bits for a prefix in the non-overflow case. Otherwise, it contains the BS memory address and the number of overflows. Assume a hash table allows only one key per bin, and one key is already programmed in the bin. If another key is assigned to the same bin, the bin is now used to store BS memory information (pointer to the BS and number of overflows). The key originally stored in the bin is relocated to the BS memory. Thus, the two keys are stored in the BS memory. It requires a total of three memory slots (one in the hash table and two in the BS memory), which means the memory overhead is 33.3%. Here, a multi-key optimization is applied, which can reduce the memory overhead caused by collisions (overflow). Allowing more than two keys per bin can eliminate the overhead of the overflow. Based on experimental results, it has been determined that majority of the bins have only one or two collisions. Thus taking this optimization, many bins will not require BS memory. This significantly reduces the BS memory requirements.</p>
<p id="p-0109" num="0108">Two types of settings were experimented with, allowing two or four keys per bin. The results are listed in Table VI of <figref idref="DRAWINGS">FIG. 33</figref>. In Table VI, the multi-key optimization is not applied to the first column for each routing table. The results of adopting two and four entries in a bin are compared with the first column in each routing table. The results show that the on-chip memory requirement of both IPv4 real routing table and IPv6 are decreased from 8% to 16%. Since the total number of entries remains the same, the reductions are mainly contributed from the BS memory, which means that fewer sub-tries are placed into BS memory. As a result, the density of hash table memory becomes higher.</p>
<p id="p-0110" num="0109">&#xa7;4.5.2 Incremental Verify Bits</p>
<p id="p-0111" num="0110">This optimization contributes to reducing the BS memory requirement as well as the hash table size in the membership query module. The hash-based scheme needs to perform a verification operation for the hash result to identify any false positive. The Verify Bits are stored in the hash table and BS memories. Both memories are implemented in on-chip memory, so the size of the Verify Bits directly affects the memory requirements of on-chip memories. Without this optimization, the length of the Verify Bits increases proportionally to the length of the prefixes. For example, the size of the Verify Bits for IPv4/16 is 5 bits, and it becomes 16 bits for IPv4/25. Furthermore, IPv6 requires only 8 bits in the first level (IPv6/13), but increases the requirement to 49 bits in the bottom level (IPv6/58) even though hash tune, which can reduce the length of the Verify bits, is used.</p>
<p id="p-0112" num="0111">FlashTrie executes all levels of the membership query in parallel. Recall that all root NHIs of intermediate sub-tries (ancestors) exist in the membership query module. In this circumstance, a sub-trie of the input IP address is matched in a lower level, which implies that the shorter sub-tries also exists in the upper levels. Using IPv4 as an example, if the sub-trie of IPv4/25 exists, the root NHI of IPv4/16 can also be found in the membership query module. Verify Bits for both root of sub-tries are stored in the membership query module. As shown in <figref idref="DRAWINGS">FIG. 14</figref>, the Verify Bits of IPv4/16 consist of bits from 31 to 27 of the sub-trie IP address, and Verify Bits of IPv4/25 consist of bits from 31 to 16 of the sub-trie IP address. The Verify Bits [31:27] of the IPv4/25 and IPv4/16 are identical. Thus, the original scheme stores redundant Verify Bits in all levels. The membership query module of IPv4/16 stores Verify Bits of bits [31:27], marked as VB16 in <figref idref="DRAWINGS">FIG. 14</figref>. The module of IPv4/25 needs only bits [26:16], marked as VB25. During the query process, the VB16 will be passed to the module of IPv4/25. The verification for the prefix of IPv4/25 will be compared with the concatenation of VB16 and VB25. In the case of IPv6, the storage of Verify Bits is organized as in FIG. <b>15</b>. This scheme is called &#x201c;Incremental Verify Bits&#x201d;.</p>
<p id="p-0113" num="0112">Table VII of <figref idref="DRAWINGS">FIG. 34</figref> lists the on-chip memory requirements and comparisons of applying incremental Verify Bits optimization combined with multi-keys optimization. The multikey optimization is not applied to the first column of each routing table. These columns show the performance of applying the incremental Verify Bits scheme only. Compared with the corresponding columns in Table VI of <figref idref="DRAWINGS">FIG. 33</figref>, the scheme gains improvements. Even when multi-keys optimization is applied, additional improvements remain achievable. Although, the improvements for IPv4 are fractional, the improvements in IPv6 are significant. The reason is that even though the requirements of hash table memory and BS memory in IPv4/25 are decreased, their proportions are small. This optimization reduced on-chip memory usage by 40 percent.</p>
<p id="p-0114" num="0113">Applying these optimizations, the total on-chip memory requirements are reduced from 9.64 Mbits to 5.07 Mbits (1.38 Mbits-IPv4, 3.69 Mbits-IPv6). With the state-of-the-art FPGAs which contain 38 Mbits of dual port on-chip memory, 14 lookup engines can be supported. As a result, a processing speed of 2.8 billion pps can be achieved.</p>
<heading id="h-0011" level="1">&#xa7;4.6 Exemplary Hardware Implementation</heading>
<p id="p-0115" num="0114">In this section, the architecture of a hardware implementation in an exemplary embodiment consistent with the present invention is described. The hardware utilization of the prototype design is also presented at the end of the section. <figref idref="DRAWINGS">FIG. 16</figref> shows block diagrams of the FlashTrie lookup engine. The engine includes five main sub-modules: (1) Direct Lookup, (2) Membership Query, (3) PC-Trie Lookup, (4) NHI Lookup, and (5) Priority Checker. When performing lookup, the input IP address is provided to the Direct Lookup and membership query modules. The Direct Lookup Module resolves the NHI in level zero, while the others cope with level one and level two. The membership query module checks if sub-tries exist for the input IP address in the next two levels. If sub-tries do exist, the module generates a PC-Trie address to query off-chip memory (where the bitmap and memory address of NHI set are stored), and forwards it to the PC-Trie Lookup module. The PC-Trie Lookup module is responsible for reading the data from external memory in terms of the input address, traversing the bitmap for further prefix matching, and calculating the address of the target NHI set. Then, the NHI Lookup module uses the address to obtain a set of NHIs from another off-chip memory and picks out the final one with partial IP according to the FlashTrie algorithm.</p>
<p id="p-0116" num="0115">Each IP address query will have an exact match in level zero, and it also may have sub-trie matches in level one and two. The outcome from the longest match will be the final NHI choice. Finally, the Priority Checker module selects the NHI from Direct Lookup module as output if only a sub-trie matches in the level zero. Otherwise, it returns the NHI from the NHI Lookup module.</p>
<p id="p-0117" num="0116">&#xa7;4.6.1 Exemplary Hardware Implementation of Direct Lookup Module</p>
<p id="p-0118" num="0117">The Direct Lookup module is used for level zero NHI lookup. The NHI for this level is stored in an on-chip Block RAM. The module consults the on-chip Block RAM according to the input IP address. Here, only most-significant bits from 31 to 17 are used as the indexing address to fetch NHI out of memory. The fetched NHI is stored in a FIFO buffer until matching procedures in other levels are completed. Then, the NHI for the input IP address is chosen between them.</p>
<p id="p-0119" num="0118">&#xa7;4.6.2 Examplary Hardware Implementation Of Membership Query Module</p>
<p id="p-0120" num="0119">Once the IP address is inputted into the lookup engine, the sub-trie matching procedures of variant length are executed in parallel. The membership query module checks if sub-tries exist for the input IP address. For the IPv4 lookup, the binary trie is divided into levels of prefixes of lengths 16 and 25 and marked as level one and two, respectively. As shown in <figref idref="DRAWINGS">FIG. 17</figref>, each level has an individual PC-Trie Address Generator for parallel lookup and PC-Trie address generation. Bits [31:16] of the input IP address are used as the input for module /16, while bits [31:7] are for module /25. Bits [15:0] of the IP address are stored in the FIFO buffer for further use. The generators for different levels are basically the same in structure and operations. The generator for level two is used as an example here and shown in <figref idref="DRAWINGS">FIG. 18</figref>. HashTune is used in order to store as many sub-tries as is necessary in limited memory slots. The sub-tries are grouped in terms of partial bits of its prefix. Each group can use a hash function to determine the position of the memory slot for storing the information of the sub-trie. The LSB 11 bits of the generator's input are treated as a group number to query the Hash ID memory for its hash function. Then, the whole input is involved in calculating the address, used to query the on-chip hash table memory, by employing HashTune.</p>
<p id="p-0121" num="0120">The output from hash table memory can be interpreted in two ways. As discussed above, it is possible that more than one sub-trie is hashed into the same bin, which results in collision. In this case, the output is taken as a query address to further refer to the BS memory. Otherwise, it is used to verify the existence of the sub-trie for the input by comparing the Verify Bits from the output with the input. In an actual implementation, the BS memories are queried whether the collision happens or not. Then, the verification compares the bits of the input with the outcomes from all BS memories as well as the hash table memory in the Matching Checker module. If it is identical to the one from hash table, the output address of the Matching Checker module is the same as the one used to query the hash table. Otherwise, it will be extracted from the BS memory's outcome, whichever Verify Bits of the BS memory entry are matched with the input IP address.</p>
<p id="p-0122" num="0121">&#xa7;4.6.3 Examplary Hardware Implementation Of PC-Trie and NHI Lookup</p>
<p id="p-0123" num="0122">If a sub-trie is found for the input IP address in the Membership Query module, the IP address may have longer prefix matching in the sub-trie, which is stored as a PC-Trie. The PC-Trie Lookup module, as shown in <figref idref="DRAWINGS">FIG. 19</figref>, uses the address generated by the membership query module, to refer to the off-chip memory. The DDR2 interface employs a DDR2 memory controller, generated by the Xilinx Memory Interface Generator (&#x201c;MIG&#x201d;). The data from the off-chip memory consists of the bitmap and NHI set base address for a sub-trie. The bitmap is traversed to determine further matching with the partial IP address, the remainder from the membership query stage. Then, the offset of the memory position is counted, as discussed in &#xa7;4.2.1 above, and is added to the NHI set base address, resulting in the address of the NHI set. The partial IP address results in the NHI index by removing the bits used for partial matching. Then, the NHI lookup module, whose architecture is shown in <figref idref="DRAWINGS">FIG. 20</figref>, applies the NHI set address to query another off-chip memory, which stores the NHI set data. The resulting NHI set contains 16 NHIs. The final NHI for the input address is selected based on the NHI index.</p>
<p id="p-0124" num="0123">&#xa7;4.6.4 Examplary Hardware Implementation Result</p>
<p id="p-0125" num="0124">The FlashTrie lookup engine is implemented on a Xilinx Virtex-4 FX100 FPGA chip, which has 42,176 slices and 376 block RAMs. The development environment is ISE 10.1. The design is downloaded on the FPGA on a board PLDA XpressFX. The board is equipped with two 1-Gbit DDR2 SDRAMs. Each independently connects to the FPGA chip. The prototype design uses one DRAM chip for bitmap storage, and another for NHI. Both DRAMs have a 16-bit data bus. The burst size is configured as eight (8), in which 128 bits of data can be read once. The whole design, including the DRAMs, runs at 200 MHz (bus clock 400 MHz). The memory controllers are generated by the Xilinx Memory Interface Generator (MIG 2.3). The input to the lookup engine is placed in an on-chip memory and fed into it. The resource utilizations are listed in Table VIII of <figref idref="DRAWINGS">FIG. 35</figref>. One lookup engine is employed in the prototype. The total occupied slices are 8% and Lookup tables (LUTs) are 4%. The used block RAM/FIFOs are 29% of the FPGA capacity.</p>
<heading id="h-0012" level="1">&#xa7;4.7 Exemplary Methods</heading>
<p id="p-0126" num="0125"><figref idref="DRAWINGS">FIG. 21</figref> is a flow diagram of one exemplary method <b>2110</b> consistent with the present invention for performing an Internet Protocol (IP) network lookup. A forwarding device may receive an IP network address of a destination device (Block <b>2120</b>) and then select a detection path based on IP protocol version (e.g., IPv4, IPv6, etc.) (Block <b>2125</b>). The detection paths for an IPv4 address lookup and an IPv6 address lookup are similar except that the number if bits used by a direct memory lookup for each type of address may be different, and the number of sub-trie levels used may be different (e.g., an IPv4 address lookup may require the use of two sub-trie levels while IPv6 address lookup may require the use of six sub-trie levels). Regardless of which detection path is select, at that point, the method <b>2110</b> may perform, in parallel, (1) a direct memory lookup of the first next hop information table (stored in on-chip, internal processor memory) using the IP network address and (2) a query of membership query information (stored in on-chip, internal processor memory) using the IP network address. (Blocks <b>2130</b> and <b>2140</b>, respectively) A first set of next hop information is then determined. (Block <b>2131</b>). Simultaneously, the location of a Prefix-compressed Trie (PC-Trie) is determined. (Block <b>2140</b>) The method <b>2110</b> then searches the determined PC-Trie (stored in off-chip, external processor memory) to determine a location and an offset with a second next hop information table for the desired information. (Block <b>2142</b>) The method <b>2110</b> determines a second set of NHI information using the determined location and the offset within the second NHI information table. (Block <b>2143</b>) The prefix lengths included in first set of NHI information and the second set of NHI information are then compared to determine the longest prefix match. (Block <b>2150</b>) The longest prefix match is then selected for use in determined the next hop device. (Block <b>2160</b>) The method may then be left. (Block <b>2170</b>)</p>
<p id="p-0127" num="0126"><figref idref="DRAWINGS">FIG. 22</figref> is a flow diagram of another exemplary method <b>2210</b> consistent with the present invention for creating and storing data structures representing network forwarding information used for network route lookup. The method <b>2210</b> may accept a routing table including prefixes of destination addresses and next hop information associated with the prefixes. (Block <b>2215</b>) The method <b>2210</b> may then create (1) a first next hop information table using the accepted routing table (Block <b>2220</b>), (2) a plurality of prefix-compressed tries using the accepted routing table (Block <b>2225</b>), (3) membership query information using the plurality of prefix-compressed tries (Block <b>2230</b>), and (4) a second next hop information lookup table using the plurality of the prefix-compressed tries (Block <b>2235</b>). The method <b>2210</b> may then store (1) the first next hop information table in on-chip memory (i.e., internal processor memory) (Block <b>2240</b>), (2) membership query information in on-chip memory (i.e., internal processor memory) (Block <b>2245</b>), (3) the plurality of prefix-compressed tries in off-chip memory (i.e., external processor memory) (Block <b>2250</b>), and (4) the second next hop information lookup table in off-chip memory (i.e., external processor memory) (Block <b>2255</b>). The method <b>2210</b> may then be left. (Block <b>2260</b>)</p>
<p id="p-0128" num="0127"><figref idref="DRAWINGS">FIG. 23</figref> is a flow diagram of another exemplary method <b>2310</b> consistent with the present invention for creating and storing data structures representing network forwarding information used for network route lookup. The method <b>2310</b> may accept a routing table including prefixes of destination addresses and next hop information associated with the prefixes. (Block <b>2315</b>) The method <b>2310</b> may then create a binary tree representation of forwarding information. (Block <b>2320</b>) The method <b>2310</b> may then create a binary tree representation of forwarding information. (Block <b>2320</b>) The method <b>2310</b> may then divide binary tree representation into multiple levels of sub-trie data structures such that (1) each of the plurality of levels includes at least one sub-trie data structure, (2) each of the sub-trie data structures includes one or more nodes, and (3) the one or more nodes including a root node at the root of the sub-trie data structure. (Block <b>2325</b>) For each of the sub-trie data structures created, the method <b>2310</b> may then determines if the root node of the sub-trie has associated NHI. (Blocks <b>2330</b>, <b>2335</b> and <b>2360</b>) if the root node has associated NHI, the associated NHI is stored in the root node location. (Block <b>2340</b>). If the root node does not have associated NHI, the method <b>2310</b> may then determine if there is any NHI along the path in the parent sub-trie. (Block <b>2345</b>) If there isn't any NHI along the path in the parent sub-trie, a null value is stored in the root node location. (Block <b>2350</b>) If there does exits NHI along the path in the parent sub-trie, a copy of that NHI is stored in the root node location. (Block <b>2355</b>). The method <b>2310</b> may then be left. (Block <b>2365</b>).</p>
<p id="p-0129" num="0128"><figref idref="DRAWINGS">FIG. 24</figref> is a flow diagram of an exemplary method <b>2410</b> consistent with the present invention for updating data structures representing network forwarding information used for network route lookup. The method <b>2410</b> may receive new route forwarding information including prefixes of destination addresses and next hop information associated with the prefixes wherein the information about the new route includes an address prefix and a address length. (Block <b>2415</b>) The method <b>2410</b> may then identify a node in a sub-trie to which the new route information belongs to using the received address prefix and address length. (Block <b>2420</b>). The method <b>2410</b> may then determining whether the destination sub-trie data structure which includes the indentified node exists. (Block <b>2425</b>) If the destination sub-trie data structure already exists, the method <b>2410</b> may then store the new route information in the identified node, wherein the identified node is located in a first sub-trie at a first level. (Block <b>2435</b>) If the destination sub-trie data structure does not exist, the method <b>2410</b> may first create a new sub-trie which includes the indentified node (Block <b>2430</b>), and then store the new route information in the identified node within the new sub-trie created, wherein the identified node is located in a first sub-trie at a first level. (Block <b>2435</b>) The method <b>2410</b> may then update the root node of descendent sub-tries located one level down with the new route forwarding information. (Block <b>2440</b>) The method <b>2410</b> may then be left. (Block <b>2445</b>)</p>
<p id="p-0130" num="0129"><figref idref="DRAWINGS">FIG. 25</figref> is a flow diagram of an exemplary method <b>2510</b> consistent with the present invention for deleting network route information from data structures representing network forwarding information used for network route lookup. The method <b>2510</b> may receive information about a route to be deleted from the sub-trie data structures, wherein the information about the route includes an address prefix and an address length. (Block <b>2515</b>) The method <b>2510</b> may then identify a node in a sub-trie to which the route information to be deleted belongs to using the received address prefix and address length. (Block <b>2520</b>). The method <b>2510</b> may then delete the route information from the identified node. (Block <b>2525</b>). The method <b>2510</b> may then determine whether or not all nodes in the destination sub-trie have been deleted. (Block <b>2530</b>) If all nodes from the destination sub-trie have not been deleted, the method <b>2510</b> may then update the root node of descendant sub-tries located one level down with the deleted route information. (Block <b>2540</b>). If the method <b>2510</b> determines that all nodes from the destination sub-trie have been deleted, the method <b>2510</b> may then delete the destination sub-trie (Block <b>2535</b>) before updating the root node of descendant sub-tries located one level down with the deleted route information (Block <b>2540</b>). The method <b>2510</b> may then be left. (Block <b>2545</b>)</p>
<p id="p-0131" num="0130"><figref idref="DRAWINGS">FIG. 26</figref> is a flow diagram of an exemplary method <b>2610</b> consistent with the present invention for updating data structures representing network forwarding information used for network route lookup. The method <b>2610</b> may receive information about a route to be updated within a sub-trie data structure, wherein the information about the route includes an address prefix and an address length. (Block <b>2615</b>) The method <b>2610</b> may then identify a node in a sub-trie to which the route information to be updated belongs to using the received address prefix and address length. (Block <b>2620</b>). The method <b>2610</b> may then updated the route information from the identified node. (Block <b>2625</b>). The method <b>2610</b> may then update the root node of descendant sub-tries located one level down with the updated route information (Block <b>2630</b>). The method <b>2610</b> may then be left. (Block <b>2635</b>)</p>
<heading id="h-0013" level="1">&#xa7;4.8 Exemplary Apparatus</heading>
<p id="p-0132" num="0131"><figref idref="DRAWINGS">FIG. 27</figref> is high-level block diagram of a machine <b>2700</b> which may perform one or more of the operations discussed above. Machine <b>2700</b> includes a processor(s) <b>2710</b>, an input/output interface unit(s) <b>2730</b>, a storage device(s) <b>2720</b>, and a system bus(es) and/or a network(s) <b>2740</b> for facilitating the communication of information among the coupled elements. At least some of the storage device(s) have direct independent connections with the processor(s) which provide the storage device(s) exclusive access to the processor(s) as required. An input device(s) <b>2732</b> and an output device(s) <b>2734</b> may be coupled with the input/output interface(s) <b>2730</b>. Operations of the present invention may be effected by the processor <b>2710</b> executing instructions. The instructions may be stored in the storage device <b>2720</b> and/or received via the input/output interface <b>2730</b>. The instructions may be functionally grouped into processing modules. Although not shown, more than one of some or all of these components may be provided.</p>
<p id="p-0133" num="0132">Machine <b>2700</b> may be a router or a label-switching router for example. In an exemplary router, the processor(s) <b>2710</b> may include a microprocessor, a network processor, and/or (e.g., custom) integrated circuits. In the exemplary router, the storage device(s) <b>2720</b> may include one or more ROM, RAM, SDRAM, SRAM, SSRAM, DRAM, flash drive, hard disk drive, and/or flash card. At least some of these storage device(s) <b>2720</b> may include program instructions defining an operating system, a protocol module (e.g. daemon) and/or other modules. In one embodiment, the methods of the present invention may be performed by a microprocessor executing stored program instructions (e.g., defining a part of the protocol module or daemon). At least a portion of the machine executable instructions may be stored (temporarily or more permanently) on the storage device(s) <b>2720</b> and/or may be received from an external source via an input interface unit(s) <b>2730</b>. Finally, in the exemplary router, the input/output interface unit(s) <b>2730</b>, input device(s) <b>2732</b> and output device <b>2734</b> may include interfaces to terminate communications links.</p>
<p id="p-0134" num="0133">Naturally, the operations of the exemplary methods may be performed on systems other than routers. Such other systems may employ different hardware and/or software.</p>
<heading id="h-0014" level="1">&#xa7;4.9 Conclusions</heading>
<p id="p-0135" num="0134">As can be appreciated from the foregoing, a low-cost, high-speed, next generation route lookup architecture called FlashTrie that can support 2-M IPv4 and 318-k IPv6 routes simultaneously. A new compact data structure for a multibit-trie representation, called Prefix-Compressed Trie, and a hash-based, high-speed, memory-efficient architecture is presented. Comprehensive simulation results and hardware implementation show the FlashTrie architecture can achieve 160-Gbps worst-case throughput with four DDR3 DRAM chips. This exceptionally small numbers of off-chip memory requires very little I/O pins in the main control chips and maintains low system cost. FlashTrie can support real-time incremental updates by reserving only 5% of total throughput (10 Mpps per engine).</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A computer-implemented method for Internet Protocol (IP) network lookup in a forwarding device, the forwarding device including an internal processor memory storing a first next hop information table and membership query information, and an external processor memory storing a plurality of prefix-compressed trees and a second next hop information table, the method comprising:
<claim-text>a) receiving, by the forwarding device, an IP network address of a destination device, as input, to determine next hop information indicating a network address of a next hop device to which a data packet is to be sent on the way to the data packet's final destination;</claim-text>
<claim-text>b) determining, by the forwarding device, a first set of next hop information using the received IP network address by performing a direct memory lookup of a first next hop information table stored in the internal processing memory of the forwarding device;</claim-text>
<claim-text>c) determining, by the forwarding device, a location of a prefix-compressed trie, stored in external processor memory, using the received network address by performing a query of membership query information stored in internal processor memory;</claim-text>
<claim-text>d) searching, by the forwarding device, the prefix-compressed trie at the determined location using the received IP network address, to determine a location and an offset within a second next hop information table, stored in external processor memory, which stores the desired next hop information;</claim-text>
<claim-text>e) determining, by the forwarding device, a second set of next hop information using (1) the determined location and (2) the offset within the second next hop information table;</claim-text>
<claim-text>f) determining, by the forwarding device, which of the first set of next hop information and the second set of next hop information has a longest match of the received IP network address; and</claim-text>
<claim-text>g) selecting, by the forwarding device, the set of next hop information that has the longest match of the received IP network address.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The computer-implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the IP network address is one of an IPv4 address or an IPv6 address.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The computer-implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the act of determining the first set of next hop information uses a first portion of the network address to perform the direct memory lookup of the first next hop information table stored in internal processor memory.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The computer-implemented method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the act of determining the location of the prefix-compressed trie uses one or more portions of the network address to perform parallel queries of membership query information stored in internal processor memory, and wherein the one or more portions of the network address is different than the first portion of the network address used to determine the first set of next hop information.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The computer-implemented method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein (1) the direct memory lookup of the first next hop information table stored in internal processor memory and (2) the queries of membership query information stored in internal processor memory are performed in parallel.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The computer-implemented method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the act of performing the queries of the membership query information to determine the location of the prefix-compressed trie includes
<claim-text>1) using a hash function on the network address to determine a matching entry in a hash table,</claim-text>
<claim-text>2) determining if the matching entry in the hash table indicates the existence of one or more collisions,</claim-text>
<claim-text>3) if the matching entry in the hash table indicates that no collision exists, then determining the pre-fix trie location directly from the hash table entry,</claim-text>
<claim-text>4) if the matching entry in the hash table indicates that one or more collisions exist, then
<claim-text>A) determining a location of a collision table in internal memory which stores the desired prefix-compressed trie location, and</claim-text>
<claim-text>B) determining the location of the prefix-compressed trie location from the collision table using the network address.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. A computer implemented method for creating stored data structures representing network forwarding information used for network route lookup, the method comprising:
<claim-text>a) accepting, by a first device, a routing table including one or more sets of forwarding information, wherein each set of forwarding information includes at least (A) a prefix of destination addresses and (B) next hop information associated with the prefix;</claim-text>
<claim-text>b) creating, by the first device, a first next hop information lookup table, using the accepted routing table;</claim-text>
<claim-text>c) creating, by the first device, a plurality of prefix-compressed tries using the accepted routing table;</claim-text>
<claim-text>d) creating, by the first device, membership query information using the plurality of prefix-compressed tries;</claim-text>
<claim-text>e) creating, by the first device, a second next hop information lookup table using the plurality of the prefix-compressed tries;</claim-text>
<claim-text>f) storing, by the first device, the first next hop information lookup table in an internal processor memory of a first forwarding device;</claim-text>
<claim-text>h) storing, by the first device, the membership query information in the internal processor memory of the first forwarding device; and</claim-text>
<claim-text>g) storing, by the first device, the plurality of prefix-compressed tries in an external processor memory of the first forwarding device;</claim-text>
<claim-text>i) storing, by the first device, the second next hop information lookup table in the external processor memory of the first forwarding device.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The computer-implemented method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the next hop information indicates an address of a second forwarding device to which a data packet is to be sent on the way to the data packet's final destination.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The computer-implemented method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the internal processor memory is on-chip memory included on the same chip as a central processing unit of the first forwarding device.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The computer-implemented method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the external processor memory is off-chip memory not included on the same chip as a central processing unit of the first forwarding device.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The computer-implemented method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the external processor memory is dynamic random access memory (DRAM).</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The computer-implemented method of <claim-ref idref="CLM-00007">claim 7</claim-ref> further comprising:
<claim-text>creating, by the first device, a binary tree representation of the accepted routing table; and</claim-text>
<claim-text>dividing, by the first device, the binary tree representation of the accepted routing table into a plurality of sub-tries, each of the plurality of sub-tries having one or more nodes, wherein the one or more nodes including a root node, and wherein each of the one or more nodes has an associated location identifier.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The computer-implemented method of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the act of creating the first next hop information lookup table further uses a first one of the plurality of sub-tries, wherein the first next hop information lookup table includes at least
<claim-text>1) an identifier of each node included in the first one of the plurality of sub-tries, and</claim-text>
<claim-text>2) the associated location identifier of each node included in the first one of the plurality of sub-tries.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The computer-implemented method of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the act of creating the plurality of prefix-compressed tries using the accepted routing table includes
<claim-text>compressing each of the plurality of sub-tries other than a first one of the plurality of sub-tries, wherein one bit of each prefix-compressed trie represents consecutive nodes having a same prefix length.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The computer-implemented method of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the act of creating the membership query information using the plurality of prefix-compressed tries includes
<claim-text>creating a plurality of hash tables by hashing at least a portion of the location identifier of the root node of each of the plurality of sub-tries other than the first one of the plurality of sub-tries.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The computer-implemented method of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the plurality of hash tables are hashed using a HashTune function.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The computer-implemented method of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the second next hop information lookup table created using each of the prefix-compressed tries includes at least
<claim-text>1) an identifier of each node included in the plurality of prefix-compressed tries, and</claim-text>
<claim-text>2) an associated location identifier of each node included in the plurality of prefix-compressed tries.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. Apparatus used for Internet Protocol (IP) network lookup comprising:
<claim-text>a) at least one processor including internal processor storing a first next hop information table and membership query information;</claim-text>
<claim-text>b) external processor memory storing a plurality of prefix-compressed trees and a second next hop information table, wherein the external processor memory has a direct independent connection to the at least one processor which provides exclusive access to the at least one processor as required; and</claim-text>
<claim-text>c) at least one storage device storing program instructions which, when executed by the at least one processor, performs a method including
<claim-text>1) receiving an IP network address of a destination device, as input, to determine next hop information indicating a network address of a next hop device to which a data packet is to be sent on the way to the data packet's final destination;</claim-text>
<claim-text>2) determining a first set of next hop information using the received IP network address by performing a direct memory lookup of a first next hop information table stored in the internal processing memory of the forwarding device;</claim-text>
<claim-text>3) determining a location of a prefix-compressed trie, stored in external processor memory, using the received network address by performing a query of membership query information stored in internal processor memory;</claim-text>
<claim-text>4) searching the prefix-compressed trie at the determined location using the received IP network address, to determine a location and an offset within a second next hop information table, stored in external processor memory, which stores the desired next hop information;</claim-text>
<claim-text>5) determining a second set of next hop information using (i) the determined location and (ii) the offset within the second next hop information table;</claim-text>
<claim-text>6) determining which of the first set of next hop information and the second set of next hop information has a longest match of the received IP network address; and</claim-text>
<claim-text>7) selecting the set of next hop information that has the longest match of the received IP network address.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The apparatus of <claim-ref idref="CLM-00018">claim 18</claim-ref> wherein determining the first set of next hop information uses a first portion of the network address to perform the direct memory lookup of the first next hop information table stored in internal processor memory.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The apparatus of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein determining the location of the prefix-compressed trie uses one or more portions of the network address to perform parallel queries of membership query information stored in internal processor memory, and wherein the one or more portions of the network address is different than the first portion of the network address used to determine the first set of next hop information.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The apparatus of <claim-ref idref="CLM-00020">claim 20</claim-ref>, wherein (1) the direct memory lookup of the first next hop information table stored in internal processor memory and (2) the queries of membership query information stored in internal processor memory are performed in parallel.</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. The apparatus of <claim-ref idref="CLM-00020">claim 20</claim-ref>, wherein performing the queries of the membership query information to determine the location of the prefix-compressed trie includes
<claim-text>i) using a hash function on the network address to determine a matching entry in a hash table,</claim-text>
<claim-text>ii) determining if the matching entry in the hash table indicates the existence of one or more collisions,</claim-text>
<claim-text>iii) if the matching entry in the hash table indicates that no collision exists, then determining the pre-fix trie location directly from the hash table entry,</claim-text>
<claim-text>iv) if the matching entry in the hash table indicates that one or more collisions exist, then
<claim-text>A) determining a location of a collision table in internal memory which stores the desired prefix-compressed trie location, and</claim-text>
<claim-text>B) determining the location of the prefix-compressed trie location from the collision table using the network address.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00023" num="00023">
<claim-text>23. Apparatus used for creating stored data structures representing network forwarding information used for Internet Protocol (IP) network lookup comprising:
<claim-text>a) at least one processor;</claim-text>
<claim-text>b) at least one input device; and</claim-text>
<claim-text>c) at least one storage device storing program instructions which, when executed by the at least one processor, performs a method including
<claim-text>1) accepting a routing table including one or more sets of forwarding information, wherein each set of forwarding information includes at least</claim-text>
<claim-text>(A) a prefix of destination addresses and (B) next hop information associated with the prefix;</claim-text>
<claim-text>2) creating a first next hop information lookup table, using the accepted routing table;</claim-text>
<claim-text>3) creating a plurality of prefix-compressed tries using the accepted routing table;</claim-text>
<claim-text>4) creating membership query information using the plurality of prefix-compressed tries;</claim-text>
<claim-text>5) creating a second next hop information lookup table using the plurality of the prefix-compressed tries;</claim-text>
<claim-text>6) storing the first next hop information lookup table in an internal processor memory of a first forwarding device;</claim-text>
<claim-text>7) storing the membership query information in the internal processor memory of the first forwarding device; and</claim-text>
<claim-text>8) storing the plurality of prefix-compressed tries in an external processor memory of the first forwarding device;</claim-text>
<claim-text>9) storing the second next hop information lookup table in the external processor memory of the first forwarding device.</claim-text>
</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
