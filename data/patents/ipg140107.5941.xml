<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627050-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627050</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>11868605</doc-number>
<date>20071008</date>
</document-id>
</application-reference>
<us-application-series-code>11</us-application-series-code>
<us-term-of-grant>
<us-term-extension>696</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>30</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>712227</main-classification>
</classification-national>
<invention-title id="d2e53">Executing perform floating point operation instructions</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5559977</doc-number>
<kind>A</kind>
<name>Avnon et al.</name>
<date>19960900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5696709</doc-number>
<kind>A</kind>
<name>Smith, Sr.</name>
<date>19971200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>5796641</doc-number>
<kind>A</kind>
<name>Tu</name>
<date>19980800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>5825678</doc-number>
<kind>A</kind>
<name>Smith</name>
<date>19981000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>5889980</doc-number>
<kind>A</kind>
<name>Smith, Jr.</name>
<date>19990300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>5978901</doc-number>
<kind>A</kind>
<name>Luedtke et al.</name>
<date>19991100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>6473807</doc-number>
<kind>B1</kind>
<name>Hills et al.</name>
<date>20021000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>719330</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>7047401</doc-number>
<kind>B2</kind>
<name>Seal et al.</name>
<date>20060500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>7251811</doc-number>
<kind>B2</kind>
<name>Rosner et al.</name>
<date>20070700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717138</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>7343479</doc-number>
<kind>B2</kind>
<name>Knebel et al.</name>
<date>20080300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712227</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>8051118</doc-number>
<kind>B2</kind>
<name>Lundvall et al.</name>
<date>20111100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>8051119</doc-number>
<kind>B2</kind>
<name>Lundvall et al.</name>
<date>20111100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>8060545</doc-number>
<kind>B2</kind>
<name>Lundvall et al.</name>
<date>20111100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>8082282</doc-number>
<kind>B2</kind>
<name>Lundvall et al.</name>
<date>20111200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>2005/0065990</doc-number>
<kind>A1</kind>
<name>Allen</name>
<date>20050300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>708495</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>2007/0022152</doc-number>
<kind>A1</kind>
<name>Gerwig et al.</name>
<date>20070100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>2007/0061387</doc-number>
<kind>A1</kind>
<name>Carlough et al.</name>
<date>20070300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00018">
<document-id>
<country>US</country>
<doc-number>2008/0211565</doc-number>
<kind>A1</kind>
<name>Shimomura et al.</name>
<date>20080900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00019">
<document-id>
<country>US</country>
<doc-number>2008/0270508</doc-number>
<kind>A1</kind>
<name>Lundvall et al.</name>
<date>20081000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00020">
<document-id>
<country>US</country>
<doc-number>2009/0094441</doc-number>
<kind>A1</kind>
<name>Hack et al.</name>
<date>20090400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00021">
<document-id>
<country>US</country>
<doc-number>2011/0214042</doc-number>
<kind>A1</kind>
<name>Lundvall et al.</name>
<date>20110900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00022">
<othercit>&#x201c;Perform Floating-Point Operation&#x201d;, Chapter 9, Floating-Point Overview and Support Instructions, pp. 9-31-9-40, from IBM Publication No. SA22-7832-05 &#x201c;z/Architecture Principles of Operation,&#x201d; Apr. 2007.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00023">
<othercit>z/Architecture Principles of Operation, International Business Machines Corporation, SA22-7832-01, Second Edition (Oct. 2001), This earlier version of the subject document is being submitted for additional consideration. For example, examiner is directed to pp. 7-115 to 7-130 with respect to the clearly distinguishable PLO instruction (mentioned on p. 15 of applicant's amendment filed Aug. 5, 2010).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00024">
<othercit>USPTO U.S. Appl. No. 11/740,165 to Lundvall et al., filed Apr. 25, 2007, Notice of Allowance dated Sep. 22, 2010.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00025">
<othercit>&#x201c;A Summary of Densely Packed Decimal Decoding&#x201d;, www.2.hursley.ibm.com/decimal/DPDecimal.html, 5 pages, 2007.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00026">
<othercit>PowerPC User Instruction Set Architecture, Book 1, Version 2.01, Sep. 2003.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00027">
<othercit>Cowlishaw, &#x201c;Densely Packed Decimal Encoding&#x201d;, IEEE Proceedings Computer Digital Tech, ISBN1350-2387, vol. 149, No. 3, pp. 102-104, IEEE May 2002.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00028">
<othercit>IEEE Standard for Radix-Independent Floating-Point Arithmetic, IEEE Std. 854-1987.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00029">
<othercit>IEEE Standard for Binary Floating Point Arithmetic, ANSI/IEEE Std 754-1985.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00030">
<othercit>z/Architecture Principles of Operatino 6th Edition, SA22-7832-05, Apr. 2007.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00031">
<othercit>Intel Itanium Architecture Software Developers Manual, vol. 3, Instruction Set Reference, Rev. 2.2, Jan. 2006, Doc. 245319-005.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00032">
<othercit>Intel Itanium Architecture Software Developer's Manual, vol. 2, System Architecture, Rev. 2.2, Jan. 2006, Doc. 245318-005.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00033">
<othercit>z/Architecture&#x2014;Preliminary Decimal Floating Point Architecture, SA23-2232-00, Nov. 2006.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00034">
<othercit>Draft Standard for Floating Point Arithmetic P754, Rev. 1.3.0, Feb. 23, 2007.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00035">
<othercit>Intel Itanium Architecture Software Developer's Manual, vol. 1 Application Architecture Revision 2.2, Jan. 2006.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00036">
<othercit>Intel 64 and 1A 32 Architecture Software Developer's Manual, vol. 2A, Instruction Set Reference, A-M. 253666-022US, Nov. 2006.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00037">
<othercit>Intel 64 and 1A-32 Architectures Software Developer's Manuay, vol. 1: Basic Architecture 253665-022US, Nov. 2006.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00038">
<othercit>USPTO U.S. Appl. No. 13/103,368 to Lundvall et al, filed May 9, 2011, Office Action dated Oct. 17, 2012.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00039">
<othercit>USPTO U.S. Appl. No. 13/103,368, filed May 9, 2001, to Shawn D. Lundvall, Notice of Allowance dated Mar. 6, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>20</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>9</number-of-drawing-sheets>
<number-of-figures>18</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20090094441</doc-number>
<kind>A1</kind>
<date>20090409</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Hack</last-name>
<first-name>Michel H. T.</first-name>
<address>
<city>Cortlandt Manor</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Smith, Sr.</last-name>
<first-name>Ronald M.</first-name>
<address>
<city>Wappingers Falls</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Hack</last-name>
<first-name>Michel H. T.</first-name>
<address>
<city>Cortlandt Manor</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Smith, Sr.</last-name>
<first-name>Ronald M.</first-name>
<address>
<city>Wappingers Falls</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<last-name>Campbell</last-name>
<first-name>John E.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Fennema</last-name>
<first-name>Robert</first-name>
<department>2183</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A method and system are disclosed for executing a machine instruction in a central processing unit. The method comprise the steps of obtaining a perform floating-point operation instruction; obtaining a test bit; and determining a value of the test bit. If the test bit has a first value, (a) a specified floating-point operation function is performed, and (b) a condition code is set to a value determined by said specified function. If the test bit has a second value, (c) a check is made to determine if said specified function is valid and installed on the machine, (d) if said specified function is valid and installed on the machine, the condition code is set to one code value, and (e) if said specified function is either not valid or not installed on the machine, the condition code is set to a second code value.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="221.40mm" wi="166.62mm" file="US08627050-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="197.19mm" wi="170.60mm" file="US08627050-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="230.89mm" wi="172.64mm" file="US08627050-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="218.95mm" wi="172.47mm" file="US08627050-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="213.87mm" wi="181.95mm" file="US08627050-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="158.58mm" wi="125.39mm" file="US08627050-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="221.15mm" wi="165.52mm" file="US08627050-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="224.62mm" wi="169.67mm" file="US08627050-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="160.44mm" wi="145.63mm" file="US08627050-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="204.81mm" wi="200.74mm" file="US08627050-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0002" num="0001">1. Field of the Invention</p>
<p id="p-0003" num="0002">This invention relates, in general, to facilitating processing within a processing environment, and more specifically, to managing processing associated with floating point operations. Even more specifically, the preferred embodiment of the invention relates to a floating-point operation instruction, which augments the IBM z/Architecure&#xae; and can be emulated by other architectures.</p>
<p id="p-0004" num="0003">2. Background Art</p>
<p id="p-0005" num="0004">Floating point is used to represent real numbers on computers. There are different types of floating point arithmetic, including binary floating point and decimal floating point, as examples. Floating point numbers are discussed in IEEE STD 754-1985, IEEE Standard For Binary Floating-Point Arithmetic; and in IEEE STD 854-1987, IEEE Standard for Radix-Independent Floating-Point Arithmetic, which are hereby incorporated herein by reference in their entirety.</p>
<p id="p-0006" num="0005">Binary floating-point numbers are represented in computer hardware as base two (binary) fractions. While binary floating point has been very valuable over the years, there are some limitations with binary floating-point operations. For instance, binary floating point cannot represent some decimal fractions, such as 0.1; and the sealing of binary floating point requires rounding. Due to the limitations of binary floating point, decimal floating point has evolved for use in computational processing in computers and other processing environments.</p>
<p id="p-0007" num="0006">Decimal floating point is easier to comprehend, since decimal data is the most common of all numeric data. A decimal floating-point finite number includes a sign bit, an exponent and a significand. The sign bit is zero for plus and one for minus. The exponent, a signed value, is represented as an unsigned binary value by adding a bias, resulting in a biased exponent. The significand includes a string of decimal digits, where each digit is an integral value between zero and one less than the radix (i.e., 10 is the radix for decimal). The number of digit positions in the significand is called the precision of the floating-point number. The numerical value of a decimal floating-point finite number is represented as (&#x2212;1)<sup>sign</sup>&#xd7;significand&#xd7;10<sup>exponent</sup>. The value of 1&#xd7;10<sup>exponent </sup>is called the quantum.</p>
<p id="p-0008" num="0007">Floating point numbers may be represented in a variety of data formats: short, long, or extended. For example, for decimal floating-point numbers, the short format includes 32 bits, the long format includes 64 bits, and the extended format includes 128 bits.</p>
<p id="p-0009" num="0008">A computer system or machine may be provided with a multitude of floating point operation functions. For instance, an instruction may be provided to convert from binary to decimal, another instruction may convert from hexadecimal to binary. Such instructions may provide for selecting any one of the short, long and extended formats. Other functions, known in the art, may be provided for over-flow control, under-flow control, suppression control and exception control.</p>
<p id="p-0010" num="0009">Not all available functions are installed on every computer, however. Presently there is not available a floating point operation instruction that instructs the computer both to determine whether a requested floating point function is installed on the computer, and, if the function is installed, to perform that function.</p>
<heading id="h-0002" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0011" num="0010">An object of this invention is to improve processing associated with floating point operations.</p>
<p id="p-0012" num="0011">Another object of the present invention is to provide a simple mechanism for a computer to determine whether a requested floating-point operation function is installed on the computer, and, if that function is not installed, to inform a program or application, which is running on the computer, of the fact that the requested function is not installed.</p>
<p id="p-0013" num="0012">These and other objectives are attained with a method and system for executing a machine instruction in a central processing unit. The method comprises the steps of obtaining a perform floating point operation instruction; in response to obtaining said perform floating point operation instruction, obtaining a test bit; determining a value of the test bit. If the test bit has a first test bit value, (a) a specified floating-point operation function is performed, and (b) a condition code is set to a value determined by said specified function. If the test bit has a second test bit value, (c) a check is made to determine if said specified function is valid and installed on the machine, (d) if said specified function is valid and installed on the machine, the condition code is set to a first predetermined value, and (e) if said specified function is either not valid or not installed on the machine, the condition code is set to a second predetermined value.</p>
<p id="p-0014" num="0013">The following documents are herein incorporated by reference in their entireties:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0014">1. U.S. patent application Ser. No. 11/746,693 for &#x201c;Fast correctly-rounding floating-point conversion,&#x201d; filed May 10, 2007;</li>
    <li id="ul0001-0002" num="0015">2. U.S. patent application Ser. No. 11/506,717 for &#x201c;FAST CORRECTLY-ROUNDING FLOATING-POINT CONVERSION,&#x201d; filed Aug. 18, 2006;</li>
    <li id="ul0001-0003" num="0016">3. U.S. Pat. No. 5,889,980 for &#x201c;Mode independent support of format conversion instructions for hexadecimal and binary floating point processing,&#x201d; filed Sep. 3, 1997;</li>
    <li id="ul0001-0004" num="0017">4. U.S. Pat. No. 5,796,641 for &#x201c;System and table-based method for converting, binary floating-point numbers to a decimal representation,&#x201d; filed May 20, 1996;</li>
    <li id="ul0001-0005" num="0018">5. U.S. Patent Application Publication no. 2007/0061387 for &#x201c;System and table-based method for converting binary floating-point numbers to a decimal representation,&#x201d; filed Sep. 15, 2005; and</li>
    <li id="ul0001-0006" num="0019">6. U.S. Patent Application Publication no. 2007/0022152 for &#x201c;System and table-based method for converting binary floating-point numbers to a decimal representation,&#x201d; filed Jul. 20, 2006, each of the above-listed documents is herein incorporated by reference in its entirety.</li>
</ul>
</p>
<p id="p-0015" num="0020">Further benefit and advantages of this invention will become apparent from a consideration of the following detailed description, given with reference to the accompanying drawings, which specify and show preferred embodiments of the invention.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0016" num="0021"><figref idref="DRAWINGS">FIG. 1A</figref> depicts one embodiment of a short data format of a decimal floating-point number.</p>
<p id="p-0017" num="0022"><figref idref="DRAWINGS">FIG. 1B</figref> depicts one embodiment of a long data format of a decimal floating-point number.</p>
<p id="p-0018" num="0023"><figref idref="DRAWINGS">FIG. 1C</figref> depicts one embodiment of an extended data format of a decimal floating-point number.</p>
<p id="p-0019" num="0024"><figref idref="DRAWINGS">FIG. 2</figref> shows valid codes for basic perform floating-point operation (PFPO) functions that may be installed.</p>
<p id="p-0020" num="0025"><figref idref="DRAWINGS">FIG. 3</figref> illustrates a PFPO instruction in accordance with the present invention.</p>
<p id="p-0021" num="0026"><figref idref="DRAWINGS">FIG. 4</figref> shows a general register that is used to request a PFPO function.</p>
<p id="p-0022" num="0027"><figref idref="DRAWINGS">FIG. 5</figref> shows a condition code used in the present invention.</p>
<p id="p-0023" num="0028"><figref idref="DRAWINGS">FIG. 6</figref> illustrates how a test bit of the general register may be used in the practice of this invention.</p>
<p id="p-0024" num="0029"><figref idref="DRAWINGS">FIG. 7</figref> shows how a program uses the PFPO instruction of the present invention for a function that the program expects to be supported in a computer.</p>
<p id="p-0025" num="0030"><figref idref="DRAWINGS">FIG. 8</figref> illustrates how a program that wants to use a new PFPO function that may or may not be installed in the computer may be written.</p>
<p id="p-0026" num="0031"><figref idref="DRAWINGS">FIG. 9</figref> depicts one embodiment of a processing environment to incorporate and use one or more aspects of the present invention.</p>
<p id="p-0027" num="0032"><figref idref="DRAWINGS">FIG. 10</figref> depicts another embodiment of a processing environment to incorporate and use one or more aspects of the present invention.</p>
<p id="p-0028" num="0033"><figref idref="DRAWINGS">FIG. 11</figref> depicts further details of the memory of <figref idref="DRAWINGS">FIG. 10</figref>, in accordance with an aspect of the present invention.</p>
<p id="p-0029" num="0034"><figref idref="DRAWINGS">FIG. 12</figref> depicts one example of a computer program product to incorporate one or more aspects of the present invention.</p>
<p id="p-0030" num="0035"><figref idref="DRAWINGS">FIGS. 13-16</figref> summarize fields and bits in a General Register O (GRO) in an embodiment of the invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS</heading>
<p id="p-0031" num="0036">The present invention, generally, relates to managing processes associated with floating point operations on a computer system or machine. As indicated above, floating point numbers may be represented in a variety of formats: short, long and extended. <figref idref="DRAWINGS">FIGS. 1A</figref>, <b>1</b>B and <b>1</b>C show a decimal floating-point number in these formats. More specifically, <figref idref="DRAWINGS">FIG. 1A</figref> depicts one example of a short data format representation <b>100</b> of a decimal floating point number; <figref idref="DRAWINGS">FIG. 1B</figref> depicts one example of a long data format representation <b>102</b> of a decimal floating point number; and <figref idref="DRAWINGS">FIG. 1C</figref> depicts one embodiment of an extended data format representation <b>104</b> of a decimal floating point number.</p>
<p id="p-0032" num="0037">Each data format is of a different length, but has the same fields. The fields include, for instance, the following:
<ul id="ul0002" list-style="none">
    <li id="ul0002-0001" num="0000">
    <ul id="ul0003" list-style="none">
        <li id="ul0003-0001" num="0038">A sign field (S) <b>106</b> represents the sign bit of the decimal floating-point number. In one example, it is bit <b>0</b> in each format, and is set to zero far plus and one for minus;</li>
        <li id="ul0003-0002" num="0039">A combination field <b>108</b>: For finite numbers, this field includes the biased exponent and the leftmost digit of the significand; for NaNs and infinities, this field includes codes to identify them.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0033" num="0040">When bits <b>1</b>-<b>5</b> of the format are in the range of 00000-11101, the operand is a finite number. The two leftmost bits of the biased exponent and the leftmost digit of the significand are encoded in bits <b>1</b>-<b>5</b> of the format. Bit <b>6</b> through the end of the combination field includes the rest of the biased exponent.</p>
<p id="p-0034" num="0041">When bits <b>1</b>-<b>5</b> of the format field are 11110, the operand is an infinity. All bits in the combination field to the right of bit <b>5</b> of the format constitute the reserved field for infinity. A nonzero value in the reserved field is accepted in a source infinity; the reserved field is set to zero in a resultant infinity.</p>
<p id="p-0035" num="0042">When bits <b>1</b>-<b>5</b> of the format are 11111, the operand is a NaN and bit <b>6</b>, called the SNaN bit, further distinguishes QNaN from SNaN. If bit <b>6</b> is zero, then it is QNaN; otherwise, it is SNaN. All bits in the combination field to the right of bit <b>6</b> of the format constitute the reserved field for NaN. A nonzero value in the reserved field is accepted in a source NaN; the reserved field is set to zero in a resultant NaN.</p>
<p id="p-0036" num="0043">As mentioned above, a computer system may be provided with a multitude of floating point operation functions; and for example, <figref idref="DRAWINGS">FIG. 2</figref> identifies a number of such functions. These functions may be provided to convert between binary, decimal and hex numbers and to convert between the short, long and extended formats as shown for example in the z/Architecture Principles of Operation from IBM. Additional functions may be provided for over-flow control, under-flow control suppression control and exception control.</p>
<p id="p-0037" num="0044">While the present invention is described herein in terms of the well-known z/Architecture from IBM, other implementations are possible in light of the teaching of the present invention herein. To implement a floating-point operation, a program loads a register with function code and other appropriate control bits. <figref idref="DRAWINGS">FIG. 3</figref> summarizes the fields and bits of such a register, referred to as General Register <b>0</b>, or GR<b>0</b>. As can be seen, for example, the PFPO operation-type-code is loaded into bits <b>33</b>-<b>39</b>, and the PFPO operand format code for operand <b>1</b> is loaded into bits <b>40</b>-<b>47</b>. In addition, in accordance with the preferred embodiment of the present invention, this register is provided, in bit <b>32</b>, with a test bit, discussed in more detail below.</p>
<p id="p-0038" num="0045">As mentioned above, not all available PFPO functions are installed on all computers. In accordance with this invention, a PFPO instruction is provided to determine whether a requested PFOP function is available. This PFPO instruction uses the above-mentioned test bit <b>32</b> of GR<b>0</b>. In addition, this PFPO instruction, in the preferred implementation, also uses a 2-bit code referred to as the condition code. <figref idref="DRAWINGS">FIG. 4</figref> illustrates the PFPO instruction and the condition code.</p>
<p id="p-0039" num="0046">Generally, a PFPO machine instruction is fetched and executed according to the present invention. When the PFOP machine instruction is executed, a requested operation specified by the function code in general register <b>0</b> is performed and the condition code is set to indicate the result. Also, preferably, when there are no exceptional conditions, condition code <b>0</b> is set. When an IEEE nontrap exception is recognized, condition code <b>1</b> is set. When an IEEE trap exception with alternate action is recognized, condition code <b>2</b> is set. A 32-bit return code is placed in bits <b>32</b>-<b>63</b> of another register, referred to as general register <b>1</b>; bits <b>0</b>-<b>31</b> of general register <b>1</b> remain unchanged.</p>
<p id="p-0040" num="0047"><figref idref="DRAWINGS">FIGS. 13-16</figref> summarize fields and bits in a General Register O (GRO) in an embodiment of the invention. <figref idref="DRAWINGS">FIG. 13</figref> shows PFPO-Operation-type code (GRO bits <b>33</b>-<b>39</b>), and <figref idref="DRAWINGS">FIG. 14</figref> shows PFPO-Operand-Format Codes (GRO bits <b>40</b>-<b>47</b> and <b>48</b>-<b>55</b>). <figref idref="DRAWINGS">FIG. 15</figref> shows PFPO-Target-Radix-Dependent Controls (GRO, bits <b>58</b>-<b>59</b>), and <figref idref="DRAWINGS">FIG. 16</figref> shows PFPO-Rounding Method (GRO bits <b>60</b>-<b>63</b>).</p>
<p id="p-0041" num="0048">In these Figures, &#x201c;valid&#x201d; codes are codes for defined functions that may be installed, and the other codes are &#x201c;invalid&#x201d;. For example, in <figref idref="DRAWINGS">FIG. 13</figref> code <b>01</b> is a valid code, and codes <b>00</b> and <b>02</b>-<b>7</b>F are invalid. In <figref idref="DRAWINGS">FIG. 15</figref>, codes <b>00</b> to <b>0</b>A are valid and codes <b>0</b>B-FF are invalid. In <figref idref="DRAWINGS">FIG. 14</figref>, bit <b>58</b> being &#x201c;1&#x201d; is not valid for BFP and DFP targets, and bit <b>59</b> being &#x201c;1&#x201d; is not valid for BFP target. In <figref idref="DRAWINGS">FIG. 16</figref>, values of 2-7 are invalid.</p>
<p id="p-0042" num="0049">In an example z/Architecture compliant implementation of this invention, bit <b>32</b> of general register <b>0</b> is the test bit. When bit <b>32</b> is zero, the function specified by bits <b>33</b>-<b>63</b> of general register <b>0</b> is performed; each field in bits <b>33</b>-<b>63</b> must be valid and the combination must be a valid and installed function; otherwise a specification exception is recognized. When bit <b>32</b> is one, the function specified by bits <b>33</b>-<b>63</b> is not performed but, instead, the condition code is set to indicate whether these bits specify a valid and installed function; the condition code is set to 0 if the function is valid and installed, or to 3 if the function is invalid or not installed. This is particularly useful if additional functions are assigned in the future to the computer system. In the discussion below the test bit is zero except when stated otherwise.</p>
<p id="p-0043" num="0050">Bits <b>33</b>-<b>39</b> of GR<b>0</b> specify the operation type. For the PFPO-convert-floating-point-radix operation, other fields in general register <b>0</b> include first-operand format, second operand format, control flags, and rounding method.</p>
<p id="p-0044" num="0051">For the PFPO-convert-floating point-radix operation, the second operand is converted to the format of the first operand and placed at the first-operand location, a return code is placed in bits <b>32</b>-<b>63</b> of general register <b>1</b>, and the condition code is set to indicate whether an exceptional condition was recognized.</p>
<p id="p-0045" num="0052">The first and second operands are in implicit floating-point registers (FPRs) of a set of FPRs defined for operands of floating point machine instructions. The first operand is in FPR<b>0</b> (paired with FPR<b>2</b> for extended). The second operand is in FPR<b>4</b> (paired with FPR<b>6</b> for extended).</p>
<p id="p-0046" num="0053">As will be understood by those of ordinary skill in the art, the present invention may be used in conjunction with other registers, controls, functions or features of a computer system. For example, the PERFORM FLOATING-POINT OPERATION (PFPO) instruction is subject to the AFP-register control bit, bit <b>45</b> of a register referred to as control register <b>0</b>. For PFPO to be executed successfully, the AFP-register-control bit must be one; otherwise, an AFP-register data exception, DXC 1, is recognized.</p>
<p id="p-0047" num="0054"><figref idref="DRAWINGS">FIG. 6</figref> illustrate what the PFPO instruction does with respect to the test bit and the remaining function/control bits. At step <b>602</b>, the routine shown in <figref idref="DRAWINGS">FIG. 6</figref> obtains the test bit and the control bits from General Register <b>0</b>. Then, at step <b>604</b>, the routine determines whether the function code in the General Register <b>0</b> denotes an installed function and whether the other bits are valid for that function. If the function is installed and those other bits are valid, the routine proceeds to step <b>606</b>, which determines if the test bit is set or not. If the test bit is set, the condition code is set to 0 at step <b>610</b>, and the routine then returns to the next instruction in the program. If, however, at step <b>606</b>, the test bit is not set, then, at step <b>612</b>, the indicated function is performed, registers are updated, the condition code is set as defined by this function, and execution returns to the next instruction in the program.</p>
<p id="p-0048" num="0055">At step <b>604</b>, if either the requested function is not installed, or the other bits are not valid for that function, the routine proceeds to step <b>614</b>, which also determines whether the test bit is set. Here, if the test bit is set, the routine proceeds to step <b>616</b>, where the condition code is set to 3, and then the execution returns to the next instruction in the program. If, at step <b>616</b>, the test bit is not set, then at step <b>620</b>, a program interruption occurs. A program interruption means that control is transferred somewhere else, which, for example, may be to the operating system's program interrupt handler. This handler, unless explicitly told otherwise through various operating system services, would normally terminate the user's program and issue an error message to the user.</p>
<p id="p-0049" num="0056"><figref idref="DRAWINGS">FIG. 7</figref> shows how a program uses the PFPO instruction for a function that the program expects to be supported. At step <b>702</b>, the program loads General Register <b>0</b> with function code and appropriate test bits, and at step <b>704</b>, the program loads one or more floating point registers with input values. At step <b>706</b>, the floating point operation is performed, and then at step <b>710</b>, the program checks the condition code and inspects the results in one or more floating point registers.</p>
<p id="p-0050" num="0057">If the program was run on a machine that did not support the expected function, the PFPO instruction would not return in-line, and the program would usually be terminated with prejudice.</p>
<p id="p-0051" num="0058"><figref idref="DRAWINGS">FIG. 8</figref> shows how a program that wants to use a new function that may or may not be installed on the computer would be written. If the function is installed, the program has less work to do, so the program wants to exploit if the function is available&#x2014;but the program is prepared to perform this function in an alternate way that is much longer than using the PFPO instruction directly.</p>
<p id="p-0052" num="0059">At step <b>802</b>, the program loads General Register <b>0</b> with function code and appropriate control bits, and at step <b>804</b>, the program sets test bit (<b>32</b>) in GR<b>0</b>. Other bits may also be set. Step <b>806</b> is to perform the floating-point operation; however, no operation is actually performed other than to set the condition code to either 0 or 3.</p>
<p id="p-0053" num="0060">At step <b>810</b>, the condition code is checked. If that code equals 3, then, at step <b>812</b>, the function is performed via the alternate way provided for by the program itself. If however, at step <b>810</b>, the condition code equals zero, the routine proceeds to steps <b>814</b>, <b>816</b>, <b>820</b> and <b>822</b>. At step <b>814</b>, test bit (<b>32</b>) in GR<b>0</b> is cleared. Other bits may be left alone, though. At step <b>816</b>, one or more floating registers are loaded with input values. Step <b>820</b> is to perform the floating-point operation, and here the desired function is actually performed. Then, at step <b>822</b>, the program checks the condition code and inspects the results in said one or more floating point registers. The two paths in <figref idref="DRAWINGS">FIG. 8</figref>, from step <b>812</b> and <b>822</b> then rejoin.</p>
<p id="p-0054" num="0061">The Perform Floating Point Operation instruction can be implemented in many architectures and may be emulated. As examples, the instruction is executed in hardware by a processor; by software executing on a processor having a native instruction set; or by emulation of a non-native instruction set that includes this instruction. In one particular example, the instruction is implemented in the z/Architecture&#xae;, offered by International Business Machines Corporation, Armonk, N.Y. z/Architecture&#xae; is a registered trademark of International Business Machines Corporation, Armonk, N.Y., U.S.A. Other names used herein may be registered trademarks, trademarks or product names of International Business Machines Corporation or other companies. One embodiment of the z/Architecture is described in &#x201c;z/Architecture Principles of Operation,&#x201d; IBM Publication No. SA22-7832-05, 6<sup>th </sup>Edition, April 2007, which is hereby incorporated herein by reference in its entirety.</p>
<p id="p-0055" num="0062">Various specific functions with which this invention may be used, and as implemented on the IBM&#xae;, are discussed below.</p>
<p id="h-0005" num="0000">Inexact-Suppression Control</p>
<p id="p-0056" num="0063">Bit <b>56</b> of general register <b>0</b> is the inexact-suppression control. When the inexact-suppression control is zero, IEEE-inexact exceptions are recognized and reported in the normal manner. When the inexact-suppression control is one, IEEE-inexact exceptions are not recognized. The inexact-suppression control has no effect on the DXC; that is, the DXC for IEEE-over-flow or IEEE-under-flow exceptions along with the detail for exact, inexact and truncated, or inexact and incremented, is reported according to the actual condition.</p>
<p id="h-0006" num="0000">Alternate-Exception-Action Control</p>
<p id="p-0057" num="0064">Bit <b>57</b> of general register <b>0</b> is the alternate-exception-action control. The setting of this control affects the action taken for IEEE-over-flow and IEEE-under-flow trap exceptions.</p>
<p id="p-0058" num="0065">When the alternate-exception-action control is zero, IEEE-over-flow and IEEE-under-flow trap exceptions are reported in the normal manner. That is, the appropriate data exception code (DXC) is placed in byte <b>2</b> of the floating-point control register, the operation is completed, and a program interruption for a data exception occurs. (As part of the program, interruption, the DXC is stored at location <b>147</b>.) This is called an IEEE trap exception with normal action.</p>
<p id="p-0059" num="0066">When the alternate-exception-action control is one, the DXC is placed in byte <b>2</b> of the floating-point control register, the operation is completed, condition code <b>2</b> is set, and program execution continues with the next sequential instruction. (There is no program interruption and the DXC is not stored at location <b>147</b>.) This is called an IEEE trap exception with alternate action.</p>
<p id="h-0007" num="0000">HFP-Over-Flow Control:</p>
<p id="p-0060" num="0067">Bit <b>58</b> of general register <b>0</b> is the HFP-over-flow control. When the HFP-over-flow control is zero, an HFP-over-flow condition is reported as an IEEE-invalid-operation exception and is subject to IEEE-invalid-operation mask. When the HFP-over-flow control is one, an HFP-over-flow condition is reported as an IEEE-over-flow exception and is subject to the IEEE-over-flow mask.</p>
<p id="p-0061" num="0068">The HFP-over-flow control is defined only for HFP targets; when other than an HFP target is specified, this bit must be zero.</p>
<p id="h-0008" num="0000">HFP-Under-Flow Control</p>
<p id="p-0062" num="0069">For HFP targets, bit <b>59</b> of general register <b>0</b> is the HFP alternate under-flow control. When the HFP-under-flow control is zero, HFP-under-flow causes the result to be set to a true zero with the same sign as the source and under-flow is not reported. (The result in this case is inexact and subject to the inexact-suppression control.) When the HFP-under-flow control is one, the condition is reported as an IEEE-under-flow exception and is subject to the IEEE-under-flow mask.</p>
<p id="p-0063" num="0070">Bit <b>59</b> of general register <b>0</b> is defined only for HFP and DFP targets; when a BFP target is specified, this bit must be zero.</p>
<p id="h-0009" num="0000">DFP Preferred Quantum Control (DPQC)</p>
<p id="p-0064" num="0071">For DFP targets, bit <b>59</b> of general register <b>0</b> is the DFP preferred quantum control (DPQC). For radix conversion with DFP targets, if the delivered value is inexact, the cohort member with the smallest quantum is selected; if the delivered value is exact, selection depends on the value of bit <b>59</b> of general register <b>0</b>, the DFP preferred quantum control (DPQC). When the delivered value is exact and the DPQC bit is zero, the cohort member with the largest quantum is selected. When the delivered value is exact and the DPQC bit is one, the preferred quantum is one and the cohort member with the quantum closest to one is selected.</p>
<p id="p-0065" num="0072">Additional features of the IBM z-architecture and with which the present invention may be used are discussed below.</p>
<p id="h-0010" num="0000">Return Code</p>
<p id="p-0066" num="0073">Regardless of what condition code is set, and independent of whether the test bit is one, a 32-bit return code is placed in bits <b>32</b>-<b>63</b> of general register <b>1</b>; bits <b>0</b>-<b>31</b> of general register <b>1</b> remain unchanged. A return code is also placed in general register <b>1</b> when a program interruption occurs for an IEEE trap exception that completes; general register <b>1</b> is not updated when a program interruption occurs for an IEEE trap exception that suppresses. Thus, general register <b>1</b> is updated on a program interruption for IEEE-over-flow, IEEE-under-flow, and IEEE-inexact trap exceptions, but is not updated on a program interruption for an IEEE-invalid-operation trap exception. Except where otherwise specified, the return code is a value of zero.</p>
<p id="h-0011" num="0000">Sign Preservation</p>
<p id="p-0067" num="0074">For PFPO convert floating-point radix, the sign of the result is the same as the sign of the source. The only exception to this is when the source is a NaN and the target is HFP; in this case, the result is the largest representable number in the target HFP format (Hmax) with the sign set to plus.</p>
<p id="h-0012" num="0000">Preferred Quantum</p>
<p id="p-0068" num="0075">For radix conversion with DFP targets, if the delivered value is inexact, the cohort member with the smallest quantum is selected; if the delivered value is exact, selection depends on the value of bit <b>59</b> of general register <b>0</b>, the DFP preferred quantum control (DPQC). When the delivered value is exact and the DPQC bit is zero, the cohort member with the largest quantum is selected. When the delivered value is exact and the DPQC bit is one, the preferred quantum is one and the cohort member with the quantum closest to one is selected.</p>
<p id="h-0013" num="0000">NaN Conversion</p>
<p id="p-0069" num="0076">When converting between DFP and BFP, the sign of the NaN is always preserved, and the value of the payload is preserved, when possible. If the value of the source payload exceeds the maximum value of the target payload, the target is set to the default QNaN, but with the same sign as the source.</p>
<p id="p-0070" num="0077">When traps are disabled, an SNaN is converted to the corresponding QNaN, and the payload is preserved, when possible; that is, SNaN(x) is converted to QNaN(x), where x is the value of the payload. For DFP, both QNaN(0) and SNaN(0) can be represented; but in BFP, there is a representation for QNaN(0), but not for SNaN(0).</p>
<p id="h-0014" num="0000">Scaled Value and Signed Scaling Exponent (&#x3a9;) for PFPO</p>
<p id="p-0071" num="0078">When, for the PFPO-convert-floating-point-radix operation, IEEE-over-flow trap action or IEEE-under-flow trap action occurs, the sealed value is computed using the following steps:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>&#x3a8;=b<sup>&#x3a9;</sup><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>z=g+&#x3a8;</i><?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0072" num="0079">Where &#x3a9; is the signed, scaling exponent, b is the target radix (2, 10, or 16), &#x3a8; is the scale factor, g is the precision-rounded value, and z is the scaled value.</p>
<p id="p-0073" num="0080">The signed scaling exponent (&#x3a9;) is selected to make the magnitude of the value of the scaled result (z) lie in the range:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>1&#x2266;|<i>z|&#x3c;b, </i><?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0074" num="0081">The value of the signed scaling exponent (&#x3a9;), treated as a 32-bit signed binary integer, is placed in bits <b>32</b>-<b>63</b> of general register <b>1</b>; bits <b>0</b>-<b>31</b> of general register <b>1</b> remain unchanged.</p>
<p id="p-0075" num="0082">The scaled value is used as the delivered value and is placed in the result location. For DFP targets, the cohort member with the quantum nearest to the scaled preferred quantum is selected. (But it should be noted that for all currently supported conversions, the result is always inexact, so the cohort member with the smallest quantum is selected.) For BFP targets, there are no redundant representations; there is only one member in a cohort. For HFP targets, the result is normalized.</p>
<p id="h-0015" num="0000">HFP Values</p>
<p id="p-0076" num="0083">Unnormalized HFP values are accepted on input, but all HFP results are normalized. If an HFP result, would be less than the smallest (in magnitude) representable normalized number, an HFP-under-flow condition exists.</p>
<p id="h-0016" num="0000">HFP-Over-Flow and Under-Flow for PFPO</p>
<p id="p-0077" num="0084">For an HFP target of a PFPO-convert-floating-point-radix operation, the handling of over-flow and under-flow conditions is controlled by the HFP-over-flow control and the HFP-under-flow control, respectively.</p>
<p id="h-0017" num="0000">HFP-Over-Flow</p>
<p id="p-0078" num="0085">An HFP-over-flow condition exists when an BFP target precision's largest number (Hmax) is exceeded in magnitude by the precision-rounded value. That is, when the characteristic of a normalized HFP result would exceed 127 and the fraction is not zero.</p>
<p id="p-0079" num="0086">When the HFP-over-flow control is zero, HFP-over-flow is reported as an IEEE-invalid-operation exception and is subject to the IEEE-invalid-operation mask in the FPC register. This is called an HFP-Over-flow-as-IEEE-invalid-operation condition.</p>
<p id="p-0080" num="0087">When the HFP-over-flow control is one, HFP-over-flow is reported as an IEEE-over-flow exception and is subject to the IEEE-over-flow mask in the FPC register. This is called an HFP-over-flow-as-IEEE-over-flow condition.</p>
<p id="h-0018" num="0000">HFP-Under-Flow</p>
<p id="p-0081" num="0088">An HFP-under-flow condition exists when the precision-rounded value is nonzero and less in magnitude than the HFP target precision's smallest normalized number, Hmin. That is, when the characteristic of a normalized HFP result would be less than zero and the fraction is not zero. The result is set to a true zero with the same sign as the source. Reporting of the HFP-under-flow condition is subject to the HFP-under-flow control. The result in this case, however, is inexact and is subject to the controls for that condition.</p>
<p id="p-0082" num="0089">When the HFP-under-flow control is zero, the HFP-under-flow condition is not reported.</p>
<p id="p-0083" num="0090">When the HFP-under-flow control is one, HFP-under-flow is reported as an IEEE-under-flow exception and is subject to the IEEE-under-flow mask in the FPC register. This is called an BFP-under-flow-as-IEEE-under-flow condition.</p>
<p id="h-0019" num="0000">IEEE Exceptions for PFPO</p>
<p id="p-0084" num="0091">Except where otherwise stated, the following discussion on IEEE exceptions applies to both BFP and DFP.</p>
<p id="h-0020" num="0000">IEEE-Invalid-Operation</p>
<p id="p-0085" num="0092">An IEEE-invalid-operation exception is recognized when any of the following occurs:
<ul id="ul0004" list-style="none">
    <li id="ul0004-0001" num="0093">1. An SNaN is encountered in an IEEE source,</li>
    <li id="ul0004-0002" num="0094">2. In an IEEE-to-HFP conversion, a NaN or an infinity is encountered in the IEEE source.</li>
    <li id="ul0004-0003" num="0095">3. An HFP-over-flow-as-IEEE-invalid-operation condition exists.</li>
</ul>
</p>
<p id="p-0086" num="0096">IEEE-invalid-operation exceptions are recognized as either IEEE-invalid-operation nontrap exceptions or IEEE-invalid-operation trap exceptions.</p>
<p id="h-0021" num="0000">IEEE-Invalid-Operation Nontrap Action</p>
<p id="p-0087" num="0097">IEEE-invalid-operation nontrap action occurs when an IEEE-invalid-operation exception is recognized and the IEEE-invalid-operation mask bit in the FPC register is zero. The operation is completed, the IEEE-invalid-operation flag bit in the FPC register is set to one, and condition code <b>1</b> is set. The result is as follows:</p>
<p id="p-0088" num="0098">When the target is IEEE and the source is an IEEE SNaN, the result is the source NaN converted to the corresponding canonical QNaN in the target format.</p>
<p id="p-0089" num="0099">When the target is HFP and the source is an IEEE NaN, the result is the largest representable number in the target HFP format (Hmax) with the sign set to plus.</p>
<p id="p-0090" num="0100">When the target is HFP and the source is an IEEE infinity, the result is Hmax with the same sign as the source.</p>
<p id="p-0091" num="0101">When an HFP-over-flow-as-IEEE-invalid-operation condition exists, the result is Hmax with the same sign as the source.</p>
<p id="h-0022" num="0000">IEEE-Invalid-Operation Trap Action</p>
<p id="p-0092" num="0102">IEEE-invalid-operation trap action occurs when an IEEE-invalid-operation exception is recognized and the IEEE-invalid-operation mask bit in the FPC register is one. The operation is suppressed, and the exception is reported as a program interruption for a data exception with DXC 80 hex.</p>
<p id="h-0023" num="0000">IEEE-Over-Flow</p>
<p id="p-0093" num="0103">For IEEE targets, an IEEE-over-flow exception is recognized when the precision-rounded value is greater in magnitude than the largest finite number (Nmax) representable in the target format. For HFP targets, an IEEE-over-flow exception is recognized when the HFP-over-flow condition exists and the HFP-over-flow control is one.</p>
<p id="h-0024" num="0000">IEEE-Over-Flow Nontrap Action</p>
<p id="p-0094" num="0104">IEEE-over-flow nontrap action occurs when the IEEE-over-flow exception is recognized and the IEEE-over-flow mask bit in the FPC register is zero.</p>
<p id="p-0095" num="0105">The operation is completed and the IEEE-over-flow flag bit in the FPC register is set to one. For IEEE targets, the result of the operation depends on the sign of the precise intermediate value and on the effective rounding method:
<ul id="ul0005" list-style="none">
    <li id="ul0005-0001" num="0106">1. For all round-to-nearest methods and round away-from-0, the result is infinity with the sign of the precise intermediate value.</li>
    <li id="ul0005-0002" num="0107">2. For round-toward-0 and found-to-prepare-for shorter-precision, the result is the largest finite number of the format, with the sign of the precise intermediate value.</li>
    <li id="ul0005-0003" num="0108">3. For round toward +&#x221e;, the result is +&#x221e; if the sign is plus, or it is the negative finite number with the largest magnitude if the sign is minus.</li>
    <li id="ul0005-0004" num="0109">4. For round toward &#x2212;&#x221e;, the result is the largest positive finite number if the sign is plus or &#x2212;&#x221e; if the sign is minus.</li>
</ul>
</p>
<p id="p-0096" num="0110">For HFP targets, the result is set to the largest representable number in the target HFP format (Hmax) with the same sign as the source.</p>
<p id="p-0097" num="0111">Additional action depends on whether there is also an IEEE-inexact exception.</p>
<p id="p-0098" num="0112">When IEEE-over-flow nontrap action occurs and no IEEE-inexact exception has been recognized, the IEEE-over-flow flag bit in the FPC register is set to one and condition code <b>1</b> is set. (This case can occur only when the inexact-suppression control is one.)</p>
<p id="p-0099" num="0113">When both IEEE-over-flow nontrap action and IEEE-inexact nontrap action occur, the IEEE-over-flow and IEEE-inexact flag bits in the FPC register are set to ones and condition code <b>1</b> is set. When IEEE-over-flow nontrap action and IEEE-inexact trap action occur, the condition code is not set, the IEEE-over-flow flag bit in the FPC register is set to one, and the IEEE-inexact exception is reported as a program interruption for a data exception with DXC 08 or 0C hex, depending on whether the result is inexact and truncated or inexact and incremented, respectively.</p>
<p id="h-0025" num="0000">IEEE-Over-Flow Trap Action</p>
<p id="p-0100" num="0114">IEEE-over-flow trap action occurs when the IEEE-over-flow exception is recognized and the IEEE-over-flow mask bit in the FPC register is one.</p>
<p id="p-0101" num="0115">The operation is completed by setting the result to the scaled value; placing the value of the signed scaling exponent (&#x3a9;), treated as a 32-bit signed binary integer in bits <b>32</b>-<b>63</b> of general register <b>1</b>; and setting DXC 20, 28, or 2C hex, depending on whether the delivered value is exact, inexact and truncated, or inexact and incremented, respectively.</p>
<p id="p-0102" num="0116">For DFP targets, the delivered value is always, inexact and the cohort member with the smallest quantum is selected.</p>
<p id="p-0103" num="0117">Additional action depends on the value of the alternate-exception-action control.</p>
<p id="p-0104" num="0118">When the alternate-exception-action control is zero, the condition code is not set and the exception is reported as a program interruption for a data exception.</p>
<p id="p-0105" num="0119">When the alternate-exception-action control is one, condition code <b>2</b> is set and no program interruption occurs.</p>
<p id="h-0026" num="0000">IEEE-Under-Flow</p>
<p id="p-0106" num="0120">For IEEE targets, an IEEE-under-flow exception is recognized when the tininess condition exists and either; (1) the IEEE-under-flow mask bit in the FPC register is zero and the denormalized value is inexact, or (2) the IEEE-under-flow mask bit in the FPC register is one.</p>
<p id="p-0107" num="0121">The tininess condition exists when the precise intermediate value of an IEEE computational operation is nonzero and smaller in magnitude than the smallest normal number (Nmin) representable in the target format.</p>
<p id="p-0108" num="0122">The denormalized value is inexact if it is not equal to the precise intermediate value.</p>
<p id="p-0109" num="0123">For HFP targets, an IEEE-under-flow exception is recognized when the HFP-under-flow condition exists and the HFP-under-flow control is one.</p>
<p id="h-0027" num="0000">IEEE-Under-Flow Nontrap Action</p>
<p id="p-0110" num="0124">IEEE-under-flow nontrap action occurs when the IEEE-under-flow exception is recognized and the IEEE-under-flow mask bit in the FPC register is zero.</p>
<p id="p-0111" num="0125">The operation is completed and the IEEE-under-flow flag bit in the FPC register is set to one.</p>
<p id="p-0112" num="0126">For IEEE targets, the result is set to the denormalized value. For DFP targets, the cohort member with the smallest quantum is selected.</p>
<p id="p-0113" num="0127">For HFP targets, the result is set to a true zero with the same sign as the source.</p>
<p id="p-0114" num="0128">Additional action depends on whether there is also an IEEE-inexact exception. When IEEE-under-flow nontrap action occurs and no IEEE-inexact exception has been recognized, the IEEE-under-flow flag bit in the FPC register is set to one and condition code <b>1</b> is set. (This case can occur only when the inexact-suppression control is one.)</p>
<p id="p-0115" num="0129">When both IEEE-under-flow nontrap action and IEEE-inexact nontrap action occur, the IEEE-under-flow and IEEE-inexact flag bits in the FPC register are set to ones and condition code <b>1</b> is set.</p>
<p id="p-0116" num="0130">When IEEE-under-flow nontrap action, and IEEE-inexact trap action occur, the condition code is not set, the IEEE-under-flow flag bit in the FPC register is set to one, and the IEEE-inexact trap exception is reported as a program interruption for a data exception with DXC 08 or 0C hex, depending on whether the result is inexact and truncated or inexact and incremented, respectively.</p>
<p id="h-0028" num="0000">IEEE-Under-Flow Trap Action</p>
<p id="p-0117" num="0131">IEEE-under-flow trap action occurs when the IEEE-under-flow exception is recognized and the IEEE-under-flow mask, bit in the FPC register is one.</p>
<p id="p-0118" num="0132">The operation is completed by setting the result to the scaled value; placing the value of the signed sealing exponent (&#x3a9;), treated as a 32-bit signed binary integer in bits <b>32</b>-<b>63</b> of general register <b>1</b>; and setting DXC 10, 18, or 1C hex, depending on whether the result is exact, inexact and truncated, or inexact and incremented, respectively.</p>
<p id="p-0119" num="0133">For DFP targets, the delivered value is always inexact and the cohort member with the smallest quantum is selected.</p>
<p id="p-0120" num="0134">Additional action depends on the value of the alternate-exception-action control.</p>
<p id="p-0121" num="0135">When the alternate-exception-action control is zero, the condition code is not set and the exception is reported as a program interruption for a data exception.</p>
<p id="p-0122" num="0136">When the alternate-exception-action control is one, condition code <b>2</b> is set and no program interruption occurs.</p>
<p id="h-0029" num="0000">IEEE-Inexact</p>
<p id="p-0123" num="0137">An IEEE-inexact exception is recognized when, for a PFPO-convert-floating-point-radix operation, an inexact condition exists, recognition of the exception is not suppressed, and neither IEEE-over-flow trap action nor IEEE-under-flow trap action occurs.</p>
<p id="p-0124" num="0138">An inexact condition exists when the rounded intermediate value differs from the precise intermediate value. The condition also exists when IEEE-over-flow nontrap action occurs.</p>
<p id="p-0125" num="0139">Even though an inexact condition exists, the IEEE-inexact exception is not recognized if the inexact suppression control is one or if IEEE-over-flow or IEEE-under-flow trap action occurs. When an inexact condition exists and the conditions for an IEEE-over-flow trap action or IEEE-under-flow trap action also apply, the trap action takes precedence and the inexact condition is reported in the DXC.</p>
<p id="h-0030" num="0000">IEEE-Inexact Nontrap Action</p>
<p id="p-0126" num="0140">IEEE-inexact nontrap action occurs when the IEEE-inexact exception is recognized and the IEEE-inexact mask bit in the FPC register is zero.</p>
<p id="p-0127" num="0141">In the absence of another IEEE nontrap action, the operation is completed using the rounded intermediate value, condition code <b>1</b> is set, and the IEEE-inexact flag bit in the FPC register is set to one. For DFP targets, the cohort member with the smallest quantum is selected.</p>
<p id="p-0128" num="0142">When an IEEE-inexact nontrap action and another IEEE nontrap action coincide, the operation is completed using the result specified for the other exception and the flag bits for both exceptions are set to one, and condition code <b>1</b> is set.</p>
<p id="h-0031" num="0000">IEEE-Inexact Trap Action</p>
<p id="p-0129" num="0143">IEEE-inexact trap action occurs when the IEEE-inexact exception is recognized and the IEEE-inexact mask bit in the FPC register is one. The operation is completed, the condition code is not set, and the exception is reported as a program interruption for a data exception with DXC 08 or 0C hex, depending on whether the result is inexact and truncated or inexact and incremented, respectively. In the absence of a coincident IEEE nontrap action, the delivered value is set to the rounded intermediate value. For DFP targets, the cohort member with the smallest quantum is selected. When the IEEE-inexact trap action coincides with an IEEE nontrap action, the operation is completed using the result specified for the IEEE nontrap action, the flag bit for the nontrap exception is set to one, and the IEEE-inexact trap action takes place.</p>
<p id="p-0130" num="0144">Resulting Condition Code (When Test Bit is Zero):
<ul id="ul0006" list-style="none">
    <li id="ul0006-0001" num="0145">0 Normal result</li>
    <li id="ul0006-0002" num="0146">1 Nontrap exception</li>
    <li id="ul0006-0003" num="0147">2 Trap exception with alternate action</li>
    <li id="ul0006-0004" num="0148">3 - -</li>
</ul>
</p>
<p id="p-0131" num="0149">Resulting Condition Code (When Test Bit is One);
<ul id="ul0007" list-style="none">
    <li id="ul0007-0001" num="0150">0 Function is valid</li>
    <li id="ul0007-0002" num="0151">1 - -</li>
    <li id="ul0007-0003" num="0152">2 -</li>
    <li id="ul0007-0004" num="0153">3 Function is invalid</li>
</ul>
</p>
<p id="p-0132" num="0154">IEEE Exceptions:
<ul id="ul0008" list-style="none">
    <li id="ul0008-0001" num="0155">Invalid operation,</li>
    <li id="ul0008-0002" num="0156">Over-flow,</li>
    <li id="ul0008-0003" num="0157">Under-flow,</li>
    <li id="ul0008-0004" num="0158">Inexact</li>
</ul>
</p>
<p id="p-0133" num="0159">Program Exceptions:
<ul id="ul0009" list-style="none">
    <li id="ul0009-0001" num="0160">Data with DXC <b>1</b>, AFP register,</li>
    <li id="ul0009-0002" num="0161">Data with DXC for IEEE exception,</li>
    <li id="ul0009-0003" num="0162">Operation (if the PFPO facility is not installed),</li>
    <li id="ul0009-0004" num="0163">Specification.</li>
</ul>
</p>
<p id="p-0134" num="0164">The following points may also be taken into consideration when writing a program using the PFPO function.</p>
<p id="p-0135" num="0165">The PFPO-convert-floating-point-radix operation performs &#x201c;correct rounding&#x201d;; that is, the result is accurately obtained from the precise intermediate value using the effective rounding method. This is in contrast to some radix conversion programs, which may produce results with larger rounding errors. A value of zero in the rounding method field (GR<b>0</b> bits <b>60</b>-<b>63</b>) specifies rounding according to the current DFP rounding mode (FPC <b>3</b>.<b>1</b>-<b>3</b>) regardless of whether the target, is DFP, BFP, or HFP.</p>
<p id="p-0136" num="0166">If the program does not supply a default QNaN (payload=zero) as a source, then its presence as a result indicates that the machine either created a new QNaN or the program attempted to convert a payload, which was too large for this format.</p>
<p id="p-0137" num="0167">If the program restricts payloads to values within the smallest payload capacity of any format to be converted to, then payloads are preserved across radix conversions.</p>
<p id="p-0138" num="0168">In the absence of suppression, bits <b>32</b>-<b>63</b> of general register <b>1</b> are always set to a return code, even though, in most cases, the return code is zero. Future extensions of PFPO may make more use of nonzero return codes. With the current definition, the only nonzero return codes are set for IEEE-over-flow trap exceptions and IEEE-under-flow trap exceptions. In this case, the value of the signed sealing exponent (&#x3a9;), is placed in bits <b>32</b>-<b>63</b> of general register <b>1</b>. For IEEE-inexact trap exceptions, the return code is set to zero, thus indicating that no scaling has occurred.</p>
<p id="p-0139" num="0169">To display a value in scientific notation, many programming languages, calculators, and spreadsheets use the letter e (or E) to separate the significand from the exponent. This is referred to as e-form notation. In this document, e-form notation, along with other forms of conventional numeric notation, is used to represent a value without regard to quantum. To indicate that both value and quantum are being represented, a variation of e-form notation, called q-form notation, is used. In q-form notation, the letter q replaces the letter e and the value shown after q is the right-units-view exponent, that is, the base <b>10</b> logarithm of the quantum. Thus, for example, the seven members of the cohort for the value 1e6 in the DFP short format are: 1q6, 10q5, 100q4, 1000q3, 10000q, 100000q1, and 1000000q0.</p>
<p id="p-0140" num="0170">As an example of the distinction between e-form and q-form notation, consider the representation of the members of the cohort of zero. The DFP short format, for example, can represent 198 exact powers of 10, ranging in value from 1e-101 to 1e96; but can represent only 192 values for a quantum, ranging from 1e-101 to 1e90. Thus, the 192 members of the cohort for zero range from 0q-101 to 0q90.</p>
<p id="p-0141" num="0171">In one embodiment, a processor of a processing environment executes the Floating Point Operation instruction. One embodiment of a processing environment to incorporate and use one or more aspects of the present invention is described with reference to <figref idref="DRAWINGS">FIG. 9</figref>. Processing environment <b>900</b> includes, for instance, a z/Architecture&#xae; processor <b>902</b> (e.g., a central processing unit (CPU)), a memory <b>904</b> (e.g., main memory), and one or more input/output (I/O) devices <b>906</b> coupled to one another via, for example, one or more buses <b>908</b> and/or other connections.</p>
<p id="p-0142" num="0172">In the example shown, z/Architecture&#xae; processor <b>902</b> is a part of a System z&#x2122; server, offered by International Business Machines Corporation (IBM&#xae;), Armonk, N.Y. System z&#x2122; servers implement IBM's z/Architecture&#xae;, which specifies the logical structure and functional operation of the computer. The System z&#x2122; server executes an operating system, such as z/OS&#xae;, also offered by International Business Machines Corporation. IBM&#xae; and z/OS&#xae; are registered trademarks of International Business Machines Corporation, Armonk, N.Y., USA. Other names used herein may be registered trademarks, trademarks or product names of International Business Machines Corporation or other companies.</p>
<p id="p-0143" num="0173">In another embodiment, the instruction and/or the logic of the instruction can be executed in a processing environment that is based on one architecture (which may be referred to as a &#x201c;native&#x201d; architecture), but emulates another architecture (which may be referred to as a &#x201c;guest&#x201d; architecture). In such an environment, for example, the Perform Floating Point Operation instruction and/or logic thereof, which is specified in the z/Architecture&#xae; and designed to execute on a z/Architecture&#xae; machine, is emulated to execute on an architecture other than the z/Architecture&#xae;. One example of this processing environment is described with reference to <figref idref="DRAWINGS">FIGS. 10-11</figref>.</p>
<p id="p-0144" num="0174">Referring to <figref idref="DRAWINGS">FIG. 10</figref>, one embodiment of a processing environment to incorporate and use one or more aspects of the present invention is described. Processing environment <b>1000</b> includes, for instance, a native central processing unit <b>1002</b>, a memory <b>1004</b> (e.g., main memory) and one or more input/output (I/O) devices <b>1006</b> coupled to one another via, for example, one or more buses <b>1008</b> and/or other connections. As examples, processing environment <b>1000</b> may include a Power PC&#xae; processor, a pSeries&#xae; server, or an xSeries&#xae; server offered by International Business Machines Corporation, Armonk, N.Y.; an HP Superdome with Intel&#xae; Itanium&#xae; 2 processors offered by Hewlett-Packard Company, Palo Alto, Calif.; and/or other machines based on architectures offered by IBM&#xae; Hewlett-Packard, Intel&#xae;, Sun Microsystems or others. Power PC&#xae;, pSeries&#xae; and xSeries&#xae; are registered trademarks of International Business Machines Corporation, Armonk, N.Y., U.S.A. Intel&#xae; and Itanium&#xae; 2 are registered trademarks of Intel Corporation, Santa Clara, Calif.</p>
<p id="p-0145" num="0175">Native central processing unit <b>1002</b> includes one or more native registers <b>1010</b>, such as one or more general-purpose registers and/or one or more special purpose registers, used during processing within the environment. These registers include information that represents the state of the environment at any particular point in time.</p>
<p id="p-0146" num="0176">Moreover, native central processing unit <b>1002</b> executes instructions and code that are stored in memory <b>1004</b>. In one particular example, the central processing unit executes emulator code <b>1012</b> stored in memory <b>1004</b>. This code enables the processing environment configured in one architecture to emulate another architecture. For instance, emulator code <b>1012</b> allows machines based on architectures other than the z/Architecture&#xae;, such as Power PC&#xae; processors, pSeries&#xae; servers, xSeries&#xae; servers, HP Superdome&#xae; servers, or others to emulate the z/Architecture&#xae; and to execute software and instructions developed based on the z/Architecture&#xae;.</p>
<p id="p-0147" num="0177">Further details relating to emulator code <b>1012</b> are described with reference to <figref idref="DRAWINGS">FIG. 11</figref>. Guest instructions <b>1102</b> comprise software instructions (e.g., machine instructions) that were developed to be executed in an architecture other than that of native CPU <b>1002</b>. For example, guest instructions <b>1102</b> may have been, designed to execute on z/Architecture&#xae; processor <b>902</b>, but are instead being emulated on native CPU <b>1002</b> (which may be for example an Intel&#xae; Itanium&#xae; 2 processor). In one example, emulator code <b>1012</b> includes an instruction fetching routine <b>1100</b> to obtain one or more guest instructions <b>1102</b> from memory <b>1004</b>, and to optionally provide local buffering for the instruction obtained. It also includes an instruction translation routine <b>1104</b> to determine the type of guest instruction that has been obtained and to translate the guest instruction into one or more corresponding native instructions <b>1109</b>. This translation includes, for instance, identifying the function to be performed by the guest instruction and choosing the native instructions to perform that function.</p>
<p id="p-0148" num="0178">Further, emulator <b>1012</b> includes an emulation control routine <b>1106</b> to cause the native instructions to be executed. Emulation control routine <b>1106</b> may cause native CPU <b>1002</b> to execute a routine of native instructions that emulate one or more previously obtained guest instructions and, at the conclusion of such execution, to return control to the instruction fetch routine to emulate the obtaining of the next guest instruction or group of guest instructions. Execution of the native instructions <b>1109</b> may include loading data into a register from memory <b>1004</b>; storing data back to memory from a register; or performing some type of arithmetic or logical operation, as determined by the translation routine.</p>
<p id="p-0149" num="0179">Each routine is, for instance, implemented in software, which is stored in memory and executed by the native central processing unit <b>1002</b>. In other examples, one or more of the routines or operations are implemented in firmware, hardware, software or some combination thereof. The registers of the emulated guest processor may be emulated using this registers <b>1010</b> of the native CPU or by using locations in memory <b>1004</b>. In embodiments, the guest instructions <b>1102</b>, native instructions <b>1109</b>, and emulation code <b>1012</b> may reside in the same memory or may be dispersed among different memory devices.</p>
<p id="p-0150" num="0180">In one example, a guest instruction <b>1102</b> that is obtained, translated and executed is the Perform Floating Point Operation instruction or similar instruction. The Perform Floating Point Operation instruction, which is a z/Architecture&#xae; instruction in this example, is fetched from memory, translated and represented as a sequence of native instructions <b>1109</b> (e.g., Power PC&#xae;, pSeries&#xae;, xSeries&#xae;, Intel&#xae;, etc.) which are executed.</p>
<p id="p-0151" num="0181">In another embodiment, a Perform Floating Point Operation instruction is executed in another architecture environment including, for example, an architecture as described in the &#x201c;INTEL&#xae; 64 and IA-32 Architectures Software Developer's Manual Volume 1,&#x201d; Order Number 253665-022US, November 2006; &#x201c;INTEL&#xae; 64 and IA-32 Architectures Software Developer's Manual Volume 2A,&#x201d; Order Number 253666-022US, November 2006; the &#x201c;INTEL&#xae; Itanium&#xae; Architecture Software Developer's Manual Volume 1,&#x201d; Doc. No. 245317-005, January 2006; the &#x201c;INTEL&#xae; Itanium&#xae; Architecture Software Developer's Manual Volume 2,&#x201d; Doc. No. 245318-005, January 2006; and/or the &#x201c;INTEL&#xae; Itanium&#xae; Architecture Software Developer's Manual Volume 3,&#x201d; Doc. No. 245319-005, January 2006; each of which is hereby incorporated herein by reference in its entirety.</p>
<p id="p-0152" num="0182">In yet a further embodiment, a data processing system suitable for storing and/or executing program code is usable that includes at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements include, for instance, local memory employed during actual execution of the program code, bulk storage, and cache memory which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.</p>
<p id="p-0153" num="0183">Input/Output or I/O devices (including, but not limited to, keyboards, displays, pointing devices, DASD, tape, CDs, DVDs, thumb drives and other memory media, etc.) can be coupled to the system either directly or through intervening I/O controllers. Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems, cable modems, and Ethernet cards are just a few of the available types of network adapters.</p>
<p id="p-0154" num="0184">One or more aspects of the present invention can be included in an article of manufacture (e.g., one or more computer program products) having, for instance, computer usable medium. The media has therein, for instance, computer readable program code means or logic (e.g., instructions, code, commands, etc.) to provide and facilitate the capabilities of the present invention. The article of manufacture can be included as a part of a system (e.g., computer system) or sold separately.</p>
<p id="p-0155" num="0185">One example of an article of manufacture or a computer program product incorporating one or more aspects of the present invention is described with reference to <figref idref="DRAWINGS">FIG. 12</figref>. A computer program product <b>1200</b> includes, for instance, one or more computer usable media <b>1202</b> to store computer readable program code means or logic <b>1204</b> thereon to provide and facilitate one or more aspects of the present invention. The medium can be an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system (or apparatus or device) or a propagation medium. Examples of a computer readable medium include a semiconductor or solid-state memory, magnetic tape, a removable computer diskette, a random access memory (RAM), a read-only memory (ROM), a rigid magnetic disk and an optical disk. Examples of optical disks include compact disk-read only memory (CD-ROM), compact disk-read/write (CD-R/W) and DVD.</p>
<p id="p-0156" num="0186">A sequence of program instructions or a logical assembly of one or more interrelated modules defined by one or more computer readable program code means or logic direct the performance of one or more aspects of the present invention.</p>
<p id="p-0157" num="0187">Advantageously, a capability is provided for facilitating detection of whether, for instructions, which support more subfunctions, and which may support more subfunctions in the future, a particular subfunction is installed, without risking program termination due to use of an uninstalled feature.</p>
<p id="p-0158" num="0188">Although one or more examples have been provided herein, these are only examples. Many variations are possible without departing from the spirit of the present invention. For instance, processing environments other than the examples provided herein may include and/or benefit from one or more aspects of the present invention. As an example, a processor can be other than an IBM System z&#x2122; processor and can execute an operating system other than z/OS&#xae;. Further, the environment need not be based on the z/Architecture&#xae;, but instead can be based on other architectures offered by, for instance, IBM&#xae;, Intel&#xae;, Sun Microsystems, as well as others. Yet further, the environment can include multiple processors, be partitioned, and/or be coupled to other systems, as examples.</p>
<p id="p-0159" num="0189">Additionally, the instruction can include other registers or entities other than registers to designate information. Further, although examples of registers are described above, each of the registers may include more, less or different information. Further, each may include additional data not necessarily needed in one or more aspects of the present invention. Specific location within the registers for the information is implementation and/or architecture dependent. Yet further, different data and/or positioning within the registers and/or entities are possible.</p>
<p id="p-0160" num="0190">Still further, one or more aspects of the present invention can be usable with other floating point systems, including variations on the decimal floating point described herein. One or more aspects of the present invention can be used with any floating point systems that include quantum, including hexadecimal or others. Further, the formats of decimal floating-point numbers, as well as properties and any other characteristics, including but not limited to, the contents of the data formats may be different than described herein. A decimal floating point number can be defined as having more, less or different components than described herein; definitions can vary; and/or there can be more, less or different formats.</p>
<p id="p-0161" num="0191">Moreover, although in the logic of Perform Floating Point Operation instruction, the test bit is set equal to one of a set of particulars numbers, other numbers or entities may be used. Further, steps of the instruction can be performed in differing order.</p>
<p id="p-0162" num="0192">Additional details regarding decimal floating point are described in &#x201c;Round For Reround Mode In Decimal Floating Point Instruction,&#x201d; U.S. Ser. No. 11/680,894, filed Mar. 1, 2007, which is hereby incorporated herein by reference in its entirety.</p>
<p id="p-0163" num="0193">As used herein, the term &#x201c;obtaining&#x201d; as in, for instance, &#x201c;obtaining an instruction&#x201d; includes, but is not limited to, fetching, receiving, having, providing, being provided, creating, developing, etc.</p>
<p id="p-0164" num="0194">The capabilities of one or more aspects of the present invention can be implemented in software, firmware, hardware, or some combination thereof. At least one program storage device readable by a machine embodying at least one program of instructions executable by the machine to perform the capabilities of the present invention can be provided.</p>
<p id="p-0165" num="0195">The flow diagrams depicted herein are just examples. There may be many variations to these diagrams or the steps (or operations) described therein without departing from the spirit of the invention. For instance, the steps may be performed in a differing order, or steps may be added, deleted, or modified. All of these variations are considered a part of the claimed invention.</p>
<p id="p-0166" num="0196">Although embodiments have been depicted and described in detail herein, it will be apparent to those skilled in the relevant art that various modifications, additions, substitutions and the like can be made without departing from the spirit of the invention, and these are, therefore, considered to be within the scope of the invention as defined in the claims.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A computer implemented method for performing a perform floating point operation (PFPO) instruction for converting any one of a Binary Floating-Point operand, a Hexadecimal Floating-Point operand or a Decimal Floating-Point operand, the method comprising:
<claim-text>obtaining said PFPO instruction defined for a computer architecture, the PFPO instruction consisting of an operation code, the instruction having implied operands consisting of general register <b>0</b> (GR<b>0</b>) and general register <b>1</b> (GR<b>1</b>); and</claim-text>
<claim-text>executing, by a processor, the obtained PFPO instruction, the executing comprising:</claim-text>
<claim-text>responsive to a Test (T) bit of GR<b>0</b> being a 0, performing a) and b):</claim-text>
<claim-text>a) performing a floating-point conversion function specified by a plurality of function fields of GR<b>0</b> to produce a result, wherein the function fields of GR<b>0</b> comprise a PFPO operation type code, a PFPO operand format code for operand <b>1</b>, a PFPO operand format code for operand <b>2</b>, an Inexact suppression control, an Alternate exception action control and a PFPO rounding method, wherein the floating-point conversion function specified is one of a plurality of specifiable floating-point conversion functions, wherein the computer is configured to execute installed floating-point conversion functions of the plurality of specifiable floating-point conversion functions;</claim-text>
<claim-text>b) storing the result in GR<b>1</b> and setting a condition code, the condition code indicating whether the performing the floating-point conversion function specified encountered an exceptional condition;</claim-text>
<claim-text>responsive to the T bit of GR<b>0</b> being a 1, performing c) and d):</claim-text>
<claim-text>c) determining whether the floating-point conversion function specified by the plurality of function fields of GR<b>0</b> is an installed specifiable floating-point conversion function; and</claim-text>
<claim-text>d) setting a condition code without storing a result, the condition code indicating whether the floating-point conversion function specified is an installed specifiable floating-point conversion function.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the performing the floating-point conversion function comprises:
<claim-text>responsive to the PFPO operation type code specifying a PFPO Convert Floating-Point Radix, converting operand <b>2</b> to the format of operand <b>1</b>, wherein operand <b>1</b> and operand <b>2</b> are floating point registers (FPRs);</claim-text>
<claim-text>storing the converted operand <b>2</b> in operand <b>1</b>; and</claim-text>
<claim-text>storing a return code in GR<b>1</b>.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method according to <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the PFPO instruction defined for the computer architecture is obtained and executed by a central processing unit of an alternate computer architecture,
<claim-text>wherein the execution further comprises interpreting the PFPO instruction to identify a predetermined routine for emulating the operation of the PFPO instruction; and</claim-text>
<claim-text>wherein executing the PFPO instruction comprises executing the predetermined routine to perform steps of the method for executing the PFPO instruction.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method according to <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising:
<claim-text>responsive to the PFPO operation type code for operand <b>2</b> having a first value, converting a Binary Floating Point (BFP) value of operand <b>2</b> to operand <b>1</b>; and</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>2</b> having a second value, converting a Hexadecimal Floating Point (HFP) operand <b>2</b> to operand <b>1</b>.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method according to <claim-ref idref="CLM-00004">claim 4</claim-ref>, further comprising any one of:
<claim-text>responsive to the PFPO operation type code for operand <b>2</b> having a third value, converting a Decimal Floating Point (DFP) value of operand <b>2</b> to operand <b>1</b>;</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>2</b> having a fourth value, converting a BFP value of operand <b>2</b> to operand <b>1</b>;</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>2</b> having a fifth value, converting a HFP value of operand <b>2</b> to operand <b>1</b>; or</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>2</b> having a sixth value, converting a DFP value of operand <b>2</b> to operand <b>1</b>.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method according to <claim-ref idref="CLM-00004">claim 4</claim-ref>, further comprising any one of:
<claim-text>responsive to the PFPO operation type code for operand <b>1</b> having the first value, converting operand <b>2</b> to a Binary Floating Point (BFP) value of operand <b>1</b>;</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>1</b> having the first value, converting operand <b>2</b> to a Binary Floating Point (BFP) value of operand <b>1</b>;</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>1</b> having the second value, converting operand <b>2</b> to a Hexadecimal Floating Point (HFP) value of operand <b>1</b>;</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>1</b> having the third value, converting operand <b>2</b> to a Decimal Floating Point (DFP) value of operand <b>1</b>;</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>1</b> having the fourth value, converting operand <b>2</b> to a BFP value of operand <b>1</b>;</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>1</b> having the fifth value, converting operand <b>2</b> to a HFP value of operand <b>1</b>; or</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>1</b> having the sixth value, converting operand <b>2</b> to a DFP value of operand <b>1</b>.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the condition code of step d) being a 0 indicates the function specified is installed and wherein the condition code of step d) being a 3 indicates the function specified is any one of invalid or not installed.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. An article of manufacture for performing a perform floating point operation (PFPO) instruction for converting any one of a Binary Floating-Point operand, a Hexadecimal Floating-Point operand or a Decimal Floating-Point operand, comprising:
<claim-text>at least one non-transitory computer usable storage medium having computer readable program code logic tangibly embodied therein for execution by the computer for performing a method comprising:</claim-text>
<claim-text>obtaining said PFPO instruction defined for a computer architecture, the PFPO instruction consisting of an operation code, the instruction having implied operands consisting of general register <b>0</b> (GR<b>0</b>) and general register <b>1</b> (GR<b>1</b>); and</claim-text>
<claim-text>executing, by a processor, the obtained PFPO instruction, the executing comprising:</claim-text>
<claim-text>responsive to a Test (T) bit of GR<b>0</b> being a 0, performing a) and b):</claim-text>
<claim-text>a) performing a floating-point conversion function specified by a plurality of function fields of GR<b>0</b> to produce a result, wherein the function fields of GR<b>0</b> comprise a PFPO operation type code, a PFPO operand format code for operand <b>1</b>, a PFPO operand format code for operand <b>2</b>, an Inexact suppression control, an Alternate exception action control and a PFPO rounding method, wherein the floating-point conversion function specified is one of a plurality of specifiable floating-point conversion functions, wherein the computer is configured to execute installed floating-point conversion functions of the plurality of specifiable floating-point conversion functions;</claim-text>
<claim-text>b) storing the result in GR<b>1</b> and setting a condition code, the condition code indicating whether the performing the floating-point conversion function specified encountered an exceptional condition;</claim-text>
<claim-text>responsive to the T bit of GR<b>0</b> being a 1, performing c) and d):</claim-text>
<claim-text>c) determining whether the floating-point conversion function specified by the plurality of function fields of GR<b>0</b> is an installed specifiable floating-point conversion function; and</claim-text>
<claim-text>d) setting a condition code without storing a result, the condition code indicating whether the floating-point conversion function specified is an installed specifiable floating-point conversion function.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The article of manufacture according to <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the performing the floating-point conversion function comprises:
<claim-text>responsive to the PFPO operation type code specifying a PFPO Convert Floating-Point Radix, converting operand <b>2</b> to the format of operand <b>1</b>, wherein operand <b>1</b> and operand <b>2</b> are floating point registers (FPRs);</claim-text>
<claim-text>storing the converted operand <b>2</b> in operand <b>1</b>; and</claim-text>
<claim-text>storing a return code in GR<b>1</b>.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The article of manufacture according to <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the PFPO instruction defined for the computer architecture is obtained and executed by a central processing unit of an alternate computer architecture,
<claim-text>wherein the execution further comprises interpreting the PFPO instruction to identify a predetermined routine for emulating the operation of the PFPO instruction; and</claim-text>
<claim-text>wherein executing the PFPO instruction comprises executing the predetermined routine to perform steps of the method for executing the PFPO instruction.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The article of manufacture according to <claim-ref idref="CLM-00009">claim 9</claim-ref>, further comprising:
<claim-text>responsive to the PFPO operation type code for operand <b>2</b> having a first value, converting a Binary Floating Point (BFP) value of operand <b>2</b> to operand <b>1</b>; and</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>2</b> having a second value, converting a Hexadecimal Floating Point (HFP) operand <b>2</b> to operand <b>1</b>.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The article of manufacture according to <claim-ref idref="CLM-00011">claim 11</claim-ref>, further comprising any one of:
<claim-text>responsive to the PFPO operation type code for operand <b>2</b> having a third value, converting a Decimal Floating Point (DFP) value of operand <b>2</b> to operand <b>1</b>;</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>2</b> having a fourth value, converting a BFP value of operand <b>2</b> to operand <b>1</b>;</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>2</b> having a fifth value, converting a HFP value of operand <b>2</b> to operand <b>1</b>; or</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>2</b> having a sixth value, converting a DFP value of operand <b>2</b> to operand <b>1</b>.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The article of manufacture according to <claim-ref idref="CLM-00011">claim 11</claim-ref>, further comprising any one of:
<claim-text>responsive to the PFPO operation type code for operand <b>1</b> having the first value, converting operand <b>2</b> to a Binary Floating Point (BFP) value of operand <b>1</b>;</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>1</b> having the first value, converting operand <b>2</b> to a Binary Floating Point (BFP) value of operand <b>1</b>;</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>1</b> having the second value, converting operand <b>2</b> to a Hexadecimal Floating Point (HFP) value of operand <b>1</b>;</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>1</b> having the third value, converting operand <b>2</b> to a Decimal Floating Point (DFP) value of operand <b>1</b>;</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>1</b> having the fourth value, converting operand <b>2</b> to a BFP value of operand <b>1</b>;</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>1</b> having the fifth value, converting operand <b>2</b> to a HFP value of operand <b>1</b>; or</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>1</b> having the sixth value, converting operand <b>2</b> to a DFP value of operand <b>1</b>.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The article of manufacture according to <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the condition code of step d) being a 0 indicates the function specified is installed and wherein the condition code of step d) being a 3 indicates the function specified is any one of invalid or not installed.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. A system for performing a perform floating point operation (PFPO) instruction for converting any one of a Binary Floating-Point operand, a Hexadecimal Floating-Point operand or a Decimal Floating-Point operand in a central processing unit, the PFPO instruction consisting of an operation code, the instruction having implied operands consisting of general register <b>0</b> (GR<b>0</b>) and general register <b>1</b> (GR<b>1</b>), said system comprising:
<claim-text>a memory; and</claim-text>
<claim-text>a processor connected to said memory, the system configured to perform a method comprising:</claim-text>
<claim-text>obtaining said PFPO instruction defined for a computer architecture; and</claim-text>
<claim-text>executing, by a processor, the obtained PFPO instruction, the executing comprising:
<claim-text>responsive to a Test (T) bit of GR<b>0</b> being a 0, performing a) and b):</claim-text>
</claim-text>
<claim-text>a) performing a floating-point conversion function specified by a plurality of function fields of GR<b>0</b> to produce a result, wherein the function fields of GR<b>0</b> comprise a PFPO operation type code, a PFPO operand format code for operand <b>1</b>, a PFPO operand format code for operand <b>2</b>, an Inexact suppression control, an Alternate exception action control and a PFPO rounding method, wherein the floating-point conversion function specified is one of a plurality of specifiable floating-point conversion functions, wherein the computer is configured to execute installed floating-point conversion functions of the plurality of specifiable floating-point conversion functions;</claim-text>
<claim-text>b) storing the result in GR<b>1</b> and setting a condition code, the condition code indicating whether the performing the floating-point conversion function specified encountered an exceptional condition;
<claim-text>responsive to the T bit of GR<b>0</b> being a 1, performing c) and d):</claim-text>
</claim-text>
<claim-text>c) determining whether the floating-point conversion function specified by the plurality of function fields of GR<b>0</b> is an installed specifiable floating-point conversion function; and</claim-text>
<claim-text>d) setting a condition code without storing a result, the condition code indicating whether the floating-point conversion function specified is an installed specifiable floating-point conversion function.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The system according to <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the performing the floating-point conversion function comprises:
<claim-text>responsive to the PFPO operation type code specifying a PFPO Convert Floating-Point Radix, converting operand <b>2</b> to the format of operand <b>1</b>, wherein operand <b>1</b> and operand <b>2</b> are floating point registers (FPRs);</claim-text>
<claim-text>storing the converted operand <b>2</b> in operand <b>1</b>; and</claim-text>
<claim-text>storing a return code in GR<b>1</b>.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The system according to <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the PFPO instruction defined for the computer architecture is obtained and executed by a central processing unit of an alternate computer architecture,
<claim-text>wherein the execution further comprises interpreting the PFPO instruction to identify a predetermined routine for emulating the operation of the PFPO instruction; and</claim-text>
<claim-text>wherein executing the PFPO instruction comprises executing the predetermined routine to perform steps of the method for executing the PFPO instruction.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The system according to <claim-ref idref="CLM-00016">claim 16</claim-ref>, further comprising:
<claim-text>responsive to the PFPO operation type code for operand <b>2</b> having a first value, converting a Binary Floating Point (BFP) value of operand <b>2</b> to operand <b>1</b>; and</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>2</b> having a second value, converting a Hexadecimal Floating Point (HFP) operand <b>2</b> to operand <b>1</b>.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The system according to <claim-ref idref="CLM-00018">claim 18</claim-ref>, further comprising any one of:
<claim-text>responsive to the PFPO operation type code for operand <b>2</b> having a third value, converting a Decimal Floating Point (DFP) value of operand <b>2</b> to operand <b>1</b>;</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>2</b> having a fourth value, converting a BFP value of operand <b>2</b> to operand <b>1</b>;</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>2</b> having a fifth value, converting a HFP value of operand <b>2</b> to operand <b>1</b>; or</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>2</b> having a sixth value, converting a DFP value of operand <b>2</b> to operand <b>1</b>.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The system according to <claim-ref idref="CLM-00018">claim 18</claim-ref>, further comprising any one of:
<claim-text>responsive to the PFPO operation type code for operand <b>1</b> having the first value, converting operand <b>2</b> to a Binary Floating Point (BFP) value of operand <b>1</b>;</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>1</b> having the first value, converting operand <b>2</b> to a Binary Floating Point (BFP) value of operand <b>1</b>;</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>1</b> having the second value, converting operand <b>2</b> to a Hexadecimal Floating Point (HFP) value of operand <b>1</b>;</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>1</b> having the third value, converting operand <b>2</b> to a Decimal Floating Point (DFP) value of operand <b>1</b>;</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>1</b> having the fourth value, converting operand <b>2</b> to a BFP value of operand <b>1</b></claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>1</b> having the fifth value, converting operand <b>2</b> to a HFP value of operand <b>1</b>; or</claim-text>
<claim-text>responsive to the PFPO operation type code for operand <b>1</b> having the sixth value, converting operand <b>2</b> to a DFP value of operand <b>1</b>.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
