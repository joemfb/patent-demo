<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08625422-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08625422</doc-number>
<kind>B1</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13786144</doc-number>
<date>20130305</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>H</section>
<class>04</class>
<subclass>L</subclass>
<main-group>12</main-group>
<subgroup>50</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>370230</main-classification>
<further-classification>370235</further-classification>
<further-classification>370389</further-classification>
<further-classification>707764</further-classification>
<further-classification>709223</further-classification>
<further-classification>712 11</further-classification>
<further-classification>712 16</further-classification>
</classification-national>
<invention-title id="d2e43">Parallel processing using multi-core processor</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6119215</doc-number>
<kind>A</kind>
<name>Key et al.</name>
<date>20000900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6523060</doc-number>
<kind>B1</kind>
<name>Kao</name>
<date>20030200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>7088731</doc-number>
<kind>B2</kind>
<name>Iny</name>
<date>20060800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>7725573</doc-number>
<kind>B2</kind>
<name>Raghunath et al.</name>
<date>20100500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>7792027</doc-number>
<kind>B2</kind>
<name>Tatar et al.</name>
<date>20100900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2002/0154648</doc-number>
<kind>A1</kind>
<name>Araya et al.</name>
<date>20021000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2003/0179706</doc-number>
<kind>A1</kind>
<name>Goetzinger et al.</name>
<date>20030900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2006/0056406</doc-number>
<kind>A1</kind>
<name>Bouchard et al.</name>
<date>20060300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370389</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2007/0169001</doc-number>
<kind>A1</kind>
<name>Raghunath et al.</name>
<date>20070700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717130</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2009/0235050</doc-number>
<kind>A1</kind>
<name>Raghunath et al.</name>
<date>20090900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2012/0159464</doc-number>
<kind>A1</kind>
<name>Demetriou et al.</name>
<date>20120600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2013/0013838</doc-number>
<kind>A1</kind>
<name>Sakamoto et al.</name>
<date>20130100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710305</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2013/0086279</doc-number>
<kind>A1</kind>
<name>Archer et al.</name>
<date>20130400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709233</main-classification></classification-national>
</us-citation>
<us-citation>
<nplcit num="00014">
<othercit>Non-Final Office Action mailed Oct. 15, 2013, for U.S. Appl. No. 13/786,232 by Finney, D., et al., filed Mar. 5, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00015">
<othercit>Notice of Allowance mailed Oct. 9, 2013, for U.S. Appl. No. 13/786,306 by Finney, D., et al., filed Mar. 5, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>29</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>15</number-of-drawing-sheets>
<number-of-figures>11</number-of-figures>
</figures>
<us-related-documents>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61740374</doc-number>
<date>20121220</date>
</document-id>
</us-provisional-application>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only" applicant-authority-category="assignee">
<addressbook>
<orgname>Unbound Networks</orgname>
<address>
<city>San Carlos</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Finney</last-name>
<first-name>Damon</first-name>
<address>
<city>San Jose</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Mathur</last-name>
<first-name>Ashok</first-name>
<address>
<city>San Carlos</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Perkins Coie LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Unbound Networks</orgname>
<role>02</role>
<address>
<city>San Carlos</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Pham</last-name>
<first-name>Chi</first-name>
<department>2471</department>
</primary-examiner>
<assistant-examiner>
<last-name>Hom</last-name>
<first-name>Shick</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Disclosed are methods, systems, paradigms and structures for processing data packets in a communication network by a multi-core network processor. The network processor includes a plurality of multi-threaded core processors and special purpose processors for processing the data packets atomically, and in parallel. An ingress module of the network processor stores the incoming data packets in the memory and adds them to an input queue. The network processor processes a data packet by performing a set of network operations on the data packet in a single thread of a core processor. The special purpose processors perform a subset of the set of network operations on the data packet atomically. An egress module retrieves the processed data packets from a plurality of output queues based on a quality of service (QoS) associated with the output queues, and forwards the data packets towards their destination addresses.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="224.20mm" wi="171.37mm" file="US08625422-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="229.95mm" wi="170.01mm" orientation="landscape" file="US08625422-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="246.13mm" wi="172.97mm" file="US08625422-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="242.15mm" wi="167.05mm" file="US08625422-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="249.09mm" wi="179.92mm" file="US08625422-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="242.82mm" wi="173.65mm" file="US08625422-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="253.07mm" wi="186.52mm" file="US08625422-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="245.45mm" wi="161.12mm" file="US08625422-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="247.73mm" wi="187.79mm" file="US08625422-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="236.56mm" wi="149.94mm" file="US08625422-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="222.76mm" wi="180.85mm" orientation="landscape" file="US08625422-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="245.11mm" wi="170.01mm" file="US08625422-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="244.18mm" wi="169.67mm" file="US08625422-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="231.65mm" wi="176.95mm" orientation="landscape" file="US08625422-20140107-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="242.49mm" wi="175.26mm" file="US08625422-20140107-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="231.31mm" wi="179.24mm" orientation="landscape" file="US08625422-20140107-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CLAIM OF PRIORITY</heading>
<p id="p-0002" num="0001">This application claims the benefit of U.S. Provisional Application Ser. No. 61/740,374, filed on Dec. 20, 2012.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">FIELD OF INVENTION</heading>
<p id="p-0003" num="0002">This invention generally relates to parallel processing. More specifically, the invention relates to parallel processing using multi-core processors.</p>
<heading id="h-0003" level="1">BACKGROUND</heading>
<p id="p-0004" num="0003">A multi-core processor is a single computing component with two or more independent actual central processing units (called &#x201c;cores&#x201d;), which are the units that read and execute program instructions. Multi-core processors are used across many application domains including general-purpose, embedded, network, digital signal processing (DSP), and graphics. The improvement in performance gained by the use of a multi-core processor depends very much on the software algorithms used and their implementation. In particular, possible gains are limited by the fraction of the software that can be run in parallel simultaneously on multiple cores.</p>
<p id="p-0005" num="0004">In multi-core network processing, a key challenge is how to exploit all the cores in these devices to achieve maximum networking performance, despite the performance limitations inherent in a symmetric multiprocessing operating system. In the current multi-core network processor architecture, the processing of a data packet is done by one or more core processors. The synchronization between various core processors and various threads of core processors, memory management, etc. are achieved through software programming. Further, when the processing of the data packet passes from one core to another core, the state or synchronization information is passed between the cores or between the threads of the core processing the data packet.</p>
<p id="p-0006" num="0005">Significant resources are consumed in passing the state/synchronization information between the threads or the processors which reduces the availability of the resources for performing actual network application related tasks. Therefore, the overhead of passing the state/synchronization information decreases the efficiency of the processor.</p>
<p id="p-0007" num="0006">Further, in current architecture, the core processor does not perform any useful network related operation while waiting for the arrival of the next data packet. The core processor may be idle until the next data packet arrives at the core processor. In current systems that have multi-core processors with an array of pipelined special purpose cores, the multi-core processor is limited by the capabilities of the special cores and pipeline depth. The multi-core is also limited by the slowest core.</p>
<heading id="h-0004" level="1">SUMMARY</heading>
<p id="p-0008" num="0007">Introduced here are methods, systems, paradigms and structures for parallel processing using multi-core processors. The disclosed solution can be used in various applications such as general purpose processing, network processing, storage systems, etc. In one embodiment, the above multi-core processor may be used as a (network) processor in a communication network for processing data packets. The network processor includes a plurality of multi-threaded core processors and a plurality of special purpose processors for processing the data packets atomically and in parallel. The network processor processes a data packet by performing a set of network operations on the data packet. The set of network operations can be based on applications/network protocols such as Resource Reservation Protocol (RSVP).</p>
<p id="p-0009" num="0008">A particular data packet is processed by a single core processor and by a single thread of the core processor. The core processor may request one or more special purpose processors to perform a subset of the set of network operations on the data packet. A special purpose processor is any processing element that exclusively handles all accesses and updates to a specific set of shared resources such that those shared resources are always accessed and updated atomically. The special purpose processor may be hardware specifically designed to handle certain types of state data (for example, meters, queues, statistics, Volume Table of Contents (VTOCs), etc.) or general purpose cores which have been dedicated to processing the specified set of shared resources. The one or more special-purpose processors processes the data packet by performing the set of operations atomically. That is, the network processor ensures that the shared resources of the network processor used for processing the particular data packet is not used by other resources of the network processor while the particular data packet is being processed. This locking out of the shared resources involved in the process ensures the atomicity of the process.</p>
<p id="p-0010" num="0009">An ingress module in the network processor allocates memory for the incoming data packets and stores the data packets in a memory of the network processor. The ingress module generates a packet buffer chain linking various buffers containing portions of the data packet, for a data packet whose size exceeds the buffer size. The ingress module adds the incoming data packets to an input queue from which one of the core processors retrieves a data packet for further processing. An output packet processor in the network processor adds the processed data packet to one of a plurality of output queues based on a quality of service (QoS) associated with the output queue and forwards the data packets contained in the output queues towards their destination addresses based on the QoS.</p>
<p id="p-0011" num="0010">Since a single thread of the core processor performs all the set of network operations on the data packet, no state information or synchronization information is passed between processors, which results in faster and more efficient processing of data packets. Also, the number of memory reads and writes are minimized reducing the delay caused due to memory reads and writes. The discussed method, systems, structures and paradigms increase a number of effective operations per packet (EOPP), that is, the number of instructions that can be performed on the data packet to perform application related tasks.</p>
<p id="p-0012" num="0011">Some embodiments of the invention have other aspects, elements, features, and steps in addition to or in place of what is described above. These potential additions and replacements are described throughout the rest of the specification.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 1</figref> is an example network processor in which an embodiment of the invention may operate.</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 2</figref> is a flow diagram illustrating a process of processing data packets by a network processor.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 3</figref> is a flow diagram illustrating a process for performing a set of network operations on a data packet in a single thread of a core processor.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 4</figref> is a flow diagram illustrating a process of processing data packets per RSVP (RFC 2475) application/networking protocol in the network processor of <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 5</figref> is a flow diagram illustrating a process of processing input data packets.</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 6</figref> is a block diagram illustrating an example of a structure for representing data packets stored in a memory of a network processor of <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 7</figref> is a flow diagram illustrating a process of storing the data packet in a memory of the network processor of <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 8</figref> is a flow diagram of process for adding a data packet to an input queue of a network processor of <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 9</figref> is a block diagram of an output queue structure of a network processor of <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 10</figref> is a flow diagram illustrating a process of processing output data packets.</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 11</figref> is a block diagram illustrating an egress module of a network processor of <figref idref="DRAWINGS">FIG. 1</figref>.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0006" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0024" num="0023">References in this description to &#x201c;an embodiment&#x201d;, &#x201c;one embodiment&#x201d;, or the like, mean that the particular feature, function, or characteristic being described is included in at least one embodiment of the present invention. Occurrences of such phrases in this specification do not necessarily all refer to the same embodiment, nor are they necessarily mutually exclusive.</p>
<p id="p-0025" num="0024">Introduced here are methods, systems, paradigms and structures for parallel processing using multi-core processors. The disclosed solution can be used in various applications such as general purpose processing, network processing, storage systems, etc. In one embodiment, the above multi-core processor may be used as a network processor in a communication network for processing data packets. The network processor processes a data packet by performing a set of network operations on the data packet. The set of network operations can be based on applications/network protocols such as Resource Reservation Protocol (RSVP).</p>
<p id="p-0026" num="0025">A particular data packet is processed by a single core processor and by a single thread of the core processor. The core processor may request one or more special purpose processors to perform a subset of the set of network operations on the data packet. The one or more special purpose processors processes the data packet by performing the set of operations atomically. That is, the network processor ensures that the shared resources of the network processor used for processing the particular data packet is not used by other resources of the network processor while the particular data packet is being processed.</p>
<p id="p-0027" num="0026">An ingress module in the network processor allocates memory for the incoming data packets and stores the data packets in a memory of the network processor. The ingress module generates a packet buffer chain linking various buffers containing portions of the data packet, for a data packet whose size exceeds the buffer size. The ingress module adds the incoming data packets to an input queue from which one of the core processors retrieves a data packet for further processing. An output packet processor in the network processor adds the processed data packet to one of a plurality of output queues based on a quality of service (QoS) associated with the output queue and forwards the data packets contained in the output queues towards their destination addresses based on the QoS.</p>
<p id="p-0028" num="0027">Since a single thread of the core processor performs all the set of network operations on the data packet, no state information or synchronization information is passed between processors, which results in faster and more efficient processing of data packets. Also, the number of memory reads and writes are minimized reducing the delay caused due to memory reads and writes. The discussed method, systems, structures and paradigms increase a number of effective operations per packet (EOPP), that is, the number of instructions that can be performed on the data packet to perform application related tasks.</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 1</figref> is an example network processor <b>100</b> in which an embodiment of the invention may operate. Data packets from various source computer systems (not shown) are transmitted to destination computer systems (not shown) via a communication network (not shown). The communication network includes various systems such as routers (not shown) that facilitate forwarding the data packets towards their corresponding destination addresses. The routers perform operations including receiving the data packets, performing error checking on the received data packets, finding next hop addresses for the data packets, fragmenting the data packets etc. before the packets are forwarded to their corresponding next hop addresses. In an embodiment, the network processor <b>100</b> may be used in such routers to perform the above discussed operations.</p>
<p id="p-0030" num="0029">The network processor <b>100</b> includes a plurality of multi-threaded core processors such as core processor <b>105</b>, a plurality of special purpose processors such as special purpose processor <b>115</b>, a memory such as control memory <b>120</b> and data memory <b>125</b>, an ingress module <b>130</b> to receive and store incoming data packets in the memory, and an egress module <b>135</b> to forward the processed data packets towards their destination addresses. An internal command network <b>110</b> such as a crossbar switch enables communication between various components in the network processor <b>100</b>.</p>
<p id="p-0031" num="0030">Each of the core processors processes data packets. However, a data packet is processed by a single core processor, such as core processor <b>105</b>, and by a single thread of the core processor <b>105</b>. The core processor <b>105</b> processes the data packet by performing a set of network operations on the data packet. The core processor <b>105</b> may request one or more special purpose processors to perform a subset of the set of network operations on the data packet. The one or more special purpose processors processes the data packet by performing the subset of the set of network operations atomically. That is, the network processor <b>100</b> ensures that the shared resources of the network processor <b>100</b> used for processing the particular data packet is not used by other resources of the network processor <b>100</b> while the particular data packet is being processed by the core processor <b>105</b> or the special purpose processor <b>115</b>.</p>
<p id="p-0032" num="0031">The core processors and special purpose processors perform the set of network operations in parallel. The set of network operations performed on the data packet can be based on applications/network protocols such as Resource Reservation Protocol (RSVP). In an embodiment, the RSVP can be a protocol defined by Request For Comment (RFC) 2475. The set of network operations in RSVP (RFC 2475) can include receiving data packets, performing error handling, performing table look up operations, metering, generating statics, policing or congestion control, forwarding data packets towards their destination addresses etc.</p>
<p id="p-0033" num="0032">In an embodiment, the special purpose processors may perform frequently executed tasks such as table lookup for finding next hop address for the data packet, metering, policing, congestion control etc. The core processors may perform tasks such as error checking, overseeing the operations performed by the special purpose processors etc. In an embodiment, the network processor <b>100</b> may have one special purpose processor for each of the identified network operations. However, in another embodiment, the network processor <b>100</b> may have a special purpose processor execute more than one network operation. The network processor <b>100</b> ensures that certain operations on the data packets are performed atomically by using a semaphore associated with a thread requesting an operation on the data packet.</p>
<p id="p-0034" num="0033">A semaphore is used for signaling a target processor such as a core processor or a special purpose processor when a request has been accomplished and any data is safe to use. For example, a semaphore attached with a table update operation may be tested by the core processor <b>105</b> to determine if the results of the table lookup have been returned to the core processor <b>105</b>. The thread on the core processor <b>105</b> may continue doing other tasks after sending any request(s) to one or more special purpose processors, until the thread needs to use the results of the request(s). Before using the results of any request, the core processor <b>105</b> will test the semaphore that was attached to the specific request. If the request has been completed and the results have been returned to the core processor <b>105</b>, then the thread will continue processing. If the request has not been completed then the core processor <b>105</b> will put the thread in sleep mode when the semaphore is tested, and will switch to processing other threads. When the semaphore is returned, the core processor <b>105</b> will wake the thread and the thread will continue processing as if the semaphore had been available at the time of the test.</p>
<p id="p-0035" num="0034">The core processors obtain the data packets from an input queue of the special purpose processor such as input packet queue processor <b>115</b>. The core processor <b>105</b> may request the input packet queue processor <b>115</b> to return a data packet. The requests from the core processors are added to a request queue, and are served on a First-In-First-Out (FIFO) basis. The request queue may have requests from various threads of each of the core processors. For example, if there are four core processors in the network processor <b>100</b> and each of the four core processors can execute three threads, the request queue can have up to twelve (4&#xd7;3) requests in the request queue.</p>
<p id="p-0036" num="0035">The ingress module <b>130</b> performs memory management operations including (i) allocating memory to incoming data packets, and (ii) storing the incoming data packets in the memory. The ingress module <b>130</b> stores the data packets in a memory such as data memory <b>125</b>. Further, the ingress module <b>130</b> may store pointers to the data packets in control memory <b>120</b>. In an embodiment, access to the data packets is provided by control memory <b>120</b>. The data packets are stored in the buffers of data memory <b>125</b>. Each of the buffers is of a configurable size. If the size of the data packet exceeds the size of the buffer, the ingress module <b>130</b> splits the data packet and stores portions of the data packet in a plurality of buffers. The ingress module <b>130</b> generates a data packet buffer chain for the data packet. The data packet buffer chain is a pointer structure that links buffers containing various portions of the data packet. After the data packet buffer chain is created, the data packet is added to the input queue by adding a pointer to the data packet buffer chain. If the input queue already contains data packets, the data packet buffer chain of the last data packet in the input queue is linked to the data packet buffer chain of the newly added data packet.</p>
<p id="p-0037" num="0036">The input packet queue processor <b>115</b> returns a data packet from the head of the input queue to a thread that is first in the request queue. If there are no data packets in the input queue, the requesting thread is switched to sleep mode until a data packet is available to be returned to the thread. When a data packet is returned to a thread of the core processor <b>105</b>, the core processor <b>105</b> performs the set of network operations on the data packet in the single thread. The core processor <b>105</b> may request one or more special purpose processors to perform a subset of the network operations atomically. While the special purpose processors are performing the operations atomically, the thread of the core processor <b>105</b> which requested the special purpose processor may be switched to sleep mode until a result of execution by the special purpose processor is posted back to the thread. Putting this core processor into sleep mode at this point avoids semaphore wait cycles and enables the other processors to more efficiently concentrate on processing background tasks.</p>
<p id="p-0038" num="0037">After the data packet is processed, the core processor <b>105</b> requests a special purpose processor such as an output packet queue processor <b>140</b> to add the processed data packet to one of a plurality of output queues. The output packet queue processor <b>140</b> adds the data packet to a particular output queue based on the QoS contracted to the data packet. An egress module <b>135</b> retrieves the data packets from the output queues based on the QoS of the output queues and forwards the data packets towards their corresponding destination addresses. After the data packet is forwarded to the next hop address, the memory allocated to the data packet is released or freed by the output packet queue processor <b>140</b>.</p>
<p id="p-0039" num="0038">In an embodiment, the control memory <b>120</b> and data memory <b>125</b> may be on the same or different physical memory devices in the network processor <b>100</b>. The control memory <b>120</b> has a list of all the buffers in the data memory <b>125</b>. The list in the control memory <b>120</b> can be a one-to-one mapping to the buffers in the data memory <b>125</b>. In an embodiment, the one-to-one mapping can include pointers to buffers of the data memory <b>125</b>. The one-to-one mapping in control memory <b>120</b> has a pointer to any given address of a data buffer.</p>
<p id="p-0040" num="0039">The control memory <b>120</b> or data memory <b>125</b> represents any form of random access memory (RAM), flash memory, content addressable memory (CAM) such as ternary CAM, or the like, or a combination of such devices. In use, the control memory <b>120</b> may contain data structures such as packet buffer chain, output packet queue header structures and data structures having commands such as memory read or memory write that are executed often.</p>
<p id="p-0041" num="0040">The internal command network <b>110</b> can be a distributed crossbar switch or data network or semaphore network that facilitates communication between various components such as core processors, special purpose processors, control memory, data memory, etc. in the network processor <b>100</b>. The internal command network <b>110</b> takes input from the core processors and outputs it to a particular destination. For example, if a core processor wants to write data to the control memory <b>120</b>, the input can be the data and the destination can be control memory <b>120</b>. The internal command network <b>110</b> contains a plurality of switches, wherein each of the core processors is connected to a series of switches that would connect a particular core processor to a particular destination.</p>
<p id="p-0042" num="0041">The network processor <b>100</b> executes various operations such as network operations, memory management, etc. using special purpose hardware processors. Further, since all of the network operations on the data packet are performed in a single thread of a core processor, there is no overhead of passing state information or synchronization information between various stages of processing. Also, the memory management is performed by hardware modules such as ingress module <b>130</b>, input packet queue processor <b>115</b>, output packet queue processor <b>140</b>, etc. Accordingly, the performance offered by the network processor <b>100</b> is significantly increased. Further, the programming model to execute the set of network operations can be a single threaded programming model which is less complex than multi-threaded programming.</p>
<p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. 2</figref> is a flow diagram illustrating a process <b>200</b> of processing data packets by a network processor, according to an embodiment of the disclosed technique. The process <b>200</b> may be executed in a network processor such as network processor <b>100</b> of <figref idref="DRAWINGS">FIG. 1</figref>. At step <b>205</b>, the network processor <b>100</b> receives a plurality of data packets from one or more source computer systems in a computer network. At step <b>210</b>, the network processor <b>100</b> performs a set of network operations on each of the data packets. The set of network operations performed can be based on a particular application/networking protocol. Each of the data packets are processed in a single thread of a specific core processor of the network processor <b>100</b>. At step <b>215</b>, the network processor <b>100</b> forwards the processed data packets towards their corresponding destination addresses based on a QoS contracted to the data packets.</p>
<p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. 3</figref> is a flow diagram illustrating a process <b>300</b> for performing a set of network operations on a data packet in a single thread of a core processor, according to an embodiment of the disclosed technique. The process <b>300</b> may be executed in a network processor such as network processor <b>100</b> of <figref idref="DRAWINGS">FIG. 1</figref>. Certain network operations are performed by a core processor and certain by special purpose processors of the network processor <b>100</b>. In an embodiment, frequently executed operations may be performed by special purpose processors. For example, in a network processor <b>100</b> executing networking protocol such as RSVP (RFC 2475), network operations such as metering, policing, generating statistics etc. can be executed by special purpose processors.</p>
<p id="p-0045" num="0044">At step <b>305</b>, a core processor such as the core processor <b>105</b> requests the special purpose processors to execute a subset of the set of network operations atomically. The core processor <b>105</b> attaches a semaphore to a thread of the core processor <b>105</b> requesting the operation. At step <b>310</b>, the special purpose processor performs the subset of the set of network operations on the data packet atomically. At step <b>315</b>, the special purpose processor posts the results of the execution of the operations to a specified memory address.</p>
<p id="p-0046" num="0045">Referring back to step <b>310</b>, performing the set of operations atomically includes ensuring that while a shared resource of the network processor <b>100</b> is being updated by a particular resource, other resources are not allowed to access the shared resource. The semaphore attached to the thread of the core processor <b>105</b> switches the thread to a sleep mode until the special purpose processor has completed executing the operation on the data packet and posted the results of the execution to a specified memory address. After the special purpose processor has completed executing the operation, the semaphore wakes up the thread of the core processor and the rest of the network operations are continued. In an embodiment, if the thread of the core processor is not dependent on the results of execution of the operations by the special purpose processor, the thread may not be switched to sleep mode. The thread may continue processing the next set of operations on the data packet.</p>
<p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. 4</figref> is a flow diagram illustrating a process <b>400</b> of processing data packets using RSVP (RFC 2475) application/networking protocol, according to an embodiment of the disclosed technique. The process <b>400</b> may be executed in a network processor such as network processor <b>100</b> of <figref idref="DRAWINGS">FIG. 1</figref>. At step <b>402</b>, a thread of a core processor such as core processor <b>105</b> sends a request to an input packet queue processor <b>115</b> to obtain a data packet. The request also includes a semaphore associated with the thread. If the request queue of the input packet queue processor <b>115</b> already has requests from other threads of the core processor <b>105</b> or other core processors, the request from the specific thread of the core processor <b>105</b> is added to the request queue on a FIFO basis.</p>
<p id="p-0048" num="0047">At determination step <b>404</b>, the core processor <b>105</b> determines whether the semaphore has indicated that the input packet queue processor <b>115</b> returned the data packet to the thread. Responsive to a determination that the input packet queue processor <b>115</b> has not returned the data packet to the thread, at step <b>406</b>, the thread is switched to sleep mode until a data packet is returned to the thread. On the other hand, responsive to a determination that the input packet queue processor <b>115</b> has returned the data packet to the thread, the core processor <b>105</b> continues processing the data packet at step <b>408</b>. In an embodiment, when the data packet is returned to the core processor <b>105</b>, the input queue packet processor <b>115</b> returns a pointer to the data packet stored in the data memory <b>125</b> of the network processor <b>100</b>. Further, a portion of the data packet, such as a header of the data packet, is read from the data memory <b>125</b> and written into a local memory of the core processor <b>105</b>. The core processor <b>105</b> may refer to the portion stored in the local memory while processing the data packet.</p>
<p id="p-0049" num="0048">At determination step <b>408</b>, the core processor <b>105</b> determines whether there are any errors in the data packet. The errors detected include, for example, size of the data packet. If the size of the data packet is lesser than a predefined minimum data packet size, the core processor <b>105</b> determines that the data packet is an erroneous data packet. The core processor <b>105</b> may also check for other errors by computing a checksum for the data packet. Initially, when the packet arrives, the ingress module <b>130</b> computes the checksum to validate whether the data packet was received correctly. The checksum may be modified corresponding to any modifications to the data packet by the core processor <b>105</b>. Responsive to a determination that the data packet is an erroneous data packet, at step <b>410</b>, the core processor <b>105</b> sends a request to the output packet queue processor <b>140</b> to drop the data packet. On the other hand, responsive to the determination that the data packet is not an erroneous data packet, the core processor <b>105</b> continues processing the data packet at step <b>412</b>.</p>
<p id="p-0050" num="0049">At step <b>412</b>, the core processor <b>105</b> sends a request to a special purpose processor to perform a table lookup operation to determine the next hop address for the data packet. The request also includes a semaphore associated with the thread. At step <b>414</b>, the special purpose processor performs the table lookup operations to determine the next hop address for the data packet and posts the results to a specified memory address. The network processor <b>100</b> supports both IPv4 and IPv6, that is, IP versions 4 and 6. Also, the special purpose processor may also determine a queue identification (ID) of an output queue, to which the data packet may be added, based on a QoS contracted to the data packet. In an embodiment, the table lookup operations can also include reverse path validation and microflow parameters. Microflow is a single instance of an application-to-application flow of packets which is identified by source address, source port, destination address, destination port and protocol id. The next hop address can include an Internet Protocol (IP) address.</p>
<p id="p-0051" num="0050">At determination step <b>416</b>, the core processor <b>105</b> determines whether the semaphore has indicated that table lookup operations have executed and results have been posted to a specific location in the memory. Responsive to a determination that the results have not been posted yet, at step <b>418</b>, the thread of the core processor <b>105</b> is switched to a sleep mode until the results are posted. On the other hand, responsive to a determination that the table lookup results have been posted, the core processor <b>105</b> continues processing the data packet at step <b>420</b>.</p>
<p id="p-0052" num="0051">At step <b>420</b>, the core processor <b>105</b> sends a request to a special purpose processor for performing metering operations. The request also includes a semaphore associated with the thread of the core processor <b>105</b>. In an embodiment, metering operations, per RFC 2475, can include measuring the temporal properties (e.g., rate) of a traffic stream selected by a classifier (which identifies particular data packets). The instantaneous state of this process may be to affect the operation of a marker, shaper, or dropper, and/or may be used for accounting, measurement or congestion control purposes.</p>
<p id="p-0053" num="0052">At step <b>422</b>, the special purpose processor performs the metering operations for the data packet. At determination step <b>424</b>, the core processor <b>105</b> determines whether the semaphore indicates that the metering operations have executed and results have been posted. Responsive to a determination that the metering results have not been posted, at step <b>426</b>, the thread of the core processor <b>105</b> is switched to sleep mode until the results are posted. On the other hand, responsive to a determination that the metering operations have completed executing and the results are posted, the core processor <b>105</b> continues processing the data packet at step <b>428</b>.</p>
<p id="p-0054" num="0053">At step <b>428</b>, the core processor <b>105</b> sends a request to a special purpose processor to perform congestion control or policing operations on the data packet. In an embodiment, the congestion control, per RFC 2475, is a process of discarding packets within a traffic stream in accordance with the state of a corresponding meter enforcing a traffic profile. The data packets may be dropped based on the data obtained from the metering operations. The request from the core processor <b>105</b> also includes a semaphore associated with the thread of the core processor <b>105</b> requesting the special purpose processor.</p>
<p id="p-0055" num="0054">At step <b>430</b>, the congestion control operations are performed by the special purpose processor. At determination step <b>432</b>, the core processor <b>105</b> determines whether the semaphore has indicated that the congestion control process has executed and posted the results. Responsive to a determination that the results of the congestion control operations are not yet available, at step <b>434</b>, the thread of the core processor <b>105</b> is switched to sleep mode until the results are posted. On the other hand responsive to a determination that the congestion control results have been posted, the core processor <b>105</b> continues processing the data packet at step <b>436</b>.</p>
<p id="p-0056" num="0055">At determination step <b>436</b>, the core processor <b>105</b> determines if a portion of the data packet, such as the header of the data packet stored in the local memory of the core processor <b>105</b>, has been modified by any of the set of network operations. In an embodiment, certain operations such as fragmenting the data packet, updating the checksum, time to live (TTL) for the data packet etc. modify certain portions of the data packet. Responsive to a determination that the data packet is not modified, the control is transferred to step <b>446</b>. On the other hand, responsive to a determination that the portion of the data packet is modified, at step <b>438</b>, the core processor <b>105</b> sends a request to a special purpose processor to write the modified portion of the data packet from the local memory of the core processor <b>105</b> to the data memory <b>125</b>. The core processor <b>105</b> also includes a semaphore with the request.</p>
<p id="p-0057" num="0056">At step <b>440</b>, the special purpose processor executes the memory write operation to write the modified portions of the data packet to the data memory <b>125</b>. At determination step <b>442</b>, the core processor <b>105</b> determines whether the semaphore has indicated that the memory write operation has executed and the modified portion of the data packet has been written to the data memory <b>125</b>. Responsive to a determination that the memory write operation has not yet completed writing the modified portion of the data packet, the thread of the core processor <b>105</b> is switched to sleep mode until the modified portion is written to the data memory <b>125</b>. On the other hand, responsive to a determination that the modified portion has been written to the data memory <b>125</b>, the core processor <b>105</b> continues processing the data packet at step <b>446</b>.</p>
<p id="p-0058" num="0057">At step <b>446</b>, the core processor <b>105</b> sends a request to the output packet queue processor <b>140</b> to add the data packet to an output queue. The core processor <b>105</b> also includes a semaphore with the request. At step <b>448</b>, the output packet queue processor <b>140</b> executes queuing operations to add the data packet to an appropriate output queue. In an embodiment, the output packet queue processor <b>140</b> identifies the output queue based on the queue ID of the data packet determined during the table lookup operations.</p>
<p id="p-0059" num="0058">At determination step <b>450</b>, the core processor <b>105</b> determines whether the semaphore indicates that the data packet has been added to the output queue. Responsive to a determination that the data packet is not yet added to the output queue, at step <b>452</b>, the thread of the core processor <b>105</b> is switched to sleep mode until the data packet is added to the output queue. On the other hand, responsive to a determination that the data packet is added to the output queue, the core processor <b>105</b> determines that the thread has completed processing the data packet. At step <b>454</b>, the thread of the core processor <b>105</b> can start processing a next data packet by sending a request to the input packet queue processor <b>115</b>.</p>
<p id="p-0060" num="0059">Further, the egress module <b>135</b> obtains data packets from the output queues based on the QoS associated with the output queues and forwards the data packets towards their corresponding destination addresses.</p>
<p id="p-0061" num="0060">Each of the core processors of the network processor <b>100</b> and each of the threads of a particular processor can perform the above discussed operations on different data packets in parallel.</p>
<p id="p-0062" num="0061">Referring back to the operations discussed in <figref idref="DRAWINGS">FIG. 4</figref>, the network processor <b>100</b> executes certain commands for every data packet that is processed by the network processor <b>100</b>. Further, these commands are similar for every thread of the core processor. The network processor <b>100</b> creates data structures to store the commands, and initializes the data structures even before a first thread of a first processor requests a data packet from the input queue processor. In an embodiment, the commands include (a) memory reads&#x2014;reading data (data packet header and data packet descriptor) from data memory <b>125</b> to a local memory of a core processor, (b) memory writes&#x2014;writing modified data (data packet header and data packet descriptor) from local memory of core processor to the data memory, (c) adding the data packet to an output queue (d) updating error counters for the data packets, (e) table look up commands, (d) metering commands, (f) congestion control commands etc. Initializing or pre-allocating memory to the data structures for the above commands even before the network processor <b>100</b> starts processing the first data packet and using the data structures for every thread of every core processor reduces the time consumed for performing these common administration operations for every data packet. The network processor <b>100</b> can utilize its processing power on performing the network protocol related tasks and thus, increasing the number of EOPP. All of the strands in the network processor may not be running &#x2018;similar&#x2019; code.</p>
<p id="p-0063" num="0062">Although it is possible for all threads to be running similar code, for example, code for processing incoming data packets, in an embodiment, not every thread of a core processor <b>105</b> may be processing the data packets. It is possible to program such that only a subset of the threads are processing incoming packets. Other threads could be programmed to execute tasks, for example, background tasks, that would only run when the higher priority threads (processing incoming data packets) are in sleep mode.</p>
<p id="p-0064" num="0063">The architecture of the network processor <b>100</b> allows the processes such as (a) input data packet operations&#x2014;receiving the input data packets and adding them to the input queue, (b) processing the data packets by the core processors, and (c) output data packet operations&#x2014;forwarding the data packets from the output queues to their corresponding destination addresses, to execute independently. That is, for example, the architecture separates a requirement for when a data packet is received by a network processor <b>100</b> and when the data packet is processed. The data packet is added to the input queue when it arrives at the network processor <b>100</b>, and the core processor may retrieve the data packet from the input queue at a later time, for example, when the core processor is ready, to process the data packet. Such an architecture allows the network processor <b>100</b> to spend as much time as it is necessary or required for processing a data packet, for example, for performing deep packet inspection, before moving on to the next one.</p>
<p id="p-0065" num="0064"><figref idref="DRAWINGS">FIG. 5</figref> is a flow diagram illustrating a process <b>500</b> of processing input data packets, according to an embodiment of the disclosed technique. The process <b>500</b> may be executed in a network processor such as network processor <b>100</b> of <figref idref="DRAWINGS">FIG. 1</figref>. At step <b>505</b>, the ingress module <b>130</b> receives a data packet. The data packet may be received from various computers in a computer network the network processor <b>100</b> is part of. At step <b>510</b>, the ingress module <b>130</b> (or a memory allocation module working in cooperation with the ingress module <b>130</b>) allocates memory to the received data packet from, for example, data memory <b>125</b> of the network processor <b>100</b>. At step <b>515</b>, the data packet is stored in the data memory. At step <b>520</b>, the ingress module <b>130</b> instructs the input packet queue processor <b>115</b> to add the data packet to the input queue.</p>
<p id="p-0066" num="0065">Referring back to step <b>515</b>, the data packet is stored one or more of the buffers of the data memory <b>125</b>. The data memory <b>125</b> contains a plurality of configurable size buffers. If the size of a received data packet is larger than the buffer size, the data packet is split into a number of portions and each of the portions is stored in a buffer. The ingress module <b>130</b> (or a packet buffer chain generation unit working in cooperation with the ingress module <b>130</b>) links each of the buffers having portions of the data packet to form a packet buffer chain for the data packet.</p>
<p id="p-0067" num="0066">Referring back to step <b>520</b>, the network processor <b>100</b> ensures that the data packet is accessible by the core processor <b>105</b> only after all portions of the data packet are written into the data memory <b>125</b>. The ingress module <b>130</b> attaches a semaphore to memory write operations that write the data packet to the memory. The input packet queue processor <b>115</b> is does not send a data packet to the requesting core processor until all portions of the data packet are written to the data memory. When all the portions of the data packet are written, the semaphore wakes up the input packet queue processor <b>115</b> indicating that complete data packet is written into the memory. The input packet queue processor <b>115</b> may then send the data packet to requesting core processor. The core processor then pauses the background tasks and resumes its high-priority function.</p>
<p id="p-0068" num="0067"><figref idref="DRAWINGS">FIG. 6</figref> is a block diagram illustrating an example <b>600</b> of a structure for representing data packets stored in a memory of a network processor, according to an embodiment of the disclosed technique. The example <b>600</b> may be implemented in a network processor such as network processor <b>100</b> of <figref idref="DRAWINGS">FIG. 1</figref>. The data packets received by the ingress module <b>130</b> are stored in the data memory <b>125</b>. In an embodiment, the control memory <b>120</b> may have packet buffer structures that contain pointers to the data packets stored in the data memory <b>125</b>. For example, for a data packet &#x201c;Packet 0&#x201d; stored in the data memory <b>125</b>, the control memory <b>120</b> may store a packet buffer chain <b>605</b> containing packet buffer structures <b>605</b>, <b>610</b>, and <b>615</b> that have pointers to the buffers containing data packet &#x201c;Packet 0.&#x201d; The network processor <b>100</b> provides access to the data packets stored in the data memory <b>125</b> through the control memory <b>120</b> using the above packet buffer structures.</p>
<p id="p-0069" num="0068">If a size of the data packet is lesser than the size of the buffer of the data memory, the data packet is stored in a single buffer. If the data packet is stored in a single buffer, the packet buffer chain for the data packet may have only packet buffer structure. For example, the packet buffer chain <b>625</b> for data packet &#x201c;Packet 1&#x201d; has only one packet buffer structure. On the other hand, when a size of the data packet is larger than the size of the buffer, the data packet is split into a number of portions and the portions are stored in a number of buffers. Each of the buffers containing portions of the data packet is linked to form a packet buffer chain such as packet buffer chain <b>605</b>. A packet buffer structure can include two pointers, a next data packet pointer for pointing to a next data packet in the input queue, and a next buffer pointer for pointing to the next buffer of the same data packet. In some packet buffer structures one or none of the pointers may be used.</p>
<p id="p-0070" num="0069">In the example <b>600</b>, for data packet &#x201c;Packet 0,&#x201d; the first packet buffer structure <b>610</b> (also referred to as header packet buffer structure <b>610</b>) of the packet buffer chain <b>605</b> includes a pointer &#x201c;Pkt 1,0&#x201d; that points to the next data packet &#x201c;Packet 1&#x201d; in the input queue, and the next buffer pointer &#x201c;Pkt 0, 1&#x201d; that points to the next buffer containing the next portion of the data packet &#x201c;Packet 0.&#x201d; In the packet buffer structure <b>615</b>, however, only next buffer pointer &#x201c;Pkt 0,2&#x201d; is used. The next packet pointer is not used. The next packet pointer can have a null value. In the last packet buffer structure <b>620</b> (also referred to as tail packet buffer structure <b>620</b>) of the packet buffer chain <b>605</b>, none of the pointers are used. The next packet pointer can have a null value. The next buffer pointer can have a value, for example, end of packet (EOP), that indicates that the current buffer is the last buffer in the packet buffer chain <b>605</b> for the data packet &#x201c;Packet 0.&#x201d;</p>
<p id="p-0071" num="0070">The packet buffer structures and packet buffer chains are created when the data packets are stored in the data memory <b>125</b>. When the data packet is added to the input queue, a pointer to the header buffer structure of the packet buffer chain of the data packet is added to the input queue. If the input queue already contains data packets, the next packet pointer in the header buffer structure of the last data packet is updated to point to the header buffer structure of the data packet added to the input queue. For example, when the data packet &#x201c;Packet 1&#x201d; is added to the input queue, the next data packet pointer of the header packet buffer structure <b>610</b> is updated to point to the header buffer structure of the data packet &#x201c;Packet 1.&#x201d;</p>
<p id="p-0072" num="0071">When the core processor requests a data packet from the input packet queue processor <b>115</b>, the input packet queue processor <b>115</b> obtains the data packet (pointer to the packet buffer structure of the data packet) from the head of the input queue and returns it to the core processor. In an embodiment, similar packet buffer structures may be used for queuing the data packets in the output queues of the network processor <b>100</b>.</p>
<p id="p-0073" num="0072"><figref idref="DRAWINGS">FIG. 7</figref> is a flow diagram illustrating a process <b>700</b> of storing the data packet in a memory of the network processor, according to an embodiment of the disclosed technique. The process <b>700</b> may be executed by a network processor such as network processor <b>100</b> of <figref idref="DRAWINGS">FIG. 1</figref>. At determination step <b>705</b>, the ingress module <b>130</b> determines whether a size of the data packet is larger than the buffer size of the data memory <b>125</b> of the network processor <b>100</b>. Responsive to a determination that the data packet size is not larger than the buffer size, at step <b>710</b>, the ingress module <b>130</b> stores the data packet in a single buffer and creates a packet buffer structure with a value indicating that the packet buffer structure is the last buffer structure in the packet buffer chain for the data packet.</p>
<p id="p-0074" num="0073">On the other hand, responsive to a determination that the data packet size is larger than the buffer size, at step <b>715</b>, the ingress module <b>130</b> stores the data packet in a number of buffers, each of the buffers having a distinct portion of the data packet. At step <b>720</b>, the ingress module <b>130</b> (or a packet buffer generation unit that works in cooperation with the ingress module <b>130</b>) generates a packet buffer structure for each of the buffers storing a portion of the data packet. At step <b>725</b>, the ingress module <b>130</b> links each of the packet buffer structures, starting from a header packet buffer structure corresponding to a first buffer containing a first portion the data packet to the tail buffer structure corresponding to a last buffer containing the last portion of the data packet, to create a packet buffer chain for the data packet.</p>
<p id="p-0075" num="0074"><figref idref="DRAWINGS">FIG. 8</figref> is a flow diagram of process <b>800</b> for adding a data packet to an input queue of a network processor, according to an embodiment of the disclosed technique. The process <b>800</b> may be executed by a network processor such as a network processor <b>100</b> of <figref idref="DRAWINGS">FIG. 1</figref>. Adding the data packet to the input queue includes adding a pointer that points to the header buffer structure of a packet buffer chain of a data packet to the input queue. After writing the data packet to the memory, the ingress module <b>130</b> sends an instruction to the input packet queue processor <b>115</b> to add the data packet to the input queue. At determination step <b>805</b>, the input packet queue processor <b>115</b> determines whether the input queue is empty. Responsive to a determination that the input queue is empty, at step <b>810</b>, the input packet queue processor <b>115</b> adds a pointer to the header packet buffer structure of the packet buffer chain of the data packet to the input queue, and the process <b>800</b> returns.</p>
<p id="p-0076" num="0075">Responsive to a determination that the input queue is not empty, at step <b>815</b>, the input packet queue processor <b>115</b> obtains a header buffer structure of the packet buffer chain of the last data packet in the input queue. At step <b>820</b>, the input packet queue processor <b>115</b> updates the next packet pointer of the header packet buffer structure of the last data packet in the input queue to point to the header packet buffer structure of the packet buffer chain of the data packet added to the input queue.</p>
<p id="p-0077" num="0076"><figref idref="DRAWINGS">FIG. 9</figref> is a block diagram of an output queue structure <b>900</b> of a network processor, according to an embodiment of the disclosed technique. The output queue structure <b>900</b> may be implemented in a network processor such as network processor <b>100</b> of <figref idref="DRAWINGS">FIG. 1</figref>. The network processor <b>100</b> forwards the data packets to their corresponding next hop addresses based on the QoS contracted to the data packets. For example, video streaming data may be guaranteed a pre-defined bandwidth and/or speed, a class of senders may be guaranteed a pre-defined bandwidth and/or speed, email data may have lower priority than video data, etc. Accordingly, the video data may be forwarded before email data. The QoS contracted to the data may be based on a number of policies. The output queue structure <b>900</b> provides a number of output queue classes and output queues for queuing output data packets based on the QoS contracted to the data packets. The egress module <b>135</b> fetches the data packets from the appropriate output queue classes and/or output queues based on the QoS contracted to the data packet and forwards them to their next hop addresses.</p>
<p id="p-0078" num="0077">The output queue structure <b>900</b> is a hierarchical structure of ports of an output link of the network processor <b>100</b>, output queue classes and output queues. Every output queue class and an output queue can be associated with a specific QoS. A port <b>905</b> has a set of output queue classes such as output queue class <b>910</b> and the output queue class <b>910</b> has a set of output queues such as output queue <b>915</b>. For example, an output queue class can have an output queue for each sender that is part of that output queue class. In an embodiment, an output queue such as output queue <b>920</b> can be directly linked to the port <b>905</b> of the output link instead of an output queue class.</p>
<p id="p-0079" num="0078">Each of the output queue classes and/or output queues is allocated a certain amount of resource. For example, if for a given time period an output queue class is allocated five percent (5%) of the bandwidth and the output queue class has five output queues in it, each of the output queues can be allocated one percent (1%) of the bandwidth, or four of the queues can be allocated one half percent (0.5%) of the bandwidth and one of the output queues may be allocated three percent (3%) of the bandwidth. The output queues and the output queue classes can be set up in number of ways based on the QoS contracts agreed with the senders. When the data packets are processed by the network processor, the amount of bandwidth consumed by each of the data packets is tracked, for example, by metering operations of <figref idref="DRAWINGS">FIG. 4</figref>. If an amount of the resource consumed by a particular output queue class or an output queue exceeds the pre-defined limit, a number of pre-defined actions may be performed on the data packets belonging to those output queue classes or output queues including dropping the data packets.</p>
<p id="p-0080" num="0079">The data packet <b>925</b> is added to the output queue <b>915</b> based on a queue ID of the data packet <b>925</b>, which is obtained, for example, during the table look up operations of <figref idref="DRAWINGS">FIG. 4</figref>. The queue ID identifies the output queue class or the port to which the output queue of the data packet <b>925</b> belongs. Accordingly, the output packet queue processor <b>140</b> adds the data packet <b>925</b> to the appropriate queue <b>915</b>.</p>
<p id="p-0081" num="0080"><figref idref="DRAWINGS">FIG. 10</figref> is a flow diagram illustrating a process <b>1000</b> of processing output data packets, according to an embodiment of the disclosed technique. The process <b>1000</b> may be executed in a network processor such as network processor <b>100</b> of <figref idref="DRAWINGS">FIG. 1</figref>. At step <b>1005</b>, the output packet queue processor <b>140</b> receives a request from the core processor <b>105</b> to add the data packet to an output queue. At step <b>1010</b>, the output packet queue processor <b>140</b> obtains the queue ID of the data packet. The queue ID identifies the output queue class or the port to which the output queue of the data packet belongs. At step <b>1015</b>, the output packet queue processor <b>140</b> adds the data packet to the identified output queue of the output queue structure. At step <b>1020</b>, the egress module <b>135</b> obtains the data packets from the output queues based on the QoS associated with the output queues and/or output queue classes. At step <b>1025</b>, the egress module <b>135</b> forwards the data packets to their corresponding next-hop addresses.</p>
<p id="p-0082" num="0081">Referring back to step <b>1005</b>, the output queue requests from various core processors or various threads of a specific core processor are stored in a request queue of the output packet queue processor <b>140</b> on a FIFO basis.</p>
<p id="p-0083" num="0082">Referring back to step <b>1015</b>, in an embodiment, the output queue structure <b>900</b> includes only output queue classes and/or output queues that contain data packets. The output queue structure <b>900</b> is not a complete list of all output queue classes or output queues that can be defined for the network processor <b>100</b>. When a data packet is added to an output queue, if the output queue is empty, the output queue is added to an output queue class to which it belongs. If the output queue class is itself empty, that is, does not already exist in the output queue structure <b>900</b>, the output queue class is created in the output queue structure <b>900</b> and the output queue is added to the output queue class. The data packet is then added to the output queue.</p>
<p id="p-0084" num="0083">Referring back to step <b>1020</b>, the process (steps <b>1005</b>-<b>1015</b>) of adding the data packets to the output queue structure <b>900</b> is independent of the process (steps <b>1020</b>-<b>1025</b>) of forwarding the data packets towards their next hop destination. The egress module <b>135</b> may obtain the data packets from the output queue structure <b>900</b> independent of when the data packets are added to the output queue structure <b>900</b>. That is, the data packets added to the output queue structure <b>900</b> may not be immediately forwarded to their next-hop addresses. The egress module <b>135</b> fetches the data packets from the output queues or output queue classes based on the QoS associated with the output queues or output queue classes. For example, if video data is guaranteed higher bandwidth than email data, the output queues or output queue classes containing video data packets may be served first and the output queues or output queue classes containing email data packets may be served later.</p>
<p id="p-0085" num="0084"><figref idref="DRAWINGS">FIG. 11</figref> is a block diagram of a system <b>1100</b> illustrating an egress module <b>1135</b> of a network processor, according to an embodiment of the disclosed technique. The egress module <b>1135</b> can be similar to the egress module <b>135</b> of network processor <b>100</b> of <figref idref="DRAWINGS">FIG. 1</figref>. The core processors request the output packet queue processor <b>140</b> to add the processed data packets to the output queue structure. The queue requests can include information regarding an output queue class and/or output queue to which the data packet belongs, and a pointer to header packet buffer structure of the data packet. The output packet queue processor <b>140</b> receives the queue requests via internal command network <b>1105</b>, and stores them in an output packet request queue <b>1110</b> on a FIFO basis.</p>
<p id="p-0086" num="0085">A packet queue finite state machine module <b>1115</b> retrieves the queue requests from the output packet request queue <b>1110</b> on FIFO basis. After retrieving a queue request, the packet queue finite state machine module <b>1115</b> requests the control memory <b>1125</b> to read the output queue header structure/output queue class header structure of the output queue/output queue class into a queue cache <b>1120</b> for a given queue ID associated with the data packet. Once the header structure is loaded, the packet queue finite state machine module <b>1115</b> identifies the corresponding output queue and/or output queue class of the data packet, and adds the data packet to the output queue.</p>
<p id="p-0087" num="0086">In an embodiment, the network processor <b>100</b> can support up to a million output queues or output queue classes. An output queue class or output queue header structure identifies a particular output queue or queue class to which a data packet belongs, a weight of the output queue or queue class, address to the next output queue or output queue class, a bit that indicates whether the output queue belongs to a output queue class or a port, etc. The header structures can be stored in control memory <b>1125</b> (similar to control memory <b>120</b> of <figref idref="DRAWINGS">FIG. 1</figref>) or in other memory such as data memory <b>125</b> from which the control memory <b>120</b> can fetch.</p>
<p id="p-0088" num="0087">An egress scheduler <b>1130</b> retrieves the data packets from the output queues or output queue classes based on the QoS associated with them, and the egress module <b>1135</b> forwards the data packets to their corresponding next-hop addresses via the output link of the network processor <b>100</b>. The output link of the network processor can be based on network processor streaming interface (NPSI). For example, the egress scheduler <b>1130</b> looks at the output queue classes and/or the output queues using information about how much bandwidth has been allocated to each of the output queues or output queue classes to do a fair round robin, or easily weighted round robin, to give priority to the output queue classes or output queues that have more bandwidth. But over a period of time, every output queue or output queue class would get processed if they have a certain amount of bandwidth allocated.</p>
<p id="p-0089" num="0088">In cases where other queues have higher priority (QoS) such as voice or video, queues which are on a best-effort basis, such as email, would only be processed when the higher-priority queue quotas have been satisfied.</p>
<p id="p-0090" num="0089">The techniques introduced herein can be implemented by, for example, programmable circuitry (e.g., one or more microprocessors) programmed with software and/or firmware, or entirely in special-purpose hardwired (non-programmable) circuitry, or in a combination of such forms. Special-purpose hardwired circuitry may be in the form of, for example, one or more ASICs, PLDs, FPGAs, etc.</p>
<p id="p-0091" num="0090">Software or firmware for use in implementing the techniques introduced here may be stored on a machine-readable storage medium and may be executed by one or more general-purpose or special-purpose programmable microprocessors. A &#x201c;machine-readable storage medium&#x201d;, as the term is used herein, includes any mechanism that can store information in a form accessible by a machine.</p>
<p id="p-0092" num="0091">A machine can also be a server computer, a client computer, a personal computer (PC), a tablet PC, a laptop computer, a set-top box (STB), a personal digital assistant (PDA), a cellular telephone, an iPhone, a Blackberry, a processor, a telephone, a web appliance, a network router, switch or bridge, or any machine capable of executing a set of instructions (sequential or otherwise) that specify actions to be taken by that machine.</p>
<p id="p-0093" num="0092">A machine-accessible storage medium or a storage device(s) or a memory includes, for example, recordable/non-recordable media (e.g., ROM; RAM; magnetic disk storage media; optical storage media; flash memory devices; etc.), etc., or any combination thereof. The storage medium typically may be non-transitory or include a non-transitory device. In this context, a non-transitory storage medium may include a device that is tangible, meaning that the device has a concrete physical form, although the device may change its physical state. Thus, for example, non-transitory refers to a device remaining tangible despite this change in state.</p>
<p id="p-0094" num="0093">The term &#x201c;logic&#x201d;, as used herein, can include, for example, programmable circuitry programmed with specific software and/or firmware, special-purpose hardwired circuitry, or a combination thereof.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method comprising:
<claim-text>receiving, at a network processor having a plurality of core processors and a plurality of special purpose processors, a plurality of data packets; and</claim-text>
<claim-text>performing, by a core processor of the core processors, a set of network operations on a data packet of the data packets, the performing a set of network operations including
<claim-text>requesting, by the core processor, a special purpose processor of the special purpose processors to perform a subset of the set of network operations on the data packet atomically,</claim-text>
<claim-text>performing, by the special purpose processor, the subset of the network operations on the data packet atomically, and</claim-text>
</claim-text>
<claim-text>performing the set of network operations on the data packet in a single thread of the core processor, the set of network operations performed being dependent on a networking protocol.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising:
<claim-text>forwarding, by the network processor and based on a quality of service (QoS) associated with each of the data packets, the data packets towards their corresponding destination addresses.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the networking protocol includes Resource Reservation Protocol (RSVP).</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the set of network operations performed in the RSVP includes at least one of (i) error checking, (ii) metering, (iii) policing, (iv) generating statistics, or (v) table look-ups for obtaining addresses to forward the data packets towards their destination addresses.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the subset of network operations performed by the special purpose processors include at least one of (i) metering, (ii) policing, (iii) generating statistics, or (iv) table look-ups for obtaining addresses to forward the data packets towards their destination addresses.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein requesting the special purpose processor to perform the subset of the set of network operations atomically includes
<claim-text>sending, by the core processor and with the request, a semaphore to the special purpose processor, the semaphore associated with a thread of the core processor that is requesting the special purpose processor to perform the subset of the set of network operations.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the semaphore allows shared resources of the network processor to be accessed by the thread executing the set of network operations on the data packet atomically.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the thread of the core processor switches to a sleep mode when the semaphore indicates that the shared resources are being accessed by the special purpose processor.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the thread of the core processor switches to an active mode when the semaphore indicates that the special purpose processor has posted results of the request to the core processor.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the set of network operations on the data packet are performed by only (i) one of the core processors, and (ii) one of a plurality of threads of the one of the core processors.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the receiving the data packets includes
<claim-text>allocating, by an ingress module of the network-processor, memory to each of the data packets, and</claim-text>
<claim-text>storing the data packets in the memory.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the core processor and the special purpose processor perform the set of network operations on the data packet by reading from or writing to the data packet stored in the memory allocated to the data packet.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref> further comprising:
<claim-text>adding the received data packets to an input queue of the network processor.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the memory includes a plurality of buffers, and wherein each of the buffers is of a configurable size.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein storing the data packets in the memory includes
<claim-text>determining whether a size of the data packet exceeds the configurable size of a buffer of the buffers,</claim-text>
<claim-text>responsive to a determination that the size of the data packet exceeds the configurable size of the buffer, storing the data packet into one or more buffers of the memory, each of the one or more buffers containing a portion of the data packet, and</claim-text>
<claim-text>linking each of the one or more buffers to generate a packet buffer chain for the data packet.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The method of <claim-ref idref="CLM-00015">claim 15</claim-ref> further comprising:
<claim-text>adding the data packet to an input queue, the adding including adding a pointer to the packet buffer chain of the data packet.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The method of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the data packet is sent to a requesting core processor after all portions of the data packet are stored in the one or more buffers allocated to the data packet.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The method of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the packet buffer chain is a plurality of packet buffer structures linking the one or more buffers of the data packet starting from a header buffer structure to a tail buffer structure, wherein the header packet buffer structure corresponds to a first buffer of the one or more buffers containing a first portion of the data packet, and wherein the tail packet buffer structure corresponds to a last buffer of the one or more buffers containing a last portion of the data packet.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The method of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein
<claim-text>the header packet buffer structure includes
<claim-text>(i) a next packet pointer that points to a packet buffer chain of a next data packet of the data packets added to the input queue, and</claim-text>
<claim-text>(ii) a next buffer pointer that points to a next buffer of the one or more buffers containing a next portion of the same data packet, and</claim-text>
</claim-text>
<claim-text>the tail packet buffer structure includes
<claim-text>a marker indicating that the tail packet buffer structure is an end of the data packet.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The method of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein adding the data packets to the input queue includes linking a current packet buffer chain of a current data packet in the input queue with a new packet buffer chain of a new data packet of the data packets added to the input queue.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein performing the set of network operations on the data packets by the core processors includes
<claim-text>requesting, by a plurality of threads of each of the core processors, the data packets from the input queue.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. The method of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the threads of the core processors requesting the data packets are added to a data packet request queue.</claim-text>
</claim>
<claim id="CLM-00023" num="00023">
<claim-text>23. The method of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the threads in the data packet request queue are served on a First-In-First-Out (FIFO) basis.</claim-text>
</claim>
<claim id="CLM-00024" num="00024">
<claim-text>24. The method of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the threads in the data packet request queue are switched to sleep mode until the data packets are available in the input queue.</claim-text>
</claim>
<claim id="CLM-00025" num="00025">
<claim-text>25. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein forwarding the data packets based on a quality of service (QoS) associated with each of the data packets includes
<claim-text>receiving, at an output packet processor of the network processor and from the core processors, a command to add the data packets to an output queue structure, and</claim-text>
<claim-text>adding the data packets to the output queue structure.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00026" num="00026">
<claim-text>26. The method of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein the output queue structure is a hierarchical structure having a plurality of output queues, each of the queues belonging to (i) one of a plurality of queue classes, or (ii) one of a plurality of ports, the ports corresponding to an output link of the network processor, and each of the queue classes belonging to one of the ports.</claim-text>
</claim>
<claim id="CLM-00027" num="00027">
<claim-text>27. The method of <claim-ref idref="CLM-00026">claim 26</claim-ref>, wherein each of the queue classes or queues corresponds to a pre-defined QoS.</claim-text>
</claim>
<claim id="CLM-00028" num="00028">
<claim-text>28. The method of <claim-ref idref="CLM-00026">claim 26</claim-ref>, wherein adding the data packets to the output queue structure includes
<claim-text>obtaining, from a particular data packet of the data packets, a queue identification (ID) of the particular data packet,</claim-text>
<claim-text>identifying, based on the queue ID, a particular output queue to which the particular data packet belongs, and</claim-text>
<claim-text>adding the particular data packet to the particular queue.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00029" num="00029">
<claim-text>29. The method of <claim-ref idref="CLM-00028">claim 28</claim-ref> further comprising:
<claim-text>retrieving, by an egress module of the network processor and based on the QoS of the queues or the queue classes, the data packets from the output queues; and</claim-text>
<claim-text>forwarding the data packets towards their corresponding destination addresses.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
