<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627053-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627053</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12977468</doc-number>
<date>20101223</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<disclaimer>
<text>This patent is subject to a terminal disclaimer.</text>
</disclaimer>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>24</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>40</subgroup>
<symbol-position>L</symbol-position>
<classification-value>N</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>713  2</main-classification>
<further-classification>713100</further-classification>
<further-classification>713191</further-classification>
</classification-national>
<invention-title id="d2e51">Method and apparatus for secure execution using a secure memory partition</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5379342</doc-number>
<kind>A</kind>
<name>Arnold et al.</name>
<date>19950100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>380  2</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5592616</doc-number>
<kind>A</kind>
<name>Finch et al.</name>
<date>19970100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714 42</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>5883956</doc-number>
<kind>A</kind>
<name>Le et al.</name>
<date>19990300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713170</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6157398</doc-number>
<kind>A</kind>
<name>Jeddeloh</name>
<date>20001200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>345532</main-classification></classification-national>
</us-citation>
</us-references-cited>
<number-of-claims>17</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>5</number-of-drawing-sheets>
<number-of-figures>5</number-of-figures>
</figures>
<us-related-documents>
<continuation>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>12911640</doc-number>
<date>20101025</date>
</document-id>
<parent-status>PENDING</parent-status>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>12977468</doc-number>
</document-id>
</child-doc>
</relation>
</continuation>
<continuation>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>11229669</doc-number>
<date>20050920</date>
</document-id>
<parent-grant-document>
<document-id>
<country>US</country>
<doc-number>7822979</doc-number>
<date>20101026</date>
</document-id>
</parent-grant-document>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>12911640</doc-number>
</document-id>
</child-doc>
</relation>
</continuation>
<continuation>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>09608439</doc-number>
<date>20000630</date>
</document-id>
<parent-grant-document>
<document-id>
<country>US</country>
<doc-number>6986052</doc-number>
<date>20060110</date>
</document-id>
</parent-grant-document>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>11229669</doc-number>
</document-id>
</child-doc>
</relation>
</continuation>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20110093700</doc-number>
<kind>A1</kind>
<date>20110421</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Mittal</last-name>
<first-name>Millind</first-name>
<address>
<city>Palo Alto</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Mittal</last-name>
<first-name>Millind</first-name>
<address>
<city>Palo Alto</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Blakely, Sokoloff, Taylor &#x26; Zafman LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Intel Corporation</orgname>
<role>02</role>
<address>
<city>Santa Clara</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Perungavoor</last-name>
<first-name>Venkat</first-name>
<department>2496</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A processor capable of secure execution. The processor contains an execution unit and secure partition logic that secures a partition in memory. The processor also contains cryptographic logic coupled to the execution unit that encrypts and decrypts secure data and code.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="163.66mm" wi="231.73mm" file="US08627053-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="228.68mm" wi="160.78mm" orientation="landscape" file="US08627053-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="234.95mm" wi="163.41mm" orientation="landscape" file="US08627053-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="237.24mm" wi="163.75mm" orientation="landscape" file="US08627053-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="246.80mm" wi="175.26mm" file="US08627053-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="225.72mm" wi="163.75mm" file="US08627053-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CROSS REFERENCE TO RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">This application is a Continuation of U.S. patent application Ser. No. 12/911,640, filed on Oct. 25, 2010, entitled &#x201c;METHOD AND APPARATUS FOR SECURE EXECUTION USING A SECURE MEMORY PARTITION&#x201d;, which is a Continuation of U.S. patent application Ser. No. 11/229,669, issued as U.S. Pat. No. 7,822,979, filed on Sep. 20, 2005, entitled &#x201c;METHOD AND APPARATUS FOR SECURE EXECUTION USING A SECURE MEMORY PARTITION&#x201d;, which is a Continuation of U.S. patent application Ser. No. 09/608,439, issued as U.S. Pat. No. 6,986,052, filed on Jun. 30, 2000, entitled &#x201c;METHOD AND APPARATUS FOR SECURE EXECUTION USING A SECURE MEMORY PARTITION&#x201d;.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">FIELD OF THE INVENTION</heading>
<p id="p-0003" num="0002">Embodiments of the present invention relate to secure execution in a processor. In particular, the present invention relates to a method and apparatus for secure execution using a secure memory partition.</p>
<heading id="h-0003" level="1">BACKGROUND</heading>
<p id="p-0004" num="0003">The tremendous increase in connectivity of computers has increased the importance of a robust security infrastructure. A computer system's security features can be used to prevent unauthorized access (e.g., from the Internet). A secure execution environment that preserves the privacy and integrity of transactions is important to enable the use of Internet based commerce. A secured execution environment could also be used to provide copy protection for published software or content (e.g., movies) stored on media like Digital Versatile Disks (DVDs) or Compact Disk-Read Only Memories (CD-ROMs).</p>
<p id="p-0005" num="0004">Securing execution includes ensuring the integrity of the execution and ensuring the privacy of code and data. Various types of threats may lead to a compromise of the integrity or privacy of a system. For example, malicious software may be able to exploit weaknesses in the operating system. Direct memory access devices may be able to read physical memory without processor support. A logic analyzer may be used to observe the traffic between the processor and the memory. Attacks may also be made which take advantage of a processor's built-in debug mode or probe mode or which physically modify the connectivity of components in the system to observe and modify the communication between the components. An attacker could also subject the hardware to an abnormal voltage, temperature or frequency so as to compromise the execution of the system and possibly cause hardware to &#x201c;leak&#x201d; out secrets. In addition, an attacker could remove the process layers selectively to expose the device structures hiding the secrets or use an Ion beam to examine the flow of signals inside the device.</p>
<p id="p-0006" num="0005">Some security schemes, such as those based on public/private key cryptography, uses private data or code that needs to be kept secret. In several cases, the encoding algorithm used is publicly known, and the strength of the cryptography is in keeping the key secret. Intermediate data, such as the control flow information of the program, should not be exposed because it may make it easier to determine the private key. In this regard, conditional assignment capability of a processor architecture may be used to eliminate branches on the secret data, but it is difficult to design code to meet this requirement. For some applications, part of the cryptographic strength is in the privacy of the algorithm itself. In this case, the execution environment needs to guarantee that even the execution code, along with the input data and all intermediate results, is kept private.</p>
<p id="p-0007" num="0006">In some systems, a special security coprocessor is used to protect the code and data of a host processor. Known systems do not provide an effective means for a host processor to protect the private code or data (e.g., a key) within the host processor against attacks that use, for example, malicious software, direct memory access devices, logic analyzers, exploit the system debug/probe mode, or modify the hardware to reveal secrets.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. 1</figref> is a partial block diagram of a computer system capable of secure execution according to an embodiment of the present invention.</p>
<p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. 2</figref> is a partial block diagram of a processor having secure execution components and a memory with a secure partition according to an embodiment of the present invention.</p>
<p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. 3</figref> is a partial block diagram of virtual and physical memory partitions.</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 4</figref> shows a flow chart of a method of processing an instruction according to an embodiment of the present invention.</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 5</figref> shows a flow chart of another method of processing an instruction according to an embodiment of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0013" num="0012">Embodiments of the present invention provide for secure execution by storing sensitive code and data in a secure memory partition. The sensitive code and data may include the code and data used to verify the authenticity and integrity of transmissions received over a network and may include content stored on a media such as a DVD or CD-ROM. A secure memory partition may be defined by the architecture as an address range within the general address space of the processor. The partition may be an address range of virtual memory locations or physical memory locations. The address range may be specified by a base address and a range. The secure memory partition may have a fixed entry point. In a further embodiment, the sensitive code and data is encrypted by hardware on the processor before it is written to the memory, and decrypted after it is read back into the processor, to protect the sensitive code and data from disclosure. Different embodiments of this invention provide protection against different levels of threats. Embodiments provide a high degree of protection against attacks based on malicious software, intelligent I/O devices, attacks using a logic analyzer, and hardware attacks that comprise de-socketing of the processor and then placing it in an integrity compromised platform.</p>
<p id="p-0014" num="0013">Embodiments of a Secure Execution System</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 1</figref> is partial block diagram of a computer system capable of secure execution according to an embodiment of the present invention. Computer <b>100</b> contains components <b>101</b>, which may include a processor <b>110</b>, chipset <b>102</b>, system memory <b>120</b>, network interface card <b>103</b>, non-volatile mass storage <b>104</b>, input/output (I/O) device <b>107</b>, and basic input/output system (BIOS) ROM <b>108</b>. The processor <b>110</b> may be coupled to the chipset <b>102</b>. The term &#x201c;coupled&#x201d; encompasses a direct connection, an indirect connection, an indirect communication, etc. Chipset <b>102</b> may also be coupled to system memory <b>120</b>, network interface card <b>103</b>, non-volatile mass storage <b>104</b>, input/output device <b>107</b> and BIOS ROM <b>108</b>. These devices may be coupled to chipset <b>102</b> over a bus or busses such as a system bus, peripheral component interface (PCI) bus, etc. Network interface card <b>103</b> may be coupled to a network <b>130</b>. Computer <b>100</b> may also contain additional components such as a co-processor, modem, etc.</p>
<p id="p-0016" num="0015">Processor <b>110</b> may be a general purpose microprocessor such as a PENTIUM class processor manufactured by Intel Corp. of Santa Clara, Calif. In another embodiment, the processor can be an Application Specific Integrated Circuit (ASIC), controller, micro-controller, etc. Chipset <b>102</b> may be one or more integrated circuit chips that acts as a hub or core for data transfer between the processor and other components of the computer system. In an embodiment, chipset <b>102</b> includes a memory control hub (MCH), which performs what is known as &#x201c;northbridge functionality,&#x201d; and an input/output controller hub (ICH), which performs what is known as &#x201c;southbridge functionality.&#x201d; System memory <b>120</b> is any device adapted to store digital information, such as a dynamic random access memory (DRAM), a static random access memory (SRAM), etc. or any combination thereof. In an embodiment, system memory <b>120</b> is a volatile memory. Processor <b>110</b>, chipset <b>102</b>, system memory <b>120</b>, and BIOS ROM <b>108</b> may be mounted on a system motherboard in computer <b>100</b>.</p>
<p id="p-0017" num="0016">Network interface card <b>103</b> may contain logic to communicate using a standard network protocol. Network <b>130</b> may be a local or wide area computer network and may be, for example, an intranet or the Internet. Non-volatile mass storage <b>104</b> may be any device or devices adapted to store digital information, such as flash memory, a hard disk, an optical digital storage device, a magneto-electrical storage device, DVD, CD-ROM, etc., or any combination thereof. <figref idref="DRAWINGS">FIG. 1</figref> shows non-volatile mass storage <b>104</b> as including an optical storage <b>105</b> and a floppy drive <b>106</b>. Input/output device <b>107</b> may be a keyboard, mouse, display screen, printer, etc. or any combination of thereof. BIOS ROM <b>108</b> may contain the code to control peripheral devices such as a keyboard, display screen, disk drives, serial communications. BIOS ROM <b>108</b> may also contain code that is used to perform other miscellaneous functions.</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 2</figref> is a partial block diagram of a processor having secure execution components and a memory with a secure partition according to an embodiment of the present invention. <figref idref="DRAWINGS">FIG. 2</figref> shows a processor <b>210</b> and a system memory <b>220</b> which are part of a computer system such as, for example, the computer system <b>100</b> shown in <figref idref="DRAWINGS">FIG. 1</figref>. Processor <b>210</b> and a system memory <b>220</b> may be the same as processor <b>110</b> and system memory <b>120</b> of <figref idref="DRAWINGS">FIG. 1</figref>. Processor <b>210</b> may be coupled to system memory <b>220</b>, for example, through a chipset such as chipset <b>102</b> of <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0019" num="0018">Processor <b>210</b> may contain execution units <b>211</b>, such as for example an arithmetic logic unit, which may be coupled to register files <b>212</b>. Register files <b>212</b> may include a plurality of registers such as general purpose registers, flag registers, an instruction pointer, index registers, etc. or a combination thereof. Register files <b>212</b> may include secure partition registers <b>214</b>. Execution units <b>211</b> may be coupled to a on-chip basic input/output system (BIOS) <b>215</b>, processor key storage element <b>216</b>, and random number generator (RNG) unit <b>217</b>. On-chip BIOS <b>215</b> may contain burned-in logic that is used by the processor to communicate with other system components, such as system memory <b>120</b>, and may contain the logic run when the processor is initiated (booted up). This logic may include bootstrap security logic <b>241</b> as described below. In addition, on-chip BIOS <b>215</b> may contain logic (e.g., firmware, microcode, etc.) to load the instructions from BIOS ROM <b>108</b> into the system memory upon system initiation. Processor key storage element <b>216</b> contains the private key or keys that processor <b>210</b> may use to verify and authenticate information received from other system components and from other computer systems. The processor keys may be burned into the processor key storage element <b>216</b>. Random number generator unit <b>217</b> may be a hardware random number generator that uses any randomization function. In one embodiment, random number generator unit <b>217</b> utilizes statistical phenomenon in physical devices (thermal noise, for example) to provide random numbers.</p>
<p id="p-0020" num="0019">In this embodiment, execution units <b>211</b> may also be coupled to secure partition enforcement logic <b>218</b> which contains the logic to manage a secure partition in a memory or memories as described below. In a further embodiment, secure partition enforcement logic <b>218</b> is coupled to an cryptographic logic <b>219</b> which encrypts information that is to be stored in a secure partition and decrypts information that is read from a secure partition. Cryptographic logic <b>219</b> may be hardware logic that implements an algorithm such as Data Encryption Standard (DES), Rivest-Shamir-Adleman (RSA), or Digital Signal Standard (DSS) encryption. In one embodiment, the cryptographic logic <b>219</b> uses a platform specific key rather than the processor keys stored in processor key storage element <b>216</b>. Secure partition enforcement logic <b>218</b> and cryptographic logic <b>219</b> may be coupled to a translation look-aside buffer (TLB) <b>213</b> which may be used to match virtual addresses in the address space of processor <b>210</b> to physical addresses in system memory <b>220</b> and in other memories accessed by processor <b>210</b>.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 2</figref> also shows system memory <b>220</b> containing a secure memory partition <b>223</b>. Secure memory partition <b>223</b> may be a section of physical memory or virtual memory that is only accessed by code residing in the secure partition. In one embodiment, secure partition <b>223</b> may be defined by two secure partition registers <b>214</b>. For example, secure partition <b>223</b> by a secure partition virtual address base register, which species the start of the secure partition in virtual memory, and a secure partition virtual address range register, which specifies the size of the secure partition. In <figref idref="DRAWINGS">FIG. 2</figref>, secure partition <b>223</b> is shown mapped to physical addresses in system memory <b>220</b>. Secure memory partition <b>223</b> may contain a secure data section <b>225</b> and a secure code section <b>226</b>. The secure code section <b>226</b> may store, for example, trusted verification enforcement instructions <b>242</b> which are used to apply cryptography algorithm and verify the authenticity and integrity of transmissions received over a network (or of content stored on a media such as a DVD or CD-ROM. Secure data section <b>225</b> may contain data used by the secure code, such as private keys and intermediate data (e.g., control flow information of the secure instructions). Secure code section <b>226</b> may have an entry point <b>228</b>, which may be used as described below.</p>
<p id="p-0022" num="0021">The embodiment shown in <figref idref="DRAWINGS">FIG. 2</figref> may operate as follows. The processor <b>210</b> ensures the integrity of the platform by authenticating the BIOS code (e.g., in BIOS ROM <b>108</b>) by using bootstrap security logic such as processor microcode or on-chip BIOS verification firmware code which is shown in <figref idref="DRAWINGS">FIG. 2</figref> as bootstrap security logic <b>241</b>. The secure BIOS <b>108</b> then in turn validates the presence of any other protection mechanisms in the chipset. According to an embodiment, when processor <b>210</b> is booted-up, it may create a secure partition by scanning the memory and determining a location for the secure partition. The processor may then program a secure partition base register and secure partition range register to define the secure partition. These registers may be write-once registers. In other embodiments, other mechanisms may be used to create the secure partition. The processor may then copy verification enforcement instructions <b>242</b> and associated data, such as keys, into secure memory partition <b>223</b> in system memory <b>220</b>. In another embodiment, verification enforcement instructions <b>242</b> are copied during processor boot-up into secure memory partition <b>223</b> from a non-volatile mass storage such as a disk drive. In this embodiment, processor <b>210</b> may use bootstrap security logic <b>241</b> stored in on-chip BIOS <b>215</b> and key data stored in processor key storage element <b>216</b> to verify the authenticity and integrity of the verification enforcement instructions <b>242</b> and data copied into secure memory partition <b>223</b>. This verification may determine if the verification enforcement instructions <b>242</b> stored in a non-volatile memory have been corrupted or compromised by an attack. Storing bootstrap security logic <b>241</b> in the processor and verification enforcement instructions <b>242</b> in a non-volatile memory may be less costly than burning the verification enforcement instructions <b>242</b> into the processor itself.</p>
<p id="p-0023" num="0022">In an embodiment, secure partition enforcement logic <b>218</b> monitors any accesses to memory that are made by processor <b>210</b>. Such accesses may include the execution of an instruction that is stored in the memory or the execution of an instruction that operates on data in the memory. An instruction operates on data in a location in a memory when the instruction reads data that is stored in the location or writes data to the location. In this embodiment, secure partition enforcement logic <b>218</b> will examine each instruction prior to execution of the instructions by processor <b>210</b>. If the instruction is a branch to a location within the secure memory partition <b>223</b>, other than the partition entry point <b>228</b>, then the secure partition enforcement logic determines that the instruction should not be executed. In such a case, the partition instruction logic may trap to a trap handler. The secure partition enforcement logic <b>218</b> will permit the execution of branches to a location within the partition from another location within the partition, and will permit the execution of branches to the partition entry point <b>228</b>. The entry point <b>228</b> may contain the start of a verification routine that verifies the authenticity of the software that jumped to the secure partition. Thus, for example, this routine might prevent an unauthorized or malicious program from executing the secure code. In addition, by enforcing the entry point to the secure code <b>226</b>, secure partition enforcement logic <b>218</b> prevents unauthorized or malicious code from bypassing the verification routine. In a further embodiment, the secure partition enforcement logic determines not to execute an instruction when the instruction is not stored at a partition entry point and the previous instruction executed was the instruction before the beginning of the partition. Thus, if the partition entry point <b>228</b> is not the first instruction in the partition, the secure partition enforcement logic <b>218</b> will prevent the processor from sequentially stepping into the secure partition at a point other than the entry point.</p>
<p id="p-0024" num="0023">In this embodiment, the secure partition enforcement logic will determine to not execute an instruction when the instruction is located outside of the secure partition and attempts to operate on (e.g., reads from or writes to) a location within the secure partition. Thus only the trusted instructions in the secure code section <b>226</b> may operate on data within the secure data section <b>225</b> of the secured memory partition <b>223</b>. In this embodiment, the secure data cannot be accessed accept by code that is located in the secure partition. In a further embodiment, the code in the secure partition may access data that is outside of the secure partition. In another embodiment, secure partition enforcement logic <b>218</b> may determine not execute instructions which attempt to operate on data in the secure data section <b>225</b> of the partition if the instruction does not have the appropriate read/write permission. In another embodiment, the secure partition enforcement logic <b>218</b> may trap to a trap handler when an instruction outside of the secure partition attempts to operate on a location within the secure partition. It may also trap to a trap handler when an instruction attempts to operate on data in the secure data section without the appropriate read/write permission.</p>
<p id="p-0025" num="0024">In an embodiment, secure memory partition <b>223</b> may be a partition in virtual memory. In an embodiment, the processor's address spaces is a virtual memory address space, and all instructions address memory in terms of virtual addresses. In this embodiment, the secure partition is specified in processor <b>210</b> by virtual addresses, such as a virtual address base register and a virtual address range register. By specifying the secure partition in terms of virtual addresses, the secure partition enforcement logic may be located earlier in the pipeline. The transaction lookaside buffer <b>213</b> may translate these virtual addresses into physical addresses. The virtual address to physical address mapping for the secure partition may be done through a trusted mechanism.</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 3</figref> is a partial block diagram of virtual and physical memory partitions. <figref idref="DRAWINGS">FIG. 3</figref> shows a virtual memory <b>360</b> that has an applet space <b>367</b> and a kernel space <b>365</b>. The applet space <b>367</b> and the kernel space <b>365</b> map to a secure partition <b>323</b> in a physical memory <b>320</b>. Information in the secure partition <b>323</b> may be swapped-out to a secure non-volatile space <b>345</b> in non-volatile memory <b>340</b>. Non-volatile memory <b>340</b> may be a flash memory. In an embodiment, the secure non-volatile space <b>345</b> contains only a small portion of the code or data in the secure partition <b>323</b>.</p>
<p id="p-0027" num="0026">In an embodiment, verification enforcement instructions <b>242</b> and associated data are stored in secure partition <b>223</b> in encrypted form to protect against disclosure of the code and data either while in transit from processor <b>210</b> to the memory or while stored in the memory. According to this embodiment, secure code and data will be decrypted by cryptographic logic <b>219</b> after they are transferred into processor <b>210</b> from a secure partition in memory so that execution units <b>211</b> may act on the code and data. Conversely, secure code and data will be encrypted by cryptographic logic <b>219</b> before they are transferred out of processor <b>210</b> to a secure partition in memory. In this way, the secure code and data will be protected from an attack by, for example, a direct memory access, logic analyzer, or Ion beam. If strong enough encryption is used, the attacker will not be able to determine the secure code or data even if they can determine the contents of the secure partition. In one embodiment, the secure code and data is encrypted and decrypted using a shared cryptographic algorithm such as, for example, the Diffi Helman method. In such an embodiment, a cover key may be used to cover the data, and this cover key is not shared. The cover key may be generated by the boot-up logic. In a further embodiment, a system has a number of processors, and the cover key is shared by system processors.</p>
<p id="p-0028" num="0027">In a further embodiment, the computer system has a secure partition in a non-volatile mass storage, such as a disk drive. The secure partition in non-volatile mass storage may be in addition to a secured partition in volatile mass storage. According to this embodiment, a partition in the non-volatile memory are addressable only by secured code.</p>
<p id="p-0029" num="0028">Random number generator <b>217</b> may be used to carry out a cryptographic algorithm or to generate a new key. The processor may use a secure Non-volatile (NV) memory to keep current a monotonic value.</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 4</figref> shows a flow chart of a method of processing an instruction according to an embodiment of the present invention. The instruction may be, for example, an assembly language instruction that is to be executed by a processor such as processor <b>110</b> of <b>210</b> of <figref idref="DRAWINGS">FIGS. 1 and 2</figref>. The instruction is examined prior to execution (<b>401</b>). When the instruction is an unauthorized access to a location within a partition of locations in virtual memory, a determination is made not to execute the instruction. In an embodiment, a determination is made not to execute the instruction when the instruction operates on data in a location within the partition and the instruction is not stored within the partition (<b>402</b>). In a further embodiment, a determination is made not to execute the instruction when the instruction is a branch from a location outside the partition, the branch is to a location within the partition, and the branch is not to a partition entry point (<b>403</b>). According to another embodiment, a determination not to execute the instruction is made when the instruction is not stored at a partition entry point and the previous instruction executed was the instruction immediately before the beginning of the partition (<b>404</b>). If a determination is made that the instruction is authorized, then the instruction is executed (<b>405</b>). For example, the instruction may be executed when the instruction branches to a location within the partition from another location within the partition and when the instruction branches to a partition entry point from a location outside the partition. According to one embodiment, the method includes trapping to a trap handler when a determination is made not to execute the instruction (<b>406</b>).</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 5</figref> shows a flow chart of another method of processing an instruction according to an embodiment of the present invention. According to an embodiment, an encrypted instruction is read into a processor from a secure partition in a memory (<b>501</b>). The instruction may have been encrypted using any cryptographic technique. The instruction read is decrypted (<b>502</b>), for example using the cryptographic logic <b>219</b> shown in <figref idref="DRAWINGS">FIG. 2</figref>. The decrypted instruction may then be executed. In an embodiment, if the instruction is an instruction that reads data from the secure partition (<b>503</b>), the data is read from the secure partition and the data read is decrypted (<b>504</b>). In another embodiment, if the instruction is an instruction that writes data into a location in the secure partition (<b>505</b>), the data is encrypted and the encrypted data is written into the secure partition (<b>506</b>). In a further embodiment, determining whether the instruction is an instruction that reads data from the secure partition or writes data to a location in the secure partition includes comparing the virtual address of the data with secure partition boundaries.</p>
<p id="p-0032" num="0031">Security Privilege Levels (SPLs)</p>
<p id="p-0033" num="0032">In an embodiment, two &#x201c;security privilege levels&#x201d; may be defined. One privilege level, referred to as security kernel privilege level, may be for executing only primitive security functions/services. A second privilege level may be defined for executing processor or third-party supplied security code. This second privilege level may be referred to as the applet privilege level. The new security privilege levels (SPLs) may be orthogonal to existing notions of privilege levels of execution. Thus, in this embodiment, the access (execute/read/write) privileges for a given virtual address range become a function of not only Current Privilege Level (CPL) but also current SPL (CSPL). CSPL indicates the security privilege level associated with the current execution. The default value of CSPL may be 3. In this case, when CSPL is 3, the execution model may be is referred to as the default execution model. When CSPL has a value other than default, the execution model is referred to as that of &#x201c;Hidden Execution&#x201d; model.</p>
<p id="p-0034" num="0033">The two privilege levels may be referred to as SPL of 0 (for kernel) and SPL of 1 (for Applets). The composite privilege level may be referred to as ring x.y, where x is the CPL for current execution and y is the CSPL for current execution. Thus if the current execution's privilege level is 3.3, it implies that current application is executing at default ring <b>3</b>. However, if the current privilege level is 3.0, it implies that current privilege level for execution is ring <b>3</b> with access rights associated with security Kernel privilege level. In one embodiment, the CSPL is always 3 in real mode, in which case there is no support for hidden execution in real mode.</p>
<p id="p-0035" num="0034">Kernel Privilege Level</p>
<p id="p-0036" num="0035">The architecture may define a new virtual address range that is used in the kernel privilege level. The new virtual address range may be defined by a Virtual Address Base Register kernel (VABRk) and Virtual Address Range Register kernel (VARRk). The virtual address range specified by VABRk and VARRk may be defined to have Kernel Level security access rights associated with it and may be referred to as the secure kernel space or the kernel's secure memory partition.</p>
<p id="p-0037" num="0036">In an embodiment, only the code within secure kernel space can read or write in this space. In this case, the integrity and privacy of data and code within the secure kernel space will not be compromised by the code that is outside of this space. In a further embodiment, the code within secure kernel space can read and write data from/to any virtual address space provided such access is allowed, for example, by existing segmentation and paging protection mechanisms. In a still further embodiment, there are instructions defined that can only be executed when at the secure kernel privilege level. In another embodiment, the kernel virtual address space is freely relocatable. In a further embodiment, the size of the secure partition is fixed at the boot-up time and is not under control of general system software. For example, only pre-OS firmware or on-chip microcode may be able to write into a virtual address range register. In this case, the virtual address range register may either be not writeable by software at all (it is written by processor microcode) or may be write-once after reset (if written by the firmware).</p>
<p id="p-0038" num="0037">In another embodiment, there is a fixed entry point into secure kernel space, and it is illegal to branch into secure kernel space from outside of this space to an offset other than the predefined offset for the entry point. From address space with default security privilege, secure kernel space may be entered through any control transfer mechanisms as long as it is to the fixed entry point. In a further embodiment, the kernel service requested by code at the kernel security privilege level may be a function of the current privilege level of the requester. In this embodiment, the code at the entry point into the secure kernel space examines caller's current privilege level and current security privilege level to determine whether or not the requested service is allowed. In an embodiment, the secure kernel address space may exit to the space with a current security privilege level of x.3 through any control transfer mechanism. In cases where the security kernel uses a call/return mechanism to change program flow, the security kernel may need to manage its secure stack space as well as transitions between secure and non-secure application stack spaces.</p>
<p id="p-0039" num="0038">Applet Privilege Level</p>
<p id="p-0040" num="0039">The architecture may define a new virtual address range within the general virtual address space of the processor. This virtual address range may be defined by two registers: a Virtual Address Base Register applet (VABRa), and a Virtual Address Range Register applet (VARRa). The address range defined by VABRa and VARRa has Applet Level may have security access rights associated with it, and may be referred to as secure applet space.</p>
<p id="p-0041" num="0040">In an embodiment, for the virtual address space corresponding to Applet Security Privilege level, the read and write access rights are limited to code that is executing within the address range with Applet or Kernel security privilege level. In one embodiment, an application defining a secure applet space must also define a secure kernel space at the same current privilege level in the context of the same process. In an embodiment, no code, other than kernel or applet hidden execution code, can read or write within secure applet space. Thus the integrity and privacy of data and code that is within secure applet address space may not be compromised by the code that does not have security access rights (i.e. current security privilege level is 3). In this embodiment, the code within secure applet space can not read or write data within secure kernel address space and the code within secure applet space can read and/or write any other address range, other than secure kernel space, provided it is allowed by existing segmentation and paging and protection mechanisms. The secure applet space may be freely relocatable. The size of the partition may be fixed at the boot time, and thus not under control of general system software. In this embodiment, only pre-OS firmware or on-chip microcode may write into the VARRa register. Thus, either register VARRa is not writeable by software at all (in case it is written by processor microcode), or is write-once after reset (if written by the firmware).</p>
<p id="p-0042" num="0041">In an embodiment, the secure applet space can only be entered from secure kernel space. In this embodiment, it may be illegal to branch into secure applet space from the default security space, but there may be no restriction on the entry point into secure applet space from secure kernel space. In this embodiment, calling a function in the secure applet space from the address space with default security privilege requires a transfer of control to the fixed entry point in the secure kernel space with proper &#x201c;credentials&#x201d; for a request of a function within the current secure applet space. The secure applet address space may exit to the space with a current security privilege level of 3 through any control transfer mechanism. However, if an applet wants to call a function in space with default security, it does so through a function call to its secure kernel space.</p>
<p id="p-0043" num="0042">In an embodiment, transitions between secure applet space and secure kernel space are similar to the transitions between address space with default security and secure kernel space, except an applet is allowed to call additional security kernel functions. In this embodiment, the secure applet space may use any control transfer mechanisms for control transfer within secure applet space, except that all interruptions cause exit from secure applet space. Secure applet space may use a call/return mechanism only if security kernel supports the management secure applet stack space, and transitions between secure and non-secure application stack spaces. Support for such a capability in the secure kernel is optional.</p>
<p id="p-0044" num="0043">Secure Physical Memory (RAM and Non-Volatile) Partitions</p>
<p id="p-0045" num="0044">In an embodiment, the security extensions define one &#x201c;secure&#x201d; partition in the physical memory. If a processor implements only security kernel privilege level, the size of the secure physical space is equal to or greater than the size of the secure kernel space. If a processor supports both security kernel and applet privilege level, then size of the physical partition may be equal to or greater than the sum of the secure kernel and applet spaces. The secure physical memory partition may be defined by a Physical Address Base Register (PABR) and a Physical Address Range Register (PARR). In an embodiment, both the base and the range of secure physical memory partition are fixed at the boot time, and thus are not under control of general system software. Only pre-OS firmware may write to PABR or PARR registers. Thus these registers are write-once only after the reset.</p>
<p id="p-0046" num="0045">The physical address partitions may be used to provide the physical memory for secure virtual address partitions when the virtual address mechanism is enabled (e.g., processor is executing in protected mode). When the virtual address mechanism is disabled (e.g., processor is in real mode), the processor hardware may disallow any accesses to secure physical memory partitions, with any access to secure physical memory partitions in real mode resulting in an illegal operation trap.</p>
<p id="p-0047" num="0046">In an embodiment, the secure physical memory partitions may be provided as physical memory in the processor die, a separate die in the same package, or as a part of the external system memory. In the case where the secure physical partition is implemented as part of the external system memory, it is advantageous if the memory controller also implement a pair of registers similar to PABR and PARR, and ensure that this address space is not accessed by DMA devices. Pre-OS BIOS may verify the presence of the appropriate protection mechanism in the chipset. A portion of the secure physical memory may correspond to non-volatile memory. The base address used for the NV physical memory partition may be same as PABR. There may be an additional range register NV Memory Range Register, or NMRR, that defines the size of the Secure NV memory partition and can only be written by SPL <b>0</b> code. Secure NV memory space may reside as a separate die in the same package or as part of an external component. In an embodiment, this NV memory is only accessible if the request is initiated by code running in secure kernel space.</p>
<p id="p-0048" num="0047">In an embodiment, there are four architectural partitions within the secure address space: 1) secure applet space, 2) secure physical memory associated with applet address space for executing a security kernel function requested by an applet, 3) secure physical memory for kernel code and data, and 4) secure NV memory. Secure physical memory for the applet space, and the portion of secure kernel space associated with the applet execution, may be a per process resource. Secure kernel space may implement a function to save the encrypted version of the content of secure applet physical address space as well as part of the secure kernel space that is reserved for a security kernel function called from secure applet code. Secure kernel address space may also implement a function to restore the secure applet physical memory and a part of the secure kernel space associated with the applet space. These functions enable &#x201c;virtualization&#x201d; of secure applet physical memory and the kernel memory associated with the applet space between several processes. The integrity of the swapped-out state may be provided by keeping a hashed value associated with the swapped state in the secure NV memory, along with a &#x201c;unique tag&#x201d; corresponding to this instance of the saved state.</p>
<p id="p-0049" num="0048">In an embodiment, there is enough secure kernel physical memory provided to enable concurrent execution of several kernel functions, and there is no need to allow swapping out kernel functions initiated by the security driver in the middle of the execution. In a further embodiment, once secure kernel space allocated for execution of security functions is in use, any future requests for kernel security functions are blocked till previously executing security functions are completed.</p>
<p id="p-0050" num="0049">Processor Keys</p>
<p id="p-0051" num="0050">In an embodiment, along with unique IDs, processors may also have a private/public key pair. The key pair may be an RSA key pair, DSS key pair, or some other key pair, with RSA being the most advantageous. The private key may be &#x201c;burned&#x201d; inside the processor and only used with specific kernel security functions. These security functions may only execute at privilege level cp1.0 (hence within the kernel security space). The public key may also be provided in the processor with the associated certificate. On-chip NV storage may be provided for full private and public keys. It is sufficient to provide storage for enough components that constitute the public and private key such that at power-up the processor is able to compute full keys using on-chip microcode or kernel code without exposing the private key. The part of the public key certificate corresponding to the signed value of the key should be also provided in on-chip NV memory. In an embodiment, an RSA key pair, for 1024 bit private keys, requires 1344 bits of hidden NV storage on the processor: 512 bits for P component, 512 bits for Q component, and 320 bits for the public key certificate (assuming that signature in the certificate are DSS signature).</p>
<p id="p-0052" num="0051">In addition to the private and public keys, the processor also may have 56 bits (or should have support for triple DES) of a DES key in the on-chip NV cells. This key may also be kept private for the processor, and may be used only for performing DES function for stores/reads to/from external secure physical memory. In an embodiment, a platform specific DES key is used instead of processor specific DES key.</p>
<p id="p-0053" num="0052">Interaction of Security Privilege Levels and Processor Modes of Operations</p>
<p id="p-0054" num="0053">In an embodiment, there are minimal interactions between default processor execution and the Current Security Privilege Level. In a further embodiment, when the virtual translation mechanism is off (i.e., processor is in real mode), the CSPL is forced to 3 (i.e. default mode) and it is illegal to access secure physical address partitions. The security mechanism may be disabled for real mode or virtual mode. In this embodiment, when virtual translation mechanism is ON, (i.e., the processor is in protected mode), any TLB miss for accesses to secure virtual address partitions are handled directly by the processor using a new translation algorithm. The TLB-misses may not result in any TLB related faults.</p>
<p id="p-0055" num="0054">In an embodiment, the Page Translation Entries formats for virtual to physical mappings for secure address space are defined such that, within secure address space, access rights are only controlled by CSPL. When executing code from any of the secure virtual partitions, performance monitoring capabilities are disabled. Where there may be transitions out of secure kernel or applet space due to interruption or external interrupt, appropriate registers may be saved in a predefined block within secure kernel space. Where there may be external system memory used for saving temporary values in the registers, prior to writing the data within secure address space to external memory, the processor may automatically encrypts the values with an on-chip DES unit using the platform specific &#x201c;cover key.&#x201d; After saving of these registers in secure physical memory, the corresponding process register values may be changed to some legal, but meaningless, values. For example, most data/address registers may be changed to all &#x201c;zeros,&#x201d; except EIP may be changed to some fixed legal value.</p>
<p id="p-0056" num="0055">Transitions out of security address spaces may be handled by on-chip microcode or by an interrupt mechanism within the kernel security virtual address partition. Where external memory is used for the security physical address partitions, some implementations may support fetching encrypted version of instruction stream using DES with platform's &#x201c;cover-key&#x201d; from security virtual address partitions.</p>
<p id="p-0057" num="0056">In an embodiment, a new secure transition (TSR) may be defined. According to this embodiment, any control transfer mechanism that transfers program control into secure kernel space from any other space provides caller's CPL and CSPL in this register. Code at the entry point in the secure kernel space can examine these bits and the requested service to determine whether or not the requested service should be allowed. For example, several of the security services can only be requested by code at CPL of 0 (i.e. security driver). In an embodiment, the TSR register may only be updated by hardware or secure kernel code (CSPL of 0).</p>
<p id="p-0058" num="0057">In an embodiment, there are fixed entry points for the secure kernel space. In this embodiment, a branch to any other offset is illegal. One of the registers may specify the function number to be executed within the security or application address space. Some of the functions may require additional parameters as well, for example input operands, a key to be used for decrypting the target code/data, etc. In an embodiment, no transfer of control into secure applet space from address space with default security (CSPL of 3) is allowed. In another embodiment, cache control bits for secure virtual address space are predefined to select &#x201c;write-back&#x201d; attribute for the secure physical space.</p>
<p id="p-0059" num="0058">Security Instructions</p>
<p id="p-0060" num="0059">Security instructions may be provided to implement the functions of the present invention. These instructions may be classified as either instruction required for supporting the security functions or instructions to improve performance of either security functions, or transitions between different privilege levels. In an embodiment, the minimum native security functions require that the implementation support a kernel security privilege level at &#x201c;logic analyzer&#x201d; threat level. The instructions that may be used to support this level of functions are: (1) an instruction to read processor private keys at cp 1.0 privilege level, (2) an instruction to write into platform &#x201c;cover&#x201d; key and another model specific register at cp1.0 privilege level, (3) an instruction to read a processor's public key, along with its certificate, at any CPL or CSPL, and (4) an instruction to read RNG at any CPL or CSPL.</p>
<p id="p-0061" num="0060">Other instructions may be defined to facilitate implementations, and to expedite the transitions between address spaces with different security privileges. These may include a branch &#x201c;hint&#x201d; instruction to indicate that a upcoming control transfer instruction actually will involve change of Current security privilege level. This instruction may be implemented as an instruction that transfers control to code in the secure applet space, an instruction that transfers control to secure kernel space, and/or an instruction that transfers control to the default security privilege level. Another instruction that may be used is an instruction to store to secure NV memory. This instruction may help implementation by making it known in the front-end, instead of the back-end, of the design that the current store is targeted to NV memory.</p>
<p id="p-0062" num="0061">Software Model</p>
<p id="p-0063" num="0062">There are a large number of options possible for to implement the security kernel space. In one embodiment, the security kernel may implement only one security function. In an further embodiment, the security kernel may support additional functions by simply implementing additional functions in macrocode. In another embodiment, the security kernel may implement a policy of allowing only one function to be invoked by the security driver at a time. In this case, the previous security function should complete before any additional security function execution is initiated. In another embodiment, the security kernel may support only one live function within its resources, but allow virtualization of the secure kernel space by the security driver. This approach may lead to significant overhead for encrypting the state of a partially executed function, and performing integrity checks for a newly loaded function. Another embodiment provides enough space in secure kernel space to allow several security functions to be live simultaneously, and not support &#x201c;virtualization&#x201d; of this space.</p>
<p id="p-0064" num="0063">In an embodiment, when an application with CSPL of 3 wants to call a kernel security function, it should to make request via a security driver running at CPL of 0 and CSPL of 3. For performance reasons, the architecture may allow an application to call a function in its associated secure applet without the overhead of a call through the security driver. An application at CSPL of 3 may make such a request through secure kernel space as long as the restrictions on the entry point into secure kernel space are followed. Secure kernel code at the fixed entry point may be responsible for verifying that the caller had appropriate privilege levels (both PL and SPL) to request the specified service. For this purpose, a new register, Transition Status Register (TSR), may be defined to provide PL and SPL of the caller into secure kernel and applet space.</p>
<p id="p-0065" num="0064">For performance reasons a secure applet may be allowed to transfer control back to application through a control transfer instruction. To preserve the privacy of execution, an applet should use a call instruction to transfer control to the application only if the security kernel provides support for a secure stack. In an embodiment, rather than putting the burden on the secure kernel space for verifying the caller, a transfer of control request from application to secure applet space may be only allowed through a security driver. In an embodiment, infrastructure also allows secure applets to call a security function in kernel space through a direct control transfer instruction as long as restrictions on the entry point are followed. Secure kernel space may provide only enough space associated with the current secure applet to support one live security function call at a time. In an embodiment, even though security kernel space can be entered from any CPL and any CSPL, security kernel code at the entry point ensures that only permitted security kernel service requests are made from a given PL and SPL. Security kernel code at the entry point may examine privilege levels of the requester in Transition Status Register (TSR) to make this determination.</p>
<p id="p-0066" num="0065">Registers</p>
<p id="p-0067" num="0066">Registers may be used to manage the secure partition mechanism. These registers may include base and range registers for the secure kernel virtual address space, applet virtual address spaces, physical address space, and non-volatile memory address space. Registers may also be provided to access various processor keys. These may include a register for a processor private key, a register for a processor public key along with signature corresponding to the certificate, and a processor DES &#x201c;cover-key.&#x201d; The registers may be read only registers.</p>
<p id="p-0068" num="0067">Other registers may include a transition status register that provides the PL and SPL of the caller for the transition into security address spaces. In addition, a unique tag number register may hold a tag number assigned to a specific instance of hidden execution. An interrupted security privilege level register may be used to record the security privilege level. These registers may be read/write registers.</p>
<p id="p-0069" num="0068">Secure Kernel and Applet Virtual Address Space Management</p>
<p id="p-0070" num="0069">In an embodiment, the secure kernel and applet address spaces are only defined when the virtual-to-physical translation mechanism is enabled. Security capability may not rely on the OS's memory manager to provide the mapping of the secure virtual address partitions to the secure physical memory. There may be a fixed mapping defined between secure virtual address partitions and secure physical partitions. There may be no provision for access and dirty faults for secure virtual address space, and cache control bits may be set to &#x201c;write-back&#x201d; mode. In an embodiment, the OS service is not needed to establish the link between the secure virtual address space and the secure physical address space. In a further embodiment, there is no notion of page faults for these virtual address partitions.</p>
<p id="p-0071" num="0070">Secure virtual space may be mapped to secure physical space using a fixed linear mapping. Page translation may be a function of the PABR and VARRk registers. Access rights may be predefined. These access rights may allow execute/read/write rights for all CPLs, thus enabling the virtual secure partition to reside at any CPL. In this embodiment, once a transition into the secure address space is allowed by the secure kernel code at the entry point, access permissions for a given virtual address within the secure partition are only controlled by CSPL.</p>
<p id="p-0072" num="0071">In an embodiment, secure virtual address space is freely relocatable. In this embodiment, any time a secure virtual partition is relocated, all previous valid mappings for the relocated secure virtual partition are invalidated. In this way, anytime a branch to the new secure virtual partition is made, there is a new valid TLB entry established for the new partition. In a further embodiment, the TLB mechanism for virtual address space with default security is enhanced to ensure that physical page addresses for these PTE's do not overlap with the secure physical space. A potential overlap may cause an illegal operation fault.</p>
<p id="p-0073" num="0072">Interruptions</p>
<p id="p-0074" num="0073">In an embodiment, hidden execution for both kernel and applet addresses may be interrupted by software and/or through external interrupts. Architecture mechanisms may be provided to allow saving context of a process that might have been in the middle of hidden execution at either the kernel or applet security privilege level. Even if a process is interrupted due to single-stepping while executing in one of the security privilege levels, the hardware and software mechanisms may ensure that the privacy and integrity of the execution is preserved up to threat models. The mechanism used to handle interruptions is dependent upon the features of the processor architecture. In one embodiment, a routine is added to existing interruption microcode to address the security issues if the code executing in security privilege level is interrupted. In another embodiment, a new security interrupt vector table is defined to handle these interruptions. In this embodiment, any interruption while the program is executing in security privilege level is redirected to the handler in security kernel address space. This secure interrupt handler may perform the critical functions to ensure privacy and integrity of the interrupted code, and then branches back to the default interruption vector with all the correct associated interruption status information.</p>
<p id="p-0075" num="0074">Security Levels Specification</p>
<p id="p-0076" num="0075">Different implementations may provide protection against different levels of threats. For example, some implementations may provide protection against only software, intelligent IO and logic analyzer (observe mode only) attacks, while other implementations may provide protection against all threat models including the threat from Ion-beam attack. The ability to protect against a class of threats defines a security level. All security levels should provide protection against a simple hardware attack comprising of de-socketing of the processor and placing it in an integrity compromised platform to circumvent the reliance on high integrity BIOS for establishing secure physical space. In one implementation, the processor ensures integrity of the platform by authenticating the BIOS using processor microcode or on-chip BIOS verification firmware code. In this case, BIOS code may validate the presence of any required security feature in the chipset.</p>
<p id="p-0077" num="0076">In one embodiment of a Security Level 1 (SL-1) model, protected partitions of external system memory and system NV (Flash) memory for mapping secure virtual address partitions are used. In an embodiment, the code for hidden execution is encrypted using a common platform key and is kept in the protected physical memory in encrypted form. For some of the functions that operate on the device's private key, precautions may be taken to ensure that they do not have any branches that are dependent on the bits of the device's private key. This may be is achieved by use of a conditional move instruction or by use of predication capabilities. In an embodiment, all intermediate computation data is kept in the clear form only in the processor registers and on-chip caches. In an embodiment, anytime the data in the secure address range needs to be stored in the external protected physical memory partition, the outbound data is encrypted using a DES unit in the Bus Interface Unit. There may be a separate a DES unit, or a common DES unit may be shared, for decrypting the incoming data and code from the secure physical address space. It is advantageous if the DES unit uses at least a 56-bit DES key. Some implementation may use a larger key (in case triple DES is used).</p>
<p id="p-0078" num="0077">Security level 1 may address the security threats up to the logic analyzer (observe mode) for all hidden execution. When the code in secure physical space is in encrypted form, it is extremely difficult to get access to the processor/platform secrets by modifying the external bus signals actively. However, this security level does not provide any guarantee against such an attack. In a further embodiment, tamper resistance software is used to make &#x201c;known-text&#x201d; attacks even hardware. The Security Level 1 model may also provides some protection against use of implementation probe mode and debug hooks to get access to the implementation specific state in order to decipher private data. Additionally, the SL1 model may employ some limited amount of protection against voltage and frequency tampering techniques to make the processor behave incorrectly to get access to the private data.</p>
<p id="p-0079" num="0078">In the SL-1 model, the protection of the secure partition of the physical memory may be provided by the virtual-to-physical translation mechanism, DES encryption in the processor, and via a physical memory type register in the memory controller. In the SL-1 model, privacy of the secret data may be ensured by operating on the secret data only with-in the processor storage. Any time data within the secure physical memory address range is written out on the bus, it is encrypted using DES unit in the BIU. For some systems, it is desirable that a DES unit be available for encrypting/decrypting data/code to/from secure physical memory uses platform specific key and not processor specific key.</p>
<p id="p-0080" num="0079">Since in SL-1 model all external code and data in the secure physical address space may be kept encrypted with the platform key, one can not decipher code or data by just looking at the external bus signals with a logic analyzer. Processor/platform private keys may be protected to a higher level of threat model. Since external code is encrypted, it is extremely difficult to know which instructions in the function are accessing the private key, or how to modify incoming instruction bit stream such that the processor ends up writing out the private data in the clear memory. The SL-1 model also provides a modest amount of protection against use of processor implementation specific debug and machine-check mechanisms as well as voltage and frequency tampering techniques to get access to processor/platform secrets.</p>
<p id="p-0081" num="0080">An embodiment of the Security Level 2 (SL-2) model raises the security level beyond SL-1 by providing on-chip physical memory for at least a portion of secure physical memory partition. In this case, all of secure NV memory partition still reside in the platform. Some of the volatile secure physical memory may also reside in external system memory. Security protection for the portion of secure volatile memory that is part of the external system memory is similar to SL-1 level. In the SL-2 security model, code for hidden execution may be downloaded from external memory in encrypted form. The code may then be decrypted and verified for integrity using processor on-chip memory. The decrypted code is then executed out of the processor's on-chip memory. All the private data is also kept in the on-chip memory may be in the clear form.</p>
<p id="p-0082" num="0081">According to an embodiment of this model, on-chip memory is a shared processor resource that is managed by the security driver. Part of the on-chip memory may be shared by different processes. The virtualization of this shared portion of the on-chip memory may be done by the driver. There may be security kernel functions available to the driver to provide the ability to encrypt-and-save the part of the on-chip memory. There may also be a security kernel function available to decrypt-and-restore previously saved partition of the on-chip physical memory. Any stores of private data to external NV memory may also be encrypted using the same DES. The SL-2 model may provide a higher level of protection against attacks using processor implementation specific probe mode or debug hooks, as well as via voltage and frequency tampering.</p>
<p id="p-0083" num="0082">In the SL-2 model, the protection of the secure partition of the physical volatile memory may be provided by the virtual-to-physical translation mechanism, on-chip physical memory and via use of DES encryption for the portion of secure physical space that is part of external system memory. The SL-2 model may raise the security level for both device/platform private keys as well as the processor hidden execution compared to SL-1 model. If all critical code and data in the external physical memory is kept in the encrypted form, and in the clear form only in the on-chip physical memory, an attacker can not decipher code or data by just looking at the external bus signals with a logic analyzer. Also, where downloads into the on-chip memory are checked for integrity, the integrity of hidden execution cannot be compromised by driving the external bus signals using a logic analyzer. The SL-2 model also may provide more protection against use of implementation probe and debug hooks to get access to the implementation specific state in order to decipher private data. The SL-2 model may also employ additional protection against voltage and frequency tampering techniques to make the processor behave incorrectly to get access to the private data.</p>
<p id="p-0084" num="0083">An embodiment of the Security Level 3 (SL-3) model raises the security level beyond SL-2 by either providing on-chip secure NV memory, or bringing in secure NV memory partition within the same package as that of the processor die. In an embodiment, some of the volatile and non-volatile memory still may reside as a part of the system memory and system NV memory. Additionally, this security level may provide a much higher level of protection against use of implementation debug hooks, machine check architecture, and various implementation tampering schemes, as well as use of radiation attack. Some implementations may provide a protective die coating on the processor and NV memory silicon, as well as on the interconnect between the processor and secure NV memory die, in order to thwart Ion-beam attack. For the partitions of volatile and non-volatile memories are in system resources, these implementations provide security at least till SL-1 level.</p>
<p id="p-0085" num="0084">In embodiments of the SL-3 model, the protection of the secure partition of the physical volatile as well as NV memory is provided by a combination of virtual-to-physical translation mechanism and on-chip physical memory. This model ensures privacy of the secret data by operating on the secret data only with-in the processor storage. This model may raise the security level for both device/platform private keys as well as the processor hidden execution compared to SL-2 model. In the SL-3 model, all storage involved in hidden execution may be brought into one package. This eliminates exposure of any internal signals between the computation engine and the storage for hidden execution. Additionally, in this model, on-chip (or the same package) NV memory also may allow protection against hardware replay attacks. The SL-3 model may provide extensive protection against leakage of private data through implementation specific probe and debug hooks. The model may also provides protection against various tampering approaches that may cause the processor to malfunction and potentially write out the private data in the clear form on the external buses. Some implementations may also provide a protective-die coating over the processor and private storage domain so that Ion beam attack can not be used to get access to the private data.</p>
<p id="p-0086" num="0085">Macro Functions within the Secure Kernel Address Space</p>
<p id="p-0087" num="0086">Some macro functions that may be implemented within the secure kernel address space are an authentication function, key management function, embedded verification kernel, sign function, verify function, load applet function, encrypted save applet, encrypted restore applet, and calling of a function in applet space.</p>
<heading id="h-0006" level="1">CONCLUSION</heading>
<p id="p-0088" num="0087">Embodiments of the present invention relate to a method and apparatus for secure execution using a secure memory partition. The present invention provides several advantages over prior systems that have a special security coprocessor to protect code and data of a host processor. The present invention is more cost effective because a coprocessor is not needed. In addition, the present invention is a higher performance solution because the security code can be executed in the higher performance general purpose processor. Further, the present invention is a more efficient solution because there is no coprocessor data transfer overhead.</p>
<p id="p-0089" num="0088">Several embodiments of the present invention are specifically illustrated and/or described herein. However, it will be appreciated that modifications and variations of the present invention are covered by the above teachings and within the purview of the appended claims without departing from the spirit and intended scope of the invention. For example, the memory partition may be implemented in virtual memory or physical memory. As another example, embodiments may contain features the conform to either the SL-1, SL-2, or SL-3 security models.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>I claim:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A processing system comprising:
<claim-text>an application processor having an execution unit and an on-chip memory;</claim-text>
<claim-text>a modem;</claim-text>
<claim-text>an I/O interface;</claim-text>
<claim-text>a peripheral interconnect coupled to the application processor, the modem, and the I/O interface;</claim-text>
<claim-text>a non-volatile memory to store verification enforcement instructions;</claim-text>
<claim-text>a system memory having a secure partition; and</claim-text>
<claim-text>a processor coupled to the non-volatile memory and the system memory, the processor comprising:</claim-text>
<claim-text>an on-chip basic input/output system (BIOS) containing bootstrap security logic; and</claim-text>
<claim-text>an execution unit coupled to the on-chip BIOS and the system memory, the execution unit configured to perform operations specified by the bootstrap security logic, the operations including copying the verification enforcement instructions from the non-volatile memory to the secure partition and verifying the authenticity of the verification enforcement instructions.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The processing system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>a key storage element configured to store a key, wherein the key is an RSA public key;</claim-text>
<claim-text>secure partition enforcement logic coupled to the execution unit, the secure partition enforcement logic configured to monitor accesses to the secure partition and to determine whether to permit or deny a memory access;</claim-text>
<claim-text>a translation look-aside buffer (TLB) coupled to the secure partition enforcement logic and configured to match a virtual memory address to physical memory addresses; and</claim-text>
<claim-text>cryptographic logic coupled to the execution unit and the key storage element, the cryptographic logic configured to decrypt the verification enforcement instructions based on the key, wherein the cryptographic logic implements an RSA algorithm.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The processing system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the non-volatile memory includes a flash memory device, and wherein the execution unit includes an arithmetic logic unit.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The processing system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising: one or more secure partition registers adapted to define the secure partition in the system memory.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The processing system of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the secure partition enforcement logic configured to monitor accesses to the secure partition and to determine whether to permit or deny a memory access comprises: the secure partition enforcement logic being configured to detect a branch instruction with a target location outside of the secure partition and to deny the branch instruction based on the target location being outside the secure partition.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The processing system of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the cryptographic logic includes a random number generator.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. A processing system comprising:
<claim-text>an application processor having an execution unit and an on-chip memory;</claim-text>
<claim-text>a modem;</claim-text>
<claim-text>an I/O interface;</claim-text>
<claim-text>a peripheral interconnect coupled to the application processor, the modem, and the I/O interface;</claim-text>
<claim-text>a non-volatile memory to store verification enforcement instructions;</claim-text>
<claim-text>a system memory having a secure partition;</claim-text>
<claim-text>a key storage element configured to store a key, wherein the key is an RSA public key; and</claim-text>
<claim-text>a processor coupled to the non-volatile memory and the system memory, the processor comprising:</claim-text>
<claim-text>an on-chip basic input/output system (BIOS) containing bootstrap security logic;</claim-text>
<claim-text>an execution unit coupled to the on-chip BIOS and the system memory, the execution unit configured to perform operations specified by the bootstrap security logic, the operations including copying the verification enforcement instructions from the non-volatile memory to the secure partition and verifying the authenticity of the verification enforcement instructions;</claim-text>
<claim-text>secure partition enforcement logic coupled to the execution unit, the secure partition enforcement logic configured to monitor accesses to the secure partition and to determine whether to permit or deny a memory access;</claim-text>
<claim-text>a translation look-aside buffer (TLB) coupled to the secure partition enforcement logic and configured to match a virtual memory address to physical memory addresses; and</claim-text>
<claim-text>cryptographic logic coupled to the execution unit and the key storage element, the cryptographic logic configured to decrypt the verification enforcement instructions based on the key, wherein the cryptographic logic implements an RSA algorithm.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The processing system of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the non-volatile memory includes a flash memory device, and wherein the execution unit includes an arithmetic logic unit.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The processing system of <claim-ref idref="CLM-00007">claim 7</claim-ref>, further comprising: one or more secure partition registers adapted to define the secure partition in the system memory.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The processing system of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the secure partition enforcement logic configured to monitor accesses to the secure partition and to determine whether to permit or deny a memory access comprises: the secure partition enforcement logic being configured to detect a branch instruction with a target location outside of the secure partition and to deny the branch instruction based on the target location being outside the secure partition.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The processing system of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the cryptographic logic includes a random number generator.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. A method comprising:
<claim-text>powering on a processing system including an application processor having an execution unit and an on-chip memory, a modem, an I/O interface, and a peripheral interconnect coupled to the application processor, the modem, and the I/O interface;</claim-text>
<claim-text>loading verification enforcement instructions stored in a non-volatile memory into a secure partition of a system memory;</claim-text>
<claim-text>executing operations specified by bootstrap security logic contained in an on-chip basis input/output system (BIOS) included in a processor, the operations including copying the verification enforcement instructions from the non-volatile memory to the secure partition and verifying the authenticity of the verification enforcement instructions.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method of <claim-ref idref="CLM-00012">claim 12</claim-ref>, further comprising:
<claim-text>storing an RSA public key in a key storage element;</claim-text>
<claim-text>monitoring accesses to the secure partition with secure partition enforcement logic</claim-text>
<claim-text>determining whether to permit or deny a memory access with the secure partition enforcement logic;</claim-text>
<claim-text>matching a virtual memory address to physical memory addresses with a translation look-aside buffer (TLB); and</claim-text>
<claim-text>decrypting the verification enforcement instructions based on the key with cryptographic logic, wherein the cryptographic logic implements an RSA algorithm.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The method of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the non-volatile memory includes a flash memory device, and wherein the execution unit includes an arithmetic logic unit.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method of <claim-ref idref="CLM-00012">claim 12</claim-ref>, further comprising: defining the secure partition in the system memory in one or more secure partition registers.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The method of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein determining whether to permit or deny a memory access with the secure partition enforcement logic comprises detecting a branch instruction with a target location outside of the secure partition and denying the branch instruction based on the target location being outside the secure partition.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The method of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the cryptographic logic includes a random number generator. </claim-text>
</claim>
</claims>
</us-patent-grant>
