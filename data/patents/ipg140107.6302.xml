<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627456-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627456</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12967348</doc-number>
<date>20101214</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>262</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20130101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>21</main-group>
<subgroup>31</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>726 19</main-classification>
<further-classification>718  1</further-classification>
<further-classification>345531</further-classification>
</classification-national>
<invention-title id="d2e53">Methods and systems for preventing access to display graphics generated by a trusted virtual machine</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>4887202</doc-number>
<kind>A</kind>
<name>Tanaka et al.</name>
<date>19891200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6131901</doc-number>
<kind>A</kind>
<name>Hirohata</name>
<date>20001000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6453392</doc-number>
<kind>B1</kind>
<name>Flynn, Jr.</name>
<date>20020900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>7380049</doc-number>
<kind>B2</kind>
<name>Rajagopal et al.</name>
<date>20080500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711  6</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>7716377</doc-number>
<kind>B2</kind>
<name>Harris et al.</name>
<date>20100500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>7757231</doc-number>
<kind>B2</kind>
<name>Anderson et al.</name>
<date>20100700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>7937701</doc-number>
<kind>B2</kind>
<name>Kinney et al.</name>
<date>20110500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>8099274</doc-number>
<kind>B2</kind>
<name>Bohizic et al.</name>
<date>20120100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>8145836</doc-number>
<kind>B2</kind>
<name>Nelson et al.</name>
<date>20120300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>8261320</doc-number>
<kind>B1</kind>
<name>Serenyi et al.</name>
<date>20120900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>726  2</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2001/0034736</doc-number>
<kind>A1</kind>
<name>Eylon et al.</name>
<date>20011000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2003/0126242</doc-number>
<kind>A1</kind>
<name>Chang</name>
<date>20030700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2005/0102671</doc-number>
<kind>A1</kind>
<name>Baumberger</name>
<date>20050500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2005/0210158</doc-number>
<kind>A1</kind>
<name>Cowperthwaite et al.</name>
<date>20050900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>2005/0216920</doc-number>
<kind>A1</kind>
<name>Tewari et al.</name>
<date>20050900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>2005/0228921</doc-number>
<kind>A1</kind>
<name>Sethi et al.</name>
<date>20051000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>2005/0235068</doc-number>
<kind>A1</kind>
<name>Moriki et al.</name>
<date>20051000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00018">
<document-id>
<country>US</country>
<doc-number>2005/0268095</doc-number>
<kind>A1</kind>
<name>O'Connor</name>
<date>20051200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00019">
<document-id>
<country>US</country>
<doc-number>2006/0146057</doc-number>
<kind>A1</kind>
<name>Blythe</name>
<date>20060700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>345506</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00020">
<document-id>
<country>US</country>
<doc-number>2006/0200616</doc-number>
<kind>A1</kind>
<name>Maliszewski</name>
<date>20060900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00021">
<document-id>
<country>US</country>
<doc-number>2006/0206702</doc-number>
<kind>A1</kind>
<name>Fausak</name>
<date>20060900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00022">
<document-id>
<country>US</country>
<doc-number>2006/0256105</doc-number>
<kind>A1</kind>
<name>Scarlata et al.</name>
<date>20061100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>345418</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00023">
<document-id>
<country>US</country>
<doc-number>2008/0091934</doc-number>
<kind>A1</kind>
<name>Peterson et al.</name>
<date>20080400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00024">
<document-id>
<country>US</country>
<doc-number>2008/0126614</doc-number>
<kind>A1</kind>
<name>Ooi et al.</name>
<date>20080500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00025">
<document-id>
<country>US</country>
<doc-number>2008/0172555</doc-number>
<kind>A1</kind>
<name>Keenan</name>
<date>20080700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00026">
<document-id>
<country>US</country>
<doc-number>2009/0089879</doc-number>
<kind>A1</kind>
<name>Wang et al.</name>
<date>20090400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00027">
<document-id>
<country>US</country>
<doc-number>2009/0102838</doc-number>
<kind>A1</kind>
<name>Bullard et al.</name>
<date>20090400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00028">
<document-id>
<country>US</country>
<doc-number>2009/0125902</doc-number>
<kind>A1</kind>
<name>Ghosh et al.</name>
<date>20090500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00029">
<document-id>
<country>US</country>
<doc-number>2009/0172663</doc-number>
<kind>A1</kind>
<name>Sahita et al.</name>
<date>20090700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00030">
<document-id>
<country>US</country>
<doc-number>2009/0204964</doc-number>
<kind>A1</kind>
<name>Foley et al.</name>
<date>20090800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00031">
<document-id>
<country>US</country>
<doc-number>2009/0210888</doc-number>
<kind>A1</kind>
<name>Lee et al.</name>
<date>20090800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00032">
<document-id>
<country>US</country>
<doc-number>2009/0222814</doc-number>
<kind>A1</kind>
<name>Astrand</name>
<date>20090900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00033">
<document-id>
<country>US</country>
<doc-number>2010/0174924</doc-number>
<kind>A1</kind>
<name>Banga et al.</name>
<date>20100700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00034">
<document-id>
<country>US</country>
<doc-number>2011/0047618</doc-number>
<kind>A1</kind>
<name>Evans et al.</name>
<date>20110200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00035">
<document-id>
<country>US</country>
<doc-number>2011/0050712</doc-number>
<kind>A1</kind>
<name>Jackson</name>
<date>20110300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00036">
<document-id>
<country>US</country>
<doc-number>2011/0141124</doc-number>
<kind>A1</kind>
<name>Halls et al.</name>
<date>20110600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>345522</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00037">
<document-id>
<country>US</country>
<doc-number>2012/0166653</doc-number>
<kind>A1</kind>
<name>Twitchell</name>
<date>20120600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00038">
<document-id>
<country>US</country>
<doc-number>2012/0278818</doc-number>
<kind>A1</kind>
<name>Green et al.</name>
<date>20121100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00039">
<document-id>
<country>KR</country>
<doc-number>10-2004-0080283</doc-number>
<date>20040900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00040">
<document-id>
<country>KR</country>
<doc-number>10-0775887</doc-number>
<date>20071100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00041">
<document-id>
<country>KR</country>
<doc-number>10-0792786</doc-number>
<date>20080100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00042">
<othercit>Dubnicki, D. et al, Design and implementation of virtual memory-mapped communication on Myrinet, IN: the 11th international parallel processing symposium, Apr. 1-5, 1997, IEEE, pp. 388-396.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00043">
<othercit>Okhravi, H. and Nicol, D., TrustGraph: Trusted Graphics Subsystem for High Assurance Systems, In ACSAC '09: Proceedings of the 2009 Annual Computer Security Applications Conference (Washington, DC, USA, 2009), IEEE Computer Society, pp. 254-265.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00044">
<othercit>Dubnicki, D. et al, Design and implementation of virtual memory-mapped communication on Myrinet, IN: the 11th international parallel processing symposium, Apr. 1-5, 1997, IEEE, pp. 388-396.(Dubnicki, D. et al) See abstract, chapter 2, and 4.5.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00045">
<othercit>International Preliminary Report on Patentability on PCT/US2010/060309 dated Jun. 28, 2012.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00046">
<othercit>International Preliminary Report on Patentability on PCT/US2010/060329 dated Jun. 28, 2012.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00047">
<othercit>International Search Report on PCT/US2010/060309 dated Sep. 1, 2011.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00048">
<othercit>International Search Report on PCT/US2010/060329 dated Aug. 30, 2011.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00049">
<othercit>Office Action on 09 U.S. Appl. No. 12/968,084 dated Nov. 13, 2012.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00050">
<othercit>Office Action on U.S. Appl. No. 12/967,358 dated Aug. 24, 2012.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00051">
<othercit>Written Opinion on PCT/US2010/060309 dated Sep. 1, 2011.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00052">
<othercit>Written Opinion on PCT/US2010/060329 dated Aug. 30, 2011.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00053">
<othercit>Ghodke; Virtualization Techniques to Enable Transparent Access to Peripheral Devices Across Networks, University of Florida 2004.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00054">
<othercit>Notice of Allowance on U.S. Appl. No. 12/968,066 dated Jun. 18, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00055">
<othercit>Office Action on 09 U.S. Appl. No. 12/968,084 dated May 23, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00056">
<othercit>Office Action on U.S. Appl. No. 12/967,358 dated Mar. 22, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00057">
<othercit>Office Action on U.S. Appl. No. 12/967,362 dated Jun. 18, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00058">
<othercit>Office Action on U.S. Appl. No. 12/968,066 dated Dec. 12, 2012.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00059">
<othercit>Office Action on U.S. Appl. No. 12/968,077 dated Jun. 19, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00060">
<othercit>Office Action on U.S. Appl. No. 12/968,082 dated Jun. 12, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00061">
<othercit>Office Action on U.S. Appl. No. 12/968,091 dated Apr. 8, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>14</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>345531</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>718  1</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>726 19</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>24</number-of-drawing-sheets>
<number-of-figures>25</number-of-figures>
</figures>
<us-related-documents>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61286263</doc-number>
<date>20091214</date>
</document-id>
</us-provisional-application>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61286266</doc-number>
<date>20091214</date>
</document-id>
</us-provisional-application>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61286215</doc-number>
<date>20091214</date>
</document-id>
</us-provisional-application>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61286216</doc-number>
<date>20091214</date>
</document-id>
</us-provisional-application>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61286218</doc-number>
<date>20091214</date>
</document-id>
</us-provisional-application>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61286636</doc-number>
<date>20091215</date>
</document-id>
</us-provisional-application>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61286619</doc-number>
<date>20091215</date>
</document-id>
</us-provisional-application>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20110145916</doc-number>
<kind>A1</kind>
<date>20110616</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>McKenzie</last-name>
<first-name>James</first-name>
<address>
<city>Cambridge</city>
<country>GB</country>
</address>
</addressbook>
<residence>
<country>GB</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Guyader</last-name>
<first-name>Jean</first-name>
<address>
<city>Cambridge</city>
<country>GB</country>
</address>
</addressbook>
<residence>
<country>GB</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>McKenzie</last-name>
<first-name>James</first-name>
<address>
<city>Cambridge</city>
<country>GB</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Guyader</last-name>
<first-name>Jean</first-name>
<address>
<city>Cambridge</city>
<country>GB</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Foley &#x26; Lardner LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Lanza</last-name>
<first-name>John D.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Citrix Systems, Inc.</orgname>
<role>02</role>
<address>
<city>Fort Lauderdale</city>
<state>FL</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Pham</last-name>
<first-name>Luu</first-name>
<department>2437</department>
</primary-examiner>
<assistant-examiner>
<last-name>Elmore</last-name>
<first-name>Gregory M</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">The methods and systems provide for preventing a non-trusted virtual machine from reading the graphical output of a trusted virtual machine. A graphics manager receives a request from a trusted virtual machine to render graphical data using a graphics processing unit. The graphics manager assigns, to the trusted virtual machine, a secure section of a memory of the graphics processing unit. The graphics manager renders graphics from the trusted virtual machine graphical data to the secure section of the graphics processing unit memory. The graphics manager receives a request from a non-trusted virtual machine to read graphics rendered from the trusted virtual machine graphical data and stored in the secure section of the graphics processing unit memory, and prevents the non-trusted virtual machine from reading the trusted virtual machine rendered graphics stored in the secure section of the graphics processing unit memory.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="178.99mm" wi="220.47mm" file="US08627456-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="196.68mm" wi="148.59mm" orientation="landscape" file="US08627456-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="182.03mm" wi="180.09mm" file="US08627456-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="188.38mm" wi="167.89mm" file="US08627456-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="215.98mm" wi="138.43mm" file="US08627456-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="221.74mm" wi="157.65mm" orientation="landscape" file="US08627456-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="208.28mm" wi="174.92mm" orientation="landscape" file="US08627456-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="217.85mm" wi="186.52mm" orientation="landscape" file="US08627456-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="224.96mm" wi="178.14mm" file="US08627456-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="253.15mm" wi="176.19mm" orientation="landscape" file="US08627456-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="233.26mm" wi="190.33mm" file="US08627456-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="124.97mm" wi="166.62mm" file="US08627456-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="233.93mm" wi="165.95mm" orientation="landscape" file="US08627456-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="239.69mm" wi="158.92mm" orientation="landscape" file="US08627456-20140107-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="241.55mm" wi="171.70mm" orientation="landscape" file="US08627456-20140107-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="167.89mm" wi="158.24mm" file="US08627456-20140107-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00016" num="00016">
<img id="EMI-D00016" he="153.84mm" wi="156.38mm" file="US08627456-20140107-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00017" num="00017">
<img id="EMI-D00017" he="215.31mm" wi="166.62mm" orientation="landscape" file="US08627456-20140107-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00018" num="00018">
<img id="EMI-D00018" he="224.28mm" wi="153.84mm" file="US08627456-20140107-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00019" num="00019">
<img id="EMI-D00019" he="235.20mm" wi="166.62mm" orientation="landscape" file="US08627456-20140107-D00019.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00020" num="00020">
<img id="EMI-D00020" he="236.47mm" wi="155.70mm" file="US08627456-20140107-D00020.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00021" num="00021">
<img id="EMI-D00021" he="222.33mm" wi="178.14mm" orientation="landscape" file="US08627456-20140107-D00021.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00022" num="00022">
<img id="EMI-D00022" he="238.42mm" wi="158.92mm" file="US08627456-20140107-D00022.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00023" num="00023">
<img id="EMI-D00023" he="245.45mm" wi="164.08mm" orientation="landscape" file="US08627456-20140107-D00023.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00024" num="00024">
<img id="EMI-D00024" he="225.55mm" wi="164.68mm" file="US08627456-20140107-D00024.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">This present application claims the benefit of and priority to: U.S. Provisional Patent Application No. 61/286,263 entitled &#x201c;Methods and Systems for Managing Injection of Input Data into a Virtualization Environment,&#x201d; filed Dec. 14, 2009; U.S. Provisional Patent Application No. 61/286,215 entitled &#x201c;Methods and Systems for Providing, to Virtual Machines, via a Designated Wireless Local Area Network Driver, Access to Data Associated With a Connection to a Wireless Local Area Network,&#x201d; filed Dec. 14, 2009; U.S. Provisional Patent Application No. 61/286,266 entitled &#x201c;Virtual Firmware Servicing Interrupts Generated Responsive to Actuation of Hardware,&#x201d; filed Dec. 14, 2009; U.S. Provisional Patent Application No. 61/286,216 entitled &#x201c;Methods and Systems for Allocating a USB Device to a Secure Virtual Machine or an Unsecure Virtual Machine,&#x201d; filed Dec. 14, 2009; U.S. Provisional Patent Application No. 61/286,218 entitled &#x201c;Drive Manager Controlling Virtual Machine Access to an Optical Disk Drive,&#x201d; filed Dec. 14, 2009; U.S. Provisional Patent Application No. 61/286,636 entitled &#x201c;Methods and Systems for Communicating Between Secure and Unsecure Virtual Machines,&#x201d; filed Dec. 15, 2009; and U.S. Provisional Patent Application No. 61/286,619 entitled &#x201c;Methods and Systems for Preventing Access to Display Graphics Generated by a Secure Virtual Machine,&#x201d; filed Dec. 15, 2009; all of which are incorporated by reference in their entirety.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">FIELD OF THE INVENTION</heading>
<p id="p-0003" num="0002">The present disclosure relates to virtualization technology and virtual machines hosted by a hypervisor. In particular, the present disclosure relates to methods and systems for preventing access to display graphics generated by a trusted virtual machine.</p>
<heading id="h-0003" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0004" num="0003">As the number of mobile employees, remote employees, guest employees and task-based employees increases, so does the need for computing systems that restrict the information available to each type of employee, and isolate an employee's personal data from work-related data. Many companies provide their employees with laptops, remote access to the company's intranet, remote access to applications used by an employee, remote access to an employee's files, and access to remote desktops, virtual machines, or remote applications. In many instances, employees can access company resources from any geographical location, using any machine and/or network.</p>
<p id="p-0005" num="0004">Some companies can provide their employees with machines that can be used to access company resources. In some instances, these machines can execute one or more hypervisors that can manage virtual machines dedicated to executing company applications and accessing company resources. A computer having this type of configuration can sometimes lack a host operating system. Furthermore, a user may be restricted from accessing personal resources while logged into a work-issued virtual machine or virtual desktop. Thus, a user may need an additional virtual machine within which the user can access personal resources and programs. In some systems, when accessing personal resources and programs, a user may be prevented from accessing company resources. Likewise, when functioning within a company-specific virtual machine or virtual desktop, the user may be prevented from accessing personal resources and programs.</p>
<heading id="h-0004" level="1">BRIEF SUMMARY OF THE INVENTION</heading>
<p id="p-0006" num="0005">In one embodiment, the methods and systems described herein provide various functionality for managing and allocating resources interacting in virtual machines. In particular, the methods and systems described herein provide methods and systems for preventing access to display graphics generated by a trusted virtual machine.</p>
<p id="p-0007" num="0006">In one aspect, the present disclosure is directed to a method for preventing a non-trusted virtual machine from reading the graphical output of a trusted virtual machine, in a computing device executing a hypervisor hosting the trusted virtual machine and the non-trusted virtual machine. The method includes receiving, by a graphics manager executed by a processor of a computing device, a request from a trusted virtual machine executed by the computing device to render graphical data using a graphics processing unit of the computing device. The method also includes assigning, by the graphics manager to the trusted virtual machine, a secure section of a memory of the graphics processing unit. The method further includes rendering, by the graphics manager, graphics from the trusted virtual machine graphical data to the secure section of the graphics processing unit memory. The method also includes receiving, by the graphics manager, a request from a non-trusted virtual machine executed by the computing device to read graphics rendered from the trusted virtual machine graphical data and stored in the secure section of the graphics processing unit memory. The method further includes preventing, by the graphics manager, the non-trusted virtual machine from reading the trusted virtual machine rendered graphics stored in the secure section of the graphics processing unit memory.</p>
<p id="p-0008" num="0007">In one embodiment, the method includes receiving, by the graphics manager, a request generated by an application executing on the trusted virtual machine, the application generating the graphical data. In another embodiment, the method includes assigning a policy to a range of memory addresses. In yet another embodiment, the method includes identifying, by the graphics manager, a security credential of the non-trusted virtual machine; and determining, by the graphics manager based on the security credential, the non-trusted virtual machine does not have permission to access the secure section of the graphics processing unit memory. In a further embodiment, the method includes applying a policy of the secure section of the graphics processing unit memory to the security credential.</p>
<p id="p-0009" num="0008">In some embodiments, the method includes storing the rendered graphics to the secure section of the graphics processing unit memory. In other embodiments, the method includes receiving, by the graphics manager, a request from an application executing on the non-trusted virtual machine to render a second set of graphical data using the graphics processing unit, the application generating the second set of graphical data; and rendering, by the graphics manager, graphics from the second set of graphical data to a section of the graphics processing unit memory not comprising the secure section of the graphics processing unit memory. In a further embodiment, the method includes identifying, by the graphics manager, a security credential of the application executing on the non-trusted virtual machine. The method also includes determining, by the graphics manager based on the security credential, the non-trusted virtual machine does not have permission to access the secure section of the graphics processing unit memory. The method further includes preventing, by the graphics manager, the graphics processing unit from rendering the graphics to the secure section of the graphics processing unit memory.</p>
<p id="p-0010" num="0009">In another aspect, the present disclosure is directed towards a system for preventing a non-trusted virtual machine from reading the graphical output of a trusted virtual machine, in a computing device executing a hypervisor hosting the trusted virtual machine and the non-trusted virtual machine. The system includes a computing device comprising a processor executing a graphics manager and a hypervisor hosting a trusted virtual machine and a non-trusted virtual machine, and a graphics processing unit, comprising a memory. The graphics manager is configured to receive a request from the trusted virtual machine to render graphical data using the graphics processing unit. The graphics manager is also configured to assign, to the trusted virtual machine, a secure section of the memory of the graphics processing unit. The graphics manager is further configured to render graphics from the trusted virtual machine graphical data to the secure section of the graphics processing unit memory. The graphics manager is also configured to receive a request from the non-trusted virtual machine to read graphics rendered from the trusted virtual machine graphical data and stored in the secure section of the graphics processing unit memory. The graphics manager is further configured to prevent the non-trusted virtual machine from reading the trusted virtual machine rendered graphics stored in the secure section of the graphics processing unit memory.</p>
<p id="p-0011" num="0010">In one embodiment, the system comprises an application executing on the trusted virtual machine generating the graphical data, and the graphics manager is further configured to receive a request generated by the application. In another embodiment, the graphics manager is further configured to assign a policy to a range of memory addresses. In yet another embodiment, the graphics manager is further configured to identify a security credential of the non-trusted virtual machine, and determine, based on the security credential, the non-trusted virtual machine does not have permission to access the secure section of the graphics processing unit memory. In a further embodiment, the graphics manager is further configured to apply a policy of the secure section of the graphics processing unit memory to the security credential.</p>
<p id="p-0012" num="0011">In some embodiments, the graphics manager is further configured to store the rendered graphics to the secure section of the graphics processing unit memory. In other embodiments, the system includes an application executing on the non-trusted virtual machine, and the graphics manager is further configured to receive a request from the application to render a second set of graphical data using the graphics processing unit, the application generating the second set of graphical data, and render graphics from the second set of graphical data to a section of the graphics processing unit memory not comprising the secure section of the graphics processing unit memory. In a further embodiment, the graphics manager is further configured to identify a security credential of the application executing on the non-trusted virtual machine. The graphics manager is also configured to determine, based on the security credential, the non-trusted virtual machine does not have permission to access the secure section of the graphics processing unit memory. The graphics manager is further configured to prevent the graphics processing unit from rendering the graphics to the secure section of the graphics processing unit memory.</p>
<p id="p-0013" num="0012">The details of various embodiments of the invention are set forth in the accompanying drawings and the description below.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE FIGURES</heading>
<p id="p-0014" num="0013">The foregoing and other objects, aspects, features, and advantages of the disclosure will become more apparent and better understood by referring to the following description taken in conjunction with the accompanying drawings, in which:</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 1A</figref> is a block diagram depicting an embodiment of a network environment comprising local machines in communication with remote machines;</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIGS. 1B-1E</figref> are block diagrams depicting embodiments of computers useful in connection with the methods and systems described herein;</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIGS. 2A and 2B</figref> are block diagrams depicting embodiments of a virtualization environment;</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 3A</figref> is a block diagram depicting an embodiment of a system for communication between trusted and non-trusted virtual machines;</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 3B</figref> is a flow diagram of an embodiment of a method for communication between trusted and non-trusted virtual machines.</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 4A</figref> is a block diagram depicting an embodiment of a system for managing injection of input data into a virtualization environment;</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 4B</figref> is a flow chart of an embodiment of a method for managing injection of input data into a virtualization environment;</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 4C</figref> is a chart of an embodiment of a method of managing injection of input data into a virtualization environment;</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 5A</figref> is a block diagram depicting an embodiment of a system for servicing interrupts generated responsive to actuation of hardware via virtual firmware;</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 5B</figref> is a flow diagram of an embodiment of a method for servicing interrupts generated responsive to actuation of hardware via virtual firmware;</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 6A</figref> is a block diagram depicting an embodiment of a system for allocating a universal serial bus (USB) device to a trusted virtual machine or a non-trusted virtual machine;</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 6B</figref> is a flow chart of an embodiment of a method for allocating a universal serial bus (USB) device to a trusted virtual machine or a non-trusted virtual machine;</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 6C</figref> is a flow chart of an embodiment of a method for applying a policy to a USB device allocated to a trusted virtual machine or a non-trusted virtual machine;</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 7A</figref> is a block diagram depicting an embodiment of a system for controlling virtual machine access to an optical disc drive;</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 7B</figref> is a flow chart of an embodiment of a method for controlling virtual machine access to an optical disc drive;</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 8A</figref> is a block diagram of an embodiment of a system for providing to virtual machines, via a designated wireless local area network driver, access to data associated with a connection to a wireless local area network;</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 8B</figref> is a flow chart of an embodiment of a method for providing to virtual machines, via a designated wireless local area network driver, access to data associated with a connection to a wireless local area network;</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 9A</figref> is a block diagram of an embodiment of a system for preventing access to display graphics generated by a trusted virtual machine;</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 9B</figref> is a flow chart of an embodiment of a method for preventing access to display graphics generated by a trusted virtual machine;</p>
<p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. 10A</figref> is a block diagram of an embodiment of a system for securing sensitive information using a hypervisor-trusted client; and</p>
<p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. 10B</figref> is a flow chart of an embodiment of a method for securing sensitive information using a hypervisor-trusted client.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<p id="p-0036" num="0035">The features and advantages of the present invention will become more apparent from the detailed description set forth below when taken in conjunction with the drawings, in which like reference characters identify corresponding elements throughout. In the drawings, like reference numbers generally indicate identical, functionally similar, and/or structurally similar elements.</p>
<heading id="h-0006" level="1">DETAILED DESCRIPTION OF THE INVENTION</heading>
<p id="p-0037" num="0036">For purposes of reading the description of the various embodiments below, the following descriptions of the sections of the specification and their respective contents may be helpful:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0037">Section A describes a network environment and computing environment which may be useful for practicing embodiments described herein;</li>
        <li id="ul0002-0002" num="0038">Section B describes embodiments of systems including a virtualization environment which may be useful for practicing embodiments described herein;</li>
        <li id="ul0002-0003" num="0039">Section C describes embodiments of systems and methods for communication between trusted and non-trusted virtual machines;</li>
        <li id="ul0002-0004" num="0040">Section D describes embodiments of systems and methods for managing injection of input data into a virtualization environment;</li>
        <li id="ul0002-0005" num="0041">Section E describes embodiments of systems and methods for servicing interrupts generated responsive to actuation of hardware via virtual firmware;</li>
        <li id="ul0002-0006" num="0042">Section F describes embodiments of systems and methods for allocating a universal serial bus (USB) device to a trusted virtual machine or a non-trusted virtual machine;</li>
        <li id="ul0002-0007" num="0043">Section G describes embodiments of systems and methods for controlling virtual machine access to an optical disc drive;</li>
        <li id="ul0002-0008" num="0044">Section H describes embodiments of systems and methods for providing to virtual machines, via a designated wireless local area network driver, access to data associated with a connection to a wireless local area network;</li>
        <li id="ul0002-0009" num="0045">Section I describes embodiments of systems and methods for preventing access to display graphics generated by a trusted virtual machine; and</li>
        <li id="ul0002-0010" num="0046">Section J describes embodiments of systems and methods for securing sensitive information using a hypervisor-trusted client.
<br/>
A. Network and Computing Environment
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0038" num="0047">Referring now to <figref idref="DRAWINGS">FIG. 1A</figref>, an embodiment of a network environment is depicted. In brief overview, the network environment comprises one or more local machines <b>102</b><i>a</i>-<b>102</b><i>n </i>(also generally referred to as local machine(s) <b>102</b>, client(s) <b>102</b>, client node(s) <b>102</b>, client machine(s) <b>102</b>, client computer(s) <b>102</b>, client device(s) <b>102</b>, endpoint(s) <b>102</b>, or endpoint node(s) <b>102</b>) in communication with one or more remote machines <b>106</b><i>a</i>-<b>106</b><i>n </i>(also generally referred to as server(s) <b>106</b> or remote machine(s) <b>106</b>) via one or more networks <b>104</b>. In some embodiments, a local machine <b>102</b> has the capacity to function as both a client node seeking access to resources provided by a server and as a server providing access to hosted resources for other clients <b>102</b><i>a</i>-<b>102</b><i>n. </i></p>
<p id="p-0039" num="0048">Although <figref idref="DRAWINGS">FIG. 1A</figref> shows a network <b>104</b> between the local machines <b>102</b> and the remote machines <b>106</b>, the local machines <b>102</b> and the remote machines <b>106</b> may be on the same network <b>104</b>. The network <b>104</b> can be a local-area network (LAN), such as a company Intranet, a metropolitan area network (MAN), or a wide area network (WAN), such as the Internet or the World Wide Web. In some embodiments, there are multiple networks <b>104</b> between the local machines <b>102</b> and the remote machines <b>106</b>. In one of these embodiments, a network <b>104</b>&#x2032; (not shown) may be a private network and a network <b>104</b> may be a public network. In another of these embodiments, a network <b>104</b> may be a private network and a network <b>104</b>&#x2032; a public network. In still another embodiment, networks <b>104</b> and <b>104</b>&#x2032; may both be private networks. In yet another embodiment, networks <b>104</b> and <b>104</b>&#x2032; may both be public networks.</p>
<p id="p-0040" num="0049">The network <b>104</b> may be any type and/or form of network and may include any of the following: a point to point network, a broadcast network, a wide area network, a local area network, a telecommunications network, a data communication network, a computer network, an ATM (Asynchronous Transfer Mode) network, a SONET (Synchronous Optical Network) network, a SDH (Synchronous Digital Hierarchy) network, a wireless network and a wireline network. In some embodiments, the network <b>104</b> may comprise a wireless link, such as an infrared channel or satellite band. The topology of the network <b>104</b> may be a bus, star, or ring network topology. The network <b>104</b> may be of any such network topology as known to those ordinarily skilled in the art capable of supporting the operations described herein. The network may comprise mobile telephone networks utilizing any protocol or protocols used to communicate among mobile devices, including AMPS, TDMA, CDMA, GSM, GPRS or UMTS. In some embodiments, different types of data may be transmitted via different protocols. In other embodiments, the same types of data may be transmitted via different protocols.</p>
<p id="p-0041" num="0050">In some embodiments, the system may include multiple, logically-grouped remote machines <b>106</b>. In one of these embodiments, the logical group of remote machines may be referred to as a server farm. In another of these embodiments, the remote machines <b>106</b> may be geographically dispersed. In other embodiments, a server farm may be administered as a single entity. In still other embodiments, the server farm comprises a plurality of server farms. The remote machines <b>106</b> within each server farm can be heterogeneous&#x2014;one or more of the remote machines <b>106</b> can operate according to one type of operating system platform (e.g., WINDOWS NT, WINDOWS 2003, WINDOWS 2008, WINDOWS 7 and WINDOWS Server 2008 R2, all of which are manufactured by Microsoft Corp. of Redmond, Wash.), while one or more of the other remote machines <b>106</b> can operate on according to another type of operating system platform (e.g., Unix or Linux).</p>
<p id="p-0042" num="0051">The remote machines <b>106</b> of each server farm do not need to be physically proximate to another remote machine <b>106</b> in the same server farm. Thus, the group of remote machines <b>106</b> logically grouped as a server farm may be interconnected using a wide-area network (WAN) connection or a metropolitan-area network (MAN) connection. For example, a server farm <b>38</b> may include remote machines <b>106</b> physically located in different continents or different regions of a continent, country, state, city, campus, or room. Data transmission speeds between remote machines <b>106</b> in the server farm can be increased if the remote machines <b>106</b> are connected using a local-area network (LAN) connection or some form of direct connection.</p>
<p id="p-0043" num="0052">A remote machine <b>106</b> may be a file server, application server, web server, proxy server, appliance, network appliance, gateway, application gateway, gateway server, virtualization server, deployment server, SSL VPN server, or firewall. In some embodiments, a remote machine <b>106</b> provides a remote authentication dial-in user service, and is referred to as a RADIUS server. In other embodiments, a remote machine <b>106</b> may have the capacity to function as either an application server or as a master application server. In still other embodiments, a remote machine <b>106</b> is a blade server. In yet other embodiments, a remote machine <b>106</b> executes a virtual machine providing, to a user or client computer <b>102</b>, access to a computing environment.</p>
<p id="p-0044" num="0053">In one embodiment, a remote machine <b>106</b> may include an Active Directory. The remote machine <b>106</b> may be an application acceleration appliance. For embodiments in which the remote machine <b>106</b> is an application acceleration appliance, the remote machine <b>106</b> may provide functionality including firewall functionality, application firewall functionality, or load balancing functionality. In some embodiments, the remote machine <b>106</b> comprises an appliance such as one of the line of appliances manufactured by the Citrix Application Networking Group, of San Jose, Calif., or Silver Peak Systems, Inc., of Mountain View, Calif., or of Riverbed Technology, Inc., of San Francisco, Calif., or of F5 Networks, Inc., of Seattle, Wash., or of Juniper Networks, Inc., of Sunnyvale, Calif.</p>
<p id="p-0045" num="0054">In some embodiments, a remote machine <b>106</b> executes an application on behalf of a user of a local machine <b>102</b>. In other embodiments, a remote machine <b>106</b> executes a virtual machine, which provides an execution session within which applications execute on behalf of a user of a local machine <b>102</b>. In one of these embodiments, the execution session is a hosted desktop session. In another of these embodiments, the execution session provides access to a computing environment, which may comprise one or more of: an application, a plurality of applications, a desktop application, and a desktop session in which one or more applications may execute.</p>
<p id="p-0046" num="0055">In some embodiments, a local machine <b>102</b> communicates with a remote machine <b>106</b>. In one embodiment, the local machine <b>102</b> communicates directly with one of the remote machines <b>106</b> in a server farm <b>38</b>. In another embodiment, the local machine <b>102</b> executes a program neighborhood application to communicate with a remote machine <b>106</b> in a server farm <b>38</b>. In still another embodiment, the remote machine <b>106</b> provides the functionality of a master node. In some embodiments, the local machine <b>102</b> communicates with the remote machine <b>106</b> in the server farm <b>38</b> through a network <b>104</b>. Over the network <b>104</b>, the local machine <b>102</b> can, for example, request execution of various applications hosted by the remote machines <b>106</b><i>a</i>-<b>106</b><i>n </i>in the server farm <b>38</b> and receive output of the results of the application execution for display. In some embodiments, only a master node provides the functionality required to identify and provide address information associated with a remote machine <b>106</b><i>b </i>hosting a requested application.</p>
<p id="p-0047" num="0056">In one embodiment, the remote machine <b>106</b> provides the functionality of a web server. In another embodiment, the remote machine <b>106</b><i>a </i>receives requests from the local machine <b>102</b>, forwards the requests to a second remote machine <b>106</b><i>b </i>and responds to the request by the local machine <b>102</b> with a response to the request from the remote machine <b>106</b><i>b</i>. In still another embodiment, the remote machine <b>106</b><i>a </i>acquires an enumeration of applications available to the local machine <b>102</b> and address information associated with a remote machine <b>106</b><i>b </i>hosting an application identified by the enumeration of applications. In yet another embodiment, the remote machine <b>106</b> presents the response to the request to the local machine <b>102</b> using a web interface. In one embodiment, the local machine <b>102</b> communicates directly with the remote machine <b>106</b> to access the identified application. In another embodiment, the local machine <b>102</b> receives output data, such as display data, generated by an execution of the identified application on the remote machine <b>106</b>.</p>
<p id="p-0048" num="0057">In some embodiments, the remote machine <b>106</b> or a server farm <b>38</b> may be running one or more applications, such as an application providing a thin-client computing or remote display presentation application. In one embodiment, the remote machine <b>106</b> or server farm <b>38</b> executes as an application any portion of the CITRIX ACCESS SUITE by Citrix Systems, Inc., such as the METAFRAME or CITRIX PRESENTATION SERVER products, any of the following products manufactured by Citrix Systems, Inc.: CITRIX XENAPP, CITRIX XENDESKTOP, CITRIX ACCESS GATEWAY, and/or any of the MICROSOFT WINDOWS Terminal Services manufactured by the Microsoft Corporation. In another embodiment, the application is an ICA client, developed by Citrix Systems, Inc. of Fort Lauderdale, Fla. In still another embodiment, the remote machine <b>106</b> may run an application, which, for example, may be an application server providing email services such as MICROSOFT EXCHANGE manufactured by the Microsoft Corporation of Redmond, Wash., a web or Internet server, or a desktop sharing server, or a collaboration server. In yet another embodiment, any of the applications may comprise any type of hosted service or products, such as GOTOMEETING provided by Citrix Online Division, Inc. of Santa Barbara, Calif., WEBEX provided by WebEx, Inc. of Santa Clara, Calif., or Microsoft Office LIVE MEETING provided by Microsoft Corporation of Redmond, Wash.</p>
<p id="p-0049" num="0058">A local machine <b>102</b> may execute, operate or otherwise provide an application, which can be any type and/or form of software, program, or executable instructions such as any type and/or form of web browser, web-based client, client-server application, a thin-client computing client, an ActiveX control, or a Java applet, or any other type and/or form of executable instructions capable of executing on local machine <b>102</b>. In some embodiments, the application may be a server-based or a remote-based application executed on behalf of the local machine <b>102</b> on a remote machine <b>106</b>. In other embodiments, the remote machine <b>106</b> may display output to the local machine <b>102</b> using any thin-client protocol, presentation layer protocol, or remote-display protocol, such as the Independent Computing Architecture (ICA) protocol manufactured by Citrix Systems, Inc. of Ft. Lauderdale, Fla.; the Remote Desktop Protocol (RDP) manufactured by the Microsoft Corporation of Redmond, Wash.; the X11 protocol; the Virtual Network Computing (VNC) protocol, manufactured by AT&#x26;T Bell Labs; the SPICE protocol, manufactured by Qumranet, Inc., of Sunnyvale, Calif., USA, and of Raanana, Israel; the Net2 Display protocol, manufactured by VESA, of Milpitas, Calif.; the PC-over-IP protocol, manufactured by Teradici Corporation, of Burnaby, B.C.; the TCX protocol, manufactured by Wyse Technology, Inc., of San Jose, Calif.; the THINC protocol developed by Columbia University in the City of New York, of New York, N.Y.; or the Virtual-D protocols manufactured by Desktone, Inc., of Chelmsford, Mass. The application can use any type of protocol and it can be, for example, an HTTP client, an FTP client, an Oscar client, or a Telnet client. In still other embodiments, the application comprises any type of software related to voice over Internet protocol (VoIP) communications, such as a soft IP telephone. In further embodiments, the application comprises any application related to real-time data communications, such as applications for streaming video and/or audio.</p>
<p id="p-0050" num="0059">The local machine <b>102</b> and remote machine <b>106</b> may be deployed as and/or executed on any type and form of computing device, such as a computer, network device or appliance capable of communicating on any type and form of network and performing the operations described herein. <figref idref="DRAWINGS">FIGS. 1B and 1C</figref> depict block diagrams of a computing device <b>100</b> useful for practicing an embodiment of the local machine <b>102</b> or a remote machine <b>106</b>. As shown in <figref idref="DRAWINGS">FIGS. 1B and 1C</figref>, each computing device <b>100</b> includes a central processing unit <b>121</b>, and a main memory unit <b>122</b>. As shown in <figref idref="DRAWINGS">FIG. 1B</figref>, a computing device <b>100</b> may include a storage device <b>128</b>, an installation device <b>116</b>, a network interface <b>118</b>, an I/O controller <b>123</b>, display devices <b>124</b><i>a</i>-<i>n</i>, a keyboard <b>126</b> and a pointing device <b>127</b>, such as a mouse. The storage device <b>128</b> may include, without limitation, an operating system, software, and a client agent <b>120</b>. As shown in <figref idref="DRAWINGS">FIG. 1C</figref>, each computing device <b>100</b> may also include additional optional elements, such as a memory port <b>103</b>, a bridge <b>170</b>, one or more input/output devices <b>130</b><i>a</i>-<b>130</b><i>n </i>(generally referred to using reference numeral <b>130</b>), and a cache memory <b>140</b> in communication with the central processing unit <b>121</b>.</p>
<p id="p-0051" num="0060">The central processing unit <b>121</b> is any logic circuitry that responds to and processes instructions fetched from the main memory unit <b>122</b>. In many embodiments, the central processing unit <b>121</b> is provided by a microprocessor unit, such as: those manufactured by Intel Corporation of Mountain View, Calif.; those manufactured by Motorola Corporation of Schaumburg, Ill.; those manufactured by Transmeta Corporation of Santa Clara, Calif.; the RS/6000 processor, those manufactured by International Business Machines of White Plains, N.Y.; or those manufactured by Advanced Micro Devices of Sunnyvale, Calif. The computing device <b>100</b> may be based on any of these processors, or any other processor capable of operating as described herein.</p>
<p id="p-0052" num="0061">Main memory unit <b>122</b> may be one or more memory chips capable of storing data and allowing any storage location to be directly accessed by the microprocessor <b>121</b>, such as Static random access memory (SRAM), Burst SRAM or SynchBurst SRAM (BSRAM), Dynamic random access memory (DRAM), Fast Page Mode DRAM (FPM DRAM), Enhanced DRAM (EDRAM), Extended Data Output RAM (EDO RAM), Extended Data Output DRAM (EDO DRAM), Burst Extended Data Output DRAM (BEDO DRAM), Enhanced DRAM (EDRAM), synchronous DRAM (SDRAM), JEDEC SRAM, PC100 SDRAM, Double Data Rate SDRAM (DDR SDRAM), Enhanced SDRAM (ESDRAM), SyncLink DRAM (SLDRAM), Direct Rambus DRAM (DRDRAM), or Ferroelectric RAM (FRAM). The main memory <b>122</b> may be based on any of the above described memory chips, or any other available memory chips capable of operating as described herein. In the embodiment shown in <figref idref="DRAWINGS">FIG. 1B</figref>, the processor <b>121</b> communicates with main memory <b>122</b> via a system bus <b>150</b> (described in more detail below). <figref idref="DRAWINGS">FIG. 1C</figref> depicts an embodiment of a computing device <b>100</b> in which the processor communicates directly with main memory <b>122</b> via a memory port <b>103</b>. For example, in <figref idref="DRAWINGS">FIG. 1C</figref> the main memory <b>122</b> may be DRDRAM.</p>
<p id="p-0053" num="0062"><figref idref="DRAWINGS">FIG. 1C</figref> depicts an embodiment in which the main processor <b>121</b> communicates directly with cache memory <b>140</b> via a secondary bus, sometimes referred to as a backside bus. In other embodiments, the main processor <b>121</b> communicates with cache memory <b>140</b> using the system bus <b>150</b>. Cache memory <b>140</b> typically has a faster response time than main memory <b>122</b> and is typically provided by SRAM, BSRAM, or EDRAM. In the embodiment shown in <figref idref="DRAWINGS">FIG. 1B</figref>, the processor <b>121</b> communicates with various I/O devices <b>130</b> via a local system bus <b>150</b>. Various buses may be used to connect the central processing unit <b>121</b> to any of the I/O devices <b>130</b>, including a VESA VL bus, an ISA bus, an EISA bus, a MicroChannel Architecture (MCA) bus, a PCI bus, a PCI-X bus, a PCI-Express bus, or a NuBus. For embodiments in which the I/O device is a video display <b>124</b>, the processor <b>121</b> may use an Advanced Graphics Port (AGP) to communicate with the display <b>124</b>. <figref idref="DRAWINGS">FIG. 1C</figref> depicts an embodiment of a computer <b>100</b> in which the main processor <b>121</b> communicates directly with I/O device <b>130</b><i>b </i>via HYPERTRANSPORT, RAPIDIO, or INFINIBAND communications technology. <figref idref="DRAWINGS">FIG. 1C</figref> also depicts an embodiment in which local busses and direct communication are mixed: the processor <b>121</b> communicates with I/O device <b>130</b><i>a </i>using a local interconnect bus while communicating with I/O device <b>130</b><i>b </i>directly.</p>
<p id="p-0054" num="0063">A wide variety of I/O devices <b>130</b><i>a</i>-<b>130</b><i>n </i>may be present in the computing device <b>100</b>. Input devices include keyboards, mice, trackpads, trackballs, microphones, and drawing tablets. Output devices include video displays, speakers, inkjet printers, laser printers, and dye-sublimation printers. An I/O controller <b>123</b>, as shown in <figref idref="DRAWINGS">FIG. 1B</figref>, may control the I/O devices. The I/O controller may control one or more I/O devices such as a keyboard <b>126</b> and a pointing device <b>127</b>, e.g., a mouse or optical pen. Furthermore, an I/O device may also provide storage and/or an installation medium <b>116</b> for the computing device <b>100</b>. In still other embodiments, the computing device <b>100</b> may provide USB connections (not shown) to receive handheld USB storage devices such as the USB Flash Drive line of devices manufactured by Twintech Industry, Inc. of Los Alamitos, Calif.</p>
<p id="p-0055" num="0064">Referring again to <figref idref="DRAWINGS">FIG. 1B</figref>, the computing device <b>100</b> may support any suitable installation device <b>116</b>, such as a floppy disk drive for receiving floppy disks such as 3.5-inch, 5.25-inch disks or ZIP disks, a CD-ROM drive, a CD-R/RW drive, a DVD-ROM drive, tape drives of various formats, USB device, hard-drive or any other device suitable for installing software and programs. The computing device <b>100</b> may further comprise a storage device, such as one or more hard disk drives or redundant arrays of independent disks, for storing an operating system and other related software, and for storing application software programs such as any program related to the client agent <b>120</b>. Optionally, any of the installation devices <b>116</b> could also be used as the storage device. Additionally, the operating system and the software can be run from a bootable medium, for example, a bootable CD, such as KNOPPIX, a bootable CD for GNU/Linux that is available as a GNU/Linux distribution from knoppix.net.</p>
<p id="p-0056" num="0065">Furthermore, the computing device <b>100</b> may include a network interface <b>118</b> to interface to the network <b>104</b> through a variety of connections including, but not limited to, standard telephone lines, LAN or WAN links (e.g., 802.11, T1, T3, 56 kb, X.25, SNA, DECNET), broadband connections (e.g., ISDN, Frame Relay, ATM, Gigabit Ethernet, Ethernet-over-SONET), wireless connections, or some combination of any or all of the above. Connections can be established using a variety of communication protocols (e.g., TCP/IP, IPX, SPX, NetBIOS, Ethernet, ARCNET, SONET, SDH, Fiber Distributed Data Interface (FDDI), RS232, IEEE 802.11, IEEE 802.11a, IEEE 802.11b, IEEE 802.11g, CDMA, GSM, WiMax and direct asynchronous connections). In one embodiment, the computing device <b>100</b> communicates with other computing devices <b>100</b>&#x2032; via any type and/or form of gateway or tunneling protocol such as Secure Socket Layer (SSL) or Transport Layer Security (TLS), or the Citrix Gateway Protocol manufactured by Citrix Systems, Inc. of Ft. Lauderdale, Fla. The network interface <b>118</b> may comprise a built-in network adapter, network interface card, PCMCIA network card, card bus network adapter, wireless network adapter, USB network adapter, modem or any other device suitable for interfacing the computing device <b>100</b> to any type of network capable of communication and performing the operations described herein.</p>
<p id="p-0057" num="0066">In some embodiments, the computing device <b>100</b> may comprise or be connected to multiple display devices <b>124</b><i>a</i>-<b>124</b><i>n</i>, which each may be of the same or different type and/or form. As such, any of the I/O devices <b>130</b><i>a</i>-<b>130</b><i>n </i>and/or the I/O controller <b>123</b> may comprise any type and/or form of suitable hardware, software, or combination of hardware and software to support, enable or provide for the connection and use of multiple display devices <b>124</b><i>a</i>-<b>124</b><i>n </i>by the computing device <b>100</b>. For example, the computing device <b>100</b> may include any type and/or form of video adapter, video card, driver, and/or library to interface, communicate, connect or otherwise use the display devices <b>124</b><i>a</i>-<b>124</b><i>n</i>. In one embodiment, a video adapter may comprise multiple connectors to interface to multiple display devices <b>124</b><i>a</i>-<b>124</b><i>n</i>. In other embodiments, the computing device <b>100</b> may include multiple video adapters, with each video adapter connected to one or more of the display devices <b>124</b><i>a</i>-<b>124</b><i>n</i>. In some embodiments, any portion of the operating system of the computing device <b>100</b> may be configured for using multiple displays <b>124</b><i>a</i>-<b>124</b><i>n</i>. In other embodiments, one or more of the display devices <b>124</b><i>a</i>-<b>124</b><i>n </i>may be provided by one or more other computing devices, such as computing devices <b>100</b><i>a </i>and <b>100</b><i>b </i>connected to the computing device <b>100</b>, for example, via a network. These embodiments may include any type of software designed and constructed to use another computer's display device as a second display device <b>124</b><i>a </i>for the computing device <b>100</b>. One ordinarily skilled in the art will recognize and appreciate the various ways and embodiments that a computing device <b>100</b> may be configured to have multiple display devices <b>124</b><i>a</i>-<b>124</b><i>n. </i></p>
<p id="p-0058" num="0067">In further embodiments, an I/O device <b>130</b> may be a bridge between the system bus <b>150</b> and an external communication bus, such as a USB bus, an Apple Desktop Bus, an RS-232 serial connection, a SCSI bus, a FireWire bus, a FireWire <b>800</b> bus, an Ethernet bus, an AppleTalk bus, a Gigabit Ethernet bus, an Asynchronous Transfer Mode bus, a HIPPI bus, a Super HIPPI bus, a SerialPlus bus, a SCI/LAMP bus, a FibreChannel bus, or a Serial Attached small computer system interface bus.</p>
<p id="p-0059" num="0068">A computing device <b>100</b> of the sort depicted in <figref idref="DRAWINGS">FIGS. 1B and 1C</figref> typically operates under the control of operating systems, which control scheduling of tasks and access to system resources. The computing device <b>100</b> can be running any operating system such as any of the versions of the MICROSOFT WINDOWS operating systems, the different releases of the Unix and Linux operating systems, any version of the MAC OS for Macintosh computers, any embedded operating system, any real-time operating system, any open source operating system, any proprietary operating system, any operating systems for mobile computing devices, or any other operating system capable of running on the computing device and performing the operations described herein. Typical operating systems include, but are not limited to: WINDOWS 3.x, WINDOWS 95, WINDOWS 98, WINDOWS 2000, WINDOWS NT 3.51, WINDOWS NT 4.0, WINDOWS 7, WINDOWS CE, WINDOWS XP, and WINDOWS VISTA, all of which are manufactured by Microsoft Corporation of Redmond, Wash.; MAC OS, manufactured by Apple Inc., of Cupertino, Calif.; OS/2, manufactured by International Business Machines of Armonk, N.Y.; and Linux, a freely-available operating system distributed by Caldera Corp. of Salt Lake City, Utah, or any type and/or form of a Unix operating system, among others.</p>
<p id="p-0060" num="0069">The computing device <b>100</b> can be any workstation, desktop computer, laptop or notebook computer, server, handheld computer, mobile telephone or other portable telecommunication device, media playing device, a gaming system, mobile computing device, or any other type and/or form of computing, telecommunications or media device that is capable of communication and that has sufficient processor power and memory capacity to perform the operations described herein. For example, the computing device <b>100</b> may comprise a device of the IPOD family of devices manufactured by Apple Inc., of Cupertino, Calif., a PLAYSTATION 2, PLAYSTATION 3, or PERSONAL PLAYSTATION PORTABLE (PSP) device manufactured by the Sony Corporation of Tokyo, Japan, a NINTENDO DS, NINTENDO GAMEBOY, NINTENDO GAMEBOY ADVANCED or NINTENDO REVOLUTION device manufactured by Nintendo Co., Ltd., of Kyoto, Japan, or an XBOX or XBOX 360 device manufactured by the Microsoft Corporation of Redmond, Wash.</p>
<p id="p-0061" num="0070">In some embodiments, the computing device <b>100</b> may have different processors, operating systems, and input devices consistent with the device. For example, in one embodiment, the computing device <b>100</b> is a TREO 180, 270, 600, 650, 680, 700p, 700w/wx, 750, 755p, 800w, Centro, or Pro smart phone manufactured by Palm, Inc. In some of these embodiments, the TREO smart phone is operated under the control of the PalmOS operating system and includes a stylus input device as well as a five-way navigator device.</p>
<p id="p-0062" num="0071">In other embodiments the computing device <b>100</b> is a mobile device, such as a JAVA-enabled cellular telephone or personal digital assistant (PDA), such as the i55sr, i58sr, i85s, i88s, i90c, i95c1, i335, i365, i570, 1576, i580, i615, i760, i836, i850, i870, i880, i920, i930, ic502, ic602, ic902, i776 or the im1100, all of which are manufactured by Motorola Corp. of Schaumburg, Ill., the 6035 or the 7135, manufactured by Kyocera of Kyoto, Japan, or the i300 or i330, manufactured by Samsung Electronics Co., Ltd., of Seoul, Korea. In some embodiments, the computing device <b>100</b> is a mobile device manufactured by Nokia of Finland, or by Sony Ericsson Mobile Communications AB of Lund, Sweden.</p>
<p id="p-0063" num="0072">In still other embodiments, the computing device <b>100</b> is a Blackberry handheld or smart phone, such as the devices manufactured by Research In Motion Limited, including the Blackberry 7100 series, 8700 series, 7700 series, 7200 series, the Blackberry 7520, the Blackberry PEARL 8100, the 8700 series, the 8800 series, the Blackberry Storm, Blackberry Bold, Blackberry Curve 8900, and the Blackberry Pearl Flip. In yet other embodiments, the computing device <b>100</b> is a smart phone, Pocket PC, Pocket PC Phone, or other handheld mobile device supporting Microsoft Windows Mobile Software. Moreover, the computing device <b>100</b> can be any workstation, desktop computer, laptop or notebook computer, server, handheld computer, mobile telephone, any other computer, or other form of computing or telecommunications device that is capable of communication and that has sufficient processor power and memory capacity to perform the operations described herein.</p>
<p id="p-0064" num="0073">In some embodiments, the computing device <b>100</b> is a digital audio player. In one of these embodiments, the computing device <b>100</b> is a digital audio player such as the Apple IPOD, IPOD Touch, IPOD NANO, and IPOD SHUFFLE lines of devices, manufactured by Apple Inc., of Cupertino, Calif. In another of these embodiments, the digital audio player may function as both a portable media player and as a mass storage device. In other embodiments, the computing device <b>100</b> is a digital audio player such as the DigitalAudioPlayer Select MP3 players, manufactured by Samsung Electronics America, of Ridgefield Park, N.J., or the Motorola m500 or m25 Digital Audio Players, manufactured by Motorola Inc. of Schaumburg, Ill. In still other embodiments, the computing device <b>100</b> is a portable media player, such as the Zen Vision W, the Zen Vision series, the Zen Portable Media Center devices, or the Digital MP3 line of MP3 players, manufactured by Creative Technologies Ltd. In yet other embodiments, the computing device <b>100</b> is a portable media player or digital audio player supporting file formats including, but not limited to, MP3, WAV, M4A/AAC, WMA Protected AAC, RIFF, Audible audiobook, Apple Lossless audio file formats and .mov, .m4v, and .mp4MPEG-4 (H.264/MPEG-4 AVC) video file formats.</p>
<p id="p-0065" num="0074">In some embodiments, the computing device <b>100</b> comprises a combination of devices, such as a mobile phone combined with a digital audio player or portable media player. In one of these embodiments, the computing device <b>100</b> is a Motorola RAZR or Motorola ROKR line of combination digital audio players and mobile phones. In another of these embodiments, the computing device <b>100</b> is a device in the iPhone line of smartphones, manufactured by Apple Inc., of Cupertino, Calif.</p>
<p id="p-0066" num="0075">In one embodiment, a computing device <b>102</b><i>a </i>may request resources from a remote machine <b>106</b>, while providing the functionality of a remote machine <b>106</b> to a client <b>102</b><i>b</i>. In such an embodiment, the computing device <b>102</b><i>a </i>may be referred to as a client with respect to data received from the remote machine <b>106</b> (which may be referred to as a server) and the computing device <b>102</b><i>a </i>may be referred to as a server with respect to the second client <b>102</b><i>b</i>. In another embodiment, the client <b>102</b> may request resources from the remote machine <b>106</b> on behalf of a user of the client <b>102</b>.</p>
<p id="p-0067" num="0076">As shown in <figref idref="DRAWINGS">FIG. 1D</figref>, the computing device <b>100</b> may comprise multiple processors and may provide functionality for simultaneous execution of instructions or for simultaneous execution of one instruction on more than one piece of data. In some embodiments, the computing device <b>100</b> may comprise a parallel processor with one or more cores. In one of these embodiments, the computing device <b>100</b> is a shared memory parallel device, with multiple processors and/or multiple processor cores, accessing all available memory as a single global address space. In another of these embodiments, the computing device <b>100</b> is a distributed memory parallel device with multiple processors each accessing local memory only. In still another of these embodiments, the computing device <b>100</b> has both some memory which is shared and some memory which can only be accessed by particular processors or subsets of processors. In still even another of these embodiments, the computing device <b>100</b>, such as a multicore microprocessor, combines two or more independent processors into a single package, often a single integrated circuit (IC). In yet another of these embodiments, the computing device <b>100</b> includes a chip having a CELL BROADBAND ENGINE architecture and including a Power processor element and a plurality of synergistic processing elements, the Power processor element and the plurality of synergistic processing elements linked together by an internal high speed bus, which may be referred to as an element interconnect bus.</p>
<p id="p-0068" num="0077">In some embodiments, the processors provide functionality for execution of a single instruction simultaneously on multiple pieces of data (SIMD). In other embodiments, the processors provide functionality for execution of multiple instructions simultaneously on multiple pieces of data (MIMD). In still other embodiments, the processor may use any combination of SIMD and MIMD cores in a single device.</p>
<p id="p-0069" num="0078">In some embodiments, the computing device <b>100</b> may comprise a graphics processing unit. In one of these embodiments, depicted in <figref idref="DRAWINGS">FIG. 1E</figref>, the computing device <b>100</b> includes at least one central processing unit <b>121</b> and at least one graphics processing unit. In another of these embodiments, the computing device <b>100</b> includes at least one parallel processing unit and at least one graphics processing unit. In still another of these embodiments, the computing device <b>100</b> includes a plurality of processing units of any type, one of the plurality of processing units comprising a graphics processing unit.</p>
<p id="p-0070" num="0079">In one embodiment, a resource may be a program, an application, a document, a file, a plurality of applications, a plurality of files, an executable program file, a desktop environment, a computing environment, or other resource made available to a user of the local computing device <b>102</b>. The resource may be delivered to the local computing device <b>102</b> via a plurality of access methods including, but not limited to, conventional installation directly on the local computing device <b>102</b>, delivery to the local computing device <b>102</b> via a method for application streaming, delivery to the local computing device <b>102</b> of output data generated by an execution of the resource on a third computing device <b>106</b><i>b </i>and communicated to the local computing device <b>102</b> via a presentation layer protocol, delivery to the local computing device <b>102</b> of output data generated by an execution of the resource via a virtual machine executing on a remote computing device <b>106</b>, or execution from a removable storage device connected to the local computing device <b>102</b>, such as a USB device, or via a virtual machine executing on the local computing device <b>102</b> and generating output data. In some embodiments, the local computing device <b>102</b> transmits output data generated by the execution of the resource to another client computing device <b>102</b><i>b. </i></p>
<p id="p-0071" num="0080">In some embodiments, a user of a local computing device <b>102</b> connects to a remote computing device <b>106</b> and views a display on the local computing device <b>102</b> of a local version of a remote desktop environment, comprising a plurality of data objects, generated on the remote computing device <b>106</b>. In one of these embodiments, at least one resource is provided to the user by the remote computing device <b>106</b> (or by a second remote computing device <b>106</b><i>b</i>) and displayed in the remote desktop environment. However, there may be resources that the user executes on the local computing device <b>102</b>, either by choice, or due to a policy or technological requirement. In another of these embodiments, the user of the local computing device <b>102</b> would prefer an integrated desktop environment providing access to all of the resources available to the user, instead of separate desktop environments for resources provided by separate machines. For example, a user may find navigating between multiple graphical displays confusing and difficult to use productively. Or, a user may wish to use the data generated by one application provided by one machine in conjunction with another resource provided by a different machine. In still another of these embodiments, requests for execution of a resource, windowing moves, application minimize/maximize, resizing windows, and termination of executing resources may be controlled by interacting with a remote desktop environment that integrates the display of the remote resources and of the local resources. In yet another of these embodiments, an application or other resource accessible via an integrated desktop environment&#x2014;including those resources executed on the local computing device <b>102</b> and those executed on the remote computing device <b>106</b>&#x2014;is shown in a single desktop environment.</p>
<p id="p-0072" num="0081">In one embodiment, data objects from a remote computing device <b>106</b> are integrated into a desktop environment generated by the local computing device <b>102</b>. In another embodiment, the remote computing device <b>106</b> maintains the integrated desktop. In still another embodiment, the local computing device <b>102</b> maintains the integrated desktop.</p>
<p id="p-0073" num="0082">In some embodiments, a single remote desktop environment <b>204</b> is displayed. In one of these embodiments, the remote desktop environment <b>204</b> is displayed as a full-screen desktop. In other embodiments, a plurality of remote desktop environments <b>204</b> is displayed. In one of these embodiments, one or more of the remote desktop environments are displayed in non-full-screen mode on one or more display devices <b>124</b>. In another of these embodiments, the remote desktop environments are displayed in full-screen mode on individual display devices. In still another of these embodiments, one or more of the remote desktop environments are displayed in full-screen mode on one or more display devices <b>124</b>.</p>
<p id="h-0007" num="0000">B. Systems Including Virtualization Environments</p>
<p id="p-0074" num="0083">Illustrated in <figref idref="DRAWINGS">FIG. 2A</figref> is one embodiment of a virtualization environment. Included on a computing device <b>201</b> is a hardware layer that can include one or more physical disks <b>204</b>, one or more physical devices <b>206</b>, one or more physical processors <b>208</b> and a physical memory <b>216</b>. In some embodiments, firmware <b>212</b> can be stored within a memory element in the physical memory <b>216</b> and can be executed by one or more of the physical processors <b>208</b>. The computing device <b>201</b> can further include an operating system <b>214</b> that can be stored in a memory element in the physical memory <b>216</b> and executed by one or more of the physical processors <b>208</b>. Still further, a hypervisor <b>202</b> can be stored in a memory element in the physical memory <b>216</b> and can be executed by one or more of the physical processors <b>208</b>. Executing on one or more of the physical processors <b>208</b> can be one or more virtual machines <b>232</b>A-C (generally <b>232</b>). Each virtual machine <b>232</b> can have a virtual disk <b>226</b>A-C and a virtual processor <b>228</b>A-C. In some embodiments, a first virtual machine <b>232</b>A can execute, on a virtual processor <b>228</b>A, a control program <b>220</b> that includes a tools stack <b>224</b>. In other embodiments, one or more virtual machines <b>232</b>B-C can executed, on a virtual processor <b>228</b>B-C, a guest operating system <b>230</b>A-B.</p>
<p id="p-0075" num="0084">Further referring to <figref idref="DRAWINGS">FIG. 2A</figref>, and in more detail, in one embodiment the virtualization environment described includes a Type 2 hypervisor <b>202</b>, or a hypervisor that executes within an operating system <b>214</b> executing on the computing device <b>201</b>. A Type 2 hypervisor, in some embodiments, executes within an operating system <b>214</b> environment and virtual machines execute at a level above the hypervisor. In many embodiments, the Type 2 hypervisor executes within the context of a user's operating system such that the Type 2 hypervisor interacts with the user's operating system.</p>
<p id="p-0076" num="0085">In some embodiments, the virtualization environment includes a computing device <b>201</b>. The computing device <b>201</b> can be any computing device, and in some embodiments the computing device <b>201</b> can be any computer, device or computing machine described herein. While <figref idref="DRAWINGS">FIG. 2A</figref> illustrates a single computing device <b>201</b>, in some embodiments the modules, programs, virtual machines, and commands stored and executed by the computing device <b>201</b> can be executed by more than one computing device <b>201</b>. In still other embodiments, the computing device <b>201</b> can be a server farm.</p>
<p id="p-0077" num="0086">In one embodiment, the computing device <b>201</b> can include a hardware layer <b>210</b> that includes one or more pieces of hardware that communicates with the computing machine <b>201</b>. In some embodiments, the hardware layer <b>210</b> can include any hardware included in the computing device <b>201</b>. In other embodiments, the hardware layer <b>210</b> can include one or more physical disks <b>204</b>, one or more physical devices <b>206</b>, one or more physical processors <b>208</b> and memory <b>216</b>.</p>
<p id="p-0078" num="0087">The hardware layer <b>210</b>, in some embodiments, can include one or more physical disks <b>204</b>. A physical disk <b>204</b> can be any hard disk, while in some embodiments a physical disk <b>204</b> can be any hard disk described herein. In some embodiments, the hardware layer <b>210</b> can include one physical disk <b>204</b>. In other embodiments, the hardware layer <b>210</b> can include more than one physical disk <b>204</b>. The computing device <b>201</b>, in some embodiments, can communicate with an external hard disk that is included in the hardware layer <b>210</b> as a physical disk <b>204</b>.</p>
<p id="p-0079" num="0088">In other embodiments, the hardware layer <b>210</b> can include a processor <b>208</b>. The processor <b>208</b>, in some embodiments, can be any processor, while in other embodiments the processor <b>208</b> can be any processor described herein. The processor <b>208</b> can include one or more processing cores. In other embodiments the computing device <b>201</b> can include one or more processors <b>208</b>. In some embodiments, the computing device <b>201</b> can include one or more different processors, e.g. a processing unit, a graphics processing unit, or a physics engine.</p>
<p id="p-0080" num="0089">Physical devices <b>206</b>, in some embodiments, can be any device included in the computing device <b>201</b>. In some embodiments, physical devices <b>206</b> can be any combination of devices included in the computing device <b>201</b> and external devices that communicate with the computing device <b>201</b>. The computing device <b>201</b>, in some embodiments, can include one or more physical devices <b>206</b>. A physical device <b>206</b> can be any of the following: a network interface card; a video card; a keyboard; a mouse; an input device; a monitor; a display device; speakers; an optical drive; a storage device; a universal serial bus connection; any device connected to the computing device <b>201</b>; any device communicating with the computing device <b>201</b>; a printer; a scanner; or any other device or device described herein. In various other figures provided herein, a physical device <b>206</b> may be shown external to computing device <b>201</b>, for clarity and without limitation or implication of distinction between internal and external devices.</p>
<p id="p-0081" num="0090">The hardware layer <b>210</b> can further include physical memory <b>216</b> that can include any type of memory. In some embodiments, the physical memory <b>216</b> can include any memory type described herein. The physical memory <b>216</b> can store data, and in some embodiments can store one or more programs, or set of executable instructions. <figref idref="DRAWINGS">FIG. 2A</figref> illustrates one embodiment where firmware <b>212</b> is stored within the physical memory <b>216</b> of the computing device <b>201</b>. Programs or executable instructions stored in the physical memory <b>216</b> can be executed by the one or more processors <b>208</b> of the computing device <b>201</b>.</p>
<p id="p-0082" num="0091">Firmware <b>212</b>, in some embodiments, can be any combination of executable instructions and hardware that controls hardware communicating with or included within the computing device <b>201</b>. In some embodiments, the firmware <b>212</b> can control one or more pieces of hardware within the hardware layer <b>210</b>. Firmware <b>212</b>, in many embodiments, can be executed by one or more processors <b>208</b> within the computing device <b>201</b>. In some embodiments, the firmware <b>212</b> can be boot firmware such as the basic input/output system (BIOS.) Additional firmware <b>212</b> executing on the computing device <b>201</b> can interface with the BIOS.</p>
<p id="p-0083" num="0092">In one embodiment, the computing device <b>201</b> can include an operating system <b>214</b> executed by one or more physical processors <b>208</b>. In some embodiments, the operating system <b>214</b> is a user operating system that can directly access the hardware devices in the hardware layer <b>210</b>. The operating system <b>214</b> can be any operating system and in some embodiments, the operating system <b>214</b> can be any operating system described herein. <figref idref="DRAWINGS">FIG. 2A</figref> illustrates one embodiment where the hypervisor <b>202</b> executes within the context of the operating system <b>214</b> executing on the computing device <b>201</b>. In this embodiment, the operating system <b>214</b> can be referred to as a host operating system <b>214</b>, while the other operating systems can be referred to as guest operating systems. Guest operating systems can include the guest operating systems <b>230</b>A-B executing on the virtual machines <b>232</b>, and/or the control program <b>220</b>.</p>
<p id="p-0084" num="0093">In some embodiments, the computing device <b>201</b> can include a hypervisor <b>202</b>. A hypervisor <b>202</b>, in some embodiments, can be a program that executed by processors <b>208</b> on the computing device <b>201</b> to manage any number of virtual machines. The hypervisor <b>202</b> can be referred to as a virtual machine monitor, or platform virtualization software. In some embodiments, a hypervisor <b>202</b> can be any combination of executable instructions and hardware that monitors virtual machines executing on a computing machine. While <figref idref="DRAWINGS">FIG. 2A</figref> illustrates a virtualization environment that includes a Type 2 hypervisor <b>202</b>, the computing device <b>201</b> can execute any other type of hypervisor. For example, the computing device <b>201</b> can execute a virtualization environment that includes a Type 1 hypervisor <b>202</b>. In some embodiments, the computing device <b>201</b> can execute one or more hypervisors <b>202</b>. These one or more hypervisors <b>202</b> can be the same type of hypervisor, or in other embodiments can be different hypervisor types.</p>
<p id="p-0085" num="0094">The hypervisor <b>202</b>, in some embodiments, can provide virtual resources to operating systems <b>230</b> or control programs <b>220</b> executing on virtual machines <b>232</b> in any manner that simulates the operating systems <b>230</b> or control programs <b>220</b> having direct access to system resources. System resources can include: physical devices; physical disks; physical processors; physical memory <b>216</b> and any other component included in the computing device <b>201</b> hardware layer <b>210</b>. In these embodiments, the hypervisor <b>202</b> may be used to emulate virtual hardware, partition physical hardware, virtualize physical hardware, or execute virtual machines that provide access to computing environments. In still other embodiments, the hypervisor <b>202</b> controls processor scheduling and memory partitioning for a virtual machine <b>232</b> executing on the computing device <b>201</b>. Hypervisor <b>202</b> may include those manufactured by VMWare, Inc., of Palo Alto, Calif.; the XEN hypervisor, an open source product whose development is overseen by the open source Xen.org community; HyperV, VirtualServer or virtual PC hypervisors provided by Microsoft, or others. In some embodiments, a computing device <b>201</b> executes a hypervisor <b>202</b> that creates a virtual machine platform on which guest operating systems may execute. In these embodiments, the computing device <b>201</b> can be referred to as a host server. An example of such a computing device is the XEN SERVER provided by Citrix Systems, Inc., of Fort Lauderdale, Fla.</p>
<p id="p-0086" num="0095">In one embodiment, the hypervisor <b>202</b> can create a virtual machine <b>232</b>A-B (generally <b>232</b>) in which an operating system <b>230</b> executes. In one of these embodiments, for example, the hypervisor <b>202</b> loads a virtual machine image to create a virtual machine <b>232</b>. In another of these embodiments, the hypervisor <b>202</b> executes an operating system <b>230</b> within the virtual machine <b>232</b>. In still another of these embodiments, the virtual machine <b>232</b> executes an operating system <b>230</b>.</p>
<p id="p-0087" num="0096">In one embodiment, the hypervisor <b>202</b> controls the execution of at least one virtual machine <b>232</b>. In another embodiment, the hypervisor <b>202</b> presents at least one virtual machine <b>232</b> with an abstraction of at least one hardware resource provided by the computing device <b>201</b>. The abstraction can further be referred to as a virtualization or virtual view of the hardware, memory processor and other system resources available on the computing device <b>201</b>. Hardware or hardware resources, in some embodiments, can be any hardware resource available within the hardware layer <b>210</b>. In other embodiments, the hypervisor <b>202</b> controls the manner in which virtual machines <b>232</b> access the physical processors <b>208</b> available in the computing device <b>201</b>. Controlling access to the physical processors <b>208</b> can include determining whether a virtual machine <b>232</b> should have access to a processor <b>208</b>, and how physical processor capabilities are presented to the virtual machine <b>232</b>.</p>
<p id="p-0088" num="0097">In some embodiments, the computing device <b>201</b> can host or execute one or more virtual machines <b>232</b>. A virtual machine <b>232</b> can be called a domain, a guest and/or a DOMAIN U or domU. A virtual machine <b>232</b> is a set of executable instructions that, when executed by a processor <b>208</b>, imitate the operation of a physical computer such that the virtual machine <b>232</b> can execute programs and processes much like a physical computing device. While <figref idref="DRAWINGS">FIG. 2A</figref> illustrates an embodiment where a computing device <b>201</b> hosts three virtual machines <b>232</b>, in other embodiments the computing device <b>201</b> can host any number of virtual machines <b>232</b>. The hypervisor <b>202</b>, in some embodiments, provides each virtual machine <b>232</b> with a unique virtual view of the physical hardware, memory, processor and other system resources available to that virtual machine <b>232</b>. In some embodiments, the unique virtual view can be based on any of the following: virtual machine permissions; application of a policy engine to one or more virtual machine identifiers; the user accessing a virtual machine; the applications executing on a virtual machine; networks accessed by a virtual machine; or any other similar criteria. The hypervisor <b>202</b>, in other embodiments, provides each virtual machine <b>232</b> with a substantially similar virtual view of the physical hardware, memory, processor and other system resources available to the virtual machines <b>232</b>.</p>
<p id="p-0089" num="0098">Each virtual machine <b>232</b> can include a virtual disk <b>226</b>A-C (generally <b>226</b>) and a virtual processor <b>228</b>A-C (generally <b>228</b>.) The virtual disk <b>226</b>, in some embodiments, is a virtualized view of one or more physical disks <b>204</b> of the computing device <b>201</b>, or a portion of one or more physical disks <b>204</b> of the computing device <b>201</b>. The virtualized view of the physical disks <b>204</b> can be generated, provided and managed by the hypervisor <b>202</b>. In some embodiments, the hypervisor <b>202</b> provides each virtual machine <b>232</b> with a unique view of the physical disks <b>204</b>. Thus, in these embodiments, the virtual disk <b>226</b> included in each virtual machine <b>232</b> can be unique when compared with the other virtual disks <b>226</b>.</p>
<p id="p-0090" num="0099">A virtual processor <b>228</b> can be a virtualized view of one or more physical processors <b>208</b> of the computing device <b>201</b>. In some embodiments, the virtualized view of the physical processors <b>208</b> can be generated, provided and managed by the hypervisor <b>202</b>. In some embodiments, the virtual processor <b>228</b> has substantially all of the same characteristics of at least one physical processor <b>208</b>. In other embodiments, the virtual processor <b>208</b> provides a modified view of the physical processors <b>208</b> such that at least some of the characteristics of the virtual processor <b>228</b> are different than the characteristics of the corresponding physical processor <b>208</b>.</p>
<p id="p-0091" num="0100">A control program <b>220</b> may execute at least one application for managing and configuring the guest operating systems executing on the virtual machines <b>232</b> and in some embodiments the computing device <b>201</b>. In some embodiments, the control program <b>220</b> can be called a control operating system, a control domain, domain 0 or dom0. The control program <b>220</b>, in some embodiments, can be DOMAIN 0 or DOM0 of the XEN hypervisor. Thus, in some embodiments, control program <b>220</b> may be executed within a control virtual machine or dom0 virtual machine, may be executed by the hypervisor, or may be executed by an operating system executing the hypervisor. The control program <b>220</b> can execute an administrative application or program that can further display a user interface which administrators can use to access the functionality of each virtual machine <b>232</b> and/or to manage the virtual machines <b>232</b>. In some embodiments, the user interface generated by the administrative program can be used to terminate the execution of virtual machines <b>232</b>, allocate resources to virtual machines <b>232</b>, assign permissions to virtual machines <b>232</b>, or manage security credentials associated with virtual machines <b>232</b>. The control program <b>220</b>, in some embodiments, can start new virtual machines <b>232</b> or terminate execution of executing virtual machines <b>232</b>. In other embodiments, the control program <b>220</b> can directly access hardware and/or resources within the hardware layer <b>210</b>. In still another embodiment, the control program <b>220</b> can interface with programs and applications executing on the computing device <b>210</b> and outside of the context of a virtual machine <b>232</b>. Similarly, the control program <b>220</b> can interface with programs and applications executing within the context of a virtual machine <b>232</b>.</p>
<p id="p-0092" num="0101">In one embodiment, the hypervisor <b>202</b> can execute the control program <b>220</b> within a virtual machine <b>232</b>. The hypervisor <b>202</b> can create and start the virtual machine <b>232</b>. In embodiments where the hypervisor <b>202</b> executes the control program <b>220</b> within a virtual machine <b>232</b>, that virtual machine <b>232</b> can be referred to as the control virtual machine <b>232</b>. In still another embodiment, the control program <b>220</b> executes within a virtual machine <b>232</b> that is authorized to directly access physical resources on the computing device <b>201</b>.</p>
<p id="p-0093" num="0102">In some embodiments, a control program <b>220</b>A (Not Shown) on a first computing device <b>201</b>A (Not Shown) may exchange data with a control program <b>220</b>B (Not Shown) on a second computing device <b>201</b>B (Not Shown). In these embodiments the first computing device <b>201</b>A may be located remote from the second computing device <b>201</b>B. The control programs <b>220</b>A-B can exchange data via a communication link between a hypervisor <b>202</b>A (Not Shown) executing on the first computing device <b>201</b>A and a hypervisor <b>202</b>B (Not Shown) executing on the second computing device <b>201</b>B. Through this communication link, the computing devices <b>201</b>A-B can exchange data regarding processors and other physical resources available in a pool of resources. Further, through this connection between hypervisors <b>202</b>A-B, the hypervisors <b>202</b>A-B can manage a pool of resources, e.g. the resources available on the first computing device <b>201</b>A and the second computing device <b>201</b>B, distributed across one or more computing devices <b>201</b>A-B. The hypervisors <b>202</b>A-B can further virtualize these resources and make them available to virtual machines <b>232</b> executing on the computing devices <b>201</b>A-B. In another instance of this embodiment, a single hypervisor <b>202</b> can manage and control virtual machines <b>232</b> executing on both computing devices <b>201</b>A-B.</p>
<p id="p-0094" num="0103">In some embodiments, the control program <b>220</b> interacts with one or more guest operating systems <b>230</b>A-B (generally <b>230</b>.) The control program <b>220</b> can communicate with the guest operating systems <b>230</b> through a hypervisor <b>202</b>. Through the hypervisor <b>202</b>, the guest operating system <b>230</b> can request access to physical disks <b>204</b>, physical processors <b>208</b>, memory <b>216</b>, physical devices <b>206</b> and any other component in the hardware layer <b>210</b>. In still other embodiments, the guest operating systems <b>230</b> can communicate with the control program <b>220</b> via a communication channel established by the hypervisor <b>202</b>, such as, for example, via a plurality of shared memory pages made available by the hypervisor <b>202</b>.</p>
<p id="p-0095" num="0104">In some embodiments, the control program <b>220</b> includes a network back-end driver for communicating directly with networking hardware provided by the computing device <b>201</b>. In one of these embodiments, the network back-end driver processes at least one virtual machine request from at least one guest operating system <b>230</b>. In other embodiments, the control program <b>220</b> includes a block back-end driver for communicating with a storage element on the computing device <b>201</b>. In one of these embodiments, the block back-end driver reads and writes data from the storage element based upon at least one request received from a guest operating system <b>230</b>.</p>
<p id="p-0096" num="0105">In another embodiment, the control program <b>220</b> includes a tools stack <b>224</b>. In another embodiment, a tools stack <b>224</b> provides functionality for interacting with the hypervisor <b>202</b>, communicating with other control programs <b>220</b> (for example, on a second computing device <b>201</b>B), or managing virtual machines <b>232</b> on the computing device <b>201</b>. In another embodiment, the tools stack <b>224</b> includes customized applications for providing improved management functionality to an administrator of a virtual machine farm. In some embodiments, at least one of the tools stack <b>224</b> and the control program <b>220</b> include a management API that provides an interface for remotely configuring and controlling virtual machines <b>232</b> running on a computing device <b>201</b>. In other embodiments, the control program <b>220</b> communicates with the hypervisor <b>202</b> through the tools stack <b>224</b>.</p>
<p id="p-0097" num="0106">In one embodiment, the hypervisor <b>202</b> executes a guest operating system <b>230</b> within a virtual machine <b>232</b> created by the hypervisor <b>202</b>. In another embodiment, the guest operating system <b>230</b> provides a user of the computing device <b>201</b> with access to resources within a computing environment. In still another embodiment, a resource includes a program, an application, a document, a file, a plurality of applications, a plurality of files, an executable program file, a desktop environment, a computing environment, or other resource made available to a user of the computing device <b>201</b>. In yet another embodiment, the resource may be delivered to the computing device <b>201</b> via a plurality of access methods including, but not limited to, conventional installation directly on the computing device <b>201</b>, delivery to the computing device <b>201</b> via a method for application streaming, delivery to the computing device <b>201</b> of output data generated by an execution of the resource on a second computing device <b>201</b>&#x2032; and communicated to the computing device <b>201</b> via a presentation layer protocol, delivery to the computing device <b>201</b> of output data generated by an execution of the resource via a virtual machine executing on a second computing device <b>201</b>&#x2032;, or execution from a removable storage device connected to the computing device <b>201</b>, such as a USB device, or via a virtual machine executing on the computing device <b>201</b> and generating output data. In some embodiments, the computing device <b>201</b> transmits output data generated by the execution of the resource to another computing device <b>201</b>&#x2032;.</p>
<p id="p-0098" num="0107">In one embodiment, the guest operating system <b>230</b>, in conjunction with the virtual machine on which it executes, forms a fully-virtualized virtual machine that is not aware that it is a virtual machine; such a machine may be referred to as a &#x201c;Domain U HVM (Hardware Virtual Machine) virtual machine&#x201d;. In another embodiment, a fully-virtualized machine includes software emulating a Basic Input/Output System (BIOS) in order to execute an operating system within the fully-virtualized machine. In still another embodiment, a fully-virtualized machine may include a driver that provides functionality by communicating with the hypervisor <b>202</b>. In such an embodiment, the driver is typically aware that it executes within a virtualized environment.</p>
<p id="p-0099" num="0108">In another embodiment, the guest operating system <b>230</b>, in conjunction with the virtual machine on which it executes, forms a paravirtualized virtual machine, which is aware that it is a virtual machine; such a machine may be referred to as a &#x201c;Domain U PV virtual machine&#x201d;. In another embodiment, a paravirtualized machine includes additional drivers that a fully-virtualized machine does not include. In still another embodiment, the paravirtualized machine includes the network back-end driver and the block back-end driver included in a control program <b>220</b>, as described above.</p>
<p id="p-0100" num="0109">Illustrated in <figref idref="DRAWINGS">FIG. 2B</figref> is another embodiment of a virtualization environment that illustrates a Type 1 hypervisor <b>202</b>. Executing on the computing device <b>201</b> is a hypervisor <b>202</b> that can directly access the hardware and resources within the hardware layer <b>210</b>. Virtual machines <b>232</b> managed by the hypervisor <b>202</b> can be a non-trusted virtual machine <b>232</b>B and/or a trusted virtual machine <b>232</b>C. Whereas the virtualization environment depicted in <figref idref="DRAWINGS">FIG. 2A</figref> illustrates a host operating system <b>214</b>, the virtualization environment embodiment in <figref idref="DRAWINGS">FIG. 2B</figref> does not execute a host operating system.</p>
<p id="p-0101" num="0110">Further referring to <figref idref="DRAWINGS">FIG. 2B</figref>, and in more detail, the virtualization environment includes a Type 1 hypervisor <b>202</b>. Type 1 hypervisors <b>202</b>, in some embodiments, execute on &#x201c;bare metal,&#x201d; such that the hypervisor <b>202</b> has direct access to all applications and processes executing on the computing device <b>201</b>, all resources on the computing device <b>201</b> and all hardware on the computing device <b>201</b> or communicating with the computing device <b>201</b>. While a Type 2 hypervisor <b>202</b> accesses system resources through a host operating system <b>214</b>, a Type 1 hypervisor <b>202</b> can directly access all system resources. The Type 1 hypervisor <b>202</b> can execute directly on one or more physical processors of the computing device <b>201</b>, and can include program data stored in the physical memory <b>216</b>.</p>
<p id="p-0102" num="0111">In a virtualization environment that employs a Type 1 hypervisor <b>202</b> configuration, the host operating system can be executed by one or more virtual machines <b>232</b>. Thus, a user of the computing device <b>201</b> can designate one or more virtual machines <b>232</b> as the user's personal machine. This virtual machine can imitate the host operating system by allowing a user to interact with the computing device <b>201</b> in substantially the same manner that the user would interact with the computing device <b>201</b> via a host operating system <b>214</b>. In some embodiments, a first virtual machine may be referred to as a control virtual machine <b>232</b>A. Control virtual machine <b>232</b>A may, in some embodiments, execute control program <b>220</b> and may provide capabilities for launching and managing one or more other virtual machines <b>232</b>. Thus, in many embodiments, a control virtual machine <b>232</b>A may be considered part of domain 0 or a host domain.</p>
<p id="p-0103" num="0112">Virtual machines <b>232</b> can be non-trusted virtual machines <b>232</b>B and trusted virtual machines <b>232</b>C. A trusted virtual machine, sometimes referred to as a secure virtual machine, is a virtual machine that is launched responsive to a user providing authentication credentials. In one embodiment, the trusted virtual machine is an encrypted image on disk that boots when the user provides authentication credentials. Authentication credentials may comprise a user name, real name, login name, account name, password, serial number, encryption key, or any other item of information identifying the user. In many embodiments, the trusted virtual machine may be booted responsive to verifying the authentication credentials against an authorized database of users. The database may be hosted by another virtual machine, by a host virtual machine, by the hypervisor, or by another computing device. For example, in one such embodiment, a user may provide authentication credentials to a control program <b>220</b> to initiate booting of a trusted virtual machine, and the control program <b>220</b> may establish a network communication with a remote computing device and transmit the authentication credentials to the remote computing device. The remote computing device may verify the credentials and respond with an indication of whether the user is authorized to boot the trusted virtual machine. In many embodiments, whether a virtual machine is considered trusted may be equivalent to whether the user booting the virtual machine has permission from a security component to boot the machine.</p>
<p id="p-0104" num="0113">In some embodiments, a trusted virtual machine may be considered to be a secure virtual machine, and accordingly these terms may be used interchangeably. In some embodiments, whether a virtual machine is a secure virtual machine can be determined based on a comparison of the virtual machine to other virtual machines executing within the same virtualization environment. For example, were a first virtual machine to have access to a pool of resources, and a second virtual machine not to have access to the same pool of resources; the second virtual machine could be considered a non-trusted virtual machine <b>232</b>B while the first virtual machine could be considered a trusted virtual machine <b>232</b>A. In some embodiments, a virtual machine's <b>323</b> ability to access one or more system resources can be configured using a configuration interface generated by either the control program <b>220</b> or the hypervisor <b>202</b>. In other embodiments, the level of access afforded to a virtual machine <b>232</b> can be the result of a review of any of the following sets of criteria: the user accessing the virtual machine; one or more applications executing on the virtual machine; the virtual machine identifier; a risk level assigned to the virtual machine based on one or more factors; or any other similar criteria. For example, in one embodiment, a virtual machine may be considered secure or trusted if the virtual machine's disk image is encrypted or is a read-only image; if an operating system of the virtual machine includes an anti-virus program or an active firewall; or any other criteria.</p>
<p id="p-0105" num="0114">In some embodiments, unsecure or non-trusted virtual machines <b>232</b>B may be prevented from accessing resources, hardware, memory locations, and programs that secure virtual machines <b>232</b>A may access. For example, a trusted virtual machine <b>232</b>C may be able to access one or more company resources, while the non-trusted virtual machine <b>232</b>B cannot access any company resources.</p>
<p id="h-0008" num="0000">C. Communication Between Trusted and Non-Trusted Virtual Machines</p>
<p id="p-0106" num="0115">In many embodiments, a computing device may host a plurality of virtual machines, including trusted and non-trusted virtual machines. For example, a user may simultaneously use a non-trusted virtual machine for playback of personal music files, while using a trusted virtual machine for accessing a corporate network. Such functions may be separated to keep the corporate network secure, while still allowing users the freedom to operate personal devices and applications. While such isolation may be desirable from a security standpoint, in many embodiments, the non-trusted and trust virtual machines may need to communicate. For example, if a user has a first application with a first window open in a first virtual machine, and a second application with a second window in a second virtual machine, the user may expect only one window to have focus, receive mouse and keyboard input, or be foremost in a z-order at any one time. Accordingly, the two virtual machines may need to communicate such focus management.</p>
<p id="p-0107" num="0116">Communication between a secure, company-specific virtual machine and an unsecure, personal virtual machine can be difficult. Solutions exist that establish communications between secure and unsecure virtual machines via traditional network connections. These solutions can pose security risks to the virtual machines because virtual machines often need to be isolated on different network segments.</p>
<p id="p-0108" num="0117">Communication between trusted and non-trusted virtual machines may, in some embodiments, be referred to as virtual-to-virtual or V2V technology. This mechanism may provide systems for inter-domain communication between both privileged and non-privileged domains running under a hypervisor. In one embodiment, the mechanism includes providing an API (Application Programmers Interface) that can be used in both kernel and user modes. The API can be present in any operating system running as a domain under the hypervisor, including Windows and Linux, or any other operating system.</p>
<p id="p-0109" num="0118">In one embodiment, the V2V API allows two domains or virtual machines to establish a channel of communication. In brief overview, one end of the channel starts as a listening endpoint. The other end can then connect to the listening endpoint. Once the channel is established, the two domains can send messages back and forth on the channel. When either end is finished communicating, it can disconnect the channel and free the associated resources.</p>
<p id="p-0110" num="0119">In some embodiments, the message passing part of the API can be a low level program that permits any block of data to be sent and received. In some embodiments, V2V provides no transport layer semantics or higher layer functionalities. Thus, in many embodiments and unlike using network interfaces for communicating between virtual machines, messages need not be encapsulated with addresses or other headers. In other embodiments, other protocols can be built on top of the V2V API to provide higher level services.</p>
<p id="p-0111" num="0120">In some embodiments, underlying event channel and shared memory architecture can be used between front end and back end para-virtual driver pairs. V2V, in some embodiments, establishes an API over these driver pairs to make them generic and reusable. V2V is unique in that it provides a means of communication between domains that is based on the underlying hypervisor functionality. In particular V2V uses the Xen facilities to share memory pages between domains and the functionality to allow domains to send events to other domains via interrupts.</p>
<p id="p-0112" num="0121">Thus, in some embodiments, these systems and methods permit communication that does not require traditional network connections between domains for communication. Such traditional network connections can pose security risks to domains (e.g. when domains need to be isolated on different network segments). V2V usage, security and access control can also be controlled by components in the control program, or the control program tool stack, discussed above. Although discussed herein primarily in terms of communication between virtual machines with different security or privilege levels, these systems and methods may be used for communications between two non-trusted virtual machines, two trusted virtual machines, a dom0 or control virtual machine and a trusted or non-trusted domU virtual machine, or any other combination of virtual machines.</p>
<p id="p-0113" num="0122">Referring briefly now to <figref idref="DRAWINGS">FIG. 3A</figref>, illustrated is a block diagram of an embodiment of a system for communication between trusted and non-trusted virtual machines. In addition to features discussed above in connection with <figref idref="DRAWINGS">FIGS. 2A and 2B</figref>, a computing device <b>201</b> may include a non-trusted virtual machine <b>232</b>B, a trusted virtual machine <b>232</b>C. The computing device <b>201</b> may also include a third virtual machine <b>232</b>D. Physical memory <b>216</b> may include a region of memory <b>300</b> that is reserved by the trusted virtual machine <b>232</b>C, discussed in more detail below. In some embodiments, one or more virtual machines may execute a communication agent (not shown) which may comprise a program, application, service, daemon, sub-routine, logic, or other executable instructions for establishing and communicating via a secure channel.</p>
<p id="p-0114" num="0123">Referring now to <figref idref="DRAWINGS">FIG. 3B</figref>, illustrated is a flow diagram of one embodiment of a method for establishing a secure communication channel between a non-trusted virtual machine and a trusted virtual machine. In brief overview, a first virtual machine such as a trusted virtual machine, or a communication agent executed by the first virtual machine, may establish itself as a listening endpoint by, at step <b>320</b> selecting a region of memory <b>300</b> to monitor. At step <b>322</b>, a second virtual machine such as a non-trusted virtual machine may write a data string to the selected region. At step <b>324</b>, the trusted virtual machine may detect the data string in the selected region. At step <b>326</b>, the trusted virtual machine may be lock the memory region to exclude a third virtual machine or others from reading or writing to the memory region, while allowing the trusted virtual machine and non-trusted virtual machine to read and write to the memory region. At step <b>328</b>, the trusted virtual machine may send an interrupt to the non-trusted virtual machine. At step <b>330</b>, the non-trusted virtual machine may write data to the region, or as the communication proceeds, may also read data from the region. At step <b>332</b>, the non-trusted virtual machine may send an interrupt to the trusted virtual machine. At step <b>334</b>, the trusted virtual machine may read from and/or write data to the region. Steps <b>328</b>-<b>334</b> may be repeated until communication is complete. At step <b>336</b>, the trusted virtual machine may unlock the memory region, allowing a third virtual machine access to the memory region.</p>
<p id="p-0115" num="0124">Still referring to <figref idref="DRAWINGS">FIG. 3B</figref> and in more detail, in one embodiment a virtual machine establishes itself as a communications endpoint by selecting a region of memory to monitor. In some embodiments, the virtual machine can be a secure or trusted virtual machine, while in other embodiments the virtual machine can be an unsecure or non-trusted virtual machine. In one embodiment, the virtual machine can establish itself as a listening endpoint. In other embodiments, the virtual machine can establish itself as a transmitting endpoint. In still other embodiments, the virtual machine can establish itself as a communication endpoint able to send or receive data over the communication channel.</p>
<p id="p-0116" num="0125">In one embodiment, the virtual machine can establish itself as a listening endpoint in response to a request from another virtual machine to transfer data to the virtual machine. In some embodiments, at step <b>320</b>, a virtual machine establishes itself as a listening endpoint by selecting a group of memory addresses, one or more memory pages, or another portion of the physical memory <b>216</b> as a common storage region <b>300</b> for both the listening virtual machine and the transmitting virtual machine. In other embodiments, a virtual machine can establish itself as a listening endpoint via a communication agent executing within the virtual machine. The communication agent, in response to an indicator, can select one or more memory locations and tag them or otherwise partition them as memory to be exclusively used by the virtual machine and any transmitting endpoint that connects with the virtual machine. In some embodiments, the virtual machine may periodically monitor the memory region for new data, or may receive an interrupt when new data is written to the memory region.</p>
<p id="p-0117" num="0126">Another virtual machine, in some embodiments at step <b>322</b>, connects to the listening endpoint of the initial virtual machine to create a communication channel. In some embodiments, the virtual machine establishes itself as a transmitting endpoint when it connects to the listening endpoint of the initial virtual machine. In one embodiment, the transmitting endpoint can connect to the listening endpoint by writing a predetermined string of data to the memory region selected by the listening endpoint. Such predetermined string may comprise an identifier of the transmitting endpoint or virtual machine wishing to establish itself as the transmitting endpoint, to allow the listening endpoint to exclude others from the communication channel. This data may be detected by the listening endpoint at step <b>324</b>. In another embodiment in which other, non-secure communications paths exist, the transmitting endpoint may use one of these communications paths to send a message to the listening endpointing, indicating it wishes to establish a secure communication channel with the listening endpoint. In some embodiments, a communication agent on the transmitting endpoint transmits a message to a communication agent on the listening endpoint indicating that the transmitting endpoint would like to communicate with the listening endpoint. The message transmitted to the listening endpoint, in some embodiments, is an interrupt that can be received by the listening endpoint virtual machine and processed.</p>
<p id="p-0118" num="0127">In some embodiments at step <b>326</b>, upon receiving a notification that a transmitting endpoint would like to communicate with the listening endpoint, the communication agent on that virtual machine will tag the reserved memory so that it can be accessed only by the listening endpoint and the transmitting endpoint. The communication channel established between the listening endpoint and the transmitting endpoint can include the shared memory pages or memory addresses accessible only by the listening endpoint and the transmitting endpoint. In other embodiments, the communication channel can include a secure communication connection between the transmitting endpoint and the listening endpoint. In further embodiments, this secure communication channel can include encoding, encrypting or otherwise encapsulating data such that only the listening endpoint can decode, decrypt or otherwise un-encapsulate the transmitted data.</p>
<p id="p-0119" num="0128">Upon creating the communication channel between the listening endpoint and the transmitting endpoint, in some embodiments at step <b>328</b>, the listening endpoint may send an interrupt to the transmitting endpoint to indicate that the communication channel is established and ready for secure transfer of data.</p>
<p id="p-0120" num="0129">At step <b>330</b>, the transmitting endpoint can copy data to the shared memory page. Upon copying data to the shared memory page, the transmitting endpoint virtual machine can issue an interrupt, at step <b>332</b>, to the listening virtual machine to indicate that data was copied into the shared memory. In some embodiments, this interrupt can be issued by a communication agent. In other embodiments, this interrupt can be issued by a physical device or network card.</p>
<p id="p-0121" num="0130">The listening endpoint, upon determining that data was copied to the shared memory page, can retrieve the copied data from the shared memory page at step <b>334</b>. Determining that data was copied to the shared memory page can include receiving the interrupt issued by the transmitting virtual machine, and the retrieval may be performed responsive to receipt of the interrupt.</p>
<p id="p-0122" num="0131">The method may, in some embodiments, include a transmission virtual machine that issues an interrupt to the listening virtual machine when data is copied to the shared memory page, and when the transmitting virtual machine runs out of space to send more data. In some embodiments, the listening virtual machine receives the interrupt and responds by either retrieving data or allocating additional memory addresses or pages to the shared memory repository. Upon allocating additional memory to the shared memory repository, the listening virtual machine can issue an interrupt to the transmitting virtual machine that additional memory was added to the shared memory repository. In some embodiments, the listening virtual machine can respond to the interrupt regarding limited memory by clearing data from the shared memory pages to free up space.</p>
<p id="p-0123" num="0132">In some embodiments, steps <b>328</b>-<b>334</b> may be repeated for the duration of the communication, with either endpoint writing data to the shared memory region and reading data written by the other endpoint. Upon completion of the communication transaction or session, at step <b>336</b>, in some embodiments, the listening endpoint may unlock the memory region such that a third virtual machine may access the memory region. In other embodiments, the transmitting endpoint may unlock the memory region. In many embodiments, prior to unlocking the memory region, the endpoint may first wipe the memory region or write null or random data to the region to remove any sensitive information.</p>
<p id="p-0124" num="0133">Through the above discussed method, data of various sizes and content may be transmitted between the trusted and non-trusted virtual machines without other virtual machines being able to intercept or otherwise read the communication, yet without necessarily requiring encryption or encapsulation.</p>
<p id="h-0009" num="0000">D. Managing Injection of Input Data into a Virtualization Environment</p>
<p id="p-0125" num="0134">In many embodiments, the security of a secure virtual machine can be compromised by keylogging attacks which, in some instances, include software or devices that can capture the actions of an input device. For example, such software can capture the keys of a keyboard that are actuated by a user. Within the context of a virtualization environment that includes both trusted and non-trusted virtual machines, the input data entered into a trusted virtual machine can be compromised were an application within the non-trusted virtual machine able to monitor and log input into the trusted virtual machines. Few if any solutions exist that reduce the risk posed to trusted virtual machines by the possibility that a non-trusted virtual machine could log the keyboard input into the trusted virtual machine. Absent any solutions, this risk could significantly diminish the security of a trusted virtual machine within a virtualization environment, and could in some cases result in the leak of sensitive corporate information.</p>
<p id="p-0126" num="0135">In one aspect, a method for preventing such keylogging attacks includes managing the injection of input data into a virtualization environment. An input manager, including a switcher, receives input events and data. Such input events and data may comprise those generated by a keyboard and/or a mouse. The input manager may determine whether to input those events into an active virtual machine. In some embodiments, the input manager executes within the context of a control program executing on a computing device connected to the input devices. The input manager may receive an input event and/or input data and determine whether an application window having focus is a window belonging to a trusted virtual machine or a window belonging to a non-trusted virtual machine. In some embodiments, the input manager further determines whether the input data corresponds to a secure key combination or an otherwise predetermined key combination.</p>
<p id="p-0127" num="0136">When windows belonging to the trusted virtual machine receive focus, the switcher of the input manager is notified. Thus, the input manager is substantially always informed as to whether a trusted window has focus. In embodiments where a trusted virtual machine window has focus and the input data corresponds to a predetermined key combination (e.g. ctrl+alt, ctrl+backspace, etc.), the input manager can inject the event into a non-trusted virtual machine. In embodiments where the trusted virtual machine window does not have focus, substantially all input events and/or data may be injected into the non-trusted virtual machine window. In still other embodiments where the input data corresponds to a secure key or input combination, the input manager can intercept the input data, input at least a portion of the data into a secure key box, and map the keyboard into the trusted virtual machine.</p>
<p id="p-0128" num="0137">In some embodiments, the control program can cause an LED or other visual indicator to flash when the user is operating within the context of a trusted virtual machine. In these embodiments, the control program knows when the user is operating within the context of a trusted virtual machine because the switch of the input manager is notified each time a trusted window receives focus or loses focus.</p>
<p id="p-0129" num="0138">Referring briefly to <figref idref="DRAWINGS">FIG. 4A</figref>, illustrated is a block diagram of an embodiment of a system for managing injection of input data into a virtualization environment. In addition to features discussed above in connection with <figref idref="DRAWINGS">FIGS. 2A and 2B</figref>, a computing device <b>201</b> may comprise an input manager <b>400</b>. Input manager <b>400</b> may be executed by a control or host virtual machine <b>232</b>A, or may be an input manager <b>400</b>&#x2032; executed by a hypervisor or an operating system executing a hypervisor. Accordingly, input manager <b>400</b> or <b>400</b>&#x2032; (referred to generally as input manager <b>400</b>) may be an application, program, service, daemon, logic, or other executable code executing in a trusted domain or dom0 for managing injection of input data into a virtualization environment.</p>
<p id="p-0130" num="0139">A computing device <b>201</b> may also include or connect to one or more input devices <b>402</b>. An input device <b>402</b> may comprise a keyboard, mouse, touchpad, drawing tablet, joystick, gamepad, control panel, switch panel, biometric sensor, or any other type and form of input device. In some embodiments, an input device <b>402</b> may include an output device capable of presenting an indicator to a user. For example, an input device <b>402</b> comprising a keyboard may include one or more LEDs <b>410</b>. Such output device <b>410</b> may be capable of control by the software to blink, flash, light up, beep, inflate, vibrate, or otherwise present a visual, auditory or tactile indicator to a user to indicate that a trusted virtual machine currently is receiving input data <b>408</b> from input device <b>402</b> as opposed to a non-trusted virtual machine. Input data <b>408</b> may comprise any type and form of input from the input device <b>402</b>, such as an alphanumeric string of data, a key combination, a click, a key acuation, an analog or digital value, or any other input. In many embodiments in which input device <b>402</b> is a keyboard, input data <b>408</b> may comprise a data string of one or more keys pressed sequentially or simultaneously. In some embodiments, the input data <b>408</b> may comprise a predetermined data string. The predetermined data string may, in one embodiment, include a key combination commonly used by an operating system, such as alt+tab, control+backspace, or any other similar combination. In another embodiment, the predetermined data string may include a predetermined control string. This control string may be used to trigger creation and focusing of a secure input box generated by a domain0 entity such as the hypervisor or control virtual machine.</p>
<p id="p-0131" num="0140">A computing device <b>201</b> may include a plurality of virtual machines <b>232</b>, including a non-trusted virtual machine <b>232</b>B and a trusted virtual machine <b>232</b>C. The virtual machines may each execute an application <b>404</b><i>a </i>and <b>404</b><i>b </i>(referred to generally as application <b>404</b>) and each application, respectively, may generate one or more windows <b>406</b><i>a </i>and <b>406</b><i>b </i>(referred to generally as window <b>406</b>). A window <b>406</b> may have focus, or be currently selected to receive input. In such cases, the window may be referred to as having focus. Similarly, the application <b>404</b> that generated the window may be referred to as having focus. Likewise, the trusted or non-trusted virtual machine executing the application may be referred to as having focus.</p>
<p id="p-0132" num="0141">Referring now to <figref idref="DRAWINGS">FIG. 4B</figref>, illustrated is a flow chart of one embodiment of a method <b>420</b> for managing injection of input data into a virtualization environment. In brief overview, at step <b>422</b>, an input manager may receive a first item of input data. The input data may comprise a single item of data, or may comprise a data string or combination of data, such as a key combination. At step <b>424</b>, the input manager may determine if the input data includes a predetermined string. As discussed above, multiple strings of data may be predetermined, such as a control string to trigger creation of a secure key input box, and an operating system-used command to switch between a plurality of active applications. Thus, at step <b>426</b> in such embodiments, if the input data includes a predetermined string, the input manager may determine if the string is the control string. If so, at step <b>430</b>, the control string may be forwarded to the control program, or the input device may be mapped to the control program such that the control program receives future input data.</p>
<p id="p-0133" num="0142">If the input data includes a predetermined string but it is not the control string, then at step <b>428</b>, the input manager may determine if a window generated by an application executing on a trusted virtual machine has focus. If not, at step <b>432</b>, the input data may be forwarded to the trusted virtual machine, window, or application, or the input device may be mapped to the trusted virtual machine such that the trusted virtual machine receives future input data. The window of the trusted virtual machine may also be given focus. If, at step <b>428</b>, a window of the trusted virtual machine does have focus, then at step <b>434</b>, the input data may be forwarded to a non-trusted virtual machine, window, or application, or the input device may be mapped to the non-trusted virtual machine such that the non-trusted virtual machine receives future input data. A window of the non-trusted virtual machine may also be given focus.</p>
<p id="p-0134" num="0143">If, at step <b>424</b>, the input manager determines that the input data does not include a predetermined string, then at step <b>428</b>&#x2032;, the input manager may determine if a window generated by an application executing on a trusted virtual machine has focus. If so, at step <b>432</b>, the input data may be forwarded to the trusted virtual machine, window, or application, or the input device may be mapped to the trusted virtual machine such that the trusted virtual machine receives future input data. The window of the trusted virtual machine may also be given focus. If, at step <b>428</b>&#x2032;, a window of the trusted virtual machine does not have focus, then at step <b>434</b>, the input data may be forwarded to a non-trusted virtual machine, window, or application, or the input device may be mapped to the non-trusted virtual machine such that the non-trusted virtual machine receives future input data. A window of the non-trusted virtual machine may also be given focus.</p>
<p id="p-0135" num="0144">Thus, in the embodiment of the method <b>420</b> illustrated in <figref idref="DRAWINGS">FIG. 4B</figref>, two triggers are utilized to determine whether the trusted virtual machine receives the input data. First, if the input data does not include a predetermined string, then the input data will be passed to either the trusted or non-trusted virtual machine, depending on which has focus. This allows a user to, for example, continue typing in an application window. However, if the input data does include a predetermined string, then the input may be forwarded or the input device may be remapped to the other virtual machine, i.e. the one that does not currently have focus. This allows the user to use a switcher key combination, for example, to switch input to a trusted and secure virtual machine. This behavior is summarized in the table shown in <figref idref="DRAWINGS">FIG. 4C</figref>.</p>
<p id="p-0136" num="0145">Additionally, if the input data includes a predetermined control string, then the input data may be forwarded or the input device remapped to a control program. This allows the user to press a special key combination to enter, for example, a management console separate from both the trusted virtual machine and non-trusted virtual machine and hosted by a dom0 entity such as the hypervisor or a control virtual machine. In still another further embodiment, the control string may be used to allow a user to switch from a non-trusted virtual machine to a trusted virtual machine. To ensure the virtual machine remains trusted, the control string may cause the dom0 entity to create an authentication window. The user may input a password or other authentication credentials, which the dom0 entity may verify. Once the user has been authenticated, the input manager may map the input device to the trusted virtual machine. Thus, the control string may be used for a password-protected virtual machine focus switcher.</p>
<p id="p-0137" num="0146">Still referring to <figref idref="DRAWINGS">FIG. 4B</figref> and in more detail, in one embodiment the input manager can receive input data from an input device at step <b>422</b>. The input device, in some embodiments, can be any input device. In other embodiments, the input device can be a keyboard and/or a mouse. Input data, in some embodiments, can be received by a driver executing on the computing device <b>201</b> within the hardware layer <b>210</b>. Upon receiving the input data, in one embodiment, the driver can forward a formatted version of the input data to the control program <b>220</b> executing on the computing device <b>201</b>. The input manager, in some embodiments, executes within the control program <b>220</b> such that when the control program receives the input data, the input manager also receives the input data.</p>
<p id="p-0138" num="0147">In some embodiments, at step <b>424</b>, the input manager can determine whether the input data contains one or more predetermined sequences or data strings. When the input data is generated by a keyboard, the one or more predetermined sequences can include one or more keystrokes. For example, a predetermined sequence can include: CTRL+ALT; CTRL+DELETE; CTRL+BACKSPACE; CTRL+ALT+BACKSPACE. In some embodiments, the predetermined sequence can correspond to an operating-system-specific key combination. When such a combination is received, the input manager can forward the keyboard combination to a non-trusted virtual machine executing on the computing device <b>201</b>. In some embodiments, the predetermined sequence can correspond to a secure key combination. When such a combination is received, the input manager can responsively map the keyboard into a trusted virtual machine.</p>
<p id="p-0139" num="0148">The input manager, in some embodiments, can determine whether a trusted virtual machine has focus. When a trusted virtual machine receives focus, the change focus event can be forwarded to the input manager so that the input manager knows substantially all the time whether the secure virtual machine window has focus. In some embodiments, the control program <b>220</b> can cause a LED or other visual, auditory, or tactile indicator to light up, turn on, or otherwise activate when the trusted virtual machine window has focus. The input manager, when the trusted virtual machine does not have focus, can inject all input data and events into the non-trusted virtual machine. In other embodiments, the input manager can inject all input data and events into the trusted virtual machine when the trusted virtual machine has focus. In still other embodiments, when the keyboard or input device is mapped into the trusted virtual machine, the input manager can ensure that all alphanumeric key presses are inserted into the trusted virtual machine while all operating-system-specific key presses are inserted into the trusted virtual machine.</p>
<p id="p-0140" num="0149">In one embodiment, the input manager can input the input data (e.g. key presses, etc.) into a trusted virtual machine or a non-trusted virtual machine based on which type of virtual machine (e.g. trusted or non-trusted) has focus, and whether the input contains a predetermined sequence.</p>
<p id="p-0141" num="0150">Thus, in many embodiments, the method <b>420</b> may determine where key events are directed from the physical device. In an example of one such embodiment, a user may press a key on the keyboard or move the mouse. The event may be received at the driver level by a control program executed by a dom0 entity. In one embodiment, the event may be forwarded to or received by the input manager. In some embodiments, the input manager may comprise a dynamic translator, such as QEMU, created by Fabrice Bellard. In a further embodiment, a dynamic translator may be provided for each virtual machine, trusted or non-trusted. If a window of the trusted virtual machine has focus, then the translator for the trusted virtual machine may allow the event to be injected into the trusted virtual machine. However, if the event is a special key combination, then the input event may be injected into a non-trusted virtual machine. If the window of the trusted virtual machine does not have focus, then the event may be injected into the non-trusted virtual machine. In one embodiment, however, if the event is a secure key combination, then the input manager may direct the key event to a secure key or password input box generated by a dom0 entity, as discussed above.</p>
<p id="p-0142" num="0151">In many embodiments, when the user clicks on a window to give the trusted window focus, the input switcher may be notified of the change. In a further embodiment, when the user clicks on another window, the input switcher may be notified that the trusted window has lost focus. In other embodiments, the input manager may periodically request an identification of a window with focus.</p>
<p id="h-0010" num="0000">E. Servicing Interrupts Generated Responsive to Actuation of Hardware Via Virtual Firmware</p>
<p id="p-0143" num="0152">Hardware devices, even relatively standard ones such as keyboards, may frequently include additional features such as media control buttons. Similarly, integrated systems like laptops may include additional keyboard keys, knobs, dials, buttons, or other features. To allow equipment manufacturers to provide these additional features, operating system manufacturers such as Microsoft have provided driver extensions to allow these devices to provide information and notification of components. For example, the Windows Management Instrumentation (WMI) is a set of extensions to the Windows Driver Model which an equipment manufacturer may use to provide information and event notification to the operating system. For example, an equipment manufacturer may provide firmware with tables that describe the added functionality and objects and methods used to control or interact with the functionality. For example, when a user presses a key on a keyboard, an interrupt is generated by the keyboard firmware that is normally captured by the Windows WMI layer, which then directs the operating system to retrieve the descriptive table to determine what the key is intended to trigger.</p>
<p id="p-0144" num="0153">However, virtualization environments present additional difficulties for manufacturers wishing to add these features. Because a hypervisor sits between virtual machines and the hardware layer, notifications may not be properly forwarded to one or more virtual machines. A hosted guest operating system may not be able to retrieve the table from the firmware provided by the manufacturer, or even know that it exists. Furthermore, the table cannot simply be retrieved and passed to the guest operating system without significantly modifying the operating system, because it normally expects only to receive objects and methods associated with an interrupt, when said interrupt is generated by the hardware device.</p>
<p id="p-0145" num="0154">In an embodiment of a system for servicing interrupts generated responsive to actuation of hardware, virtual firmware may be used to communicate requests back and forth between the device firmware and the hosted operating system or systems. A dom0 entity, such as a hypervisor or control virtual machine, has direct access to the hardware of the computing device. Accordingly, when the user presses a key and the firmware generates an interrupt, the dom0 entity can capture the interrupt. The dom0 entity may forward the interrupt to virtual firmware of the guest virtual machine, which may forward the interrupt to the guest operating system as if it was the original hardware device.</p>
<p id="p-0146" num="0155">The guest operating system, responsive to receiving the interrupt from the virtual firmware, may send a request to the virtual firmware for the objects and methods associated with the interrupt. The virtual firmware may forward the request to the dom0 entity, which may forward the request to the firmware of the hardware device.</p>
<p id="p-0147" num="0156">The firmware of the hardware device may retrieve the objects and methods associated with the interrupt from memory, such as an Advanced Configuration and Power Interface (ACPI) table, and forward these objects and methods to the dom0 entity. The dom0 entity may forward the objects and methods to the virtual firmware, which may respond to the request from the guest operating system, providing information on how to utilize the functionality of the hardware.</p>
<p id="p-0148" num="0157">Referring briefly now to <figref idref="DRAWINGS">FIG. 5A</figref>, illustrated is a block diagram of an embodiment of a system for servicing interrupts generated responsive to actuation of hardware via virtual firmware. In addition to features discussed above, a computing device <b>201</b> may connect to or communicate with an input device or devices <b>500</b>. In many embodiments, the input device <b>500</b> may be an input device <b>402</b> discussed above, or any other input device discussed herein. The input device <b>500</b> may communicate with the computing device <b>201</b> via a hardware driver able to receive raw data from the device and interpret the raw data into commands and data able to be interpreted by an operating machine or control program <b>220</b>.</p>
<p id="p-0149" num="0158">The computing device may include, retrieve or download firmware <b>502</b> from the input device <b>500</b> and/or may execute the firmware <b>502</b>. In some embodiments, In some embodiments, the firmware <b>212</b> executing on the computing device <b>201</b>, or more specifically on a processor <b>208</b> within the computing device <b>201</b>, can include an advanced configuration and power interface (ACPI) layer <b>504</b>A. An ACPI layer <b>504</b>A can be a layer that provides one or more methods, objects and other management specifications and configurations for devices within the computing device <b>201</b>. The ACPI layer <b>504</b>A can further include objects, methods and specifications for managing power within the computing device <b>201</b>. In some embodiments, the ACPI layer <b>504</b>A can have exclusive control over all aspects of power management within the computing device <b>201</b> and can also configure devices within the computing device <b>201</b>. The ACPI layer <b>504</b>A, in some embodiments, can include an ACPI specification that lists one or more operating states. These operating states can outline system configurations such as: which devices in the computing device <b>201</b> should receive power; how much power should be delivered to devices within the computing device <b>201</b>; whether to configure devices within the computing device <b>201</b> to terminate or start one or more services or processes; and other such configurations.</p>
<p id="p-0150" num="0159">In one embodiment, the ACPI layer <b>504</b>A can include a plurality of tables that include objects and methods for interfacing the firmware <b>502</b> with an operating system requesting information about a device or an interrupt generated by a device. For example, were a device connected to or included within the computing device <b>201</b> to generate an interrupt, an operating system, control program <b>220</b> or other program executing on the computing device <b>201</b> can query the ACPI layer <b>504</b>A tables for information about that device and therefore about the interrupt. This information can be scraped or obtained from the firmware <b>502</b>, and may include objects or methods associated with the device.</p>
<p id="p-0151" num="0160">In some embodiments, the firmware <b>502</b> can include objects and methods for each device included within the computing device <b>201</b>. For example, the firmware <b>502</b> can include an object for a keyboard that has a device ID specific to the keyboard. In this example, the keyboard object in the firmware <b>502</b> can also have methods that are specific to the keyboard. These methods can include functions and processes for receiving input from the keyboard, and functions and processes for sending commands to the keyboard. The ACPI layer <b>504</b>A, in some embodiments, permits operating systems, control programs and other applications and processes to access the keyboard object within the firmware <b>502</b> and to further access the keyboard methods within the firmware <b>502</b> by acting as an interface between the firmware <b>502</b> and the operating system or program.</p>
<p id="p-0152" num="0161">Just as the computing device <b>201</b> can include firmware <b>502</b>, so can the virtual machines <b>232</b> executing on the computing device <b>201</b>. In one embodiment, one or more virtual machines <b>232</b> executing on the computing device <b>201</b> may each include virtual firmware <b>503</b>. Virtual firmware <b>503</b> may be a virtualized view of firmware <b>502</b> that executes on the computing device <b>201</b>. In one embodiment, the control program <b>220</b> can generate virtual firmware <b>503</b> by analyzing the device objects within the firmware <b>502</b> on the computing device <b>201</b>, and listing them in a table within the virtual firmware <b>503</b>. The control program <b>220</b> can, in some embodiments, generate the virtual firmware <b>503</b> in response to a lifecycle event such as: startup of the control program <b>220</b>; startup of a virtual machine <b>232</b>; migration of a virtual machine <b>232</b>; power down of the control program <b>220</b>; power down of a virtual machine <b>232</b>; boot-up of the computing device <b>201</b>; or any other similar lifecycle event. The table included in the virtual firmware <b>503</b>, in some embodiments, is similar to the firmware <b>502</b> in that it lists each device managed by the firmware <b>502</b> as well as an identifier of the device.</p>
<p id="p-0153" num="0162">The virtual firmware <b>503</b> can, in some embodiments, include a virtual ACPI layer <b>504</b>B. In some embodiments, the virtual ACPI layer <b>504</b>B can function substantially similar to that of the computing device <b>201</b> ACPI layer <b>504</b>A in that the virtual ACPI layer <b>504</b>B can act as an interface between guest operating systems <b>230</b>, control programs <b>220</b> and other applications, and the virtual firmware <b>503</b> on a machine <b>232</b>.</p>
<p id="p-0154" num="0163">In still other embodiments, the guest operating systems <b>230</b>, control program <b>220</b> and other applications or services executing within the virtual machine(s) <b>232</b> can include a management interface <b>506</b>A-B (generally referred to as a management interface <b>506</b>). In some embodiments, the management interface <b>506</b> may be a windows management interface that interfaces directly with the ACPI layer within firmware to receive information about a device. In one embodiment, the management interface <b>506</b>B can interface directly with the virtual ACPI layer <b>504</b>B to obtain object information and methods associated with or assigned to a device within the firmware <b>502</b>. For example, the management interface <b>506</b>B can communicate with the virtual ACPI layer <b>504</b>B to obtain information about a keyboard interrupt generated when a user actuates a key on the keyboard.</p>
<p id="p-0155" num="0164">Referring now to <figref idref="DRAWINGS">FIG. 5B</figref>, illustrated is a flow diagram of a method for servicing interrupts generated responsive to actuation of hardware via virtual firmware. In one embodiment, firmware of a computing device <b>201</b>, which may be referred to as physical firmware as opposed to virtual firmware, may receive an interrupt from hardware at step <b>520</b> and forward the interrupt to a control program <b>220</b>. The control program <b>220</b> may then inject into or forward the interrupt to virtual firmware executing on a virtual machine <b>232</b>. Upon receipt of the interrupt, the virtual firmware may forward the interrupt to an operating system of the virtual machine.</p>
<p id="p-0156" num="0165">At step <b>522</b>, the operating system of the guest virtual machine may receive the interrupt from the virtual firmware. At step <b>524</b>, responsive to receiving the interrupt, the operating system may generate a request for objects and methods associated with the interrupt, and may transmit this request to the virtual firmware. The virtual firmware may forward the request to the control program, which may forward the request to the physical firmware.</p>
<p id="p-0157" num="0166">At step <b>526</b>, responsive to receiving the request, the physical firmware may extract objects and methods associated with the interrupt from an ACPI table. The physical firmware may transmit the extracted objects and methods to the control program, which may forward them to the virtual firmware. The virtual firmware may forward the objects and methods to the operating system of the guest virtual machine. At step <b>528</b>, the guest operating system may receive the requested objects and methods from the virtual firmware, allowing the guest operating system to properly interact with the hardware device.</p>
<p id="p-0158" num="0167">Further referring to <figref idref="DRAWINGS">FIG. 5B</figref>, and in more detail, in one embodiment the firmware of the computing device <b>201</b> may receive an interrupt at step <b>520</b> and forward the interrupt to the control program <b>220</b>. In some embodiments, the firmware of the computing device <b>201</b> facilitates the forwarding of the interrupt to the control program <b>220</b>. The interrupt, in some embodiments, can be generated in response to the actuation of a key on a keyboard or in response to some other input event. For example, the interrupt can be generated in response to: the actuation of a key on a keyboard; the turning of a dial on a keyboard; touching a touch pad on the keyboard; clicking a mouse button, moving a mouse, or any other input event.</p>
<p id="p-0159" num="0168">The control program <b>220</b>, upon receiving the interrupt, can inject the interrupt into the virtual firmware on the virtual machine. In some embodiments, injecting the interrupt into the virtual firmware may comprise providing the interrupt to the virtual firmware such that the virtual firmware can receive the interrupt in much the same manner that the firmware of the computing device <b>201</b> receives the interrupt. Thus, the virtual firmware can facilitate the forwarding of the interrupt to an operating system <b>230</b> executing within a virtual machine <b>232</b>.</p>
<p id="p-0160" num="0169">In some embodiments, the virtual firmware forwards the interrupt to an operating system <b>230</b> of the virtual machine <b>232</b>. Forwarding the interrupt to an operating system <b>230</b> of the virtual machine <b>232</b> can include forwarding the interrupt to a management interface of the virtual machine <b>232</b>. The management interface can execute according to a windows management interface specification, and can interface directly with an ACPI layer of the virtual firmware.</p>
<p id="p-0161" num="0170">At step <b>522</b>, in some embodiments, an operating system <b>230</b> of the virtual machine <b>232</b> may receive the interrupt from the virtual firmware. At step <b>524</b>, responsive to receiving the interrupt, the operating system may issue a request to the virtual firmware for objects and methods associated with the interrupt. The virtual firmware may in turn forward the operating system request to the control program <b>220</b>, which receives the request and issues the request to the firmware of the computing device <b>201</b>. In some embodiments, issuing the request to the firmware of the computing device <b>201</b> may include issuing a request for objects and methods associated with the interrupt to an ACPI layer of the firmware. In other embodiments, issuing a request to the virtual firmware may include issuing a request for objects and methods associated with the interrupt to an ACPI layer of the virtual firmware. In many embodiments, issuing a request for objects and methods can include issuing a request for objects and methods associated with the device that generated the interrupt. For example, the operating system <b>230</b> can request objects and methods associated with the keyboard and in some instances, the actuated key.</p>
<p id="p-0162" num="0171">At step <b>526</b>, responsive to receiving the request for objects and methods associated with the interrupt, an ACPI layer of the firmware of the computing device <b>201</b> may return to the requesting program (e.g. the control program <b>220</b>) objects and methods associated with the device generating the interrupt and/or the interrupt. The control program <b>220</b> can receive the associated objects and methods, and can forward these objects and methods to the virtual firmware of the virtual machine <b>232</b>. An ACPI layer of the virtual firmware can respond to the operating system's request by returning to a management interface of the operating system, the received objects and methods. At step <b>528</b>, a management interface of the operating system <b>230</b> may receive the objects and methods associated with the interrupt and process them.</p>
<p id="p-0163" num="0172">Thus, the operating system <b>230</b> may use the received objects and methods to interact with the virtual firmware as if it were the firmware of the input device, and the virtual firmware and control program together may form a communication chain for passing interrupts and requests from the operating system to the physical firmware.</p>
<p id="h-0011" num="0000">F. Allocating a Universal Serial Bus (USB) Device to a Trusted Virtual Machine or a Non-Trusted Virtual Machine</p>
<p id="p-0164" num="0173">As discussed above, in many embodiments of virtualization environments, a user may simultaneously use both a trusted virtual machine and a non-trusted virtual machine. The operating systems executing within the two virtual environments often do not communicate regarding low level functions such as receiving plug-and-play and other devices. Thus, there can be situations where a control program must determine which virtual environment receives access to a universal serial bus (USB) device connected to the computing device, such as a USB thumb drive, web camera, graphics interface, or other USB device. In many cases, this determination can include determining the level of access a virtualization environment can have to a USB device. Absent policies or other directions indicating which virtual machine receives access to the USB device, issues may arise when an application is writing data to a disk, or when an application needs to continuously read data from a disk in order to finish a transaction.</p>
<p id="p-0165" num="0174">Referring briefly now to <figref idref="DRAWINGS">FIG. 6A</figref>, illustrated is a block diagram of an embodiment of a system for allocating a USB device to a trusted virtual machine or a non-trusted virtual machine. USB devices are plug-and-play devices and thus may frequently include firmware and ACPI tables. Accordingly, the discussion above regarding servicing interrupts via virtual firmware should be considered in connection with this section as well, and each virtual machine may comprise virtual firmware and ACPI tables. A computing device <b>201</b> may connect to or communicate with a USB device <b>600</b> via a USB port <b>602</b>. The USB device may have one or more attributes <b>604</b>, such as a serial number, device type, presence of encryption, or other features.</p>
<p id="p-0166" num="0175">In some embodiments, a control program <b>220</b> may include or access a set of security policies <b>606</b> stored on the computing device <b>201</b> in a memory element or storage repository accessible to the control program <b>220</b>. In some embodiments, the security policies <b>606</b> can be stored in a database on the computing device <b>201</b>. The security policies <b>606</b>, in some embodiments, can be a set of policies used by the control program <b>220</b>, a policy engine of the control virtual machine <b>232</b>A or hypervisor <b>202</b>, or any other program to determine any of the following: whether a virtual machine <b>323</b> can access one or more memory elements, devices, processors or disks; whether a user can access one or more memory elements, devices, processors or disks; whether a device should be made available to one or more virtual machines <b>232</b>; whether one or more commands generated by an application executing within a virtual machine <b>232</b> should be forwarded to a device on the computing device <b>201</b>; and whether one or more requests generated by an application executing within a virtual machine <b>232</b> should be forwarded to a device on the computing device <b>201</b>.</p>
<p id="p-0167" num="0176">The policy engine may comprise an agent, service, program, application, routine, logic or other executable code for using the security policies <b>606</b> to determine whether one or more actions are permitted. In some embodiments, the policy engine can operate in lieu of other programs executing within the context of the control program <b>220</b>. In other embodiments, the policy engine can operate in conjunction with the other programs.</p>
<p id="p-0168" num="0177">Illustrated in <figref idref="DRAWINGS">FIG. 6B</figref> is a flow chart of an embodiment of a method <b>620</b> for assigning a USB device to at least one virtual machine. At step <b>622</b>, in some embodiments, a control program executing on a computing device within a virtualization environment may receive data that indicates a device was plugged into a USB port of the computing device. The control program may, at step <b>624</b>, identify one or more attributes of the device. In a further embodiment, the control program may identify a security level of the device, responsive to application of one or more security policies to the one or more identified attributes. At step <b>626</b>, the control program may select a virtual machine from a plurality of virtual machines, and at step <b>628</b> may grant the selected virtual machine access to the device or map the device to the selected virtual machine.</p>
<p id="p-0169" num="0178">Still referring to <figref idref="DRAWINGS">FIG. 6B</figref> and in more detail, in one embodiment at step <b>622</b>, the control program may receive data indicating that a device was plugged into a USB port of the computing device. Receiving data indicating that a device was plugged into a USB port, in some embodiments, can include receiving an interrupt generated responsive to device being plugged into the USB port. The interrupt can be serviced by firmware and forwarded to the control program as discussed above in connection with <figref idref="DRAWINGS">FIGS. 5A-5B</figref>. In other embodiments, the data can include a plug-and-play event notification generated by the control program or an operating system executing on the control virtual machine.</p>
<p id="p-0170" num="0179">In some embodiments, at step <b>624</b>, the control program may identify one or more attributes of the device. Identifying the device attributes may include querying the USB port for information about the device. This information may include any of the following: serial number; device identifier; device type; a device driver of the device; the presence of encrypted data on the device; or data on the device being locked or read-only. In some embodiments, the control program can query the USB port for information about the device. The USB port in turn can send the control program the device information within which the control program can identify relevant attributes of the device.</p>
<p id="p-0171" num="0180">In a further embodiment, the control program may identify a security level of the device. Identifying a security level of the device may include using a serial number of the device or a device type of the device to query security policies for a security level of the device. The security policies can indicate whether the device should be allowed to be passed into one or more virtual machines executing on the computing device <b>201</b>.</p>
<p id="p-0172" num="0181">Based on an identification of the device attributes and/or an identification of a security level of the device, the control program may determine which virtual machine should receive the device. Upon making this determination, at step <b>626</b>, the control program may select the determined virtual machine from amongst one or more virtual machines executing on the computing device. In some embodiments, the control program may reference a table that lists one or more device identifiers or device types and the virtual machines that can receive these devices. In other embodiments, the control program can by default pass the device to an active virtual machine. For example, if the applications in a virtual machine currently have focus or are currently executing, the control program can select that virtual machine by default.</p>
<p id="p-0173" num="0182">In some embodiments, the control program may grant the selected virtual machine access to the device and/or map the device to the selected virtual machine at step <b>628</b>. Granting access to the device can include passing the device to the selected virtual machine. In other embodiments, granting access to the device may include updating the selected virtual machine's virtualized view of available physical resources to include the device.</p>
<p id="p-0174" num="0183">One advantage of the above technique is that, because a virtual machine's access to the USB device is decided by a entity external to the virtual machine, namely control program <b>220</b>, security policies may be applied to the virtual machine's access at a level below the virtual hardware drivers. This may close off security holes while still allowing access to the USB device that ordinarily can only be resolved by disabling the USB device. For example, if a USB thumb drive has a rootkit hidden on it and set to execute automatically, ordinarily, granting access to the USB drive to a virtual machine would allow the rootkit to execute. While the operating system of the virtual machine may include defenses against such intrusion, these defenses usually operate at a software level above the USB driver, and accordingly may not be able to prevent all such attacks. Furthermore, because the defenses execute on the operating system that is the subject of the rootkit's attacks, the rootkit may be able to apply countermeasures to these defenses.</p>
<p id="p-0175" num="0184">Conversely, in the method and system described above, control program <b>220</b> is monitoring and controlling access to the USB drive while executing externally to the virtual machine and operating system accessing the USB drive, either on a control virtural machine or on the hypervisor. Thus, the operating system executing the control program <b>220</b> is not the subject of the rootkit's attacks and may be unaffected by the rootkit. Additionally, the control program <b>220</b> can control a virtual machine's access to the USB drive at the hardware level.</p>
<p id="p-0176" num="0185">Referring now to <figref idref="DRAWINGS">FIG. 6C</figref>, illustrated is a flow chart of one embodiment of a method <b>640</b> for controlling a virtual machine's access to a device communicating with a USB port. In brief overview, at step <b>642</b>, a control program <b>220</b> can intercept a read/write request issued to the device by a virtual machine having access to the device. For example, the virtual machine may have been granted access to the device using the method <b>620</b> discussed above. At step <b>644</b>, the control program <b>220</b> may determine whether the requested action is permitted and, at step <b>646</b>, may forward the read/write request to the device upon determining the requested action is permitted.</p>
<p id="p-0177" num="0186">Further referring to <figref idref="DRAWINGS">FIG. 6C</figref>, and in more detail, at step <b>642</b> in one embodiment the control program can intercept a read/write request issued to the device. In some embodiments, the read/write request can be generated by a guest operating system executing on the virtual machine. In other embodiments, the read/write request can be generated by an application executing on the virtual machine. The control program can intercept all read/write requests issued by the virtual machine to the device. In some embodiments, the control program can also intercept all commands issued to the device including ejection commands, print commands, etc.</p>
<p id="p-0178" num="0187">At step <b>644</b>, the control program can determine whether the requested action is permitted. This determination, in some embodiments, can be made by querying security policies. Using the device attributes and an identifier of the virtual machine, the control program can query the security policies to determine whether a requested action is permitted. For example, the control program may use the fact that the requesting virtual machine is a trusted virtual machine, the fact that the device is a storage device, and the fact that the requested action is a request to write data to the storage device to determine whether the write should be allowed. In this example, the security policies may indicate that trusted virtual machines should not be allowed to write data to external storage devices, to prevent theft of sensitive information.</p>
<p id="p-0179" num="0188">Based on this indication, the control program may determine that the requested action is not permitted. In some embodiments, the control program can return to the requesting application or virtual machine an error message indicating the requested action is not permitted. In other embodiments, the control program may determine that the requested action is permitted. Accordingly, at step <b>646</b>, the control program may forward the request to the USB device.</p>
<p id="h-0012" num="0000">G. Controlling Virtual Machine Access to an Optical Disc Drive</p>
<p id="p-0180" num="0189">Managing access for a plurality of virtual machines to USB devices such as thumb drives, where the device may be mapped to a single virtual machine at a time, or access to an internal hard drive where different partitions may be mapped to a single virtual machine at a time, may be relatively straightforward due to this one-to-one mapping, although, as discussed above, determining which virtual machine can access the device may be more complicated. A similar mapping has been used for controlling access to optical disc drives, where a user explicitly maps an optical drive to a virtual machine through a control program. If the user wishes to use a second virtual machine to read a CD, the user must explicitly map the optical drive to the second virtual machine, essentially &#x201c;installing&#x201d; the optical drive as a new device. This may add undesirable complexity, particularly when a user is switching back and forth between a plurality of virtual machines.</p>
<p id="p-0181" num="0190">It may be preferable in many instances to have a plurality of virtual machines each act as if they simultaneously have access to the optical disc drive, eliminating a requirement that the user manually switch access to the drive back and forth. One embodiment of a solution for granting a virtual machine exclusive access to an optical disc drive may performed in response to determining the virtual machine initiated a transaction with the optical disc drive. A drive manager executing on the computing device may obtain a transaction stream generated by an optical disc drive connected to the computing device. The drive manager may convert the transaction stream to a command stream. Based on an analysis of the command stream, the drive manager may determine which virtual machine of a plurality of virtual machines initiated a transaction with the optical disc drive. In response to this determination, the drive manager may lock the optical disc drive to grant the virtual machine exclusive access to the optical disc drive. In one embodiment, the drive manager may determine, subsequent to locking the optical disc drive, that the virtual machine stopped transacting with the optical disc drive. In response to this determination, the drive manager may unlock the optical disc drive.</p>
<p id="p-0182" num="0191">Referring now to <figref idref="DRAWINGS">FIG. 7A</figref>, illustrated is a block diagram of an embodiment of a system for controlling virtual machine access to an optical disc drive. In addition to other features discussed herein, a computing device may include an optical disc drive <b>700</b>. In some embodiments, a control program <b>220</b> may comprise a drive manager <b>702</b>. Although shown on the control virtual machine, in many embodiments the control program <b>220</b> may execute on the hypervisor <b>202</b>. The hypervisor <b>202</b> may host a plurality of guest virtual machines <b>232</b>B-<b>232</b>C, and each guest virtual machine may include a virtual optical disc drive <b>704</b>A-<b>704</b>B (referred to generally as a virtual optical disc drive <b>704</b>).</p>
<p id="p-0183" num="0192">Still referring to <figref idref="DRAWINGS">FIG. 7A</figref>, and in more detail, the hardware layer <b>210</b> can, in some embodiments, include an optical disc drive <b>700</b>. The optical disc drive <b>700</b> can be any optical disc drive, while in other embodiments the optical disc drive <b>700</b> can be any disk drive described herein. In some embodiments, the optical disc drive <b>700</b> can be a DVD drive; a DVD-R or DVD-RW drive; a CD drive; CD R/W drive; a BluRay drive; or any other disc drive. While <figref idref="DRAWINGS">FIG. 3B</figref> illustrates an optical disc drive <b>700</b>, in some embodiments the disk drive can be a magnetic disk drive, such as a floppy disk drive; a ZIP drive; a tape drive; or any other magnetic disk drive.</p>
<p id="p-0184" num="0193">In some embodiments, virtual machines <b>232</b> can include one or more virtual optical disc drives <b>704</b>A-<b>704</b>B (generally optical disc drives <b>704</b>). These virtual optical disc drives <b>704</b> can, in some embodiments, be a virtualized view of physical disc drives <b>700</b> on the computing device <b>201</b>. Guest operating systems <b>230</b> executing on the virtual machines <b>232</b> can interact with the virtual disc drive <b>704</b> much the same way that the guest operating system <b>230</b> would interact with a physical disc drive <b>700</b>. In many embodiments, and unlike traditional manual remapping of optical disc drives to virtual machines, these virtual disc drives <b>704</b> may appear accessible to each guest operating system <b>230</b> simultaneously. Therefore, the guest operating systems <b>230</b> can issue read and write commands to the virtual disc drive <b>704</b>. In some embodiments, a drive manager <b>702</b> executing within the context of the control program <b>220</b> can intercept these read/write commands and send them to the physical disk drives <b>700</b>.</p>
<p id="p-0185" num="0194">In some embodiments, a drive manager <b>702</b> can execute within the control program <b>220</b>. The drive manager <b>702</b>, in some embodiments, can intercept read/write requests issued by applications executing within the virtual machines <b>232</b> and determine whether to pass those read/write requests to an optical disc drive <b>700</b> in the hardware layer <b>210</b>. The drive manager <b>702</b> can also receive from the disc drive <b>700</b> a stream of transactions, and can intuit from the stream of transactions the current actions of the disc drive <b>700</b>. In some embodiments, the drive manager <b>702</b> may convert the transaction stream to a stream of commands and analyze the generated command stream. Through this analysis, the drive manager <b>702</b> can determine whether the disc drive <b>700</b> is reading from a disc, writing to a disc, ejecting a disc, receiving a disc, idle, etc. Thus, the drive manager <b>700</b> can intuit from the transaction stream a state of the disk drive disc.</p>
<p id="p-0186" num="0195">In one embodiment, a set of security policies <b>706</b> can be stored on the computing device <b>201</b> in a memory element or storage repository accessible to the control program <b>220</b>. In some embodiments, the security policies <b>706</b> can be stored in a database on the computing device <b>201</b>. The security policies <b>706</b>, in some embodiments and similar to security policies <b>606</b> discussed above, can be a set of policies used by the control program <b>220</b>, a policy engine, or any other program to determine any of the following: whether a virtual machine <b>323</b> can access one or more memory elements, devices, processors or discs; whether a user can access one or more memory elements, devices, processors or discs; whether a device should be made available to one or more virtual machines <b>232</b>; whether one or more commands generated by an application executing within a virtual machine <b>232</b> should be forwarded to a device on the computing device <b>201</b>; and whether one or more requests generated by an application executing within a virtual machine <b>232</b> should be forwarded to a device on the computing device <b>201</b>.</p>
<p id="p-0187" num="0196">Similarly, in some embodiments a policy engine executing on the computing device <b>201</b> can use the security policies <b>606</b> to determine whether one or more actions are permitted. In some embodiments the policy engine <b>606</b> can operate in lieu of other programs executing within the context of the control program <b>220</b>. In other embodiments, the policy engine can operate in conjunction with the other programs.</p>
<p id="p-0188" num="0197">Illustrated in <figref idref="DRAWINGS">FIG. 7B</figref> is a flow chart of one embodiment of a method <b>720</b> for controlling access to a disk drive. At step <b>722</b>, a drive manager, control program, or hypervisor may map an optical disc drive to a plurality of virtual machines. At step <b>724</b>, the drive manager can receive or obtain a transaction stream from the optical disc drive and interpret and/or convert the transaction stream at step <b>726</b>. Upon interpreting the transaction stream, at step <b>728</b>, the drive manager may identify from the interpreted stream one or more transactions initiated by a virtual machine and determine which virtual machine initiated the transaction. Using this determination, the drive manager can then control access to the optical disc drive at step <b>730</b>.</p>
<p id="p-0189" num="0198">In some embodiments, the drive manager may continue monitoring communications between the disc drive and the determined virtual machine. Upon determining the transaction is complete at step <b>732</b>, at step <b>734</b> the drive manager may unlock the optical drive or allow other virtual machines to transmit requests to the optical drive.</p>
<p id="p-0190" num="0199">Further referring to <figref idref="DRAWINGS">FIG. 7B</figref>, and in more detail, in one embodiment the method <b>720</b> can be carried out by a drive manager. In other embodiments, the method <b>720</b> can be carried out by the control program. In still other embodiments, the method <b>720</b> can be carried out by any combination of the drive manager and the control program.</p>
<p id="p-0191" num="0200">In one embodiment, at step <b>722</b>, the drive manager, control program, control virtual machine, or hypervisor can map an optical disc drive connected to a computing device to a plurality of virtual machines executing on the computing device. In some embodiments, mapping the optical disc drive may comprise updating a virtualized view of hardware of each virtual machine to include the optical disc drive. In one embodiment, mapping the optical disc drive may comprise providing a virtual optical disc drive on each virtual machine, the virtual optical disc drive associated with the physical optical disc drive.</p>
<p id="p-0192" num="0201">In some embodiments, the drive manager may receive requests to read from a disc within the disc drive, or requests to write to a disc within the disc drive. These requests can be issued by one or more guest operating systems <b>230</b> executing within the context of a virtual machine <b>232</b>. In other embodiments, these requests can be issued by one or more applications executing within the context of a virtual machine <b>232</b>. For example, the drive manager can intercept a read request issued by a guest operating system <b>230</b> to a disc drive. The issued request can include commands instructing the disc drive to return to the guest operating system <b>230</b> the data stored in one or more sectors of memory. The drive manager can intercept this request to determine whether to forward the request to the physical disc drive.</p>
<p id="p-0193" num="0202">In some embodiments, the drive manager can receive a transaction stream generated by the disc drive at step <b>724</b>. In one embodiment, the drive manager may obtain the transaction stream responsive to intercepting a read/write request. In other embodiments, the drive manager may continuously interpret the transaction stream to track the state of the disc drive. In still another embodiment, the drive manager obtains or receives the transaction stream when a second virtual machine <b>232</b>B issues a read/write request while a first virtual machine <b>232</b>A accesses the disc drive.</p>
<p id="p-0194" num="0203">The transaction stream received from the disc drive, in some embodiments, can include a constant stream of small computer system interface (SCSI) commands output by the disc drive. In other embodiments, the transaction stream can include data formatted according to any type of communication protocol or standard. Typically, the SCSI commands are transmitted by the disc drive over an ATAPI or ATA interface or cable. The commands can be more generally referred to as machine commands, and in many embodiments they must be converted by a driver into a transaction format that can be processed by an operating system. When an operating system, in some embodiments, issues a command to the disc drive, that command is converted into a machine command that can be interpreted by the disc drive.</p>
<p id="p-0195" num="0204">In one embodiment, the drive manager may receive the transaction stream generated by the disc drive and convert the transaction stream into commands that can be interpreted by the operating system or control program <b>220</b> at step <b>726</b>. Converting the transaction stream can include reading through the transactions and matching sections of the transaction stream to a corresponding operating system command.</p>
<p id="p-0196" num="0205">In some embodiments, the drive manager can determine whether a virtual machine <b>232</b> has initiated one or more transactions with the disc drive at step <b>728</b>. In some embodiments, this determination can further include determining a state of the disc drive, where the state can be any of the following states: reading from a disc; writing to a disc; ejecting a disc; receiving commands; issuing commands; transmitting data; or any other state of the disc drive.</p>
<p id="p-0197" num="0206">Upon determining whether the virtual machine <b>232</b> initiated a transaction with the disc drive, the drive manager may then control access to the optical disc drive at step <b>730</b>. In one embodiment, controlling access to the optical disc drive may comprise locking the optical drive to prevent other virtual machines from accessing the drive, reading data from the drive, issuing requests to the drive, or otherwise interacting with the drive. In other embodiments, controlling access to the disc drive can include determining whether an application or virtual machine has permission to access the disc drive, and preventing unqualified applications from issuing read/write requests to the disc drive. In still other embodiments, controlling access to the disc drive can include receiving a read/write request from a virtual machine <b>232</b>, determining another virtual machine <b>232</b> is accessing the disc drive, and returning to the initial virtual machine a message indicating the disc drive is in use. In still another embodiment, controlling access to the disc drive may include buffering a request from a second virtual machine while a first virtual machine is accessing the disc drive, such that the buffered request may be issued to the disc drive when the first virtual machine has completed accessing the disc drive. In many embodiments, controlling or locking the optical drive to other virtual machines while a first virtual machine is accessing the disc drive may be performed external to the guest virtual machines, by the control virtual machine or hypervisor, such that the operating system of each other guest virtual machine does not know that it is temporarily prevented from accessing the disc drive.</p>
<p id="p-0198" num="0207">In one embodiment, the drive manager may grant a first virtual machine access to the disc drive at step <b>730</b>. The drive manager may then receive a read/write request issued by an application executing in a second virtual machine, and in some embodiments, may respond with a response indicating the drive is not available.</p>
<p id="p-0199" num="0208">In some embodiments, granting exclusive access to the disc drive can include identifying the type of transaction to be carried out by the virtual machine. In other embodiments, granting exclusive access to the disc drive can include determining security credentials, access rights, or other similar permissions for the virtual machine and/or the application issuing the read/write requests.</p>
<p id="p-0200" num="0209">In many embodiments, the drive manager may grant exclusive access to the disc drive to a virtual machine during the pendency of a transaction. In other embodiments, the drive manager may grant exclusive access during a period of time required to receive an acknowledgement, data, response or other information from the disc drive.</p>
<p id="p-0201" num="0210">In some embodiments, the drive manager can receive or intercept another read/write request from another virtual machine while an initial virtual machine transacts with and otherwise accesses the disc drive. Thus, the drive manager receives the other virtual machine's read/write request at the same time that an initial virtual machine transacts with the disc drive. The drive manager can determine that another virtual machine is transacting with the disc drive by analyzing the transaction stream generated by the disc drive. In other embodiments, the drive manager can track when and to which virtual machine and/or application the drive manager has granted exclusive access to the disc drive.</p>
<p id="p-0202" num="0211">In some embodiments, upon determining that an initial virtual machine is transacting with the disc drive, the drive manager can return to the other virtual machine or application executing on the other virtual machine, a response indicating the drive is not available. The response can, in some embodiments, include an error message or device busy alert. In other embodiments, the drive manager can prevent applications on another virtual machine from viewing the disc drive when the disc drive is exclusively assigned to an initial virtual machine. In still other embodiments, the drive manager can store the read/write request to a queue or buffer, and forward the request to the disc drive once the initial virtual machine stops transacting with the disc drive. In one embodiment, the drive manager can issue a notice to the virtual machine and/or application indicating that the device is unavailable, while substantially simultaneously storing the request to a queue.</p>
<p id="p-0203" num="0212">At step <b>732</b>, in many embodiments, the drive manager can determine that an initial virtual machine stopped transacting with a disc drive. In some embodiments, the drive manager can make this determination by receiving an indicator from the virtual machine that the transaction has ended. In other embodiments, the drive manager can make this determination by interpreting the transaction stream generated by the disc drive to determine a series of actions taken by the disc drive. Transactions in which the disc drive indicates it has finished a task can in some embodiments indicate that a virtual machine stopped transacting with the disk drive.</p>
<p id="p-0204" num="0213">The drive manager can then revoke exclusive access to the disc drive at step <b>734</b>. In some embodiments, the drive manager can revoke exclusive access by allowing other virtual machines to access the disc drive. In one embodiment, the drive manager can revoke exclusive access by updating a database, list or table to indicate that the virtual machine no longer has exclusive access to the disc drive. Steps <b>724</b>-<b>734</b> may be repeated, such that upon receiving a read/write request for the disc drive, issued by another virtual machine, the drive manager can grant the other virtual machine exclusive access to the disc drive. In other embodiments in which the drive manager has queued or buffered requests from the other virtual machines, the drive manager may grant each virtual machine exclusive access in turn and transmit the corresponding buffered requests to the disc drive to step through the queue. This may be done in a first-in, first-out (FIFO) order, a first-in, last-out (FILO) order, a round robin method, or any other order.</p>
<p id="h-0013" num="0000">H. Providing Access to Virtual Machines to Data Associated with a Connection to a Wireless Local Area Network, Via a Designated Wireless Local Area Network Driver</p>
<p id="p-0205" num="0214">Conventionally, when a number of virtual machines share access to a wireless local area network (LAN) driver, one of the virtual machines is nominated as the controller of the wireless local area network driver and, therefore, to access to the wireless local area network. The controller typically runs a communications stack, which may be referred to as a supplicant stack. The controller handles, via the wireless LAN driver, the process of connecting to a wireless network. However, other virtual machines attempting to access data identifying a characteristic of the established connection, which is made available by the driver, are prevented from doing so because, typically, only the controller can access this data.</p>
<p id="p-0206" num="0215">In some embodiments of a solution for providing access to a plurality of virtual machines to characteristics and data associated with a connection to a wireless LAN, a paravirtual wi-fi driver is a driver that sits in the guest operating system of a virtual machine and appears to the guest operating system as a wireless network card. The guest operating system commands to this wireless card and the virtualization layer (e.g. the control program) can determine which virtual machine <b>232</b> should have access to the network. In some embodiments, the guest operating system never gives over the network key, the guest OS merely negotiates with the control program for access. In some embodiments, a guest virtual machine controlling and maintaining network connections may include additional DNS and routing tables corresponding to a second virtual machine and may act, via the paravirtual wi-fi driver, as a network bridge to the second virtual machine. In many embodiments, this bridging behavior will not be apparent to an operating system of either the guest operating system or the second virtual machine, as the bridged data may be passed through a V2V or private communication channel rather than a network connection, even an internal one.</p>
<p id="p-0207" num="0216">Referring now to <figref idref="DRAWINGS">FIG. 8A</figref>, a block diagram depicts one embodiment of a system for providing, to virtual machines on a physical device, via a designated wireless local area network driver, access to data associated with a connection to a wireless local area network. In brief overview, and in addition to many of the components discussed in more detail above, the system includes a wireless network interface <b>800</b>, a wireless network interface driver <b>802</b>, a first driver <b>804</b>A, and a second driver <b>804</b>B. The first driver <b>804</b>A may be executed by a first virtual machine <b>232</b>A, which executes on a physical computing device A <b>201</b>. The first driver <b>804</b>A may establish, via a communications stack not illustrated, a connection to a second computing device <b>100</b><i>b </i>via a wireless local area network <b>104</b> and maintain the established connection. The second driver <b>804</b>B may be executed by a second virtual machine <b>232</b><i>b</i>, which executes on the physical computing device <b>201</b>. In some embodiments, the second driver <b>804</b>B may request access to data identifying a characteristic of the established connection. The second driver <b>804</b>B may receive, from the first driver <b>804</b>A, the requested data. The second driver <b>804</b>B may, in some embodiments, display the data to a user of the physical computing device <b>201</b>. In some embodiments, the hypervisor <b>202</b> may enable access by the first driver <b>804</b>A to the wireless network interface and disable access by the second driver <b>804</b>B to the wireless network interface.</p>
<p id="p-0208" num="0217">Still referring to <figref idref="DRAWINGS">FIG. 8A</figref> and in greater detail, a driver may comprise a software application executed by a computing device that controls a device connected, directly or indirectly, to the computing device. In one embodiment, the first driver <b>804</b>A is a driver executed by a virtual machine monitor, not illustrated, executed by another virtual machine; for example, a control program <b>220</b> executing in a control virtual machine may execute the virtual machine monitor, which executes the first driver <b>804</b>A. In another embodiment, the other second driver <b>804</b>B is authorized to access the physical wireless network interface card <b>800</b>. In still another embodiment, the second driver <b>804</b>B is a virtual driver allocated access to a virtualized wireless network interface card. In yet another embodiment, the first driver <b>804</b>A and the second driver <b>804</b>B are drivers executed on the physical computing device A <b>201</b><i>a </i>that provide functionality for controlling a physical card <b>800</b>.</p>
<p id="p-0209" num="0218">In one embodiment, the first driver <b>804</b>A is a wireless local area network driver (which may be referred to as a Wi-Fi driver). In another embodiment, the first driver <b>804</b>A controls, via a communications stack, a physical network interface card <b>800</b> with which the physical computing device <b>201</b> may connect to a second computing device <b>100</b><i>b </i>via a wireless local area network <b>104</b>. In another embodiment, the first driver <b>804</b>A is a virtualized software program that communicates, via a communications stack, with a physical driver <b>802</b>, which, in turn, controls the physical network interface card <b>800</b> with which the physical computing device <b>201</b> connects to the second computing device <b>100</b><i>b </i>via the wireless local area network <b>104</b>. In still another embodiment, the second driver <b>804</b>B is also a Wi-Fi driver.</p>
<p id="p-0210" num="0219">Each of first driver <b>804</b>A and second driver <b>804</b>B may include or communicate with a network communications stack or protocol stack provided by the guest operating system <b>230</b> executing the driver <b>804</b>. In some embodiments in which a dom0 entity executes a wireless network interface driver <b>802</b> (sometimes referred to as the physical driver, as opposed to the virtual drivers <b>804</b>), these communications stacks may be referred to as supplicant stacks. The communications stacks may comprise software implementations of a computer networking protocol suite.</p>
<p id="p-0211" num="0220">In one embodiment, the wireless network interface <b>800</b> may comprise a wireless network interface card of any type and form, including a PCI card, a USB wireless network interface, a PCMCIA wireless network interface, or any other type of wireless network interface. In some embodiments, the wireless network interface <b>800</b> may comprise an internal card installed inside the physical computing device <b>201</b>.</p>
<p id="p-0212" num="0221">In some embodiments, a wireless network interface card <b>800</b> converts data from the physical computing device <b>201</b> into radio signals. In one of these embodiments, the wireless adapter card <b>800</b> includes an antenna that transmits the radio signals to a wireless router in the network <b>104</b> for forwarding to the second computing device <b>100</b><i>b</i>. In one embodiment, the hypervisor <b>202</b> is a hypervisor as described above. In another embodiment, the hypervisor <b>202</b> includes functionality for enabling or disabling access, by a driver, to a communications stack. In still another embodiment, and by way of example, the hypervisor <b>202</b> includes a component for transmitting a message to a virtual machine with an instruction to enable or disable a driver.</p>
<p id="p-0213" num="0222">In one embodiment, a virtual machine monitor executed by an operating system of a virtual machine executes the first driver <b>804</b>A. In another embodiment, the virtual machine monitor is a component executed by the control program <b>220</b> discussed above. In another embodiment, the virtual machine monitor is the control program <b>220</b>.</p>
<p id="p-0214" num="0223">In some embodiments, the first driver <b>804</b>A communicates, via a physical wireless network interface driver <b>802</b> executed by a dom0 entity such as the hypervisor <b>202</b> or a control virtual machine, with wireless network interface <b>800</b>. The dom0 entity may allow the first virtual machine <b>232</b>A access to the wireless network interface <b>800</b> in this manner, while preventing a second virtual machine <b>232</b>B from accessing the interface. This may be done to allow the first virtual machine <b>232</b>A continuous and exclusive access to the wireless network interface <b>800</b> to maintain a wireless connection. For example, the wireless connection may include broadcasted keep-alives and other communications messages between the computing device <b>201</b> and a wireless router or base station, even when no IP connections to another computing device <b>100</b><i>b </i>are active.</p>
<p id="p-0215" num="0224">In one embodiment, the first driver <b>804</b>A may act as a network bridge for the second driver <b>804</b>B and/or the second virtual machine <b>232</b>B. In many embodiments, this may be done without an operating system <b>230</b> of either virtual machine <b>232</b> needing to be configured to bridge the network connection, and avoids the first virtual machine <b>232</b> needing to have two separate network drivers active to bridge the connection. In one such embodiment, data and requests of the bridged connection may be passed between the first driver <b>804</b>A and the second driver <b>804</b>B using shared memory pages or V2V messages, as discussed above. In many embodiments, the first driver <b>804</b>A may comprise a Domain Name Service (DNS) table A and incoming and outgoing routing tables A and B for the guest operating system A <b>230</b>A. Additionally, the first driver <b>840</b>A may comprise a DNS table B and incoming and outgoing routing tables C and D for the guest operating system B <b>230</b>B of the second virtual machine <b>232</b>B. By maintaining these additional routing and DNS tables, the first driver <b>804</b>A may direct communications properly between the wireless network interface <b>800</b> and applications of the first virtual machine <b>232</b>A or the second virtual machine <b>232</b>B. In many embodiments, the first driver <b>804</b>A may receive the DNS table B, and routing tables C and D from the second driver <b>804</b>B, which may store identical tables.</p>
<p id="p-0216" num="0225">Referring now to <figref idref="DRAWINGS">FIG. 8B</figref>, a flow diagram depicts one embodiment of a method <b>820</b> for providing, to virtual machines on a physical device, via a designated wireless local area network driver, access to data associated with a connection to a wireless local area network. In brief overview, the method <b>820</b> includes establishing, at step <b>822</b> by a first driver executed by a first virtual machine hosted by a hypervisor executed by a first computing device, a network connection via a wireless network. At step <b>824</b>, the first driver may receive from a second driver executed by a second virtual machine hosted by the hypervisor a request for a characteristic of the network connection. At step <b>826</b>, the first driver may provide the requested characteristic to the second driver. At step <b>828</b>, in some embodiments, an operating system of the second virtual machine may display the characteristic to a user.</p>
<p id="p-0217" num="0226">At step <b>830</b>, in some embodiments, the first virtual machine may maintain the established network connection. At step <b>832</b>, in one embodiment, the hypervisor may disable access to the wireless network interface by the first driver. At step <b>834</b>, the hypervisor may enable access to the wireless network interface by the second driver. At step <b>836</b>, the second driver may communicate via the established network connection.</p>
<p id="p-0218" num="0227">Still referring to <figref idref="DRAWINGS">FIG. 8B</figref> and in greater detail, at step <b>822</b>, a first driver executed a first virtual machine executing on the physical computing device may establish a network connection via a wireless network. In some embodiments, the hypervisor <b>202</b> enables access by the first driver to a communications stack associated with a physical wireless network interface. Access by a second driver executed by a second virtual machine to the communications stack may be disabled. The first driver may establish, via the communications stack of the physical wireless network interface, a connection to a second computing device via a wireless local area network. In one embodiment, the first driver maintains the established connection. In another embodiment, the first driver receives connection-related data&#x2014;such as an identification of the wireless local area network, an identifier of a level of signal strength of the connection, or other data identifying a characteristic of the connection.</p>
<p id="p-0219" num="0228">In some embodiments, establishing and/or maintaining a network connection may comprise providing authorization or login credentials to a wireless router or base station. For example, in one such embodiment, the first driver may provide a wired equivalent privacy (WEP) key or a wifi-protected access (WPA or WPA2) key to the wireless router.</p>
<p id="p-0220" num="0229">At step <b>824</b>, in some embodiments, the second driver may request, from the first driver, access to data identifying a characteristic of the established connection. In one embodiment, the first driver receives from the second driver a request for an identification of a signal strength of the established connection. In another embodiment, the first driver receives from the second driver a request for an identification of the wireless local area network.</p>
<p id="p-0221" num="0230">At step <b>826</b>, the first driver may provide the requested characteristic to the second driver. In some embodiments, the first driver may provide the requested characteristic via a V2V channel or shared memory region or other inter-virtual machine communication channel.</p>
<p id="p-0222" num="0231">At step <b>828</b>, in some embodiments, the second virtual machine, an operating system of the second virtual machine, an application of the second virtual machine, or the second driver may display, to a user of the computing device, the received data. Displaying the received data may comprise displaying the network name, SSID, connection strength or other variables in a manner typically used by the operating system of the second virtual machine to display such data when executing on a non-virtualized machine.</p>
<p id="p-0223" num="0232">At step <b>830</b>, in some embodiments, the first virtual machine and/or the first driver may maintain the network connection. In some embodiments, the first virtual machine may maintain the network connection by transmitting a signal to a base station or wireless router to keep the wireless connection alive.</p>
<p id="p-0224" num="0233">In some embodiments, at step <b>832</b>, the hypervisor may disable access, by the first driver, to the communications stack of the physical wireless network interface or otherwise enable access to the interface. In some embodiments, disabling access by the first driver may comprise disabling access without closing an established or maintained network connection. This may be done to enable another virtual machine to utilize the established connection.</p>
<p id="p-0225" num="0234">At step <b>834</b>, in one embodiment, the hypervisor may enable access to the interface by the second driver. In one embodiment in which the first driver provided login credentials or keys to establish the connection, enabling access by the second driver may comprise not requiring the user or the second driver to provide such login credentials or keys to utilize the established network connection. Rather, the network connection established by the first driver may be utilized by the second driver without requiring additional authentication. This may be done, for example, by not closing the established connection when transferring access from the first driver to the second driver. Accordingly, at step <b>836</b>, the second driver may communicate via the established connection.</p>
<p id="h-0014" num="0000">I. Preventing Access to Display Graphics Generated by a Trusted Virtual Machine</p>
<p id="p-0226" num="0235">As discussed above, in many instances a user may use a non-trusted virtual machine and a trusted virtual machine simultaneously. For example, the user may run a media player application on a non-trusted virtual machine while working on corporate data on a trusted virtual machine. In some cases, an application executing within a unsecure or non-trusted, user-specific virtual machine, may request screen graphics generated by applications executing within a secure, trusted, company-specific virtual machine. Typically each virtual machine has access to a single graphics processing unit (GPU), therefore each virtual machine typically has access to most aspects of the GPU. In particular, in many cases each virtual machine has read/write access to memory used by the GPU to store rendered images and other graphics data. Thus, in the above-mentioned scenario, the non-trusted virtual machine can read the graphics generated by the trusted virtual machine by reading from the GPU memory. This situation is not ideal because it can open security loopholes whereby users can obtain information from a trusted virtual machine simply by capturing screen images or &#x201c;screen-scraping.&#x201d;</p>
<p id="p-0227" num="0236">In one solution to this problem, a graphics manager executing on the computing device, may receive a request from the trusted virtual machine to render graphical data using a graphics processing unit of the computing device. The graphics manager may select and assign a secure section of memory of the graphics processing unit to the trusted virtual machine. The graphics manager may render graphics from graphical data generated by trusted secure virtual machine to the secure section of the graphics processing unit memory. If the graphics manager receives a request from an application executing on a non-trusted virtual machine to read graphics that are rendered from the trusted virtual machine graphical data, and that are stored in the secure section of the graphics processing unit memory, the graphics manager can prevent the application from reading the trusted virtual machine graphics from the secure section of the graphics processing unit memory.</p>
<p id="p-0228" num="0237">Referring now to <figref idref="DRAWINGS">FIG. 9A</figref> and in brief overview, in one embodiment of a system for preventing access to display graphics generated by a trusted virtual machine, in addition to other components discussed herein, a computing device <b>201</b> may comprise a graphics processing unit (GPU) <b>900</b>, which may include or access a memory unit <b>908</b>. The system may also include a graphics manager <b>902</b> executed by a trusted virtual machine and/or a control virtual machine or control program <b>220</b> discussed above, or a graphics manager <b>902</b>&#x2032; executed by a hypervisor <b>202</b>. Thus, the graphics manager <b>902</b> may be executed by a trusted dom0 entity. The system may include a trusted virtual machine <b>232</b>A, which may execute a first application <b>904</b>A. The first application <b>904</b>A may generate graphical data <b>906</b>A, such as windows, toolbars, buttons, video, images, or other data. In some embodiments, the first application <b>904</b>A may comprise a remote access application, such as an ICA or Remote Desktop Protocol client and may connect to a server and display graphical data <b>906</b>A generated remotely and delivered to the application. Similarly, the system may include a non-trusted virtual machine <b>232</b>B which may execute a second application <b>904</b>B, generating graphical data <b>906</b>B.</p>
<p id="p-0229" num="0238">A graphics processing unit (GPU) <b>900</b>, in some embodiments, can be included in the hardware layer <b>210</b> of the computing device <b>201</b>. The graphics processing unit <b>900</b> can be any processor able to render graphics. In some embodiments, the graphics processing unit <b>900</b> may include memory <b>908</b> that the graphics processing unit <b>900</b> can use to store rendered graphics and other graphics data. In other embodiments, the graphics processing unit <b>900</b> is allocated a portion of the physical memory <b>216</b>, discussed above, which the graphics processing unit <b>900</b> can use to store graphics information and rendered graphics.</p>
<p id="p-0230" num="0239">In some embodiments, the system may include a graphics manager <b>902</b>. The graphics manager <b>902</b> may be executed in any trusted environment, including a control virtual machine and/or a hypervisor <b>202</b>. The graphics manager <b>902</b> can act as a layer between the virtual machines <b>232</b>, such that the graphics manager <b>902</b> can intercept requests issued to the physical GPU <b>900</b> by applications <b>904</b>A-<b>904</b>B executing on the virtual machines <b>232</b>. While <figref idref="DRAWINGS">FIG. 9A</figref> illustrates a graphics manager <b>902</b> that executes on the trusted virtual machine <b>232</b>A, in some embodiments the graphics manager <b>902</b> may be included within a control program <b>220</b>, a tools stack <b>224</b>, or executed by the hypervisor, an underlying operating system, or a control virtual machine. In some embodiments, the graphics manager <b>902</b> assigns graphics memory locations to applications <b>904</b> and/or virtual machines <b>232</b> executing on the computing device <b>201</b>. In other embodiments, the graphics manager <b>902</b> segments the GPU memory <b>908</b> into secure and unsecure memory sections. In still other embodiments, the graphics manager <b>908</b> segments physical memory <b>216</b> assigned to the GPU <b>900</b> into secure and unsecure memory sections including a secure region <b>910</b>.</p>
<p id="p-0231" num="0240">When an application <b>904</b> issues a request or command to the GPU <b>900</b>, in some embodiments, the graphics manager <b>902</b> can intercept that request and determine whether the command or request should be forwarded to the GPU <b>900</b>. The graphics manager <b>902</b>, in some embodiments, may make that determination by reviewing one or more security policies, discussed in more detail above, to determine whether the application <b>904</b> has permission to write to memory or read from a particular area of memory, referred to as a secure region <b>910</b>. In some embodiments, the graphics manager <b>902</b> forwards identifying information about the application <b>904</b> and the virtual machine <b>232</b> on which the application <b>904</b> executes, to a policy engine, discussed above. Based on the received information and one or more security policies, the policy engine may determine whether the command or request should be pushed through to the GPU <b>900</b> and relays this determination to the graphics manager <b>902</b>.</p>
<p id="p-0232" num="0241">Illustrated in <figref idref="DRAWINGS">FIG. 9B</figref> is one embodiment of a method <b>920</b> for segmenting GPU <b>900</b> memory into an unsecure and secure section of memory. A graphics manager may receive a request, issued by a trusted virtual machine to the GPU, to render one or more graphics at step <b>922</b>. The graphics manager may, at step <b>924</b>, assign a secure section of GPU memory to the trusted virtual machine or an application of the trusted virtual machine. The graphics manager can then render the graphical data and store the rendered images in a secure section of the GPU memory at step <b>926</b>.</p>
<p id="p-0233" num="0242">At step <b>928</b>, in some embodiments, the graphics manager may receive a request, issued from a non-trusted virtual machine to the GPU, requesting to read image data from the secure section of GPU memory. Upon receiving this request, the graphics manager can prevent the unsecure virtual machine from reading the secure section of memory at step <b>930</b>. In some embodiments, at step <b>932</b>, the graphics manager may receive a request from the non-trusted virtual machine to render graphical data. At step <b>934</b>, the graphics manager may direct the GPU to render the graphics from the non-trusted virtual machine to a section of the GPU memory not including the secure section of memory.</p>
<p id="p-0234" num="0243">Further referring to <figref idref="DRAWINGS">FIG. 9B</figref> and in more detail, in one embodiment the graphics manager may receive a request from a secure or trusted virtual machine to render graphics from graphics data at step <b>922</b>. In some embodiments, the trusted virtual machine generates this request in response to a request issued by an application executing on the trusted virtual machine. For example, an application executing on the trusted virtual machine can generate graphics commands and graphical data. The application can issue a request to the guest operating system executing on the trusted virtual machine, asking the guest operating system to render graphics from the graphics commands and graphical data. In some embodiments, the guest operating system can forward this request to the control program <b>220</b> which can forward the request to the graphics manager. In one embodiment, the request can include the graphics data and graphics commands. In another embodiment, the request can be a request for access to the GPU. Although referred to as receiving a request, in many embodiments, requests to render graphical data are transmitted from the guest operating system or application on the virtual machine to the GPU, but are intercepted or redirected to the graphics manager.</p>
<p id="p-0235" num="0244">In some embodiments, the graphics manager can partition the memory of the GPU to create a secure memory section at step <b>924</b>. The graphics manager can segment, partition or otherwise assign a segment of the GPU memory as a secure section of the GPU memory. In some embodiments, the graphics manager can assign the trusted virtual machine a secure section of memory. Assigning the virtual machine a secure section of memory can include generating an entry in a database indicating that a particular range of memory addresses are assigned to the trusted virtual machine.</p>
<p id="p-0236" num="0245">At step <b>926</b>, in some embodiments, the GPU receives the graphics commands and graphics data from the graphics manager, renders graphics from this information and stores the rendered graphics in the secure section of the GPU memory. In one embodiment, the graphics manager, after segmenting or partitioning the GPU memory so that a portion of the memory is assigned to store graphics rendered from graphical data generated by a trusted virtual machine, passes the graphics information to the GPU. When passing the graphics information to the GPU, the graphics manager can also pass metadata or additional instructions instructing the GPU to render the images to the secure memory section of the GPU memory.</p>
<p id="p-0237" num="0246">While <figref idref="DRAWINGS">FIG. 9B</figref> illustrates a method <b>920</b> that partitions or segments GPU memory, in other embodiments the method <b>920</b> can include partitioning or segmenting physical memory <b>216</b> assigned to the GPU. In still other embodiments, the graphics manager may not physically segment or partition the GPU memory, but rather assign a range of memory addresses to the trusted virtual machine. The memory address assignations can be stored in a database on the control virtual machine and can be accessed by the graphics manager. In other embodiments, the assigned memory addresses can be stored in any list, database or storage repository accessible by the graphics manager.</p>
<p id="p-0238" num="0247">In some embodiments, the graphics manager can receive a request from a non-trusted virtual machine to read image data from the secure section of GPU memory at step <b>928</b>. In response to this request, at step <b>930</b>, the graphics manager may prevent the non-trusted virtual machine from reading the secure section of memory. In some embodiments, receiving the request to read image data from the secure section of the GPU memory can include intercepting a read request issued by an application executing on a non-trusted virtual machine, where the read request can be issued by the application to the GPU. Preventing the non-trusted virtual machine from reading the secure section of memory can include first analyzing security and/or access credentials of the non-trusted virtual machine. In some embodiments, the graphics manager prevents access after determining that the non-trusted virtual machine lacks the access rights or security credentials to read secure images. Upon determining that the non-trusted virtual machine lacks access rights, in some embodiments the graphics manager can return an error indicating that the memory location is unavailable. In other embodiments, the graphics manager can return data in another section of memory accessible by the non-trusted virtual machine. For example, in response to a print screen request issued by the non-trusted virtual machine, the graphics manager could return only those portions of the screen to which the non-trusted virtual machine has access. Thus, in some embodiments, the sections of the screen corresponding to the trusted virtual machine may be blacked out or otherwise deleted from the print screen image returned to the non-trusted virtual machine. Removing a section of the screen can include paging out the raster from the screen and checking the writes. In other embodiments, a stencil could be used to identify the pixels to which the non-trusted virtual machine has access, and drawing an image that includes only those pixels while the rest of the pixels are drawn a default color value.</p>
<p id="p-0239" num="0248">In a further embodiment, at step <b>932</b>, the graphics manager may receive a request from the non-trusted virtual machine to render graphical data. The graphics manager may receive the request in a similar manner to those discussed above with regard to receiving a request from the trusted virtual machine to render graphical data. In many embodiments, the graphics manager intercepts or receives the request via a redirection.</p>
<p id="p-0240" num="0249">At step <b>934</b>, responsive to receiving the request from the non-trusted virtual machine, the graphics manager may direct the GPU to render the graphics from the non-trusted virtual machine and store the rendered graphics to a section of the GPU memory not including the secure section partitioned off for the trusted virtual machine. This may be done to avoid graphics corruption, for example.</p>
<p id="p-0241" num="0250">In one embodiment, both the non-trusted virtual machine and the trusted virtual machine have full access to the GPU. In many embodiments each virtual machine has the ability to reverse engineer the screen properties to figure out where to send pixels. However, through the methods and systems discussed herein, non-trusted virtual machines are unable to obtain access to graphics generated by trusted virtual machines.</p>
<p id="h-0015" num="0000">J. Securing Sensitive Information Using a Hypervisor-Trusted Client</p>
<p id="p-0242" num="0251">There exist many client-server systems where a client device provides sensitive user information to a server over a network. In many instances, these systems are vulnerable to security attacks via key-loggers, screen scrapers or other malware that can capture the sensitive information provided by the client device during a user session or while a user accesses resources and applications provided by the server. A client device or computer can capture and/or store sensitive user information such as passwords or other user-specific access information when a user requests to access information on a server. In some instances, a user can request access to corporate resources such as applications or desktops. The client device can capture password or other sensitive access information and present this captured information to a corporate computer along with a request for access to the desired resource. The corporate computer in turn can determine whether to permit the user to access the requested resource.</p>
<p id="p-0243" num="0252">During these scenarios, the applications used to request access may execute within the context of a non-trusted operating system or may communicate over an unsecure or non-trusted network, e.g. a home computer, a kiosk, a user's personal computer, a mobile device, etc. Thus, the security of the user-provided information can be compromised by malware or other similar applications that can obtain sensitive information. Current solutions for reducing the risk of disclosing passwords or other secret information include end point scanning and remediation. One disadvantage of this approach is that it can take time for the scan and any necessary remediation to complete. The scan may also be limited in terms of the threats it can identify. Furthermore, remediation can lead to end user confusion.</p>
<p id="p-0244" num="0253">Other solutions include using XENCLIENT published by Citrix Systems together with a separate enterprise controlled operating system and use that for access to enterprise resources. One advantage to this solution is that it enables off-line access to corporate resources, as they have effectively been downloaded into the trusted corporate image. A disadvantage, however, is that it requires a client side, corporate maintained image, and all the overheads and delays that result from getting it there. Furthermore, the client itself may not be secure.</p>
<p id="p-0245" num="0254">Accordingly, one solution may involve using a trusted virtual machine image to control remote access to applications hosted by a remote presentation application. This application, in some embodiments, can be XENAPP published by Citrix Systems. In other embodiments, other remote presentation applications can be used.</p>
<p id="p-0246" num="0255">When the user logs in or starts an application for accessing a device, e.g. CITRIX RECEIVER, the user may be asked to provide a password. In some embodiments, the password is needed to get a list of available applications, or access the Merchandizing Server and Delivery Services.</p>
<p id="p-0247" num="0256">Instead of collecting the credentials itself through the traditional authentication plug-in, the application can call the hypervisor. In response, the hypervisor can start the authentication component. This component may show a window to collect credentials. Using virtualization technology for directed I/O (VT-D) pass-through, the hypervisor may display this window directly by writing to the video buffer, and the hypervisor may verify that the mouse and keyboard are connected to the hypervisor environment, rather than a non-trusted user image or virtual machine.</p>
<p id="p-0248" num="0257">Credentials may be collected and can be stored in the secure environment of the hypervisor. These credentials may be transmitted to the server for authentication. The authentication server may return a set of capabilities, potentially one for each of the services that the application's plug-ins may need to access. In some embodiments, the hypervisor may pass all the non-sensitive capabilities to the application on the return call, but may keep the capability for the actual ICA connection.</p>
<p id="p-0249" num="0258">Thus, in some embodiments, when the application detects the user wants to connect to an application on the server, the application may initiate or launch a proxy agent in domU or the user's non-trusted virtual machine. The proxy agent may communicate with a dom0 entity such as the hypervisor or a control virtual machine, and request launch of the remote client agent, e.g. an ICA application. The dom0 entity may start the client agent, responsive to this request. In some embodiments, the proxy agent may provide the client agent with information needed to initiate a connection to a remote application server, such as an IP address, server identification, or other non-sensitive information.</p>
<p id="p-0250" num="0259">Once the client agent has established a communications session with the remote server, the client agent, executing in the trusted dom0 domain, may display its output by directly writing to the video buffer. This output may be placed so that it is visible in the same screen area as a window generated by the domU proxy agent occupies. However, a screenshot made in domU will not show the contents of the client agent's output window. In one embodiment, the client agent may display its output via a secure memory region of the GPU, as in the system discussed above with regard to preventing access to display graphics generated by a trusted virtual machine.</p>
<p id="p-0251" num="0260">In many embodiments, the client agent and proxy agent may communicate with one another via either an ICA virtual channel, or using V2V communications or the systems discussed above for communication between a trusted virtual machine and a non-trusted virtual machine. The communications may allow the proxy agent executing in domU to indicate to the dom0 client agent when it is being given focus. Upon receiving focus, the dom0 client agent may obtain control over the keyboard and mouse. In one embodiment, this may be done using the systems and methods discussed above regarding injecting input data into a trusted virtual machine or a non-trusted virtual machine. Accordingly, keystrokes and mouse clicks, including passwords and other login credentials, can be fed to the server via the trusted dom0 entity, and remain invisible and inaccessible to applications in a domU virtual machine.</p>
<p id="p-0252" num="0261">In some embodiments, when the user suspends the session, the client agent in dom0 may retain information about the session. In a further embodiment, no information may be retained by the domU proxy agent.</p>
<p id="p-0253" num="0262">Referring briefly to <figref idref="DRAWINGS">FIG. 10A</figref>, illustrated is a block diagram of a system for securing sensitive information using a hypervisor-trusted client. In addition to features and elements discussed in more detail above, the system may include a proxy agent <b>1000</b> executed by a non-trusted virtual machine, and a client agent <b>1002</b> executed by a dom0 entity, such as a control virtual machine. Although illustrated on the control virtual machine, in many embodiments, the client agent <b>1002</b> may be executed by the hypervisor or an underlying operating system.</p>
<p id="p-0254" num="0263">In some embodiments, the proxy agent <b>1000</b> may comprise an application, service, daemon, routine, function, or other executable code for initiating, responsive to a user request, a client agent <b>1002</b> in a trusted dom0 domain. The proxy agent <b>1000</b> may further comprise functionality for generating a proxy window in a screen region. As discussed above, such proxy window may occupy the same region of the screen as a window containing output data generated by the client agent. The proxy window may be behind, in a z-order, the output data, or may be in front of the output data but transparent. In many embodiments, generating the proxy window may be done to cause a guest operating system to create a taskbar button for the proxy window. Accordingly, a user of the guest operating system may cause the proxy window to gain focus by selecting its taskbar button, selecting the proxy window, using an operating system-provided application switcher, or via other means. When the proxy window obtains focus, the proxy agent <b>1000</b> may transmit a message to the client agent <b>1002</b>, indicating that the proxy window has gained focus in the guest operating system, using any of the methods discussed above. Responsive to receiving the message, the client agent <b>1002</b> may move its output window forward in a z-order, unpause a paused connection, take control of a keyboard, mouse, or other input device, or perform other functions. Similarly, when the proxy window loses focus, such as from the user clicking on the window of another application in the guest operating system, the proxy agent <b>1000</b> may transmit a corresponding message to the client agent <b>1002</b> indicating the proxy window no longer has focus. Responsive to receiving such message, the client agent <b>1002</b> may pause the connection, move the output window back in a z-order, release control of the keyboard, mouse, or other input device to the guest operating system, or perform other such functions.</p>
<p id="p-0255" num="0264">In many embodiments, the client agent <b>1002</b> may comprise an application, service, daemon, subroutine, function, logic, or other executable code for establishing a connection to a remote server and displaying graphical output data. In many embodiments, the client agent <b>1002</b> may comprise an ICA client or RDP client. In some embodiments, the client agent <b>1002</b> may provide functionality for obtaining user credentials, such as login information and passwords, and transmitting these credentials to the remote server. In a further embodiment, the client agent <b>1002</b> may encrypt the credentials prior to transmission.</p>
<p id="p-0256" num="0265">Using the above systems, a user of a guest operating system executing on the non-trusted virtual machine may not be aware that the client agent is executing in a dom0 entity such as a control virtual machine or the hypervisor. By using the proxy window in the same location as the graphical output data presented by the client agent, the user may interact with the client agent as if it were executing on the guest operating system. However, sensitive information gathered by and presented by the client agent may remain inaccessible to the guest operating system or applications executed by the non-trusted virtual machine.</p>
<p id="p-0257" num="0266">Referring now to <figref idref="DRAWINGS">FIG. 10B</figref>, illustrated is a flow chart of a method <b>1020</b> for securing sensitive information by using a hypervisor-trusted client. In brief overview, at step <b>1022</b>, a user of a non-trusted virtual machine may request to establish a connection to a remote device, such as a remote application server. The non-trusted virtual machine or an operating system of the non-trusted virtual machine may launch a proxy agent. At step <b>1024</b>, the proxy agent may request a trusted virtual machine, the hypervisor, or another dom0 entity to launch a client agent. At step <b>1026</b>, in one embodiment, a graphics manager may assign a secure section of GPU memory to the client agent. In another embodiment, this step may be avoided by allowing the client agent to write directly to a video buffer using VT-D pass through. At step <b>1028</b>, the client agent may render graphics to the secure section of GPU memory, or write directly to the video buffer. At step <b>1030</b>, the client agent may receive a network address of the remote device from the non-trusted virtual machine. At step <b>1032</b>, the client agent may establish a connection with the remote device using the received network address.</p>
<p id="p-0258" num="0267">In some embodiments, the client agent may gather credentials from a user in a secure, trusted environment, by taking control of the user's keyboard and/or mouse or other input devices. For example, the client agent may receive this data through the methods discussed above regarding injecting input data into a secure virtual machine.</p>
<p id="p-0259" num="0268">In one embodiment, the proxy agent may generate a window in the same screen location as the output data displayed by the client agent. The window may be behind the output data in a z-order, or may be in front and transparent. When the user of the guest operating system on the non-trusted virtual machine clicks on the window, or a taskbar button or other user interface element associated with the window, the proxy agent window may receive focus. Because this window is transparent or behind the client agent's graphics output data, the user may believe they're clicking on a window of an application executing on the remote device and displayed via the remote client agent. Accordingly, the user may interact with the remote application without realizing that the client agent is not executing within the guest operating system or non-trusted virtual machine.</p>
<p id="p-0260" num="0269">Although discussed above in terms of virtual machines and guest operating systems, in many embodiments, the machine may execute only the one operating system in domU and the user may be unaware that a hypervisor is executing beneath the operating system. Accordingly, the user may be further unaware that the client agent is executing any other than within the domU operating system.</p>
<p id="p-0261" num="0270">In some embodiments, the above methods and systems may be used to access applications or desktops no matter where they are hosted, including applications hosted on a server farm, in the enterprise, hosted service or in the cloud; desktops hosted on a server farm, in the enterprise, hosted service or in the cloud; applications hosted on a client side secure or trusted operating system via a trusted virtual machine; a whole desktop hosted on a client side secure or trusted operating system; or any other remote application or desktop.</p>
<p id="p-0262" num="0271">In some embodiments, these methods and systems describe executing the application, e.g. the ICA client, inside an non-trusted image while connecting to applications served from a trusted image. By doing this, the application executing in the trusted image can be isolated from an unsecure or non-trusted users' environment.</p>
<p id="p-0263" num="0272">It should be understood that the systems described above may provide multiple ones of any or each of those components and these components may be provided on either a standalone machine or, in some embodiments, on multiple machines in a distributed system. The systems and methods described above may be implemented as a method, apparatus or article of manufacture using programming and/or engineering techniques to produce software, firmware, hardware, or any combination thereof. In addition, the systems and methods described above may be provided as one or more computer-readable programs embodied on or in one or more articles of manufacture. The term &#x201c;article of manufacture&#x201d; as used herein is intended to encompass code or logic accessible from and embedded in one or more computer-readable devices, firmware, programmable logic, memory devices (e.g., EEPROMs, ROMs, PROMs, RAMs, SRAMs, etc.), hardware (e.g., integrated circuit chip, Field Programmable Gate Array (FPGA), Application Specific Integrated Circuit (ASIC), etc.), electronic devices, a computer readable non-volatile storage unit (e.g., CD-ROM, floppy disk, hard disk drive, etc.). The article of manufacture may be accessible from a file server providing access to the computer-readable programs via a network transmission line, wireless transmission media, signals propagating through space, radio waves, infrared signals, etc. The article of manufacture may be a flash memory card or a magnetic tape. The article of manufacture includes hardware logic as well as software or programmable code embedded in a computer readable medium that is executed by a processor. In general, the computer-readable programs may be implemented in any programming language, such as LISP, PERL, C, C++, C#, PROLOG, or in any byte code language such as JAVA. The software programs may be stored on or in one or more articles of manufacture as object code.</p>
<p id="p-0264" num="0273">Having described certain embodiments of methods and systems for providing seamless thumbnails for hosted applications, it will now become apparent to one of skill in the art that other embodiments incorporating the concepts of the invention may be used.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed: </us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. In a computing device executing a hypervisor hosting a trusted virtual machine and a non-trusted virtual machine, a method for preventing the non-trusted virtual machine from reading the graphical output of the trusted virtual machine, comprising:
<claim-text>receiving, by a graphics manager executed by a processor of the computing device, a first request from the trusted virtual machine executed by the computing device to render graphical data using a graphics processing unit of the computing device;</claim-text>
<claim-text>assigning, by the graphics manager to the trusted virtual machine, a secure section of a memory of the graphics processing unit;</claim-text>
<claim-text>rendering, by the graphics manager, graphics from the trusted virtual machine graphical data to the secure section of the graphics processing unit memory;</claim-text>
<claim-text>receiving, by the graphics manager, a second request from the non-trusted virtual machine executed by the computing device to read graphics rendered from the trusted virtual machine graphical data and stored in the secure section of the graphics processing unit memory;</claim-text>
<claim-text>preventing, by the graphics manager responsive to receiving the second request, the non- trusted virtual machine from reading the trusted virtual machine rendered graphics stored in the secure section of the graphics processing unit memory;</claim-text>
<claim-text>receiving, by the graphics manager, a third request from an application executing on the non-trusted virtual machine to render a second set of graphical data using the graphics processing unit, the application generating the second set of graphical data; and</claim-text>
<claim-text>rendering, by the graphics manager, graphics from the second set of graphical data to a section of the graphics processing unit memory not comprising the secure section of the graphics processing unit memory.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein receiving the first request from a trusted virtual machine further comprises receiving, by the graphics manager, a fourth request generated by an application executing on the trusted virtual machine, the application generating the graphical data.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein assigning the secure section of memory further comprises assigning a policy to a range of memory addresses.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein preventing the non-trusted virtual machine from reading the secure section of the graphics processing unit memory further comprises:
<claim-text>identifying, by the graphics manager, a security credential of the non-trusted virtual machine; and</claim-text>
<claim-text>determining, by the graphics manager based on the security credential, the non-trusted virtual machine does not have permission to access the secure section of the graphics processing unit memory.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein determining the non-trusted virtual machine does not have permission further comprises applying a policy of the secure section of the graphics processing unit memory to the security credential.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein rendering graphics further comprises storing the rendered graphics to the secure section of the graphics processing unit memory.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>identifying, by the graphics manager, a security credential of the application executing on the non-trusted virtual machine;</claim-text>
<claim-text>determining, by the graphics manager based on the security credential, the non-trusted virtual machine does not have permission to access the secure section of the graphics processing unit memory; and</claim-text>
<claim-text>preventing, by the graphics manager, the graphics processing unit from rendering the graphics to the secure section of the graphics processing unit memory.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. In a computing device executing a hypervisor hosting a trusted virtual machine and a non-trusted virtual machine, a system for preventing the non-trusted virtual machine from reading the graphical output of the trusted virtual machine, comprising:
<claim-text>the computing device comprising:</claim-text>
<claim-text>a processor executing a graphics manager and the hypervisor hosting the trusted virtual machine and the non-trusted virtual machine, and</claim-text>
<claim-text>a graphics processing unit, comprising a memory; and</claim-text>
<claim-text>wherein the graphics manager is configured to:
<claim-text>receive a first request from the trusted virtual machine to render graphical data using the graphics processing unit,</claim-text>
<claim-text>assign, to the trusted virtual machine, a secure section of the memory of the graphics processing unit,</claim-text>
<claim-text>render graphics from the trusted virtual machine graphical data to the secure section of the graphics processing unit memory,</claim-text>
<claim-text>receive a second request from the non-trusted virtual machine to read graphics rendered from the trusted virtual machine graphical data and stored in the secure section of the graphics processing unit memory,</claim-text>
<claim-text>prevent the non-trusted virtual machine from reading the trusted virtual machine rendered graphics stored in the secure section of the graphics processing unit memory, responsive to receiving the second request,</claim-text>
<claim-text>receive a third request from the application to render a second set of graphical data using the graphics processing unit, the application generating the second set of graphical data, and</claim-text>
<claim-text>render graphics from the second set of graphical data to a section of the graphics processing unit memory not comprising the secure section of the graphics processing unit memory.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, further comprising an application executing on the trusted virtual machine generating the graphical data, and wherein the graphics manager is further configured to receive a request generated by the application.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the graphics manager is further configured to assign a policy to a range of memory addresses.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the graphics manager is further configured to:
<claim-text>identify a security credential of the non-trusted virtual machine, and</claim-text>
<claim-text>determine, based on the security credential, the non-trusted virtual machine does not have permission to access the secure section of the graphics processing unit memory.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the graphics manager is further configured to apply a policy of the secure section of the graphics processing unit memory to the security credential.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the graphics manager is further configured to store the rendered graphics to the secure section of the graphics processing unit memory.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the graphics manager is further configured to:
<claim-text>identify a security credential of the application executing on the non-trusted virtual machine,</claim-text>
<claim-text>determine, based on the security credential, the non-trusted virtual machine does not have permission to access the secure section of the graphics processing unit memory, and</claim-text>
<claim-text>prevent the graphics processing unit from rendering the graphics to the secure section of the graphics processing unit memory.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
