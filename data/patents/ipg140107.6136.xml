<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627260-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627260</doc-number>
<kind>B1</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13665800</doc-number>
<date>20121031</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>455</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>50</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>716132</main-classification>
<further-classification>716103</further-classification>
<further-classification>716104</further-classification>
<further-classification>716106</further-classification>
<further-classification>716136</further-classification>
</classification-national>
<invention-title id="d2e43">Bit-level simplification of word-level models</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>7222317</doc-number>
<kind>B1</kind>
<name>Mathur et al.</name>
<date>20070500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>716107</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>7343575</doc-number>
<kind>B2</kind>
<name>Bjesse et al.</name>
<date>20080300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>7512912</doc-number>
<kind>B1</kind>
<name>Iyer</name>
<date>20090300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>716136</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>7673257</doc-number>
<kind>B1</kind>
<name>Bains et al.</name>
<date>20100300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>716104</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>7890894</doc-number>
<kind>B2</kind>
<name>Bjesse et al.</name>
<date>20110200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>8001498</doc-number>
<kind>B2</kind>
<name>Bjesse</name>
<date>20110800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>8104000</doc-number>
<kind>B2</kind>
<name>Bjesse</name>
<date>20120100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>8122401</doc-number>
<kind>B1</kind>
<name>Chauhan et al.</name>
<date>20120200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>716107</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2002/0138812</doc-number>
<kind>A1</kind>
<name>Johannsen</name>
<date>20020900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>716  5</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2007/0016722</doc-number>
<kind>A1</kind>
<name>Lee et al.</name>
<date>20070100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711103</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2008/0134114</doc-number>
<kind>A1</kind>
<name>Bjesse et al.</name>
<date>20080600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2008/0144372</doc-number>
<kind>A1</kind>
<name>Lee et al.</name>
<date>20080600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>36518503</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2010/0077366</doc-number>
<kind>A1</kind>
<name>Bjesse</name>
<date>20100300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2010/0107132</doc-number>
<kind>A1</kind>
<name>Bjesse</name>
<date>20100400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>716  5</main-classification></classification-national>
</us-citation>
</us-references-cited>
<number-of-claims>27</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>716103</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>716104</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>716106</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>716136</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>10</number-of-drawing-sheets>
<number-of-figures>10</number-of-figures>
</figures>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only" applicant-authority-category="assignee">
<addressbook>
<orgname>Synopsys, Inc.</orgname>
<address>
<city>Mountain View</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Bjesse</last-name>
<first-name>Per Mattias</first-name>
<address>
<city>Portland</city>
<state>OR</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Adams Intellex, PLC</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Synopsys, Inc.</orgname>
<role>02</role>
<address>
<city>Mountain View</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Chiang</last-name>
<first-name>Jack</first-name>
<department>2825</department>
</primary-examiner>
<assistant-examiner>
<last-name>Ngo</last-name>
<first-name>Brian</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Computer implemented techniques for simplification of models are disclosed including various manipulations that are useful in logic analysis, verification, and re-synthesis. A high word-level representation is obtained along with a bit-level design representation. A map between the word-level representation and the bit-level representation is produced. Optimizations are performed on the bit-level representation with the results being lifted and included in the word-level representation, based on the map. Similar optimizations are performed on the word-level representation and translated to the bit-level representation.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="197.95mm" wi="270.43mm" file="US08627260-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="279.40mm" wi="215.90mm" orientation="landscape" file="US08627260-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="236.39mm" wi="197.95mm" orientation="landscape" file="US08627260-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="228.09mm" wi="193.04mm" orientation="landscape" file="US08627260-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="206.93mm" wi="184.74mm" orientation="landscape" file="US08627260-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="253.92mm" wi="200.91mm" orientation="landscape" file="US08627260-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="246.97mm" wi="189.06mm" orientation="landscape" file="US08627260-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="255.52mm" wi="194.99mm" orientation="landscape" file="US08627260-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="253.92mm" wi="198.63mm" orientation="landscape" file="US08627260-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="224.45mm" wi="180.09mm" orientation="landscape" file="US08627260-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="241.64mm" wi="186.01mm" orientation="landscape" file="US08627260-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">FIELD OF ART</heading>
<p id="p-0002" num="0001">This application relates generally to semiconductor circuits and more particularly to bit-level simplification of word-level models.</p>
<heading id="h-0002" level="1">BACKGROUND</heading>
<p id="p-0003" num="0002">Modern electronic systems are constructed from a variety of circuits based on digital, analog, and high frequency components. These systems are exceptionally complex, and therefore difficult and expensive to design. Two design approaches generally exist: top-down decomposition and bottom-up assembly of constituent components. Feature sizes of the components comprising such electronic systems are now routinely smaller than the wavelength of visible light. In addition, rapid market changes drive ever-increasing demand for performance, advanced feature sets, system versatility, and a variety of other system requirements. These demands often introduce contradictory design requirements into the design process. Logic systems are routinely constructed from tens or hundreds of millions of transistors. System designers are required to make significant tradeoffs in performance, physical size, architectural complexity, power consumption, heat dissipation, fabrication complexity, and cost, to name a few. Each design decision exercises a profound influence on the resulting electronic system. To handle such electronic system complexity, designers create specifications around which to design their electronic systems. The specifications attempt to balance the many disparate demands being made of the electronic systems to contain the exploding design complexity.</p>
<p id="p-0004" num="0003">Logic system designers develop a system specification to which proposed designs must conform. Comparison of proposed designs to the specification helps ensure that the designs meet critical system objectives. This process of comparison is called verification. Logic systems may be described at a variety of levels of abstraction, from low-level transistor layouts to high-level description languages. Most designers describe and design their electronic systems at a high-level of abstraction using an IEEE Standard hardware description language (HDL) such as Verilog&#x2122;, SystemVerilog&#x2122;, or VHDL&#x2122;. The high-level HDL is easier for designers to understand, especially for a vast system, and may describe highly complex concepts that are difficult to grasp using a lower level of abstraction. The HDL description may be converted into any of the other levels of abstraction that is helpful to the developers. For example, a high-level description may be converted to a logic-level description (RTL), a gate-level (GL) description, a layout-level description, or a mask-level description. Each lower level of abstraction introduces more detail into the design description. The lower-levels of abstraction may be generated automatically by computer, derived from a design library, or created by another design automation technique. Ultimately, it is critical to ensure that the performance of the resulting lower-level designs is still capable of matching the requirements of the system specification and still provides the desired logic function.</p>
<heading id="h-0003" level="1">SUMMARY</heading>
<p id="p-0005" num="0004">Techniques implemented to prove correctness of electronic system designs are required to rewrite and manipulate models in order to simplify them by removing redundancy and merging internal equivalence points. Further, the computationally costly proving process must minimize proof duration and computational resource utilization. A computer-implemented method for design analysis is disclosed comprising: obtaining a high-level design which includes a word-level representation; obtaining a bit-level representation of the high-level design; determining a map between the word-level representation and the bit-level representation; optimizing the bit-level representation; and lifting results from the optimizing of the bit-level representation and including the results in the word-level representation based on the map.</p>
<p id="p-0006" num="0005">The obtaining a bit-level design representation may comprise translating the word-level representation of the high-level design. The method may further comprise maintaining the map between the word-level representation and the bit-level representation. The optimizing may further comprise removing redundancy. The lifting of the results from the optimizing of the bit-level representation may include creating an isomorph of the bit-level representation within the word-level representation. Creating the isomorph may comprise taking constants from the bit-level representation and using those constants in the word-level representation. Creating the isomorph may comprise identifying nets from the bit-level representation that are merged, mapping bit-level nets that are merged to corresponding nets within the word-level representation, and merging the corresponding nets within the word-level representation. The method may further comprise optimizing the word-level representation. The method may further comprise translating the optimizing of the word-level representation onto the bit-level representation. The method may further comprise iterating between the optimizing the bit-level representation, the lifting the results from the optimizing of the bit-level representation, the optimizing the word-level representation, and translating the optimizing of the word-level representation onto the bit-level representation. The optimizing of the word-level representation may include re-writing an expression to simplify an equation. The re-writing may include removing redundancy in the word-level representation. The re-writing may include merging an internal equivalence point. The re-writing may include substituting a section of the word-level representation with a section from the bit-level representation. The high-level design may include a datapath. Superfluous terms of the bit-level representation may be removed from the word-level representation. The word-level representation may be rebalanced using mathematical identities to identify equivalences in bit-level equations of the bit-level representation. Bit-level equations of the bit-level representation may be solved to find constant values. Bit-level equations of the bit-level representation may be solved to find equivalences. The method may further comprise implementing a semiconductor design based on the lifting. The method may further comprise evaluating the bit-level representation and the word-level representation for equivalence.</p>
<p id="p-0007" num="0006">In embodiments, a computer system for design analysis may comprise: a memory which stores instructions; one or more processors coupled to the memory wherein the one or more processors are configured to: obtain a high-level design which includes a word-level representation; obtain a bit-level representation of the high-level design; determine a map between the word-level representation and the bit-level representation; optimize the bit-level representation; and lift results from the optimizing of the bit-level representation and including the results in the word-level representation based on the map. In some embodiments, a computer program product embodied in a non-transitory computer readable medium for design simulation comprising: code for obtaining a high-level design which includes a word-level representation; code for obtaining a bit-level representation of the high-level design; code for determining a map between the word-level representation and the bit-level representation; code for optimizing the bit-level representation; and code for lifting results from the optimizing of the bit-level representation and including the results in the word-level representation based on the map.</p>
<p id="p-0008" num="0007">Various features, aspects, and advantages of various embodiments will become more apparent from the following further description.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0009" num="0008">The following detailed description of certain embodiments may be understood by reference to the following figures wherein:</p>
<p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. 1</figref> is a flow diagram for bit-level simplification.</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 2</figref> is a flow diagram for bit-level optimization.</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 3</figref> is a flow diagram for word-level optimization.</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 4</figref> is a diagram showing optimizing and mapping.</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 5</figref> is an example diagram of a top-level problem.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 6</figref> is an example table showing bit mappings.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 7</figref> is an example diagram with reduction due to bit-level constant.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 8</figref> is an example diagram with word-level model rewriting.</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 9</figref> is an example diagram with equivalence detected.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 10</figref> is a system diagram for bit-level and word-level manipulation.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0020" num="0019">The design process for complex semiconductors includes numerous logic manipulations as well as thorough verification capabilities. The verification of modern electronic systems requires that a device under test (DUT) be simulated to the extent that the behavior of the DUT may be shown to match a specification for the electronic system. Part of this effort may involve optimization of various logic abstractions and then re-synthesis of the resulting logic implementation.</p>
<p id="p-0021" num="0020">The verification process includes several tasks including estimation, simulation, and proof of correctness. Therefore, models of electronic systems are typically both written and manipulated at a high level. Attempts to prove the correctness of datapath-dominated designs include having word-level models describing the DUT be rewritten to render the problem in a simpler and more computationally efficient manner. Superfluous terms in a model, however, can render rules for rewriting as inapplicable. Therefore, extraneous terms should be removed before the rewrite rules are applied. This need renders removing redundancies and locating/merging internal equivalence points as critical modeling steps. Both the removing and locating steps are highly complex and costly from a computation perspective. Therefore, new, more efficient techniques which significantly reduce complexity and cost are therefore desired.</p>
<p id="p-0022" num="0021">The disclosed concept includes rewriting of word-level models for datapath-dominated electronic designs in order to simplify the problem. Redundant term removal can be performed and internal equivalence points identified and merged. To remove unneeded terms and merge internal equivalence points, the word-level problem is translated to a bit-level problem. After this translation, maps can be maintained between the two models. High-speed rewriting and redundancy removal are performed on the bit-level model, and the results of the bit-level rewriting and redundancy removal are lifted up to the word-level model. An isomorphic word-level design can be created to aid in this process. If multiple components of the word-level model are mapped to the same bit-level nets, on a bit for bit basis, then those components can be merged. Additionally, if it is discovered that components of the bit-level model resolve to a constant, then the corresponding word-level components receive constant values as well. In this manner, word-level rewriting, and other word-level analysis, follows model rewriting and simplification at the bit-level. Similar optimizations at the word level can be translated down to a bit-level representation. The bit-level representation can then be further optimized and the result lifted to the word-level representation. In this manner bit-level representations and word-level representations can be iterated and further improved in a quick fashion.</p>
<p id="p-0023" num="0022">Computational efficiency is critical to effective logic manipulation and proof of correctness for system designs, particularly when those designs are datapath dominated. Superfluous terms often appear in a system model, preventing the application of model rewrite rules. Therefore, it is necessary to remove model redundancy and to merge internal equivalence points so that rewriting becomes possible. However, redundancy removal and equivalence point merging is very costly. Instead, a word-level problem may be translated to a bit-level problem while maintaining maps between the two models. To achieve this congruency of models, high-speed rewriting and redundancy removal procedures are applied to simplify the bit-level model. Afterwards, the result may be applied to the word level model, forming a word-level model optimized with results lifted from the bit level model. In some cases an isomorphic word-level design is created, except for where components are merged or a constant value is replaced or some other optimization is identified on the bit level. Following bit-level simplification and lifting corresponding changes up to the word-level, word-level rewriting and other word-level analysis may proceed.</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 1</figref> is a flow diagram for bit-level simplification. A flow <b>100</b> is described for bit-level simplification of word-level models. The flow <b>100</b> may describe a computer-implemented method for design analysis. The flow <b>100</b> includes obtaining a high-level design <b>110</b> which includes a word-level representation. The high-level representation that is obtained may comprise a word-level design written in any of a variety of languages, including Verilog&#x2122;, VHDL&#x2122;, SystemVerilog&#x2122;, SystemC&#x2122;, or other language. In many cases the high-level design includes a datapath.</p>
<p id="p-0025" num="0024">The flow <b>100</b> may include translating <b>112</b> the obtained design representation to a bit-level representation. The translation <b>112</b> may take as input an obtained representation and may produce a bit-level representation. Bits of a bit-level representation may be assigned to correspond to input variables of a word-level representation. For example, individual bits of a bit-level representation may be assigned to individual, single-bit variables of a word-level representation. Similarly, multiple bits of a bit-level representation may be assigned to multiple-bit variables of a word-level representation. The bit mappings, in many cases, are unique.</p>
<p id="p-0026" num="0025">The flow <b>100</b> includes obtaining a bit-level representation <b>114</b> of the high-level design. The bit-level representation can be obtained from a representation stored in memory, generated by an EDA tool, written directly in a bit-level language, and so on. The obtaining of a bit-level design representation <b>114</b> may comprise translating the word-level representation of the high-level design. In other embodiments, a bit-level representation can be obtained by translation of a high-level representation written in, for example, an IEEE Standard HDL or other high-level language convenient to modeling.</p>
<p id="p-0027" num="0026">The flow <b>100</b> includes determining a map <b>120</b> between the word-level representation and the bit-level representation. A map can indicate relationships between bits of a bit-level model and a word-level model, relationships between logic gates and logic blocks, and so on. A map can also indicate which portions of a word-level representation correspond to which portions of a bit-level representation. In addition to determining a map, the flow <b>100</b> includes maintaining the map <b>122</b> between the word-level representation and the bit-level representation. Maintaining a map <b>122</b> can be important given bit-level simplifications and manipulation, word-level simplifications and manipulations, and so on.</p>
<p id="p-0028" num="0027">The flow <b>100</b> continues with optimizing the bit-level representation <b>130</b> and may comprise bit-level rewriting. Optimization of a bit-level representation may further comprise redundancy removal. Any techniques appropriate to bit-level simplification may be applied. Optimization may be performed repeatedly as a result of iteration <b>164</b>.</p>
<p id="p-0029" num="0028">The flow <b>100</b> continues with lifting results <b>140</b> from the optimization of the bit-level representation. Simplifications performed on a bit-level model are lifted up in such a way that simplifications may be applied to a word-level representation and may be based on the mapping. The uplifting may include results from rewriting, redundancy removal, internal equivalence merging, and the like. The lifting of the results <b>140</b> from the optimizing of the bit-level representation may include creating a lifted version of the model or an isomorph <b>142</b>, or something similar to an isomorph, of the bit-level representation within the word-level representation. The result created in the word-level representation may have components which are merged or a constant value which is replaced or some other optimization that is identified.</p>
<p id="p-0030" num="0029">The lifted version may be a model of a word-level representation and may be further simplified as part of an optimization process. The creating of the lifted version may comprise taking constants from the bit-level representation and using those constants in the word-level representation. An optimization may comprise further rewriting, redundancy removal, merging of internal equivalence points, and the like. Nets from the bit-level representation may be identified and merged with a mapping of the bit-level nets to the corresponding nets within the word-level representation with merging the corresponding nets <b>144</b> within the word-level representation. The optimization may further comprise identifying improvements, mapping, and merging of redundancies <b>144</b>.</p>
<p id="p-0031" num="0030">The flow <b>100</b> continues with including results in the word-level representation <b>150</b> based on the map. Results from high-speed rewriting and redundancy removal at a bit-level and that were lifted up to a word-level may be applied to a word-level representation. For example, constants that are discovered in a bit-level representation may be lifted up to a word-level representation where word-level variables corresponding to bit-level constants are similarly set to constants.</p>
<p id="p-0032" num="0031">The flow <b>100</b> continues with optimizing the word-level representation <b>160</b>. Various rewriting rules may be applied to a word-level representation in order to simplify the word-level representation. In some cases superfluous terms of the word-level model are removed from the word-level model. Further, optimization techniques may be applied to aid in other objectives, examples including but not limited to computational optimization, evaluation of equivalence, and the like. In embodiments, mathematical properties are applied to rewriting and optimization. For example, the commutative property of multiplication may be applied to reorder variables in order to make computation of equivalence simpler. Results of the optimization of a word-level representation may be translated onto a bit-level representation <b>162</b>. The resulting bit-level representation may be analyzed for simplification, rewriting, and the like. Further, the resulting bit-level representation may assist in evaluation for equivalence. The flow <b>100</b> may further comprise iterating <b>164</b> between the optimizing the bit-level representation, the lifting the results from the optimizing of the bit-level representation, the optimizing the word-level representation, and translating the optimizing of the word-level representation onto the bit-level representation. Iteration <b>164</b> may further assist model simplification, rewriting, optimization, and the like. Iteration may not occur for some simplification functions, while for others it may occur one or more times.</p>
<p id="p-0033" num="0032">The flow <b>100</b> may continue with evaluating the bit-level representation and the word-level representation for equivalence <b>170</b> where the equivalence may be part of a verification process. In many cases the bit-level representation and word-level representation are equivalent on a correct by construction basis. Therefore, in many embodiments equivalence checking is not needed at this point in the flow <b>100</b>. However, significant changes may have been made to a bit-level representation as a result of rewriting, redundancy removal, internal equivalence point merging, simplification, identification of constants, and the like. Similarly, a word-level representation may have undergone significant changes as a result of the lifting up of the results from a bit-level representation to a word-level representation. Thus equivalence between representations may be useful to the design process. Equivalence may be evaluated in a variety of ways including bit-level equivalence, word-level equivalence, high-level equivalence, and the like. The flow <b>100</b> may continue with implementing a semiconductor design based on the lifting. Various steps in the flow <b>100</b> may be changed in order, repeated, omitted, or the like without departing from the disclosed inventive concepts. Various embodiments of the flow <b>100</b> may be included in a computer program product embodied in a non-transitory computer readable medium that includes code executable by one or more processors.</p>
<p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. 2</figref> is a flow diagram for bit-level optimization. A flow <b>200</b> may continue from or be part of the previously described flow <b>100</b>. In some embodiments, the flow <b>200</b> stands on its own and works from pre-existing bit-level representations, system designs, and the like. The flow <b>200</b> begins with optimizing a bit-level representation <b>210</b> by various techniques. Optimization of a bit-level representation may involve a variety of operations including high-speed rewriting, redundancy removal, merging internal equivalence points, identification of constants, and the like. High-speed rewriting can include taking a normalized bit-level representation and applying rules for analyzing the bit-level representation. These rules can identify representation manipulations that are quickly and repeated performed. By way of example, a high-speed rewriting rule can look down through two levels of hierarchy to rearrange operands frequently encountered. Numerous other high-speed rewriting rules are possible and frequently beneficial. In order to undertake optimization of a bit-level representation, various other analysis steps may be taken.</p>
<p id="p-0035" num="0034">The flow <b>200</b> may include finding equivalence <b>212</b>. For example, internal model equivalence points may be found <b>212</b> as part of the analysis of a bit-level model. If such points are identified, data about the points may be used to optimize a bit-level representation. The flow <b>200</b> may include finding constants <b>214</b>. In embodiments, bit-level equations of a bit-level representation are solved to find constant values <b>214</b>. If such constants are identified, data about the constants may be used to optimize a bit-level representation by removing logic a constant has caused to be ignored. The flow <b>200</b> may include removing redundancy <b>216</b>. For example, portions of a bit-level representation may be identified to be redundant as a result of analysis, simplification, and the like. If such redundancy is identified, data about the redundancies may be used to optimize a bit-level representation by removing logic found to be redundant. The flow <b>200</b> may include finding other factors <b>218</b> where the other factors might include identifying portions of logic that may be inactive due to an idle or disabled clock. If such logic is identified, data about the logic may be used to optimize a bit-level representation by removing logic found to be inactive, for example. Further, the bit-level representation may be analyzed from a graph perspective. A portion of the graph, or sub-graph, may be simplified and this simplification included in the bit-level representation. Various steps in the flow <b>200</b> may be changed in order, repeated, omitted, or the like without departing from the disclosed inventive concepts. Various embodiments of the flow <b>200</b> may be included in a computer program product embodied in a non-transitory computer readable medium that includes code executable by one or more processors.</p>
<p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. 3</figref> is a flow diagram for word-level optimization <b>300</b>. A flow <b>300</b> may continue from or be part of the previously described flow <b>100</b>. In some embodiments, the flow <b>300</b> stands on its own and works from pre-existing word-level representations, system designs, and the like. A flow <b>300</b> begins with optimizing the word-level representation <b>320</b>. Optimization of a word-level representation may involve a variety of operations. In order to accomplish the optimization of a bit-level representation, various analysis steps may be taken.</p>
<p id="p-0037" num="0036">The flow <b>300</b> may include rewriting an expression <b>310</b> to simplify an equation. In embodiments, various logic minimization techniques such as the Quine-McCluskey algorithm are used to rewrite logic functions of a word-level representation. The flow <b>300</b> may include removing redundancy <b>312</b> in the word-level representation. In embodiments, the optimization of a word-level representation seeks for constant variables. When, in embodiments, constant variables are found, expressions that use a constant are simplified, removed, or otherwise manipulated. The flow <b>300</b> may include rebalancing <b>314</b>. In embodiments, the word-level representation can be rebalanced <b>314</b> using mathematical identities to identify equivalences in the bit-level equations of the bit-level representation. For example, the commutative property of multiplication may be applied to reorder variables in an expression, and the like. The equivalences in the bit-level representation may then be lifted up to the word-level representation to aid with the rebalancing of the word-level representation. The flow <b>300</b> may include merging an internal equivalence point <b>318</b>. When components of a word-level representation may be mapped to the same bit-level nets for all bits, the components may be merged and a simplified word-level representation may be achieved. The flow <b>300</b> may include substituting <b>316</b> a section of the word-level representation with a section from the bit-level representation. Thus, a section of the bit-level representation can be lifted from the bit-level representation into the word-level representation and replace that section. Such replacement can be based on the mapping between the bit-level representation and the word-level representation.</p>
<p id="p-0038" num="0037">The flow <b>300</b> continues with translating the optimizing of the word-level representation <b>330</b> onto the bit-level representation. The translating may comprise assigning bits of a bit-level representation to each variable of a word-level model. Bits of a bit-level model may be associated with bits and varying width words, for example, of a word level model. Bits of a bit-level model may map uniquely to variables of a word-level model. Various steps in the flow <b>300</b> may be changed in order, repeated, omitted, or the like without departing from the disclosed inventive concepts. Various embodiments of the flow <b>300</b> may be included in a computer program product embodied in a non-transitory computer readable medium that includes code executable by one or more processors.</p>
<p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. 4</figref> is a diagram showing optimizing and mapping. A designer may start with a behavioral-level model <b>410</b> using VHDL&#x2122;, Verilog&#x2122;, SystemVerilog&#x2122;, SystemC&#x2122;, or some other language. A word-level model <b>420</b> may be generated from the behavioral-level model <b>410</b> using various design automation tools. A bit-level model <b>430</b> may be generated from the word-level model <b>420</b> using various design automation tools. In some cases the word-level model <b>420</b> can be generated on its own by designers or may be derived from the bit-level model <b>410</b>. In some cases the bit-level model <b>430</b> can be generated on its own by designers. Verification can involve checking the behavioral-level model <b>410</b> against the word-level model <b>420</b> to see that the two models match. Verification can involve checking the word-level model <b>420</b> against the bit-level model <b>420</b> to see that the two models match. Because of the different characteristics of the different levels of abstraction, different optimization techniques can be used at each level. In the disclosed concept, optimization of the bit-level model <b>432</b> is performed. A mapping is maintained <b>440</b> between the bit-level model <b>430</b> and the word-level model <b>420</b>. For the bits in the bit-level model <b>430</b>, corresponding words or bits are identified in the word-level model <b>420</b>. Changes to the bit-level model <b>430</b> are lifted (or translated) to the word-level model <b>420</b>. Thus, optimizations at the bit-level are incorporated to the word-level. Likewise, optimization of the word-level model <b>422</b> can be performed. The mapping between the bit-level model <b>430</b> and the word-level model <b>420</b> can similarly be used to translate changes to the word-level model <b>420</b> to the bit-level model <b>430</b>. The optimizing can include equivalence identification, logic reduction, Boolean analysis, constant evaluation, and other types of logic and circuit optimization. By optimizing at the bit-level model and word-level model levels and then reflecting changes to the other level through the mapping to the other level optimization and re-synthesis can be significantly improved.</p>
<p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. 5</figref> is an example diagram of a top-level problem <b>500</b>. The top-level problem <b>500</b> is illustrative of some of the types of optimizations that can be applied to a word-level model and similar rearrangements are also possible for bit-level models. The example top-level model <b>500</b> can be a high-level model written, for example, in an IEEE Standard HDL such as Verilog&#x2122;, SystemVerilog&#x2122;, or VHDL&#x2122; including descriptions of a system structure and function. <figref idref="DRAWINGS">FIG. 6</figref> provides a mapping while <figref idref="DRAWINGS">FIGS. 7 through 9</figref> provide example manipulations that are exemplary but are not shown by way of limitation.</p>
<p id="p-0041" num="0040">The example top-level problem <b>500</b> is shown in which the equivalence of models is evaluated. A model on the left-hand side <b>502</b> may represent any model including a detailed system design, while the model on the right-hand side <b>504</b> may show a simplified model, a reference model, a model generated by an EDA tools, and the like, against which equivalence is to be evaluated. The objective of the problem <b>500</b> is to determine whether the left hand model <b>502</b> is equivalent to the right hand model <b>504</b>. This problem <b>500</b> may be part of a verification procedure.</p>
<p id="p-0042" num="0041">In embodiments, a bit-level design (not shown) may be obtained for analysis as part of the equivalence determination. The obtaining of a bit-level design representation may comprise translating the word-level representation of the high-level design. The bit-level representation could include each gate and each net connection between the gates.</p>
<p id="p-0043" num="0042">The left-hand side <b>502</b> of example <b>500</b> may show a model comprising logic, while the right-hand side <b>504</b> may show a word-level model. In embodiments, both the left-hand side <b>502</b> and the right-hand side <b>504</b> may be word-level representations. In some cases the right-hand side <b>504</b> can be a behavioral description. In this situation the left-hand side <b>502</b>, a word-level representation, would be compared against the right-hand side <b>504</b> the behavioral description. Equivalence could be checked between these two representations.</p>
<p id="p-0044" num="0043">Any appropriate abstraction can be used on either a left-hand side <b>502</b> or a right-hand side <b>504</b>. Beginning with the left-hand side <b>502</b>, there are various inputs. Inputs may be bits, words, strings, or any other appropriate input to a given model. For example, bit inputs IO(<b>1</b>) <b>510</b> and I<b>1</b>(<b>1</b>) <b>512</b> may be single-bit inputs to logic gates. 32-bit word inputs A <b>522</b> and B <b>524</b> may represent inputs to a logic block such as a Multiplier <b>520</b>. Any appropriate width word inputs may be provided to the logic. An output <b>582</b> of logic and an output <b>580</b> of other logic is connected to other logic including a MUX <b>530</b>. In this example, the logic output <b>582</b> is connected to a control input of a multiplexer the MUX <b>530</b> and the output <b>580</b> of other logic connected to another side's input of the MUX <b>530</b>. The MUX <b>530</b>, in this case, represents a 32-bit wide set of multiplexors where one 32-bit word or the other 32-bit word is selected for propagation. Another 32-bit word input D <b>532</b> is connected to the other side input of a MUX <b>530</b>. In the example shown, the output <b>582</b> of combinational logic <b>582</b> is always true based on the AND-Inverter-OR gate combination. As a result, one side of the multiplexer <b>530</b> is always selected. The model <b>502</b> can be simplified as a result which reduces the complexity of the model. For the example shown, input D <b>532</b> cannot be selected based on the control logic feeding the MUX <b>530</b> selector input. Continuing, the 32-bit wide output of MUX <b>530</b> is connected to an input to a Multiplier <b>550</b>. Another input to the Multiplier <b>550</b> is a 32-bit wide word input C <b>552</b>. An output <b>585</b> of the Multiplier <b>550</b> is connected to an input of an equality evaluator Equal <b>570</b>. In this case the Equal <b>570</b> function is a verification capability abstraction within a design automation tool rather than a logic component configuration. The signal <b>584</b> may be compared for equality with another signal <b>586</b>, which is the output of right-hand side <b>504</b>.</p>
<p id="p-0045" num="0044">Continuing, the right-hand side <b>504</b> of the example problem <b>500</b> may show a model to which equality is to be demonstrated. There are inputs to various elements of the right-hand model <b>504</b>. Inputs may be bits, words, strings, and any other input appropriate to a given model. For example, word inputs A <b>552</b> and B <b>544</b> represent 32-bit inputs to a logic block such as Multiplier <b>550</b>. In this case input A <b>542</b> is the same as input A <b>522</b> previously discussed. An output of the Multiplier <b>540</b> is connected to a Multiplier <b>560</b>. Another word input B <b>562</b> is connected to the Multiplier <b>560</b>. An output <b>586</b> of the Multiplier <b>560</b> is connected to an input of the equivalence calculator Equal <b>570</b>. In the example given, if the signal <b>584</b> is calculated to be equivalent to the signal <b>586</b> then the two sides of the problem <b>500</b> are equivalent.</p>
<p id="p-0046" num="0045"><figref idref="DRAWINGS">FIG. 6</figref> is an example table <b>600</b> showing word-level to bit-level mappings. A high-level model may be obtained, and include signals comprising, bits and words. By mapping between a word-level model and a bit-level model optimizations in one level may be translated to the other level. In many cases the bit-level model will be derived from a word-level model where the word-level model was used to generate a corresponding bit-level model using a design automation tool. Each variable in a word-level model may be assigned signals in a bit-level model. <figref idref="DRAWINGS">FIG. 6</figref> shows an example table which represents a mapping between variables of a word-level model and bits of a bit-level model. A single-bit variable, I<b>0</b>(<b>1</b>) is associated with a bit BIT_<b>0</b>. Another single-bit variable I<b>1</b>(<b>1</b>) is associated with a bit BIT_<b>1</b>, and so on. Multi-bit variables of a word-level model are associated with multiple bits in a bit-level model. For example, a variable in a word-level model such as A(<b>32</b>) is assigned bits in a bit-level model, such as BIT_<b>5</b>, BIT_<b>6</b>, . . . BIT_<b>36</b>. Continuing, outputs of logic in a word-level model are represented by bits in the bit-level model. For example, &#x201c;Output Of And Gate&#x201d; in the word-level model maps to BIT_<b>2</b> in the bit-level model, where BIT_<b>2</b>=BIT_<b>0</b>&#xb7;BIT_<b>1</b>. Each variable of the word-level model may similarly map to a bit or a plurality of bits in the bit-level model.</p>
<p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. 7</figref> is an example diagram with reduction. The top level problem <b>700</b> is a reduction from the previous top level problem <b>500</b>. The reduction can be accomplished due to a bit-level constant, as will be seen. Equations may be solved to find constant values and resulting logic optimizations may be produced. Solving bit-level equations may reveal constants, redundancies, simplifications, and the like. Any simplifications found at one level may be translated to another level with resulting simplification. In <figref idref="DRAWINGS">FIG. 5</figref>, for example, a selection signal input to the Multiplexer <b>530</b> was discovered to be a constant. The AND-Inverter-OR combination resulted in signal <b>582</b> to always be in the &#x201c;1&#x201d; state. Based on this constant value, the AND-Inverter-OR combination as well as the MUX <b>530</b> could be removed. This type reduction could be a good example of bit-level representation reduction. The reduction could then be translated to a corresponding word-level representation model.</p>
<p id="p-0048" num="0047">Based on the reduction in logic, left-hand side <b>502</b> from the previous top level model <b>500</b> becomes a new left-hand side <b>702</b>. While left-hand side <b>702</b> does not match right-hand side <b>704</b>, the logic arrangement can be seen to be similar. For the left-hand side <b>702</b> 32-bit wide inputs A <b>712</b> and B <b>714</b> are connected to a Multiplier <b>710</b> with a corresponding output going into a Multiplier <b>730</b>. The other input to Multiplier <b>730</b> is a 32-bit wide input C <b>732</b>. On the right-hand side <b>704</b>, 32-bit wide inputs A <b>722</b> and C <b>724</b> are connected to a Multiplier <b>720</b> with a corresponding output going into a Multiplier <b>740</b>. The other input to Multiplier <b>740</b> is a 32-bit wide input B <b>742</b>. The output of the multiplier <b>730</b>, signals <b>770</b>, are evaluated for equivalence to signals <b>762</b> using the Equal <b>750</b> abstraction, similar to that described earlier in <figref idref="DRAWINGS">FIG. 5</figref>.</p>
<p id="p-0049" num="0048"><figref idref="DRAWINGS">FIG. 8</figref> is an example diagram with word-level model rewriting <b>800</b>. The top level problem <b>800</b> is a rearrangement from the previous top level problem <b>700</b>. A left-hand side <b>802</b> and a right-hand side <b>804</b> are shown where equivalence is being checked through an Equal <b>850</b> abstraction using signals <b>860</b> and signals <b>862</b>. In the previous left-hand side <b>702</b>, (A*B)*C was shown using Multiplier <b>710</b> and Multiplier <b>730</b>. In the same manner (A*B)*C is now shown using Multiplier <b>810</b> and Multiplier <b>830</b>. The A <b>812</b>, B <b>814</b>, and C <b>832</b> inputs are each 32 bit-wide words. In the previous right-hand side <b>704</b>, (A*C)*B was shown using Multiplier <b>720</b> and Multiplier <b>740</b>. Now the right-hand side <b>804</b> word-level representation has been rearranged to by (A*B)*C using Multiplier <b>820</b> and Multiplier <b>840</b>. The A <b>822</b>, B <b>824</b>, and C <b>842</b> inputs are each 32 bit-wide words and this case correspond to the A <b>812</b>, B <b>814</b>, and C <b>832</b> inputs. The rearrangement is an example and is based on the commutative properties of multiplication. Other similar types of rearrangements are possible. By performing this rearrangement of the right-hand side <b>804</b>, the left-hand side <b>802</b> and the right-hand side <b>804</b> become isomorphic representations. In the case of top level problem <b>800</b>, the left-hand side <b>802</b> and right-hand side <b>804</b> are word-level isomorphs. When a bit-level model and a word-level model are being manipulated a lifted version representation can similarly be created between the bit-level representation and the word-level representation.</p>
<p id="p-0050" num="0049"><figref idref="DRAWINGS">FIG. 9</figref> is an example diagram with equivalence detected. An example <b>900</b> is shown in which the previous left-hand side <b>802</b> and the previous right-hand side <b>804</b> are shown to be equivalent. A <b>32</b>-bit wide word A <b>912</b> input and a 32-bit wide word B input <b>914</b> are applied to Multiplier <b>910</b>. A <b>32</b>-bit wide word C <b>922</b> is multiplied with the resulting word using Multiplier <b>920</b>. The signals <b>860</b> and signals <b>862</b> are abstracted to be signals <b>940</b> and signals <b>942</b> which are actually the same signals resulting in a detected equivalence using the Equal <b>930</b> abstraction.</p>
<p id="p-0051" num="0050"><figref idref="DRAWINGS">FIG. 10</figref> is a system diagram for bit-level and word-level manipulation. A system <b>1000</b> may comprise one or more processors <b>1010</b> coupled to a memory <b>1012</b> and a display <b>1014</b>. The one or more processors <b>1010</b> may be coupled to a representation manipulation module <b>1030</b>, a mapping module <b>1040</b>, and an equivalence evaluation module <b>1050</b>. In at least one embodiment, the one or more processors <b>1010</b> may accomplish the representation manipulation, mapping, and equivalence evaluation functions. The one or more processors may access a design information storage <b>1020</b> that includes a high-level design. The one or more processors <b>1010</b> may be configured to obtain a high-level design which includes a word-level representation, obtain a bit-level representation of the high-level design, determine a map between the word-level representation and the bit-level representation, optimize the bit-level representation, lift results from the optimizing of the bit-level representation, and including the results in the word-level representation based on the map. The word-level representation may be rendered in an IEEE Standard hardware description language (HDL) such as Verilog&#x2122;, SystemVerilog&#x2122;, and VHDL&#x2122;. A bit-level representation may be obtained, may be generated from the word-level representation, may be derived by a design tool, or may be otherwise procured. The word-level and bit-level representations may be manipulated to remove superfluous terms, remove redundancy, rewrite a model, and the like. The system <b>1000</b> may be configured to determine a mapping <b>1040</b> representation between the bit-level representation and the word-level representation <b>1030</b>. A lifted model may be created wherein components which are mapped to the same bit-level nets for all bits may be merged, and where word-level signals with a bit-level implementation which has been discovered to be constant may receive word-level constant values. The system <b>1000</b> may be configured to evaluate equivalence. Equivalence may be determined between a word-level model and an isomorphic word-level model which has been simplified, and the like. In embodiments, the determining of equivalence is used for simplifying models.</p>
<p id="p-0052" num="0051">The one or more processors <b>1010</b> may be coupled to the memory <b>1012</b> which stores design data, instructions, system support data, intermediate data, analysis results, and the like. The one or more processors <b>1010</b> may be coupled to an electronic display <b>1014</b>. The display <b>1014</b> may be any electronic display, including but not limited to, a computer display, a laptop screen, a net-book screen, a tablet computer screen, a cell phone display, a mobile device display, a remote with a display, a television, a projector, or the like.</p>
<p id="p-0053" num="0052">The system <b>1000</b> may include a computer program product. The computer program product may comprise code for obtaining a high-level design which includes a word-level representation; code for obtaining a bit-level representation of the high-level design; code for determining a map between the word-level representation and the bit-level representation; code for optimizing the bit-level representation; and code for lifting results from the optimizing of the bit-level representation and including the results in the word-level representation based on the map.</p>
<p id="p-0054" num="0053">Each of the above methods may be executed on one or more processors on one or more computer systems. Embodiments may include various forms of distributed computing, client/server computing, and cloud based computing. Further, it will be understood that the depicted steps or boxes contained in this disclosure's flow charts are solely illustrative and explanatory. The steps may be modified, omitted, repeated, or re-ordered without departing from the scope of this disclosure. Further, each step may contain one or more sub-steps. While the foregoing drawings and description set forth functional aspects of the disclosed systems, no particular implementation or arrangement of software and/or hardware should be inferred from these descriptions unless explicitly stated or otherwise clear from the context. All such arrangements of software and/or hardware are intended to fall within the scope of this disclosure.</p>
<p id="p-0055" num="0054">The block diagrams and flowchart illustrations depict methods, apparatus, systems, and computer program products. The elements and combinations of elements in the block diagrams and flow diagrams, show functions, steps, or groups of steps of the methods, apparatus, systems, computer program products and/or computer-implemented methods. Any and all such functions&#x2014;generally referred to herein as a &#x201c;circuit,&#x201d; &#x201c;module,&#x201d; or &#x201c;system&#x201d; &#x2014;may be implemented by computer program instructions, by special-purpose hardware-based computer systems, by combinations of special purpose hardware and computer instructions, by combinations of general purpose hardware and computer instructions, and so on.</p>
<p id="p-0056" num="0055">A programmable apparatus which executes any of the above mentioned computer program products or computer-implemented methods may include one or more microprocessors, microcontrollers, embedded microcontrollers, programmable digital signal processors, programmable devices, programmable gate arrays, programmable array logic, memory devices, application specific integrated circuits, or the like. Each may be suitably employed or configured to process computer program instructions, execute computer logic, store computer data, and so on.</p>
<p id="p-0057" num="0056">It will be understood that a computer may include a computer program product from a computer-readable storage medium and that this medium may be internal or external, removable and replaceable, or fixed. In addition, a computer may include a Basic Input/Output System (BIOS), firmware, an operating system, a database, or the like that may include, interface with, or support the software and hardware described herein.</p>
<p id="p-0058" num="0057">Embodiments of the present invention are neither limited to conventional computer applications nor the programmable apparatus that run them. To illustrate: the embodiments of the presently claimed invention could include an optical computer, quantum computer, analog computer, or the like. A computer program may be loaded onto a computer to produce a particular machine that may perform any and all of the depicted functions. This particular machine provides a means for carrying out any and all of the depicted functions.</p>
<p id="p-0059" num="0058">Any combination of one or more computer readable media may be utilized including but not limited to: a non-transitory computer readable medium for storage; an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor computer readable storage medium or any suitable combination of the foregoing; a portable computer diskette; a hard disk; a random access memory (RAM); a read-only memory (ROM), an erasable programmable read-only memory (EPROM, Flash, MRAM, FeRAM, or phase change memory); an optical fiber; a portable compact disc; an optical storage device; a magnetic storage device; or any suitable combination of the foregoing. In the context of this document, a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system, apparatus, or device.</p>
<p id="p-0060" num="0059">It will be appreciated that computer program instructions may include computer executable code. A variety of languages for expressing computer program instructions may include without limitation C, C++, Java, JavaScript&#x2122;, ActionScript&#x2122;, assembly language, Lisp, Perl, Tcl, Python, Ruby, hardware description languages, database programming languages, functional programming languages, imperative programming languages, and so on. In embodiments, computer program instructions are stored, compiled, or interpreted to run on a computer, a programmable data processing apparatus, a heterogeneous combination of processors or processor architectures, and so on. Without limitation, embodiments of the present invention may take the form of web-based computer software, which includes client/server software, software-as-a-service, peer-to-peer software, or the like.</p>
<p id="p-0061" num="0060">In embodiments, a computer enables execution of computer program instructions including multiple programs or threads. The multiple programs or threads may be processed approximately simultaneously to enhance utilization of the processor and to facilitate substantially simultaneous functions. By way of implementation, any and all methods, program codes, program instructions, and the like described herein may be implemented in one or more threads which may in turn spawn other threads, which may themselves have priorities associated with them. In some embodiments, a computer may process these threads based on priority or other order.</p>
<p id="p-0062" num="0061">Unless explicitly stated or otherwise clear from the context, the verbs &#x201c;execute&#x201d; and &#x201c;process&#x201d; may be used interchangeably to indicate execute, process, interpret, compile, assemble, link, load, or a combination of the foregoing. Therefore, embodiments that execute or process computer program instructions, computer-executable code, or the like may act upon the instructions or code in any and all of the ways described. Further, the method steps shown are intended to include any suitable method of causing one or more parties or entities to perform the steps. The parties performing a step, or portion of a step, need not be located within a particular geographic location or country boundary. For instance, if an entity located within the United States causes a method step, or portion thereof, to be performed outside of the United States then the method is considered to be performed in the United States by virtue of the causal entity.</p>
<p id="p-0063" num="0062">While the invention has been disclosed in connection with preferred embodiments shown and described in detail, various modifications and improvements thereon will become apparent to those skilled in the art. Accordingly, the forgoing examples should not limit the spirit and scope of the present invention; rather it should be understood in the broadest sense allowable by law.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A computer-implemented method for design analysis comprising:
<claim-text>obtaining a high-level design which includes a word-level representation;</claim-text>
<claim-text>obtaining a bit-level representation of the high-level design;</claim-text>
<claim-text>determining, using one or more processors, a map between the word-level representation and the bit-level representation;</claim-text>
<claim-text>optimizing the bit-level representation; and</claim-text>
<claim-text>lifting results from the optimizing of the bit-level representation and including the results in the word-level representation based on the map wherein the lifting includes creating an isomorph of the bit-level representation within the word-level representation and where the creating an isomorph includes mapping bit-level nets to corresponding nets within the word-level representation where the bit-level nets are merged, identifying nets from the bit-level representation that are merged, and merging the corresponding nets within the word-level representation.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the obtaining a bit-level design representation comprises translating the word-level representation of the high-level design.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising maintaining the map between the word-level representation and the bit-level representation.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the optimizing further comprises removing redundancy.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the creating the isomorph comprises taking constants from the bit-level representation and using those constants in the word-level representation.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising optimizing the word-level representation.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref> further comprising translating the optimizing of the word-level representation onto the bit-level representation.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00007">claim 7</claim-ref> further comprising iterating between the optimizing the bit-level representation, the lifting the results from the optimizing of the bit-level representation, the optimizing the word-level representation, and translating the optimizing of the word-level representation onto the bit-level representation.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref> wherein the optimizing the word-level representation includes re-writing an expression to simplify an equation.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref> wherein the re-writing includes removing redundancy in the word-level representation.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref> wherein the re-writing includes merging an internal equivalence point.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref> wherein the re-writing includes substituting a section of the word-level representation with a section from the bit-level representation.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the high-level design includes a datapath.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein superfluous terms of the bit-level representation are removed from the word-level representation.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the word-level representation is rebalanced using mathematical identities to identify equivalences in bit-level equations of the bit-level representation.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein bit-level equations of the bit-level representation are solved to find constant values.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein bit-level equations of the bit-level representation are solved to find equivalences.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising implementing a semiconductor design based on the lifting.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising evaluating the bit-level representation and the word-level representation for equivalence.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. A computer system for design analysis comprising:
<claim-text>a memory which stores instructions;</claim-text>
<claim-text>one or more processors coupled to the memory wherein the one or more processors are configured to:
<claim-text>obtain a high-level design which includes a word-level representation;</claim-text>
<claim-text>obtain a bit-level representation of the high-level design;</claim-text>
<claim-text>determine a map between the word-level representation and the bit-level representation;</claim-text>
<claim-text>optimize the bit-level representation; and</claim-text>
<claim-text>lift results from the optimizing of the bit-level representation and including the results in the word-level representation based on the map wherein lifting includes creating an isomorph of the bit-level representation within the word-level representation and where the creating an isomorph includes mapping bit-level nets to corresponding nets within the word-level representation where the bit-level nets are merged, identifying nets from the bit-level representation that are merged, and merging the corresponding nets within the word-level representation.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The system of <claim-ref idref="CLM-00020">claim 20</claim-ref> wherein the one or more processors are further configured to maintain the map between the word-level representation and the bit-level representation.</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. The system of <claim-ref idref="CLM-00020">claim 20</claim-ref> wherein the creating the isomorph comprises taking constants from the bit-level representation and using those constants in the word-level representation.</claim-text>
</claim>
<claim id="CLM-00023" num="00023">
<claim-text>23. The system of <claim-ref idref="CLM-00020">claim 20</claim-ref> wherein the one or more processors are further configured to: optimize the word-level representation; translate the optimizing of the word-level representation onto the bit-level representation; and iterate between the optimizing the bit-level representation, the lifting the results from the optimizing of the bit-level representation, the optimizing the word-level representation, and translating the optimizing of the word-level representation onto the bit-level representation.</claim-text>
</claim>
<claim id="CLM-00024" num="00024">
<claim-text>24. A computer program product embodied in a non-transitory computer readable medium for design simulation comprising:
<claim-text>code for obtaining a high-level design which includes a word-level representation;</claim-text>
<claim-text>code for obtaining a bit-level representation of the high-level design;</claim-text>
<claim-text>code for determining a map between the word-level representation and the bit-level representation;</claim-text>
<claim-text>code for optimizing the bit-level representation; and</claim-text>
<claim-text>code for lifting results from the optimizing of the bit-level representation and including the results in the word-level representation based on the map wherein the lifting includes creating an isomorph of the bit-level representation within the word-level representation and where the creating an isomorph includes mapping bit-level nets to corresponding nets within the word-level representation where the bit-level nets are merged, identifying nets from the bit-level representation that are merged, and merging the corresponding nets within the word-level representation.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00025" num="00025">
<claim-text>25. The computer program product of <claim-ref idref="CLM-00024">claim 24</claim-ref> further comprising code for maintaining the map between the word-level representation and the bit-level representation.</claim-text>
</claim>
<claim id="CLM-00026" num="00026">
<claim-text>26. The computer program product of <claim-ref idref="CLM-00024">claim 24</claim-ref> wherein the creating the isomorph comprises taking constants from the bit-level representation and using those constants in the word-level representation.</claim-text>
</claim>
<claim id="CLM-00027" num="00027">
<claim-text>27. The computer program product of <claim-ref idref="CLM-00024">claim 24</claim-ref> further comprising: code for optimizing the word-level representation; code for translating the optimizing of the word-level representation onto the bit-level representation; and code for iterating between the optimizing the bit-level representation, the lifting the results from the optimizing of the bit-level representation, the optimizing the word-level representation, and translating the optimizing of the word-level representation onto the bit-level representation. </claim-text>
</claim>
</claims>
</us-patent-grant>
