<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627165-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627165</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12403546</doc-number>
<date>20090313</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>1265</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>H</section>
<class>03</class>
<subclass>M</subclass>
<main-group>13</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>714752</main-classification>
</classification-national>
<invention-title id="d2e53">Bitwise operations and apparatus in a multi-level system</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6034996</doc-number>
<kind>A</kind>
<name>Herzberg</name>
<date>20000300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6160854</doc-number>
<kind>A</kind>
<name>Heegard et al.</name>
<date>20001200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6311306</doc-number>
<kind>B1</kind>
<name>White et al.</name>
<date>20011000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714790</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>7142612</doc-number>
<kind>B2</kind>
<name>Horowitz et al.</name>
<date>20061100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>7379505</doc-number>
<kind>B2</kind>
<name>Zaleski, II et al.</name>
<date>20080500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2002/0133781</doc-number>
<kind>A1</kind>
<name>Mikkola et al.</name>
<date>20020900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714790</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2003/0023924</doc-number>
<kind>A1</kind>
<name>Davis et al.</name>
<date>20030100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714763</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2003/0156603</doc-number>
<kind>A1</kind>
<name>Rakib et al.</name>
<date>20030800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370485</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2003/0235149</doc-number>
<kind>A1</kind>
<name>Chan et al.</name>
<date>20031200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2004/0001561</doc-number>
<kind>A1</kind>
<name>Dent et al.</name>
<date>20040100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2004/0014444</doc-number>
<kind>A1</kind>
<name>Ben Rached et al.</name>
<date>20040100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2006/0090114</doc-number>
<kind>A1</kind>
<name>Duffy et al.</name>
<date>20060400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714746</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2008/0246639</doc-number>
<kind>A1</kind>
<name>Sakai et al.</name>
<date>20081000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>341107</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2008/0247470</doc-number>
<kind>A1</kind>
<name>Wang et al.</name>
<date>20081000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>375241</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>2008/0311920</doc-number>
<kind>A1</kind>
<name>Xu et al.</name>
<date>20081200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>455450</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>2009/0013233</doc-number>
<kind>A1</kind>
<name>Radke</name>
<date>20090100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>2009/0241006</doc-number>
<kind>A1</kind>
<name>Liikanen et al.</name>
<date>20090900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714752</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00018">
<document-id>
<country>US</country>
<doc-number>2010/0146363</doc-number>
<kind>A1</kind>
<name>Birru et al.</name>
<date>20100600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714752</main-classification></classification-national>
</us-citation>
<us-citation>
<nplcit num="00019">
<othercit>Wicker, Stephen B., <i>Error Control Systems for Digital Communication and Storage</i>, 1995, Prentice-Hall pp. 238-239 and 290-332.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00020">
<othercit>Ungerboeck, Channel Coding with Multilevel/Phase Signals, Jan. 1982, Ieee Transactions on Information Theory, vol. IT-28, No. 1, pp. 55-67.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>23</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>714752</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714E11032</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>17</number-of-drawing-sheets>
<number-of-figures>21</number-of-figures>
</figures>
<us-related-documents>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61039016</doc-number>
<date>20080324</date>
</document-id>
</us-provisional-application>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20090241006</doc-number>
<kind>A1</kind>
<date>20090924</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Liikanen</last-name>
<first-name>Bruce A.</first-name>
<address>
<city>Berthoud</city>
<state>CO</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Van Aken</last-name>
<first-name>Stephen P.</first-name>
<address>
<city>Boulder</city>
<state>CO</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Cadloni</last-name>
<first-name>Gerald L.</first-name>
<address>
<city>Longmont</city>
<state>CO</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="004" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Seabury</last-name>
<first-name>John L.</first-name>
<address>
<city>Erie</city>
<state>CO</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="005" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Eisenhuth</last-name>
<first-name>Robert B</first-name>
<address>
<city>Boulder</city>
<state>CO</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Liikanen</last-name>
<first-name>Bruce A.</first-name>
<address>
<city>Berthoud</city>
<state>CO</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Van Aken</last-name>
<first-name>Stephen P.</first-name>
<address>
<city>Boulder</city>
<state>CO</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Cadloni</last-name>
<first-name>Gerald L.</first-name>
<address>
<city>Longmont</city>
<state>CO</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="004" designation="us-only">
<addressbook>
<last-name>Seabury</last-name>
<first-name>John L.</first-name>
<address>
<city>Erie</city>
<state>CO</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="005" designation="us-only">
<addressbook>
<last-name>Eisenhuth</last-name>
<first-name>Robert B</first-name>
<address>
<city>Boulder</city>
<state>CO</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Pritzkau Patent Group, LLC</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Micron Technology, Inc.</orgname>
<role>02</role>
<address>
<city>Boise</city>
<state>ID</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Bhatia</last-name>
<first-name>Ajay</first-name>
<department>2117</department>
</primary-examiner>
<assistant-examiner>
<last-name>Nguyen</last-name>
<first-name>Thien D</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A system uses multi-level encoding where each symbol of a plurality of symbols represents more than one bit of information in a user data symbol stream for transfer using a multilevel transmission channel. The user data symbols are represented in a digital bitwise form such that each symbol is presented as a plurality of bits and each bit is subject to a different probability of error. An error correction procedure is applied based on the different error probability that is associated with each bit in the plurality. The channel can be configured to support a mosaic tile structure, each tile containing a channel symbol such that a selected tile has a collective error probability that is different from other tiles. Customized coding can be applied to the tile structure to allocate a selected amount of error correction power to the selected tile based on an overall available correction power.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="118.53mm" wi="176.95mm" file="US08627165-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="225.04mm" wi="168.91mm" file="US08627165-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="163.41mm" wi="192.02mm" file="US08627165-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="147.40mm" wi="182.29mm" file="US08627165-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="216.24mm" wi="163.07mm" file="US08627165-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="166.29mm" wi="192.62mm" file="US08627165-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="214.04mm" wi="155.53mm" file="US08627165-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="158.07mm" wi="191.09mm" file="US08627165-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="214.04mm" wi="157.14mm" file="US08627165-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="190.75mm" wi="175.34mm" file="US08627165-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="221.91mm" wi="191.09mm" orientation="landscape" file="US08627165-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="226.23mm" wi="180.09mm" orientation="landscape" file="US08627165-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="225.98mm" wi="175.01mm" file="US08627165-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="242.32mm" wi="168.74mm" file="US08627165-20140107-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="208.03mm" wi="159.34mm" file="US08627165-20140107-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="209.63mm" wi="170.35mm" file="US08627165-20140107-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00016" num="00016">
<img id="EMI-D00016" he="211.50mm" wi="168.15mm" file="US08627165-20140107-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00017" num="00017">
<img id="EMI-D00017" he="206.50mm" wi="176.95mm" file="US08627165-20140107-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">RELATED APPLICATION</heading>
<p id="p-0002" num="0001">The present application claims priority from U.S. Provisional Patent Application Ser. No. 61/039,016, filed on Mar. 24, 2008, the contents of which are incorporated herein by reference</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">BACKGROUND</heading>
<p id="p-0003" num="0002">The present application is generally related to multi-level information systems and, more particularly, to an apparatus and method relating to bitwise operations in a multilevel system.</p>
<p id="p-0004" num="0003">The prior art is replete with examples of various types of operations that have been performed in single bit systems. Applicants believe that the execution of such operations in the context of multilevel systems have largely been influenced by single bit systems in ways that can be problematic at least with respect to the competing interests of efficiency and error correction, as will be further brought to light below.</p>
<p id="p-0005" num="0004">The foregoing examples of the related art and limitations related therewith are intended to be illustrative and not exclusive. Other limitations of the related art will become apparent to those of skill in the art upon a reading of the specification and a study of the drawings.</p>
<heading id="h-0003" level="1">SUMMARY</heading>
<p id="p-0006" num="0005">The following embodiments and aspects thereof are described and illustrated in conjunction with systems, tools and methods which are meant to be exemplary and illustrative, not limiting in scope. In various embodiments, one or more of the above-described problems have been reduced or eliminated, while other embodiments are directed to other improvements.</p>
<p id="p-0007" num="0006">In general, a system uses multi-level data encoding where each symbol of a plurality of user data symbols represents more than one bit of information in a user data symbol stream for transfer using a multilevel transmission channel. In one aspect of the disclosure, a method and associated apparatus are described. In relation to the transfer, the user data symbols are represented in a digital bitwise form such that each symbol is presented as a plurality of bits where each bit in the plurality of bits is subject to a different probability of error. An error correction procedure is applied to the plurality of bits, for the bitwise digital form of each user data symbol that is transferred, based on the different error probability that is associated with each bit in the plurality of bits such that an error correction power for at least one bit of the plurality of bits is different than another error correction power that is associated with another one of the plurality of bits.</p>
<p id="p-0008" num="0007">In another aspect of the disclosure, as part of a system which uses a multilevel transmission channel for transferring user data, a method and associated apparatus are described. The multilevel transmission channel is configured to support a plurality of bitwise data symbols, each of which bitwise data symbols represents more than one bit of information such that each bitwise data symbol is made up of a plurality of bits where each bit in the plurality of bits is subject to a different probability of error. A mosaic data structure is applied to the bitwise data symbols of the multilevel channel based on the different probability of error for each bit, which mosaic data structure is formed of an arrangement of mosaic tiles, and each of which mosaic tiles is configured for receiving a channel symbol such that at least a selected one of the mosaic tiles is characterized by a collective error probability based on the error probability of a selected group of the bits assigned to the selected mosaic tile which is different than another collective error probability that characterizes at least one other one of the mosaic tiles based a different group of the bits assigned to the other mosaic tile. The user data is encoded into the channel symbols in a way which provides an error correction power for correction of one or more errors in at least some of the channel symbols, which errors are caused by the transfer through the multilevel channel. The channel symbols are introduced into the mosaic tiles. Thereafter, the user data is recovered from the channel symbols such that the error correction power of the encoding is applied by a selected amount to at least the selected one of the plurality of bits and by a different amount to at least one other one of the plurality of bits for correcting errors that occur within the selected group of bits in the selected mosaic tile.</p>
<p id="p-0009" num="0008">In still another aspect of the disclosure, as part of a system which uses multi-level data encoding where each symbol of a plurality of user data symbols represents more than one bit of information in a user data symbol stream for transfer using a multilevel transmission channel, a method and associated apparatus are described. In relation to the transfer, the user data symbols are represented in a digital bitwise form such that each symbol is presented as a plurality of bits where each bit in the plurality of bits forms a portion of one of the data symbols and each bit of each data symbol includes a different bit position. At least one selected bit from a selected bit position of each data symbol is transferred in a bitstream that is subject to a selected encryption/decryption procedure such that a selected amount of encryption of the bitstream is different from another encryption/decryption that is applied to at least one other bit in a different bit position during the transfer.</p>
<p id="p-0010" num="0009">In yet another aspect of the disclosure, as part of a system which uses multi-level data encoding where each symbol of a plurality of user data symbols represents more than one bit of information in a user data symbol stream for transfer using a multilevel transmission channel, a method and associated apparatus are described. In relation to the transfer, the user data symbols are represented in a digital bitwise form such that each symbol is presented as a plurality of bits where each bit in the plurality of bits forms a portion of one of the data symbols and each bit of each data symbol includes a different bit position. At least one selected bit from a selected bit position of each data symbol is transferred in a bitstream that is subject to a selected compression/decompression procedure such that a selected amount of compression of the bitstream is different from another amount of compression that is applied to at least one other bit in a different bit position during the transfer.</p>
<p id="p-0011" num="0010">In addition to the exemplary aspects and embodiments described above, further aspects and embodiments will become apparent by reference to the drawings and by study of the following descriptions.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0012" num="0011">Exemplary embodiments are illustrated in referenced figures of the drawings. It is intended that the embodiments and figures disclosed herein are to be illustrative rather than limiting.</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 1</figref> is a graph illustrating a graph of a variable of interest versus probability in the context of a single bit window showing a probability density function within the window.</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 2</figref> is a graph of a variable of interest versus probability in the context of a 2 bit multi-level system showing the probability density function for each of the four values along with vertical lines separating regions that are associated with each value.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 3</figref> is a graph of a variable of interest versus probability in the context of a 4 bit multi-level system showing the probability density function for each of the four values separated by vertical lines which demark a region that is associated with each value. Further, two exemplary charge distributions are shown to illustrate variation in per bit error rates.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 4</figref> is a graph of bit error rate versus signal to noise ratio including plots of the error rate for each bit in a 4 bit multi-level system, shown here to illustrate the variation in bit-to-bit error rate.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 5</figref> is a block diagram illustrating one embodiment of a system which implements error correction power that can vary from bit to bit.</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 6</figref> is a flow diagram which illustrates one embodiment of the operation of the system of <figref idref="DRAWINGS">FIG. 5</figref>.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 7</figref> is a block diagram illustrating one embodiment of a system which implements data compression having a data compression power that can vary from bit to bit.</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 8</figref> is a flow diagram which illustrates one embodiment of the operation of the system of <figref idref="DRAWINGS">FIG. 7</figref>.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 9</figref> is a block diagram illustrating one embodiment of a system which implements data encryption having an encryption power that can vary from bit to bit.</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 10</figref> is a flow diagram which illustrates one embodiment of the operation of the system of <figref idref="DRAWINGS">FIG. 9</figref>.</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 11</figref><i>a </i>is a diagrammatic illustration of one embodiment for interleaving and deinterleaving a 2 bit symbol value.</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 11</figref><i>b </i>is a diagrammatic illustration of one embodiment for allocating correction power among the two interleaves of <figref idref="DRAWINGS">FIG. 11</figref><i>a. </i></p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 12</figref> is a diagrammatic illustration of one embodiment of a data structure that can be imposed on an arrangement of 120 memory cells, each of which memory cells can store a 4 bit value or symbol.</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 13</figref> is another diagrammatic illustration of the data structure of <figref idref="DRAWINGS">FIG. 12</figref> shown here to illustrate other aspects of the interleaves and symbols contained therein.</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 14</figref> is a flow diagram which illustrates one embodiment of a method for packing symbols into the data mosaic of <figref idref="DRAWINGS">FIGS. 12 and 13</figref>.</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 15</figref> is a diagrammatic illustration of one embodiment of a data structure that can be imposed on an arrangement of <b>40</b> memory cells, each of which memory cells can store a 4 bit value or symbol.</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 16</figref> is another diagrammatic illustration of the data structure of <figref idref="DRAWINGS">FIG. 15</figref> shown here to illustrate other aspects of the interleaves and symbols contained therein.</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 17</figref> is a flow diagram that illustrates one embodiment of an encoding method that can be performed by a controller operating in accordance with the present disclosure.</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 18</figref> is a flow diagram that illustrates one embodiment of a decoding method that can be performed by a controller operating in accordance with the present disclosure.</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 19</figref> is a block diagram of one embodiment of a controller including componentry that is directed to the encoding functionality of the controller according to the present disclosure.</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 20</figref> is a block diagram of one embodiment of a controller including componentry that is directed to the decoding functionality of the controller according to the present disclosure.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0034" num="0033">The following description is presented to enable one of ordinary skill in the art to make and use the invention and is provided in the context of a patent application and its requirements. Various modifications to the described embodiments will be readily apparent to those skilled in the art and the generic principles taught herein may be applied to other embodiments. Thus, the present invention is not intended to be limited to the embodiment shown, but is to be accorded the widest scope consistent with the principles and features described herein including modifications and equivalents, as defined within the scope of the appended claims. It is noted that the drawings are not to scale and are diagrammatic in nature in a way that is thought to best illustrate features of interest. Descriptive terminology may be adopted for purposes of enhancing the reader's understanding, with respect to the various views provided in the figures, and is in no way intended as being limiting.</p>
<p id="p-0035" num="0034">A traditional single bit system is generally characterized by the presence or absence of information within a window, generally indicated by the reference number <b>10</b>, that is illustrated by <figref idref="DRAWINGS">FIG. 1</figref> showing a probability density function that is a normal distribution of the number of occurrences for each possible value of the variable of interest along the horizontal, x axis of the figure. Thus, the vertical, y axis of the figure corresponds to probability. The horizontal axis can represent any suitable variable including, by way of example, charge in an electron storage device such as flash memory (NROM, NAND, NOR), resistance in a phase change medium storage device (Phase Change Memory (PRAM, nanotubes)), magnetic moment or magnetic spin direction in a magnetic storage device (Probe Storage), the phase angle of information transmitted in a transmission channel (Phase Shift Keying (PSK)), the amplitude or magnitude of information transmitted in a channel (Amplitude Modulation (AM), Pulse Amplitude Modulation (PAM)), the delta frequency transmitted in a channel (Frequency Modulation (FM), Frequency Shift Keying (FSK)), capacitance change (FerroElectric Random Access Memory (FERAM)), or molecular storage) or any combination of the above. It should be appreciated that the concept that is embodied by <figref idref="DRAWINGS">FIG. 1</figref> applies generally to every know transmission or storage channel either currently known and, most likely, yet to be developed. From this characterization, an information error rate can be statistically determined. In a single bit system, the error can be referred to as the Bit Error Rate (BER). Current examples of single bit systems are most digital telecommunications channels and magnetic recording such as Disk Drives and Tape Drives, and semiconductor storage such as DRAM (Dynamic Random Access), SRAM (Static Random Access) and SLC (Single Level Cell) Flash memory.</p>
<p id="p-0036" num="0035">A multi-level system is characterized by the use of symbols where each symbol represents more than one bit of information. In such a multi-level system, a symbol stream can be transferred using a multilevel transmission channel where multiple bits of information are needed to represent the symbols transmitted or stored in the system. In the context of this disclosure, a multilevel transmission channel is considered to be any medium or expedient that can be used to transfer the symbols such as, for example, memory cells of any suitable type, electromagnetic signals, optical signals and, more generally, any device that is capable of functioning in a way that implements variables such as described above as characterized by some measurable physical parameter. It should be appreciated that the recognitions that have been brought to light herein are applicable to essentially any form of transmission channel that uses a binary digital representation of symbols that represent more than one bit of information, as will be further discussed below.</p>
<p id="p-0037" num="0036">By way of non-limiting example, a 2 bit multilevel system uses 4 possible values of information represented as a single symbol, as illustrated by <figref idref="DRAWINGS">FIG. 2</figref> which assigns a two-bit value to each level where each level is illustrated with an associated probability density function, only one of which would generally be employed at a time. As in <figref idref="DRAWINGS">FIG. 1</figref>, the x axis corresponds to a suitable variable of interest while the y axis corresponds to probability. The four available levels are indicated as windows 00, 01, 10 and 11. In one embodiment, this symbol can be represented as the values A, B, C and D where each one of these four values is unique. Using the example of a flash memory cell, such a system can be implemented by the capability to selectively store each one of four different amounts or levels of charge at a single memory location.</p>
<p id="p-0038" num="0037">Graphically, the influence of bit position on error probability can be seen with reference to <figref idref="DRAWINGS">FIG. 3</figref> which is representative of a 4 bit, 16 level multilevel system. It should be appreciated that the heavy vertical lines in this figure represent borders between neighboring values, which have also been labeled with corresponding base 10 values for purposes of convenience. For one distribution, plotted as a solid line <b>12</b> and shown with a value of 3 (0011), the probability of an error in the Most Significant bit (MSB) is relatively small. That is, a read back value would have to be positioned to the right by 5 levels in order to produce an error in the MSB. In contrast, however, for another distribution <b>14</b> that is illustrated using a dashed line and with a value of 8 (1000), a significantly higher probability of producing an error in the MSB is demonstrated since the level immediately to the left represents a change in the MSB. In both cases, however, a shift of either distribution to the left or right will produce an error in the LSB. In view of these results, Applicants recognize that the probability of error for each bit within this multi-level symbol is different. Furthermore, the error probability of each bit is a function of the data value within the symbol. That is, the error probability changes based on the position of the bit in a multilevel symbol. As the symbol grows larger in the number of bits it represents, the difference in error probability between the LSB and MSB grows larger and each successive bit within the symbols will exhibit a different probability of error. A system that deals with each bit independently on a bit by bit basis is referred to as a bitwise system in which bitwise operations are performed as opposed to a system that deals with all bits in a group of bits such as a byte or word or symbol as is common in prior art systems. While the foregoing discussion is framed in terms of a read operation in order to facilitate the reader's understanding, it should be appreciated that Applicants recognize that this concern arises as a result of the bitwise conversion to a multilevel symbol as will be further discussed.</p>
<p id="p-0039" num="0038">Turning now to <figref idref="DRAWINGS">FIG. 4</figref>, which is a graph showing bit error rate against SNR, the standard definition of Signal to Noise Ratio (SNR) for this class of transmission or storage channels is the width of the window divided by the standard deviation (sigma) of the signal distribution represented in either power or voltage decibels. A wide distribution with a large sigma has a low SNR. In view of Applicants' recognitions in accordance with the descriptions above, Applicants have separated the error probability for each bit (indicated as CellBERB<b>0</b>-Cell BERB<b>3</b>) and plotted the resultant curves as bit error rates (BER) which are presented as a function of voltage SNR in decibels (dB) in <figref idref="DRAWINGS">FIG. 4</figref>. It can be seen that CELLBERB<b>0</b> exhibits the highest BER whereas CELLBER<b>1</b>-CELLBER<b>3</b> exhibit progressively decreasing BER. An average BER curve is shown as CELLBER. It should be noted that the probability of error can be viewed interchangeably based on SNR and BER. That is, a system with a relatively better BER is equivalent to a system with a relatively higher SNR.</p>
<p id="p-0040" num="0039">It is recognized herein that the bit-to-bit variation in probability of error that has been brought to light above and as demonstrated by <figref idref="DRAWINGS">FIG. 4</figref>, occurs in all multi-level systems. A difference in bit-to-bit error probability reduces the effectiveness of non-symbol bitwise error correcting codes. These codes include, but are not limited to convolutional, turbo and Low Density Parity Code, LDPC, classes of codes that encode a series of bits and expects that the probability of error is the same for all bits. This is in contrast to symbol type coding systems such as Reed Solomon or BCH codes that encode series of symbols rather than bits. In contrast, for a bitwise series coded system, one of the fundamental assumptions of the prior art is that all bits in the series have the same probability of error. In a multi-level system, however, Applicants recognize that this assumption is not valid. For this reason, a multi-level system which includes a bitwise code conversion will fall short of its potential performance when the assumption of equal bit to bit error probability is made.</p>
<p id="p-0041" num="0040">It is recognized that any time two or more bits of a bitwise code are processed as if they are subject to the same probability of error, the performance of the system will not achieve its potential performance. Applicants observed this degradation empirically, based on system modeling. Treating each bit on the basis of its individual probability of error was likewise observed to resolve the performance degradation which could not be accounted for in some other way. Applicants are unaware of any system in the prior art which treats or handles each bit of such a code according to a customized, different probability of error for each bit.</p>
<p id="p-0042" num="0041">For any given class of coding system, there is always a tradeoff between the correction capability of the code and the efficiency of the code. The correction capability of all coding systems comes from encoding redundancy bits with the information bits so that errors can be corrected using the redundant information. The more redundant information that is added, the more correction capability the code has. In contrast, however, the more redundant information that is added, the more inefficient the coding system becomes. The tradeoff for a coding system is the balance between the correction capability and the efficiency of the code. The other tradeoff in coding system design is the choice of codes and their implementation complexity. Simple hard threshold detection and mapping functions such as gray code or constellation mapping are very easy to implement, have 100% efficiency, but also have no correction capability. More complex code systems such as convolutional encoding and viterbi decoding are more difficult to implement but do provide correction capabilities&#x2014;at the cost of loss in efficiency. Even more complex codes such as LDPC have even better correction capabilities with higher coding efficiency but at the cost of extremely large and difficult implementations.</p>
<p id="p-0043" num="0042">In one embodiment, generally indicated by the reference number <b>20</b> in <figref idref="DRAWINGS">FIG. 5</figref>, and associated method, illustrated by <figref idref="DRAWINGS">FIG. 6</figref>, that is based on the teachings above, the difference in BER between bits of a multi-level system is addressed through coding systems that are customized for the error probability of each bit. One embodiment with respect to the LSB and the next higher bit resides in the use of two different convolutional codes, each with a different given efficiency and correction capability. One code is designed specifically for the SNR/error probability of the LSB and the other being designed specifically for the SNR/error probability of the next higher bit. The overall effect is a more efficient system with higher correction capability. Each bit of the four bit system of <figref idref="DRAWINGS">FIG. 5</figref> is handled in this manner. <figref idref="DRAWINGS">FIG. 5</figref> illustrates 4 bits of a bitwise code arriving at a Serializer <b>22</b> such that a succession of 4 bit values is received (see step <b>100</b> of <figref idref="DRAWINGS">FIG. 6</figref>). The Serializer outputs a dedicated line for each incoming bit. A plurality of encode systems, indicated as Encode Systems <b>0</b>-<b>3</b>, then separately encode bits arriving on lines b<b>0</b>-b<b>3</b> such that each line is handled based on a different error probability (see step <b>102</b> of <figref idref="DRAWINGS">FIG. 6</figref>). Encoded lines be<b>0</b> through be<b>3</b> connect the encode systems to a Deserializer <b>103</b> (see step <b>104</b> of <figref idref="DRAWINGS">FIG. 6</figref>). As noted above, encoding which imposes more correction capability will generally introduce relatively more parity bits, which may be referred to interchangeably herein as redundancy bits. In this regard, be<b>0</b> would then be expected to carry a greater amount of data than the remaining lines and each increasing bit in the bit order would require relatively fewer parity bits, with be<b>3</b> carrying the fewest. In order to compensate for the relative differences in the amount of data carried by lines be<b>0</b>-be<b>3</b> for an incoming block of input data on lines b<b>0</b>-b<b>3</b> of a given size, padding bits (zeros, for example) can be added on lines be<b>1</b>-be<b>3</b> to produce an output block that corresponds to the same length as an output block on be<b>0</b>, responsive to the input block and including the added parity bits. It is noted that this padding functionality can be implemented in the encoding blocks, as part of the Deserializer <b>103</b> or as a separate block. Another embodiment that is useful in compensating for the relative differences in the amount of data carried by lines be<b>0</b>-be<b>3</b> resides in using different coding systems for each line. As an example, consider a system that uses the high correction capability and relatively good efficiency of LDPC on the LSB, be<b>0</b>, and then uses a Turbo code for the next bit, be<b>1</b>, and then a convolutional code for the next bit, be<b>2</b>, and so on. Each coding system is successively more efficient and successively less powerful in its error correction capability. The overall system however can be optimized for the best performance of each coding system with the highest overall efficiency. In addition, the implementation of any one of these systems can also be simplified since the amount of data in each bit line is smaller than the total amount of data. In the case of LDPC, the implementation complexity is relative to the size of the data block on which the code operates. In the above example, the be<b>0</b> line has one forth the amount of data as the whole data block and therefore can utilize a smaller LDPC implementation.</p>
<p id="p-0044" num="0043">The data is transferred from the Deserializer <b>103</b> to a multi-level transmission channel for transfer and receipt by a Serializer <b>105</b> (see step <b>106</b> of <figref idref="DRAWINGS">FIG. 6</figref>). From the Serializer <b>105</b> that terminates the transmission channel, the data corresponding to each bit is routed onto encoded bit lines be<b>0</b>-be<b>3</b> and received by respective ones of decode systems <b>0</b>-<b>3</b> (see step <b>108</b> of <figref idref="DRAWINGS">FIG. 6</figref>). Each decode system is matched to a corresponding one of the encode systems in a manner that is well understood by one having ordinary skill in the art. Decode systems <b>0</b>-<b>3</b>, at step <b>110</b> of <figref idref="DRAWINGS">FIG. 6</figref>, then remove the encoding and place bit data onto bit lines b<b>0</b>-b<b>3</b>. It is noted that padding bits can be removed by the Serializer, by the decode systems or by a separate functional block which has not been shown for purposes of illustrative clarity. Bit lines b<b>0</b>-b<b>3</b> are connected to a Deserializer <b>111</b> which then reproduces the original bitwise data subject to performance constraints at step <b>112</b> of <figref idref="DRAWINGS">FIG. 6</figref>.</p>
<p id="p-0045" num="0044">In the generalized form of the system of <figref idref="DRAWINGS">FIG. 5</figref>, the encode/decode blocks are not limited to convolutional coding. For example, an LDPC code can be applied on the LSB, and a convolutional code on the next higher bit. As a multi-level system grows from 2 or 4 bits to 8 or 16 or more bits, there can be as many different code rates or coding systems, each designed for optimal efficiency and code correction capabilities of the particular bit for which it is implemented. Thus, the type of encoding/decoding on a particular line can be customized irrespective of the type of encoding/decoding that is selected for any other line. In this way, a remarkable and heretofore unseen degree of flexibility is provided, accompanied by the aforementioned enhanced performance.</p>
<p id="p-0046" num="0045">In view of the foregoing, an optimally designed coding system for the SNR of each bit within a system is produced. It should be appreciated that implementation complexity can be reduced by using relatively more complex encoding systems for the lowest SNR bits rather than for all the bits as would be in a traditional design where, for instance, an LDPC coding system might be implemented for all bits as if they were each subject to the same probability of error. For example, in one embodiment, if an LDPC implementation was needed only for the LSB in the above system, that LDPC section could be made <b>1</b>/<b>4</b> the size of an implementation which would subject all 4 bits to LDPC coding. In this regard, the term &#x201c;coding&#x201d; refers collectively to the encoding and associated decoding process.</p>
<p id="p-0047" num="0046">At this juncture, it is appropriate to discuss a number of other embodiments that are available based, at least in part, on certain teachings that have been brought to light above. Accordingly, attention is now directed to <figref idref="DRAWINGS">FIG. 7</figref> in conjunction with <figref idref="DRAWINGS">FIG. 5</figref>. <figref idref="DRAWINGS">FIG. 7</figref> illustrates a system which is identical to the system of <figref idref="DRAWINGS">FIG. 5</figref>, however, encode/decode systems <b>0</b>-<b>3</b> have been replaced by compression/decompression systems <b>0</b>-<b>3</b>.</p>
<p id="p-0048" num="0047">Comparison of <figref idref="DRAWINGS">FIGS. 6 and 8</figref> reveals that operations are performed in a similar manner except that encode step <b>102</b> of <figref idref="DRAWINGS">FIG. 6</figref> has been replaced with compression step <b>200</b> of <figref idref="DRAWINGS">FIG. 8</figref> and decode step <b>110</b> of <figref idref="DRAWINGS">FIG. 6</figref> has been replaced with decompression step <b>210</b> of <figref idref="DRAWINGS">FIG. 8</figref>. In particular, each bit line includes a matched pair of compression and decompression systems such that each one of bit lines be<b>0</b>-<b>3</b> is subject to compression that is essentially independent of the compression that is in use on the other bit lines.</p>
<p id="p-0049" num="0048">What is embraced by <figref idref="DRAWINGS">FIGS. 7 and 8</figref> resides in a reconfiguration of data for compression. In the prior art, data values in the form of bytes or words or symbols of variable numbers of bits are processed through a data compression algorithm. The present embodiment sweeps aside this constraint and transforms the incoming information into a series of individual bit streams corresponding to the number of bits represented in the data. For example, a byte of data would have 8 bit streams of data, a word would have 16 bit streams and so on. Each bit stream is then individually compressed. The compression algorithm for one stream may be different than that of another stream. Multiple compression algorithms allow each data bit stream to be compressed based on the characteristics of the bit within the original data.</p>
<p id="p-0050" num="0049">As an example of how different compressions may be applied, consider data that is unsigned amplitude information, commonly referred to as magnitude information. The volume of the number of shares of stock sold in the stock market is an example of such data. For this type of data, it is common that the maximum binary value occurs much less frequently than small values and therefore, the MSB of the binary representation of this data is zero more often than it is a one. The MSB could therefore be compressed through any number of different algorithms more than the LSB of the same data. The LSB may have different characteristics which allow it to be compressed more efficiently if an algorithm other than the one used on the MSB were used. It is recognized that each bit in turn can be optimized independently for the characteristics of that particular bit.</p>
<p id="p-0051" num="0050">Another embodiment will now be described with initial reference to <figref idref="DRAWINGS">FIG. 9</figref>. It is appropriate to compare this figure with <figref idref="DRAWINGS">FIGS. 5 and 7</figref>. Accordingly, the system of <figref idref="DRAWINGS">FIG. 9</figref> is essentially identical to the systems of <figref idref="DRAWINGS">FIGS. 5 and 7</figref>, however, the encode/decode systems <b>0</b>-<b>3</b> of <figref idref="DRAWINGS">FIG. 5</figref> have been replaced by encryption/decryption systems <b>0</b>-<b>3</b>.</p>
<p id="p-0052" num="0051">Comparison of <figref idref="DRAWINGS">FIGS. 6 and 10</figref> reveals that operations are formed in a similar manner except that encode step <b>102</b> of <figref idref="DRAWINGS">FIG. 6</figref> has been replaced with encryption step <b>220</b> of <figref idref="DRAWINGS">FIG. 8</figref> and decode step <b>110</b> of <figref idref="DRAWINGS">FIG. 6</figref> has been replaced with decryption step <b>230</b> of <figref idref="DRAWINGS">FIG. 10</figref>. In particular, each bit line includes a matched pair of encryption and decryption systems such that each one of bit lines be<b>0</b>-<b>3</b> is subject to encryption that is essentially independent of the encryption that is in use on the other bit lines.</p>
<p id="p-0053" num="0052">What is embraced by <figref idref="DRAWINGS">FIGS. 9 and 10</figref> resides in a reconfiguration of data for encryption purposes. In the prior art, data values in the form of bytes, words or symbols of variable numbers of bits are processed through a data encryption algorithm with each of these data values being handled as a unit. In <figref idref="DRAWINGS">FIG. 9</figref>, the incoming information in the form of nibbles (4 bits) is first transformed into a series of individual bit streams corresponding to the number of bits represented in the data. For example, a byte of data would correspond to 8 bit streams of data, a word would correspond to and generate 16 bit streams and so on. Each bit stream is then individually encrypted. The encryption algorithm for one stream may be different than that of another stream. Multiple encryption algorithms allow each data bit stream to be encrypted independently. By way of example, an encryption key may be different from one bit line to another and/or the encryption algorithm and/or the length of the encryption key may be different. For instance, each of bit lines be<b>0</b>-be<b>3</b> may be subjected to a different encryption key and/or a different encryption algorithm so as to provide different amounts of encryption power.</p>
<p id="p-0054" num="0053">As an example of how different encryptions may be applied, consider a Pretty Good Privacy (PGP) secure transaction system commonly in use today. In this prior art system, an encryption key is generated that is shared between two parties and the message is encrypted in a bytewise manner. In general, the strength of the encryption in such a prior art system is determined by the number of bits in the encryption key. According to the present disclosure, however, by encrypting each bit individually with a key of the same length as in the prior art bytewise system, the effective encryption key length is increased. This characteristic can be used in at least two ways: One provides for making a stronger encryption/decryption system by presenting more encryption systems that would necessarily be subject to decipher. Another provides for maintaining the same or equivalent level of security of encryption/decryption with a key length that is shorter. As a non-limiting example of the latter, consider a large system that operates on 64 bits at a time. A system with one key length that operates on all 64 bits at once can be duplicated with <b>64</b> systems, one for each bit, with a shorter key. Since the key generation is the longest, most complicated, procedure involved in the process of encrypting/decrypting, it is of benefit to be able to generate shorter keys with the same security level.</p>
<p id="p-0055" num="0054">In view of <figref idref="DRAWINGS">FIGS. 5-10</figref>, it should be appreciated that other types of operations may be well-suited for use in introducing and then removing specialized coding to and from each one of the bit lines, respectively, in order to accomplish some particular objective in view of the specific non-limiting examples above which include error detection related encoding, data compression and security encryption.</p>
<p id="p-0056" num="0055">Turning now to additional details with respect to the application of Error Correcting Codes in storage systems based on multi-level storage media. Flash Memory remains as the exemplary medium, but other technologies capable of storing more than one bit per storage cell are considered as equally applicable. Performance improvement is disclosed in the context of techniques that are directed to use in two different environments: (1) the first environment resides in the use of prior art 2-bit per cell memory that uses standard NAND flash circuit topologies and interfaces, and (2) the second environment resides in the use of greater than 2-bit per cell memory in memory devices circuitry and interfaces customized for use with the system such as is described above. Both techniques exploit the recognition that has been brought to light above with respect to multi-level systems (including Flash memory) wherein each cell exhibits a probability of error that is higher for bits of lesser significance than for bits of higher significance.</p>
<p id="p-0057" num="0056">Error correction in conventional Flash Memory including two bit per cell embodiments has typically been deployed through implementations of bit-correcting codes known as BCH codes. These codes are effective in correcting randomly-occurring single-bit errors. In contrast, Reed-Solomon Codes can correct multiple-bit symbols, with each symbol defined as containing a specific number of bits. For example, a byte-correcting Reed-Solomon Code can be constructed that uses 8-bit symbols, and which corrects any subset of the bits contained in a single 8-bit symbol as one unit. Although the disclosed techniques may be implemented using either BCH or Reed-Solomon Codes, the discussion refers to Reed Solomon coding since Reed-Solomon codes provide the ability to correct multiple bits per symbol. By way of example, for a given block of data, a Reed Solomon Code can correct a specific number of symbols, irrespective of the number of bit errors that are contained by any given symbol. That is, for a given symbol, all of its bits could be in error and the symbol would be corrected so long as the total number of symbols in error does not exceed the correction capability of the code.</p>
<p id="p-0058" num="0057">As alluded to immediately above, since Reed-Solomon and BCH codes are block codes, applying them requires that data be encoded and decoded in block units. In the prior art, Reed-Solomon or BCH ECC coding are configured to compute ECC parity with equal weight given to all symbols comprising a block of data. A related concept, called &#x201c;interleaving&#x201d;, is a partitioning technique that divides a data block into two or more parts, each of which is separately subjected to ECC encoding. The term &#x201c;interleaving&#x201d; usually applies to a technique that groups alternating symbols in a sequence into separate groups&#x2014;other partitioning techniques may be applied with equal validity, but simplicity of implementation makes the interleaving technique useful. Normally, the prior art application of ECC or BCH encoding uses interleaves which are equal, or very nearly so, in length to one another. In practical terms, interleaving a block is the same as slicing it into multiple portions, with each portion then treated as an independent unit for ECC encoding and decoding. Unlike the prior art, the interleaves used herein may be of variable length, and still be categorized as interleaves. This variability may be the result of different numbers of parity symbols being appended from one interleave to the next (i.e., the T value of the correction code varies based on bit position error considerations in a multilevel system), however, such variability may arise in other ways, yet may be addressed in a manner that is consistent with the teachings herein.</p>
<p id="p-0059" num="0058">It should be appreciated that prior art solutions of which Applicants are aware give equal weight to each interleave with respect to error correction power. This means that for each of I interleaves numbered <b>0</b>, <b>1</b>, <b>2</b>, . . . , I-<b>1</b>, each with n&#x2032;-k&#x2032; message symbols, each interleave is encoded with k&#x2032; parity symbols where n&#x2032; is the total number of symbols, k&#x2032; is the total number of parity symbols and n&#x2032;-k&#x2032; is total number of user data symbols which may be termed as message symbols.</p>
<p id="p-0060" num="0059">In one aspect of this disclosure, more efficient use can be made of available spare memory symbols in a given memory to balance the correction required by the differing probabilities of bit-level error that is associated with stored data based on the significance of bits in each of the stored symbols. Two variations are described below. The first variation applies to the case in which 2-bit memory symbols are being stored, and the second variation is a more general case of 3-bits per symbol or more. In both variations, the LSB in each symbol has a higher probability of error than its accompanying MSB or bits with significance greater than the LSB but less than the MSB. In the case of wider symbols, in which TCM encoding is also applied such that parity bits are added, the TCM decoder itself adds its own properties to the error signatures that can be corrected by the Reed-Solomon codes. That is, TCM generally adds decoding errors that show up as groups of bits; hence, correction is directed not only to error probabilities varying as a function of bit significance within memory symbols, but also to the tendency of errors to appear in bursts, which may be termed as &#x201c;burstiness&#x201d; in the vicinity of decoding errors made by the TCM decoder.</p>
<p id="p-0061" num="0060">(1) 2-Level NAND Flash With Standard Circuit Topology and Standard Interface</p>
<p id="p-0062" num="0061">The technique that is advantageously applied represents a marked improvement in the use of FCC parity allocated to storage media in devices that store 2 or more bits per cell, provided certain requirements can be met by the memory itself. In accordance with this technique, the available FCC parity is re-partitioned so that relatively more parity bits are used to correct errors on data most likely to have errors; and that fewer parity bits are allocated to error correction for data bits less likely to have errors. In this way, better memory performance can be achieved with a fixed budget of available parity bits. In standard flash memory, the available parity stored is a fixed amount appended to each page. Accordingly, the result for standard flash with such a fixed parity bit budget is better utilization of the parity bits at hand.</p>
<p id="p-0063" num="0062">As has been brought to light above, this re-allocation of correction capability is based on the recognition that in multi-level storage, the LSB of a data symbol (i.e., a multi-bit data value that can be stored in a memory cell) is more likely to be in error than the MSB of the same data symbol. In the prior art, there does not appear to be any recognition of this fact as evidenced by FCC encode/decode processes in which all the LSBs in a data block are associated with the same number of parity symbols as the MSBs. It should be appreciated that the present discussion refers to the LSB as a value that is subject to a greater probability of error as a result of symbol to bit stream conversion such as is associated with storing and retrieving a data symbol to and from a memory cell of a multi-level system. That is, by way of example, the LSB of interest would be bit zero of a four bit value when a memory cell is capable of storing <b>16</b> values. Such four bit and like values will be referred to herein as &#x201c;data symbols&#x201d; that are not to be confused with FCC encoding symbols such as, for example, Reed Solomon symbols.</p>
<p id="p-0064" num="0063">The present disclosure addresses this situation first of all by using bitstream FCC encoding (see, for example, <figref idref="DRAWINGS">FIGS. 5 and 6</figref>), which can encode the LSB so as to create a set of parity symbols determined solely on the LSBs of a data block and thereby proportionally customize the correction power that is directed to the LSB. As demonstrated by <figref idref="DRAWINGS">FIG. 6</figref>, a customized correction power can be applied to each bit in order of significance. Accordingly, it should be recognized that the T value of the correction code varies per bit. An encoder, constructed in light of these teachings, can be configured to truncate parity fields for more significant bits relative to bits of lesser significance. In this way, the configuration of the encoder can match the available parity resources for a given flash memory in a customized way, but proportionally allocate more parity symbols to the LSBs than to the MSBs. A cooperating decoder performs the inverse function of the decoder, but is able to correct more errors occurring with respect to the bits of lesser significance relative to bits of greater significance.</p>
<p id="p-0065" num="0064">(2) n-level NAND Flash With Custom Circuit Topology and Custom Interface using TCM</p>
<p id="p-0066" num="0065">As recognized above, a multi-level storage system has bit error probabilities that vary according to the significance of the bits in each data symbol. TCM coding can be used to deal with this fact by applying more robust coding to the LSB (or bits of greater significance than the LSB but of lesser significance than the MSB) of each data symbol via a convolutional code, and more general constellation mapping may be applied to the remaining bits of each data symbol. The effect of this encoding is to provide for correction of the predominance of LSB errors that occur on readback as well as the lesser frequency of more significant bit errors that also occur. However, the decoding process misses some errors that the next level of FCC correction, in this case a Reed-Solomon code, is targeted to subsequently correct. Although the action of the TCM decoder is to reduce the natural error frequency in the readback sequence by orders of magnitude, errors can still appear at the output of the TCM decoder. These TCM decoder errors have two salient characteristics:</p>
<p id="p-0067" num="0066">(1) Error probabilities are still distributed bit-by-bit relative to the bit significance of decoded data symbols. The lower the significance of the bits of each decoded data symbol, the greater the probability it will be subject to error. Nevertheless, decoding errors can occur on any or all bits of each symbol returned by the decoder.</p>
<p id="p-0068" num="0067">(2) Although many decoding errors occur on individual bits of decoded data symbols in an isolated fashion, there is nevertheless a tendency for decoding errors to appear in groups, and in instances where these groups of bits fail, the subsequent FCC correction design should be able to correct them to a great extent.</p>
<p id="p-0069" num="0068">Prior art implementations of Reed-Solomon error correction are able to correct errors with the above properties given sufficient overhead. The present disclosure facilitates improvement relative to prior art methods, in one sense, by making possible greatly reduced overhead to achieve the same result, with the benefit of enhanced efficiency. Greatly reduced overhead with the benefit of enhanced efficiency is provided by recognizing that error probability varies bit by bit and relying on this property to encode at least the LSBs independent of other bits; and to encode non-LSBs in a methodical way. Accordingly, the predominance of LSB errors as well as correlated non-LSB errors are corrected with more efficiency than the efficiency that is exhibited by prior art approaches.</p>
<p id="p-0070" num="0069">Aspects of the present disclosure relative to the prior art</p>
<p id="p-0071" num="0070">(1) For 2-level NAND Flash (exemplary) with Standard Circuit Topology and Standard Interface. More efficient utilization of spare bytes available for use as FCC parity is provided with the result that on average, more data errors can be corrected per block than in prior art implementations. This, in turn, makes possible more reliable and/or longer-life memory than otherwise possible. Viewed in one sense, the memory can degrade to a greater degree over its life and yet remain useful for a relatively longer period of time, since the errors associated with the degradation will be correctable up to some number of errors that exceeds an overall correction power of the correction scheme that is employed.</p>
<p id="p-0072" num="0071">(2) For NAND memory (exemplary) with 2-bits or more per cell in a custom memory configured with a custom interface, it is possible for a system to use significantly fewer FCC parity symbols per block than would be possible by prior art approaches to FCC encoding to maintain a given degree of correction capability. Of course, this improvement can manifest itself in higher density, more reliable memory relative to prior art approaches to FCC implementations.</p>
<p id="p-0073" num="0072"><figref idref="DRAWINGS">FIGS. 11</figref><i>a </i>and <b>11</b><i>b </i>illustrate one manner in which 2-bit symbols might be managed in one embodiment.</p>
<p id="p-0074" num="0073">In <figref idref="DRAWINGS">FIG. 11</figref><i>a</i>, the conversion of a series of 2-bit memory symbols <b>240</b> to unencoded interleaves <b>240</b> and <b>242</b> is diagrammatically represented. The symbols can represent values stored in 2 bit per cell memory locations. What is illustrated resides in constructing two separate interleaves by splitting each 2-bit symbol into its MSB and LSB. The MSB makes up or is added to the upper one of the interleaves in the figure and the LSB makes up or is added to the other, lower interleave in a sequential manner. The process is reversible as indicated by arrows <b>246</b>. The two interleaves constructed this way can be Reed-Solomon encoded according to the approach shown in <figref idref="DRAWINGS">FIG. 11</figref><i>b. </i></p>
<p id="p-0075" num="0074"><figref idref="DRAWINGS">FIG. 11</figref><i>b </i>is a diagrammatic illustration showing one embodiment in which a budgeted amount of overhead available for Reed-Solomon parity can be allocated to the encoding of the interleaves constructed in <figref idref="DRAWINGS">FIG. 11</figref><i>a</i>. First of all, it is presumed that the interleaves constructed in <figref idref="DRAWINGS">FIG. 11</figref><i>a </i>have been converted from a sequence of bits into a sequence of Reed-Solomon Symbols that can be directly encoded by a Reed-Solomon Checkbyte Calculation process acting on each interleave. FCC encoding can then be performed on the interleaves. The procedure for doing so may be consistent with conventional methods (familiar to Reed-Solomon practitioners) or the procedure may involve separate treatment of the interleaves. In either case, the result is a Reed-Solomon encoding which results in a series of residue symbols (checkbytes) accompanying each interleave. <figref idref="DRAWINGS">FIG. 11</figref><i>b </i>illustrates that a set of K overhead symbols can be available for the overall set of residue symbols. In the present example, however, K/2+R of this total can be allocated to Interleave <b>0</b> (containing the LSBs which are most likely to be in error), and K/2&#x2212;R can be allocated to Interleave <b>1</b> (containing the MSBs) which are less likely to be in error. R, in this example, can be any value less than one-half the value of K. Accordingly, customized error correction has been applied on the basis of bit significance. Additional examples will be provided below which extend the concepts that have been brought to light thus far to more complex situations. It can be seen that a greater number of parity symbols have been dedicated to the LSB of Interleave <b>0</b>.</p>
<p id="p-0076" num="0075">It should be appreciated that a multi-layered coded system includes at least two encode and two decode blocks. A multi-level channel or medium allows the transfer or storage of information in a digital form represented by more than 1 bit. A 1 bit system is generally referred to as a single level system. Two bits requires at least <b>4</b> levels to fully represent digitally, three bits requires <b>8</b> levels, 4 bits 16 levels and so on in a 2^n fashion. As noted above, the values that are actually stored in the multi-level memory cells are referred to herein as data symbols.</p>
<p id="p-0077" num="0076">In a system that employs Reed Solomon (RS) error correction as an outer layer of the coding systems and Trellis Coded Modulation (TCM) as an inner layer of the coding system in conjunction with a multi-level channel, it is common that the symbol sizes between the different systems are of different sizes. In a typical system, information (i.e., actual user data) is represented as an 8 bit byte. A Reed Solomon encoding system commonly has symbol sizes other than 8 bits. For example, disk drive RS systems commonly use 10 bit symbols. In Trellis Coded Modulation, on the other hand, coding can vary from 3 bit to 6 bit symbol sizes and multilevel channels may include any number of levels to represent 2 or more bits. The nature of TCM causes errors to tend to occur in bursts. This is a characteristic of the convolution/Viterbi portion of the TCM coding system. It should be appreciated that bursts of errors are best handled in a Reed Solomon system when multiple errors occur in only one RS symbol, as opposed to distributing these errors over multiple symbols. As will be seen, Applicants have recognized that the characteristics of these two different coding systems lend themselves to arranging or mapping the bits and symbols of the different systems in memory cells in a fashion that best utilizes the strengths of each system.</p>
<p id="p-0078" num="0077">In a multilevel channel, the least significant bit has the highest probability of error, as described above. For this reason and in one exemplary embodiment, a convolutional code along with a maximum likelihood detector can used on the LSB alone while the most significant bits can be coded through constellation mapping. TCM coding, however, then generates parity bits such that there are more least significant bits than most significant bits. It should be appreciated that when errors occur in the LSBs, the errors can affect the constellation selection for the MSB's, which results in even more errors. Furthermore, should a burst of errors occur out of the TCM, it is more likely to influence the least significant bit. Thus, the correction system can benefit by imposing the Reed Solomon symbols in a way which operates to effectively spread the correction capability of the RS system over a larger burst of errors.</p>
<p id="p-0079" num="0078">Turning to <figref idref="DRAWINGS">FIG. 12</figref>, a data structure or mosaic is generally indicated by the reference number <b>100</b> and diagrammatically illustrated. Data structure <b>260</b> may be imposed on an arrangement of memory cells M<b>1</b>-M<b>120</b> that are shown in four rows <b>262</b><i>a</i>-<b>262</b><i>d </i>of 30 cells each for illustrative purposes and a number of which are designated within dashed rectangles. These memory cells can be addressable in a sequential manner, although this is not a requirement. In the present example, each memory cell stores a four bit value as a data symbol, for example, as some amount of charge in a flash memory cell. Corresponding bit values are labeled as Bit <b>0</b> through Bit <b>3</b> adjacent to each row in the figure. Further, a distribution of four interleaves of data is illustrated throughout the map with each interleave containing Reed Solomon symbols that are produced from a respective one of four blocks of data. It is noted that a key <b>270</b> is provided which shows the various regions that form the interleaves. The symbol that is received by each tile may be referred to as a channel symbol. The first interleave is illustrated using a diagonal cross hatch that is applied to those bit positions containing the first interleave. The second interleave is illustrated using a horizontal cross hatch that is applied to those bit positions containing the second interleave. The third interleave is illustrated using a vertical cross hatch that is applied to those bit positions containing the third interleave. The fourth interleave is illustrated using no cross hatch applied to the bit positions that contain this data. Data structure <b>260</b> further imposes a mosaic on the memory cells that is made up of a pattern of mosaic tiles, each of which can contain one ten bit Reed Solomon symbol at a given time. In the present example, the first 30 memory cells are shown, with the bits of these memory cells having been assigned Mosaic Tile (MT) numbers MT-<b>1</b><sub>a </sub>through MT-<b>11</b><sub>a</sub>. At least ten Reed Solomon bit locations are encompassed by each mosaic tile, with the individual Reed Solomon bit numbers being designated in each mosaic tile as <b>0</b>-<b>9</b>. For MT-<b>2</b><sub>a </sub>through MT-<b>6</b><sub>a </sub>and MT-<b>8</b><sub>a </sub>through MT-<b>11</b><sub>a</sub>, the Reed Solomon bit numbers are arranged in what is termed as a serpentine fashion which can range across bits <b>1</b>-<b>3</b> of the memory cells, as illustrated, before proceeding to use bits of an adjacent memory cell. For example, in MT-<b>2</b><sub>a</sub>, bits <b>1</b>-<b>3</b> of memory cell <b>3</b> contain Reed Solomon bits <b>1</b>-<b>3</b>, respectively. Bit <b>3</b> of memory cell <b>4</b> contains Reed Solomon bit <b>0</b>. Bits <b>1</b>-<b>3</b> of memory cell <b>2</b> contain Reed Solomon bits <b>4</b>-<b>6</b>, respectively, and Bits <b>1</b>-<b>3</b> of memory cell <b>1</b> contain Reed Solomon bits <b>7</b>-<b>9</b>. The Mosaic Tiles which contain Reed Solomon bits arranged in a serpentine pattern may be referred to as serpentine tiles. In contrast, MT-<b>1</b><sub>a </sub>and MT-<b>7</b><sub>a </sub>may be referred to as &#x201c;flat tiles&#x201d;, since these two MTs contain all bit zeros for memory cells <b>1</b>-<b>30</b> within these two Reed Solomon symbols. Insofar as these flat tiles contain the bitstream that is associated with the least significant bit selected as a group, it should be appreciated that a collective error probability for these flat mosaic tiles represents a maximum error probability with respect to all of the mosaic tiles. Selection of a different group of bits for assignment to another tile results in a lesser collective error probability since the different group of bits includes bits that are associated with lesser probability of error. It should be noted that the subject flat tiles contain 15 bit positions, as opposed to the 10 bit positions that are contained by the serpentine tiles. The five extra bit positions are identified using an &#x201c;x&#x201d; which is distributed throughout the ten bit positions of the Reed Solomon symbol stored therein. The x positions are parity bits that are determined by the TCM encoding which is applied in this embodiment to bit zero of the memory cells in order to compensate for the increased error probability that is associated with bit zero of the memory cells.</p>
<p id="p-0080" num="0079">Still referring to <figref idref="DRAWINGS">FIG. 12</figref>, the pattern of MT-<b>1</b><sub>a </sub>through MT-<b>11</b><sub>a </sub>repeats for each successive group of 11 MTs illustrated in the figure. In this regard, subscripts a-d have been applied to designate the row in which a particular MT appears, although such designations have been applied to a limited number of MTs for purposes of illustrative clarity. It is important to understand, however, that the contents of the MTs rotate among the interleaves in a predetermined way. <figref idref="DRAWINGS">FIG. 13</figref> illustrates the mosaic of <figref idref="DRAWINGS">FIG. 12</figref> with each MT having a designation of the Interleave and RS symbol associated therewith. Each MT is labeled as IxSy where x and y represent the interleave number and the number of the Reed Solomon symbol as part of that interleave.</p>
<p id="p-0081" num="0080">In the present embodiment, MT-<b>1</b><sub>a </sub>contains the first RS symbol of interleave <b>1</b> (I<b>1</b>S<b>1</b>) to which TCM encoding has been applied. MT-<b>2</b><sub>a </sub>contains the first RS symbol of interleave <b>2</b> (<b>12</b>S<b>1</b>); MT-<b>3</b><sub>a </sub>contains the first RS symbol of interleave <b>3</b> (I<b>3</b>S<b>1</b>); and MT-<b>4</b><sub>a </sub>contains the first RS symbol of interleave <b>4</b> (I<b>4</b>S<b>1</b>). MT-<b>5</b><sub>a </sub>then contains the second RS symbol of interleave <b>1</b> (I<b>1</b>S<b>2</b>) and MT-<b>6</b><sub>a </sub>contains the second RS symbol of interleave <b>2</b> (I<b>2</b>S<b>2</b>). It should be appreciated that MT-<b>6</b><sub>a </sub>contains RS bits <b>0</b>-<b>4</b> which are actually ahead of a border <b>280</b> at what may be referred to as a leading edge of MT-<b>1</b><sub>a</sub>. For this reason, MT-<b>7</b><sub>a </sub>contains the second RS symbol of the third interleave (I<b>3</b>S<b>2</b>), including TCM encoding. MT-<b>8</b><sub>a </sub>then contains the second RS symbol of the fourth interleave (I<b>4</b>S<b>2</b>); MT-<b>9</b><sub>a </sub>contains the third RS symbol of the first interleave (I<b>1</b>S<b>3</b>); MT-<b>10</b><sub>a </sub>contains the third RS symbol of the second interleave (I<b>2</b>S<b>3</b>); and MT-<b>11</b><sub>a </sub>contains the third RS symbol of the third interleave (I<b>3</b>S<b>3</b>). Rotation among the interleaves then continues by MT-<b>1</b><sub>b </sub>containing the third RS symbol of the fourth interleave (I<b>4</b>S<b>3</b>) with the contents of subsequent MTs being apparent in view of the figure. At a junction <b>282</b>, it can be seen in <figref idref="DRAWINGS">FIG. 12</figref> that RS bit positions <b>0</b>-<b>4</b> of MT-<b>6</b><sub>b </sub>are ahead of what may be referred to as a leading edge <b>282</b> of MT-<b>1</b><sub>b</sub>. For this reason, MT-<b>7</b><sub>b </sub>contains the fifth RS symbol of the second interleave (I<b>2</b>S<b>5</b>). All memory cells shown are subjected to the described mapping. It should be appreciated that the entirety of the mapping pattern has been illustrated and that the mosaic of the figure can now repeat. It can be seen that for each interleave, eleven RS symbols are mapped out in the memory arrangement. Moreover, symbols from the various interleaves are distributed among the mosaic tiles in a way which balances error probabilities among the interleaves since each interleave appears twice in one of the flat tiles. By way of example, a Reed Solomon symbol size of 10 bits was selected with a 4 bit data symbol size. It is to be understood that this selection is not intended as being limiting and that the concepts that have been brought to light are considered to be applicable to a wide range of combinations of RS symbol sizes and data symbol sizes.</p>
<p id="p-0082" num="0081">Referring to <figref idref="DRAWINGS">FIG. 14</figref>, a flow diagram is presented which illustrates one embodiment of a packing technique that produces the mosaic of <figref idref="DRAWINGS">FIGS. 12 and 13</figref>. Initially, at <b>300</b>, the RS symbols can be serialized preparatory to packing. At <b>302</b>, a flat tile is loaded with an RS symbol. This symbol can include TCM encoding. At <b>304</b>, the next serpentine tile is loaded with an RS symbol. At <b>306</b>, a test determines if additional symbols remain to be packed. If not, the process ends at <b>310</b>. If, however, there are additional symbols, at <b>312</b> the leading border is tested to determine if any bits of the last serpentine tile to be loaded fall have crossed the border. In some cases, the bits of the last serpentine may pack against the border perfectly which is treated as if the border has been crossed. In either case, the next flat tile is then loaded with a symbol at <b>302</b>. If no bits have surpassed the border or the last serpentine tile did not pack perfectly against the border, the next serpentine tile is loaded at <b>304</b>. It is considered that this packing technique enjoys broad applicability. For example, it is not limited to the use of Reed Solomon symbols and may readily be adapted to a wide range of mosaics and associated tile patterns. These tile patterns may subject more than one data bit to a flat tile in combination with at least two other data bits being subjected to a serpentine pattern. Moreover, the flat tiles may be of different lengths such that different borders can be tested at different times.</p>
<p id="p-0083" num="0082">Referring to <figref idref="DRAWINGS">FIG. 15</figref>, one embodiment of a data structure is generally indicated by the reference number <b>400</b> and is diagrammatically illustrated. Data structure <b>400</b> may be imposed on an arrangement of memory cells M<b>1</b>-M<b>40</b> that are shown in four groups of ten. In the present example, each memory cell stores four bit values wherein a rightmost column indicates the bit <b>0</b> value and bits <b>1</b>-<b>3</b> are shown to the left of the bit <b>0</b> column. These memory cells can be addressable in a sequential manner, although this is not a requirement. Further, a distribution of four interleaves of data is illustrated throughout the data structure with each interleave containing Reed Solomon symbols that can be produced from a respective one of four blocks of data. It is noted that a key <b>402</b> is provided which shows the various regions that form the interleaves. The first interleave is illustrated using an orthogonally intersecting cross hatch that is applied to those bit positions containing the first interleave. The second interleave is illustrated using a vertical cross hatch that is applied to those bit positions containing the second interleave. The third interleave is illustrated using no cross hatch applied to the bit positions that contain this data. The fourth interleave is illustrated using a horizontal cross hatch applied to the bit positions that contain this data. Data structure <b>400</b> further imposes a mosaic on the memory cells that is made up of a pattern of mosaic tiles, each of which can contain one ten bit Reed Solomon symbol at a given time. In the present example, the first <b>40</b> memory cells are shown, with the bits of these memory cells having been assigned Mosaic Tile (MT) numbers MT-<b>1</b> through MT-<b>16</b>. It is noted that TCM encoding has not been applied to bit <b>0</b> in the present example such that ten Reed Solomon bit locations are encompassed by each mosaic tile, with the individual Reed Solomon bit numbers being designated in each mosaic tile as <b>0</b>-<b>9</b>. For MT-<b>2</b> through MT-<b>4</b>, MT-<b>6</b> through MT-<b>8</b>, MT-<b>10</b> through MT-<b>12</b>, and MT-<b>14</b> through MT-<b>16</b>, the Reed Solomon bit numbers are arranged in the serpentine fashion which ranges across bits <b>1</b>-<b>3</b> of the memory cells, as illustrated, before proceeding to use bits of an adjacent memory cell. For example, in MT-<b>2</b>, bits <b>1</b>-<b>3</b> of memory cell <b>2</b> contain Reed Solomon bits <b>4</b>-<b>6</b>, respectively. Bits <b>1</b>-<b>3</b> of memory cell <b>1</b> contain Reed Solomon bits <b>7</b>-<b>9</b>, respectively. The Mosaic Tiles which contain Reed Solomon bits arranged in a serpentine pattern may be referred to as serpentine tiles. In contrast, MT-<b>1</b>, MT-<b>5</b>, MT-<b>9</b> and MT-<b>13</b> may be referred to as flat tiles, since these four MTs contain all bit zeros for memory cells <b>1</b>-<b>40</b> within four Reed Solomon symbols. Again, the flat tiles are most likely to be subject to error since these tiles contain the bit zero values for every memory cell, thereby increasing the likelihood of a burst of errors appearing in a single Reed Solomon symbol such that the overall correction capability of the RS code is more likely to be capable of correcting all of the errors, as discussed above, but without using TCM encoding.</p>
<p id="p-0084" num="0083">Referring to <figref idref="DRAWINGS">FIG. 16</figref> in conjunction with <figref idref="DRAWINGS">FIG. 15</figref>, the former illustrates the mosaic tiles of <figref idref="DRAWINGS">FIG. 15</figref> without individual designations of memory cell bits and memory cells in order to clearly show the tiles, but with designations of the RS symbols contained by each tile according to interleave and symbol number. Specifically, tiles are designated in <figref idref="DRAWINGS">FIG. 16</figref> as IxSy, as in <figref idref="DRAWINGS">FIG. 12</figref>, where x is the interleave number and y is the symbol number for the associated interleave. Thus, by way of example, I<b>2</b>S<b>4</b> is the fourth RS symbol of the second interleave. It should be appreciated that additional error protection is realized through the rotation of the four interleaves among the tile positions, as illustrated, protecting any one interleave from being subject to relatively more error probability. That is, each interleave appears one time in the flat tile position (bit <b>0</b> in <figref idref="DRAWINGS">FIG. 15</figref>) during the illustrated complete sequence of the overall mosaic. Accordingly, the error probability associated with memory cell bit zero is distributed evenly among the interleaves. It is noted that the illustrated mosaic of <figref idref="DRAWINGS">FIGS. 15 and 16</figref> has been provided by way of example and the teachings that have been brought to light can be applied to a broad range of data arrangements.</p>
<p id="p-0085" num="0084">Using the specification to this point and figures, it is considered that one ordinary skill in the art can readily implement a controller or like apparatus and associated methods in view of the teachings therein. The following disclosure and subsequent figures are provided for still further explanatory purposes.</p>
<p id="p-0086" num="0085">A controller for a data storage system is a device that makes it possible for a host computer to store and retrieve information to and from, respectively, the storage system's media. The controller presents to its host a set of addressable storage units to which data may be stored. The controller accesses these units on behalf of its host by receiving and executing commands issued by the host and implements functionality that translates these commands into low-level read/write and other transactions with the media. The definition of &#x201c;host&#x201d; or &#x201c;host computer&#x201d; is any device that connects to the controller via an interface that transfers data to and from the host as a result of command-level interactions between the host and the controller. By this definition, the host may or may not be a computer that executes application programs; for one example among many possibilities, it could be another memory controller (such as a RAID controller). The design of this interface can be unique or can be compliant with one of many interfaces defined by standards-based specifications. Data transfer involving the storage media in the storage system, in both directions, is the primary service provided by the controller. Controller functionality is typically implemented as a combination of hardware and software elements: the particular mix comprises an architecture resulting from choices made about performance and cost, among others. Usually, there are types of functions that are by their nature either implemented as hardware or as software. Where there is a choice, the decision criterion is commonly based on a compromise among considerations related to cost and/or performance. Ancillary controller services manage media resources, and ensure the integrity of stored and retrieved information. Additional services that might be included in the controller, but that are not mandatory, can be, for example, data security, or power management.</p>
<p id="p-0087" num="0086">A controller's implementation is necessarily specific to the system role for which it is designed. What kind(s) of host and expected demands therefrom, as well as the technology and extent of the storage media itself are the some considerations from which the functional design requirements can originate. In the case of NAND flash memory, there is an established practice in the design of controllers for NAND flash devices.</p>
<p id="p-0088" num="0087">Controller design targeting NAND flash is in this document exemplary. Aspects of a controller that supports particular needs of multi-level NAND flash storage also apply to other non-volatile storage technologies, including, but not limited to phase change memory (P-RAM), and resistive memory (R-RAM).</p>
<p id="p-0089" num="0088">A data storage system comprised of non-volatile media that successfully stores and retrieves error free information can use various techniques, for example, as described above with regard to <figref idref="DRAWINGS">FIGS. 1-17</figref>, to overcome media imperfections that are exaggerated when storing multiple levels in each cell comprising the memory devices. Media imperfections, take the form of noise regardless of the number of levels stored in each cell, and interactions between each cell and its neighbors can generate distortions that add to the noise. The greater the number of levels stored per cell, the greater is the influence of noise, and so, techniques that store and retrieve error free data must be more robust (which usually requires greater sophistication, and more coding overhead) than corresponding techniques for storage of fewer levels.</p>
<p id="p-0090" num="0089">The following describes at least one embodiment which creates a mechanism and associated method that is particularly suited to per-cell storage of 3 or more bits (8 or more levels per symbol) in media cells characterized by an acceptable amount of noise. The result of this mechanism's application is an optimal balance of data storage capacity in the presence of noise, storage capacity, retrieval performance, application flexibility, and economy of implementation. Realization of the mechanism and its application to non-volatile memory media is the basis of the system being described.</p>
<p id="p-0091" num="0090">Briefly stated, the apparatus and associated method may be realized by the construction of hardware and software that perform a data storage error detection and correction process by some combination of one or more of the four elements that are listed immediately hereinafter (all but one of which are described above):
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0091">(1) Trellis Coded Modulation (TCM),</li>
        <li id="ul0002-0002" num="0092">(2) Bit stream encoding,</li>
        <li id="ul0002-0003" num="0093">(3) an adjunct error detection and correction function, and</li>
        <li id="ul0002-0004" num="0094">(4) system-oriented pre-compensation and post-compensation functions (optional)</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0092" num="0095">All four of these elements may be non-generic in the context of a particular controller design. Each can be configured with some set of parameters that defines the bounds of its behavior and performance, and the mechanism may be &#x201c;tunable&#x201d; so as to accommodate a range of media devices, each with particular noise characteristics, as well as a range of bit-density settings. The &#x201c;tunability&#x201d; attribute of a controller can provide the capability to vary the aforementioned parameters in accordance with characteristics of memory media that may change during the course of operation by the controller.</p>
<p id="p-0093" num="0096">Elements (1), (2), and (3) above may take the form of a method and an apparatus that encode data prior to storing it on the memory media on the one hand, and a method and an apparatus that decodes the data after it has been retrieved from the memory media on the other hand. Hence, a controller implemented using these techniques includes an apparatus for encoding and an apparatus for decoding. Element (4) above comprises a method and an apparatus that operate in parallel with and largely independently from the encode and decode processes of (1), (2), and (3). However, the pre-compensation and post-compensation apparatus, element (4), monitors data flows in the controller and in this respect is a controller component that is integrated with encode and decode flows; actual compensation occurs through the application of compensation values to data passing through the encoding or decoding flow. The encoding and decoding aspects are common to memory controllers in general to the extent that all such controllers support read and write processes. However, distinguishing properties of the described system differentiate such a controller from systems that use prior art read and write processes</p>
<p id="p-0094" num="0097">TCM encoding and decoding in the controller may be configured using the aforementioned &#x201c;tunability&#x201d; attribute in order achieve optimal performance with particular memory media. Programmable configuration parameters include: convolution polynomials, code puncture polynomials, constellation mapping functions, and the convolutionally encoded subset of each TCM symbol.</p>
<p id="p-0095" num="0098">Encoding in this system, as described above, can be a method and corresponding apparatus by which TCM symbols are allocated to codewords of the adjunct error detection and correction (ECC) function according to the probability of failure of each bit in each TCM symbol. For example, consistent with the property recognized above that in a multi-level storage system, bits of lesser significance in a symbol exhibit higher probability of error than bits of greater significance, the Encoding/Decoding function allocates less significant bits from TCM symbols correspondingly more ECC power than more significant bits. In addition, because of a behavior exhibited by the TCM decoding function that tends to propagate errors in the event of a decoding failure, multiple bit errors are observed in decoded TCM symbol streams that are correlated with decoding failure events and not, strictly speaking, determined by the higher probability of less significant bit errors relative to more significant bits (as described above). Accordingly, an additional attribute of the described system as implemented may be the allocation of TCM symbols to error correction power so as to provide a best possible balance between ECC correction capacity and the combination of relative probability of less significant bits versus more significant bits, and TCM error propagation.</p>
<p id="p-0096" num="0099">The adjunct error detection and correction (ECC) function may be any encoding and decoding process that detects and corrects erroneous information during the decoding process. The most desirable ECC implementation, when used with TCM, may be one that uses a multiple interleave Reed-Solomon code. However, narrow sense BCH (as an example) could be used with equal validity even though corresponding encoding parameters for optimum BCH usage would be different than those for Reed-Solomon usage. Other embodiments may use adjunct ECC functions that are yet to be developed.</p>
<p id="p-0097" num="0100">Pre-compensation and post-compensation may be culminations of the method and apparatus that factors-in corrections to the TCM symbol stream before it is written in the case of pre-compensation, or before it is decoded in the case of post-compensation. The overall compensation scheme, in terms of apparatus and associated method, can overcome several difficulties by operating independently of the encoding process and the decoding process, and imposes no processing overhead on the controller's embedded microcontroller (other than supervisory oversight by the controller's software). The compensation scheme functions by monitoring encoding and decoding flows in the controller so as to accumulate information about how data in the flow can be conditioned to mitigate noise independent of the actual decoding flow. The method and apparatus uses the accumulated information to maintain an arrangement used by the controller (usually a look-up table-based approach) to actually apply pre-compensation or post-compensation to the data streams. The generality of compensation hardware combined with the look-up table based approach is advantageous in and by itself. Compensation flexibility can advantageously be maintained even using combinations of the four elements listed above, and this flexibility makes it possible to compensate not only for well-understood data distortion behaviors associated with the medium, but also to programmatically compensate for unforeseen effects, and even non-linear effects.</p>
<p id="h-0006" num="0000">Encoding Description</p>
<p id="p-0098" num="0101">Attention is now directed to <figref idref="DRAWINGS">FIG. 17</figref> which illustrates one embodiment of an encoding method that is generally indicated by the reference number <b>1000</b> and is executable by a controller that is operating in accordance with the teachings above. Generally, the figure shows the encoding flow starting with un-encoded symbols at the top of the figure and finishing at the bottom of the figure with the output of pre-compensated TCM symbols that constitute an encoded result of the process. Each step of method <b>1000</b> is described immediately hereinafter.</p>
<p id="p-0099" num="0102">At step <b>1100</b>, it should be appreciated that un-encoded symbols, henceforth referred to as &#x201c;user data symbols&#x201d;, may be obtained in various ways. For simplicity, all possible ways user data symbols may be supplied to the encoder are termed the &#x201c;source&#x201d;. For example, symbols may be contained in a buffer memory which itself could be either internal to or external to the controller. Such memory-buffered symbols may be read from the memory into the encoding flow after having been transferred from some other location to the memory. As another example, the user data symbols can be sourced directly from an interface as the source that connects directly to the host computer which issues commands, sends and receives data with the controller (and its attached memory devices). As yet another possibility, user data symbols can be generated internal to the controller itself.</p>
<p id="p-0100" num="0103">User data symbols can have two properties defined by specific parameters that are also parameters controlling the encoding flow. These parameters are symbol format and block length.</p>
<p id="p-0101" num="0104">Symbol format is the width of each symbol as understood by the ultimate user of the data being stored and retrieved. In multi-level recording systems, the width of the stored and retrieved symbol may itself be variable, and width as a parameter may be referred to as the &#x201c;bit density&#x201d; setting. The ultimate user may be the host computer connected to the controller, but may also be the controller itself. A user data symbol is normally 8-bits wide. User data symbols may be conveyed to the encoding process as a series of these 8-bit units, by a series of multiples of the 8-bit units, e.g., 32-bits (or <b>4</b> symbols) as an increment or at a time, or by a series of sub-multiples of the 8-bit units, e.g., 4-bits per increment. The width in User Data Symbols may be any value designed to work with a particular embodiment.</p>
<p id="p-0102" num="0105">Block length is a property consistent with storage and retrieval of user data symbols that is generally seen with file-oriented storage devices. Encoding and decoding methods are designed such that they require data symbols being encoded to be finite in number, and this finite number, whatever it is, is called the &#x201c;block length.&#x201d; In some embodiments of the controller, variable block lengths may be accommodated, but the number of possible block lengths may tend to be finite, rather than unbounded. There is no hard constraint on the number of block lengths, but defining an exact number serves to simplify the task set executed by the controller. Block lengths in memory devices can range from a few dozen user symbols, or less, to a few thousand user symbols; some subsystems maintain the specific length as a set parameter adopted by an entire storage device, and some memory systems may allow more than one block length to apply, and still other memory systems may allow the block length parameter to be dynamically varied within the allowed possibilities. Adjunct block length parameters may be present in a given memory subsystem even if the parameters are never used for blocks of user data symbols. Instead, these adjunct block lengths can be used for classes of non-user-data transactions such as meta-data transferred in conjunction with file system, internal addressing and wear leveling, among other transactions.</p>
<p id="p-0103" num="0106">Accordingly, encoding method <b>1000</b> can be applied to block-length sequences of user data symbols obtained from Retrieve Unencoded Symbols <b>1100</b>.</p>
<p id="p-0104" num="0107">By way of example, in step <b>1102</b>, user data symbols are converted to Reed-Solomon symbols. In any given controller embodiment, user data symbols can be presented as a series of units, each unit being comprised of some multiple of User Data Symbols that constitutes the encoding and decoding data path width, and this data path width may vary from one controller embodiment to another without changing essential properties of the system. Likewise, components of a controller's embodiment concerned with Reed Solomon processing may utilize a data path width from among multiple possibilities without altering desired system attributes. The use of Reed Solomon encoding, too, is exemplary, since it would be possible for a particular controller implementation to use, for example, a narrow-sense BCH realization instead of Reed Solomon, or any other suitable ECC. Moreover, an adjunct Error Correction technique that has yet to be developed may be found to be suitable.</p>
<p id="p-0105" num="0108">Symbol conversion generally is a width conversion: no information is added in the process of doing the conversion. One exception is the situation in which fill bits can be added to the final Reed-Solomon symbol in order to finish conversion of an integral number of user symbols into an integral number of Reed-Solomon symbols.</p>
<p id="p-0106" num="0109">For example, the user data block length might be chosen as 24 bytes which contains 24*8, or 192 bits; and the Reed-Solomon symbol size might be chosen as 9 bits. So, the conversion from user data format to Reed-Solomon format would be a conversion of 24 user data symbols (bytes) to 22, 9-bit Reed Solomon symbols. Because 22*9=198, the number of bits in the resultant Reed-Solomon symbols exceeds the number of bits in the 24 user data bytes by 22*9&#x2212;24*8=6 bits, hence the final Reed Solomon symbol generated from the conversion is comprised of 6 fill bits in addition to the 3 bits obtained from the user data block.</p>
<p id="p-0107" num="0110">The result of step <b>1102</b> is the user data block expressed as a block of Reed-Solomon symbols. When the Reed-Solomon symbol size is different from the user data symbol size, the symbol count of the resultant Reed-Solomon symbols is different from the user data symbol count. If the Reed-Solomon symbol contains more bits than the user data symbol, then this count is less than the user data symbol count, and the reverse would be true were the Reed-Solomon symbol to contain fewer bits than the user data symbol Of course, this flow is exemplary, and so if narrow sense BCH were to be applied instead of Reed Solomon, the symbols would be bits, and the number of bits presented at each process step would be a bit multiple rather than a Reed-Solomon symbol multiple.</p>
<p id="p-0108" num="0111">The symbols generated by step <b>1102</b> are un-encoded in that they still contain only user data information (with the possibility of inserted fill bits to the final symbol), although here the symbols are the result of conversion from user data format.</p>
<p id="p-0109" num="0112">An RS encode step <b>1104</b> is a parity calculation step. Since Reed-Solomon is an exemplary flow in this discussion, the encoding process would be equally valid for a narrow-sense BCH, in which a BCH encoding process would also be a parity calculation function. In either case, the parity calculation process takes as input Reed-Solomon (or BCH) symbols, and finishes by appending parity in the form of Reed-Solomon (or BCH) symbols, respectively. This process step produces as output the same block of symbols presented as input plus an additional set of symbols comprising the parity.</p>
<p id="p-0110" num="0113">An optional randomizing step (not shown) can be performed just after RS (or BCH) parity calculation. The randomization can be achieved by applying a transformation function that randomizes the symbols in a way that is independent of both symbol values and of subsequent encoding (and decoding) processes; as a result, the inverse transformation is easily applied during the read-back and decoding processes. The randomization step minimizes sensitivities in encoding and decoding flows to influence of patterns that might appear in real data. The tendency toward sensitivity to particular data patterns is a phenomenon commonly observed among practitioners of the art relative to the content of this disclosure. The number of parity symbols is determined by parameters associated with the particular encoding. Key among these are the correction capacity, in symbols, of the selected encoding (whether Reed-Solomon or BCH), and the number of interleaves encoded.</p>
<p id="p-0111" num="0114">The result of encoding step <b>1104</b>) is a block of encoded symbols, the form of which is consistent with prevailing practice which would be recognizable to practitioners of ordinary skill in the art. If a Reed Solomon code is used, the output block is comprised of a message portion which is the same length as the input symbols from step <b>1102</b> followed by a parity field containing an additional number of symbols defined by the Reed-Solomon correction capacity and the number of interleaves. It should be noted that the message symbols and the parity symbols may have been randomized, so values of the message portion can be different from the original message, and the parity portion may be randomized relative to parity symbols calculated by the encoder. If BCH is used, the output symbols include the bits of the original user data message followed by the parity field. The BCH parity field contains a specific number of bits which is dependent on BCH parameters that include, but are not limited to, the bit correcting capacity of the selected BCH configuration, and the number of interleaves. The remaining determinant of BCH parity size in the result from step <b>1104</b> is the configuration of the defining generator polynomial for the specific implementation.</p>
<p id="p-0112" num="0115">In step <b>1106</b>, RS symbols are converted to unencoded TCM symbols using bitstream encoding as taught above (see, for example, <figref idref="DRAWINGS">FIG. 12</figref>). While this step is another data conversion function, in contrast to the conversion of user data to Reed-Solomon (or BCH) symbols, step <b>1106</b> involves application of encoding rules to incoming symbols to produce a block of un-encoded TCM symbols. The encoding rules constitute a transformation that reorganizes the Reed-Solomon (or BCH) symbols into a data structure which, by way of example, can have the form and properties of the mosaic structure described with regard to <figref idref="DRAWINGS">FIGS. 12 and 13</figref>, and implemented by the method of <figref idref="DRAWINGS">FIG. 14</figref>. This step is particular to specific embodiments of a controller produced according to this disclosure since for purposes of integrating the selected Reed-Solomon (or BCH) realization with a selected TCM realization so that together they can cooperate to provide an encoding with an optimum combination of correcting power and encoding overhead. The conversion is sensitive to parameters in the Reed-Solomon (or BCH) and TCM encoder configuration that, in turn, influences parameters in the conversion process. These parameters include:</p>
<p id="p-0113" num="0116">For Reed-Solomon or (BCH), symbol size, symbol correction capacity (T), and the number of interleaves.</p>
<p id="p-0114" num="0117">For TCM, number of bits from each un-encoded TCM symbol that are convolutionally encoded, convolution polynomial, and the puncture configuration.</p>
<p id="p-0115" num="0118">The result of step <b>1106</b> is a block of symbols that have been transformed by Reed-Solomon encoding and randomization, and which have been resized to fit the symbol width of the TCM encoder. Attendant to the result of conversion <b>1106</b> is the allocation of the symbol set from step <b>1104</b> into TCM symbols with RS (or BCH) interleaves dedicated to TCM input symbols in accordance with the higher relative probabilities of LSB errors as well as the correlation of errors in non-LSBs (i.e., bits of greater significance than the LSB) with errors in LSBs (due to TCM decoding errors in the decoder). Hence, a specific flow definition in step <b>1106</b> relative to configurations of RS (or BCH) and TCM, can define the un-encoded TCM symbols as a data structure consistent, for example, with the format described earlier and illustrated by <figref idref="DRAWINGS">FIGS. 12 and 13</figref>. By this criterion, the result is to apply the highest correction power to the LSB that has the highest probability of error.</p>
<p id="p-0116" num="0119">A TCM encoding step <b>1108</b> is uses the symbols from step <b>1106</b>. This process is well-understood in the art and there are many examples in the engineering literature. The particular encoding process can be tuned to the memory media being accessed by the controller, and so different controller embodiments can be fitted with appropriate configuration parameters. In this sense, the TCM configuration can be a determinant to the configuration of accompanying Reed-Solomon (or BCH) realizations as well as to the encoding process step.</p>
<p id="p-0117" num="0120">The result of TCM encoding <b>1108</b>) is a block of encoded TCM symbols. These symbols are &#x201c;pure&#x201d; in the sense that they represent exact multi-level Memory Cell Storage Targets to be stored in suitable form (an amount of charge, a resistance, etc.) in non-volatile media. At this point, the encoding process has added coding overhead in the form of RS (or BCH) parity and TCM overhead. It is randomized data both explicitly by randomization that may be performed in step <b>1102</b> and by the action of the convolutional encoder. Accordingly, the symbols available at this point in the flow are no longer recognizable as user data. Nevertheless, the symbols contain redundancy by which data errors induced during the write and read process can be corrected and the original (stored) user data symbols completely recovered.</p>
<p id="p-0118" num="0121">A pre-compensation step <b>1110</b>) may be applied as an option in some embodiments. As with other approaches to data storage, it is possible to apply compensation to data before it is written to the media in order to counter known distortions. With non-volatile storage technologies, some distortion mechanisms are well-understood, and some, as with emerging non-volatile technologies may not be well-understood. Consequently, pre-compensation can apply a generalized process that makes adjustments for known mechanisms in memory such as, for example, NAND flash, but which has the flexibility to be reprogrammed for other types of memory.</p>
<p id="p-0119" num="0122">The result of pre-compensation, if applied in this embodiment, is a block of encoded and compensated TCM symbols. As of step <b>1110</b>, these symbols represent the actual Memory Cell Target Values that will be applied during the write process to whichever non-volatile storage medium is attached to the controller.</p>
<p id="p-0120" num="0123">Deliver Encoded Symbols provides the resultant symbols culminating from steps <b>1110</b> to <b>1112</b>.</p>
<p id="h-0007" num="0000">Decoding Description</p>
<p id="p-0121" num="0124">Referring to <figref idref="DRAWINGS">FIG. 18</figref>, attention is now directed to one embodiment of a decoding method, generally indicated by the reference number <b>1200</b>, which may be employed by a controller that is configured in accordance with the present disclosure.</p>
<p id="p-0122" num="0125">A Retrieve Encoded Symbols step <b>1201</b> represents a generalized read method that a controller can use to retrieve TCM symbols from a storage medium. A read method that supports retrieval of multi-level symbols from NAND flash as a source of symbols to the decoder is one suitable, but non-limiting example. Another suitable example resides in a read method that supports retrieval of multi-level symbols from a phase-change memory (PCM) device, as are read processes that attach to multi-level devices of other technologies. Similarly, read methods that support retrieval of symbols from other non-volatile memory devices serve as additional examples.</p>
<p id="p-0123" num="0126">It should be appreciated that Read Encoded Symbols <b>1201</b> generates sequences of encoded TCM symbols. A given sequence can correspond to a single data block. At this point, the symbols have received no conditioning in the process of being retrieved, for example, from memory media. Hence, the symbols represent data symbols as stored in the memory medium, which are as yet unprocessed by the read-back apparatus. In accordance with the properties and requirements of the TCM decoding method, these symbols can comprise a data portion corresponding to the number of data bits being stored in each memory cell (e.g., 3 bits, 4 bits, or greater), and a &#x201c;soft&#x201d; portion that pinpoints a multi-level Memory Cell Target Value with precision greater than that possible with the data portion of the value alone. Normally, the data plus soft bits of each sample are the result of an analog to digital conversion (ADC) obtained after sensing a memory cell's contents; this conversion is part of the Read Encoded Symbols process in (<b>1201</b>).</p>
<p id="p-0124" num="0127">An optional post-compensation step can be applied at <b>1202</b>. With regard to this step, it should be appreciated that distortions to originally targeted symbol values occur as a by-product of these symbols having been stored in specific memory cells and then retrieved by a read/retrieval method. To the extent that these distortions are understood and reproducible by one or more processes in the controller, Post-Compensation can be applied.</p>
<p id="p-0125" num="0128">Post-Compensation <b>1202</b>, if applied, results in sequences of compensated TCM symbols that are still in TCM-encoded form. By removing predictable distortions from the symbols returned from the Read Encoded Symbols step <b>1201</b>, some of the noise present in retrieved symbols is removed, thereby reducing the error correction overhead required of the remaining decoding steps relative to what the error correction overhead would have been with no Post-Compensation. Hence, post-compensation can serve to reduce noise. In effect, the symbols at this point in the decoding process are the same symbols as would be obtained directly from step <b>1201</b> except that they are less noisy. In an embodiment that does not use post-compensation, step <b>1204</b> can operate directly on the symbols retrieved by the Read Encoded Symbols process <b>1201</b>.</p>
<p id="p-0126" num="0129">A TCM decode step <b>1204</b>) decodes TCM symbols obtained, for example, from step <b>1202</b> by producing symbols that are the same (or close to the same) as the symbols originally input to the encoder. When some of the result symbols differ from original symbols input to the encoder, the variance is generally the result of TCM decoding error(s) due to misinterpretation of the encoded input symbols. Usually, distortions introduced via juxtaposition of Encoder Deliver Encoded Symbols Step <b>1112</b> (see <figref idref="DRAWINGS">FIG. 17</figref>) with Decoder Retrieve Encoded Symbols Step <b>1201</b> have resulted in noise that exceeded the TCM decoder's ability to remove the resulting errors. This is also in light of whatever Pre-Compensation and Post-Compensation steps may have been executed in line with Encoder Deliver Encoded Symbols and Decoder Retrieve Encoded Symbol steps. TCM decoding is well understood by practitioners of the controller and Data Communications arts, but is considered to provide heretofore unseen advantages when implemented in light of the teachings herein. As such, it is considered that one having ordinary skill in the art is enabled with respect to practicing the TCM processes described herein with this overall disclosure in hand.</p>
<p id="p-0127" num="0130">It should be appreciated that one result that is attendant to TCM encoding (see <figref idref="DRAWINGS">FIG. 17</figref>) resides in an expansion of the symbol set which expansion is reversed by the decoding process of <figref idref="DRAWINGS">FIG. 18</figref>.</p>
<p id="p-0128" num="0131">TCM-decoded TCM symbols are the result of TCM Decode step <b>1204</b>. These symbols include the Bitstream programming organization effected by the Reed-Solomon to TCM conversion with Bitstream Encoding of step <b>1106</b> in <figref idref="DRAWINGS">FIG. 17</figref>. As such, the error configurations introduced by sequence misinterpretation by the TCM decode step (to the extent such misinterpretations may have occurred) are distributed in a predictable way in these symbols. This predictable distribution can be accompanied by subsequent decoding steps in such a way that errors which do occur can be maximally reversed.</p>
<p id="p-0129" num="0132">At step <b>1206</b>, conversion of decoded TCM symbols to Reed-Solomon symbols is the result of reformatting a sequence of TCM symbols so that they become a corresponding sequence of Reed-Solomon symbols. Other ECC approaches could be used while still remaining within the bounds of the teachings of this disclosure, so the conversion in this step could be to symbols from a narrow-sense BCH code (for example) with equal validity. Step <b>1206</b> is a re-packing of TCM symbols to Reed-Solomon symbols, and it is significant to note that after the conversion is complete, the Bitstream Encoding added during the encoding process (<figref idref="DRAWINGS">FIG. 17</figref>) is still present.</p>
<p id="p-0130" num="0133">The symbols produced by step <b>1206</b> are the result of TCM symbol to the exemplary Reed-Solomon symbol conversion. One function of step <b>1206</b> (in addition to the conversion of TCM symbols to adjunct ECC symbols&#x2014;e.g., Reed-Solomon) can be conversion from the data structures illustrated by <figref idref="DRAWINGS">FIGS. 12 and 13</figref> as part of the conversion from TCM. The symbols at this point are un-encoded symbols from the ECC code, in <figref idref="DRAWINGS">FIG. 18</figref> shown as Reed-Solomon by way of example. Other ECC approaches could be applied, with one notable embodiment being narrow-sense BCH. Regardless of the ECC approach used here, it is noted that encoding introduced during the encoding flow is present in these symbols. That is, in the instance of RS, the RS parity symbols are present.</p>
<p id="p-0131" num="0134">An RS decode step <b>1208</b> decodes the symbols received from step <b>1206</b>. Decoding removes differences that might be present in the decoded symbols relative to the symbols originally generated by RS Encode step <b>1104</b> of <figref idref="DRAWINGS">FIG. 17</figref>. The extent of such differences that can be removed is a function of the implementation. Also, parity symbols added during RS Encoding are also removed. This step is conceptually and practically the same if some approach other than Reed-Solomon is chosen. In any embodiment, however, the decoding that is performed is a reversal of that performed during the encoding step, so that both the encoding and decoding are defined by the same ECC configuration. Step <b>1206</b> also reverses randomization of it was employed in the encode process.</p>
<p id="p-0132" num="0135">Decoded RS symbols are &#x201c;clean&#x201d; in the sense that all data errors caused by distortions from the storage and retrieval process have been removed at least within the capability of the codes. For a successfully decoded block of symbols, these symbols are identical to the Reed-Solomon message symbols originally input to the Reed-Solomon Encoder.</p>
<p id="p-0133" num="0136">Step <b>1210</b> is effectively the final step in the decoding flow in the sense that its result should be the original set of user data symbols. The exemplary Reed-Solomon symbols from step <b>1208</b> are converted to user data symbols. Because of the encoding still in effect, the step is more than a simple change of symbol size from Reed-Solomon to User Data symbols: the function performed here is to reassemble user bytes from ECC interleaves that contain bits of lesser significance as distinct from interleaves that contain bits of greater significance. Some interleaves contain only LSBs, and some interleaves contain bits of greater significance. This is another inverse transformation, in that it is intended to be the exact reverse of the forward transformation performed by encoding step <b>1102</b> of <figref idref="DRAWINGS">FIG. 17</figref>.</p>
<p id="p-0134" num="0137">User Data symbols are output symbols from both the decoding flow. They are identically the symbols originally presented by the Encoder's Source (<b>100</b>).</p>
<p id="p-0135" num="0138">At step <b>1212</b>, user symbols from step <b>1210</b> are sent to the Destination. As with the Retrieve Unencoded Symbols step of the Encoder, there are many suitable ways in which this step can be completed a complete listing of which is not necessary to the overall integrity of the present disclosure.</p>
<p id="h-0008" num="0000">Encoding Apparatus</p>
<p id="p-0136" num="0139"><figref idref="DRAWINGS">FIG. 19</figref> is a block diagram which illustrates one embodiment of a controller <b>1300</b>, shown within a dashed rectangle, for non-volatile memory. A source <b>1301</b> can vary from one controller embodiment to another. Usually, the Source is a memory, but other arrangements can exist in a controller without changing desired attributes of the system. Relative to overall Encoder <b>1300</b>, the Source supplies User Data Symbols.</p>
<p id="p-0137" num="0140">An input symbol to RS symbol packer (i.e., RS encoder) is indicated by the reference number <b>1302</b>. Input symbols, usually as a multiple of 8-bit User Data Symbol values are obtained from Source <b>1301</b>. Packer <b>1302</b> converts each set of 8-bit values into a set of Reed-Solomon symbols and may operate on one input unit per step. Input units can be of any size, but usually the unit size is either one input symbol or a few input symbols, where the input symbols are made up of User Data Symbols. Input symbols are presented as a sequence, and packer <b>1302</b> is configured for the exact sequence length that will be encoded. Because the number of User Data Symbols comprising the input sequence is likely to be different than the number of Reed-Solomon symbols that results, the Block Length in symbols can have two values relative to packer <b>1302</b>. One value (in symbols) is the Block Length in User Data Symbols and the other value is the Block Length in Reed-Solomon symbols. When the number of User Data Symbols does not convert into an integral number of Reed-Solomon symbols, the packer can determine the number of fill bits that need to be inserted into the last Reed-Solomon output symbol in order to achieve an integral multiple of Reed-Solomon symbols in the final output Block of Reed Solomon Symbols.</p>
<p id="p-0138" num="0141">In one embodiment, the User Input Symbols are 8-bits apiece, which is what would normally be expected, and Reed-Solomon symbols may be 9-bits apiece. This means that each 9 Input symbols would map evenly into 8 Reed-Solomon symbols. In another embodiment, a data block of 100 bytes (Input Symbols) would map onto 89 9-bit Reed-Solomon symbols, with the last Reed-Solomon symbol of the sequence having only 8 of its 9 bits used. In this case, the RS packer can close the sequence by inserting a fill bit into the last Reed-Solomon symbol to be generated. While many embodiments are possible, it is evident that a flexible approach may be employed with regard to configuring the RS packer.</p>
<p id="p-0139" num="0142">It should be noted that the use of a Reed-Solomon code is an exemplary case and as such represents only one class of embodiments. While Reed-Solomon configurations may be found to be optimal in the context of Encoding, other approaches could be used instead of Reed-Solomon without limitation, the most notable probably being a narrow-sense BCH code. Of course, it is possible that other suitable approaches may be applied that are yet to be developed while still remaining within the purview of this overall disclosure.</p>
<p id="p-0140" num="0143">A Reed-Solomon Checkbyte calculator <b>1303</b> is conventional to the extent that it is well understood as applied to prior art memory controllers. Checkbyte calculator <b>1303</b> determines a set of additional Reed-Solomon symbols and appends the additional symbols to the set of input symbols. The appended symbols can be called parity symbols, and the combined Input Symbols plus appended parity comprise a Reed-Solomon codeword. For purposes of flexibility, the Reed-Solomon encode/decode or other suitable configurations may be adaptable by way of programmability, so the Checkbyte Calculator in one embodiment can accommodate variable correction capacity (T), and/or a variable number of interleaves. In some embodiments, programmable symbol width can likewise be a programmable parameter. The extent of programmable parameters can depend on the particular controller architecture and may depend on the selected memory media technology.</p>
<p id="p-0141" num="0144">Reed-Solomon Checkbyte Calculator <b>1303</b> may include a randomizing function which is applied to encoded Reed-Solomon codewords to minimize pattern-sensitivities that might exist in the encode and decode functions. The Randomize function chosen, for any given embodiment, can operate independent of the data values it randomizes, so is not affected by data errors returned after written data is retrieved from the memory.</p>
<p id="p-0142" num="0145">A Reed-Solomon to TCM Symbol converter <b>1304</b>, accomplishes one of the features described above with regard, for example, to <figref idref="DRAWINGS">FIGS. 12 and 13</figref> in order to implement the mosaic tile pattern and perform the RS to TCM symbol conversion. This is the encoding function which allocates bits from the Reed-Solomon symbols into TCM symbols recognizing both the manner in which TCM can convolutionally encode the least significant part of each symbol provided to it, and can encode the remaining most significant part by a TCM constellation mapping transformation. In one embodiment, the least significant part of each TCM symbol allocated to the convolutional part of the encoder is a single bit (i.e., the LSB), though this can also be more than the LSB generally by increasing order of significance. The remaining bits of each symbol are then the most significant part that are transformed by the constellation mapping function alone. The Reed-Solomon to TCM conversion does two things which must be properly executed for the approach to work: first, it allocates the bits of one Reed-Solomon symbol into one or more TCM symbols. In one embodiment, the width of a TCM symbol is normally less than that of a Reed-Solomon symbol, the allocation then results in each Reed-Solomon symbol mapping to more than one TCM symbol. Reed-Solomon (or BCH) configurations that operate with TCM encodings of multi-level symbols (3 bits or more) generally require multiple interleaves to be optimal in terms of error correction performance. Hence, in one feature of packer <b>1304</b>, Reed-Solomon symbols can be packed into TCM symbols according to interleaves. This means that for a run length characteristic of the mosaic data structure previously described (see <figref idref="DRAWINGS">FIGS. 12 and 13</figref>), bits composing the resultant TCM symbols are taken from Reed-Solomon in a deterministic fashion. At a minimum, each LSB in each resultant TCM symbol is taken from a Reed-Solomon symbol from an interleave designated for TCM LSBs. Allocation of LSBs and MSBs by interleave exhibits a rotation so that, at one stage of the conversion of <b>1304</b>, a set of LSBs may be taken from an Interleave <b>0</b> Reed-Solomon symbol, and at another stage of the conversion a set of LSBs is taken from a symbol from Reed-Solomon Interleave <b>1</b>. The rotation repeats as a block is converted so that over the course of the block, each Reed-Solomon interleave is allocated a roughly equal number of LSBs. The same sort of rotation applies to TCM bits of greater significance than the LSB such that over the course of a block, each Reed-Solomon Interleave, in turn, has an equal number of LSBs and MSBs, respectively. The total number of Reed-Solomon interleaves may vary (<figref idref="DRAWINGS">FIGS. 12 and 13</figref> represent one exemplary case).</p>
<p id="p-0143" num="0146">The preceding assumes that the TCM encoding strategy is one in which convolutional encoding is performed only on the LSBs of the raw symbol stream. In a scenario in which a sufficiently large number of levels is targeted to memory devices, this strategy could become one in which bits of lesser significance from each symbol are convolutionally encoded. For example, a hypothetical multi-level system might target 6-bit TCM symbols in which the 2 bits of lesser significance are convolutionally encoded, while the 4 bits of greater significance are not convolutionally encoded. Furthermore, the convolutional encoding of each of these lesser significant bits may be different from each other. The least significant bit has the highest error probability and the method therefore may apply a convolutional code of higher error correcting capabilities than the next least significant bit with lower error probability than the least significant bit. The next least significant bit can use a convolutional code with error correcting capabilities in accordance with the error probability of this bit location. In this case, the encoding configuration would be more complicated because the Reed-Solomon (or other) code's symbols would need to be distributed into the TCM symbols by a process that integrates with this configuration fact. Applicants are unaware of any use in the prior art of per-bit convolutional codes as taught herein.</p>
<p id="p-0144" num="0147">One consideration with regard to the conversion performed by converter <b>1304</b> from Reed-Solomon symbols to TCM symbols (and conversely by the decoder, yet to be described, that performs a reverse conversion) relates to the convolutional encoding of TCM expanding the number of input symbols in the convolutionally encoded result. Furthermore, in most controller configurations, this expansion is also the result of a puncture parameter that modifies the extent of added redundancy (minimizes the extent) by constraining the total TCM overhead imposed by the encoding process. Accordingly, the Reed-Solomon to TCM symbol conversion must understand exactly the form of the expansion, and insert placeholders (non-occupied bit values) into its resultant TCM symbols for the expansion that will occur when the symbols are encoded. In the case of prior art TCM implementations, this effect (and associated requirement) is well understood by practitioners of the art.</p>
<p id="p-0145" num="0148">Because a multi-level storage and retrieval system can target non-volatile memory in a generalized way, the controller that implements the multi-level storage system can be flexible and therefore capable of programmatically targeting a range of memory configurations that include variation in the number of bits per Memory Cell Target Value. Accordingly, the encoder (and decoder) can be programmable over a range of encoding (and decoding) configurations. In the case of the Reed-Solomon to TCM symbol conversion, such parameters include the number of Reed-Solomon interleaves, the TCM convolution function, the number of TCM bits of lesser significance convolutionally encoded, the width of TCM symbols (bit density), and the TCM puncture configuration.</p>
<p id="p-0146" num="0149">A TCM encoder <b>1305</b> performs the TCM encoding operation on the un-encoded TCM symbols produced by RS symbol converter <b>1304</b>. Methods and implementations of TCM encoding are well understood as taught, for example, by Ungerboeck's classic paper entitled &#x201c;Channel coding with Multilevel/Phase Signals&#x201d;&#x2014;IEEE Trans. Info. Theory vol. IT 28, No. 1, January 1982, pp 55-67, but it is considered to provide heretofore unseen advantages when implemented in light of this overall disclosure. Moreover, it is believed that some degree of programmability, though not always seen in prior art instances of TCM, would further differentiate from the prior art.</p>
<p id="p-0147" num="0150">Output from TCM encoder <b>1305</b> is a set of encoded TCM symbols. In this form, each symbol represents, in digital form, a Memory Cell Target Value that includes the data bits (e.g., a 4-bit TCM symbol represents a 4-bit Memory Cell Target Value).</p>
<p id="p-0148" num="0151">A pre-compensation corrector <b>1306</b> and a pre-compensation offset calculator <b>1307</b> can implement pre-compensation in the controller, although it is again noted that compensation is an option and not a requirement. It is noted that component <b>1306</b> is generally implements a correction application function, usually an adder, and that item <b>1307</b> generally implements a calculation function. In <b>1307</b>, the calculation function may include the reading of one or more other blocks of information than the current block (the block being processed by the flow being described in the Figure). Hence pre-compensation as it is applied to the current block may be the culmination of reading one or more prior blocks in addition to the current block, and the calculation step provided by <b>1307</b> may be accomplished by accumulating statistics from those prior blocks that may be used to calculate compensating offsets which are applied to the current block via step <b>1306</b>.</p>
<p id="p-0149" num="0152">Resultant symbols from the action of pre-compensation corrector <b>1306</b> and pre-compensation offset adder <b>1307</b> are Memory Cell Storage Target Values that are at this point ready to be written into the memory. Because each Memory Cell Storage Target Value is intended for a specific cell in the memory medium, pre-compensation and write methods can be coordinated with respect to making sure that write symbols are directed to their intended cells. Pre-Compensation can include significant changes to the uncompensated TCM symbols that were input to these blocks. First, whereas the input symbols had only as many bits per symbol as the width of the TCM symbol (memory symbol width), the pre-compensated symbol can be augmented by soft bits which pinpoint the memory Memory Cell Storage Target Value with sub-memory-bit precision. Secondly, the compensation offset can utilize the soft bits (and in some case the memory bits too, depending on the extent of the applied compensation offset).</p>
<p id="p-0150" num="0153">Destination <b>1308</b> is the generalized location to which compensation symbols are directed. Specific embodiments can vary from controller to controller while remaining within the scope of this overall disclosure. In the encoding scheme, the encoded and pre-compensated symbols are ready for writing into the memory itself, but depending on the controller architecture the path from this point to the memory can be more or less direct. Ultimately, the nature of the Destination is a function of the controller's architecture and should be flexibly interpreted so long as the teachings herein are being applied.</p>
<p id="h-0009" num="0000">Decoding Apparatus</p>
<p id="p-0151" num="0154">Attention is now directed to <figref idref="DRAWINGS">FIG. 20</figref> which is a block diagram that illustrates one embodiment of a multi-level non-volatile memory controller <b>1400</b> that is shown within a dashed rectangle.</p>
<p id="p-0152" num="0155">Initially, un-encoded TCM symbols are issued to controller <b>1400</b> from a Source <b>1401</b>, which in this block diagram is a generalized representation of any suitable originator of symbols that are intended for decoding. The symbols coming from the source are ultimately memory symbols obtained by the read process that retrieves them from the memory media. The path they follow from the memory into the decoder can vary with embodiments of the controller.</p>
<p id="p-0153" num="0156">While compensation is itself optional, in this embodiment, a post-compensation offset adder <b>1402</b> and a post-compensation offset calculator <b>1403</b> may be used. In one embodiment, postcompensation Offset Adder <b>1402</b> might be located in the decoder's data path, and postcompensation Offset Calculator <b>1403</b> might be another controller component which is shared between the decoder's post-compensation function and the encoder's pre-compensation function (SGxx on compensation).</p>
<p id="p-0154" num="0157">Source <b>1401</b> provides un-encoded TCM symbols to adder <b>1402</b> including the significant (data) bits of the TCM symbol (memory symbol) and the soft bits. The number of soft bits can depend on the controller and on the type of memory device; generally this can be three or four bits in addition to the TCM bits themselves. The action of adder <b>1402</b> is generally to apply a correction (usually by adding it) to a current TCM symbol. Accordingly, the output of adder <b>1402</b> is a corresponding un-encoded TCM symbol (TCM bits plus soft bits) and this result should be, by the method of post-compensation, a less noisy version of the uncompensated input on a symbol by symbol basis. The compensated output serves as input to a TCM decoder, yet to be described. Otherwise, source <b>1401</b> can feed symbols directly to the TCM encoder in an embodiment where postcompensation is not used.</p>
<p id="p-0155" num="0158">It is considered that one having ordinary skill in the art can readily implement a suitable TCM decoder <b>1404</b> with this overall disclosure in hand. In this regard, a generalized TCM decoder is well understood in the communications engineering arts. Its main structures include a soft Viterbi detector with traceback memory, and a TCM constellation mapping function. The TCM decoder receives unprocessed TCM symbols supplied by the read process, each of which can include soft bits, and returns decoded set of symbols that have the form of un-encoded TCM symbols (i.e., TCM symbols with no soft bits that include placeholders for punctured convolutional expansion).</p>
<p id="p-0156" num="0159">A TCM symbol to RS symbol unpacker <b>1405</b> is configured to invert the packing process of symbol packer <b>1304</b>) in the Encoder (<figref idref="DRAWINGS">FIG. 19</figref>). As such, it has the same set of features and constraints as the forward conversion in packer <b>1304</b>, as well as being the reverse implementation of the encoding.</p>
<p id="p-0157" num="0160">Generally, unpacker <b>1405</b> receives post-compensated and decoded TCM symbols from the TCM decoder and generates Reed-Solomon symbols at its output. The conversion process implemented by this block is the exact inverse of that of the encoding process. Because configurations can vary with respect to TCM parameters, (convolution, puncture, number of LSBs in convolution) and the number of interleaves, the configuration of this functional block should closely reverse the encoded configuration of every data block that it decodes.</p>
<p id="p-0158" num="0161">Resultant Reed-Solomon symbols from unpacker <b>1405</b> correspond to each Reed-Solomon symbol that was input to the Reed-Solomon to TCM conversion of the encoder.</p>
<p id="p-0159" num="0162">A Reed-Solomon Decoder <b>1406</b> performs a final error correction step executed in the controller. Decoder <b>1406</b> should receive, from TCM Symbol to Reed-Solomon Symbol converter <b>1405</b>, an exact number of Reed-Solomon message symbols plus parity symbols generated by the Reed-Solomon encoder prior to writing the data. Together, these symbols comprise a returned message that may contain decoding errors passed along by the TCM decoder. The action of Reed-Solomon decoder <b>1406</b> is to determine whether any errors are indeed present in the input symbols, correct the errors if present, and output the decoded result as user data symbols.</p>
<p id="p-0160" num="0163">It has previously been mentioned that implementation of a controller with Reed-Solomon as the error correcting code is exemplary. In the context of the invention, narrow-sense BCH, for example, could be used in a controller with equal validity.</p>
<p id="p-0161" num="0164">The role of interleaving in the error correction code can provide benefits in view of the disclosure above. In this regard, the Reed-Solomon decoder can be capable of interleaving configurations that are consistent with any applied encoding and TCM configurations that accompany specific multi-level Memory Cell Storage Target Values and specific memory device technologies. In this sense, the Reed-Solomon decoder (and encoder) may be capable of programmability sufficient to support the required system flexibility, and to this end, the decoder may be necessarily reconfigurable with respect to error correction capacity (T), and number of interleaves.</p>
<p id="p-0162" num="0165">A de-randomization unit can be part of the Reed-Solomon Decoder, which would implement an inverse of the randomize function executed in the Encoder (<figref idref="DRAWINGS">FIG. 19</figref>).</p>
<p id="p-0163" num="0166">Reed-Solomon decoding results in removal of parity symbols so that only the original data portion of the message is provided to the output. The message symbols at the output of the decoder represent the original data, but the data is still organized as Reed-Solomon symbols.</p>
<p id="p-0164" num="0167">A converter <b>1407</b> receives Reed-Solomon symbols and repacks them into User Data Symbols. Output from symbol converter <b>1407</b> can be one byte wide, in which case converted output is transmitted one byte per step, or it can be greater than a byte or a portion of a byte. In embodiments where the output might optimally be the width of a wider memory (e.g., 32-bits), converter <b>1407</b> can perform the width expansion and output a full word whenever one becomes available.</p>
<p id="p-0165" num="0168">Destination <b>1408</b> is a generalized representation of the various controller components that might follow the decoder. As with other Source and Destinations shown in the other figures in this document, this one can be implemented in various flexible ways while the teachings herein are nevertheless remain in practice.</p>
<p id="p-0166" num="0169">The foregoing description of the invention has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form or forms disclosed, and other modifications and variations may be possible in light of the above teachings wherein those of skill in the art will recognize certain modifications, permutations, additions and sub-combinations thereof.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. In a system which uses multi-level data encoding where each symbol of a plurality of symbols represents more than one bit of information in a symbol stream that is transferred using a multilevel transmission channel, a method comprising:
<claim-text>in relation to said transfer, representing said symbols in a digital bitwise form such that each symbol is presented as a given plurality of bits where each bit in the given plurality of bits is subject to a different probability of error; and</claim-text>
<claim-text>applying an error correction procedure to each one of the given plurality of bits, for the bitwise digital form of each symbol that is transferred as part of the symbol stream, based on the different error probability that is associated with each bit in the given plurality of bits such that an error correction power is associated with each one of the given plurality of bits and the error correction power for any one bit of the given plurality of bits is different than another error correction power that is associated with any other one of the given plurality of bits and all the symbols of the symbol stream are recoverable subject to the error correction power to compensate at least for channel induced errors.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein said error correction procedure includes:
<claim-text>for the bitwise digital form of each symbol to be transferred, encoding each bit of the given plurality of bits to apply a customized encoding to each one of the given plurality of bits which is based on a bit error rate that is different for each one of the given plurality of bits for use as encoded symbols;</claim-text>
<claim-text>passing the encoded symbols to the multilevel transmission channel as said symbol stream; receiving the encoded symbols from the multilevel transmission channel; and</claim-text>
<claim-text>decoding the encoded symbols, as received from the multilevel transmission channel, in a way that applies a customized decoding to each one of given plurality of bits, based on the bit error rate for each one of the given plurality of bits, to restore the symbols to said digital bitwise form and to recover the symbol stream by removing said customized encoding.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. In a system which uses a plurality of levels to represent a corresponding plurality of symbols, respectively, in a symbol stream and where each one of the plurality of symbols represents more than one bit of information, a method comprising:
<claim-text>converting each one of the symbols to a digitally encoded value using a given plurality of bits such that each bit in the given plurality of bits is subject to a different probability of error; and</claim-text>
<claim-text>encoding the given plurality of bits for each symbol based on the different probability of error for each bit in the given plurality of bits to subject at least one bit of each symbol to a correction power that is different than another correction power for another bit of the symbol thereby producing an error corrected digitally encoded value corresponding to each symbol for subsequent recovery of each symbol as part of the symbol stream.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, further comprising:
<claim-text>transferring the digitally encoded value of each symbol to a multilevel transmission medium;</claim-text>
<claim-text>receiving the digitally encoded value of each symbol from the multilevel transmission medium;</claim-text>
<claim-text>decoding each digitally encoded value based on the different probability of error for each bit in the given plurality of bits to remove the encoding from each bit in the given plurality of bits to recover the symbol stream after transfer through said multilevel transmission medium.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref> wherein said encoding and said decoding includes applying a different error correction power to each bit of the given plurality of bits of each symbol that is based on the bit error rate of each bit in the given plurality of bits.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. In a system which uses multi-level data encoding where each symbol of a plurality of symbols represents more than one bit of information in a symbol stream that is transferred using a multilevel transmission channel, an apparatus comprising:
<claim-text>a first arrangement for representing said symbols in a digital bitwise form, in relation to said transfer, such that each symbol is presented as a given plurality of bits where each bit in the given plurality of bits is subject to a different probability of error; and</claim-text>
<claim-text>a second arrangement for applying an error correction procedure to each one of the given plurality of bits, for the bitwise digital form of each symbol that is transferred as part of the symbol stream, based on the different error probability that is associated with each bit in the given plurality of bits such that an error correction power is associated with each one of the given plurality of bits and the error correction power for any one bit of the given plurality of bits is different than another error correction power that is associated with any other one of the given plurality of bits and all the symbols of the symbol stream are recoverable subject to the error correction power to compensate at least for channel induced errors.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The apparatus of <claim-ref idref="CLM-00006">claim 6</claim-ref> wherein said second arrangement is configured to apply said error correction procedure by encoding each bit of the given plurality of bits, for the bitwise digital form of each symbol to be transferred, to apply a customized encoding to each one of the given plurality of bits which is based on a bit error rate that is different for each one of the given plurality of bits for use as encoded symbols and for passing the encoded symbols to the multilevel transmission channel as said symbol stream and said second arrangement is further configured for receiving the encoded symbols from the multilevel transmission channel and, thereafter, decoding the encoded symbols in a way that applies a customized decoding to each one of given plurality of bits, based on the bit error rate for each one of the given plurality of bits, to restore the symbols to said digital bitwise form and to recover the symbol stream by removing said customized encoding.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. In a system which uses multi-level data encoding where each one of a plurality of symbols represents more than one bit of information in a symbol stream, a method comprising:
<claim-text>converting the symbols of the symbol stream to a corresponding bit stream in which each symbol is represented using a given plurality of bits such that each bit in the given plurality of bits is subject to a different probability of error; and</claim-text>
<claim-text>encoding the bit stream based on the different probability of error for each bit in the given plurality of bits to form an encoded bit stream for transmission and all the symbols of the symbol stream are recoverable subject to decoding to compensate at least for errors induced by the transmission.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. In a system which uses multi-level data encoding where each symbol of a plurality of user data symbols represents more than one bit of information in a user data symbol stream for transfer using a multilevel transmission channel, a method comprising:
<claim-text>in relation to said transfer, representing said user data symbols in a digital bitwise form such that each symbol is presented as a plurality of bits where each bit in the plurality of bits is subject to a different probability of error; and</claim-text>
<claim-text>applying an error correction procedure to the plurality of bits, for the bitwise digital form of each user data symbol that is transferred as part of the symbol stream, based on the different error probability that is associated with each bit in the plurality of bits such that an error correction power for at least one bit of the plurality of bits is different than another error correction power that is associated with another one of the plurality of bits and all the symbols of the symbol stream are recoverable subject to the error correction power to compensate at least for channel induced errors.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref> wherein said error correction procedure includes:
<claim-text>for the bitwise digital form of each symbol to be transferred, the error correction procedure includes (i) encoding each bit of the plurality of bits to apply a customized encoding to at least a selected one of the plurality of bits which is based on a bit error rate that is different for each one of the plurality of bits for use as encoded symbols, (ii) passing the encoded symbols to the multilevel transmission channel as said symbol stream, (iii) receiving the encoded symbols from the multilevel transmission channel, and (iv) decoding the encoded symbols, as received from the multilevel transmission channel, in a way that applies a customized decoding to at least the selected one of the plurality of bits, based on the bit error rate for each one of the plurality of bits, to restore the symbols to said digital bitwise form and to remove said customized encoding in a way which cooperates with the customized encoding to provide a customized error correction power that is different from another error correction power that is associated with at least one other one of the plurality of bits thereby recovering the symbol stream.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref> wherein said customized error correction power is applied to a lowest order bit of the plurality of bits such that the customized error correction power is higher for the lowest order bit as compared to the error correction power associated with any other bit in the plurality of bits.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref> including applying a convolutional code to the lowest order bit and applying a constellation mapping collectively to the other bits.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. In a system which uses multi-level data encoding where each symbol of a plurality of symbols represents more than one bit of information in a symbol stream that is transferred using a multilevel transmission channel, an apparatus comprising:
<claim-text>a first arrangement for representing said symbols in a digital bitwise form, in relation to said transfer, such that each symbol is presented as a plurality of bits where each bit in the plurality of bits is subject to a different probability of error; and</claim-text>
<claim-text>a second arrangement for applying an error correction procedure to at least a selected one of the plurality of bits, for the bitwise digital form of each symbol that is transferred as part of the symbol stream, based on the different error probability that is associated with each bit in the plurality of bits such that an error correction power is associated with the selected one of the plurality of bits and the error correction power for at least the selected bit is different than another error correction power that is associated with at least one other one of the plurality of bits and all the symbols of the symbol stream are recoverable subject to the error correction power to compensate at least for channel induced errors.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The apparatus of <claim-ref idref="CLM-00013">claim 13</claim-ref> wherein said second arrangement is configured to apply said customized error correction procedure by encoding each bit of the plurality of bits, for the bitwise digital form of each symbol to be transferred, to apply a customized encoding to at least a selected one of the plurality of bits which is based on a bit error rate that is different for each one of the given plurality of bits for use as encoded symbols and for passing the encoded symbols to the multilevel transmission channel as said symbol stream and said second arrangement is further configured for receiving the encoded symbols from the multilevel transmission channel and, thereafter, decoding the encoded symbols in a way that applies a customized decoding at least to the selected one of the plurality of bits, based on the bit error rate for each one of the plurality of bits, to restore the symbols to said digital bitwise form and to remove said customized encoding thereby recovering the symbol stream.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. In a system which uses a multilevel transmission channel for transferring user data, a method comprising:
<claim-text>configuring the multilevel transmission channel to support a plurality of bitwise data symbols, each of which bitwise data symbols represents more than one bit of information such that each bitwise data symbol is made up of a plurality of bits where each bit in the plurality of bits is subject to a different probability of error;</claim-text>
<claim-text>applying a mosaic data structure to the bitwise data symbols of the multilevel channel based on said different probability of error for each bit, which mosaic data structure is formed of an arrangement of mosaic tiles, and each of which mosaic tiles is configured for receiving a channel symbol such that at least a selected one of the mosaic tiles is characterized by a collective error probability based on the error probability of a selected group of said bits assigned to the selected mosaic tile which is different than another collective error probability that characterizes at least one other one of the mosaic tiles based a different group of said bits assigned to the other mosaic tile;</claim-text>
<claim-text>encoding the user data into the channel symbols in a way which provides an error correction power for correction of one or more errors in at least some of said channel symbols, which errors are caused by the transfer through the multilevel channel;</claim-text>
<claim-text>introducing the channel symbols into the mosaic tiles; and</claim-text>
<claim-text>thereafter, recovering the user data from the channel symbols such that the error correction power of said encoding is applied by a selected amount to at least the selected one of the plurality of bits and by a different amount to at least one other one of the plurality of bits for correcting errors that occur within the selected group of bits in the selected mosaic tile.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The method of <claim-ref idref="CLM-00015">claim 15</claim-ref> wherein each bitwise data symbol includes a least significant bit and said applying includes assigning the selected group of bits in the selected mosaic tile exclusively as least significant bits.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The method of <claim-ref idref="CLM-00016">claim 16</claim-ref> including configuring said mosaic tiles in a pattern that repeats based, at least in part, on a number of bits that said selected mosaic tile contains in the selected group of bits.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The method of <claim-ref idref="CLM-00015">claim 15</claim-ref> including arranging the selected mosaic tile such that the collective error probability for the selected mosaic tile is a maximum error probability with respect to all of the mosaic tiles.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The method of <claim-ref idref="CLM-00018">claim 18</claim-ref> wherein said encoding is configured for correcting multiple bit errors in up to a given number of the channel symbols such that correction of such multiple bit errors in the selected mosaic tile compensates for the maximum error probability of the selected mosaic tile.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The method of <claim-ref idref="CLM-00015">claim 15</claim-ref> including applying a convolutional code to said selected one of the mosaic tiles to provide an additional error correction power for the selected one of the mosaic tiles.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The method of <claim-ref idref="CLM-00020">claim 20</claim-ref> including configuring the selected mosaic tile with one or more additional redundancy bits as compared to at least one other mosaic tile.</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. The method of <claim-ref idref="CLM-00021">claim 21</claim-ref> including using a trellis coded modulation as the convolutional code to generate the one or more additional redundancy bits.</claim-text>
</claim>
<claim id="CLM-00023" num="00023">
<claim-text>23. The method of <claim-ref idref="CLM-00015">claim 15</claim-ref> including repeating the mosaic data structure in the multilevel channel responsive to introducing the channel symbols into the mosaic tiles and said method further comprising dividing the user data into a plurality of interleaves and said introducing the channel symbols into the mosaic tiles includes rotating each interleave through each position in the mosaic data structure with said repeating of the mosaic data structure.</claim-text>
</claim>
</claims>
</us-patent-grant>
