<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08626485-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08626485</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12552839</doc-number>
<date>20090902</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>308</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>455</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>703 23</main-classification>
</classification-national>
<invention-title id="d2e53">Emulation apparatus, emulator generating method and emulator executing method</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>4846311</doc-number>
<kind>A</kind>
<name>Thangavelu</name>
<date>19890700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>2002/0173943</doc-number>
<kind>A1</kind>
<name>Armbruster et al.</name>
<date>20021100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>2003/0233642</doc-number>
<kind>A1</kind>
<name>Hank</name>
<date>20031200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717156</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2007/0240117</doc-number>
<kind>A1</kind>
<name>Wiles et al.</name>
<date>20071000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717124</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>JP</country>
<doc-number>A 2-43188</doc-number>
<date>19900200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>JP</country>
<doc-number>A 2-250122</doc-number>
<date>19901000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>JP</country>
<doc-number>A 2003-30269</doc-number>
<date>20030100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>JP</country>
<doc-number>A 2003-167863</doc-number>
<date>20030600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00009">
<othercit>Jose F. Morales et al., &#x201c;A Generator of Efficient Abstract Machine Implementations and Its Application to Emulator Minimization,&#x201d; 2005, Lecture Notes in Computer Science 3668, Springer-Verlag, pp. 21-36.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00010">
<othercit>Hiroyuki Tomiyama et al., &#x201c;Code placement techniques for cache miss rate reduction,&#x201d; 1997, ACM Transactions on Design Automation of Electronic Systems, vol. 2, No. 4, pp. 410-429.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00011">
<othercit>Susan L. Graham et al., &#x201c;Gprof: A call graph execution profiler,&#x201d; 1982, Proceedings of the 1982 SIGPALN symposium on compiler construction, pp. 120-126.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00012">
<othercit>Karl Pettis et al., &#x201c;Profile Guided Code Positioning,&#x201d; 1990, Proceedings of the ACm SIGPAL 1990 Conference on Programming Language Design and Implementation, pp. 16-27.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00013">
<othercit>Wen-mei Hwu et al., &#x201c;Achieving high instruction cache performance with an optimizing compiler,&#x201d; 1989, Proceedings of the 16th annual international symposium on Computer architecture, pp. 242-251.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00014">
<othercit>Cristina Cifuentes et al., &#x201c;Walkabout&#x2014;A Retargetable Dynamic Binary Translation Framework,&#x201d; 2002, Sun Microsystems, pp. 1-30.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00015">
<othercit>Darryl Grove, &#x201c;Improving Code Layout Can Improve Application Performance,&#x201d; 2005, http://developers.sun.com/solaris/articles/codelayout.html, pp. 1-5.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00016">
<othercit>Gary Carleton et al., &#x201c;Profile-Guided Optimizations,&#x201d; 1998, Dr. Dobb's Journal, vol. 23, No. 5, five pages.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00017">
<othercit>Gerolf Hoflehner et al., &#x201c;Compiler optimizations for transaction processing workloads on Itanium Linux systems,&#x201d; 2004, Proceedings of the 37th International Symposium on Microarchitecture, eleven unnumbered pages.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
</us-references-cited>
<number-of-claims>8</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>703 23</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>12</number-of-drawing-sheets>
<number-of-figures>13</number-of-figures>
</figures>
<us-related-documents>
<continuation>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>PCT/JP2007/056494</doc-number>
<date>20070327</date>
</document-id>
<parent-status>PENDING</parent-status>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>12552839</doc-number>
</document-id>
</child-doc>
</relation>
</continuation>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20090326910</doc-number>
<kind>A1</kind>
<date>20091231</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Ogihara</last-name>
<first-name>Takayuki</first-name>
<address>
<city>Kawasaki</city>
<country>JP</country>
</address>
</addressbook>
<residence>
<country>JP</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Ogihara</last-name>
<first-name>Takayuki</first-name>
<address>
<city>Kawasaki</city>
<country>JP</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Greer Burns &#x26; Crain, Ltd.</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Fujitsu Limited</orgname>
<role>03</role>
<address>
<city>Kawasaki</city>
<country>JP</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Shah</last-name>
<first-name>Kamini S</first-name>
<department>2123</department>
</primary-examiner>
<assistant-examiner>
<last-name>Guill</last-name>
<first-name>Russ</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">In an emulation apparatus, a processing operation recording unit records processing operations performed by an emulator executing unit and corresponding execution time. A counting unit reads policies defined in a policy storing unit and counts an execution frequency of each processing operation in each policy. According to the counting result of the counting unit, a source combining unit rearranges source components in an optimal order for each policy and combines the rearranged source components to generate a source. A compiling unit compiles the source generated for each policy and generates an emulator for each policy. An emulator selecting unit finds a policy that includes the current time from among the policies defined in the policy storing unit, reads the emulator generated for the found policy from an emulator storing unit, and instructs the emulator executing unit to execute that emulator.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="176.28mm" wi="168.40mm" file="US08626485-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="142.49mm" wi="141.56mm" file="US08626485-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="233.51mm" wi="170.26mm" file="US08626485-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="77.89mm" wi="163.91mm" file="US08626485-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="166.20mm" wi="91.95mm" file="US08626485-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="107.36mm" wi="93.81mm" file="US08626485-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="78.32mm" wi="98.38mm" file="US08626485-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="191.18mm" wi="139.28mm" file="US08626485-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="85.51mm" wi="111.08mm" file="US08626485-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="203.03mm" wi="141.56mm" file="US08626485-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="136.06mm" wi="91.95mm" file="US08626485-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="192.53mm" wi="169.33mm" file="US08626485-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="143.43mm" wi="166.12mm" file="US08626485-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATION</heading>
<p id="p-0002" num="0001">This application is a continuation of PCT international application Ser. No. PCT/JP2007/056494 filed on Mar. 27, 2007 which designates the United States, the entire contents of which are incorporated herein by reference.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">FIELD</heading>
<p id="p-0003" num="0002">The embodiments discussed herein are directed to an emulation apparatus, an emulator generating method and an emulator executing method.</p>
<heading id="h-0003" level="1">BACKGROUND</heading>
<p id="p-0004" num="0003">Typically, an emulator is a software program that performs processing operations identical to a hardware component such as a central processing unit (CPU). That is, an emulator is a software program that includes description of vast processing operations originally performed by a hardware component and that emulates those processing operations. There has been a strong demand for enhancement in the processing speed of emulators and a number of studies have been undertaken to achieve the same.</p>
<p id="p-0005" num="0004">For example, Japanese Laid-open Patent Publication No. 02-250122 discloses a technique of counting an instruction usage frequency of instructions emulated in an emulator and performing emulator adjustment with the use of the instruction usage frequency. Generally, in an emulator, the operation of determining the types of instructions that have been emulated (known as an instruction fetch operation) is repeated for a number of times. Thus, by counting the instruction usage frequency of instructions as disclosed in Japanese Laid-open Patent Publication No. 02-250122, the instruction fetch operation can be performed with respect to the instructions in the descending order of their instruction usage frequency. That enables enhancement in the emulator performance.</p>
<p id="p-0006" num="0005">For example, consider a case when an instruction A has a usage frequency of 10% of the total instruction usage frequency, an instruction B has a usage frequency of 50% of the total instruction usage frequency, and an instruction C has a usage frequency of 20% of the total instruction usage frequency. In that case, performing the first instruction fetch operation with respect to the instruction B leads to the type determination of 50% of the total instructions. Subsequently, performing the second instruction fetch operation with respect to the instruction C leads to the type determination of 70% (=50+20) of the total instructions.</p>
<p id="p-0007" num="0006">Thus, it is presumable that performing the instruction fetch operation in the descending order of instruction usage frequency results in a decrease in the number of times for which type determination is repeated in an emulator. That enables enhancement in the processing speed of the emulator. To achieve that, for example, the instruction usage frequency of instructions can be simulatedly counted in advance and the emulator can be adjusted in such a way that the instruction fetch operation is performed with respect to the instructions in the statistically descending order of their instruction usage frequency.</p>
<p id="p-0008" num="0007">However, there are certain limitations on enhancing the emulator performance by simulatedly counting the instruction usage frequency. More particularly, because an emulator performs processing operations of a hardware component such as a CPU, the instruction usage frequency of instructions completely changes depending on the usage environment in which the emulator is executed. In other words, simulation does not necessarily lead to optimal emulator adjustment with respect to the usage environment in which an emulator is actually executed.</p>
<p id="p-0009" num="0008">Moreover, the usage environment for an emulator is not always constant and changes significantly depending on, for example, a time period or a day of the week. However, if simulation is used to perform emulator adjustment, then the temporal changes in the usage environment are not taken into consideration. As a result, during certain time periods, an emulator may suffer performance loss such as slowdown in the processing speed thereof.</p>
<heading id="h-0004" level="1">SUMMARY</heading>
<p id="p-0010" num="0009">According to an aspect of an embodiment of the invention, an emulation apparatus for generating an emulator by combining a plurality of source components each describing a processing operation, includes an obtaining unit that, for each time period of a plurality of time periods in which an emulator usage environment changes, obtains a count of execution frequency of the processing operation performed by the emulator; a combining unit that, according to the count of execution frequency obtained by the obtaining unit, rearranges and combines the source components to generate a source; and a compiling unit that compiles the source generated by the combining unit.</p>
<p id="p-0011" num="0010">The object and advantages of the invention will be realized and attained by means of the elements and combinations particularly pointed out in the claims.</p>
<p id="p-0012" num="0011">It is to be understood that both the foregoing general description and the following detailed description are exemplary and explanatory and are not restrictive of the invention, as claimed.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0005" level="1">BRIEF DESCRIPTION OF DRAWINGS</heading>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram of essential parts in an emulation apparatus according to a first embodiment;</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 2</figref> is a schematic diagram of exemplary policies defined in the first embodiment;</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 3</figref> is a schematic diagram of exemplary source components used in the first embodiment;</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 4</figref> is a schematic diagram of exemplary combining rules specified in the first embodiment;</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 5</figref> is a flowchart for explaining an overview of the operations performed in the emulation apparatus;</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 6</figref> is a flowchart for explaining an operation of recording execution time performed in the emulation apparatus;</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 7</figref> is a schematic diagram of exemplary processing data obtained in the first embodiment;</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 8</figref> is a flowchart for explaining an operation of generating a counting result performed in the emulation apparatus;</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 9</figref> is a schematic diagram of an exemplary counting result obtained in the first embodiment;</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 10</figref> is a flowchart for explaining a source combining operation performed in the emulation apparatus;</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 11</figref> is a flowchart for explaining a compiling operation performed in the emulation apparatus;</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 12</figref> is a flowchart for explaining an operation of emulator execution performed in the emulation apparatus; and</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 13</figref> is a block diagram of an exemplary system configuration of an emulation system according to a second embodiment.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0006" level="1">DESCRIPTION OF EMBODIMENTS</heading>
<p id="p-0026" num="0025">The gist of embodiments of the present invention is to keep a record of the execution frequency of instructions for each policy about a usage environment in which emulators are executed, generate an emulator for each policy by optimally rearranging source components according to the recorded execution frequency, and selectively execute one of the emulators depending on the current policy. Hereinafter, preferred embodiments of the present invention will be explained with reference to accompanying drawings.</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram of essential parts in an emulation apparatus <b>100</b> according to a first embodiment. The emulation apparatus <b>100</b> includes an emulator executing unit <b>101</b>, a processing operation recording unit <b>102</b>, a policy storing unit <b>103</b>, a counting unit <b>104</b>, a source component storing unit <b>105</b>, a source combining unit <b>106</b>, a compiling unit <b>107</b>, an emulator storing unit <b>108</b>, and an emulator selecting unit <b>109</b>.</p>
<p id="p-0028" num="0027">The emulator executing unit <b>101</b> executes an emulator that has been selected for a particular policy by the emulator selecting unit <b>109</b>. More particularly, the emulator executing unit <b>101</b> sequentially executes the instructions given in an emulator and performs processing operations of, for example, a CPU that the emulator is written to emulate.</p>
<p id="p-0029" num="0028">The processing operation recording unit <b>102</b> keeps therein a record of the processing operations performed by the emulator executing unit <b>101</b> along with the time at which each processing operation is executed (hereinafter, &#x201c;execution time&#x201d;). More particularly, every time a processing operation, herein known as a source component that constitutes an emulator, is executed, the processing operation recording unit <b>102</b> records that processing operation (executed source components) and the corresponding execution time.</p>
<p id="p-0030" num="0029">The policy storing unit <b>103</b> stores therein a plurality of policies each defined for a different usage environment in which emulators are executed. More particularly, the policy storing unit <b>103</b> stores therein certain time periods, as policies, in which the usage environment is different. For example, with reference to <figref idref="DRAWINGS">FIG. 2</figref>, the policy storing unit <b>103</b> stores therein a priority order of time periods each defined for a different usage environment. As depicted in <figref idref="DRAWINGS">FIG. 2</figref>, a policy <b>1</b> is defined as the 26-th day of each month; while a policy <b>2</b> is defined as Saturdays and Sundays. Similarly, a policy <b>3</b> is defined as a time period from 9 o'clock to 17:30 o'clock on each day; while a policy <b>4</b> is defined as a time period from 17:30 o'clock on each day to 9 o'clock on next day. Meanwhile, if, for example, the 26-th day of a month falls on a Saturday, then that day corresponds to the policy <b>1</b> and not to the policy <b>2</b> because of the priority order thereof. Moreover, because the policy <b>2</b> has a higher priority than the policies <b>3</b> and <b>4</b>, the time periods defined in the policies <b>3</b> and <b>4</b> fall only on weekdays.</p>
<p id="p-0031" num="0030">The counting unit <b>104</b> reads the policies defined in the policy storing unit <b>103</b> and counts an execution frequency of processing operations in each policy. That is, by referring to the execution time of each source component recorded in the processing operation recording unit <b>102</b>, the counting unit <b>104</b> counts the number of source components of each type (described later) executed in each defined time period (i.e., in each defined policy).</p>
<p id="p-0032" num="0031">The source component storing unit <b>105</b> stores therein the source components (or fragments of source codes) that are the processing operations constituting emulators. The stored source components include a processing operation, known as an instruction fetch operation, to determine types of instructions that have been emulated. Meanwhile, the source components are generated by, for example, dividing a software program at dividable positions as depicted in <figref idref="DRAWINGS">FIG. 3</figref>.</p>
<p id="p-0033" num="0032">The source combining unit <b>106</b> stores therein certain combining rules that are used in generating a source, which represents the complete set of processing operations in an emulator. Depending on the combining rules, the source combining unit <b>106</b> combines some of the source components to obtain the source of an emulator. For example, the source combining unit <b>106</b> stores therein certain combining rules as depicted in <figref idref="DRAWINGS">FIG. 4</figref> and combines source components <b>1</b> to <b>7</b> to generate a source <b>1</b>.</p>
<p id="p-0034" num="0033">In this embodiment, the source components includes fixed source components and rearrangable source components. The source combining unit <b>106</b> places the fixed source components at predetermined positions and rearranges rearrangable source components for each policy based on the counting result of the counting unit <b>104</b>. That is, the source combining unit <b>106</b> rearranges the rearrangable source components for each policy in the descending order of their execution frequency. Moreover, the source combining unit <b>106</b> inserts an insertion source component between each adjacent pair of the source components.</p>
<p id="p-0035" num="0034">In this way, for each policy, the source combining unit <b>106</b> combines some of the source components that have been rearranged in a certain appropriate order to generate a source that represents an emulator for the corresponding policy.</p>
<p id="p-0036" num="0035">The compiling unit <b>107</b> then compiles the source for each policy and generates an emulator for that policy. More particularly, the compiling unit <b>107</b> refers to the number of policies defined in the policy storing unit <b>103</b>, compiles the source corresponding to each policy, and generates an emulator for each policy.</p>
<p id="p-0037" num="0036">The emulator storing unit <b>108</b> stores therein the emulators generated by the compiling unit <b>107</b> corresponding to all the defined policies.</p>
<p id="p-0038" num="0037">When an emulator start instruction is invoked, the emulator selecting unit <b>109</b> finds a policy (i.e., a time period) including the current time from among the policies defined in the policy storing unit <b>103</b>, reads the emulator generated for the found policy from the emulator storing unit <b>108</b>, and instructs the emulator executing unit <b>101</b> to execute that emulator. Moreover, the emulator selecting unit <b>109</b> refers to a policy (i.e., a time period) that is the most immediate policy to start after the current time and performs emulator changeover setting with respect to the start time of that particular policy.</p>
<p id="p-0039" num="0038">The operations performed in the emulation apparatus <b>100</b> are described below by citing concrete examples.</p>
<p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. 5</figref> is a flowchart for explaining an overview of the operations performed in the emulation apparatus <b>100</b>. First, when the emulator executing unit <b>101</b> executes an emulator as depicted in <figref idref="DRAWINGS">FIG. 5</figref>, the processing operation recording unit <b>102</b> records the execution time of the processing operation corresponding to each source component in that emulator (Step S<b>101</b>). Then, the counting unit <b>104</b> counts the execution time for each policy (Step S<b>102</b>).</p>
<p id="p-0041" num="0040">Subsequently, the source combining unit <b>106</b> combines the source components for each policy according to the combining rules and generates the source for each policy (Step S<b>103</b>). At that time, based on the execution time for each policy counted by the counting unit <b>104</b>, the source combining unit <b>106</b> rearranges the rearrangable source components in each policy in the descending order of their execution frequency. After the source combining unit <b>106</b> generates the source for each policy, the compiling unit <b>107</b> compiles each source and generates an emulator for each policy (Step S<b>104</b>). The generated emulators are stored in the emulator storing unit <b>108</b>.</p>
<p id="p-0042" num="0041">At the time of emulator execution, the emulator selecting unit <b>109</b> finds the policy including the current time and selects the emulator corresponding to the found policy from the emulator storing unit <b>108</b>. The emulator executing unit <b>101</b> then executes the selected emulator (Step S<b>105</b>).</p>
<p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. 6</figref> is a flowchart for explaining the details of the operation of recording the execution time performed by the processing operation recording unit <b>102</b> at Step S<b>101</b>.</p>
<p id="p-0044" num="0043">In that operation, first, the processing operation recording unit <b>102</b> monitors whether the emulator executing unit <b>101</b> is executing instructions in an emulator (Step S<b>201</b>). If the emulator executing unit <b>101</b> is executing instructions in an emulator (Yes at Step S<b>201</b>), the processing operation recording unit <b>102</b> records the source component corresponding to each executed instruction along with the execution time of that instruction (Step S<b>202</b>). For example, when the emulator executing unit <b>101</b> executes an emulator, the processing operation recording unit <b>102</b> records the execution time for each instruction in that emulator as depicted in <figref idref="DRAWINGS">FIG. 7</figref>. Thus, for each executed instruction, the processing data in <figref idref="DRAWINGS">FIG. 7</figref> includes the execution time of that instruction and the source component corresponding to the details of that instruction.</p>
<p id="p-0045" num="0044"><figref idref="DRAWINGS">FIG. 8</figref> is a flowchart for explaining the details of the operation of generating a counting result performed by the counting unit <b>104</b> at Step S<b>102</b>.</p>
<p id="p-0046" num="0045">First, the counting unit <b>104</b> reads one of the policies defined in the policy storing unit <b>103</b> (Step S<b>301</b>) and reads the processing data for one of the instructions recorded in the processing operation recording unit <b>102</b> (Step S<b>302</b>). Then, the counting unit <b>104</b> determines whether the execution time in the read processing data falls in the time period defined as the read policy (Step S<b>303</b>). If the execution time in the read processing data falls in the time period defined as the read policy (Yes at Step S<b>303</b>), the counting unit <b>104</b> increments by one the execution frequency of the source component in the read processing data (Step S<b>304</b>).</p>
<p id="p-0047" num="0046">If the execution time in the read processing data does not fall in the time period defined as the read policy (No at Step S<b>303</b>) or if the increment operation of the counting unit <b>104</b> (Step S<b>304</b>) has already been performed, the counting unit <b>104</b> determines whether the above determination operation (Step S<b>303</b>) is performed on the processing data of each instruction recorded in the processing operation recording unit <b>102</b> (Step S<b>305</b>). If the above determination operation is yet to be performed on the processing data of any instruction (No at Step S<b>305</b>) the counting unit <b>104</b> performs the above determination operation on the recorded processing data.</p>
<p id="p-0048" num="0047">When the above determination operation is performed on the processing data recorded in the processing operation recording unit <b>102</b> (Yes at Step S<b>305</b>), the counting unit <b>104</b> stores therein a counting result corresponding to the currently-read policy (Step S<b>306</b>). That is, the counting unit <b>104</b> stores therein the execution frequency of each source component in an emulator that is executed in the time period defined as the currently-read policy. Then, the counting unit <b>104</b> determines whether the counting operation is performed for all the policies stored in the policy storing unit <b>103</b> (Step S<b>307</b>). If the counting operation is yet to be performed for any policy (No at Step S<b>307</b>), the counting unit <b>104</b> performs the above operations for that policy.</p>
<p id="p-0049" num="0048">When the processing is performed for all the policies (Yes at Step S<b>307</b>), the counting result of the execution frequency of each source component executed in each policy is obtained. <figref idref="DRAWINGS">FIG. 9</figref> is a schematic diagram of an exemplary counting result obtained by the counting unit <b>104</b>. In the time period defined as the policy <b>1</b> in <figref idref="DRAWINGS">FIG. 9</figref>, the source component <b>1</b> is executed for 100 times, the source component <b>2</b> is executed for 20 times, and the source component <b>2</b> is executed for 5 times. Because the policies are defined in advance according to the changes in the usage environment for emulator execution, the execution frequency corresponding to each policy depicts peculiar characteristics.</p>
<p id="p-0050" num="0049"><figref idref="DRAWINGS">FIG. 10</figref> is a flowchart for explaining the source combining operation performed by the source combining unit <b>106</b> at Step S<b>103</b>.</p>
<p id="p-0051" num="0050">First, the source combining unit <b>106</b> selects one of the policies as a target policy for source generation from the policy storing unit <b>103</b> (Step S<b>401</b>). Then, the source combining unit <b>106</b> reads one of the combining rules (Step S<b>402</b>) and obtains such source components from the source component storing unit <b>105</b> for which the read combining rule specifies a combining method. A single combining rule may specify a combining method for one or more source components. By referring to the combining rule, the source combining unit <b>106</b> then determines whether the obtained source components are of the rearrangable type and thus can be rearranged in a different order (Step S<b>403</b>).</p>
<p id="p-0052" num="0051">If the obtained source components are of the rearrangable type, the source combining unit <b>106</b> refers to the counting result in the counting unit <b>104</b> and rearranges the source components in the descending order of their execution frequency in the target policy (Step S<b>404</b>). For example, consider a case when, with reference to the counting result depicted in <figref idref="DRAWINGS">FIG. 9</figref>, the policy <b>1</b> is set as the target policy and the source components <b>2</b> to <b>4</b> are of the rearrangable type. In that case, the source combining unit <b>106</b> rearranges the source components <b>2</b> to <b>4</b> in the order of the source component <b>2</b>, the source component <b>4</b>, and the source component <b>3</b>. Instead, if the policy <b>2</b> is set as the target policy, then the source combining unit <b>106</b> rearranges the source components <b>2</b> to <b>4</b> in the order of the source component <b>4</b>, the source component <b>3</b>, and the source component <b>2</b>.</p>
<p id="p-0053" num="0052">In this way, in the source combining operation, the order of the rearrangable source components is determined according to their usage frequency in each policy. Thus, for each time period defined as a policy, the source components are combined in an optimal order thereby enabling enhancement in the processing speed of emulators.</p>
<p id="p-0054" num="0053">Upon rearranging the source components for which one of the combining rules specifies a combining method, the source combining unit <b>106</b> links the rearranged group of source components (hereinafter, &#x201c;source segment&#x201d;) to an existing source segment (Step S<b>405</b>). An existing source segment refers to a rearranged group of source components that have already been rearranged according to a different one of the combining rules. Meanwhile, the source combining unit <b>106</b> links together only such source segments that constitute a single source according to the combining rules. For example, according to the combining rules depicted in <figref idref="DRAWINGS">FIG. 4</figref>, the source <b>1</b> is generated by linking together three source segments, namely, a source segment including the source component <b>1</b>; a source segment including the source components <b>2</b>, <b>3</b>, and <b>4</b>; and a source segment including the source components <b>6</b> and <b>7</b>.</p>
<p id="p-0055" num="0054">Subsequently, the source combining unit <b>106</b> determines whether the combining operation according to the combining rules is performed for all the combining rules (Step S<b>406</b>). If the combining operation is yet to be performed for any combining rule (No at Step S<b>406</b>), then the source combining unit <b>106</b> performs the combining operation for that combining rule.</p>
<p id="p-0056" num="0055">Upon performing the combining operation for all the combining rules (Yes at Step S<b>406</b>), the source combining unit <b>106</b> stores therein the source generated corresponding to the current target policy (Step S<b>407</b>). That is, the source combining unit <b>106</b> stores therein the target policy and the source generated by optimally linking the source components in the target policy in a corresponding manner. Subsequently, the source combining unit <b>106</b> determines whether the source is generated corresponding to each policy stored in the policy storing unit <b>103</b> (Step S<b>408</b>). If the source is yet to be generated for any policy (No at Step S<b>408</b>), then the source combining unit <b>106</b> repeats the above processing (Steps S<b>401</b> to S<b>407</b>) for that policy.</p>
<p id="p-0057" num="0056">The generation of a source corresponding to each policy (Yes at Step S<b>408</b>) means that the source of an emulator corresponding to each policy is obtained. In the source corresponding to each policy, the source components executed in that policy are optimally rearranged in a descending order of their execution frequency.</p>
<p id="p-0058" num="0057"><figref idref="DRAWINGS">FIG. 11</figref> is a flowchart for explaining the compiling operation performed by the compiling unit <b>107</b> at Step S<b>104</b>.</p>
<p id="p-0059" num="0058">First, the compiling unit <b>107</b> selects one of the policies as a target policy for source compilation and emulator generation from the policy storing unit <b>103</b> (Step S<b>501</b>). Then, the compiling unit <b>107</b> obtains the source corresponding to the target policy from the source combining unit <b>106</b> and compiles it to generate an emulator for the target policy (Step S<b>502</b>).</p>
<p id="p-0060" num="0059">Then, the compiling unit <b>107</b> stores the generated emulator and the target policy in a corresponding manner in the emulator storing unit <b>108</b> (Step S<b>503</b>). Subsequently, the compiling unit <b>107</b> determines whether an emulator is generated corresponding to each policy stored in the policy storing unit <b>103</b> (Step S<b>504</b>). If an emulator is yet to be generated for any policy (No at Step S<b>504</b>), then the compiling unit <b>107</b> repeats the above processing (Steps S<b>501</b> to S<b>504</b>) for that policy.</p>
<p id="p-0061" num="0060">Upon generating an emulator corresponding to each policy stored in the policy storing unit <b>103</b>, an emulator suitable for each policy is generated (Yes at Step S<b>504</b>) and stored in the emulator storing unit <b>108</b>.</p>
<p id="p-0062" num="0061"><figref idref="DRAWINGS">FIG. 12</figref> is a flowchart for explaining the operation of emulator execution performed by the emulator selecting unit <b>109</b> and the emulator executing unit <b>101</b> at Step S<b>105</b>.</p>
<p id="p-0063" num="0062">First, the emulator selecting unit <b>109</b> determines whether an emulator start instruction is invoked externally (Step S<b>601</b>). If an emulator start instruction is invoked (Yes at Step S<b>601</b>), the emulator selecting unit <b>109</b> reads the policy of highest priority from the policy storing unit (Step S<b>602</b>) and determines whether the read policy (i.e., time period) includes the current time (Step S<b>603</b>).</p>
<p id="p-0064" num="0063">If the read policy includes the current time (Yes at Step S<b>603</b>), then the emulator selecting unit <b>109</b> selects the emulator corresponding to the read policy from the emulator storing unit <b>108</b> (Step S<b>604</b>) and instructs the emulator executing unit <b>101</b> to execute the selected emulator. On the other hand, if the read policy does not include the current time (No at Step S<b>603</b>), the emulator selecting unit determines whether the comparison operation between the read policy and the current time is performed for all the policies stored in the policy storing unit <b>103</b> (Step S<b>605</b>). If the comparison operation is yet to be performed for any policy (No at Step S<b>605</b>), then the emulator selecting unit <b>109</b> reads that policy and performs the comparison operation between the read policy and the current time.</p>
<p id="p-0065" num="0064">On the other hand, if the comparison operation between the read policy and the current time has been performed for all the policies (Yes at Step S<b>605</b>) or if an emulator corresponding to a particular policy has already been executed, then the emulator selecting unit <b>109</b> performs emulator changeover setting. More particularly, the emulator selecting unit <b>109</b> selects a policy (i.e., a time period) that is the most immediate policy to start after the current time (Step S<b>606</b>). The start time of the selected policy represents an emulator changeover time in the continuous execution of emulators. That is, at the start time of the selected policy, the emulator executing unit <b>101</b> needs to start executing the emulator corresponding to the selected policy.</p>
<p id="p-0066" num="0065">For that, the emulator selecting unit <b>109</b> first sets the start time of the selected policy as the emulator changeover time (Step S<b>607</b>). Then, at the emulator changeover time, the emulator selecting unit <b>109</b> selects the emulator corresponding to the selected policy from the emulator storing unit <b>108</b> and instructs the emulator executing unit <b>101</b> to execute the newly selected emulator.</p>
<p id="p-0067" num="0066">Thus, in the first embodiment, a different emulator is executed for each different time period defined as a policy. Moreover, from among a plurality of emulators generated according to the changes in the usage environment, an emulator suitable for the current time is executed. That enables reliable enhancement in the processing efficiency of emulators irrespective of the changes in the usage environment.</p>
<p id="p-0068" num="0067">According to the first embodiment, for each of the policies defined according to the changes in the usage environment, an execution frequency of each processing operation in an emulator is counted. Depending on the counting result, source components that correspond to the processing operations are rearranged and combined to generate a source for each policy. The source for each policy is compiled to generate an emulator for that policy. Then, from among a plurality of emulators generated according to the changes in the usage environment, an emulator is executed that corresponds to the policy including the current time. In this way, it is possible to generate emulators according to differing execution frequencies of the processing operations in the actual usage environment and selectively execute an emulator that corresponds to the actual time of execution. That enables reliable enhancement in the processing efficiency of emulators irrespective of the changes in the usage environment.</p>
<p id="p-0069" num="0068">Meanwhile, in the first embodiment, it is assumed that the emulation apparatus <b>100</b> singularly performs emulator generation and emulator execution. Alternatively, it is also possible to separate the emulation apparatus <b>100</b> in two apparatuses that separately perform emulator generation and emulator execution. For example, as depicted in <figref idref="DRAWINGS">FIG. 13</figref>, the emulation apparatus <b>100</b> may be separated in an emulator executing apparatus <b>200</b> and an emulator generating apparatus <b>300</b> that respectively perform emulator execution and emulator generation. At the time of emulator execution, the emulator executing apparatus <b>200</b> counts the execution frequency of each source component. The emulator generating apparatus <b>300</b> then generates an emulator for each policy by using the counting result and information on the defined policies. The constituent elements of the emulator executing apparatus <b>200</b> and the emulator generating apparatus <b>300</b> are identical to those depicted in <figref idref="DRAWINGS">FIG. 1</figref>. Hence, their description is not repeated.</p>
<p id="p-0070" num="0069">In the configuration depicted in <figref idref="DRAWINGS">FIG. 13</figref>, the emulator generating apparatus <b>300</b> may be disposed at the customer's site while disposing the emulator executing apparatus <b>200</b> at the developer's site for developing emulators. That eliminates the need for the developer to disclose, for example, source components to the customer. Moreover, the developer may generate an emulator for each policy by obtaining necessary information from the customer.</p>
<p id="p-0071" num="0070">According to the embodiments, a plurality of emulators are generated each performing processing operations in an optimal order for a corresponding time period. By executing a different emulator depending on each time period, it is possible to enhance the processing speed of emulators. That enables reliable enhancement in emulator performance irrespective of changes in a usage environment.</p>
<p id="p-0072" num="0071">According to the embodiments, emulators may be generated according to execution frequencies of processing operations in the actual usage environment.</p>
<p id="p-0073" num="0072">According to the embodiments, processing operations such as an instruction fetch operation are performed in a prompt manner thereby enabling reliable enhancement in the processing speed of emulators.</p>
<p id="p-0074" num="0073">According to the embodiments, the processing details of source components may be used to define source components of a fixed type and source components of a rearrangable type. That enables generation of a source from a combination of fixed source components and rearrangable source components.</p>
<p id="p-0075" num="0074">According to the embodiments, it is possible to selectively execute an emulator according to the actual time of execution. That enables reliable enhancement in the processing efficiency of emulators irrespective of changes in the usage environment.</p>
<p id="p-0076" num="0075">According to the embodiments, it is possible to reliably select an emulator that is suitable for the actual time of execution.</p>
<p id="p-0077" num="0076">According to the embodiments, emulator changeover is performed at the start time of each time period for which a suitable emulator differs. That enables selective execution of suitable emulators on a consistent basis.</p>
<p id="p-0078" num="0077">All examples and conditional language recited herein are intended for pedagogical purposes to aid the reader in understanding the invention and the concepts contributed by the inventor to furthering the art, and are to be construed as being without limitation to such specifically recited examples and conditions, nor does the organization of such examples in the specification relate to a depicting of the superiority and inferiority of the invention. Although the embodiments of the present inventions have been described in detail, it should be understood that the various changes, substitutions, and alterations could be made hereto without departing from the spirit and scope of the invention.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. An emulation apparatus for generating an emulator by combining a plurality of source components each describing a processing operation, the emulation apparatus comprising:
<claim-text>a processor coupled to a memory,</claim-text>
<claim-text>wherein:</claim-text>
<claim-text>the memory stores policies each defined for different usage environment; and</claim-text>
<claim-text>the processor executes the processing operation to generate the emulator by:</claim-text>
<claim-text>obtaining, for each time period defined by the policy stored in the memory, a count of execution frequency of the processing operation performed by the emulator;</claim-text>
<claim-text>rearranging and combining, for each policy stored in the memory and according to the count of execution frequency obtained in the obtaining, the source components to generate a source; and</claim-text>
<claim-text>compiling, for each policy stored in the memory, the source generated at the rearranging and combining.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The emulation apparatus according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the obtaining includes:
<claim-text>(i) executing the emulator;</claim-text>
<claim-text>(ii) recording, when the emulator is executed at the executing, an execution time of a processing operation described by each of the source components corresponding to the emulator; and</claim-text>
<claim-text>(iii) counting, for each time period defined by the policy stored in the memory, the execution time recorded at the recording.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The emulation apparatus according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the rearranging and combining rearranges, for each time period defined by the policy stored in the memory, the source components in a descending order of execution frequency of corresponding processing operations.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. An emulation apparatus for generating an emulator by combining a plurality of source components each describing a processing operation, the emulation apparatus comprising:
<claim-text>a processor coupled to a memory,</claim-text>
<claim-text>wherein the processor executes the processing operation to generate the emulator by:</claim-text>
<claim-text>obtaining, for each time period of a plurality of time periods, a count of execution frequency of the processing operation performed by the emulator, an emulator usage environment being different in each of the plurality of time periods;</claim-text>
<claim-text>rearranging and combining, according to the count of execution frequency obtained in the obtaining, the source components to generate a source by referring to information regarding whether each of the source components is of a rearrangable type and, according to the count of execution frequency obtained at the obtaining, rearranging the source components of the rearrangable type; and</claim-text>
<claim-text>compiling the source generated at the rearranging and combining.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. An emulator generating method, executed by a computer, for generating an emulator by combining a plurality of source components each describing a processing operation, the emulator generating method comprising:
<claim-text>storing, in a memory, policies each defined for different usage environment;</claim-text>
<claim-text>obtaining, for each time period defined by the policy stored in the memory, a count of execution frequency of the processing operation performed by the emulator;</claim-text>
<claim-text>rearranging and combining, for each policy stored in the memory and according to the count of execution frequency obtained at the obtaining, the source components to generate a source; and</claim-text>
<claim-text>compiling, for each policy stored in the memory, the source generated at the rearranging and combining.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The emulator generating method according to <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the obtaining includes:
<claim-text>(i) executing the emulator;</claim-text>
<claim-text>(ii) recording, when the emulator is executed at the executing, an execution time of a processing operation described by each of the source components corresponding to the emulator; and</claim-text>
<claim-text>(iii) counting, for each time period defined by the policy stored in the memory, the execution time recorded at the recording.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The emulator generating method according to <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the rearranging and combining rearranges, for each time period defined by the policy stored in the memory, the source components in a descending order of execution frequency of corresponding processing operations.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. An emulator generating method, executed by a computer, for generating an emulator by combining a plurality of source components each describing a processing operation, the emulator generating method comprising:
<claim-text>obtaining, for each time period of a plurality of time periods, a count of execution frequency of the processing operation performed by the emulator, an emulator usage environment being different in each of the plurality of time periods;</claim-text>
<claim-text>rearranging and combining the source components to generate a source by referring to information regarding whether each of the source components is of a rearrangable type and, according to the count of execution frequency obtained at the obtaining, rearranging the source components of the rearrangable type; and</claim-text>
<claim-text>compiling the source generated at the rearranging and combining. </claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
