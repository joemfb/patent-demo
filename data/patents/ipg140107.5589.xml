<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08626689-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08626689</doc-number>
<kind>B1</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13196484</doc-number>
<date>20110802</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<us-term-of-grant>
<us-term-extension>106</us-term-extension>
<disclaimer>
<text>This patent is subject to a terminal disclaimer.</text>
</disclaimer>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>1</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>N</subclass>
<main-group>5</main-group>
<subgroup>00</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>706 45</main-classification>
<further-classification>711121</further-classification>
<further-classification>717114</further-classification>
</classification-national>
<invention-title id="d2e55">Data pattern analysis using optimized deterministic finite automation</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5796942</doc-number>
<kind>A</kind>
<name>Esbensen</name>
<date>19980800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5945933</doc-number>
<kind>A</kind>
<name>Kalkstein</name>
<date>19990800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6088803</doc-number>
<kind>A</kind>
<name>Tso et al.</name>
<date>20000700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6108782</doc-number>
<kind>A</kind>
<name>Fletcher et al.</name>
<date>20000800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>6119236</doc-number>
<kind>A</kind>
<name>Shipley</name>
<date>20000900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>6178448</doc-number>
<kind>B1</kind>
<name>Gray et al.</name>
<date>20010100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>6219706</doc-number>
<kind>B1</kind>
<name>Fan et al.</name>
<date>20010400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>6449723</doc-number>
<kind>B1</kind>
<name>Elgressy et al.</name>
<date>20020900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>6851061</doc-number>
<kind>B1</kind>
<name>Holland et al.</name>
<date>20050200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>7134143</doc-number>
<kind>B2</kind>
<name>Stellenberg et al.</name>
<date>20061100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>7152164</doc-number>
<kind>B1</kind>
<name>Loukas et al.</name>
<date>20061200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>7185368</doc-number>
<kind>B2</kind>
<name>Copeland, III</name>
<date>20070200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>7304996</doc-number>
<kind>B1</kind>
<name>Swenson et al.</name>
<date>20071200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>7849502</doc-number>
<kind>B1</kind>
<name>Bloch et al.</name>
<date>20101200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>7991723</doc-number>
<kind>B1</kind>
<name>Dubrovsky et al.</name>
<date>20110800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>2002/0083331</doc-number>
<kind>A1</kind>
<name>Krumel</name>
<date>20020600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>2003/0061361</doc-number>
<kind>A1</kind>
<name>Bacik et al.</name>
<date>20030300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709228</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00018">
<document-id>
<country>US</country>
<doc-number>2003/0065800</doc-number>
<kind>A1</kind>
<name>Wyschogrod et al.</name>
<date>20030400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00019">
<document-id>
<country>US</country>
<doc-number>2003/0084328</doc-number>
<kind>A1</kind>
<name>Tarquini et al.</name>
<date>20030500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00020">
<document-id>
<country>US</country>
<doc-number>2003/0110208</doc-number>
<kind>A1</kind>
<name>Wyschogrod et al.</name>
<date>20030600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00021">
<document-id>
<country>US</country>
<doc-number>2003/0145228</doc-number>
<kind>A1</kind>
<name>Suuronen et al.</name>
<date>20030700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00022">
<document-id>
<country>US</country>
<doc-number>2003/0154399</doc-number>
<kind>A1</kind>
<name>Zuk et al.</name>
<date>20030800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00023">
<document-id>
<country>US</country>
<doc-number>2004/0093513</doc-number>
<kind>A1</kind>
<name>Cantrell et al.</name>
<date>20040500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00024">
<document-id>
<country>US</country>
<doc-number>2004/0123155</doc-number>
<kind>A1</kind>
<name>Etoh et al.</name>
<date>20040600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00025">
<document-id>
<country>US</country>
<doc-number>2004/0199790</doc-number>
<kind>A1</kind>
<name>Lingafelt et al.</name>
<date>20041000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00026">
<document-id>
<country>US</country>
<doc-number>2004/0255163</doc-number>
<kind>A1</kind>
<name>Swimmer et al.</name>
<date>20041200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00027">
<document-id>
<country>US</country>
<doc-number>2005/0120243</doc-number>
<kind>A1</kind>
<name>Palmer et al.</name>
<date>20050600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00028">
<document-id>
<country>US</country>
<doc-number>2005/0216770</doc-number>
<kind>A1</kind>
<name>Rowett et al.</name>
<date>20050900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00029">
<document-id>
<country>US</country>
<doc-number>2005/0262556</doc-number>
<kind>A1</kind>
<name>Waisman et al.</name>
<date>20051100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00030">
<document-id>
<country>US</country>
<doc-number>2006/0020595</doc-number>
<kind>A1</kind>
<name>Norton et al.</name>
<date>20060100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00031">
<document-id>
<country>US</country>
<doc-number>2006/0069787</doc-number>
<kind>A1</kind>
<name>Sinclair</name>
<date>20060300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00032">
<document-id>
<country>US</country>
<doc-number>2006/0075206</doc-number>
<kind>A1</kind>
<name>Bouchard et al.</name>
<date>20060400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711202</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00033">
<document-id>
<country>US</country>
<doc-number>2007/0058551</doc-number>
<kind>A1</kind>
<name>Brusotti et al.</name>
<date>20070300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00034">
<document-id>
<country>US</country>
<doc-number>2008/0034073</doc-number>
<kind>A1</kind>
<name>McCloy et al.</name>
<date>20080200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00035">
<document-id>
<country>US</country>
<doc-number>2008/0271147</doc-number>
<kind>A1</kind>
<name>Mohanan et al.</name>
<date>20081000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>726 24</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00036">
<document-id>
<country>EP</country>
<doc-number>1 122 932</doc-number>
<date>20010800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00037">
<document-id>
<country>EP</country>
<doc-number>1 528 743</doc-number>
<date>20050500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00038">
<document-id>
<country>WO</country>
<doc-number>WO 97/39399</doc-number>
<date>19971000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00039">
<othercit>Aggarwal, N., &#x201c;Improving the Efficiency of Network Intrusion Detection System&#x201d;, Indian Institute of Technology, pp. 1-40, May 3, 2006.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00040">
<othercit>Bellovin, S., &#x201c;Firewall-Friendly FTP,&#x201d; Network Working Group, RFC No. 1579, AT&#x26;T Bell Laboratories, Feb. 1994, Http://www.ietf.org/rfc1579.txt?number=1579, downloaded Jul. 15, 2002, 4 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00041">
<othercit>Blyth, Andrew, &#x201c;Detecting Intrusion&#x201d;, School of Computing, University of Glamorgan, 14 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00042">
<othercit>Branch, Joel, &#x201c;Denial of Service Intrusion Detection Using Time Dependent Deterministic Finite Automata&#x201d;, RPI Graduate Research Conference 2002, Oct. 17, 2002. 7 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00043">
<othercit>Gateway Anti-Virus, Anti-Spyware and Intrusion Prevention Service, Unified Threat Management, Intelligent Real-time Protection, &#xa9; 2005, 2 pp.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00044">
<othercit>Giles, C., &#x201c;Learning a Class of Large Finite State Machines with a Recurrent Neural Network&#x201d;, Neural Networks, vol. 8., No. 9, pp. 1359-1365, 1995.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00045">
<othercit>Holzmann, G., &#x201c;A Minimized Automaton Representation of Reachable States&#x201d;, Int J STTT 2, pp. 270-278, 1999.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00046">
<othercit>Juniper Networks, &#x201c;Architecture,&#x201d; www.juniper.net/products/intrusion/architecture.html, downloaded Jun. 11, 2004, 3 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00047">
<othercit>Juniper Networks, &#x201c;Attack Detection,&#x201d; www.juniper.net/products/intrusion/detection.html, downloaded Jun. 11, 2004, 7 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00048">
<othercit>Juniper Networks, &#x201c;Attack Prevention,&#x201d; www.juniper.net/products/intrusion/prevention.html, downloaded Jun. 11, 2004, 2 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00049">
<othercit>Juniper Networks, &#x201c;Intrusion Detection and Prevention,&#x201d; www.juniper.net/products/intrusion/downloaded Jun. 11, 2004, 2 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00050">
<othercit>Juniper Networks, &#x201c;Juniper Networks NetScreen&#x2014;IDP 10/100/500/1000,&#x201d; Intrusion Detection and Prevention, Spec Sheet, Apr. 2004, 2 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00051">
<othercit>Lucas, S., &#x201c;Learning Deterministic Finite Automata with a Smart State Labeling Evolutionary Algorithm&#x201d;, IEEE Transaction on Pattern Analysis and Machine Intelligence , vol. 27, No. 7, pp. 1063-1074 Jul. 2005.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00052">
<othercit>Krugal, Christopher, &#x201c;Using Decision Trees to Improve Signature-Based Intrusion Detection&#x201d;, Sep. 8, 2003, RAID 2003: recent Advance in Intrusion Detection, 20 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00053">
<othercit>Roberts, Paul, &#x201c;NetScreen Announces Deep Inspection Firewall,&#x201d; IDG News Service, Oct. 20, 2003, http://www.nwfusion.com/news/2003/1020netscannou.html, downloaded Jun. 11, 2004, 5 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00054">
<othercit>Roesch, Martin and Green, Chris, &#x201c;Snort Users Manual,&#x201d; Snort Release 2.0.0, M. Roesch, C. Green, Copyright 1998-2003 M. Roesch, Copyright 2001-2003 C. Green, Copyright 2003 Sourcefire, Inc. dated Dec. 8, 2003 (53 pgs).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00055">
<othercit>&#x201c;Snort&#x2122;: The Open Source Network Intrusion Detection System&#x201d;, accessed at: http://www.snort.org/about.html on Jun. 23, 2004, last updated Jun. 23, 2004, 2 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00056">
<othercit>SonicWALL Complete Anti-Virus, Automated and Enforced Anti-Virus Protection, &#xa9; 2005, 2 pp.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00057">
<othercit>SonicWALL Content Filtering Service, Comprehensive Internet Security&#x2122;, &#xa9; 2005, 2 pp.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00058">
<othercit>SonicWALL Content Security Manager Series, Easy-to-use, Affordable, Content Security and Internet Threat Protection, &#xa9; 2006, Dec. 2006. 4 pp.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00059">
<othercit>SonicWALL Endpoint Security: Anti-Virus, Automated and Enforced Anti-Virus and Anti-Spyware Protection, &#xa9; 2007, Mar. 2007, 2 pp.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00060">
<othercit>SonicWALL Internet Security Appliances, &#x201c;Content Security Manager Integrated Solutions Guide&#x201d;, Version 3.0, &#xa9; 2007, 160 pp.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00061">
<othercit>SonicWALL Internet Security Appliances, &#x201c;SonicOS 3.8 Standard Administrator's Guide&#x201d;, &#xa9; 2007, 362 pp.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00062">
<othercit>SonicOS Standard 3.8.0.2 Release Notes, SonicWALL secure Anti-Virus Router 80 Series, SonicWALL, Inc., Software Release: Apr. 11, 2007, 13 pp.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00063">
<othercit>The Ultimate Internet Sharing Solution, WinProxy, User Manual, Copyright 1996-2002 Osistis Software, Inc., dated Feb. 2002 (290 pgs).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00064">
<othercit>Van Engelen, R., &#x201c;Constructing Finite State Automata for High-Performance XML Web Services&#x201d;, International Symposium on Web Services and Applications, pp. 1-7, 2004.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00065">
<othercit>EP Application No. EP 04 02 5579, May 23, 2005, 3 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00066">
<othercit>U.S. Appl. No. 11/778,546; Final Office Action mailed Oct. 22, 2010.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00067">
<othercit>U.S. Appl. No. 11/778,546; Office Action mailed Jul. 7, 2010.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>24</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>706 45</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>12</number-of-drawing-sheets>
<number-of-figures>12</number-of-figures>
</figures>
<us-related-documents>
<continuation>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>11778546</doc-number>
<date>20070716</date>
</document-id>
<parent-grant-document>
<document-id>
<country>US</country>
<doc-number>7991723</doc-number>
</document-id>
</parent-grant-document>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>13196484</doc-number>
</document-id>
</child-doc>
</relation>
</continuation>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Dubrovsky</last-name>
<first-name>Aleksandr</first-name>
<address>
<city>San Mateo</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Brady</last-name>
<first-name>Justin Michael</first-name>
<address>
<city>San Jose</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Yanovsky</last-name>
<first-name>Roman</first-name>
<address>
<city>Los Altos</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="004" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Yanovsky</last-name>
<first-name>Boris</first-name>
<address>
<city>Saratoga</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Dubrovsky</last-name>
<first-name>Aleksandr</first-name>
<address>
<city>San Mateo</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Brady</last-name>
<first-name>Justin Michael</first-name>
<address>
<city>San Jose</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Yanovsky</last-name>
<first-name>Roman</first-name>
<address>
<city>Los Altos</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="004" designation="us-only">
<addressbook>
<last-name>Yanovsky</last-name>
<first-name>Boris</first-name>
<address>
<city>Saratoga</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Lewis Roca Rothgerber LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>SonicWALL, Inc.</orgname>
<role>02</role>
<address>
<city>San Jose</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Chaki</last-name>
<first-name>Kakali</first-name>
<department>2122</department>
</primary-examiner>
<assistant-examiner>
<last-name>Bharadwaj</last-name>
<first-name>Kalpana</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Techniques for data pattern analysis using deterministic finite automaton are described herein. In one embodiment, a number of transitions from a current node to one or more subsequent nodes representing one or more sequences of data patterns is determined, where each of the current node and subsequent nodes is associated with a deterministic finite automaton (DFA) state. A data structure is dynamically allocated for each of the subsequent nodes for storing information associated with each of the subsequent nodes, where data structures for the subsequent nodes are allocated in an array maintained by a data structure corresponding to the current node if the number of transitions is greater than a predetermined threshold. Other methods and apparatuses are also described.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="197.95mm" wi="138.94mm" file="US08626689-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="225.38mm" wi="152.91mm" file="US08626689-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="168.40mm" wi="142.66mm" orientation="landscape" file="US08626689-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="242.82mm" wi="173.31mm" file="US08626689-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="186.77mm" wi="183.22mm" file="US08626689-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="176.95mm" wi="155.87mm" file="US08626689-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="222.76mm" wi="175.26mm" file="US08626689-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="208.20mm" wi="171.62mm" file="US08626689-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="194.06mm" wi="179.92mm" file="US08626689-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="219.12mm" wi="180.59mm" file="US08626689-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="177.63mm" wi="171.37mm" file="US08626689-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="219.12mm" wi="185.84mm" file="US08626689-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="185.17mm" wi="164.08mm" file="US08626689-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">This is a continuation of U.S. patent application Ser. No. 11/778,546, entitled &#x201c;Data Pattern Analysis Using Optimized Deterministic Finite Automation&#x201d; filed on Jul. 16, 2007 now U.S. Pat. No. 7,991,723, which is incorporated by reference in its entirety.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">FIELD OF THE INVENTION</heading>
<p id="p-0003" num="0002">The present invention relates generally to data pattern analysis. More particularly, this invention relates to data pattern analysis using deterministic finite automaton.</p>
<heading id="h-0003" level="1">BACKGROUND</heading>
<p id="p-0004" num="0003">Deterministic finite automaton (DFA) or deterministic finite state machine is a set of states tied together by a set of transitions, where transitions specify movement from one state to another based on some input. Thus, a deterministic finite automaton at a given state and for a given input has only one transition to a next state. Examples of such deterministic finite automaton may be designed in hardware or software to produce results based on the state and any input. Some applications for deterministic finite automaton are used in electronic systems, such as network equipment and computer operated systems, to control and run processes.</p>
<p id="p-0005" num="0004">To increase the speed at which a deterministic finite automaton operates on an electronic system current systems load an array into memory for each state of the deterministic finite automaton. Each array contains information on the current state and defines what the next state will be given a certain input. As the number of states and transitions between states of a deterministic finite automaton increases the size of the array also increases. This creates the need for large amounts of memory necessary to store the information needed to execute a deterministic finite automaton. As the memory demands increase so does the cost of implementing a deterministic finite automaton.</p>
<heading id="h-0004" level="1">SUMMARY OF THE DESCRIPTION</heading>
<p id="p-0006" num="0005">Techniques for data pattern analysis using deterministic finite automaton are described herein. In one embodiment, a number of transitions from a current node to one or more subsequent nodes representing one or more sequences of data patterns is determined, where each of the current node and subsequent nodes is associated with a deterministic finite automaton (DFA) state. A data structure is dynamically allocated for each of the subsequent nodes for storing information associated with each of the subsequent nodes, where data structures for the subsequent nodes are allocated in an array maintained by a data structure corresponding to the current node if the number of transitions is greater than a predetermined threshold.</p>
<p id="p-0007" num="0006">Other features of the present invention will be apparent from the accompanying drawings and from the detailed description which follows.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0008" num="0007">The present invention is illustrated by way of example and not limitation in the figures of the accompanying drawings in which like references indicate similar elements.</p>
<p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram illustrating an example of a network configuration according to one embodiment.</p>
<p id="p-0010" num="0009"><figref idref="DRAWINGS">FIGS. 2A-2B</figref> are state diagrams illustrating an exemplary DFA according to certain embodiments of the invention.</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 3</figref> is a state diagram illustrating an example of DFA states which may represent a data pattern.</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIGS. 4A-4B</figref> are block diagrams illustrating examples of data structure configurations according to certain embodiments of the invention.</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIGS. 5A-5B</figref> are flow diagrams illustrating a process for data pattern analysis according to certain embodiments of the invention.</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIGS. 6A-6B</figref> are pseudo code representing examples of data structures according to certain embodiments of the invention.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 7</figref> is a diagram of a network of computer systems, which may be used with an embodiment of the invention.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 8</figref> is a block diagram of a digital processing system which may be used with one embodiment of the invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0006" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0017" num="0016">Techniques for data pattern analysis using deterministic finite automaton are described herein. In the following description, numerous details are set forth to provide a more thorough explanation of embodiments of the present invention. It will be apparent, however, to one skilled in the art, that embodiments of the present invention may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form, rather than in detail, in order to avoid obscuring embodiments of the present invention.</p>
<p id="p-0018" num="0017">Reference in the specification to &#x201c;one embodiment&#x201d; or &#x201c;an embodiment&#x201d; means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the invention. The appearances of the phrase &#x201c;in one embodiment&#x201d; in various places in the specification do not necessarily all refer to the same embodiment.</p>
<p id="p-0019" num="0018">Recently, DFA states have been widely used in identifying certain data patterns of data traffics such as, for example, antivirus, anti-spyware and/or content filtering processes in a network environment. Each DFA state is associated with a data structure to store certain information regarding to a respective DFA state such as target or matched data, link references to other data structures of other DFA states. The data structures of DFA states that represent certain data pattern may be referenced one another. A first data structure may reference a second data structure either including the whole second data structure (e.g., an array) or alternatively, a link referenced to an address of the second data structure (e.g., a linked-list structure). As described above, if the first data structure contains the entire second data structure, processing logic can access from the first data structure to the second data structure faster, but it requires more memory to retain the second data structure. In a linked-list manner, it takes less memory; however, it accesses slower.</p>
<p id="p-0020" num="0019">According to certain embodiments of the invention, dependent upon certain data patterns being examined, data structures for the DFA states may be allocated in an array manner, a linked-list manner, or a combination of both, to optimize the memory usage (e.g., a hybrid approach). For example, given the fact that some states do not necessarily have all 256 transitions (e.g., standard 256 ACSII codes representing 256 characters) associated with them and some do, for certain states with more than or equal to a certain threshold, most or all transitions are allocated as pointers in a dynamic array. For states which have transitions fewer than certain threshold, the transitions may be allocated in a linked-list manner in which each state requires only two pointers, one referencing to its parent and the other one referencing to its child. Alternatively, for a given state of a sequence of state representing a data sequence, based on a relationship between the given state and its top parent state (e.g., root state), a data structure for the given state may be allocated in a data array or in a linked-list manner. For example, if a given node is within a predetermined distance from its root node, the data structure corresponding to the given node may be allocated in an array; otherwise, the data structure may be allocated in a linked-list manner. The distance threshold may be user configurable and/or specified in the data structure of the root node. Other configurations may exist.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram illustrating an example of a network configuration according to one embodiment. Referring to <figref idref="DRAWINGS">FIG. 1</figref>, in one embodiment, the network configuration <b>100</b> includes a network access device <b>104</b> providing network access services for one or more network nodes <b>106</b>-<b>107</b> over a first network <b>105</b> which may be a local area network (LAN). In order to access remote nodes <b>101</b>-<b>102</b> (e.g., Web servers or peer nodes) over a second network <b>103</b> (e.g., an external network), each of the nodes <b>106</b>-<b>107</b> has to go through the network access device <b>104</b> and optionally, a network service provider (e.g., an Internet service provider or ISP) in order to access remote nodes <b>101</b>-<b>102</b>.</p>
<p id="p-0022" num="0021">In one embodiment, the connection between the network access device <b>104</b> and the network <b>103</b> may be a wired connection. Alternatively, such a connection may be a wireless connection; for example, a satellite or an IEEE 802.1x compatible connection. The network <b>103</b> may be a wide area network (WAN), such as, for example, the Internet. The network <b>105</b> may be a home network using an IEEE 802.1x compatible protocol. Alternatively, the network <b>105</b> may be a local network within an organization (e.g., an Intranet). The network <b>105</b> may be a wired or wireless network, or a combination of both, using a variety of network protocols, such as, Ethernet and/or IEEE 802.1x compatible protocols, such as, for example, Wi-Fi and/or Bluetooth protocols. Wireless connections may include both RF and non-RF links, for example, an IR link. Wired connections may include both electrical and non-electrical links, for example, fiber optic links.</p>
<p id="p-0023" num="0022">According to one embodiment, network access device <b>104</b> (e.g., gateway device) includes packet inspection logic <b>108</b> which may be implemented as part of an antivirus/spyware and/or content filtering function of the network access device <b>104</b>. Packet inspection logic <b>108</b> may inspect incoming and/or outgoing data packets to detect certain data patterns which may be used to identify certain offensive data such as viruses or certain offensive content. The packet inspection logic <b>108</b> may use multiple DFA states to identify the data patterns, where each DFA is associated with a data structure (e.g., DFA data structures <b>109</b>) to store certain state information of the respective DFA state. According to one embodiment, the DFA data structures <b>109</b> may be allocated dependent upon the specific transitions from one DFA state to another DFA state of a data pattern. The data structures of the child nodes may be allocated in a dynamic array fashion, a linked-list manner, or a combination of both. For example, for certain states with more than or equal to a certain threshold, most or all transitions are allocated as pointers in a dynamic array. For states which have transitions fewer than certain threshold, the transitions may be allocated in a linked-list manner in which each state requires only two pointers, one referencing to its parent and the other one referencing to its child. Furthermore, a data structure for a given node may be allocated in an array or in a linked-list manner dependent upon its relationship (e.g., distance from the root node) with respect to its top parent node or root node. As a result, memory usage for the DFA data structures may be optimized without compromising the performance of content scanning.</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 2A</figref> is a state diagram illustrating an exemplary DFA according to one embodiment of the invention. In this example, an IPS (intrusion detection/prevention system) is programmed to detect and to prevent a pattern of &#x201c;0111&#x201d; to pass through. The DFA <b>200</b> shown in <figref idref="DRAWINGS">FIG. 2A</figref> corresponds to this pattern. Processing logic may use the DFA <b>200</b> to perform pattern matching on a number of packets to determine whether the packets contain the pattern &#x201c;0111&#x201d;. Furthermore, to simplify the illustration, it is assumed in this example that each packet contains only one digit. However, it should be appreciated that the concept is applicable to scenarios where a packet contains more than one digit and/or alphabetic letters.</p>
<p id="p-0025" num="0024">Referring to <figref idref="DRAWINGS">FIG. 2A</figref>, the DFA <b>200</b> includes 5 states <b>211</b>-<b>219</b>. The states <b>211</b>-<b>219</b> in the DFA <b>200</b> may be referred to as nodes. Pattern matching begins at the initial state <b>211</b>. If a packet received contains a &#x201c;1&#x201d;, processing logic remains in the initial state <b>211</b>. If the packet contains a &#x201c;0&#x201d;, which corresponds to the first digit in the predetermined pattern, processing logic transitions to the A state <b>213</b>. If processing logic receives a &#x201c;0&#x201d; subsequently, processing logic remains in the A state <b>213</b>. If processing logic receives a &#x201c;1&#x201d;, which corresponds to the second digit in the predetermined pattern, then processing logic transitions into the B state <b>215</b>. From the B state <b>215</b>, processing logic may transition back to the A state <b>213</b> if the next packet received contains a &#x201c;0&#x201d;. If the next packet received contains a &#x201c;1&#x201d;, which corresponds to the third digit in the predetermined pattern, then processing logic transitions to the C state <b>217</b>.</p>
<p id="p-0026" num="0025">From the C state <b>217</b>, processing logic may transition back to the A state <b>213</b> if the next packet received contains a &#x201c;0&#x201d;. If the next packet received contains a &#x201c;1&#x201d;, which corresponds to the last digit in the predetermined pattern, then processing logic transitions to the final state <b>219</b>. When processing logic reaches the final state <b>219</b>, processing logic knows that the packets received so far contains the predetermined pattern. Hence, processing logic may perform the appropriate operations in response to receiving the predetermined pattern, such as block the packet of the predetermined pattern last received and issuing an alarm to alert system administrators. To keep track of which state of the DFA processing logic is in, processing logic may use a logical pointer to point to the current state of the DFA. For example, a logical pointer <b>221</b> in <figref idref="DRAWINGS">FIG. 2A</figref> points at state B <b>215</b> to indicate that state B <b>215</b> is the current state of the pattern matching.</p>
<p id="p-0027" num="0026">One advantage of using the DFA to perform pattern matching on packets is to eliminate the need to reassemble the packets because processing logic can walk through the DFA as each packet is received and examined. If processing logic reaches a final state, there is a match between the pattern contained in the packets received so far and the predetermined pattern. As mentioned above, a pattern is typically broken up into a number of segments and each segment is transmitted using a packet. Using the DFA, processing logic may not have to reassemble the packets in order to find out what the pattern contained in the packets is in order to match the pattern against a predetermined pattern. Processing logic may perform pattern matching on a packet-by-packet basis as each of the packets is received without reassembling the packets. Therefore, processing logic does not have to store the packets for reassembling the packets. Instead, processing logic may simply store a pointer to keep track of the current state in the DFA.</p>
<p id="p-0028" num="0027">The concept described above may be expanded to signature detection. A signature is a collection of multiple patterns. To keep track of which pattern within a signature is being matched, processing logic may use a tree structure, where each node within the tree structure corresponds to a pattern and each pattern is represented using a DFA. Alternatively, a single DFA may represent multiple patterns, an example of which is discussed below with reference to <figref idref="DRAWINGS">FIG. 2B</figref>. Processing logic may use a pointer to point at the node corresponding to the pattern that is currently being matched.</p>
<p id="p-0029" num="0028">In some embodiments, multiple patterns in a signature are matched sequentially. That is, once a first pattern is matched, processing logic goes on to try to match a second pattern. However, processing logic may continue looking for the first pattern in the incoming data packets because the first pattern may repeat before the second pattern arrives. In some embodiments, processing logic has to take into consideration of additional rules besides matching individual patterns of a signature. For example, a first pattern may have to be at least x bytes away from the second pattern, where x is a predetermined number. Alternatively, two patterns of the signature may have to be separated from each other by y bytes or less, where y is a predetermined number.</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 2B</figref> is a state diagram illustrating an exemplary DFA according to an alternative embodiment of the invention. In this example, an IPS is programmed to detect a pattern of &#x201c;CAT&#x201d; and a pattern of &#x201c;CACHE.&#x201d; Both patterns may be part of a signature. To simplify the illustration, it is assumed in this example that each packet contains only one alphabetic letter. However, it should be appreciated that the concept is applicable to scenarios where a packet contains one or more alphabetic letters and/or one or more numeric digits.</p>
<p id="p-0031" num="0030">The DFA <b>250</b> includes six states <b>251</b>-<b>257</b>. Pattern matching begins at the initial state <b>251</b>. If a packet received contains a &#x201c;C,&#x201d; which is the first letter of both &#x201c;CAT&#x201d; and &#x201c;CACHE,&#x201d; processing logic transitions to the state <b>252</b>. If the packet received contains any other alphabet, processing logic remains in the initial state <b>251</b>. From state <b>252</b>, if processing logic receives a &#x201c;C,&#x201d; then processing logic remains in state <b>252</b>. If processing logic receives an &#x201c;A,&#x201d; then processing logic transitions to state <b>253</b>. If processing logic receives any alphabet other than &#x201c;A&#x201d; or &#x201c;C,&#x201d; processing logic returns to the initial state <b>251</b>.</p>
<p id="p-0032" num="0031">From state <b>253</b>, if processing logic receives a &#x201c;C,&#x201d; then processing logic transitions to state <b>254</b> because &#x201c;C&#x201d; is the third letter in the pattern &#x201c;CACHE.&#x201d; If processing logic receives a &#x201c;T,&#x201d; then processing logic transitions to the final state <b>257</b> because the pattern &#x201c;CAT&#x201d; is matched. If processing logic receives any alphabet other than &#x201c;T&#x201d; or &#x201c;C,&#x201d; processing logic returns to the initial state <b>251</b>. From state <b>254</b>, if processing logic receives a &#x201c;C,&#x201d; then processing logic transitions back to state <b>253</b>. If processing logic receives an &#x201c;H,&#x201d; then processing logic transitions to state <b>255</b>. If processing logic receives any alphabet other than &#x201c;H&#x201d; or &#x201c;C,&#x201d; processing logic returns to the initial state <b>251</b>.</p>
<p id="p-0033" num="0032">From state <b>255</b>, if processing logic receives a &#x201c;C,&#x201d; then processing logic transitions back to state <b>252</b>. If processing logic receives an &#x201c;E,&#x201d; then processing logic transitions to the final state <b>256</b> because the pattern matches &#x201c;CACHE.&#x201d; If processing logic receives any alphabet other than &#x201c;E&#x201d; or &#x201c;C,&#x201d; processing logic returns to the initial state <b>251</b>. As discussed above, when processing logic reaches a final state (e.g., state <b>256</b> and state <b>257</b>), processing logic knows that the packets received so far contains at least one of the predetermined patterns. Hence, processing logic may perform the appropriate operations in response to receiving the predetermined pattern, such as blocking the packet of the predetermined pattern last received and issuing an alarm to alert system administrators. Furthermore, to keep track of which state of the DFA <b>250</b> processing logic is in, processing logic may use a logical pointer to point to the current state of the DFA <b>250</b>. Further detailed information concerning the above packet scanning techniques can be found in a co-pending U.S. patent application Ser. No. 11/112,252, entitled &#x201c;Method and Apparatus for Identifying Data Patterns in a File,&#x201d; filed Apr. 21, 2005, which has been assigned to a common assignee of this application, and which is incorporated by reference herein in its entirety.</p>
<p id="p-0034" num="0033">As described above, each DFA state is associated with a data structure for storing state information for the respective DFA state. Each data structure is dynamically allocated from a parent state dependent upon a specific data pattern at the point in time. For example, referring to <figref idref="DRAWINGS">FIG. 2B</figref>, at node or state <b>253</b>, a next state could be state <b>254</b> or state <b>257</b> dependent upon a specific data pattern. As a result, a DFA data structure associated with a child node of node <b>253</b> may be in a dynamic array manner or in a linked list manner based on certain rules, which may be configured by a network administrator or predetermined policies.</p>
<p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. 3</figref> is a state diagram illustrating an example of DFA states which may represent a data pattern. Referring to <figref idref="DRAWINGS">FIG. 3</figref>, in this example, a parent node <b>301</b> has two child nodes <b>302</b>-<b>303</b>, each corresponding to a transition from node <b>301</b>. Node <b>302</b> includes child nodes <b>304</b>-<b>306</b>, each corresponding to a transition from node <b>302</b>, while node <b>302</b> itself is a child node to node <b>301</b>. Node <b>303</b> includes only one child node <b>307</b> forming a single node chain having nodes <b>308</b> and <b>309</b>.</p>
<p id="p-0036" num="0035">According to one embodiment, for a given node, if a number of transitions from this given node to child nodes of this given node is greater than or equal to a predetermined threshold, the data structures for the child nodes are allocated in an array do that the data structures of the child nodes can be directly accessed from the data structure of the given node (e.g., parent node). In this configuration, if number of the transitions is relatively large, that means the child nodes or DFA states are frequently accessed from the parent node (e.g., commonly used data patterns). As a result, it is desirable that the data structures for all child nodes are maintained and directly accessed from the parent node for the purposes of performance, even though this configuration requires more memory (e.g., contiguous or continuous) for the data structures.</p>
<p id="p-0037" num="0036">Referring back to <figref idref="DRAWINGS">FIG. 3</figref>, given node <b>302</b>, it is assumed that the number of transitions from node <b>302</b> to nodes <b>304</b>-<b>306</b> is greater than or equal to a predetermined threshold (e.g., 3 in this example). Thus, from the data structure associated with node <b>302</b>, data structures for nodes <b>304</b>-<b>306</b> are allocated in an array (e.g., a continued block of memory) which can be directly and quickly accessed from node <b>302</b>, as shown in <figref idref="DRAWINGS">FIG. 4A</figref>. In this situation, the benefit of higher performance outweighs the detriment of requiring a larger memory block. If, however, the number of transitions is less than a certain threshold, the data structures of the child nodes may be allocated in a linked-list configuration as shown in <figref idref="DRAWINGS">FIG. 4B</figref>, where each data structure includes a first reference pointer linked with a data structure of its immediate parent node and a second reference pointer linked with a data structure of one its immediate child node in a chain fashion. In a linked-list configuration a parent node has to walk through one child node at a time in order to access to all of its child nodes. In this way, a smaller continued or contiguous block of memory is needed; however, it may take a longer time to access all the child nodes. Since there are fewer child nodes, memory usage may be reduced and the performance drawback may be minimized.</p>
<p id="p-0038" num="0037">According to another embodiment, for a given node, if there is only one immediate child node (e.g., the whole data sequence is a single child chain where a node has only zero or one child node), a data structure of the top parent node of the chain may include most or all necessary information for the child nodes in the chain, optionally in a compressed manner, to further reduce memory usage without significantly compromising the performance. In this example as shown in <figref idref="DRAWINGS">FIG. 3</figref>, data structures for states or nodes <b>303</b>, and <b>307</b>-<b>309</b> may be allocated in a compressed form within the data structure corresponding their root parent node <b>301</b>. Examples of pseudo code in C/C++ representing the data structures are shown in <figref idref="DRAWINGS">FIGS. 6A-6B</figref>.</p>
<p id="p-0039" num="0038">Furthermore, according to further embodiment, for a given state of a sequence of state representing a data sequence, based on a relationship between the given state and its top parent state (e.g., root state), a data structure for the given state may be allocated in a data array or in a linked-list manner. For example, if a given node is within a predetermined distance from its root node, the data structure corresponding to the given node may be allocated in an array; otherwise, the data structure may be allocated in a linked-list manner. The distance threshold may be user configurable and/or specified in the data structure of the root node.</p>
<p id="p-0040" num="0039">Referring back to <figref idref="DRAWINGS">FIG. 3</figref>, for example, it is assumed that a data structure for any node within a three node distance from its root parent node will be allocated in an array; otherwise the data structure will be allocated in a linked-list manner. Thus, in this example as shown in <figref idref="DRAWINGS">FIG. 3</figref>, data structures for nodes <b>303</b> and <b>307</b>-<b>308</b> may be allocated in an array within the data structure for the root node <b>301</b>, while the data structure for node <b>309</b> may be allocated in a separate data structure accessible from the data structure corresponding to node <b>308</b> via a linked-list manner. Note that the configurations of data structures described above may be allocated in a mixed or combined manner. Thus, data structures for a particular sequence may be allocated in an array in part and in a linked-list manner in part.</p>
<p id="p-0041" num="0040"><figref idref="DRAWINGS">FIG. 5A</figref> is a flow diagram illustrating a process for data pattern analysis according to one embodiment of the invention. Note that process <b>500</b> may be performed by processing logic which may include hardware, software, or a combination of both. For example, process <b>500</b> may be performed by a network access device such as network access device <b>104</b> of <figref idref="DRAWINGS">FIG. 1</figref>. Referring to <figref idref="DRAWINGS">FIG. 5A</figref>, at block <b>501</b>, for given a current node of multiple nodes representing one or more data patterns, where each node corresponding to a DFA state, processing logic determines a number of transitions from the current node to one or more immediate child nodes. If the number of transitions is greater than or equal to a predetermined threshold or alternatively, if a child node is within a predetermined distance from the root node, at block <b>502</b>, data structures for the child nodes are allocated in an array (e.g., continuous block of memory) that are directly accessible from the current node. In this way, the data structures of the child nodes can be quickly accessed, but it requires more memory at block <b>504</b>. Otherwise, at block <b>503</b>, each data structure corresponding to an immediate child node is allocated in a linked-list manner, where the current node has to &#x201c;walk&#x201d; through intermediate nodes in order to reach a node down at the bottom of the linked-list. In this way, it requires less memory, but the performance (e.g., speed) to access these data structures would be reduced at block <b>504</b>. Other operations may also be performed.</p>
<p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. 5B</figref> is a flow diagram illustrating a process for data pattern analysis according to an alternative embodiment of the invention. Note that process <b>550</b> may be performed by processing logic which may include hardware, software, or a combination of both. For example, process <b>550</b> may be performed by a network access device such as network access device <b>104</b> of <figref idref="DRAWINGS">FIG. 1</figref>. Referring to <figref idref="DRAWINGS">FIG. 5B</figref>, at block <b>551</b>, for given a current node of multiple nodes representing one or more data patterns, where each node corresponding to a DFA state, processing logic determines whether the child nodes are in a single node chain (e.g., each node in the chain only has one immediate child node). If so, at block <b>552</b>, a single data structure is allocated for the entire chain. In one embodiment, the single data structure is allocated for the most top parent node of the chain. The data members of the single data structure are used to store all necessary information for each child node in the chain, optionally in a compressed form, which can be directly accessed during data pattern analysis at block <b>554</b>. Otherwise, at block <b>553</b>, the data structures for the child nodes may be allocated dependent upon other factors such as those shown in <figref idref="DRAWINGS">FIG. 5A</figref>. Other operations may also be performed.</p>
<p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. 6A</figref> is pseudo code representing a data structure used in a data pattern analysis according to one embodiment. Referring to <figref idref="DRAWINGS">FIG. 6A</figref>, data structure <b>600</b> may be allocated to a parent node of a sequence of data pattern. As described above, data structure <b>600</b> representing a parent node may need to access a data structure of a child node in a form dependent upon a specific configuration of a data pattern. For example, as described above, if the number of transitions from a parent node exceeds a predetermined threshold, the data structures of all child nodes are allocated in an array as data member <b>601</b> directly accessed by data structure <b>600</b>. In this situation, the benefit of higher performance justifies a larger memory block.</p>
<p id="p-0044" num="0043">Otherwise, if the number of transitions from a parent node is below a predetermined threshold, the data structures of all child nodes are allocated in a linked-list manner as data member <b>602</b> in which a parent node associated with data structure <b>600</b> has to &#x201c;walk&#x201d; through each data structure one at a time. Although it may take longer time to walk through, a smaller memory block is needed. Since the number of transitions is relatively small, the balance of memory usage and performance is achieved.</p>
<p id="p-0045" num="0044">In a special situation in which the sequence of data pattern is a single node chain, as described above, a single data structure is allocated for all child nodes in a compressed form as data member <b>603</b> (with a data structure example as shown in <figref idref="DRAWINGS">FIG. 6B</figref>). That is, in this situation, only one data structure accessed from the parent node is needed to represent all child nodes. Since each child node can only have up to two transitions, either to an immediate parent node or to an immediate child node, a single data structure is sufficient to cover all necessary information associated with each child node in the chain.</p>
<p id="p-0046" num="0045">In addition, according to certain embodiments, data structure <b>600</b> includes data member <b>604</b> to store an entry point to a data structure of a right sibling (e.g., a horizontal sibling as shown in <figref idref="DRAWINGS">FIG. 3</figref>). Data member <b>605</b> is used to store an entry point to each transition state (also referred to as a fail state) when a current state fails to match a target data. Data member <b>606</b> is used to store an entry point of a function or routine to which processing logic will call when the current state matches the target data. Data member <b>606</b> may contain additional information about what exactly was matched by the entire sequence, such as, for example, a pattern ID and/or a function pointer to call when the match occurs, etc. Data member <b>607</b> is used to store the number of child nodes with respect to the current node as a parent node. For example, child count <b>607</b> may be used to determine whether certain child nodes should be allocated in an array or in a linked-list manner. Alternatively, the distance of a particular child node with respect to its root node can be used to determine whether the data structure for the node should be allocated in an array or in a linked-list manner. Data member <b>608</b> is used to store an ASCII content of the current node.</p>
<p id="p-0047" num="0046">Further, data member <b>609</b> is used to indicate whether the data structures of the child nodes are allocated in an array. If so, data member <b>601</b> is valid; otherwise, data member <b>602</b> is valid. Data member <b>610</b> is used to indicate whether the child nodes are in a single node chain; if so, data member <b>603</b> will take a precedent. Data structure <b>600</b> may further include certain attributes associated with the current node and/or the sequence of data pattern. For example, data member <b>611</b> may be used to indicate whether a particular character should be treated as a case sensitive or insensitive manner. Data member <b>612</b> may be used to indicate that a fail pointer from the current character points to a node with a match state, in which case, processing logic needs to follow a fail pointer and temporarily match something else while the processing logic is walking through the sequence. Note that the format of data structure <b>600</b> is shown for purposes of illustration only. More or fewer data members, as well as other formats, may also be implemented.</p>
<p id="p-0048" num="0047"><figref idref="DRAWINGS">FIG. 6B</figref> is pseudo code representing a data structure used in a data pattern analysis according to one embodiment. For example, data structure <b>650</b> may be used in a single node data chain (e.g., accessed from data structure <b>600</b> of <figref idref="DRAWINGS">FIG. 6A</figref> via data member <b>603</b>). Data structure <b>650</b> may be allocated as a single data structure to cover all child nodes in the chain, optionally in a compressed form. According to one embodiment, data member <b>651</b> may be used to indicate how many child nodes in the chain. Similar to data member <b>606</b> of data structure <b>600</b>, data member <b>652</b> may include additional information about what exactly was matched by the entire sequence, such as, for example, a pattern ID and/or a function pointer to call when the match occurs, etc. Data member <b>653</b> may be used to represent the ASCII content of the chain, such as, for example, data sequence of &#x201c;ABCDEFGH&#x201d;, etc. Data member <b>654</b> may be used to represent certain attributes associated with each character in the chain, such as those similar to attributes stored in data members <b>611</b>-<b>612</b> of data structure <b>600</b>. For example, key[0] may be used to store attributes associated with character &#x2018;A&#x2019; of data member <b>653</b>. Similar to data member <b>612</b> of data structure <b>600</b>, data member <b>655</b> may be used to store each of the fail states. Also note that the format of data structure <b>650</b> is shown for purposes of illustration only. More or fewer data members, as well as other formats, may also be utilized.</p>
<p id="p-0049" num="0048"><figref idref="DRAWINGS">FIG. 7</figref> is a diagram of a network of computer systems, which may be used with an embodiment of the invention. As shown in <figref idref="DRAWINGS">FIG. 7</figref>, a network <b>700</b> includes a number of client computer systems that are coupled together through an Internet <b>722</b>. It will be appreciated that the term &#x201c;Internet&#x201d; refers to a network of networks. Such networks may use a variety of protocols for exchange of information, such as TCP/IP, ATM, SNA, SDI. The physical connections of the Internet and the protocols and communication procedures of the Internet are well known to those in the art. It will be also appreciated that such systems may be implemented in an Intranet within an organization.</p>
<p id="p-0050" num="0049">Access to the Internet <b>722</b> is typically provided by Internet service providers (ISPs), such as the ISP <b>724</b>, and the ISP <b>726</b>. Users on client systems, such as the client computer systems <b>702</b>, <b>704</b>, <b>718</b>, and <b>720</b>, generally obtain access to the Internet through Internet service providers, such as ISPs <b>724</b> and <b>726</b>. Access to the Internet may facilitate transfer of information (e.g., email, text files, media files, etc.) between two or more digital processing systems, such as the client computer systems <b>702</b>, <b>704</b>, <b>718</b>, and <b>720</b> and/or a Web server system <b>728</b>.</p>
<p id="p-0051" num="0050">For example, one or more of the client computer systems <b>702</b>, <b>704</b>, <b>718</b>, and <b>720</b> and/or the Web server <b>728</b> may provide document presentations (e.g., a Web page) to another one or more of the client computer systems <b>702</b>, <b>704</b>, <b>718</b>, and <b>720</b> and/or Web server <b>728</b>. For example, in one embodiment of the invention, one or more client computer systems <b>702</b>, <b>704</b>, <b>718</b>, and <b>720</b> may request to access a document that may be stored at a remote location, such as the Web server <b>728</b>. In the case of remote storage, the data may be transferred as a file (e.g., download) and then displayed (e.g., in a window of a browser) after transferring the file. In another embodiment, the document presentation may be stored locally at the client computer systems <b>702</b>, <b>704</b>, <b>718</b>, and/or <b>720</b>. In the case of local storage, the client system may retrieve and display the document via an application, such as a word processing application, without requiring a network connection.</p>
<p id="p-0052" num="0051">The Web server <b>728</b> typically includes at least one computer system to operate with one or more data communication protocols, such as the protocols of the World Wide Web and, as such, is typically coupled to the Internet <b>722</b>. Optionally, the Web server <b>728</b> may be part of an ISP which may provide access to the Internet and/or other network(s) for client computer systems. The client computer systems <b>702</b>, <b>704</b>, <b>718</b>, and <b>720</b> may each, with appropriate Web browsing software, access data, such as HTML document (e.g., Web pages), which may be provided by the Web server <b>728</b>.</p>
<p id="p-0053" num="0052">The ISP <b>724</b> provides Internet connectivity to the client computer system <b>702</b> via a modem interface <b>706</b>, which may be considered as part of the client computer system <b>702</b>. The client computer systems <b>702</b>, <b>704</b>, <b>718</b>, and <b>720</b> may be a conventional data processing system, such as a desktop computer, a &#x201c;network&#x201d; computer, a handheld/portable computer, a cell phone with data processing capabilities, a Web TV system, or other types of digital processing systems (e.g., a personal digital assistant (PDA)).</p>
<p id="p-0054" num="0053">Similarly, the ISP <b>726</b> provides Internet connectivity for the client computer systems <b>702</b>, <b>704</b>, <b>718</b>, and <b>720</b>. However, as depicted in <figref idref="DRAWINGS">FIG. 7</figref>, such connectivity may vary between various client computer systems, such as the client computer systems <b>702</b>, <b>704</b>, <b>718</b>, and <b>720</b>. For example, as shown in <figref idref="DRAWINGS">FIG. 7</figref>, the client computer system <b>704</b> is coupled to the ISP <b>726</b> through a modem interface <b>708</b>, while the client computer systems <b>718</b> and <b>720</b> are part of a local area network (LAN). The interfaces <b>706</b> and <b>708</b>, shown as modems <b>706</b> and <b>708</b>, respectively, may represent an analog modem, an ISDN modem, a DSL modem, a cable modem, a wireless interface, or other interface for coupling a digital processing system, such as a client computer system, to another digital processing system.</p>
<p id="p-0055" num="0054">The client computer systems <b>718</b> and <b>720</b> are coupled to a LAN bus <b>712</b> through network interfaces <b>714</b> and <b>716</b>, respectively. The network interface <b>714</b> and <b>716</b> may be an Ethernet-type, asynchronous transfer mode (ATM), or other type of network interface. The LAN bus is also coupled to a gateway digital processing system <b>710</b>, which may provide firewall and other Internet-related services for a LAN. The gateway digital processing system <b>710</b>, in turn, is coupled to the ISP <b>726</b> to provide Internet connectivity to the client computer systems <b>718</b> and <b>720</b>. The gateway digital processing system <b>710</b> may, for example, include a conventional server computer system. Similarly, the Web server <b>728</b> may, for example, include a conventional server computer system.</p>
<p id="p-0056" num="0055">In one embodiment, the local area network <b>712</b> may be local wireless network (e.g., a home network) and the gateway <b>710</b> may include a wireless access point (also referred to as a base station) to one or more clients <b>718</b> and <b>720</b> using a variety of wireless networking protocols; for example, the IEEE 802.xx protocols including Wi-Fi and/or Bluetooth protocols. In a further embodiment, the gateway <b>710</b> may access the server <b>728</b> via dialup network services using a modem.</p>
<p id="p-0057" num="0056"><figref idref="DRAWINGS">FIG. 8</figref> is a block diagram of a digital processing system which may be used with one embodiment of the invention. For example, the system <b>500</b> shown in <figref idref="DRAWINGS">FIG. 8</figref> may be used as a client computer system such as clients <b>704</b>-<b>705</b> of <figref idref="DRAWINGS">FIG. 7</figref>. Alternatively, the exemplary system <b>800</b> may be implemented as a network access device <b>702</b>, etc.</p>
<p id="p-0058" num="0057">Note, that while <figref idref="DRAWINGS">FIG. 8</figref> illustrates various components of a computer system, it is not intended to represent any particular architecture or manner of interconnecting the components, as such details are not germane to the present invention. It will also be appreciated that network computers, handheld computers, cell phones, and other data processing systems which have fewer components or perhaps more components may also be used with the present invention. The computer system of <figref idref="DRAWINGS">FIG. 8</figref> may, for example, be an Apple Macintosh computer or an IBM compatible PC.</p>
<p id="p-0059" num="0058">As shown in <figref idref="DRAWINGS">FIG. 8</figref>, the computer system <b>800</b>, which is a form of a data processing system, includes a bus <b>802</b> which is coupled to a microprocessor <b>803</b> and a ROM <b>807</b>, a volatile RAM <b>805</b>, and a non-volatile memory <b>806</b>. The microprocessor <b>803</b>, which may be, for example, an Intel processor or a PowerPC processor, is coupled to cache memory <b>804</b> as shown in the example of <figref idref="DRAWINGS">FIG. 8</figref>. The bus <b>802</b> interconnects these various components together and also interconnects these components <b>803</b>, <b>807</b>, <b>805</b>, and <b>806</b> to a display controller and display device <b>808</b>, as well as to input/output (I/O) devices <b>810</b>, which may be mice, keyboards, modems, network interfaces, printers, and other devices which are well-known in the art.</p>
<p id="p-0060" num="0059">Typically, the input/output devices <b>810</b> are coupled to the system through input/output controllers <b>809</b>. The volatile RAM <b>805</b> is typically implemented as dynamic RAM (DRAM) which requires power continuously in order to refresh or maintain the data in the memory. The non-volatile memory <b>806</b> is typically a magnetic hard drive, a magnetic optical drive, an optical drive, or a DVD RAM or other type of memory system which maintains data even after power is removed from the system. Typically, the non-volatile memory will also be a random access memory, although this is not required.</p>
<p id="p-0061" num="0060">While <figref idref="DRAWINGS">FIG. 8</figref> shows that the non-volatile memory is a local device coupled directly to the rest of the components in the data processing system, it will be appreciated that the present invention may utilize a non-volatile memory which is remote from the system, such as a network storage device which is coupled to the data processing system through a network interface such as a modem or Ethernet interface. The bus <b>802</b> may include one or more buses connected to each other through various bridges, controllers, and/or adapters, as is well-known in the art. In one embodiment, the I/O controller <b>809</b> includes a USB (Universal Serial Bus) adapter for controlling USB peripherals. Alternatively, I/O controller <b>809</b> may include an IEEE-1394 adapter, also known as FireWire adapter, for controlling FireWire devices. Other components may also be included.</p>
<p id="p-0062" num="0061">Techniques for data pattern analysis using deterministic finite automaton have been described herein. Some portions of the preceding detailed descriptions have been presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the ways used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here, and generally, conceived to be a self-consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.</p>
<p id="p-0063" num="0062">It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion, it is appreciated that throughout the description, discussions utilizing terms such as &#x201c;processing&#x201d; or &#x201c;computing&#x201d; or &#x201c;calculating&#x201d; or &#x201c;determining&#x201d; or &#x201c;displaying&#x201d; or the like, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission or display devices.</p>
<p id="p-0064" num="0063">Embodiments of the present invention also relate to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes, or it may comprise a general-purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium, such as, but is not limited to, any type of disk including floppy disks, optical disks, CD-ROMs, and magnetic-optical disks, read-only memories (ROMs), random access memories (RAMs), erasable programmable ROMs (EPROMs), electrically erasable programmable ROMs (EEPROMs), magnetic or optical cards, or any type of media suitable for storing electronic instructions, and each coupled to a computer system bus.</p>
<p id="p-0065" num="0064">The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general-purpose systems may be used with programs in accordance with the teachings herein, or it may prove convenient to construct more specialized apparatus to perform the required method operations. The required structure for a variety of these systems will appear from the description below. In addition, embodiments of the present invention are not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of embodiments of the invention as described herein.</p>
<p id="p-0066" num="0065">A machine-readable medium may include any mechanism for storing or transmitting information in a form readable by a machine (e.g., a computer). For example, a machine-readable medium includes read only memory (&#x201c;ROM&#x201d;); random access memory (&#x201c;RAM&#x201d;); magnetic disk storage media; optical storage media; flash memory devices; electrical, optical, acoustical or other form of propagated signals (e.g., carrier waves, infrared signals, digital signals, etc.); etc.</p>
<p id="p-0067" num="0066">In the foregoing specification, embodiments of the invention have been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of the invention as set forth in the following claims. The specification and drawings are, accordingly, to be regarded in an illustrative sense rather than a restrictive sense.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for data pattern analysis, the method comprising:
<claim-text>a processor executing instructions residing in memory, the processor determining a number of transitions from a current node to one or more subsequent nodes representing one or more sequences of data patterns, each of the current node and subsequent nodes being associated with a deterministic finite automaton (DFA) state; and</claim-text>
<claim-text>the processor dynamically allocating a data structure for each of the subsequent nodes for storing information associated with each of the subsequent nodes in memory, wherein data structures for the subsequent nodes are dynamically allocated a first type of data structure to optimize performance when the number of transitions is greater than a predetermined threshold, and wherein data structures for the subsequent nodes are dynamically allocated a second type of data structure to optimize memory utilization when the number of transitions is less than or equal to the predetermined threshold.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the data structures for the subsequent nodes corresponding to the first type of data structure is an array maintained by a data structure corresponding to the current node, and wherein the data structures for the subsequent nodes corresponding to the second type of data structure are dynamically allocated in a chain manner with a reference maintained by the data structure corresponding to the current node.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein each element of the array is directly accessible from the data structure corresponding to the current node.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the data structures for the subsequent nodes corresponding to the first type of data structure is an array maintained by a data structure corresponding to the current node, and wherein the data structures for the subsequent nodes corresponding to the second type of data structure are dynamically allocated in a linked-list manner, wherein each of the data structures dynamically allocated in a linked-list manner includes a first reference pointer linked to a previous data structure and a second reference pointer linked to a next data structure.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising determining whether each of the subsequent nodes includes a single child node, wherein the data structures for the subsequent nodes corresponding to the first type of data structure are allocated in an array maintained by a data structure corresponding to the current node when each of the subsequent nodes includes a single child node.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, further comprising allocating an array for storing matched data for the subsequent nodes and accessible by the data structure of the current node, each element of the array corresponding to one subsequent node.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. A non-transitory computer readable storage medium having embodied thereon a program executable by a processor to perform a method for data pattern analysis, the method comprising:
<claim-text>determining a number of transitions from a current node to one or more subsequent nodes representing one or more sequences of data patterns, each of the current node and subsequent nodes being associated with a deterministic finite automaton (DFA) state; and</claim-text>
<claim-text>dynamically allocating a data structure for each of the subsequent nodes for storing information associated with each of the subsequent nodes in memory, wherein data structures for the subsequent nodes are dynamically allocated a first type of data structure to optimize performance when the number of transitions is greater than a predetermined threshold and wherein data structures for the subsequent nodes are dynamically allocated a second type of data structure to optimize memory utilization when the number of transitions is less than or equal to the predetermined threshold.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The non-transitory computer readable storage medium of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the data structures for the subsequent nodes corresponding to the first type of data structure is an array maintained by a data structure corresponding to the current node, and wherein the data structures for the subsequent nodes corresponding to the second type of data structure are dynamically allocated in a chain manner with a reference maintained by the data structure corresponding to the current node.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The non-transitory computer readable storage medium of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein each element of the array is directly accessible from the data structure corresponding to the current node.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The non-transitory computer readable storage medium of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the data structures for the subsequent nodes corresponding to the first type of data structure is an array maintained by a data structure corresponding to the current node, and wherein the data structures for the subsequent nodes corresponding to the second type of data structure are dynamically allocated in a linked-list manner, wherein each of the data structures dynamically allocated in a linked-list manner includes a first reference pointer linked to a previous data structure and a second reference pointer linked to a next data structure.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The non-transitory computer readable storage medium of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the method further comprising determining whether each of the subsequent nodes includes a single child node, wherein the data structures for the subsequent nodes corresponding to the first type of data structure are allocated in an array maintained by a data structure corresponding to the current node when each of the subsequent nodes includes a single child node.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The non-transitory computer readable storage medium of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the method further comprising allocating an array for storing matched data for the subsequent nodes and accessible by the data structure of the current node, each element of the array corresponding to one subsequent node.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. A data processing system, the system comprising:
<claim-text>a processor; and</claim-text>
<claim-text>a memory for storing instructions, which when executed from the memory, cause the processor to determine a number of transitions from a current node to one or more subsequent nodes representing one or more sequences of data patterns, each of the current node and subsequent nodes being associated with a deterministic finite automaton (DFA) state, and the processor dynamically allocating a first type of data structure to optimize performance or a second type of data structure to optimize memory utilization for each of the subsequent nodes for storing information associated with each of the subsequent nodes, wherein data structures for the subsequent nodes corresponding to the first data structure are dynamically allocated in an array maintained by a data structure corresponding to the current node when the number of transitions is greater than a predetermined threshold, and wherein data structures for the subsequent nodes corresponding to the second data structure are dynamically allocated in a chain manner or in a linked-list manner when the number of transitions is less than or equal to the predetermined threshold.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. A method for data pattern analysis, the method comprising:
<claim-text>a processor executing instructions residing in memory, the processor determining whether each of one or more subsequent nodes transitioned from a current node includes a single child node, the current node and subsequent nodes representing one or more sequences of data patterns, wherein each of the current node and subsequent nodes is associated with a deterministic finite automaton (DFA) state; and</claim-text>
<claim-text>the processor dynamically allocating a data structure for each of the subsequent nodes for storing information associated with each of the subsequent nodes in memory, wherein data structures for the subsequent nodes are dynamically allocated in an array to optimize performance wherein the data structures in the array are maintained by a data structure corresponding to the current node when each of the subsequent nodes includes a single child node, and wherein data structures for the subsequent nodes are dynamically allocated a second type of data structure to optimize memory utilization when the number of transitions is less than or equal to the predetermined threshold.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the data structures for the subsequent nodes corresponding to the second type of data structure are dynamically allocated in a chain manner with a reference maintained by the data structure corresponding to the current node.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The method of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the data structures for the subsequent nodes corresponding to the second type of data structure are dynamically allocated in a linked-list manner, wherein each of the data structures includes a first reference pointer linked to a previous data structure and a second reference pointer linked to a next data structure.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The method of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein each element of the array is directly accessible from the data structure corresponding to the current node.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. A non-transitory computer readable storage medium for storing instructions embodied thereon a program executed by a processor to perform a method for data pattern analysis, the method comprising:
<claim-text>determining whether each of one or more subsequent nodes transitioned from a current node includes a single child node, the current node and subsequent nodes representing one or more sequences of data patterns, wherein each of the current node and subsequent nodes is associated with a deterministic finite automaton (DFA) state;</claim-text>
<claim-text>determining a number of transitions from the current node to the one or more subsequent nodes representing one or more sequences of data patterns; and</claim-text>
<claim-text>dynamically allocating a data structure for each of the subsequent nodes for storing information associated with each of the subsequent nodes, wherein data structures for the subsequent nodes are dynamically allocated in an array to optimize performance, the data structures for the subsequent nodes maintained by a data structure corresponding to the current node when each of the subsequent nodes includes a single child node, and when the number of transitions is greater than a predetermined threshold and wherein data structures for the subsequent nodes are dynamically allocated a second type of data structure to optimize memory utilization when the number of transitions is less than or equal to the predetermined threshold.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The non-transitory computer readable storage medium of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the data structures for the subsequent nodes corresponding to the second type of data structure are dynamically allocated in a chain manner with a reference maintained by the data structure corresponding to the current node.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The non-transitory computer readable storage medium of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein the data structures for the subsequent nodes corresponding to the second type of data structure are dynamically allocated in a linked-list manner, wherein each of the data structures includes a first reference pointer linked to a previous data structure and a second reference pointer linked to a next data structure.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. A method for data pattern analysis, the method comprising:
<claim-text>a processor executing instruction residing in memory, the processor determining a relationship of each of one or more child nodes transitioned from a root parent node include a distance between each of the child nodes and the root parent node, the root parent node and child nodes representing one or more sequences of data patterns, wherein each of the root parent node and child nodes is associated with a deterministic finite automaton (DFA) state; and</claim-text>
<claim-text>the processor dynamically allocating a data structure for each of the child nodes for storing information associated with each of the child nodes in memory, wherein a data structure for a child node is dynamically allocated in an array to optimize performance when the distance between the child node and the root parent node is less than a predetermined threshold or in a linked-list manner to optimize memory utilization when the distance between the child node and the root parent node is greater than or equal to a predetermined threshold.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. The method of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the distance between the child node and the root parent node is represented by a number of intermediate nodes between the child node and the root parent node.</claim-text>
</claim>
<claim id="CLM-00023" num="00023">
<claim-text>23. A non-transitory computer readable storage medium having embodied thereon a program executable cause the to perform a method for data pattern analysis, the method comprising:
<claim-text>determining a relationship of each of one or more child nodes transitioned from a root parent node include a distance between each of the child nodes and the root parent node, the root parent node and child nodes representing one or more sequences of data patterns, wherein each of the root parent node and child nodes is associated with a deterministic finite automaton (DFA) state; and</claim-text>
<claim-text>dynamically allocating a data structure for each of the child nodes for storing information associated with each of the child nodes, wherein a data structure for a child node is allocated either in an array to optimize performance when the distance between the child node and the root parent node is less than a predetermined threshold or in a linked-list manner to optimize memory utilization when the distance between the child node and the root parent node is greater than or equal to a predetermined threshold.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00024" num="00024">
<claim-text>24. The non-transitory computer readable storage medium of <claim-ref idref="CLM-00023">claim 23</claim-ref>, wherein the distance between the child node and the root parent node is represented by a number of intermediate nodes between the child node and the root parent node. </claim-text>
</claim>
</claims>
</us-patent-grant>
