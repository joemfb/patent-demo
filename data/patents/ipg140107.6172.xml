<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627296-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627296</doc-number>
<kind>B1</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12882491</doc-number>
<date>20100915</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>243</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>44</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>717135</main-classification>
<further-classification>717124</further-classification>
<further-classification>717130</further-classification>
</classification-national>
<invention-title id="d2e53">Unified unit and integration test with automatic mock creation</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>7587636</doc-number>
<kind>B2</kind>
<name>Tillmann et al.</name>
<date>20090900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714 33</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>8087007</doc-number>
<kind>B2</kind>
<name>Duneau</name>
<date>20111200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717135</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>2008/0256517</doc-number>
<kind>A1</kind>
<name>Atkin et al.</name>
<date>20081000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717124</main-classification></classification-national>
</us-citation>
<us-citation>
<nplcit num="00004">
<othercit>Mark Seemann, &#x201c;Mock Objects to the Rescue! Test your .NET Code with NMock&#x201d;, Oct. 2004; MSDN Oct 2004 [Retrieve from msdn.microsoft.com/en-us/magazine/cc163904.aspx on Aug. 20, 2012].</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00005">
<othercit>Alexander Chaffee, &#x201c;Unit testing with mock objects&#x201d;, Nov. 1, 2002; DeveloperWorks [Retrieve from www.ibm.com/developerworks/library/j-mocktest/index.html on Aug. 20, 2012].</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00006">
<othercit>Donsw, &#x201c;Unit Testing options in Visual Studio 2008&#x201d;, May 10, 2009 [Retrieve from www.codeproject.com/Articles/36321/unit-testing-options-in-visual-studio-2008 on Aug. 26, 2012].</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00007">
<othercit>Omar Al Zabir, &#x201c;Do Unit Test and Integration Test from same test code using Conditional Compilation&#x201d;, Feb. 28, 2010 [Retrieve from http://omaralzabir.com/do<sub>&#x2014;</sub>unit<sub>&#x2014;</sub>test<sub>&#x2014;</sub>and<sub>&#x2014;</sub>integration<sub>&#x2014;</sub>test<sub>&#x2014;</sub>from<sub>&#x2014;</sub>same<sub>&#x2014;</sub>test<sub>&#x2014;</sub>code<sub>&#x2014;</sub>using<sub>&#x2014;</sub>conditional<sub>&#x2014;</sub>compilation/ on Sep. 6, 2012.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00008">
<othercit>Kirby, D., &#x201c;The Python Mock Module,&#x201d; Sourceforge.net, 2005, 6 pages [online] [retrieved on Feb. 1, 2011] retrieved from the internet &#x3c;URL:http://python-mock.sourceforge.net/&#x3e;.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00009">
<othercit>Bernhardt, G., &#x201c;Dingus&#x201d; Github Inc., 2011, 5 pages [online] [retrieved on Feb. 1, 2011] retrieved from the internet &#x3c;URL:https://github.com/garybernhardt/dingus&#x3e;.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>14</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>7</number-of-drawing-sheets>
<number-of-figures>7</number-of-figures>
</figures>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Picard</last-name>
<first-name>Antoine</first-name>
<address>
<city>Mountain View</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Picard</last-name>
<first-name>Antoine</first-name>
<address>
<city>Mountain View</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Fenwick &#x26; West LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Google Inc.</orgname>
<role>02</role>
<address>
<city>Mountain View</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Zhen</last-name>
<first-name>Li B</first-name>
<department>2197</department>
</primary-examiner>
<assistant-examiner>
<last-name>Chen</last-name>
<first-name>Sen</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Computer code for a mock object is automatically generated and used in testing computer program code. Interactions with a method of an object that is described by the computer program code are captured. From the captured interactions, mock code that creates a mock object is automatically generated. The mock object mimics the captured interactions. Subsequently, test code, which has at least some of the computer program code and mock code, is executed to enable testing of the computer program code.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="132.76mm" wi="161.63mm" file="US08627296-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="172.30mm" wi="121.24mm" file="US08627296-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="244.18mm" wi="179.92mm" file="US08627296-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="193.38mm" wi="88.31mm" file="US08627296-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="209.55mm" wi="186.77mm" file="US08627296-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="190.42mm" wi="98.81mm" file="US08627296-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="195.41mm" wi="104.48mm" file="US08627296-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="202.61mm" wi="148.25mm" file="US08627296-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND</heading>
<p id="p-0002" num="0001">1. Field of Disclosure</p>
<p id="p-0003" num="0002">This disclosure relates in general to the field of software testing, and in particular to unit and integration testing of source code.</p>
<p id="p-0004" num="0003">2. Description of the Related Art</p>
<p id="p-0005" num="0004">In computer programming, unit testing is a software verification and validation method in which a programmer tests individual units of source code for errors. The goal of unit testing is to isolate each part of a software program and show that the individual parts are functionally correct. A difficulty with unit testing arises when individual units of code are dependent on other units of code and parts of the system that are not within the control of the developer. For example, a unit of code may contain a command to call an object that accesses an external database in order to retrieve a text string. This object call is a dependency that relies on the results returned from the database. Thus, if there is an error during the unit test, the programmer does not know if the error is caused by the dependency (i.e. the database access) or the unit of source code being tested.</p>
<p id="p-0006" num="0005">To eliminate the effect of dependencies, software developers are encouraged to create mock objects. Mock objects are substituted in place of real dependencies, similar to how a car designer uses a crash test dummy to simulate the effect of vehicle impacts. The mock object simulates the behavior of a real dependency, and has the advantage of returning a known result and being much faster to execute than the real dependency.</p>
<p id="p-0007" num="0006">Although unit testing with mock objects is preferred, the problem with mock objects is that they are tedious to create. Creating a mock object with conventional techniques is essentially a manual process. The software developer must examine each line of the source code being tested in order to identify dependencies. The developer then translates these dependencies into lines of code that define a mock object. Due to the difficulty in creating a mock object, many software developers choose to skip the mocking step and are unable to take advantage of the speed and reliability associated with mock testing.</p>
<p id="p-0008" num="0007">Additionally, during the software development process, a developer may want to test a source code's dependencies on other pieces of source code. This type of test is known as an integration test. In contrast to unit testing, the goal of integration testing is to verify a piece of software code based on its interactions with other pieces of software code. Under conventional means, getting the benefits of unit testing and integration testing requires a developer to maintain two sets of test code. Alternatively, the developer can maintain one set of test code and manually edit the test code in order to switch between a unit test and integration test. These conventional methods require additional work on a developer's part, thus discouraging the developer from thoroughly testing the source code by using both a unit test and an integration test.</p>
<heading id="h-0002" level="1">SUMMARY</heading>
<p id="p-0009" num="0008">The above and other issues are addressed by a method, a non-transitory computer-readable storage medium, and system for testing program code. Embodiments of the method comprise capturing interactions with a method of an object that is described by the computer program code. From the captured interactions, mock code that creates a mock object is automatically generated. The mock object mimics the captured interactions. Test code, which has at least some of the computer program code and mock code, is executed to enable testing of the computer program code.</p>
<p id="p-0010" num="0009">Embodiments of the computer-readable storage medium store computer-executable instructions for performing the steps described above. Embodiments of the system further comprise a processor for executing the computer-executable instructions.</p>
<p id="p-0011" num="0010">The features and advantages described in this disclosure and in the following detailed description are not all-inclusive, and particularly, many additional features and advantages will be apparent to one of ordinary skill in the relevant art in view of the drawings, specification, and claims hereof. Moreover, it should be noted that the language used in the specification has been principally selected for readability and instructional purposes, and may not have been selected to delineate or circumscribe the inventive subject matter, resort to the claims being necessary to determine such inventive subject matter.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF DRAWINGS</heading>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 1</figref> is a high-level block diagram that illustrates a development system for unified unit and integration testing with automatic mock creation according to one embodiment.</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 2</figref> is a high-level block diagram illustrating a typical computer for use as a development system.</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 3</figref> is a high-level block diagram illustrating a detailed view of modules within the mock generation module according to one embodiment.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 4</figref> is a diagram illustrating the interaction between a unit of source code and a capture object according to one embodiment.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 5</figref> is a high-level block diagram illustrating a detailed view of modules within the unit/integration testing module according to one embodiment.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 6</figref> is a flowchart illustrating a method of generating mock code for performing unit testing of a computer program according to one embodiment.</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 7</figref> is a flowchart illustrating a method of testing a computer program according to one embodiment.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0019" num="0018">The Figures (FIGS.) and the following description describe certain embodiments by way of illustration only. One skilled in the art will readily recognize from the following description that alternative embodiments of the structures and methods illustrated herein may be employed without departing from the principles described herein. Reference will now be made in detail to several embodiments, examples of which are illustrated in the accompanying figures. It is noted that wherever practicable similar or like reference numbers may be used in the figures and may indicate similar or like functionality.</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 1</figref> is a high-level block diagram that illustrates a development system <b>110</b> for unified unit and integration testing with automatic mock creation according to one embodiment. The development system <b>110</b> is an electronic device that is used to develop software code. In one embodiment, the development system <b>110</b> is a conventional computer system executing, for example, a Microsoft Windows-compatible operating system (OS), Apple OS X, and/or a Linux distribution. The development system <b>110</b> can be any type of computer system, such as a laptop, desktop, workstation, or server. The development system <b>110</b> can also be another device having computer functionality, such as a personal digital assistant (PDA), mobile telephone, video game system, etc. The development system <b>110</b> can be attached to a network in order to communicate with other electronic devices.</p>
<p id="p-0021" num="0020">As shown, the development system <b>110</b> includes a mock generation module <b>120</b> and a unit/integration testing module <b>130</b>. The mock generation module <b>120</b> executes a unit of source code to capture its dependencies. The unit of source code can be stored locally in the development system <b>110</b> or remotely on another computer system attached to a network. As used herein, a unit of source code is a portion of source code that can be tested in order to verify its functionality. In most programming languages, a unit of source code can make calls to one or more objects. An object is a data structure that can include various data fields and methods together with logic describing interactions of the data fields and methods. When an object is called, it responds by returning data to the caller, changing the state of data fields within the object, or both. In one embodiment, an object can either be local or global. Local objects are passed into the unit of source code as parameters at the time of execution, and cannot be called unless they are explicitly passed in. Global objects, in contrast, can be called by the unit of source code at any point, regardless of whether the global objects are explicitly passed into the code.</p>
<p id="p-0022" num="0021">A unit of source code typically calls an object in order to accomplish particular tasks performed by that object (e.g. access a database, retrieve the current time, check for network errors, perform a complex calculation). In this circumstance, the object is referred to as a &#x201c;dependency&#x201d; of the source code because the source code is dependent upon the functionality of the called object. However, an object called by a unit of source code may be slow or return unpredictable results, thereby making it undesirable to use the actual, or &#x201c;real&#x201d; object in a unit test.</p>
<p id="p-0023" num="0022">The mock generation module <b>120</b> generates computer code for use with a &#x201c;mock&#x201d; object that can be used in place of a real object during a unit test. A mock object mimics the operation of and has the same interface as its corresponding real object. However, the mock object is much simpler than a real object because it simply receives calls and returns data according to a pre-defined behavior. Unlike a real object, the mock object does not perform any time-consuming calculations or access any external data sources. The behavior of a mock object is also predictable, returning the same data each time it is called.</p>
<p id="p-0024" num="0023">The unit/integration testing module <b>130</b> tests a unit of source code using either real objects or mock objects having code generated by the mock generation module <b>120</b>, depending upon how the testing module is configured. This testing is advantageous because it provides a programmer with the flexibility of switching between a unit test (i.e. testing with mock objects) and an integration test (i.e. testing with real objects) without having to duplicate any test code. The unit/integration testing module <b>130</b> also verifies the results of the test to determine if any errors occurred.</p>
<p id="p-0025" num="0024">Since the mock generation module <b>120</b> automatically generates the computer code used with the mock object, the burden on the programmer is decreased when performing unit testing. Since the unit/integration module <b>130</b> can quickly switch between a unit test and integration test without the duplication of test code, the burden on the programmer is further reduced. Thus, obstacles to performing unit testing are removed and programmers are more likely to perform unit tests of their work. As a result, the quality of the code produced by the programmers is increased.</p>
<p id="h-0005" num="0000">Computer Architecture</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 2</figref> is a high-level block diagram illustrating a typical computer <b>200</b> for use as the development system <b>110</b>. Illustrated are a processor <b>202</b> coupled to a chipset <b>204</b>. Also coupled to the chipset <b>204</b> are a memory <b>206</b>, a storage device <b>208</b>, a keyboard <b>210</b>, a graphics adapter <b>212</b>, a pointing device <b>214</b>, and a network adapter <b>216</b>. A display <b>218</b> is coupled to the graphics adapter <b>212</b>. In one embodiment, the functionality of the chipset <b>204</b> is provided by a memory controller hub <b>220</b> and an I/O controller hub <b>222</b>. In another embodiment, the memory <b>206</b> is coupled directly to the processor <b>202</b> instead of the chipset <b>204</b>.</p>
<p id="p-0027" num="0026">The storage device <b>208</b> is a non-transitory computer-readable storage medium, such as a hard drive, compact disk read-only memory (CD-ROM), DVD, or a solid-state memory device. The memory <b>206</b> holds instructions and data used by the processor <b>202</b>. The pointing device <b>214</b> is a mouse, track ball, or other type of pointing device, and is used in combination with the keyboard <b>210</b> to input data into the computer system <b>200</b>. The graphics adapter <b>212</b> displays images and other information on the display <b>218</b>. The network adapter <b>216</b> couples the computer <b>200</b> to the network <b>116</b>.</p>
<p id="p-0028" num="0027">As is known in the art, a computer <b>200</b> can have different and/or other components than those shown in <figref idref="DRAWINGS">FIG. 2</figref>. In addition, the computer <b>200</b> can lack certain illustrated components. In one embodiment, a computer <b>200</b> acting as the development system <b>110</b> is formed of multiple blade computers and lacks a keyboard <b>210</b>, pointing device <b>214</b>, graphics adapter <b>212</b>, and/or display <b>218</b>. Moreover, the storage device <b>208</b> can be local and/or remote from the computer <b>200</b> (such as embodied within a storage area network (SAN)).</p>
<p id="p-0029" num="0028">This description uses the term &#x201c;module&#x201d; to refer to computer program logic for providing a specified functionality. A module can be implemented in hardware, firmware, and/or software. A module is typically stored on a computer-readable storage medium such as the storage device <b>208</b>, loaded into the memory <b>206</b>, and executed by the processor <b>202</b>.</p>
<p id="h-0006" num="0000">Example Architectural Overview of the Mock Generation Module</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 3</figref> is a high-level block diagram illustrating a detailed view of modules within the mock generation module <b>120</b> according to one embodiment. Some embodiments of the mock generation module <b>120</b> have different and/or other modules than the ones described herein. Similarly, the functions can be distributed among the modules in accordance with other embodiments in a different manner than is described here. Likewise, the functions can be performed by other entities.</p>
<p id="p-0031" num="0030">For purposes of this discussion, assume that a programmer has developed a unit of code in a programming language that is similar to the PYTHON programming language that receives an identifier of a user and returns an integer indicating the number of characters in the user's real name. For example, the development code can be as follows:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0031">1 Int NumCharsInRealName(user x) {</li>
    <li id="ul0001-0002" num="0032">2 return len(x.GetRealName( ));</li>
    <li id="ul0001-0003" num="0033">3 }</li>
</ul>
</p>
<p id="p-0032" num="0034">In this sample development code, line 1 declares a function &#x201c;NumCharsInRealName&#x201d; that accepts a parameter &#x201c;x&#x201d; of type &#x201c;user.&#x201d; Line 2 indicates that the code calls the &#x201c;getrealname( )&#x201d; method of x, which returns the real name of user x. Further, line 2 indicates that the NumCharsInRealName function returns the result of a call of the &#x201c;Len&#x201d; (length) function having the real name of user x as a parameter. Thus, if user x is &#x201c;apicard,&#x201d; and this user's real name is &#x201c;Antoine Picard,&#x201d; the code will return the integer &#x201c;13&#x201d;&#x2014;the number of characters in the user's name when excluding the intermediate space.</p>
<p id="p-0033" num="0035">Prior to performing a unit test of this code, the programmer can include statements that invoke the functionality of the mock generation module <b>120</b> in order to generate code for use with a mock object that can be used in place of a real object during a unit test. An example of such testing code is as follows:
<ul id="ul0002" list-style="none">
    <li id="ul0002-0001" num="0036">1 Test_NumCharsInRealName( ) {</li>
    <li id="ul0002-0002" num="0037">2 User a=User(&#x201c;apicard&#x201d;);</li>
    <li id="ul0002-0003" num="0038">3 MoxRecorder m=MoxRecorder(a);</li>
    <li id="ul0002-0004" num="0039">4 Assert NumCharsInRealName(m)==13;</li>
    <li id="ul0002-0005" num="0040">5 m.Report( );</li>
    <li id="ul0002-0006" num="0041">6 m.Verify( );</li>
    <li id="ul0002-0007" num="0042">7 }</li>
</ul>
</p>
<p id="p-0034" num="0043">In the above sample testing code, line 2 includes code for creating an object &#x201c;a&#x201d; of type &#x201c;User&#x201d; with the string &#x201c;apicard.&#x201d; User object a is the real object that will be mocked during unit testing. Line 3 includes code for creating an object &#x201c;m&#x201d; of type &#x201c;MoxRecorder&#x201d; and assigns it the value of the MoxRecorder function run with user a as an input parameter. Line 4 includes code making an &#x201c;Assert&#x201d; statement that indicates whether the NumCharsInRealName function returns the integer &#x201c;13&#x201d; when called with MoxRecorder object m as a parameter. Line 5 includes code calling the &#x201c;Report( )&#x201d; method of object m, which generates the code for use with a mock object in unit testing. Line 6 includes code calling the &#x201c;Verify( )&#x201d; method of object m, which resets the Moxrecorder object m and includes other functionality that is utilized during unit testing.</p>
<p id="p-0035" num="0044">Turning now to <figref idref="DRAWINGS">FIG. 3</figref>, the mock generation module <b>120</b> itself includes modules for performing various functions. These modules include an object capture module <b>305</b>, a dependency capture module <b>310</b>, and a mock output module <b>315</b>. These modules <b>305</b>, <b>310</b>, <b>315</b> include functionality corresponding to the functionality invoked on the development system <b>110</b> when testing code, like that described above, is executed. The remainder of the discussion of <figref idref="DRAWINGS">FIG. 3</figref> relates the illustrated modules with the sample testing code.</p>
<p id="p-0036" num="0045">Line 3 of the testing code, MoxRecorder m=MoxRecorder(a), creates a MoxRecorder object m. An object of type MoxRecorder uses functionality supplied by the object capture module <b>305</b> to capture (i.e., record) underlying interactions for any methods called on the object. Said another way, the object capture module <b>305</b> includes functionality for capturing interactions performed on an object and a programmer invokes this functionality by writing code that creates and uses a MoxRecorder object.</p>
<p id="p-0037" num="0046">In one embodiment, the object capture module <b>305</b> captures interactions by &#x201c;wrapping&#x201d; a real object (e.g., user object &#x201c;a&#x201d;) with a capture object. The capture object simulates the operation of the wrapped real object by receiving calls from source code, passing the calls to the underlying real object, receiving data returned from the real object, and passing the data back to the caller. <figref idref="DRAWINGS">FIG. 4</figref> illustrates the interaction between a unit of source code <b>405</b> and a capture object <b>450</b>. The capture object <b>450</b> is created by wrapping the real object <b>410</b>. The capture object <b>450</b> is configured so that whenever the capture object is called <b>415</b> by the source code <b>405</b>, it passes the call to the underlying real object <b>410</b>. The real object <b>410</b> executes the call and returns data to the capture object <b>450</b>. The capture object <b>450</b> then forwards the returned data <b>420</b> to the calling source code <b>405</b>. Each of these interactions is captured by the object capture module <b>305</b>.</p>
<p id="p-0038" num="0047">Moreover, the object capture module <b>305</b> records the captured interactions. In one embodiment, each call involving the capture/real objects is recorded into an ordered list of recorded calls <b>455</b> with at least the following metadata: (1) the name of the called method, (2) the parameters passed to the called method, and (3) the data returned by the called method.</p>
<p id="p-0039" num="0048">For example, the sample testing code described above interacts with the MoxRecorder object m in line 4 where it uses the statement &#x201c;Assert NumCharsInRealName(m)==13.&#x201d; This statement calls the function NumCharsInRealName( ) as described in the sample development code, and passes it the parameter MoxRecorder object m. NumCharsInRealName( ) invokes the &#x201c;GetRealName&#x201d; method on object m, and this interaction is captured and recorded by the object capture module <b>305</b>. The object capture module <b>305</b> can record the interactions in a table like the following:</p>
<p id="p-0040" num="0049">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="63pt" align="left"/>
<colspec colname="2" colwidth="63pt" align="left"/>
<colspec colname="3" colwidth="70pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>Call</entry>
<entry>Parameter</entry>
<entry>Return Data</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>MoxRecorder</entry>
<entry>user(&#x201c;apicard&#x201d;)</entry>
<entry/>
</row>
<row>
<entry/>
<entry>x.GetRealName</entry>
<entry>( )</entry>
<entry>&#x201c;Antoine Picard&#x201d;</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0041" num="0050">Depending on the embodiment and the code, the object capture module <b>305</b> can capture and record interactions with one or more local and/or global objects. The technique for capturing and recording interactions with local objects is described above. For global objects, in one embodiment the programmer replaces allcalled methods of the global objects with stubs that invoke MoxRecorder to capture the interactions with the global objects and record the values returned by the methods. As a result, when development code is tested in a unit test, a mock is used for the global object method calls. In another embodiment, the programmer only replaces calls to specific methods of a global or local object with stubs that invoke Moxrecorder to capture the interactions with those methods.</p>
<p id="p-0042" num="0051">A wrapped object in the development code can create one or more other objects. Interactions with these other objects should also be tracked and recorded in order to support unit testing of the code. To this end, an embodiment of the mock generation module <b>120</b> includes a dependency capture module <b>310</b> for recursively wrapping and capturing interactions with these subsequently created objects.</p>
<p id="p-0043" num="0052">For example, assume that the &#x201c;NumCharsInRealName&#x201d; function in the sample development code described above is written as follows:
<ul id="ul0003" list-style="none">
    <li id="ul0003-0001" num="0053">1 Int NumCharsInRealName(user x) {</li>
    <li id="ul0003-0002" num="0054">2 RealName y=x.GetRealName( );</li>
    <li id="ul0003-0003" num="0055">3 return Len(y.firstname( )) +</li>
    <li id="ul0003-0004" num="0056">4 Len(y.middlename( )) +</li>
    <li id="ul0003-0005" num="0057">5 Len (y.lastname( ));</li>
    <li id="ul0003-0006" num="0058">6 }</li>
</ul>
</p>
<p id="p-0044" num="0059">In this second version of the NumCharsInRealName function, line 2 creates an object &#x201c;y&#x201d; of type &#x201c;RealName&#x201d; and assigns it the value returned by the &#x201c;GetRealName( )&#x201d; method of x. Then, lines 3-5 use the &#x201c;firstname( ),&#x201d; &#x201c;middlename( ),&#x201d; and &#x201c;lastname( )&#x201d; methods of object y to return the length of user x's real name. As a result, if the interactions with only user object x were tracked, the mock generation module <b>120</b> would miss the interactions involving the dependent RealName object y.</p>
<p id="p-0045" num="0060">The dependency capture module <b>310</b> detects dependent objects and identifies the dependent objects to the capture module <b>305</b>. In one embodiment, the dependency capture module <b>310</b> monitors the interactions captured by the object capture module <b>305</b> and detects when a dependent object is created. If such an object is created, the dependency capture module <b>310</b> invokes the object capture module <b>305</b> to capture interactions involving the dependent object. In this way, the dependency capture module <b>310</b> recursively identifies and tracks dependent objects.</p>
<p id="p-0046" num="0061">When the sample testing code described above is executed, the object capture <b>305</b> and dependency capture <b>310</b> modules collectively capture and record the interactions with the MoxRecorder objects and any dependent objects. A mock output module <b>315</b> analyzes the recorded interactions and automatically generates lines of code that represent a mock object, called &#x201c;mock code.&#x201d; For example, the mock output module <b>315</b> can analyze a table created by the object capture module <b>305</b> and generate the mock code based on the interactions described by the table.</p>
<p id="p-0047" num="0062">In one embodiment, mock output module <b>315</b> generates the mock code by translating each call captured by the capture module <b>315</b> into computer code. The computer code uses the mock functionality inherent in the programming language, in this case a language that is similar to PYTHON, to simulate the functionality of the mocked object. For example, the calls captured in the above-mentioned table can be automatically translated into the following lines of mock code:
<ul id="ul0004" list-style="none">
    <li id="ul0004-0001" num="0063">1 Mock_a=Mock(User(&#x201c;apicard&#x201d;));</li>
    <li id="ul0004-0002" num="0064">2 Mock_a.GetRealName( ) .andreturn(&#x201c;Antoine Picard&#x201d;);</li>
</ul>
</p>
<p id="p-0048" num="0065">In this code, line 1 creates a mock object called &#x201c;mock_a&#x201d; with the standard PYTHON library &#x201c;Mock&#x201d; command. Line 2 specifies that the GetRealName( ) method of the Mock_a object returns the string &#x201c;Antoine Picard&#x201d;. In more complex scenarios, such as those involving dependent objects that are recursively tracked, the mock output module <b>315</b> will create many such lines of code to create and define the behaviors of multiple mocked objects.</p>
<p id="p-0049" num="0066">The mock output module <b>315</b> outputs the generated code for display to a programmer. The mock output module <b>315</b> can also output the code for storage in the development system <b>110</b> and/or elsewhere. As described below, the mock code is used by the unit/integration testing module <b>130</b> to test the source code.</p>
<p id="h-0007" num="0000">Example Architectural Overview of the Unit/Integration Testing Module</p>
<p id="p-0050" num="0067"><figref idref="DRAWINGS">FIG. 5</figref> is a high-level block diagram illustrating a detailed view of modules within the unit/integration testing module <b>130</b> according to one embodiment. Some embodiments of the unit/integration testing module <b>130</b> have different and/or other modules than the ones described herein. Similarly, the functions can be distributed among the modules in accordance with other embodiments in a different manner than is described here. Likewise, the functions can be performed by other entities.</p>
<p id="p-0051" num="0068">Assume that the programmer is using the testing code described above and that the programmer has used the mock generation module <b>120</b> to generate the mock code. The programmer inserts the mock code into the testing code by, e.g., manually cutting and pasting the mock code into the testing code, and/or using an automated technique. The resulting testing code is as follows:
<ul id="ul0005" list-style="none">
    <li id="ul0005-0001" num="0069">1 Test_NumCharsInRealName( ) {</li>
    <li id="ul0005-0002" num="0070">2 User a=User(&#x201c;apicard&#x201d;);</li>
    <li id="ul0005-0003" num="0071">3 Mock_a=Mock(User(&#x201c;apicard&#x201d;));</li>
    <li id="ul0005-0004" num="0072">4 Mock_a.GetRealName( ) .andreturn(&#x201c;Antoine Picard&#x201d;);</li>
    <li id="ul0005-0005" num="0073">5 MoxRecorder m=MoxRecorder (a, mock_a);</li>
    <li id="ul0005-0006" num="0074">6 Assert NumCharsInRealName (m)==13;</li>
    <li id="ul0005-0007" num="0075">7 m.Verify( );</li>
    <li id="ul0005-0008" num="0076">8 }</li>
</ul>
</p>
<p id="p-0052" num="0077">In this second version of the testing code (the &#x201c;combined testing code&#x201d;), the mock code output by the mock output module <b>315</b> is inserted as lines 3-4. As discussed above, line 3 creates a mock object called &#x201c;mock_a&#x201d; and line 4 specifies that the GetRealName( ) method of the Mock_a object returns the string &#x201c;Antoine Picard&#x201d;. In addition, the parameters passed to the MoxRecorder function at line 5 are &#x201c;(a, mock.a)&#x201d; instead of just &#x201c;(a)&#x201d; as in the previous version.</p>
<p id="p-0053" num="0078">A test execution module <b>510</b> within the unit/integration testing module <b>130</b> executes a test of the development code using the combined testing code. In one embodiment, the test execution module <b>510</b> can selectively perform either a unit test (i.e. testing with mock objects) or an integration test (i.e. testing with real objects) on the development code. The programmer or another entity specifies the type of test to perform by setting a flag within the development system <b>110</b>. For example, a programming environment executing on the development system <b>110</b> can include the test execution module <b>510</b> and have a configuration setting that the programmer can use to specify the type of test. Similarly, the programmer can set a variable within the testing code that the test execution module <b>510</b> examines to determine the type of test to perform. This flexibility is beneficial because it allows a programmer to get the benefits of unit testing and integration testing without maintaining two sets of test code, thereby speeding up the software development process.</p>
<p id="p-0054" num="0079">In one embodiment, the test execution module <b>510</b> executes the MoxRecorder function differently depending upon the selected test type. If the programmer is performing a unit test, the output of the MoxRecorder function is generated using the mock object received as an input parameter. For example, referring to line 5 of the combined testing code, the test execution module <b>510</b> executes the MoxRecorder function using the &#x201c;mock_a&#x201d; input parameter, thereby causing the MoxRecorder object m to take the value of mock_a and the mock to be used when the NumCharsInRealName function is called in line 6. On the other hand, if the programmer is performing an integration test, the output of the MoxRecorder function is generated using the real object received as the input parameter. For example, referring again to line 5 of the combined testing code, the test execution module <b>510</b> executes the MoxRecorder function using the &#x201c;a&#x201d; input parameter, thereby causing the MoxRecorder object m to take the value of the real user object a and a's real methods to be performed when the NumCharsInRealName function is called in line 6. The functionality for selecting among the input parameters can be integrated into the MoxRecorder function.</p>
<p id="p-0055" num="0080">A test verification module <b>515</b> verifies the results of the unit or integration test. In one embodiment, the test verification module <b>515</b> uses the result of the &#x201c;Assert&#x201d; statement to determine whether the test was successful. The statement &#x201c;Assert NumCharsInRealName(m)==13&#x201d; will raise an error if the &#x201c;NumCharsInRealName( )&#x201d; function does not return the expected value of &#x201c;13.&#x201d; In such a case, the test verification module <b>515</b> can report the error to the programmer by, e.g., logging the error in an error report, displaying a message on a display of the development system <b>110</b>, or performing a similar action.</p>
<p id="p-0056" num="0081">In addition, an embodiment of the test verification module <b>515</b> determines if each method defined for each mock object was called by the testing code. This determination is made by recording interactions (i.e. calls) between development code and mock objects when the test execution module <b>510</b> executes the code. The test verification module <b>515</b> then compares the recorded interactions against the mock objects. If each method in a mock object was not called, then this indicates that the test failed because the code did not function as expected. For example, the code being tested may have changed since the mock objects were last generated. The statement &#x201c;m.verify ( )&#x201d; will raise an error if each method of a mock object was not called, as expected, and report the error to the programmer.</p>
<p id="h-0008" num="0000">Overview of Methodology</p>
<p id="p-0057" num="0082"><figref idref="DRAWINGS">FIG. 6</figref> is a flowchart illustrating a method of generating mock code for performing unit testing of a computer program according to one embodiment. In one embodiment, the method of <figref idref="DRAWINGS">FIG. 6</figref> is performed by the mock generation module <b>120</b>, although some or all of the method can be performed by other modules in other embodiments. In addition, other embodiments can perform the steps of the method in different orders and can include different and/or additional steps.</p>
<p id="p-0058" num="0083">The mock generation module <b>120</b> executes <b>605</b> testing code that uses the MoxRecorder function wrap real objects with capture objects. As the code executes, the mock generation module <b>120</b> captures <b>610</b> interactions with the capture objects in the code. The mock generation module <b>120</b> also captures <b>615</b> interactions involving dependent objects that are created by the wrapped real objects. From the captured interactions, the mock generation module <b>120</b> automatically generates <b>620</b> lines of code for mock objects. The mock generation module then outputs <b>625</b> the code, for example, in a display that is shown to a programmer or in a file stored by the development system <b>110</b>.</p>
<p id="p-0059" num="0084"><figref idref="DRAWINGS">FIG. 7</figref> is a flowchart illustrating a method of testing a computer program according to one embodiment. In one embodiment, the method of <figref idref="DRAWINGS">FIG. 7</figref> is performed by the unit/integration testing module <b>130</b>, although some or all of the method can be performed by other modules in other embodiments. In addition, other embodiments can perform the steps of the method in different orders and can include different and/or additional steps.</p>
<p id="p-0060" num="0085">The unit/integration module <b>130</b> executes <b>705</b> combined testing code. The test execution module <b>130</b> checks <b>710</b> the setting of a flag to determine the type of test to perform. If the flag is set to perform a unit test, the unit/integration module <b>130</b> executes <b>715</b> the combined testing code with mock objects. That is, the MoxRecorder functions in the code return mock objects so that the remainder of the code uses the mock objects to test the development code. If the flag is set to perform an integration test, the unit/integration module <b>130</b> executes <b>720</b> the combined testing code with real objects to test a development code's dependencies. Thus, the MoxRecorder functions in the code return real objects so that the remainder of the code uses the real objects when testing the development code and the objects' real dependencies are called. The unit/integration module <b>130</b> then verifies <b>725</b> the test results and reports <b>730</b> the verification results.</p>
<p id="p-0061" num="0086">The above description is included to illustrate the operation of certain embodiments and is not meant to limit the scope of the invention. The scope of the invention is to be limited only by the following claims. From the above discussion, many variations will be apparent to one skilled in the relevant art that would yet be encompassed by the spirit and scope of the invention.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>The invention claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method of testing a unit of computer program code that has a dependency on an object described by the computer program code, comprising:
<claim-text>generating a capture object based on the object described by the computer program code, a method of the capture object corresponding to a method of the object described by the computer program code;</claim-text>
<claim-text>calling the method of the capture object, the capture object interacting with the method of the object described by the computer program code responsive the method of the capture object being called;</claim-text>
<claim-text>capturing interactions with the method of the object described by the computer program code as the capture object interacts with the method of the object described by the computer program code;</claim-text>
<claim-text>responsive to the captured interactions, automatically generating mock code for creating a mock object that mimics the captured interactions; and</claim-text>
<claim-text>executing testing code having at least some the computer program code and the mock code, wherein executing the testing code comprises:
<claim-text>determining whether to perform a unit test or an integration test;</claim-text>
<claim-text>responsive to determining to perform the unit test, using the mock code to mimic the captured interactions during execution of the testing code; and</claim-text>
<claim-text>responsive to determining to perform the integration test, using the object described by the computer program code to perform interactions with the method of the object described by the computer program code during execution of the testing code.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein capturing interactions with the method comprises capturing one or more of:
<claim-text>a name of the method;</claim-text>
<claim-text>parameters passed to the method; and</claim-text>
<claim-text>data returned by the method.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>detecting creation of a dependent object that is created based on data returned by the method of the capture object; and</claim-text>
<claim-text>responsive to detecting creation of a dependent object, capturing interactions with a method of the dependent object;</claim-text>
<claim-text>wherein the automatically generated mock code comprises code for creating a mock object that mimics the captured interactions with the dependent object.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>identifying a plurality of parameters for a function contained within the testing code, the plurality of parameters including a real object parameter referencing a real object defined by the testing code and a mock object parameter referencing a mock object defined by the testing code; and</claim-text>
<claim-text>selecting among the plurality of parameters responsive to determining whether to perform a unit test or an integration test on the testing code;</claim-text>
<claim-text>wherein the object referenced by the selected parameter is used during execution of the testing code for the interactions.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein capturing interactions with a method of the object comprises capturing interactions with a method of one of: a local object or a global object.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. A non-transitory computer-readable medium storing executable computer instructions for testing a unit of computer program code that has a dependency on an object described by the computer program code, the computer instructions comprising instructions for:
<claim-text>generating a capture object based on the object described by the computer program code, a method of the capture object corresponding to a method of the object described by the computer program code;</claim-text>
<claim-text>calling the method of the capture object, the capture object interacting with the method of the object described by the computer program code responsive the method of the capture object being called;</claim-text>
<claim-text>capturing interactions with the method of the object described by the computer program code as the capture object interacts with the method of the object described by the computer program code;</claim-text>
<claim-text>responsive to the captured interactions, automatically generating mock code for creating a mock object that mimics the captured interactions; and</claim-text>
<claim-text>executing testing code having at least some the computer program code and the mock code, wherein executing the testing code comprises:
<claim-text>determining whether to perform a unit test or an integration test;</claim-text>
<claim-text>responsive to determining to perform the unit test, using the mock code to mimic the captured interactions during execution of the testing code; and</claim-text>
<claim-text>responsive to determining to perform the integration test, using the object described by the computer program code to perform interactions with the method of the object described by the computer program code during execution of the testing code.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The computer-readable storage medium of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein capturing interactions with the method comprises capturing one or more of:
<claim-text>a name of the method;</claim-text>
<claim-text>parameters passed to the method; and</claim-text>
<claim-text>data returned by the method.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The computer-readable storage medium of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the instructions further comprise instructions for:
<claim-text>detecting creation of a dependent object that is created based on data returned by the method of the capture object; and</claim-text>
<claim-text>responsive to detecting creation of a dependent object, capturing interactions with a method of the dependent object;</claim-text>
<claim-text>wherein the automatically generated mock code comprises code for creating a mock object that mimics the captured interactions with the dependent object.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The computer-readable storage medium of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the instructions further comprise instructions for:
<claim-text>identifying a plurality of parameters for a function contained within the testing code, the plurality of parameters including a real object parameter referencing a real object defined by the testing code and a mock object parameter referencing a mock object defined by the testing code; and</claim-text>
<claim-text>selecting among the plurality of parameters responsive to determining whether to perform a unit test or an integration test on the testing code;</claim-text>
<claim-text>wherein the object referenced by the selected parameter is used during execution of the testing code for the interactions.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The computer-readable storage medium of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein capturing interactions with a method of the object comprises capturing interactions with a method of one of: a local object or a global object.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. A system for testing a unit of computer program code that has a dependency on an object described by the computer program code, the system comprising:
<claim-text>a non-transitory computer-readable storage medium storing executable computer program instructions for:
<claim-text>generating a capture object based on the object described by the computer program code, a method of the capture object corresponding to a method of the object described by the computer program code;</claim-text>
<claim-text>calling the method of the capture object, the capture object interacting with the method of the object described by the computer program code responsive the method of the capture object being called;</claim-text>
<claim-text>capturing interactions with the method of the object described by the computer program code as the capture object interacts with the method of the object described by the computer program code;</claim-text>
<claim-text>responsive to the captured interactions, automatically generating mock code for creating a mock object that mimics the captured interactions; and</claim-text>
<claim-text>executing testing code having at least some the computer program code and the mock code, wherein executing the testing code comprises:
<claim-text>determining whether to perform a unit test or an integration test;</claim-text>
<claim-text>responsive to determining to perform the unit test, using the mock code to mimic the captured interactions during execution of the testing code; and</claim-text>
<claim-text>responsive to determining to perform the integration test, using the object described by the computer program code to perform interactions with the method of the object described by the computer program code during execution of the testing code; and</claim-text>
</claim-text>
</claim-text>
<claim-text>a processor for executing the computer program instructions.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein capturing interactions with the method comprises capturing one or more of:
<claim-text>a name of the method;</claim-text>
<claim-text>parameters passed to the method; and</claim-text>
<claim-text>data returned by the method.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the instructions further comprise instructions for:
<claim-text>detecting creation of a dependent object that is created based on data returned by the method of the capture object; and</claim-text>
<claim-text>responsive to detecting creation of a dependent object, capturing interactions with a method of the dependent object;</claim-text>
<claim-text>wherein the automatically generated mock code comprises code for creating a mock object that mimics the captured interactions with the dependent object.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the instructions further comprise instructions for:
<claim-text>identifying a plurality of parameters for a function contained within the testing code, the plurality of parameters including a real object parameter referencing a real object defined by the testing code and a mock object parameter referencing a mock object defined by the testing code; and</claim-text>
<claim-text>selecting among the plurality of parameters responsive to determining whether to perform a unit test or an integration test on the testing code;</claim-text>
<claim-text>wherein the object referenced by the selected parameter is used during execution of the testing code for the interactions.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
