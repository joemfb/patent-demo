<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08626716-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08626716</doc-number>
<kind>B1</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10820969</doc-number>
<date>20040408</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<us-term-extension>2057</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>7</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>00</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>707646</main-classification>
<further-classification>707640</further-classification>
<further-classification>707655</further-classification>
</classification-national>
<invention-title id="d2e53">Service broker enhancements</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5734887</doc-number>
<kind>A</kind>
<name>Kingberg et al.</name>
<date>19980300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  4</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5813009</doc-number>
<kind>A</kind>
<name>Johnson et al.</name>
<date>19980900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707100</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6484173</doc-number>
<kind>B1</kind>
<name>O'Hare et al.</name>
<date>20021100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  9</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6505200</doc-number>
<kind>B1</kind>
<name>Ims et al.</name>
<date>20030100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>6625602</doc-number>
<kind>B1</kind>
<name>Meredith et al.</name>
<date>20030900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  8</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>6691115</doc-number>
<kind>B2</kind>
<name>Mosher et al.</name>
<date>20040200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707 10</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>6826560</doc-number>
<kind>B1</kind>
<name>Leymann et al.</name>
<date>20041100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  3</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>7177866</doc-number>
<kind>B2</kind>
<name>Holenstein et al.</name>
<date>20070200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>7624376</doc-number>
<kind>B1</kind>
<name>Katzer et al.</name>
<date>20091100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>8027922</doc-number>
<kind>B2</kind>
<name>Lee</name>
<date>20110900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2002/0152278</doc-number>
<kind>A1</kind>
<name>Pontenzone et al.</name>
<date>20021000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2004/0216107</doc-number>
<kind>A1</kind>
<name>Somogyi et al.</name>
<date>20041000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718100</main-classification></classification-national>
</us-citation>
<us-citation>
<nplcit num="00013">
<othercit>Lee, Wing K., <i>Architecture and Method for Real-Time Asynchronous Data Warehousing with Transactional Integrity</i>, Filing Date&#x2014;Apr. 8, 2004, U.S. Appl. No. 10/820,619, Specification (47 pgs.) and Drawings (8 sheets).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00014">
<othercit>Lee, Wing, <i>Integration Infrastructure</i>, Filing Date&#x2014;Jul. 14, 2003, U.S. Appl. No. 10/619,296, Specification (32 pgs.) and Drawings (6 sheets).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00015">
<othercit>Office Action dated Jan. 4, 2007 (9 pages), U.S. Appl. No. 10/820,619, filed Apr. 8, 2004.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00016">
<othercit>Final Office Action dated Jun. 4, 2007 (8 pages), U.S. Appl. No. 10/820,619, filed Apr. 8, 2004.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00017">
<othercit>Advisory Action dated Aug. 13, 2007 (4 pages), U.S. Appl. No. 10/820,619, filed Apr. 8, 2004.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00018">
<othercit>Office Action dated Nov. 26, 2007 (9 pages), U.S. Appl. No. 10/820,619, filed Apr. 8, 2004.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00019">
<othercit>Final Office Action dated Jun. 13, 2008 (12 pages), U.S. Appl. No. 10/820,619, filed Apr. 8, 2004.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00020">
<othercit>Advisory Action dated Aug. 27, 2008 (3 pages), U.S. Appl. No. 10/820,619, filed Apr. 8, 2004.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00021">
<othercit>Office Action dated Dec. 2, 2008 (11 pages), U.S. Appl. No. 10/820,619, filed Apr. 8, 2004.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00022">
<othercit>Katzer, Robin D., et al., Patent Application entitled, &#x201c;Integration of COTS Software Data Stores Into Integrated Data Access Layer,&#x201d; filed Apr. 8, 2004, U.S. Appl. No. 10/820,539.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00023">
<othercit>Examiner's Answer dated May 26, 2010 (17 pages), U.S. Appl. No. 10/820,619, filed Apr. 8, 2004.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00024">
<othercit>Final Office Action dated Jun. 12, 2009, 15 pages, U.S. Appl. No. 10/820,619, filed Apr. 8, 2004.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00025">
<othercit>Advisory Action dated Aug. 25, 2009, 3 pages, U.S. Appl. No. 10/820,619, filed Apr. 8, 2004.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>15</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>718100</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707  3</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707 10</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707100</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>8</number-of-drawing-sheets>
<number-of-figures>8</number-of-figures>
</figures>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Katzer</last-name>
<first-name>Robin D.</first-name>
<address>
<city>Olathe</city>
<state>KS</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Lee</last-name>
<first-name>Wing K.</first-name>
<address>
<city>Overland Park</city>
<state>KS</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Katzer</last-name>
<first-name>Robin D.</first-name>
<address>
<city>Olathe</city>
<state>KS</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Lee</last-name>
<first-name>Wing K.</first-name>
<address>
<city>Overland Park</city>
<state>KS</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Sprint Communications Company L.P.</orgname>
<role>02</role>
<address>
<city>Overland Park</city>
<state>KS</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Kim</last-name>
<first-name>Paul</first-name>
<department>2169</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A data access layer operable to manage data requests from one or more software applications is provided. The data access layer includes a query processor, a metadata repository, a transaction data store, and an exception handler. The query processor manages transaction processing of data requests between applications, such as commercial-off-the-shelf software applications, and data stores. The metadata repository maintains a logical data model related to the data to provide instructions regarding handling the data requests from the application. The transaction data store maintains transaction information. A data warehouse may be updated along with the data stores by publication and subscription of data updates. When an error related to processing the one of the data requests is detected, the exception handler uses the transaction information to return any of the data to its previous state using compensating transactions.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="167.22mm" wi="230.38mm" file="US08626716-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="219.20mm" wi="184.66mm" orientation="landscape" file="US08626716-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="240.45mm" wi="180.09mm" orientation="landscape" file="US08626716-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="225.47mm" wi="179.92mm" orientation="landscape" file="US08626716-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="225.30mm" wi="187.71mm" orientation="landscape" file="US08626716-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="208.79mm" wi="181.78mm" orientation="landscape" file="US08626716-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="205.99mm" wi="184.91mm" orientation="landscape" file="US08626716-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="242.32mm" wi="185.59mm" orientation="landscape" file="US08626716-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="239.61mm" wi="192.53mm" orientation="landscape" file="US08626716-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">This application contains related subject-matter to U.S. patent application Ser. No. 10/619,296 filed Jul. 14, 2003 and entitled &#x201c;Integration Infrastructure&#x201d;, and to U.S. patent application Ser. No. 10/820,619 filed on even data herewith for &#x201c;Architecture and Method for Real-time Asynchronous Data Warehousing with Transactional Integrity&#x201d;.</p>
<heading id="h-0002" level="1">STATEMENT REGARDING FEDERALLY SPONSORED RESEARCH OR DEVELOPMENT</heading>
<p id="p-0003" num="0002">Not applicable.</p>
<heading id="h-0003" level="1">REFERENCE TO A MICROFICHE APPENDIX</heading>
<p id="p-0004" num="0003">Not applicable.</p>
<heading id="h-0004" level="1">FIELD OF THE INVENTION</heading>
<p id="p-0005" num="0004">The present invention relates to the transfer of data among computer-based data storage systems. More particularly, embodiments of the present invention provide for the management of data transactions with commercial, off-the-shelf data stores and for the updating of data in data warehouses.</p>
<heading id="h-0005" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0006" num="0005">When multi-step data transfer transactions take place among computing systems, errors can occur at any step in a transaction. When an error does occur in a step, it is often desirable to reverse any data changes that were made in that step and in previous steps. Many commercial, off-the-shelf (COTS) applications do not have internal mechanisms that provide for transaction processing for the data stores. That is, there is typically no automated method for rolling back a change that has been made to the data in a COTS application. As used herein, the term &#x201c;data store&#x201d; can refer to various computer-based storage systems, protocols, and applications such as relational databases, directories, and spreadsheets.</p>
<p id="p-0007" num="0006">Transactions with the data stores used in an enterprise's day-to-day operations are sometimes limited to the updating of critical data. It is typically undesirable to interrupt these critical updates with routine requests for the retrieval of data. Such queries can instead be made to another type of data storage system known as a data warehouse. Data warehouses typically contain copies of the data contained in multiple data stores. Copies of all of the data in the operational data stores are typically sent to a data warehouse in a periodic, batch process. Routine queries can then be made to the static data in the data warehouse and the operational data stores can be left free for more critical activities. However, due to the batch nature of the copying of data from the operational data stores to the data warehouses, the data warehouses may not always contain the most current version of the data in the data stores.</p>
<p id="p-0008" num="0007">As further background, messaging has emerged as a popular form of asynchronous communication between heterogeneous computing systems and applications. Several middleware and enterprise architecture tool vendors offer messaging solutions based on proprietary technology that can converge middleware and application services by combining application servers with messaging and business process management solutions. Other trends include end-to-end integration across enterprises and the emergence of new web-based service standards such as XML, SOAP, and UDDI. In addition, JMS provides a standard interface for incorporating messaging within Java applications. It acts as a wrapper around the messaging technology of other vendors.</p>
<p id="p-0009" num="0008">Several types of topology can support messaging. These include publish/subscribe, point-to-point, hub and spoke, bus, and distributed hub. Publish/subscribe messaging is organized around topics. A publisher sends a message to a topic and any interested subscriber can receive the message from the topic. Publish/subscribe messaging is typically used when multiple subscribers might be interested in the same message. It is appropriate for notification messages for which no response is required upon consumption. It is also useful for enterprise-level messages such as account creation, account termination, and subscription suspension. For example, a message server could publish an &#x201c;account created&#x201d; event after an account has been created and subscribers could consume the message.</p>
<p id="p-0010" num="0009">Point-to-point messaging is based on message queues. A producer sends a message to a specified queue and a consumer receives messages from the queue. Multiple senders and receivers are possible for a queue but an individual message can be delivered to only one receiver. Point-to-point messaging is typically used when only one consumer exists and the message is targeted for a known application. It is also useful when successful consumption by the target system is a requirement since messages stay in the queue until the receiver picks them up. As an example, point-to-point messaging would be appropriate within a telecommunications company when a message to reserve a mobile telephone number is transmitted. Such a message would typically be transmitted to only one consumer.</p>
<p id="p-0011" num="0010">In hub and spoke messaging, all applications are connected to a central message server. The message server is responsible for routing, authentication, access control, and transformation between data types. An application can act as a publisher and the message server can act as a subscriber or the message server can act as a publisher and an application can act as a subscriber. Hub and spoke messaging is typically used when greater control is required outside the applications. For example, because of workflow and timing issues, business process integration is typically tied to a message hub. Hub and spoke messaging is also used when there is a need to keep client applications simple. An intelligent message hub allows the use of simpler clients such as JMS APIs. Since hub and spoke messaging is centralized, it is typically implemented in a clustered environment for fault tolerance. A drawback of hub and spoke messaging is that the message server can become a bottleneck for messages between applications.</p>
<p id="p-0012" num="0011">Under bus architecture messaging, applications publish and subscribe to messages on a bus. Any application can be a publisher or subscriber. Integration logic and intelligence is distributed in application adapters that handle routing and data transformation. Intelligence is thereby implemented in multiple locations. Messaging over a bus is useful for simple message sharing and broadcasting where complex rules, transformations, and workflows are not required. It is particularly suitable for applications that use the same data representation. It is possible to connect a message server/broker to a bus to centralize processing and rules.</p>
<p id="p-0013" num="0012">Another messaging approach is the deployment of a distributed hub architecture. In this approach, multiple hubs can be present for different domains or organizations. Each hub could have its own localized rules and use a different messaging vendor or technology. Global rules could be propagated among the hubs. An architecture such as this can alleviate performance bottlenecks.</p>
<p id="p-0014" num="0013">When applications that use disparate data formats need to communicate with one another, a transformation from one format to the other typically occurs. Two models for accomplishing a data transformation are distributed transformation and centralized transformation. In the distributed model, an adapter is present between each application and a common message server. The adapters can transform data between an application-specific format and a common format. When an application publishes a message it sends the message to its adapter. The adapter transforms the message from the application's native data format to the common data format and sends the message to the message server. When another application wishes to subscribe to the message, that application's adapter receives the message from the message server in the common data format. The adapter then transforms the message into the native data format of the second application and sends the message to the second application. A well-defined, stable protocol such as XML is preferable for the common data format. Messaging systems that use the publish/subscribe protocol are good candidates for this approach.</p>
<p id="p-0015" num="0014">In the centralized transformation model, all data transformation is done in a central location. A first application that wishes to send a message to a second application can publish the message in its native format. The message is then sent to a centralized message server where a transformation takes place between the data format of the first application and the data format of the second application. The second application can then receive the message in its native data format. The centralized transformation model thus uses a pair-wise mapping approach between the source and destination systems. This approach is more applicable than the distributed transformation model to communication between commercial, off-the-shelf packages. Centralized, pair-wise transformation is also appropriate for systems that use point-to-point communication and for non-enterprise events such as the transfer of data that is specific to only a few applications.</p>
<p id="p-0016" num="0015">Two types of messaging can be described, data messaging and notification messaging. In data messaging, all of the data that one application wishes to transfer to another application is packaged in a single published event. The sending application publishes the data to a message server and the message server transfers the data to the receiving application when the receiving application subscribes to the published event. The receiving application receives all of the relevant data as part of the message; it does not need to perform any extra queries. Data messaging places a heavy load on the message bus. This type of messaging is suitable for communication between commercial, off-the-shelf applications since all the data to be transferred between two such applications typically must be contained within a single published event. Data messaging is also appropriate for communication across domains within an enterprise.</p>
<p id="p-0017" num="0016">In notification messaging, an application sends its data to an information broker which places the data in a data store. The application then publishes a notification message to a message server informing a receiving application that the data is available. Upon receiving the message from the message server, the receiving application can query the information broker which then retrieves the data from the data store and transfers it to the receiving application. Since the notification message that is published from the sending application to the message broker contains only a small amount of data, a lighter load is placed on the message bus compared to data messaging. Notification messaging is appropriate for distribution of data to custom-developed applications since these applications can be modified as needed to make queries to the information broker for the desired data.</p>
<p id="p-0018" num="0017">The queues or channels through which applications and a message server communicate can be application-specific or shared. In the application-specific queue architecture, a separate request and reply queue is present for each application. An application always places its messages on and receives its messages from the same queue. This architecture promotes easy identification of the source of a message and allows the message server to control when applications receive messages. Application-specific queues are useful in the hub-and-spoke and point-to-point messaging systems.</p>
<p id="p-0019" num="0018">In the shared queue architecture, queues and messages are shared between multiple applications. This allows multicasting of messages to multiple applications. Queues can be grouped by functions or domains such as account information, profile information, security information, or services information. This promotes the implementation of common processes but can require that filtering be implemented in each application. Shared queue architecture is appropriate for the publish/subscribe and bus messaging systems and other situations where the timing of event consumption is not an issue.</p>
<p id="p-0020" num="0019">Numerous criteria can be used in the selection of a messaging technology. One factor is the level of support for multiple communication paradigms such as publish/subscribe, point-to-point, hub and spoke, and bus-based topology. Another factor is quality of service issues such as guaranteed delivery of messages and priority of messages. The level of security support, including items such as Secure Socket Layer, authorization, authentication, and firewalls, can also be taken into consideration. Massive scalability and high throughput without appreciable performance degradation are also desirable. Another factor is the use of a standards-based implementation such as Java or XML rather than reliance on product-specific knowledge. Connectivity to other messaging systems such as JMS and Tuxedo is also desirable. Coexistence with an application server, while not typically required, is often desirable.</p>
<p id="p-0021" num="0020">Messaging implementations often fail due to poor implementation of the messaging tool as opposed to the inadequacy of the tool itself. An enterprise architecture group can provide guidance on key areas as part of the architecture definition for event-based messaging. For example, the enterprise architecture group could assist in choosing among the various messaging models. Whether a common enterprise model will be used for event specification as opposed to application-specific event specification can also be decided. A decision can be made on whether to use centralized or distributed data transformation. Guidelines can be established for queue architecture such as whether there will be a single input and a single output queue per application, whether there will be shared queues, and whether multiple messages or business events can be placed on the same queue or if a separate queue will be used for each business event. It can also be decided whether JMS wrapping will be used for messaging technology and whether a combination of event-based messaging and an information service layer will be used for complete data and transaction management.</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 1</figref> depicts an enterprise architecture in which front-end clients are integrated with back-end systems through an Enterprise Integration (EI) layer. The front-end clients, such as Premiere <b>110</b>, IVR <b>120</b>, CTI <b>130</b>, and SPCS <b>140</b>, can use the EI layer <b>100</b> to access back-end systems where data is hidden from the client applications. The EI layer <b>100</b> provides access to data located in two types of stores, back-end systems such as P2K <b>150</b>, NMS <b>160</b>, and Renaissance <b>170</b>, and an integrated database of operational data that can be referred to as the Operational Data Store (ODS) <b>180</b>. The ODS <b>180</b> can be largely replicated from other back-office applications but can also serve as the System of Record for some data. The EI layer <b>100</b> can access the appropriate data store using system-specific protocols such as SQL, CORBA <b>155</b>, MQ <b>165</b>, or RMI <b>175</b>. Front-end applications can use IBM's asynchronous MQSeries messaging <b>185</b> to interact with the EI layer <b>100</b>. A queue can be set up for each function or business transaction and multiple front-end applications can use the same queue when calling the same business transaction. The EI layer <b>100</b> can support create, read, update, and delete (CRUD) functions, particularly the translation of back-end Application Programming Interface (API) calls.</p>
<p id="p-0023" num="0022">The EI layer <b>100</b> can be implemented as a set of C++ programs called Business Logic Modules or BLMs, each of which provides a separate transaction. Each BLM can read messages from and write messages to an individual queue. Transformation logic and source data rules can be hard-coded in the BLMs. Each BLM that requires access to a particular back-end system can contain API logic to communicate with that system. A reusable framework for logging, exception management, and connection management could be present within the BLMs.</p>
<p id="p-0024" num="0023">An enterprise integration architecture such as this has several limitations. First, there may be no infrastructure support for a business event notification mechanism such as publish/subscribe messaging if communication between front-end applications and the EI layer is done through point-to-point messaging or if communication with back-end systems is done with APIs or with MQSeries. There may be no adapters or connectors to isolate the enterprise from application-specific requirements and there may be no transformation tools for translating an enterprise-specific data format into application-specific formats. If data transformation is hard coded, changes to data mapping can be expensive. Also, since client applications may be required to use a message-oriented protocol for data access, development complexity and a performance bottleneck can result. In addition, no rules repository may exist to define System of Record rules based on subject area. This means that the reorganization of data could lead to code changes. Another limitation may be the use of fixed-length field structures as opposed to self-describing message formats such as XML. Such structures require that code changes be made as new data elements are introduced. A lack of support for transaction management could be another limitation. There may also be no use of metadata. Other limitations could include an architecture that is not component-based, an inadequate object model, an infrastructure that is unable to achieve a desired uptime and response time, and a reduced speed in deploying new interfaces because of the lack of appropriate tools and technologies within the integration layer. These limitations can lead to difficulty in making changes, an inadequate reuse of business-related services, a higher cost of maintenance and debugging, a longer time to market for new capabilities and changes, and the necessity for increased testing due to the lack of isolation of functionality.</p>
<p id="p-0025" num="0024">Another limitation is that development of complex client applications may be necessary in order for clients to access back-end data using MQSeries messaging via the EI layer. For example, the use of asynchronous messaging for synchronous data may be required; synchronous methods may not be available to access back-office data and services. The use of MQSeries messaging via the EI layer could also entail the use inflexible message formats that may not shield applications from a ripple effect generated by changes to other systems. A degradation of performance could also result. Another issue is the lack of transmission management in the integration layer. This can result in data being out of synchronization.</p>
<p id="p-0026" num="0025">Another limitation is that business process steps might be hard-coded in the applications in multiple systems. The same processing step may be duplicated in multiple systems. Modifications to the business processes can require coordinated changes to multiple applications, typically entailing costly code changes. Encoding and changing processes in multiple applications in a timely and cost-effective manner can be difficult and the limited reuse of code lends itself to custom development. Thus, the embedding of business process steps in multiple systems can hinder the ability to roll out new products and services and to make changes to existing ones. For a process requiring multi-step interaction with a back-end application, the steps typically must be encoded in the client and hence may be difficult to modify. Also, there may be no end-to-end visibility of business processes, no tracking capability, and no ability to optimize processes and gain operational efficiency.</p>
<p id="p-0027" num="0026">Various point-to-point interfaces may exist for key business transactions that are not brokered. These interfaces would bypass the EI layer and directly perform CRUD functions in the target system. Since each target system typically has its own API set, each application that needs to communicate with a particular target system typically needs its own code developed specifically for that target. Thus, the point-to-point interfaces create a tight coupling between applications that can be costly to change. Also, business transactions performed across point-to-point interfaces such as these are not visible to other applications. Applications requiring knowledge of these transactions typically must use data replication to make assumptions about the transactions.</p>
<p id="p-0028" num="0027">Replication processes can introduce data integrity problems that cause decreased times to failure, increased times to repair, and inflated costs due to rework and data inconsistencies. Replication lag times can cause stale data that can lead to poor customer experience and potential loss of revenue. As replication of data progresses, syntactic and semantic errors can increase with increased distance from the source of the data. Replication processes consume additional resources such as personnel, hardware, and software with each replication. Integration of replication and batch processes is typically point-to-point and based on the structure of the underlying data models. This can cause tight coupling and inflexibility between systems and create a potential bottleneck as the volume of data grows with a rapidly increasing subscriber base. Also, numerous replication logic rules within the target applications may need to be redeveloped so that they can deduce business events from replicated data.</p>
<p id="p-0029" num="0028">In an enterprise integration architecture such as that just described, each front-office application would typically need to be aware of the locations of data and services in the enterprise and would typically need to use the access mechanism supported by the back-office application to which it is connected. Each application would typically need to understand the format and structure of the data in the back-office system and map it to its own internal representation. Reorganization or relocation of data and services could lead to costly and time-consuming changes to multiple applications.</p>
<heading id="h-0006" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0030" num="0029">The present disclosure provides a data access layer operable to manage data requests from one or more commercial-off-the-shelf software applications. The data access layer includes a query processor, a metadata repository, a transaction database, and an exception handler. The query processor manages transaction processing of data requests between commercial-off-the-shelf software applications and a plurality of data stores. The metadata repository maintains a logical data model related to the data and uses the logical data model to instruct the query processor regarding handling of the data requests from the commercial-off-the-shelf software application. The transaction database is operable to store transaction information related to one of the data requests received from the query processor. The exception handler communicates with the transaction database. The exception handler is operable, in response to notification of an error related to processing the one of the data requests, to retrieve the transaction information from the transaction database for the query processor. The exception handler uses the transaction information to determine whether any data stored in one or more of the plurality of data stores has changed based on the transaction information and further to return any of the data to a previous state, at least a portion of the data returned to the previous state using a compensating transaction.</p>
<p id="p-0031" num="0030">In another embodiment, a system for transactions processing of data requests from applications is provided. The system comprises an application having a data request, a plurality of data stores to maintain data, and a data warehouse to maintain data. The system further comprises a query processor, a metadata repository, a transaction database, and an exception handler. The query processor manages transaction processing of data requests from the application. The metadata repository maintains a logical data model related to the data. The metadata repository instructs the query processor regarding handling of the data requests from the application and between the plurality of data stores and the data warehouse. The transaction database is operable to store a transaction information related to one of the data requests received from the query processor. The exception handler communicates with the transaction database. The exception handler is operable, in response to notification of an error related to processing the one of the data requests, to retrieve the transaction information from the transaction database for the query processor. The exception handler uses the transaction information to determine whether any data stored in one or more of the plurality of data stores and data warehouse has changed and further to return the data to a prior state, at least a portion of the data returned to the prior state using a compensating transaction.</p>
<p id="p-0032" num="0031">In another embodiment, a method for managing application data transactions is provided. The method includes receiving, by a query processor, a data request from an application, and storing a transaction record in a transaction database based on the data request. The method includes determining, using a logical data model, one or more data stores and data warehouses to update based on the data request. The method provides for updating one or more data stores based on the data request, determining whether the data stores were successfully updated, and where the data stores were not successfully updated, returning the data in the one or more data stores to a prior state. The method further provides for updating the data warehouse based on the changes to the one or more data stores, determining whether the data warehouse was successfully updated, and where the data warehouse was not successfully updated, returning the data in the data warehouse to a prior state, at least a portion of the data warehouse data and data store data returned to the prior state using a compensating transaction.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0007" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram depicting components in an enterprise integration architecture under the prior art;</p>
<p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram depicting components in an embodiment of the Integration Infrastructure;</p>
<p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. 3</figref> is a block diagram depicting components in an embodiment of the Service Broker component of the Integration Infrastructure;</p>
<p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. 4</figref> is a block diagram depicting a sequence of events in the configuration of an embodiment of the Integration Infrastructure;</p>
<p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. 5</figref> is a block diagram depicting the retrieval of data in an embodiment of the Integration Infrastructure; and</p>
<p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. 6</figref> is a block diagram depicting the invocation of a service in an embodiment of the Integration Infrastructure.</p>
<p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. 7</figref> is a block diagram of an embodiment of a data access layer.</p>
<p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. 8</figref> is a block diagram of an alternative embodiment of a data access layer.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0008" level="1">DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS</heading>
<p id="p-0041" num="0040">To fully appreciate aspects of the service broker enhancements provided herein, the present disclosure includes description of integration infrastructure, messaging, and service broker as provided in U.S. patent application Ser. No. 10/619,296 filed Jul. 14, 2003 and entitled &#x201c;Integration Infrastructure.&#x201d; <figref idref="DRAWINGS">FIGS. 2 through 6</figref> and the related description are exemplary of one or more embodiments of systems, techniques, and/or methods whereby the service broker enhancements disclosed hereafter may be employed, however, the present disclosure should not be limited to these exemplary embodiments.</p>
<p id="p-0042" num="0041">A more efficient manner for distributing data and events to multiple applications is desired. In a target state, an enterprise integration layer such as that described above would become aware of business events rather than merely passing on data and messages. This can be accomplished by integrating the enterprise integration layer with a business process integration engine that implements the core processes of the enterprise and feeds messages to the target systems. In this target state, back-office applications would typically need to be capable of generating or publishing business events. Middleware, such as the enterprise integration layer and the business process integration engine, would not necessarily be involved in business transactions. Applications that rely on batch loading would typically need to be capable of becoming online processes that are ready to consume events, that is, to subscribe to messages. Messaging-based data exchange would reduce the need for batch load processes but not eliminate it. Batch processes might continue to be the most effective means of providing data to some target applications. Messaging would provide an infrastructure to make events persistent, guarantee message delivery, and transform messages for the target system. Messaging would also allow other applications interested in an event to easily plug in to the event. Data would be made available to applications in real-time, thus reducing or eliminating the need for replication and batch loads. Making the enterprise integration layer aware of business events may entail an assessment and realignment of an existing implementation of the layer and its tools, an alignment with the direction of future architecture, and an alignment with business process management and workflow strategy.</p>
<p id="p-0043" num="0042">Another area in which improvements can be made is in the standardization of technology. It would be desirable to have a set of standardized, service-oriented, synchronous and asynchronous interfaces through which clients can access back-office data and services. Such interfaces could offer decreased complexity resulting in reduced maintenance. The development of standardized connectors and adapters to packaged applications such as Ensemble, Convergys P2K, and Clarify can be achieved using technologies such as Java Connector Architecture. Data transformation tools can be used for data mapping. These techniques for data standardization can eliminate the need for tightly coupled integration and reduce reliance on custom development. The maximum use and reuse of enterprise-wide infrastructure components such as logging, naming, and security and the reuse of existing middleware products such as IBM's MQSeries messaging environment where possible is also desired. Another area in which improvements can be made is in the promotion of the use of publish/subscribe messaging for business event notification. Similarly, asynchronous access to data and services via protocols such as JMS and COSNotification would also be beneficial. The elimination or minimization of data replication, preferably through the use of caching in the integration layer can improve performance and response time. The implementation of transaction management within the integration layer and the provision of transaction semantics can also lead to improvements. This can allow support for high transaction volumes. A business process management system is also desirable. Such a system can deal with long-term needs such as a common enterprise model, business intelligence, and business-to-business integration. The provision of a development environment that allows implementers to deploy, configure, and maintain applications more quickly and easily can also be beneficial. This could reduce development backlog and allow developers to focus on configuration instead of coding.</p>
<p id="p-0044" num="0043">Other potential areas of improvement can include the development of a monitoring framework, the creation of a high-availability design, and the clustering of similar functions. The use of synchronous request/reply messaging, the use of an integration infrastructure as a business service abstraction layer, and the shielding of client applications from changes that do not directly affect them would also be beneficial. The alignment of message payloads, particularly data lookup responses, to the usage patterns of client applications would also offer improvement, as would a policy of data location transparency.</p>
<p id="p-0045" num="0044">The development of policies and guidelines on implementation of these components can promote evolution to the target state of infrastructure integration. The steps in achieving infrastructure integration can include identifying current deficiencies, defining the strategy and concepts that will govern the new architecture, developing enterprise-specific detailed integration requirements, and defining an architecture framework. Further steps can include studying industry trends and identifying leading off-the-shelf products, assessing the capabilities of off-the-shelf products in meeting the requirements of the enterprise, examining current capabilities within the enterprise for viable solutions, and finalizing off-the-shelf and internal solutions. Developing a proof of concept, defining a migration strategy for evolution from the current infrastructure to the target state, and identifying projects that can use the new integration components can be additional steps in achieving infrastructure integration.</p>
<p id="p-0046" num="0045">The target state is to develop a framework to provide multiple access mechanisms for enterprise data and services based on an enterprise-wide object model. An embodiment of such a framework, which can be referred to as the Integration Infrastructure, is shown in <figref idref="DRAWINGS">FIG. 2</figref>. The Integration Infrastructure can include an enterprise integration layer that can be referred to as Service Broker <b>210</b>, a messaging system that can be referred to as Message Broker <b>220</b>, and a Business Process Integration system <b>230</b>. An example of a suitable Business Process Integration system is the BusinessWare platform produced by Vitria Technology, Inc. Separate enterprise-wide operational data stores <b>240</b> can exist outside of packaged applications <b>250</b> to hold replicated data and reference data. The data in the enterprise-wide operational data stores <b>240</b> can be kept synchronized with data in the commercial, off-the-shelf packages <b>250</b>. Transient data and cross-reference data can be maintained in a local data store. A System of Record data store for missing data can also be present. The Integration Infrastructure effort can be aligned with an overall enterprise data strategy. A phased implementation plan can be developed in conjunction with a data architecture group involving prioritization and alignment with projects that are suitable for a first implementation.</p>
<p id="p-0047" num="0046">The Service Broker component of the Integration Infrastructure provides a means to support integration of front-office and back-office systems for data and services. It simplifies application architecture by standardizing client access to enterprise data and services. Service Broker provides decoupling between consumers and providers of data and services and hides the locations of data and services. Brokering of information and services across a set of enterprise-wide operational data stores and packaged applications is also provided. Service Broker allows applications to access enterprise data and services via multiple technologies including SQL/ODBC, JMS, Java RMI, LDAP, CORBA, MQSeries, Tuxedo, and web services such as SOAP and XML. Java applications, Java objects in an application server, Java servlets in a web server, applications capable of accessing ODBC/JDBC data sources, MSOffice applications with ODBC access tools, and applications with XML interfaces can also access Service Broker functionality. Service Broker can also interface to Message Broker and the Business Process Integrator. Standardized client access interfaces allow clients to perform data operations (such as creation, reading, updating, and deletion) as well as to execute methods and services via any of the above access methods. Service Broker uses back-office metadata repositories that can contain business rules, data transformation rules, and rules for publishing events via Message Broker. This rule-driven architecture also supports validation rules, data and service access rules, caching rules, and event generation rules. Service Broker uses a component-based architecture based on an enterprise-wide object model that represents all major business entities in the operations domain. This modular architecture allows rapid changes to support new requirements. Service Broker provides a transformation mechanism for mapping between an enterprise object model format and back-office system formats. It uses commercially available transformation engines (such as XSLT) rather than hard coding.</p>
<p id="p-0048" num="0047">Service Broker can define and generate business events and publish the business events to all applications that need to be aware of the events. Business events are key milestones within a process flow such as the completion of a credit check or the creation of an account. Information about events such as these is often needed by multiple applications within an enterprise. When a clear definition of business events or their sources does not exist, applications must deduce that business events have occurred by replicating data and applying rules. These methods cannot be done in real time and are time-consuming and error prone. The definition and automatic generation of business events by Service Broker can make an enterprise business event-aware. This can be done by identifying key business events based on process flows, identifying the source of each event, creating event specifications and queue architecture, modifying source applications to &#x201c;fire&#x201d; business events, and developing application adapters to publish events on a message bus or a specified queue. Subscriber or consumer applications can then take the events from the bus or queue and perform their own processing such as updating a database, creating a file for a batch feed, or tracking the status of an order. When key business events are available, applications can readily use them rather than having to deduce them.</p>
<p id="p-0049" num="0048">An embodiment of the Service Broker architecture is shown in <figref idref="DRAWINGS">FIG. 3</figref>. In this embodiment, Service Broker <b>300</b> consists of several related components including an Enterprise Object Model <b>302</b>, a rules engine <b>304</b>, a business event repository <b>308</b>, adapters <b>312</b>, a back-office metadata repository <b>310</b>, a business object server <b>320</b>, client access interfaces <b>328</b>, a transaction processor <b>330</b>, and a local data store <b>332</b>.</p>
<p id="p-0050" num="0049">Service Broker <b>300</b> can use an Enterprise Object Model (EOM) <b>302</b> to define the major business entities in the operations domain. The EOM <b>302</b> is an object-oriented representation that unifies business information and business services. It has facilities for accessing and updating data in back-office databases, legacy systems, and packaged applications as well as for accessing services in any back-office system <b>350</b>. The EOM <b>302</b> is not dependent on any particular back-office application <b>350</b>; it models data services across all back-office applications <b>350</b>. A user <b>301</b> can define the EOM <b>302</b> at development time through user interface <b>303</b> using standard object-oriented programming principles such as object and relationships, inheritance, uses, and containment. The EOM <b>302</b> can be defined through the use of a Unified Modeling Language (UML) graphical editor or through the import of models from external sources such as Rational Rose. A metadata repository can be present within the EOM <b>302</b> for browsing EOM data and services such as classes and relationships.</p>
<p id="p-0051" num="0050">Data and services can be mapped between the EOM <b>302</b> and back-office data and functions. The mapping is specific to a particular EOM object and a particular back-office system <b>350</b>. The metadata provided by a back-office adapter <b>312</b> is used to aid in the mapping. The mapping can be bi-directional. That is, when a read event occurs, mapping is done from the format of a back-office system <b>350</b> to an EOM object. When a create, update, or delete event occurs, mapping is done from an EOM object to the format of a back-office system <b>350</b>. There is support for bi-directional object/relational mapping and for bi-directional object/object mapping. The mappings can be one-to-one, one-to-many, or many-to-many. The ability to add custom code for data transformation for complex mappings also exists. At the time of design and development, data maps can be created using a visual editor that maps from the EOM to/from the specific source or back-office format type(s). Data maps can be versioned and stored in the back-office metadata repository <b>310</b>. At run time, the appropriate data map is invoked by the business object server <b>320</b>. Source data is passed to the map function and data in the target format is returned.</p>
<p id="p-0052" num="0051">Various types of rules can be defined and stored in a rules engine <b>304</b> within Service Broker <b>300</b>. These can include validation and data integrity rules, data and service access rules, event notification rules, and caching rules. The rules can be defined using a graphical tool such as Rules Editor. Validation and integrity rules associate rules with EOM objects. These rules ensure that all back-office application rules are independent and are not duplicated. Data and service access rules associate EOM objects with target systems and data maps. These rules deal with location and information reliability. Location-based rules are concerned with the mapping of a business object, attribute, or method to the data or methods of a back-office system <b>350</b> as well as the mapping of a back-office system <b>350</b> to the appropriate transformer and adapter <b>312</b>. Information reliability-based rules determine the most reliable source of data at a given time. Another factor relevant to data and service access rules is the determination of the source of data based on latency and performance requirements. For example, for transactions requiring a low response time, a replicated data store rather than a packaged application can be accessed. Event notification rules associate business events to the EOM <b>302</b>. These rules deal with criteria for determining when to publish what information to Message Broker <b>340</b>. For example, an event can be considered to occur upon the creation, reading, updating, or deleting of an object, upon the invocation of a particular method, upon the evaluation of an expression, or when similar activities occur. Rules regarding such functions can be associated with business objects in the EOM <b>302</b>. Caching rules concern what EOM business objects to cache, how long they should be cached, when they should be refreshed, and similar issues.</p>
<p id="p-0053" num="0052">Service Broker <b>300</b> can use a business event repository <b>308</b> to contain a definition of all enterprise-wide business events that are of interest to multiple parties. Business events can be generated by packaged applications, by a database system, or by Service Broker <b>300</b> itself. The business event repository <b>308</b> also identifies all publishers for a particular business event. Adapters <b>312</b> within Service Broker <b>300</b> can provide access to back-office systems <b>350</b> for retrieving data, updating data, and invoking services. Multiple types of adapters <b>312</b> can exist including adapters for communicating with databases <b>314</b> such as Oracle and Sybase; protocol-based adapters for LDAP and other directory services <b>316</b>, XML, Tuxedo, MQSeries, and similar protocols; adapters that interface to packaged applications <b>318</b>; object-based adapters for CORBA, Java RMI, COM, and similar communication standards; native language-based adapters for languages such as C, C++, and Java; and custom adapters. Database adapters can supply metadata regarding table definitions and stored procedures. Object adapters can supply metadata regarding interface repositories and type libraries. Protocol adapters can supply metadata regarding XML DTDs and Tuxedo contract repositories. Adapters <b>312</b> are technology-specific rather than system-specific. For example, the same adapter would be used for accessing two different systems if both systems use CORBA. At the design and development stage, adapters <b>312</b> supply a data transformation engine <b>306</b> with metadata related to an external system to support mapping development and method invocation. At run time, adapters <b>312</b> are used by the business object server <b>320</b> to interact with back-office systems <b>350</b>.</p>
<p id="p-0054" num="0053">A back-office metadata repository <b>310</b> within Service Broker <b>300</b> can hold the metadata supplied by the adapters <b>312</b>. For example, the table definitions and stored procedures supplied by a database adapter, the interfaces supplied by an object adapter, and the XML DTDs and Tuxedo contracts supplied by a protocol adapter can all be held by the back-office metadata repository <b>310</b>. Several different types of relational data store <b>314</b>, such as new data stores, existing data stores, and replicated data stores, may supply data to the back-office metadata repository <b>310</b>. It is typically not feasible to directly access the data stores of commercial, off-the-shelf systems; the API provided by the vendor generally must be used. EOM objects in the repository <b>310</b> such as data and methods can be viewed. Back-office system classes, interfaces, tables, stored procedures, and transactions can also be viewed.</p>
<p id="p-0055" num="0054">The business object server <b>320</b> component of Service Broker <b>300</b> manages the exchange of information between the Service Broker business objects and back-office applications <b>350</b>. Multiple classes of the business object server <b>320</b> can exist such as account, customer, and product. Each business object server <b>320</b> implements data creation, reading, updating, and deletion functions and service methods associated with a particular business object. Each implementation fetches data from a back-office system <b>350</b>, stores data in an appropriate back-office system <b>350</b>, and invokes the appropriate services in a back-office system <b>350</b>. The business object server <b>320</b> uses the rules engine <b>304</b>, the transaction processor <b>330</b>, and data transformation <b>306</b> to interact with back-office applications <b>350</b> using the appropriate adapter <b>312</b>.</p>
<p id="p-0056" num="0055">Among the functions performed by the business object server <b>320</b> are object assembly and disassembly <b>322</b>, caching and synchronization <b>324</b>, and service invocation <b>326</b>. Object assembly deals with the creation, upon a client request, of a composite object or objects through the aggregation of data attributes from multiple back-office systems <b>350</b>. For example, if a client queries to retrieve all subscribers tied to an account, the business object server <b>320</b> will instantiate multiple instances of a subscriber object based on data from a back-office system <b>350</b> and will populate each instance with appropriate data from one or more back-office systems <b>350</b>. Object disassembly is the breaking of a composite object into multiple objects for storage in a back-office system <b>350</b>. Caching is the loading of an instance of an object into memory for high-performance access. The business object server <b>320</b> manages the creation, refreshing, flushing, and other functions related to a cache based on pre-defined caching rules. The business object server <b>320</b> also keeps multiple copies of data in multiple back-office systems <b>350</b> synchronized when creation, updating, and deletion functions are performed. Synchronization is done based on rules defined in the rules engine <b>304</b>. The business object server <b>320</b> uses the transaction processor <b>330</b> in its synchronization steps when an operation requires transactional integrity.</p>
<p id="p-0057" num="0056">Based on a set of pre-defined rules, the service invocation functions <b>326</b> of the business object server <b>320</b> determine the back-office systems <b>350</b> required to support desired data or service operations, identify the transformations to be applied, identify the functions to be invoked on a target system <b>350</b>, and invoke the appropriate back-office functions via the target system adapter <b>312</b>. The object methods supported by Service Broker <b>300</b> are typically composite business services and are independent of how they are implemented in a back-office system <b>350</b>. A single method call defined in the EOM <b>302</b> can translate into multiple service invocations <b>326</b> in a back-office system <b>350</b>. The business object server <b>320</b> maintains the state of the invocations <b>326</b> and handles exceptions. Code written for a service invocation <b>326</b> is typically not specific to a particular target system <b>350</b> but rather uses rules and metadata to execute the appropriate back-office functions.</p>
<p id="p-0058" num="0057">The client access interfaces <b>328</b> within Service Broker <b>300</b> allow front-end applications <b>348</b> to have a standardized interface through which to access back-end systems <b>350</b>. This reduces complexity, eliminates tight coupling, and decreases reliance on custom development. The client access interfaces <b>328</b> can include an object interface <b>342</b>, a relational interface <b>344</b>, and a web services interface <b>346</b>. The object interface <b>342</b> allows Java programs <b>348</b> to access objects using RMI or EJB session beans and allows Java, C, and C++ programs <b>348</b> to access objects using a standard Object Request Broker. The relational interface <b>344</b> can use ODBC or JDBC to allow client applications <b>348</b> to access information with statements that allow the selection, insertion, updating, and deletion of data. The relational interface <b>344</b> also allows client applications <b>348</b> to access object methods by invoking stored procedures. The web services interface <b>346</b> uses communication protocols such as http and SOAP to allow client applications <b>348</b> to access objects using XML documents, or for example XQuery which may be an example of an XML form of SQL statement.</p>
<p id="p-0059" num="0058">The client access interfaces <b>328</b> within Service Broker <b>300</b> can allow access to multiple quality of service capabilities for both transactional and non-transactional services. The client access interfaces <b>328</b> can be integrated with an enterprise-wide naming and directory service <b>334</b> for location transparency both to client applications <b>348</b> and within the Service Broker framework. An existing enterprise-wide security service <b>336</b> can be used for authorization. The interfaces <b>328</b> can also be integrated with an application management and monitoring system <b>338</b> to perform error reporting, root-cause analysis, and predictive modeling.</p>
<p id="p-0060" num="0059">As business and product applications interact with Service Broker <b>300</b>, distributed transaction processing may become necessary. Service Broker <b>300</b> can provide transactional quality of service through the use of a transaction processor <b>330</b>. Transaction processing may not be possible for data services such as transactions involving access to packaged applications using Application Programming Interfaces.</p>
<p id="p-0061" num="0060">A local data store <b>332</b> can be used for data that may need to be made persistent within Service Broker <b>300</b> such as transient data and cross-reference data. The local data store <b>332</b> would typically not be used for System of Record data. The local data store <b>332</b> would not be available for use by other enterprise applications directly but could be accessed via the Service Broker client interfaces <b>328</b>.</p>
<p id="p-0062" num="0061">The components of Service Broker <b>300</b> can use previously existing infrastructure services. A naming and directory service <b>334</b> can be used by Service Broker client applications <b>348</b> and intra-Service Broker components such as the business object server <b>320</b> and the adapters <b>312</b> to locate target components and services. A security service <b>336</b> can be used to determine data access authorization credentials. The logging framework of an application management and monitoring system <b>338</b> can be used for error logging, monitoring, and reporting. Message Broker <b>340</b> can be used for exchanging messages with other systems using the publish/subscribe paradigm. More specifically, Service Broker <b>300</b> has the capability to generate business events and publish them to Message Broker <b>340</b>. Message Broker <b>340</b> can then make the entire enterprise aware of the business events.</p>
<p id="p-0063" num="0062">An embodiment of the process of configuring Service Broker is shown in <figref idref="DRAWINGS">FIG. 4</figref>. In box <b>410</b>, the Enterprise Object Model is defined. Next, in box <b>420</b>, the back-office metadata repository <b>310</b> is loaded via the adapters <b>312</b> that convert the data in data stores <b>314</b> and packaged applications <b>318</b>. Business events are then defined in box <b>430</b> and placed in the business event repository <b>308</b>. Data transformation maps are defined in box <b>440</b>. Rules are defined in box <b>450</b> and placed in the rules engine <b>304</b>.</p>
<p id="p-0064" num="0063">An embodiment of the process of a front-end application retrieving data from a back-end system is illustrated in <figref idref="DRAWINGS">FIG. 5</figref>. The application <b>348</b> first obtains a reference for a business service from a naming and directory service <b>334</b>, via path <b>515</b>. The application <b>348</b>, via path <b>525</b>, then requests access to the data from an appropriate client access interface <b>328</b>. The client access interface <b>328</b>, via path <b>535</b>, calls a security service <b>336</b> to check the authorization of the front-end user. Upon the user being authorized, the client access interface <b>328</b>, via path <b>545</b>, invokes the business service on a business object server <b>320</b>. Using location and mapping rules from a rules engine <b>304</b>, the business object server <b>320</b> maps data from the EOM data format to the format of the target back-office system. The business object server <b>320</b>, via a path <b>555</b>, then retrieves the requested data from the target back-office system such as a data store <b>314</b> or a packaged application <b>318</b>. The business object server <b>320</b> maps the retrieved data from the native format of the back-office system into the EOM data format and assembles a business object <b>590</b>. The business object server <b>320</b>, via path <b>565</b>, logs the event in an application management and monitoring system <b>338</b> and then, via path <b>575</b>, returns the result to the front-end application <b>348</b>.</p>
<p id="p-0065" num="0064">An embodiment of the process of a front-end application invoking a service in a back-end system is shown in <figref idref="DRAWINGS">FIG. 6</figref>. The application <b>348</b> first obtains a reference for the service from a naming and directory service <b>334</b>, via path <b>615</b>. The application <b>348</b>, via path <b>625</b>, then requests the service from an appropriate client access interface <b>328</b>. The client access interface <b>328</b>, via path <b>635</b>, calls a security service <b>336</b> to check the authorization of the front-end user. Upon the user being authorized, the client access interface <b>328</b>, via path <b>645</b>, invokes the business service on a business object server <b>320</b>. Using location and mapping rules from a rules engine <b>304</b>, the business object server <b>320</b> maps the service request from the EOM data format to the format of the target back-office system. The business object server <b>320</b>, via a path <b>655</b>, then invokes the service in the target back-office system such as a data store <b>314</b> or a packaged application <b>318</b>. The business object server <b>320</b>, via path <b>665</b>, logs the event in an application management and monitoring system <b>338</b> and then, via path <b>675</b>, returns the result to the front-end application <b>348</b>. If the event generation rules in the rules engine <b>304</b> indicate that components elsewhere in the enterprise need to be aware of the event, then the event is published to Message Broker <b>340</b>.</p>
<p id="p-0066" num="0065">In an embodiment, two options exist for the initial phase of the migration from an EI-based architecture such as that shown in <figref idref="DRAWINGS">FIG. 1</figref> to the more modular Service Broker. In the first option, Service Broker would be implemented for a new data domain or subject area (such as a product/offer catalog) that would co-exist with the EI infrastructure. An application would retrieve previously existing data from the EI infrastructure but would use Service Broker for data related to the new subject area. In subsequent phases of this option, Service Broker could be built out for additional new data domains. If changes were needed in EI-based business transactions, additional Service Broker components could be developed and outdated business transactions could be retired. The phased implementation of Service Broker would be based on new project requirements for new data domains and the need for changes to existing component programs within the EI infrastructure. Over the phases, client applications would use Service Broker for accessing more and more data domains and message-based access would slowly be phased out.</p>
<p id="p-0067" num="0066">In the second option, Service Broker would be layered on top of the existing EI infrastructure for a particular subject area such as account data. This EI wrapper would provide a synchronous access mechanism through which applications could retrieve data. An application could use this Service Broker interface and Service Broker would then call existing EI-based business transactions. In subsequent phases of this option, additional layers of Service Broker could be placed on the EI infrastructure for additional previously existing domains. New Service Broker capabilities could be built for new data domains. If changes were needed in EI-based business transactions, additional Service Broker components could be developed and outdated business transactions could be retired.</p>
<p id="p-0068" num="0067">Service Broker can eliminate point-to-point interfaces between applications though one or both of two options. Under one option, point-to-point interfaces are migrated to the Service Broker architecture, thereby decoupling the source and target systems and providing enterprise-wide visibility to business events and transactions. Under the other option, business events and point-to-point interfaces to which the enterprise needs visibility are identified. These point-to-point interfaces are left intact but the target applications publish key business transaction events that occur over these interfaces so that visibility to the rest of the enterprise is provided. In either case, the development of new point-to-point interfaces is avoided.</p>
<p id="p-0069" num="0068">Another element in the Integration Infrastructure framework is Message Broker. Message Broker is a middleware layer that can connect disparate applications and transport information in a consistent format between systems. It can be a component of an overall approach for integrating enterprise applications through event-based messaging. Message Broker can provide a foundation for business process automation by allowing integration of both data and business logic across applications. It can allow asynchronous communication and event-based integration through the use of communication queues or channels. The majority of communication is typically performed in a publish/subscribe manner but other communication paradigms, including request/response and point-to-point, can also be supported. Multiple consumers can easily subscribe to the same message. Message Broker can eliminate the need for tight integration between Application Programming Interfaces and hence provide a more flexible environment. A facility can be present to map simple or complex data structures from one data format to another. For example, non-XML data can be transformed into an XML format. A facility to connect to other native technologies such as CORBA, RDBMS, and J2EE can also be present. A filtering framework can allow applications to filter messages based on event type or message content. The capability can exist to provide enterprise level quality of service through guaranteed delivery, full transaction processing and recovery, and prioritization of messages on a channel or queue. Integration process automation can also be available through a facility to control and manage several sub-tasks tied to integrating systems via messaging. A capability to model and automate simple and complex business processes through workflow management can also be present. Service Broker can publish data to Message Broker based on the transactions it is brokering, such as data creation, updating, and deletion transactions, and can subscribe to information from Message Broker in order to perform operations such as updating a data store. IBM's MQSeries is an example of a system that supports message brokering.</p>
<p id="p-0070" num="0069">Connectors and adapters can be present within Message Broker to act as single integration points for applications and the messaging environment. The adapters can comprise a message interface, a transformation module, and an application interface. The message interface publishes an event to or subscribes to an event from a message queue within the message infrastructure. The transformation layer then maps the data between the enterprise business representation and the application specific format. The application interface then uses an application-specific interface mechanism (such as CORBA, EJB, or RDBMS) to interface with an application.</p>
<p id="p-0071" num="0070">An administrative console can be available within Message Broker that allows business process modeling to be performed. This user interface can allow business analysts to graphically model and automate cross-application business processes and related business rules. The administrative console can also provide real-time modeling and management of all components via event-based monitors, alarms, and alerts. It can provide both local and remote administration from a single GUI available on any machine to any authorized user. It can also provide the ability to view the messages that are on the queues.</p>
<p id="p-0072" num="0071">To minimize or eliminate data replication, desired business events can be made available in a standard format on a message bus via Message Broker. Applications can subscribe to these events and obtain desired data via the event or through the use of Service Broker. To migrate an event to Message Broker, key business events and the source system for each event are identified. A common format for each business event is then created. Source applications are then modified to &#x201c;fire&#x201d; these events; that is, source applications are given the ability to signal that a business event has occurred. A source application adapter publishes events on a message bus, a message queue, or via Message Broker. The source application adapter also performs a transformation of data related to the business event from the source data format to a standard data format. The source application adapter can publish the event and the data related to the event independently or it can combine the event and the data related to the event into a single data packet. A target application adapter subscribes to desired events and performs a transformation from the standard data format to the target data format. Implementation of the Message Broker infrastructure is typically tied to projects that identify which business events to publish and who the subscribers are. Existing replication and batch feed functionality can be replaced with a real-time Message Broker-driven approach for desired business events.</p>
<p id="p-0073" num="0072">It is not necessary that all communication between all applications pass through Message Broker. For example, message brokering may not be necessary for the exchange of very specific information such as bill mediation data and voice mail provisioning data. Information such as this is more suitable for point-to-point communication since no enterprise-wide visibility is required; the information has only local significance between the two communicating applications. Other situations where message brokering may not be appropriate include cases where synchronous communication is desired, where data exchange is in the call path, or where a pre-built, vendor-provided interface already exists. In the latter case, lower costs and lower time to market can sometimes be achieved with the vendor interface.</p>
<p id="p-0074" num="0073">In addition to Service Broker and Message Broker, Business Process Integration is another element in the Integration Infrastructure. Business Process Integration can be achieved with products such as Vitria's BusinessWare platform. Business Process Integration, which can also be referred to as Workflow or Business Process Management, can accelerate the delivery of new products and services and promote the rapid adaptation of business processes to constantly changing market conditions. Business Process Integration can improve efficiency and profitability by streamlining processes across systems and people, within an enterprise, and with partners. Business Process Integration can externalize and centralize business process coordination steps by separating business processing from functional processing. Business process logic can then be changed independently of functional applications. Business process changes can be implemented quickly using graphical modeling tools. Tracking, analysis, and reporting of process information and business metrics can be provided. A status and jeopardy management function can allow the tracking of task intervals and the generation of jeopardy notifications. A Business Process Integration engine can distribute work to target applications.</p>
<p id="p-0075" num="0074">Business Process Integration can also support the logic for sequential, parallel, and conditional processing for automated tasks with customers and partners and manual tasks such as human processes and exception handling. It can also involve the execution of automated steps. Business processes can be nested or sub-processes can be chained together. Business Process Integration can use the Message Broker infrastructure to communicate with applications. When invoking a method to a target application, a process integrator can post a message destined for the target application. The process integrator can receive responses from applications by retrieving the messages that are sent to it. Users can acquire &#x201c;manual&#x201d; tasks from the work queues. It should be appreciated that the forgoing is exemplary and not all aspects are required, however specific enhancements which may each independently add value or be useful are described herein and below.</p>
<p id="p-0076" num="0075"><figref idref="DRAWINGS">FIG. 7</figref> depicts an embodiment of a system through which transaction processing can be provided to data stores, such as those managed by service broker <b>300</b> as described above, and through which data warehouses can be kept up-to-date. A data access layer <b>710</b> handles data transfers among an external application <b>720</b>, COTS data stores <b>730</b>, <b>740</b>, and <b>750</b>, and data warehouses <b>760</b> and <b>770</b>. The data stores shown in <figref idref="DRAWINGS">FIG. 7</figref> are a DB2 database <b>730</b>, an Oracle database <b>740</b>, and a flat file <b>750</b> but other numbers and types of data stores could be present. Similarly, other numbers of data warehouses could be present.</p>
<p id="p-0077" num="0076">The data access layer <b>710</b> comprises a query processor <b>712</b>, a metadata database <b>714</b>, a transaction database <b>716</b>, and an exception handling module <b>718</b>. The query processor <b>712</b> receives data requests from the application <b>720</b>. A data request might be a query to retrieve data from a data store <b>730</b>, <b>740</b>, or <b>750</b>, an update to the data in a data store <b>730</b>, <b>740</b>, or <b>750</b>, or some other type of interaction with the data in a data store <b>730</b>, <b>740</b>, or <b>750</b>.</p>
<p id="p-0078" num="0077">The metadata database <b>714</b> informs the query processor <b>712</b> how to handle data requests. A logical data model in the metadata database <b>714</b> determines which data store <b>730</b>, <b>740</b>, or <b>750</b> a data request applies to, how the data should be updated, retrieved, aggregated, or otherwise manipulated and whether updated data should be sent to a data warehouse <b>760</b> or <b>770</b>.</p>
<p id="p-0079" num="0078">Data requests received by the query processor <b>712</b> are copied to the transaction database <b>716</b>. If an error occurs at any point in the processing of a data request, the request can be retrieved from the transaction database <b>716</b> and used to return any data that was modified back to its previous state.</p>
<p id="p-0080" num="0079">If the query processor <b>712</b> detects that an error has occurred in the processing of a data request, the query processor <b>712</b> informs the exception handling module <b>718</b>. The exception handling module <b>718</b> retrieves the data request from the transaction database <b>716</b>, determines from the data request the previous state of any data elements that were changed, and rolls the data elements back to their previous state.</p>
<p id="p-0081" num="0080"><figref idref="DRAWINGS">FIG. 7</figref> depicts a successful data request. In this embodiment, a data request is made sequentially to the DB2 database <b>730</b>, the Oracle database <b>740</b>, and the flat file <b>750</b>. That is, the data request is first made to the DB2 database <b>730</b> and, if it is completed successfully, it is then made to the Oracle database <b>740</b>. If the data request is completed successfully in the Oracle database <b>740</b>, it is then made to the flat file <b>750</b>.</p>
<p id="p-0082" num="0081">An application <b>720</b> sends the data request to the query processor <b>712</b> via path <b>705</b>. Query processor <b>712</b> consults the metadata database <b>714</b> via path <b>715</b> to determine how the data request should be handled. Query processor <b>712</b> also sends a copy of the data request to transaction database <b>716</b> via path <b>725</b>. The logical data model in the metadata database <b>714</b> indicates to the query processor <b>712</b>, via path <b>715</b>, how to process the data request. The query processor <b>712</b> then attempts to perform the appropriate actions on the data stores <b>730</b>, <b>740</b>, and <b>750</b>, via paths <b>735</b>, <b>745</b>, and <b>755</b>, respectively.</p>
<p id="p-0083" num="0082">In the embodiment of <figref idref="DRAWINGS">FIG. 1</figref>, the data request is completed successfully in all of the data stores <b>730</b>, <b>740</b>, and <b>750</b>. Therefore, the copy of the data request in the transaction database <b>716</b> is no longer needed and is removed from the transaction database <b>716</b>. The data request is then considered committed in the data stores <b>730</b>, <b>740</b>, and <b>750</b> and the query processor <b>712</b> sends a report of a successful data request to the application <b>720</b> via path <b>765</b>. If the data request was a data update and if the logical data model in the metadata database <b>714</b> specifies that the updated data should be sent to the data warehouses <b>760</b> and <b>770</b>, this is then done in a process described below.</p>
<p id="p-0084" num="0083">The same data element can be maintained in more than one data store <b>730</b>, <b>740</b>, and/or <b>750</b> and might also be kept in one or more data warehouses <b>760</b> and/or <b>770</b>. For example, a common data element such as a user name might need to exist in multiple locations. If a change is made to such a data element, the change would typically need to take place in all locations that contain the element. For example, the metadata database <b>714</b> might tell the query processor <b>712</b> that a data request needs to go to the data stores <b>730</b>, <b>740</b>, and <b>750</b> in that order. When the change is committed in the data stores <b>730</b>, <b>740</b>, and <b>750</b>, the metadata database <b>714</b> might specify that the same change needs to occur in one or more data warehouses <b>760</b> and/or <b>770</b>. While data requests to the data stores <b>730</b>, <b>740</b>, and <b>750</b> are done synchronously, updated data is sent to the data warehouses <b>760</b> and <b>770</b> in an asynchronous, publish/subscribe manner.</p>
<p id="p-0085" num="0084">In publish/subscribe data transfer, a publishing application places a data message on one or more communication channels. The data message typically includes a header that describes the content of the message. Applications that have access to the communication channels can examine the header and determine if the message is relevant to them. If an application is interested in a message, it can accept, or subscribe to, the message. Publish/subscribe messaging is asynchronous in that a publishing application can publish a message at one time and a subscribing application can receive the message at later time.</p>
<p id="p-0086" num="0085">In the embodiment of <figref idref="DRAWINGS">FIG. 7</figref>, the query processor <b>712</b>, via paths <b>765</b> and <b>775</b>, publishes any updates that were made to the data stores <b>730</b>, <b>740</b>, and/or <b>750</b>. A data warehouse <b>760</b> or <b>770</b> can subscribe to the updates, via path <b>765</b> or <b>775</b>, if it is interested. If a data warehouse <b>760</b> or <b>770</b> subscribes to the updates, the data in the data warehouse <b>760</b> or <b>770</b> will match the data in the data stores <b>730</b>, <b>740</b>, and <b>750</b>.</p>
<p id="p-0087" num="0086">In an embodiment, the original data request is not deleted from the transaction database <b>716</b> upon the successful updating of data stores <b>730</b>, <b>740</b>, and <b>750</b> but instead remains in the transaction database <b>716</b> until a data warehouse <b>760</b> or <b>770</b> responds that it has received the updated data. This allows the query processor <b>712</b> to retrieve a data request from the transaction database <b>716</b> and publish a data update again if an error occurs in the publish/subscribe process. Further, the process may notify an administrator of any error so that, when appropriate, additional action may be taken.</p>
<p id="p-0088" num="0087">In this manner, the data warehouses <b>760</b> and <b>770</b> can replicate the data in the data stores <b>730</b>, <b>740</b>, and <b>750</b>. After the data in the data stores <b>730</b>, <b>740</b>, and <b>750</b> has been copied to the data warehouses <b>760</b> and <b>770</b> one time in a batch process, the data warehouses <b>760</b> and <b>770</b> can stay up-to-date merely by keeping up with changes in the data stores <b>730</b>, <b>740</b>, and <b>750</b> as they occur. Updating a data warehouse <b>760</b> or <b>770</b> in this manner keeps the data warehouse <b>760</b> or <b>770</b> more current than copying data to the data warehouse <b>760</b> or <b>770</b> in a periodic batch process, as well as reducing the loads on the data stores <b>730</b>, <b>740</b>, and <b>750</b> that a batch process imposes.</p>
<p id="p-0089" num="0088"><figref idref="DRAWINGS">FIG. 8</figref> depicts the processing of a data request in which an error occurs. When an error occurs, the data access layer <b>710</b> allows the data stores <b>730</b>, <b>740</b>, and <b>750</b> to be rolled back to their previous states. In the embodiment of <figref idref="DRAWINGS">FIG. 8</figref>, an application <b>720</b> makes a data request to data stores <b>730</b>, <b>740</b>, and <b>750</b> sequentially as described above. In this case, however, an error occurs in the processing of the request by the Oracle database <b>740</b> after the request is successfully completed in the DB2 database <b>730</b>. Therefore, the DB2 database <b>730</b> and the Oracle database <b>740</b> need to be in the status they held prior to the data request.</p>
<p id="p-0090" num="0089">For the Oracle database <b>740</b>, the data request was never completed so the Oracle database <b>740</b> would remain in its previous state and no rollback of data would be needed. For the DB2 database <b>730</b>, however, the data request was successfully completed and a rollback would be necessary. The rollback is managed by the exception handling module <b>718</b>.</p>
<p id="p-0091" num="0090">When an error occurs and the query processor <b>712</b> is unable to complete a data request, the query processor <b>712</b> informs the exception handling module <b>718</b> of the error via path <b>795</b> and specifies the data store <b>730</b>, <b>740</b>, or <b>750</b> in which the error occurred. The exception handling module <b>18</b> then retrieves the record of the data request from the transaction database <b>716</b> via path <b>805</b>. In the embodiment of <figref idref="DRAWINGS">FIG. 8</figref>, the exception handling module <b>718</b> retrieves the record of the data request made to the DB2 database <b>730</b> and uses it to determine the prior state of the data in the DB2 database <b>730</b>. Then, via path <b>815</b>, the exception handling module <b>718</b> rolls the data in the DB2 database <b>730</b> back to its previous state.</p>
<p id="p-0092" num="0091">The exception handling module <b>18</b> then informs the query processor <b>712</b>, via path <b>795</b>, of the actions it took in rolling back the data. The query processor <b>712</b> then sends an exception report to the requesting application <b>720</b> via path <b>765</b> and removes the copy of the data request from the transaction database <b>716</b> via path <b>725</b>.</p>
<p id="p-0093" num="0092">In addition to the above functions, the query processor <b>712</b> can also perform security functions by calling an external security service <b>780</b>, via path <b>835</b>, to determine if an application <b>720</b> is authorized to make a data request. The externalizing of security functions allows the use of a single sign-on for the data access layer <b>710</b> and for other applications in an enterprise.</p>
<p id="p-0094" num="0093">The data access layer provides a form of transaction processing similar to a two-phase commit to commercial, off-the-shelf data stores that do not have that capability. Use of compensating transactions to achieve the two-phase commit capability is an example of an XA compliant transaction, or combinations of both XA compliant transactions and compensating transactions. Various combinations of these and other types of transactions may be employed and may be nested within one another, serially, or otherwise. One embodiment of the present disclosure employs a compensating transaction, which is similar to the two-phase commit, to accomplish a similar result. By using compensating transactions, the present embodiment provides transaction control capabilities to commercial-off-the-shelf (COTS) applications and their related data stores or databases that do not otherwise have this capability. Further, the present disclosure contemplates providing such transaction control to numerous COTS applications integrated within an enterprise, and also in combination with the existing enterprise data stores.</p>
<p id="p-0095" num="0094">As an example of such transaction or transaction combination, when executing a compensating transaction to update several databases, if the transaction is successful then the non-compliant XA transaction may be executed. If the non-compliant XA transaction is successful, then the XA transaction may be committed and the application may be notified that the transaction was successful. If any of the transactions failed then the transaction may be compensated or rolled-back. In one embodiment, a compensating transaction may be described as the programming code or logic to restore, return, or back-out the recent change(s) or update(s) made to the data store or database. Other techniques and combinations of transactions will readily suggest themselves to one skilled in the art based on the present disclosure.</p>
<p id="p-0096" num="0095">In some aspects, the data store or database may be operable to roll-back some or all the transaction(s) until the data store is instructed to commit the transaction. In other aspects, the roll-back may be handled by a program so that all or portions of the transaction record is maintained, including the previous state of the data, in order to be operable to restore the data in the event of a failure. The present disclosure, according to one embodiment, employs compensating transactions as a means of managing roll-backs of data for failed transactions in various environments, such as in environments where XA transactions are not supported.</p>
<p id="p-0097" num="0096">Such transaction processing can be provided to multiple data stores that use disparate data storage protocols and formats. In addition, the data access layer keeps data warehouses more current than they are kept through traditional batch updates. The use of publish/subscribe messaging allows data warehouses to be updated whenever an update to an operational data store occurs.</p>
<p id="p-0098" num="0097">Although only a few embodiments of the present invention have been described, it should be understood that the present invention may be embodied in many other specific forms without departing from the spirit or the scope of the present invention. The present examples are to be considered as illustrative and not restrictive, and the invention is not to be limited to the details given herein, but may be modified within the scope of the appended claims along with their full scope of equivalents.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for managing application data transactions comprising:
<claim-text>receiving by a query processor a data request from an application to update at least one data element;</claim-text>
<claim-text>storing a transaction record in a transaction data store based on the data request;</claim-text>
<claim-text>determining, using a logical data model, one or more data stores and one or more data warehouses to update based on the one or more data stores and the one or more data warehouses maintaining the at least one data element of the data request, wherein the one or more data warehouses contain copies of data contained in the one or more data stores;</claim-text>
<claim-text>responsive to receiving the data request, updating the at least one data element maintained by the one or more data stores based on the data request;</claim-text>
<claim-text>determining whether the one or more data stores were successfully updated;</claim-text>
<claim-text>where the one or more data stores were not successfully updated, returning data updated responsive to the data request in the one or more data stores to a prior data store state using a compensating transaction;</claim-text>
<claim-text>responsive to receiving the data request, updating the at least one data element maintained by the one or more data warehouses based on the data request;</claim-text>
<claim-text>determining whether the one or more data warehouses were successfully updated;</claim-text>
<claim-text>where one or more of the one or more data warehouses were not successfully updated, returning data in the one or more data warehouses that has been updated responsive to the data request to a prior data warehouse state using a compensating transaction; and</claim-text>
<claim-text>where one or more of the one or more data warehouses were not successfully updated, the at least one data element updated in the one or more data stores responsive to the data request remains updated.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising requesting a security module to determine whether the data request by the application is authorized.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the one or more data stores comprise a first data store and a second data store, and wherein updating the one or more data stores and determining the status of the updates further includes:
<claim-text>changing data in the first data store, the first data store maintaining data in a first format; and</claim-text>
<claim-text>failing to change data in the second data store, the second data store maintaining data in a second format,</claim-text>
<claim-text>wherein determining whether the one or more data stores were successfully updated comprises:
<claim-text>identifying that the change to the second data store failed, and</claim-text>
</claim-text>
<claim-text>wherein returning the data in the one or more data stores to a prior state using a compensating transaction comprises:
<claim-text>restoring the data in the first data store to a prior state, the prior state defined as the data in the first data store prior to the change.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein updating the one or more data warehouses further includes:
<claim-text>publishing the updates to the one or more data stores to a channel accessible by the one or more data warehouses;</claim-text>
<claim-text>subscribing to the updates by the one or more data warehouses; and</claim-text>
<claim-text>updating the transaction data store regarding the publication and subscription of the updates.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising notify the application regarding whether the updates to the one or more data stores were successful.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>removing the transaction record from the transaction data store after the data is committed to the one or more data stores and the one or more data warehouses.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the application is further defined as a commercial-off-the-shelf software application.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the one or more data warehouses were not successfully updated, returning data in only the one or more data warehouses that has been updated based on the data request to a prior data warehouse state using a compensating transaction.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, where the one or more data warehouses were not successfully updated, returning the data in all the data warehouses to a prior data warehouse state using the compensating transaction.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, further comprising requesting a security module to determine whether the data request by the application is authorized.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the one or more data stores comprise a first data store and a second data store, and wherein updating the one or more data stores and determining the status of the updates further includes:
<claim-text>changing data in the first data store, the first data store maintaining data in a first format; and</claim-text>
<claim-text>failing to change data in the second data store, the second data store maintaining data in a second format,</claim-text>
<claim-text>wherein determining whether the one or more data stores were successfully updated comprises:
<claim-text>identifying that the change to the second data store failed, and</claim-text>
</claim-text>
<claim-text>wherein returning the data in the one or more data stores to a prior state using the compensating transaction comprises:
<claim-text>restoring the data in the first data store to a prior state, the prior state defined as the data in the first data store prior to the change.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein updating the one or more data warehouses further includes:
<claim-text>publishing the updates to the one or more data stores to a channel accessible by the one or more data warehouses;</claim-text>
<claim-text>subscribing to the updates by the one or more data warehouses; and</claim-text>
<claim-text>updating the transaction data store regarding the publication and subscription of the updates.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, further comprising notifying the application regarding whether the updates to the one or more data stores were successful.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, further comprising:
<claim-text>removing the transaction record from the transaction data store after the data is committed to the one or more data stores and the one or more data warehouses.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the application is further defined as a commercial-off-the-shelf software application.</claim-text>
</claim>
</claims>
</us-patent-grant>
