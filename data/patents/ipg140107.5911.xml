<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627020-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627020</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13562493</doc-number>
<date>20120731</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<us-term-of-grant>
<disclaimer>
<text>This patent is subject to a terminal disclaimer.</text>
</disclaimer>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>12</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>711152</main-classification>
</classification-national>
<invention-title id="d2e51">Security erase of a delete file and of sectors not currently assigned to a file</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6731447</doc-number>
<kind>B2</kind>
<name>Bunker et al.</name>
<date>20040500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>360 60</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>7308543</doc-number>
<kind>B2</kind>
<name>Kishi</name>
<date>20071200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>7469327</doc-number>
<kind>B2</kind>
<name>Kawamura et al.</name>
<date>20081200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>7570560</doc-number>
<kind>B2</kind>
<name>Sun et al.</name>
<date>20090800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>7571475</doc-number>
<kind>B2</kind>
<name>Moon</name>
<date>20090800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>7739462</doc-number>
<kind>B2</kind>
<name>Dewey</name>
<date>20100600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>7873870</doc-number>
<kind>B2</kind>
<name>Ohara</name>
<date>20110100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2008/0016132</doc-number>
<kind>A1</kind>
<name>Merhar</name>
<date>20080100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>22</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>7</number-of-drawing-sheets>
<number-of-figures>7</number-of-figures>
</figures>
<us-related-documents>
<continuation>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>13236220</doc-number>
<date>20110919</date>
</document-id>
<parent-grant-document>
<document-id>
<country>US</country>
<doc-number>8234462</doc-number>
<date>20120731</date>
</document-id>
</parent-grant-document>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>13562493</doc-number>
</document-id>
</child-doc>
</relation>
</continuation>
<continuation>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>12686291</doc-number>
<date>20100112</date>
</document-id>
<parent-grant-document>
<document-id>
<country>US</country>
<doc-number>8024530</doc-number>
<date>20110920</date>
</document-id>
</parent-grant-document>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>13236220</doc-number>
</document-id>
</child-doc>
</relation>
</continuation>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61144670</doc-number>
<date>20090114</date>
</document-id>
</us-provisional-application>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20120300331</doc-number>
<kind>A1</kind>
<date>20121129</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Deetz</last-name>
<first-name>Randell</first-name>
<address>
<city>Costa Mesa</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Streuter</last-name>
<first-name>Gary William</first-name>
<address>
<city>San Clemente</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Burke</last-name>
<first-name>Kenneth</first-name>
<address>
<city>Costa Mesa</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="004" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Sedin</last-name>
<first-name>James</first-name>
<address>
<city>Ketchum</city>
<state>ID</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Deetz</last-name>
<first-name>Randell</first-name>
<address>
<city>Costa Mesa</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Streuter</last-name>
<first-name>Gary William</first-name>
<address>
<city>San Clemente</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Burke</last-name>
<first-name>Kenneth</first-name>
<address>
<city>Costa Mesa</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="004" designation="us-only">
<addressbook>
<last-name>Sedin</last-name>
<first-name>James</first-name>
<address>
<city>Ketchum</city>
<state>ID</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Law Office of Scott C. Harris, Inc.</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>CMS Products, Inc.</orgname>
<role>02</role>
<address>
<city>Costa Mesa</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Nguyen</last-name>
<first-name>Hiep</first-name>
<department>2188</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Secure erase of files and unallocated sectors on storage media such that any previous data is non-recoverable. The database contains sets of data patterns used to overwrite the data on different physical media. The software programs manage the overwriting process automatically when a file has been deleted. When de-allocated sectors in the file system are pruned from a file or escaped the file deletion process also finds them. Data will never be found on deleted sectors or on pruned sectors is overwritten.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="141.65mm" wi="142.32mm" file="US08627020-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="120.90mm" wi="158.75mm" file="US08627020-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="158.75mm" wi="126.49mm" file="US08627020-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="134.79mm" wi="158.75mm" file="US08627020-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="158.75mm" wi="158.41mm" file="US08627020-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="158.75mm" wi="122.77mm" file="US08627020-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="158.75mm" wi="110.83mm" file="US08627020-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="200.24mm" wi="158.75mm" file="US08627020-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CROSS-REFERENCE</heading>
<p id="p-0002" num="0001">This application is a continuation application of U.S. patent application Ser. No. 13/236,220 filed Sep. 19, 2011, now U.S. Pat. No. 8,234,462 issued Jul. 31, 2012, which is a continuation of U.S. patent application Ser. No. 12/686,291 filed Jan. 12, 2010, now U.S. Pat. No. 8,024,530 issued Sep. 20, 2011, which claims priority from provisional application No. 61/144,670, filed Jan. 14, 2009, the disclosure of which is herewith incorporated by reference in their entirety.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">BACKGROUND</heading>
<p id="p-0003" num="0002">There has long existed a basic need for rendering old, expired, or sensitive data unreadable by forensic methodologies. Businesses routinely reformat and/or carry out other actions, such that externally attached disk drives and other storage media such that sensitive data can not be read by persons who should not have access to that data. Over the years several schemes have been designed to thwart attempts to recover data from storage devices where the files have been deleted and in some cases where the storage device itself has been reformatted. However, it is believed that it is still possible to recover sensitive classified and business data from such a hard drive.</p>
<p id="p-0004" num="0003">Typical methods of rendering data residing on storage devices unreadable involve writing different patterns over the old data. While this would seem to render the older data unrecoverable, it often is not the case. Different physical media types often do not completely switch the magnetic state of bits of the old data when written over. Sophisticated recovery techniques, therefore, can still obtain the data that has been &#x201c;deleted&#x201d; in this way.</p>
<p id="p-0005" num="0004">Generally the types of utilities that attempt to render data unrecoverable require the user to explicitly execute the program and to name the file to be security wiped or erased. Other utilities are launched on a scheduled basis and are driven by script files. Still other methodologies are in place to allow IT departments and administrators to decide when and what behavior the security erase programs are to exhibit.</p>
<heading id="h-0003" level="1">SUMMARY</heading>
<p id="p-0006" num="0005">The embodiments define ways to overcome these shortcomings for security erasing and rendering forensic attempts at recovering data unsuccessful.</p>
<p id="p-0007" num="0006">Embodiments maintain a database with optimal overwrite patterns for each type of physical media that will be security erased. The embodiments have at least two basic modes of operation. A first mode security erases files when the file is deleted by the file system. A second mode covers those cases where allocation units in the form of single sectors or clusters of sectors have been pruned from a file and thus escape the security erase at file delete time; or are sectors that were returned to a sector/cluster allocation table without being security erased due to some software or hardware design, malfunction, or failure. This mode is triggered on a cyclic or scheduled basis. The embodiments scan the sector/cluster allocation table, reading unallocated sectors and comparing the data on the sector with the final pattern used to overwrite data on that specific physical media type. If the final pattern is not present on the sector, these embodiments will initiate a security erase.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0008" num="0007">Embodiments of the embodiments are illustrated by way of example, and not by way of limitation. The following figures and the descriptions both brief and the detailed descriptions of the embodiments refer to similar elements and in which:</p>
<p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. 1</figref> depicts a sector or cluster allocation table or map.</p>
<p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. 2</figref> depicts a sector of data and 5 overwrite patterns.</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 3</figref> depicts a database with entries specific to different physical media types and specific data overwrite patterns for each physical media type.</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 4</figref> depicts the logic flow chart for a software program that is launched by the file system or operating system either just before a file is deleted or just after a file is delete such that the software program depicted by <figref idref="DRAWINGS">FIG. 4</figref> can perform a secure erase of the file.</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 5</figref> depicts the logic flow chart for a software program that is launched by the operating system on a cyclic basis such that the program can scan the allocation table or map of the storage device and perform a security erase of any unallocated sector or cluster that had not been security erased.</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 6</figref> depicts the logic flow chart for a software program that ensures that hard disk drives do not contain previously written data on the inner track areas of the disks.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 7</figref> shows a block diagram of a computer system using this technique.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0016" num="0015">The present embodiments operate a computer system of the type shown as <b>700</b> in <figref idref="DRAWINGS">FIG. 7</figref>. Boot is carried out using a processor <b>710</b> to execute the instructions in a system BIOS. There is at least one physical storage device, e.g. a hard drive <b>730</b> or solid state drive residing within said computer system or attached to said computer system through an external bus <b>735</b>. The external bus can be any of USB, IEEE-1394, E-SATA, SATA, Ethernet. The external bus can be any of a plurality of wireless links such as but not limited to 802.11. The computer runs an operating system encompassing a file system. The storage device stores information, as described herein. As conventional, the computer <b>700</b> can also have a user interface, RAM, display ports, and other conventional parts.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 1</figref> shows a representation of a sector or cluster allocation map <b>10</b> of a hard drive such as <b>730</b>. This particular map is 1,024 bits wide which represents a storage device or partition that has 1,024 sectors or 1,024 clusters. If this map represented 1,024 sectors, the storage device would be 524,288 bytes in size. These maps generally represent clusters where a single cluster may contain from one sector to many sectors. Typically a cluster would contain 16, 32, or 64 sectors. A cluster size of 64 means that each cluster is made up of 64 sectors of 32,768 bytes. If the cluster map were 1,024 bits in size, that means that the storage device contains 33,554,432 bytes. There are many trade-offs in selecting cluster sizes which are not germane to the embodiments.</p>
<p id="p-0018" num="0017">The representation of cluster maps in the following descriptions show allocated sectors/clusters as a binary &#x201c;1&#x201d; and a binary &#x201c;0&#x201d; if they are unallocated.</p>
<p id="p-0019" num="0018">The sector/cluster map <b>10</b> depicted in <figref idref="DRAWINGS">FIG. 1</figref>, <b>10</b>, contains 1,024 bits. Bit address map <b>11</b> shows the first 8 addresses and the last 8 addresses for purposes of clarity. The first sector/cluster <b>13</b> which is bit address 0000 <b>14</b> shows that sector/cluster <b>13</b> is allocated by virtue of its value being equal to &#x201c;1&#x201d;. Thus sector/cluster map <b>12</b> has the first 3 sectors/clusters allocated (value=&#x201c;1&#x201d;). Sector/cluster map <b>12</b> also shows that last bit address <b>15</b> in sector/cluster map <b>12</b> is un-allocated by virtue of its value equal to &#x201c;0&#x201d;.</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 3</figref> is a representation of a database <b>40</b> where each entry <b>42</b>, <b>43</b>, and <b>44</b> contain sets of records specific to particular types of storage media. Entry <b>3</b>; item <b>44</b>, contains specific overwrite data for media type <b>45</b>. Entry <b>3</b> also contains number of patterns <b>46</b> which specifies the number of unique overwrite patterns for this storage media type. For entry <b>3</b>; <b>44</b> there are &#x201c;n&#x201d; overwrite patterns represented by pattern <b>1</b>; <b>47</b> to pattern &#x201c;n&#x201d; <b>48</b>. When an overwrite operating is being executed, the software program <b>50</b> or <b>70</b> uses number of patterns <b>46</b> and pattern <b>1</b> <b>47</b> through pattern &#x201c;n&#x201d; <b>48</b> to ensure that overwritten data is not recoverable.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 2</figref> shows a representation <b>20</b> of a single sector of data. Sector byte address map <b>21</b> shows the byte addresses ranging from 000 <b>23</b> to 511 <b>24</b>. Note that this address map shows sector <b>22</b> which contains 512 addressable bytes of data. The first byte of data is sector address 0 <b>23</b> and the last byte of data is sector address 511 <b>26</b>. Also note that only the first 8 bytes of sector <b>22</b> and the last 8 bytes of sector <b>22</b> are shown for purposes of clarity. In <figref idref="DRAWINGS">FIG. 2</figref>, sector data is represented as hexadecimal values. Sector <b>22</b> contains the data that was written to the storage device by some application. Also shown are 5 overwrite patterns as pattern <b>1</b> <b>27</b>, pattern <b>2</b> <b>28</b>, pattern <b>3</b> <b>29</b>, pattern <b>4</b> <b>30</b>, and pattern <b>5</b> <b>31</b>. Overwrite patterns typically contain alternate bit patters. For example, pattern <b>1</b> <b>27</b> contains the hexadecimal value &#x201c;AA&#x201d; which has a binary pattern of &#x201c;1010 1010&#x201d;. Pattern <b>2</b> <b>28</b> contains the hexadecimal value &#x201c;55&#x201d; which has a binary pattern of 0101 0101&#x2033;. Note that these 2 patterns are made up of alternating bits and the bits between each pattern are different. When pattern <b>1</b> <b>27</b> is written, then pattern <b>2</b> <b>28</b> is written over pattern <b>1</b> <b>27</b>, each bit will have been written as a &#x201c;1&#x201d; and then written as a &#x201c;0&#x201d;.</p>
<p id="p-0022" num="0021">Pattern <b>3</b> <b>29</b> contains the hexadecimal value &#x201c;CC&#x201d; which has a binary pattern of &#x201c;1100 1100&#x201d;. Pattern <b>4</b> <b>30</b> contains the hexadecimal value &#x201c;33&#x201d; which has a binary pattern of 0011 0011&#x2033;. Note that these two patterns are made up of alternating groups of bits and the bits between each pattern are different. When pattern <b>3</b> <b>29</b> is written then pattern <b>4</b> <b>30</b> is written over pattern <b>3</b> <b>29</b>, each group of 2 bits will have been written as a &#x201c;1&#x201d; and then written as a &#x201c;0&#x201d;.</p>
<p id="p-0023" num="0022">Pattern <b>5</b> <b>31</b> contains the hexadecimal value &#x201c;FF&#x201d; which has a binary pattern of &#x201c;1111 1111&#x201d;. Typically a pattern with all bits in a byte being equal to &#x201c;1&#x201d; or &#x201c;0&#x201d; will be the final pattern written to the storage media.</p>
<p id="p-0024" num="0023">The patterns represented here are not to be construed as being the actual over write patterns for any physical media type. The values shown in pattern <b>1</b> <b>27</b> through pattern <b>5</b> <b>31</b> are for the purposes of explaining portions of the embodiments.</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 4</figref> shows the logic flow <b>50</b> of the file overwrite software program of the embodiments. In this flow <b>50</b>, the file system or operating system of the computer system the embodiments is running, or will call or cause software program <b>50</b> to be executed. When software program <b>50</b> is started, receive notification <b>51</b> starts the execution. Processing block <b>52</b> retrieves from the file system entry. The file system entry may have been passed to software program <b>50</b> as a function of the calling process or process block <b>52</b> may make calls to the operating system to retrieve the entry for the deleted file. Processing block <b>53</b> then retrieves the sector/cluster linked list or map of allocated sectors that had been assigned to the file that was deleted. Note that the file system may delete the file prior to calling software program <b>50</b> or may call software program <b>50</b> prior to actually deleting the file and returning the sectors/clusters to the allocation map or pool.</p>
<p id="p-0026" num="0025">Processing block <b>54</b> interrogates the operating system for the physical media type containing the sectors for the file sectors that are to be security erased. Using the media type provided by the operating system, processing block <b>55</b> accesses database <b>40</b>. Processing block <b>56</b> sets a pointer to pattern <b>1</b> <b>47</b> which is the first overwrite pattern for media type <b>45</b>. Processing block <b>57</b> retrieves the number of patterns <b>46</b> and places the number of patterns into a counter.</p>
<p id="p-0027" num="0026">The overwrite cycle starts with processing block <b>58</b> which overwrites the pattern indicated by the pointer set in processing block <b>56</b>. After the pattern has been written on all of the sectors identified by the linked list or map obtained by processing block <b>53</b>, processing block <b>59</b> will decrement the number of patterns counter set by processing block <b>57</b>. Decision block <b>60</b> checks to see if the pattern counter is equal to 0. If the pattern counter is equal to 0, then software program <b>50</b> will exit at exit point <b>61</b>. If the pattern counter is not equal to 0, processing block <b>62</b> will move the pattern pointer set by processing block <b>56</b> to the next pattern in the sequence of patterns then passes control to processing block <b>58</b> which starts the next overwrite pattern write.</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 5</figref> shows the logic flow <b>70</b> of the sector/cluster scan overwrite software program of the embodiments. In this flowchart <b>70</b>, the operating system of the computer system the will call or cause software program <b>50</b> to be executed on some cyclic basis. When software program <b>70</b> is started, start sector/cluster scan <b>71</b> is the entry point to the software program. Processing block <b>72</b> interrogates the operating system for the physical media type of the physical storage device that is to be scanned. Note that software program <b>70</b> can be run by the operating system against internal storage devices and externally attached storage devices.</p>
<p id="p-0029" num="0028">Processing block <b>72</b> obtains the physical media type from the operating system and accesses database <b>40</b> and sets a pointer to the correct entry <b>42</b>, <b>43</b>, or <b>44</b>. For this example entry <b>44</b> media type <b>45</b> matches the physical media type obtained from the operating system. Processing block <b>73</b> then retrieves the first byte of sector/cluster map for the physical storage device.</p>
<p id="p-0030" num="0029">From this point on there are three logical processing loops in software program <b>70</b>. There is a outer loop ranging from processing block <b>74</b> to decision block <b>78</b>, an inner loop ranging from processing block <b>75</b> to decision block <b>77</b>, and one side processing loop ranging from processing block <b>82</b> to processing block <b>85</b>.</p>
<p id="p-0031" num="0030">The outer loop begins with processing block <b>74</b> which loads a byte size (8 bits) bit mask with a binary pattern of &#x201c;1000 0000&#x201d;. Processing block <b>75</b> performs a logical AND of the bit mask with the current contents obtained from sector/cluster map <b>12</b> for the physical storage device. If the matching bits of sector/cluster map <b>12</b> for the physical storage device and the bit mask are both a binary &#x201c;1&#x201d;, the resulting value will be a logical TRUE Boolean value. Decision block <b>78</b> examines the resulting Boolean value. If it is true, this indicates that the sector/cluster is currently allocated. If the Boolean value is FALSE, this indicates that the sector/cluster is not allocated and control will be pasted to processing block <b>80</b>. Assuming that the resulting value of the AND function was TRUE, control will be passed to decision block <b>77</b>.</p>
<p id="p-0032" num="0031">Decision block <b>77</b> tests to see if the current bit in the bit mask is the last bit to be tested for this cycle. For this example the last bit position in the mask has the binary value of &#x201c;0000 0001&#x201d;. If this is not the case, then control is passed to processing block <b>87</b>. Processing block <b>87</b> shifts the pattern in the bit mask one position to the right. If the pattern in the bit mask prior to processing block <b>87</b> was &#x201c;0100 0000&#x201d; it will be shifted one position to the right resulting in the pattern being changed to &#x201c;0010 0000&#x201d;. After the bit mask has been shifted one position to the right, control is passed to processing block <b>75</b> which is the beginning of the inner loop.</p>
<p id="p-0033" num="0032">If decision block <b>77</b> determines that the pattern in the bit mask is &#x201c;0000 0001&#x201d;, then it decides that this was the last bit in the mask to be tested and processing falls through to decision block <b>78</b>. Decision block <b>78</b> determines if the current byte of sector/cluster map <b>12</b> being tested is the last byte of the sector/cluster map <b>12</b> control will be passed to exit point <b>79</b>. If decision block <b>78</b> determines that the current byte of sector/cluster map <b>12</b> is not the last byte in sector/cluster map <b>12</b> control will be passed to processing block <b>88</b>. Processing block <b>88</b> retrieves the next byte of the sector/cluster map and passes control to processing block <b>74</b> which is the start of the outer processing loop.</p>
<p id="p-0034" num="0033">If decision block <b>76</b> determines that the result of the AND function which tests to see if the current sector/cluster being tested with the bit mask is not allocated, control will be passed to processing block <b>80</b>. Processing block <b>80</b> accesses database <b>40</b> and sets a pointer to pattern <b>1</b> <b>47</b> which is the fist overwrite pattern for media type <b>45</b>. Processing block <b>81</b> then retrieves the number of patterns <b>46</b> and places the number into a counter.</p>
<p id="p-0035" num="0034">Processing block <b>82</b> is the first block of the side processing loop. Processing block <b>82</b> overwrites the current pattern pointed to by the pointer initially set by processing block <b>80</b> on the sector or cluster identified by the current byte of sector/bluster map <b>12</b>. After the sector or cluster identified by the current byte of sector/bluster map has been overwritten, control is passed to processing block <b>83</b>. Processing block <b>83</b> decrements the number of patterns counter set by processing block <b>81</b>.</p>
<p id="p-0036" num="0035">Decision block <b>84</b> then determines is the number of patterns remaining to be written is greater than zero.</p>
<p id="p-0037" num="0036">If the number of patterns counter is greater than zero, control is passed to processing block <b>85</b> which sets the pattern pointer initially set by processing block <b>80</b> to the next pattern.</p>
<p id="p-0038" num="0037">Decision block <b>84</b> checks to see if the pattern counter is equal to 0. If the pattern counter is equal to 0 then control is passed to decision block <b>77</b>. If the pattern counter is not equal to 0, processing block <b>85</b> will move the pattern pointer set by processing block <b>80</b> to the next pattern in the sequence of patterns then passes control to processing block <b>82</b> which starts the next overwrite pattern write.</p>
<p id="p-0039" num="0038">Another method of recovering erased or reformatted data from hard disk drives is through the use forensic tools that can micro-step the write/read heads off of the center of the track to an area that is reserved by the disk drive. This area exists between the tracks of hard disk drive to cover the case where the heads may wander off of the center line of a given track. The case also exists that is referred to as &#x201c;track creep&#x201d;. Hard disk drives have a tendency to move the track outward or inward depending on the drive. This movement is caused by wear of the various mechanical parts and assemblies in a hard disk drive. Overwriting a given track will normally only overwrite the track on the center of the track. If track creep has developed in the drive, then there exists the possibility of data remaining on the area between the tracks. <figref idref="DRAWINGS">FIG. 6</figref> shows a flow diagram <b>90</b> is intended to cover the possibility of data being present in the areas between tracks.</p>
<p id="p-0040" num="0039">Software program off-track write <b>91</b> is called by another application program such as those depicted in <figref idref="DRAWINGS">FIG. 4</figref> and <figref idref="DRAWINGS">FIG. 5</figref>. When software program off-track write is called, the calling program will pass the pattern to be written, the first sector of the sequence to be written and the number of sectors to write.</p>
<p id="p-0041" num="0040">Process block <b>92</b> commands the hard disk drive into a diagnostic mode where additional commands such as micro-step are available. Some hard disk drive may not need to be placed into a diagnostic mode in order for software program off-track write to access the hard disk's ability to be commanded to micro-step.</p>
<p id="p-0042" num="0041">Processing block <b>93</b> will command the write head of the hard disk drive to the center of the current track containing the sectors to be written. Process block <b>94</b> then writes the data pattern received from the calling software program to the specified sectors.</p>
<p id="p-0043" num="0042">Software program off-track write has two basic micro-step loops. The first loop ranges from processing block <b>96</b> to decision block <b>99</b>. This loop micro-steps the write head inward toward the hub of the hard disk drive. The second loop ranges from processing block <b>102</b> to decision block <b>105</b>. This loop micro-steps the write head outward from the center of the track toward the outer diameter of the hard disk drive.</p>
<p id="p-0044" num="0043">The first loop receives control from processing block <b>95</b> which sets the number of micro-steps of the write head. Processing block <b>96</b> commands the write head inward for a specified distance or number of steps depending on the particular hard disk drive. Processing block <b>97</b> then writes the same pattern that had been written on the same sectors on the center of the track.</p>
<p id="p-0045" num="0044">Processing block <b>98</b> then decrements the number of inner micro-steps and passes control to decision block <b>99</b>. Decision block <b>99</b> checks to see if the number of remaining micro-steps is zero. If the number of remaining micro-steps is greater than zero, it passes control to the beginning of the fist loop at processing block <b>96</b>. If the number of remaining micro-steps is zero decision block <b>99</b> passes control to processing block <b>100</b>.</p>
<p id="p-0046" num="0045">Processing block <b>100</b> will command the write head of the hard disk drive to the center of the current track containing the sectors to be written.</p>
<p id="p-0047" num="0046">The second loop receives control from processing block <b>101</b> which sets the number of micro-steps of the write head. Processing block <b>102</b> commands the write head outward for a specified distance or number of steps depending on the particular hard disk drive. Processing block <b>103</b> then writes the same pattern that had been written on the same sectors on the center of the track.</p>
<p id="p-0048" num="0047">Processing block <b>104</b> then decrements the number of outer micro-steps and passes control to decision block <b>105</b>. Decision block <b>105</b> checks to see if the number of remaining micro-steps is zero. If the number of remaining micro-steps is greater than zero it passes control to the beginning of the second loop at processing block <b>102</b>. If the number of remaining micro-steps is zero decision block <b>105</b> passes control to processing block <b>106</b>.</p>
<p id="p-0049" num="0048">Processing blocks <b>106</b> and <b>107</b> clean up the track that has just been processed, ensuring that the center of the track contains valid data in the form of the overwrite pattern. Processing block <b>106</b> will command the write head of the hard disk drive to the center of the current track containing the sectors to be written. Process block <b>107</b> then writes the data pattern received from the calling software program to the specified sectors. Control is then passed to exit off-track write <b>108</b>.</p>
<p id="p-0050" num="0049">Although only a few embodiments have been disclosed in detail above, other embodiments are possible and the inventors intend these to be encompassed within this specification. The specification describes specific examples to accomplish a more general goal that may be accomplished in another way. This disclosure is intended to be exemplary, and the claims are intended to cover any modification or alternative which might be predictable to a person having ordinary skill in the art. The present application describes use of a hard drive in a computer system, operating to execute programs. Other drives and other techniques can be supported in analogous ways.</p>
<p id="p-0051" num="0050">Those of skill would further appreciate that the various illustrative logical blocks, modules, circuits, and algorithm steps described in connection with the embodiments disclosed herein may be implemented as electronic hardware, computer software, or combinations of both. To clearly illustrate this interchangeability of hardware and software, various illustrative components, blocks, modules, circuits, and steps have been described above generally in terms of their functionality. Whether such functionality is implemented as hardware or software depends upon the particular application and design constraints imposed on the overall system. Skilled artisans may implement the described functionality in varying ways for each particular application, but such implementation decisions should not be interpreted as causing a departure from the scope of the exemplary embodiments of the embodiments.</p>
<p id="p-0052" num="0051">The various illustrative logical blocks, modules, and circuits described in connection with the embodiments disclosed herein, may be implemented or performed with a general purpose processor, a Digital Signal Processor (DSP), an Application Specific Integrated Circuit (ASIC), a Field Programmable Gate Array (FPGA) or other programmable logic device, discrete gate or transistor logic, discrete hardware components, or any combination thereof designed to perform the functions described herein. A general purpose processor may be a microprocessor, but in the alternative, the processor may be any conventional processor, controller, microcontroller, or state machine. The processor can be part of a computer system that also has a user interface port that communicates with a user interface, and which receives commands entered by a user, has at least one memory (e.g., hard drive or other comparable storage, and random access memory) that stores electronic information including a program that operates under control of the processor and with communication via the user interface port, and a video output that produces its output via any kind of video output format, e.g., VGA, DVI, HDMI, displayport, or any other form.</p>
<p id="p-0053" num="0052">A processor may also be implemented as a combination of computing devices, e.g., a combination of a DSP and a microprocessor, a plurality of microprocessors, one or more microprocessors in conjunction with a DSP core, or any other such configuration. These devices may also be used to select values for devices as described herein.</p>
<p id="p-0054" num="0053">The steps of a method or algorithm described in connection with the embodiments disclosed herein may be embodied directly in hardware, in a software module executed by a processor, or in a combination of the two. A software module may reside in Random Access Memory (RAM), flash memory, Read Only Memory (ROM), Electrically Programmable ROM (EPROM), Electrically Erasable Programmable ROM (EEPROM), registers, hard disk, a removable disk, a CD-ROM, or any other form of storage medium known in the art. An exemplary storage medium is coupled to the processor such that the processor can read information from, and write information to, the storage medium. In the alternative, the storage medium may be integral to the processor. The processor and the storage medium may reside in an ASIC. The ASIC may reside in a user terminal. In the alternative, the processor and the storage medium may reside as discrete components in a user terminal.</p>
<p id="p-0055" num="0054">In one or more exemplary embodiments, the functions described may be implemented in hardware, software, firmware, or any combination thereof. If implemented in software, the functions may be stored on or transmitted over as one or more instructions or code on a computer-readable medium. Computer-readable media includes both computer storage media and communication media including any medium that facilitates transfer of a computer program from one place to another. A storage media may be any available media that can be accessed by a computer. By way of example, and not limitation, such computer-readable media can comprise RAM, ROM, EEPROM, CD-ROM or other optical disk storage, magnetic disk storage or other magnetic storage devices, or any other medium that can be used to carry or store desired program code in the form of instructions or data structures and that can be accessed by a computer. The memory storage can also be rotating magnetic hard disk drives, optical disk drives, or flash memory based storage drives or other such solid state, magnetic, or optical storage devices. Also, any connection is properly termed a computer-readable medium. For example, if the software is transmitted from a website, server, or other remote source using a coaxial cable, fiber optic cable, twisted pair, digital subscriber line (DSL), or wireless technologies such as infrared, radio, and microwave, then the coaxial cable, fiber optic cable, twisted pair, DSL, or wireless technologies such as infrared, radio, and microwave are included in the definition of medium. Disk and disc, as used herein, includes compact disc (CD), laser disc, optical disc, digital versatile disc (DVD), floppy disk and blu-ray disc where disks usually reproduce data magnetically, while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer-readable media.</p>
<p id="p-0056" num="0055">Operations as described herein can be carried out on or over a website. The website can be operated on a server computer, or operated locally, e.g., by being downloaded to the client computer, or operated via a server farm. The website can be accessed over a mobile phone or a PDA, or on any other client. The website can use HTML code in any form, e.g., MHTML, or XML, and via any form such as cascading style sheets (&#x201c;CSS&#x201d;) or other.</p>
<p id="p-0057" num="0056">Also, the inventors intend that only those claims which use the words &#x201c;means for&#x201d; are intended to be interpreted under 35 USC 112, sixth paragraph. Moreover, no limitations from the specification are intended to be read into any claims, unless those limitations are expressly included in the claims. The computers described herein may be any kind of computer, either general purpose, or some specific purpose computer such as a workstation. The programs may be written in C, or Java, Brew or any other programming language. The programs may be resident on a storage medium, e.g., magnetic or optical, e.g. the computer hard drive, a removable disk or media such as a memory stick or SD media, or other removable medium. The programs may also be run over a network, for example, with a server or other machine sending signals to the local machine, which allows the local machine to carry out the operations described herein.</p>
<p id="p-0058" num="0057">Where a specific numerical value is mentioned herein, it should be considered that the value may be increased or decreased by 20%, while still staying within the teachings of the present application, unless some different range is specifically mentioned. Where a specified logical sense is used, the opposite logical sense is also intended to be encompassed.</p>
<p id="p-0059" num="0058">The previous description of the disclosed exemplary embodiments is provided to enable any person skilled in the art to make or use the embodiments. Various modifications to these exemplary embodiments will be readily apparent to those skilled in the art, and the generic principles defined herein may be applied to other embodiments without departing from the spirit or scope of the embodiments. Thus, the embodiments is not intended to be limited to the embodiments shown herein but is to be accorded the widest scope consistent with the principles and novel features disclosed herein.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A computer system with secure erase capabilities, comprising:
<claim-text>a processor, analyzing a file system on a physical memory media to determine data of the file system that represent file portions on the memory media which are intended to be deleted, to determine information about said physical memory media and to determine at least one but less than all of multiple different overwrite patterns will best overwrite said memory media based on said information, as at least one selected overwrite pattern, and outputting signals for writing said at least one selected overwrite pattern over said data.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The computer system as in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said processor writes multiple patterns as said at least one selected pattern by first writing a first pattern of said multiple patterns over said portions, and second writing other patterns of said multiple patterns over said portions.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The computer system as in <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein said processor includes a pattern counter, storing a value that includes a number representing a number of patterns to be written, and operates to decrement a value in said pattern counter each time one of said patterns is written.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The computer system as in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said request is for at least one file that have been indicated by a user as being deleted.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The computer system as in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said request is made by the computer system.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The computer system as in <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein said request made by the computer system is to delete areas of a file which remain when a new file is shorter than a version of the file that is older than the new file.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The computer system as in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said request is for outputting signals that command a writing head within the physical media to write said overwrite patterns at different radial locations corresponding to different offsets along a track.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. A computer system, comprising:
<claim-text>a processor, said processor operating according to a program for analyzing a file system on a physical memory media to determine portions of the file system that represent file portions on the memory media which are intended to be deleted;</claim-text>
<claim-text>said processor writing at least one pattern over said data to overwrite said file portions, by outputting signals that command a writing head within the physical media to write said at least one pattern at multiple different radial locations corresponding to different offsets along a track of said memory media.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The system as in <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein said processor operates to first determine, using said computer system, information about said physical media and second determining which at least one but less than all of multiple different overwrite patterns will best overwrite said memory media as at least one selected overwrite pattern, and said processor writing said at least one selected overwrite pattern over said data at said multiple different radial offsets.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The system as in <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein said at least one optimal overwrite pattern comprises multiple patterns to be written, and said processor operates to first write a first pattern of said multiple patterns over said portions, and second write other patterns of said multiple patterns over said portions.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The system as in <claim-ref idref="CLM-00009">claim 9</claim-ref>, further comprising a pattern counter, storing a value that includes a number representing a number of patterns to be written, and said processor operating for decrementing said value in said pattern counter each time one of said patterns is written on said portions.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. A computer system, comprising:
<claim-text>a processor, analyzing a file system on a physical memory media to determine at a first time, first areas on the physical memory representing deleted files, and to determine at a second time, second areas on the physical memory representing areas remaining when a smaller file has been saved in place of a larger file and outputting signals operating to write overwrite patterns over both of said first areas and said second areas.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The system as in <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein said processor operates to first determine information about said physical media and to second determine which at least one but less than all of multiple different overwrite patterns will best overwrite said memory media as at least one selected overwrite pattern, and said processor writing said at least one selected overwrite pattern over said data.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The system as in <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein said processor further outputting signals that command a writing head within the physical memory media to write said overwrite patterns at different radial locations corresponding to different offsets along a track.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The system as in <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein said processor operates to first determine information about said physical media and to second determine which at least one but less than all of multiple different overwrite patterns will best overwrite said memory media as at least one selected overwrite pattern, and said processor writing said at least one selected overwrite pattern over said data.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. A computer product comprising a processor and memory storing executable instructions, that when executed, implement a secure erase program, said executable instructions comprising:
<claim-text>analyzing a file system on a physical memory media to determine data of the file system that represent file portions on the memory media which are intended to be deleted, to determine information about said physical memory media;</claim-text>
<claim-text>based on said information, to determine at least one but less than all of multiple different overwrite patterns will best overwrite said memory media as at least one selected overwrite pattern; and</claim-text>
<claim-text>output signals for writing said at least one selected overwrite pattern over said data.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The product as in <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein said output signals comprises writing multiple patterns as said at least one selected pattern by first writing a first pattern of said multiple patterns over said portions, and second writing other patterns of said multiple patterns over said portions.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The product as in <claim-ref idref="CLM-00016">claim 16</claim-ref>, further comprising instructions for implementing a pattern counter, storing a value that includes a number representing a number of patterns to be written, and operating to decrement a value in said pattern counter each time one of said patterns is written.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The product as in <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein said request is for at least one file that have been indicated by a user as being deleted.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The product as in <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein said request is made by a computer system.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The product as in <claim-ref idref="CLM-00020">claim 20</claim-ref>, wherein said request made by the computer system is to delete areas of a file which remain when a new file is shorter than a version of the file that is older than the new file.</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. The product as in <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein said request is for outputting signals that command a writing head within the physical media to write said overwrite patterns at different radial locations corresponding to different offsets along a track. </claim-text>
</claim>
</claims>
</us-patent-grant>
