<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627472-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627472</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13072136</doc-number>
<date>20110325</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<us-term-of-grant>
<us-term-extension>255</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>11</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>12</main-group>
<subgroup>14</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>726 23</main-classification>
<further-classification>709223</further-classification>
<further-classification>709224</further-classification>
</classification-national>
<invention-title id="d2e53">Determining heavy distinct hitters in a data stream</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>7453922</doc-number>
<kind>B2</kind>
<name>Oates et al.</name>
<date>20081100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>375148</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>7581064</doc-number>
<kind>B1</kind>
<name>Zedlewski et al.</name>
<date>20090800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711118</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>8078710</doc-number>
<kind>B2</kind>
<name>Cormode et al.</name>
<date>20111200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709223</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2005/0131946</doc-number>
<kind>A1</kind>
<name>Korn et al.</name>
<date>20050600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>7071041</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>2008/0294604</doc-number>
<kind>A1</kind>
<name>Goswami</name>
<date>20081100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  3</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2009/0006607</doc-number>
<kind>A1</kind>
<name>Bu et al.</name>
<date>20090100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709224</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2010/0161695</doc-number>
<kind>A1</kind>
<name>Standfield et al.</name>
<date>20100600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>708202</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2011/0087779</doc-number>
<kind>A1</kind>
<name>Martin et al.</name>
<date>20110400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709224</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2011/0122792</doc-number>
<kind>A1</kind>
<name>Duffield et al.</name>
<date>20110500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370252</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2011/0173528</doc-number>
<kind>A1</kind>
<name>Zunger</name>
<date>20110700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>715234</main-classification></classification-national>
</us-citation>
<us-citation>
<nplcit num="00011">
<othercit>Bar-Yossef, et al., &#x201c;Counting Distinct Elements in a Data Stream&#x201d;, In Proc. 6th International Workshop on Randomization and Approximation Techniques (RANDOM), pp. 1-10; 2002.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00012">
<othercit>Durand, et al., &#x201c;Loglog Counting of Large Cardinalities&#x201d;; Algorithms Project, INRIA-Rocquencourt, F78153 Le Chesnay (France); pp. 605-617; 2003.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00013">
<othercit>Flajolet, et al., &#x201c;Probabilistic Counting Algorithms for Data Base Applications&#x201d;, Journal of Computer and System Sciences, 31(2): pp. 182-209; 1985.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00014">
<othercit>Ganguly, et al., &#x201c;Streaming Algorithms for Robust, Real-Time Detection of DDoS Attacks&#x201d;, In Proc. 27th International Conference on Distributed Computing Systems (ICDCS); pp. 1-25; Nov. 29, 2006.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00015">
<othercit>Giroire, &#x201c;Order Statistics and Estimating Cardinalities of Massive Data Sets&#x201d;, Discrete Applied Mathematics, 157(2): pp. 406-427; 2009.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00016">
<othercit>Venkatamaran, et al., &#x201c;New Streaming Algorithms for Fast Detection of Superspreaders&#x201d; In Proc. 12th ISOC Symposium on Network and Distributed Systems Security (NDSS), pp. 169-166; 2005.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>18</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>726 23</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>708202</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707  3</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711118</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>709223</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>709224</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>370252</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>6</number-of-drawing-sheets>
<number-of-figures>6</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20120246726</doc-number>
<kind>A1</kind>
<date>20120927</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Kind</last-name>
<first-name>Andreas</first-name>
<address>
<city>Rueschlikon</city>
<country>CH</country>
</address>
</addressbook>
<residence>
<country>CH</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Locher</last-name>
<first-name>Thomas R.</first-name>
<address>
<city>Rueschlikon</city>
<country>CH</country>
</address>
</addressbook>
<residence>
<country>CH</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Kind</last-name>
<first-name>Andreas</first-name>
<address>
<city>Rueschlikon</city>
<country>CH</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Locher</last-name>
<first-name>Thomas R.</first-name>
<address>
<city>Rueschlikon</city>
<country>CH</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Cantor Colburn LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Morris</last-name>
<first-name>Daniel</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Nguyen</last-name>
<first-name>Dustin</first-name>
<department>2446</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A method for determining a heavy distinct hitter (HDH) in a data stream by a data traffic monitor, the data stream comprising a plurality of element-value (e,v) pairs, includes receiving the plurality of (e,v) pairs from the data stream by an HDH module in the data traffic monitor, the HDH module being in communication with a counter block, the counter block comprising a plurality of hash functions, and further comprising a respective pair of distinct counting primitives associated with each hash function of the plurality of hash functions; and adding each of the plurality of (e,v) pairs to one of the distinct counting primitives of the respective pair of distinct counting primitives for each of the plurality of hash functions in the counter block.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="196.34mm" wi="160.61mm" file="US08627472-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="207.60mm" wi="159.60mm" file="US08627472-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="168.99mm" wi="177.55mm" file="US08627472-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="178.14mm" wi="184.57mm" file="US08627472-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="203.12mm" wi="183.90mm" file="US08627472-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="213.36mm" wi="187.11mm" file="US08627472-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="156.97mm" wi="169.84mm" file="US08627472-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND</heading>
<p id="p-0002" num="0001">This disclosure relates generally to the field of traffic monitoring in a computing network, and more specifically to determining heavy distinct hitters in a data stream transmitted over the computing network.</p>
<p id="p-0003" num="0002">Today's computer infrastructures are highly distributed systems where data traffic is generated at many different locations. Metering or monitoring the data traffic in such a network may be performed for such purposes as troubleshooting, planning and billing. To facilitate metering and monitoring, network routers collect flow information that may be analyzed by processing units. A processing unit may perform tasks such as flow information collection, filtering, analysis, or aggregation. Traffic metering and monitoring may also be performed for security reasons. Anomalies that may indicate security issues may be detected by monitoring a data stream. For example, a processing unit may discover a distributed denial of service (DDoS) attack by observing that a large number of different machines are sending data packets to a small number of destinations. Another network anomaly is a single machine sending data packets to a large number of different destinations, indicating that the single machine may have been compromised and is being used to disseminate a worm.</p>
<p id="p-0004" num="0003">Security problems such as a DDoS attack or worm dissemination may be detected by determining heavy distinct hitters (HDH) in the data stream. If each packet in a data stream is considered as an element-value (e,v) pair, where each element is a destination and each value is a source address, then the attacked machines in the DDoS scenario are those elements for which the number of distinct values in the observed data stream is large. Alternately, if an element is defined as a source address and a value is defined as a destination address, then the elements with the largest number of distinct values may correspond to compromised machines that are distributing a worm. The elements that occur in the data stream together with a large number of distinct values are heavy distinct hitters. It is desirable to identify the heavy distinct hitters as efficiently as possible.</p>
<p id="p-0005" num="0004">The HDH problem may be approached by finding all elements that occur in the data stream paired with a number of distinct values that is greater than or equal to a particular threshold. The number of distinct values that occur together with an element may also be determined. However, finding the exact number of HDH elements and values paired with those elements requires a processing unit to store all distinct (e,v) pairs that are received in the data stream, and check for each arriving (e,v) pair whether or not it has already been received, which may require a large amount of memory and processing power, especially at high traffic rates.</p>
<p id="p-0006" num="0005">To lower memory and processing requirements, a HDH approximation may be determined instead. For example, two parameters epsilon and delta may be defined in the range (0,1), epsilon being the allowed relative error in the estimates, and delta being the failure probability. A threshold T may also be defined as the minimum number of distinct values required for an element to be considered a heavy distinct hitter. After processing a portion of a data stream, an output set of elements that are heavy distinct hitters (i.e., occur with a number of distinct values that is greater than threshold T) may be determined and, for the elements in the set of heavy distinct hitters, the total number of distinct values that occurred with each element may be estimated. If an element is in the set of heavy distinct hitters, then the true number of distinct values that occur with this element is at least (1-epsilon)T, and if an element is not in the output set, then the true number of distinct values that occurs with this element is lower than (1+epsilon)T, and the error in the number of distinct values for all elements is at most epsilon*T. The approximation output must satisfy these conditions with probability at least 1-delta. Thus, the error is at most an epsilon fraction of the threshold T, and the whole process succeeds with probability 1-delta. Since the process succeeds most of the time, delta may be set to a much smaller value than epsilon. As delta is smaller, delta has a smaller impact on the space requirements to compute the approximate solution than epsilon. There may be an anomaly in the case in which one or a few elements occur with a larger number of distinct values than all other elements, or in other words, a few elements occur more often than a certain fraction of all distinct (e,v) pairs. For this situation, if d is the total number of distinct (e,v) pairs, the threshold T may be set to phi*d, where phi is another parameter in the range (0,1). However, approximation of HDHs in a data stream with a low epsilon and low delta with relatively low memory and processing requirements presents challenges.</p>
<heading id="h-0002" level="1">BRIEF SUMMARY</heading>
<p id="p-0007" num="0006">In one aspect, a method for determining a heavy distinct hitter (HDH) in a data stream by a data traffic monitor, the data stream comprising a plurality of element-value (e,v) pairs, includes receiving the plurality of (e,v) pairs from the data stream by an HDH module in the data traffic monitor, the HDH module being in communication with a counter block, the counter block comprising a plurality of hash functions, and further comprising a respective pair of distinct counting primitives associated with each hash function of the plurality of hash functions; and adding each of the plurality of (e,v) pairs to one of the distinct counting primitives of the respective pair of distinct counting primitives for each of the plurality of hash functions in the counter block.</p>
<p id="p-0008" num="0007">Additional features are realized through the techniques of the present exemplary embodiment. Other embodiments are described in detail herein and are considered a part of what is claimed. For a better understanding of the features of the exemplary embodiment, refer to the description and to the drawings.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS</heading>
<p id="p-0009" num="0008">Referring now to the drawings wherein like elements are numbered alike in the several FIGURES:</p>
<p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. 1</figref> is a schematic block diagram illustrating an embodiment of a data traffic monitor for determining heavy distinct hitters in a data stream.</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 2</figref> is a flowchart illustrating an embodiment of a method for processing a received element.</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 3</figref> is a flowchart illustrating an embodiment of a method for processing a received element in a counter block.</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 4</figref> is a flowchart illustrating an embodiment of a method for determining a number of distinct values received with an element.</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 5</figref> is a flowchart illustrating an embodiment of a method for determining a number of distinct values received with an element in a counter block.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 6</figref> is a schematic block diagram illustrating an embodiment of a computer that may be used in conjunction with data traffic monitor for determining heavy distinct hitters in a data stream.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0016" num="0015">Embodiments of a data traffic monitor for determining heavy distinct hitters (HDH) in a data stream are provided, with exemplary embodiments being discussed below in detail. A set of counter blocks in the data traffic monitor process (e,v) pairs as they are received from the data stream, and a relatively accurate estimate of the number of distinct values observed with a particular element in the data stream is determined using the counter blocks. Each counter block includes a set of hash functions, and each hash function is associated with two distinct counting primitives. Relatively low processing power and storage space may be required by the data traffic monitor to approximate the HDHs in the data stream with a relatively low error and good probability of success, and the data stream may have a relatively high data rate.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 1</figref> illustrates an embodiment of a data traffic monitor <b>100</b>. Data traffic monitor <b>100</b> includes a HDH module <b>102</b> that processes a plurality of element-value (e,v) pairs that are received in a data stream, as indicated by exemplary (e,v) pairs <b>101</b>A-E. HDH module <b>102</b> is in communication with a plurality of counter blocks CB<sub>1 </sub>to CB<sub>N</sub>, indicated by blocks <b>103</b>A-N. A detailed view of an exemplary counter block CB<sub>2 </sub>is shown. A counter block, such as counter block CB<sub>2</sub>, includes M hash functions H<sub>1 </sub>to H<sub>M</sub>, indicated by blocks <b>104</b>A-M. Each hash function H<sub>1 </sub>to H<sub>M </sub>is associated with two respective distinct counting primitives: a C<sub>0 </sub>distinct counting primitive from the set of distinct counting primitives indicated by blocks <b>104</b>A-M, and a C<sub>1 </sub>distinct counting primitive from the set of distinct counting primitives indicated by blocks <b>106</b>A-M. The hash functions H<sub>1 </sub>to H<sub>M </sub>are pseudo-random hash functions that, given an input element e, may return one of two hash results, 0 or 1. The same input element always returns the same hash result from a particular hash function. The two possible hash results from a hash function each map to one of the respective distinct counting primitives C<sub>0 </sub>and C<sub>1 </sub>that are associated with the hash function. For example, as shown in <figref idref="DRAWINGS">FIG. 1</figref>, for the (e,v) pair <b>101</b>C, hash function H<sub>1 </sub>(<b>104</b>A) maps e to its C<sub>0 </sub>(<b>105</b>A), hash function H<sub>2 </sub>(<b>104</b>B) maps e to its C<sub>0 </sub>(<b>105</b>B), hash function H<sub>3 </sub>(<b>104</b>C) maps e to its C<sub>1 </sub>(<b>106</b>C), and hash function H<sub>M </sub>(<b>104</b>M) maps e to its C<sub>1 </sub>(<b>106</b>M). The data traffic monitor <b>100</b> may include any appropriate number N of counter blocks, and each counter block may include any appropriate number M of hash functions, with one distinct counting primitive C<sub>0 </sub>and one distinct counting primitive C<sub>1 </sub>per hash function, i.e., the number of hash functions M may be different for different counter blocks.</p>
<p id="p-0018" num="0017">The distinct counting primitives C<sub>0 </sub>or C<sub>1 </sub>indicated by blocks <b>104</b>A-M and <b>106</b>A-M may be instances of any appropriate distinct counting primitive that may be used for distinct counting. Each distinct counting primitive C<sub>0 </sub>or C<sub>1 </sub>includes an add operation for processing received (e,v) pairs, and a return operation that returns the number of distinct items that have been added to the distinct counting primitive. The add operation receives the current (e,v) pair as an input; a call to the add operation may take the form of add((e,v)). The return operation does not require any inputs, and a call to the return operation may take the form of getNum().</p>
<p id="p-0019" num="0018">Processing of received (e,v) pairs by data traffic monitor <b>100</b> is described in further detail with respect to methods <b>200</b> and <b>300</b> of <figref idref="DRAWINGS">FIGS. 2-3</figref>. Method <b>200</b> may be implemented in HDH module <b>102</b>, and method <b>300</b> may be implemented separately in each of counter blocks CB<sub>1 </sub>to CB<sub>N</sub>. As shown in <figref idref="DRAWINGS">FIG. 2</figref>, in block <b>201</b>, parameter i is set to 1. Parameter i is used to step through counter blocks CB<sub>1 </sub>to CB<sub>N</sub>. In block <b>202</b>, counter block CB<sub>i </sub>is updated with the current (e,v) pair, which is described in further detail with respect to method <b>300</b> of <figref idref="DRAWINGS">FIG. 3</figref>. In block <b>203</b>, i is incremented by 1, and in block <b>204</b>, it is determined if i is less than or equal to the number of counter blocks N. If i is less than or equal to N, blocks <b>202</b> and <b>203</b> are repeated for each of counter blocks CB<sub>1 </sub>to CB<sub>N </sub>until i is greater than N and each of CB<sub>1 </sub>to CB<sub>N </sub>is updated with the current (e,v) pair (for example, (e,v) pair <b>101</b>C of <figref idref="DRAWINGS">FIG. 1</figref>).</p>
<p id="p-0020" num="0019">Method <b>300</b> of <figref idref="DRAWINGS">FIG. 3</figref> describes updating a counter block with the current (e,v) pair as is performed in block <b>202</b>, and is performed individually in each of counter blocks CB<sub>1 </sub>to CB<sub>N</sub>. In block <b>301</b>, a parameter j is set to 1. Parameter j is used to step through all the hash functions H<sub>1 </sub>to H<sub>M </sub>in the counter block. In block <b>302</b>, a parameter q is set equal to the hash output by hash function H<sub>j </sub>for the element e of the current (e,v) pair, i.e., q=H<sub>j</sub>(e). The hash function H<sub>j </sub>returns either 1 or 0, and therefore q is 1 or 0. Therefore, distinct counting primitive C<sub>q </sub>is one of the two distinct counting primitives C<sub>0 </sub>or C<sub>1 </sub>that are associated with H<sub>j</sub>. Because the hash functions H<sub>1 </sub>to H<sub>M </sub>always return the same respective output for the same input, all (e,v) pairs that include element e are added to the distinct counting primitive C<sub>q </sub>associated with H<sub>j </sub>as they are received. In block <b>303</b>, (e,v) is added the distinct counting primitive C<sub>q </sub>associated with H<sub>j</sub>. The C<sub>q </sub>associated with H<sub>j </sub>may process (e,v) by calling the distinct counting primitive add function with the input parameter (e,v), i.e., add((e,v)). After the current (e,v) pair is added to distinct counting primitive C<sub>q </sub>associated with hash function H<sub>j</sub>, j is incremented by 1 in block <b>304</b>, and, if j is determined to be is less than or equal to the number M of hash functions in the counter block in block <b>305</b>, blocks <b>302</b>, <b>303</b>, and <b>304</b> are repeated until j is greater than M, and the current (e,v) pair is added to one pseudo-randomly selected distinct counting primitive for each hash function H<sub>1 </sub>to H<sub>M </sub>in the counter block.</p>
<p id="p-0021" num="0020">To determine whether an element e is a HDH in the data stream, methods <b>400</b> and <b>500</b> of <figref idref="DRAWINGS">FIGS. 4 and 5</figref> are implemented in HDH module <b>102</b> and counter blocks CB<sub>1 </sub>to CB<sub>N</sub>, respectively. In block <b>401</b>, set X is initialized to an empty set. In block <b>402</b>, parameter i is set to 1. Parameter i is used to step through counter blocks CB<sub>1 </sub>to CB<sub>N</sub>. In block <b>403</b>, CB<sub>i </sub>returns an estimate x<sub>i </sub>of the number of distinct values that have been observed in the data stream paired with the element e; this is described in further detail below with respect to method <b>500</b> of <figref idref="DRAWINGS">FIG. 5</figref>. In block <b>404</b>, the estimate x<sub>i </sub>returned by CB<sub>i </sub>in block <b>403</b> is added to set X. In block <b>405</b>, i is incremented by 1, and in block <b>406</b>, it is determined if i is less than or equal to the total number of counter blocks N. If i is less than or equal to N, blocks <b>403</b>, <b>404</b>, and <b>405</b> are repeated until i is greater than N and each of CB<sub>1 </sub>to CB<sub>N </sub>has returned an estimate x, for element e, and all the returned estimates x<sub>i </sub>have been added to set X. Then, in block <b>407</b>, the median of set X is determined, which gives an overall estimate of the number of distinct values that have been observed in the data stream paired with the element e. If the median of set X is over a threshold T, then element e is determined to be a HDH in the data stream.</p>
<p id="p-0022" num="0021">Determination of x<sub>i </sub>for the element e in block <b>403</b> of <figref idref="DRAWINGS">FIG. 4</figref> is discussed in further detail with respect to <figref idref="DRAWINGS">FIG. 5</figref>. Each individual counter block CB<sub>1 </sub>to CB<sub>N </sub>implements method <b>500</b> of <figref idref="DRAWINGS">FIG. 5</figref>. In block <b>501</b>, a parameter j is set to 1, and a parameter c is set to 0. Parameter j is used to step through all the hash functions H<sub>1 </sub>to H<sub>M </sub>in a counter block. In block <b>502</b>, a parameter q is set equal to the hash given by H<sub>j </sub>for the element e, i.e., q=H<sub>j</sub>(e). The hash function H<sub>j </sub>returns either 1 or 0, and therefore q is 1 or 0. Therefore, distinct counting primitive C<sub>q </sub>is one of the two distinct counting primitives C<sub>0 </sub>or C<sub>1 </sub>that are associated with H<sub>j</sub>. Because a hash function always returns the same output for the same input, all (e,v) pairs that include element e were added to the distinct counting primitive C<sub>q </sub>associated with H<sub>j</sub>. In block <b>503</b>, the output of the return function (i.e., getNum()) for distinct counting primitive C<sub>q </sub>associated with H<sub>j </sub>is added to c, and the output of the return function (i.e., getNum()) for the other distinct counting primitive associated with H<sub>j</sub>, C<sub>1-q </sub>(i.e., the distinct counting primitive to which (e,v) pairs that include element e were not added by H<sub>j</sub>) is subtracted from c. Parameter j is incremented by 1 in block <b>504</b>, and, if j is determined to be is less than or equal to the number of hash functions M in the counter block in block <b>505</b>, blocks <b>502</b>, <b>503</b>, and <b>504</b> are repeated until j is greater than M, and each of H<sub>1 </sub>to H<sub>M</sub>, have added getNum()of their distinct counting primitive C<sub>q </sub>to c and subtracted getNum() of their distinct counting primitive C<sub>1-q </sub>from c. Then, in block <b>506</b>, the counter block returns c divided by the number of hash functions M as estimate x<sub>i </sub>of the number of distinct values that have been observed in the data stream paired with the element e, which is added to set X by HDH module <b>102</b> as discussed above in block <b>404</b>.</p>
<p id="p-0023" num="0022">In an exemplary embodiment, a distinct counting primitive, which may be any of the distinct counting primitives indicated by blocks <b>105</b>A-M and <b>106</b>A-M, may store k hash values, h<sub>1 </sub>to h<sub>k</sub>. These hash values are sorted, i.e., h<sub>1</sub>&#x3c;=h<sub>2</sub>&#x3c;= . . . h<sub>k</sub>. Initially, all the hash values h<sub>1 </sub>to h<sub>k </sub>may be set to infinity. The distinct counting primitive may further include a single pseudo-random hash function that maps a received input to a hash output in the range (0, 1) uniformly at random. The same input is always hashed to the same hash output by the distinct counting primitive hash function. The add function may be implemented as follows. The add function receives the current (e,v) pair as an input, and the hash output of (e,v) is determined by the distinct counting primitive hash function. The hash function will always return the same hash output for the same input, and will return different hash outputs for (e,v) pairs that have the same element but different values. Hash value h<sub>k </sub>is then set equal to the hash output of (e,v) if the hash output of (e,v) is less than h<sub>k</sub>. When the value of h<sub>k </sub>changes, the hash values h<sub>1 </sub>to h<sub>k </sub>are reordered so that they are sorted, i.e., h<sub>1</sub>&#x3c;=h<sub>2</sub>&#x3c;= . . . h<sub>k</sub>, such that the k smallest hash values that are encountered are kept. The return function getNum()may be implemented by returning the number of the hash values h<sub>1 </sub>to h<sub>k </sub>that are not set to infinity, which is the correct number of distinct (e,v) pairs processed by the hash function unless there was a hash collision, which occurs with negligible probability. However, in the case where all of hash values h<sub>1 </sub>to h<sub>k </sub>are not infinity, (k&#x2212;1)/h<sub>k </sub>is returned, which is an unbiased estimate of the correct number of distinct (e,v) pairs processed by the add function. The number of hash values h<sub>1 </sub>to h<sub>k </sub>may be greater than or equal to 3 in some embodiments. Such a distinct counting primitive is discussed in further detail in F. Giroire, &#x201c;Order Statistics and Estimating Cardinalities of massive Data Sets&#x201d;, Discrete Applied Mathematics, 157(2):406-427, 2009, which is herein incorporated by reference in its entirety. The above distinct counting primitive implementation is discussed for exemplary purposes only; any appropriate distinct counting primitive having functionality for adding distinct items and for returning a number of distinct items that were added to the distinct counting primitive may be used for distinct counting primitives C<sub>0 </sub>or C<sub>1 </sub>that are indicated by blocks <b>104</b>A-M and <b>106</b>A-M of <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0024" num="0023">If the parameters epsilon, delta, and phi are relatively small, e.g., epsilon &#x2266;0.1, delta &#x2266;0.1, and phi &#x2266;0.5 and the total number of distinct elements e in the data stream, which is upper bounded by the number of distinct element-value pairs d, which in turn is upper bounded by the length of the data stream, is also not too large, e.g., smaller than 100 million, if the number of counter blocks N is about N:=2*ln(10/(delta*phi)) and the number of hash functions M and associated distinct counting primitive pairs C<sub>0 </sub>and C<sub>1 </sub>in each counter block is about M:=22/(epsilon*phi)^2, and an element e is determined to be a HDH when the median of the set X determined by the data traffic monitor <b>100</b> for the element e is at least the threshold T, then data traffic monitor <b>100</b> determines accurate approximations independent of the distribution of the data stream. In the case that the parameters epsilon, delta, and phi are close to 1 and the number of distinct elements is extremely large, the number of counter blocks N can be set to 2*ln(L/delta), where L is an estimated upper bound on the number of distinct elements e. In some embodiments, the parameter L may be adapted over time to a number that is computed from a moving average function, such as exponentially weighted moving average (EWMA), of the actual total number of distinct elements in previous observation periods. The given values for N and M ensure that the relative error is epsilon for a threshold of T=phi*d with probability at least 1-delta. In most cases, the space requirements for data traffic monitor <b>100</b> depends on selection of the parameters epsilon, delta, and phi. Even if the data stream contains an exceedingly large number of distinct elements, the space requirements grow only logarithmically with the number of distinct (e,v) pairs d, which means that HDH system <b>100</b> is suitable for very large data streams.</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 6</figref> illustrates an example of a computer <b>600</b> which may be utilized by exemplary embodiments of a data traffic monitor for determining heavy distinct hitters in a data stream as embodied in software. Various operations discussed above may utilize the capabilities of the computer <b>600</b>. One or more of the capabilities of the computer <b>600</b> may be incorporated in any element, module, application, and/or component discussed herein.</p>
<p id="p-0026" num="0025">The computer <b>600</b> includes, but is not limited to, PCs, workstations, laptops, PDAs, palm devices, servers, storages, and the like. Generally, in terms of hardware architecture, the computer <b>600</b> may include one or more processors <b>610</b>, memory <b>620</b>, and one or more input and/or output (I/O) devices <b>670</b> that are communicatively coupled via a local interface (not shown). The local interface can be, for example but not limited to, one or more buses or other wired or wireless connections, as is known in the art. The local interface may have additional elements, such as controllers, buffers (caches), drivers, repeaters, and receivers, to enable communications. Further, the local interface may include address, control, and/or data connections to enable appropriate communications among the aforementioned components.</p>
<p id="p-0027" num="0026">The processor <b>610</b> is a hardware device for executing software that can be stored in the memory <b>620</b>. The processor <b>610</b> can be virtually any custom made or commercially available processor, a central processing unit (CPU), a digital signal processor (DSP), or an auxiliary processor among several processors associated with the computer <b>600</b>, and the processor <b>610</b> may be a semiconductor based microprocessor (in the form of a microchip) or a macroprocessor.</p>
<p id="p-0028" num="0027">The memory <b>620</b> can include any one or combination of volatile memory elements (e.g., random access memory (RAM), such as dynamic random access memory (DRAM), static random access memory (SRAM), etc.) and nonvolatile memory elements (e.g., ROM, erasable programmable read only memory (EPROM), electronically erasable programmable read only memory (EEPROM), programmable read only memory (PROM), tape, compact disc read only memory (CD-ROM), disk, diskette, cartridge, cassette or the like, etc.). Moreover, the memory <b>620</b> may incorporate electronic, magnetic, optical, and/or other types of storage media. Note that the memory <b>620</b> can have a distributed architecture, where various components are situated remote from one another, but can be accessed by the processor <b>610</b>.</p>
<p id="p-0029" num="0028">The software in the memory <b>620</b> may include one or more separate programs, each of which comprises an ordered listing of executable instructions for implementing logical functions. The software in the memory <b>620</b> includes a suitable operating system (O/S) <b>650</b>, compiler <b>640</b>, source code <b>630</b>, and one or more applications <b>660</b> in accordance with exemplary embodiments. As illustrated, the application <b>660</b> comprises numerous functional components for implementing the features and operations of the exemplary embodiments. The application <b>660</b> of the computer <b>600</b> may represent various applications, computational units, logic, functional units, processes, operations, virtual entities, and/or modules in accordance with exemplary embodiments, but the application <b>660</b> is not meant to be a limitation.</p>
<p id="p-0030" num="0029">The operating system <b>650</b> controls the execution of other computer programs, and provides scheduling, input-output control, file and data management, memory management, and communication control and related services. It is contemplated by the inventors that the application <b>660</b> for implementing exemplary embodiments may be applicable on all commercially available operating systems.</p>
<p id="p-0031" num="0030">Application <b>660</b> may be a source program, executable program (object code), script, or any other entity comprising a set of instructions to be performed. When a source program, then the program is usually translated via a compiler (such as the compiler <b>640</b>), assembler, interpreter, or the like, which may or may not be included within the memory <b>620</b>, so as to operate properly in connection with the O/S <b>650</b>. Furthermore, the application <b>660</b> can be written as an object oriented programming language, which has classes of data and methods, or a procedure programming language, which has routines, subroutines, and/or functions, for example but not limited to, C, C++, C#, Pascal, BASIC, API calls, HTML, XHTML, XML, ASP scripts, FORTRAN, COBOL, Perl, Java, ADA, .NET, and the like.</p>
<p id="p-0032" num="0031">The I/O devices <b>670</b> may include input devices such as, for example but not limited to, a mouse, keyboard, scanner, microphone, camera, etc. Furthermore, the I/O devices <b>670</b> may also include output devices, for example but not limited to a printer, display, etc. Finally, the I/O devices <b>670</b> may further include devices that communicate both inputs and outputs, for instance but not limited to, a NIC or modulator/demodulator (for accessing remote devices, other files, devices, systems, or a network), a radio frequency (RF) or other transceiver, a telephonic interface, a bridge, a router, etc. The I/O devices <b>670</b> also include components for communicating over various networks, such as the Internet or intranet.</p>
<p id="p-0033" num="0032">If the computer <b>600</b> is a PC, workstation, intelligent device or the like, the software in the memory <b>620</b> may further include a basic input output system (BIOS) (omitted for simplicity). The BIOS is a set of essential software routines that initialize and test hardware at startup, start the O/S <b>650</b>, and support the transfer of data among the hardware devices. The BIOS is stored in some type of read-only-memory, such as ROM, PROM, EPROM, EEPROM or the like, so that the BIOS can be executed when the computer <b>600</b> is activated.</p>
<p id="p-0034" num="0033">When the computer <b>600</b> is in operation, the processor <b>610</b> is configured to execute software stored within the memory <b>620</b>, to communicate data to and from the memory <b>620</b>, and to generally control operations of the computer <b>600</b> pursuant to the software. The application <b>660</b> and the O/S <b>650</b> are read, in whole or in part, by the processor <b>610</b>, perhaps buffered within the processor <b>610</b>, and then executed.</p>
<p id="p-0035" num="0034">When the application <b>660</b> is implemented in software it should be noted that the application <b>660</b> can be stored on virtually any computer readable medium for use by or in connection with any computer related system or method. In the context of this document, a computer readable medium may be an electronic, magnetic, optical, or other physical device or means that can contain or store a computer program for use by or in connection with a computer related system or method.</p>
<p id="p-0036" num="0035">The application <b>660</b> can be embodied in any computer-readable medium for use by or in connection with an instruction execution system, apparatus, or device, such as a computer-based system, processor-containing system, or other system that can fetch the instructions from the instruction execution system, apparatus, or device and execute the instructions. In the context of this document, a &#x201c;computer-readable medium&#x201d; can be any means that can store, communicate, propagate, or transport the program for use by or in connection with the instruction execution system, apparatus, or device. The computer readable medium can be, for example but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, device, or propagation medium.</p>
<p id="p-0037" num="0036">More specific examples (a nonexhaustive list) of the computer-readable medium may include the following: an electrical connection (electronic) having one or more wires, a portable computer diskette (magnetic or optical), a random access memory (RAM) (electronic), a read-only memory (ROM) (electronic), an erasable programmable read-only memory (EPROM, EEPROM, or Flash memory) (electronic), an optical fiber (optical), and a portable compact disc memory (CDROM, CD R/W) (optical). Note that the computer-readable medium could even be paper or another suitable medium, upon which the program is printed or punched, as the program can be electronically captured, via for instance optical scanning of the paper or other medium, then compiled, interpreted or otherwise processed in a suitable manner if necessary, and then stored in a computer memory.</p>
<p id="p-0038" num="0037">In exemplary embodiments, where the application <b>660</b> is implemented in hardware, the application <b>660</b> can be implemented with any one or a combination of the following technologies, which are well known in the art: a discrete logic circuit(s) having logic gates for implementing logic functions upon data signals, an application specific integrated circuit (ASIC) having appropriate combinational logic gates, a programmable gate array(s) (PGA), a field programmable gate array (FPGA), etc.</p>
<p id="p-0039" num="0038">The technical effects and benefits of exemplary embodiments include a relatively accurate estimation of heavy distinct hitters in a data stream with relatively low processing and storage requirements by a data traffic monitor.</p>
<p id="p-0040" num="0039">The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein, the singular forms &#x201c;a&#x201d;, &#x201c;an&#x201d;, and &#x201c;the&#x201d; are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms &#x201c;comprises&#x201d; and/or &#x201c;comprising,&#x201d; when used in this specification, specify the presence of stated features, integers, steps, operations, elements, and/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, elements, components, and/or groups thereof.</p>
<p id="p-0041" num="0040">The corresponding structures, materials, acts, and equivalents of all means or step plus function elements in the claims below are intended to include any structure, material, or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description, but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>The invention claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for determining a heavy distinct hitter (HDH) in a data stream by a data traffic monitor, the data stream comprising a plurality of element-value (e,v) pairs, the method comprising:
<claim-text>receiving the plurality of (e,v) pairs from the data stream by an HDH module in the data traffic monitor, the HDH module being in communication with a counter block, the counter block comprising a plurality of hash functions, and further comprising a respective pair of distinct counting primitives associated with each hash function of the plurality of hash functions; and</claim-text>
<claim-text>adding each of the plurality of (e,v) pairs to one of the distinct counting primitives of the respective pair of distinct counting primitives for each of the plurality of hash functions in the counter block.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein a hash function comprises a pseudo-random hash function that returns one of two possible hash results in response to an input, wherein the two possible hash results each map to a respective distinct counting primitive of the pair of distinct counting primitives associated with the hash function, and wherein the hash function always returns the same hash result for the same input.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising adding an (e,v) pair to a distinct counting primitive based on the hash result from the hash function in response to the element e as an input.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein a distinct counting primitive is further configured to return a number of distinct (e,v) pairs that have been added to the distinct counting primitive.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, further comprising determining an estimate of a number of distinct values observed with an element e in the data stream by the counter block, wherein determining an estimate of a number of distinct values observed with the element e in the data stream comprises:
<claim-text>for each hash function of the plurality of hash functions, adding, to a total, the number of distinct (e,v) pairs that have been added to the distinct counting primitive associated with the hash function that is indicated by the hash result given by the hash function in response to the element e as an input, and subtracting, from the total, the number of distinct (e,v) pairs that have been added to the distinct counting primitive associated with the hash function that is not indicated by the hash result given by the hash function in response to the element e as an input;</claim-text>
<claim-text>dividing the total by the number of hash functions in the counter block to determine an estimate of a number of distinct values observed with the element e in the data stream; and</claim-text>
<claim-text>returning the estimate to the HDH module.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein HDH module is in communication with a plurality of counter blocks, and wherein each of the plurality of counter blocks returns an estimate of a number of distinct values observed with the element e in the data stream to the HDH module.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref>, further comprising determining a median of the estimates received from the plurality of counter blocks by the HDH module, and in the event the median is greater than a threshold, determining that the element e is a HDH in the data stream.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein an element of an (e,v) pair represents a source address, and a value of an (e,v) pair represents a destination address.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein an element of an (e,v) pair represents a destination address, and a value of an (e,v) pair represents a source address.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. A method for determining a heavy distinct hitter (HDH) in a data stream by a data traffic monitor, the data stream comprising a plurality of element-value (e,v) pairs, the method comprising:
<claim-text>receiving an (e,v) pair of the plurality of (e,v) pairs from the data stream by an HDH module in the data traffic monitor, the HDH module being in communication with a counter block, the counter block comprising a plurality of hash functions and a plurality of pairs of distinct counting primitives, wherein each pair of distinct counting primitives is associated with a single respective hash function of the plurality of hash functions, and each of the plurality of hash functions is associated with a single pair of distinct counting primitives of the plurality of pairs of distinct counting primitives; and</claim-text>
<claim-text>for each hash function of the plurality of hash functions:
<claim-text>selecting a distinct counting primitive of the pair of distinct counting primitives associated with the hash function based on the received (e,v) pair; and</claim-text>
<claim-text>adding the (e,v) pair to the selected distinct counting primitive.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein each hash function of the plurality of hash functions comprises a pseudo-random hash function that returns one of two possible hash results in response to an input, wherein each hash function always returns the same hash result for the same input; and
<claim-text>wherein each of the two possible hash results for each hash function of the plurality of hash functions maps to selection of a respective one of the pair of distinct counting primitives that are associated with the hash function.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein each of the plurality of (e,v) pairs are added to a selected distinct counting primitive of the respective pair of distinct counting primitives based on the hash result that is returned based on inputting the element e to the respective hash function that is associated with the pair of distinct counting primitives.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein each distinct counting primitive of the plurality of pairs of distinct counting primitives is configured to return a number of distinct (e,v) pairs that have been added to the distinct counting primitive.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, further comprising determining an estimate of a number of distinct values v paired with a particular element e in the data stream by the counter block, wherein determining the estimate of the number of distinct values v paired with the particular element e in the data stream comprises:
<claim-text>initializing a total to zero;</claim-text>
<claim-text>for each hash function of the plurality of hash functions:
<claim-text>adding, to the total, a number of distinct (e,v) pairs that have been added to a first distinct counting primitive of the pair of distinct counting primitives associated with the hash function, wherein the first distinct counting primitive is mapped to a hash result that is returned by the hash function in response to inputting the particular element e to the hash function; and</claim-text>
<claim-text>subtracting, from the total, the number of distinct (e,v) pairs that have been added to a second distinct counting primitive of the pair of distinct counting primitives, wherein the second distinct counting primitive is not mapped to the hash result that is returned by the hash function in response to inputting the particular element e to the hash function;</claim-text>
</claim-text>
<claim-text>dividing the total by the number of the plurality of hash functions in the counter block to determine an estimate for the counter bock of the number of distinct values observed with the particular element e in the data stream; and</claim-text>
<claim-text>returning the estimate from the counter block to the HDH module.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein HDH module is in communication with a plurality of counter blocks, and wherein each of the plurality of counter blocks returns a respective estimate of a number of distinct values observed with the particular element e in the data stream to the HDH module.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The method of <claim-ref idref="CLM-00015">claim 15</claim-ref>, further comprising determining a median of the estimates received from the plurality of counter blocks by the HDH module, and in the event the median is greater than a threshold, determining that the particular element e is a HDH in the data stream.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein an element of an (e,v) pair represents a source address, and a value of an (e,v) pair represents a destination address.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein an element of an (e,v) pair represents a destination address, and a value of an (e,v) pair represents a source address. </claim-text>
</claim>
</claims>
</us-patent-grant>
