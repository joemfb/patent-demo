<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08626964-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08626964</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13333181</doc-number>
<date>20111221</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<us-term-of-grant>
<us-term-extension>115</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>13</main-group>
<subgroup>28</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>710 22</main-classification>
<further-classification>345503</further-classification>
</classification-national>
<invention-title id="d2e53">Method of transferring data, a method of processing data, an accelerator, a computer system and a computer program</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5708849</doc-number>
<kind>A</kind>
<name>Coke et al.</name>
<date>19980100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710 22</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5894560</doc-number>
<kind>A</kind>
<name>Carmichael</name>
<date>19990400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>5928339</doc-number>
<kind>A</kind>
<name>Nishikawa</name>
<date>19990700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710 26</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6006287</doc-number>
<kind>A</kind>
<name>Wakazu</name>
<date>19991200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710 22</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>6105075</doc-number>
<kind>A</kind>
<name>Ghaffari</name>
<date>20000800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710  5</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>7496699</doc-number>
<kind>B2</kind>
<name>Pope et al.</name>
<date>20090200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710 52</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>7533195</doc-number>
<kind>B2</kind>
<name>Hayden</name>
<date>20090500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710 22</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>7631115</doc-number>
<kind>B2</kind>
<name>King</name>
<date>20091200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710 22</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2005/0033874</doc-number>
<kind>A1</kind>
<name>Futral et al.</name>
<date>20050200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710 22</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2011/0078342</doc-number>
<kind>A1</kind>
<name>Siddabathuni et al.</name>
<date>20110300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710 22</main-classification></classification-national>
</us-citation>
</us-references-cited>
<number-of-claims>5</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>5</number-of-drawing-sheets>
<number-of-figures>11</number-of-figures>
</figures>
<us-related-documents>
<continuation>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>12636906</doc-number>
<date>20091214</date>
</document-id>
<parent-status>PENDING</parent-status>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>13333181</doc-number>
</document-id>
</child-doc>
</relation>
</continuation>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20120159013</doc-number>
<kind>A1</kind>
<date>20120621</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Dimond</last-name>
<first-name>Robert Gwilym</first-name>
<address>
<city>London</city>
<country>GB</country>
</address>
</addressbook>
<residence>
<country>GB</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Dimond</last-name>
<first-name>Robert Gwilym</first-name>
<address>
<city>London</city>
<country>GB</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Conley Rose, P.C.</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Maxeler Technologies, Ltd.</orgname>
<role>03</role>
<address>
<city>London</city>
<country>GB</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Mamo</last-name>
<first-name>Elias</first-name>
<department>2184</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">The invention provides a method of transferring data from a data array within a main memory of a computer to an accelerator for processing, the embodiment of the method comprising: at the accelerator, requesting data from the main memory and generating a data stream between the main memory and the accelerator, the generated data stream including data from the data array; and, using an offset to determine the scheduling of array elements within the generated data stream.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="121.92mm" wi="141.31mm" file="US08626964-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="226.23mm" wi="174.33mm" file="US08626964-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="192.62mm" wi="162.39mm" file="US08626964-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="241.89mm" wi="179.41mm" file="US08626964-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="215.56mm" wi="175.18mm" file="US08626964-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="207.35mm" wi="133.69mm" file="US08626964-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<p id="p-0002" num="0001">This application is a continuation of, and claims the benefit of, co-pending application Ser. No. 12/636,906, filed Dec. 14, 2009, titled &#x201c;A Method of Transferring Data, A Method of Processing Data, An Accelerator, A Computer System and A Computer Program,&#x201d; which application is incorporated herein by reference as if reproduced in full below.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">FIELD OF INVENTION</heading>
<p id="p-0003" num="0002">The invention relates to a method of transferring data from a main memory of a computer to an accelerator for processing, a method of processing data using an accelerator, a method of processing a data-set on a computer, an accelerator for connection to a main computer, a computer system and a computer program.</p>
<p id="p-0004" num="0003">In embodiments, the invention relates to a technical method and apparatus that can be used to solve numerical problems over a large data-set on a bus-connected accelerator.</p>
<heading id="h-0002" level="1">BACKGROUND</heading>
<p id="p-0005" num="0004">In many current applications data-sets of significant size are generated and need to be processed. For example, in oil and gas exploration where mapping of a surface such as an ocean floor is required, typically a grid of sensors, distributed over a very large area, might be used to collect data to help in the search for hydrocarbon reserves. A sonic impulse is provided and each of the sensors serves to measure reflection from the surface or sub-surface being mapped. This might include measuring, at each sensor, the frequency, amplitude and delay of the received signals. Ocean based surveys typically use 30,000 sensors to record data over a 120 dB range each being sampled at more than 2 kbps, with new sonic impulses every 10 seconds. The volume of data generated with such a system is significant, typically of the order of terabytes of data each day. Similar sized (or larger) data-sets might be generated in other applications too where a physical process is modelled. For example in areas such as fluid flow modelling or financial data modelling the size of the data-set can be very large indeed.</p>
<p id="p-0006" num="0005">Accelerators are known for use with computers to enable them to process such data-sets. An example of a known accelerator is the Maxeler MAX2 PCI Express Card. Typically an accelerator includes a field-programmable gate array (FPGA), designed to be configured by the customer or designer after manufacture. The FPGA configuration is generally specified using a hardware description language (HDL), and it is known that such devices can be used to implement any logical function that an ASIC could perform.</p>
<p id="p-0007" num="0006">Conventionally, in use, whilst processing such a data-set, a substantial portion of the data-set is transferred to and from the accelerator on each iteration. Numerical solutions typically involve many such iterations. A typical data-set size approaches the maximum memory capacity of current state-of-the-art computers.</p>
<p id="p-0008" num="0007">The accelerator computes an iteration by streaming data from the data-set through a compute pipeline. In some cases it might be that part of the compute operation is performed by the processor of the computer and not by the accelerator. In the example of a 3D convolution operation, the boundary conditions and/or special encoding or decoding of the data-set may be performed by the computer's own processor whilst the majority of the computation required to complete the convolution calculation is performed on the accelerator.</p>
<heading id="h-0003" level="1">SUMMARY</heading>
<p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. 1</figref> shows a simplified schematic representation of a computer system <b>2</b>. A main computer <b>1</b> is provided. Many components of the main computer <b>1</b> are not shown for simplicity, but it will be understood that all features of a conventional computer system might be included. The computer <b>1</b> includes a central processing unit CPU <b>4</b> connected to a main computer memory <b>6</b> via a bus <b>8</b>. In addition, the computer system <b>2</b> includes an accelerator <b>10</b> which typically includes an FPGA. Such a system might be used for solving numerical problems and may be defined as a bus-connected accelerator. The accelerator operates on a data-set in main memory via a DMA (Direct Memory Access) engine <b>16</b>. The accelerator <b>10</b> includes a compute pipeline <b>12</b> that contains buffering <b>14</b> to organise the required data items for a compute operation. The accelerator might be a separate component connected via an external bus to the main computer <b>1</b> or might be a chip or card inserted as part of the main computer.</p>
<p id="p-0010" num="0009">Although in theory such devices are known and work acceptably, as data rates increase and the size of data-sets on which operations are performed also increase, improvements are desired.</p>
<p id="p-0011" num="0010">One particular problem arises where there is a need to maximise the rate of data transfer over the bus (thereby to minimise the data-set transfer time between the computer and the accelerator) and also where there is a desire to minimise the complexity of the accelerator hardware dedicated to data transfer. As large data sets are often transferred over the bus in each iteration some means by which the amount of data transferred in each iteration can be limited, without compromising functionality is desired.</p>
<p id="p-0012" num="0011">The desire to minimise the complexity of the accelerator hardware dedicated to data transfer is particularly important where the data transfer hardware contends for the same resource(s) as the compute hardware of the accelerator. The FPGA typically contains three types of resources: LUTs (look up tables), registers and Block RAM. Data transfer hardware and compute hardware both contend for these same three resources.</p>
<p id="p-0013" num="0012">The problem arises in particular where the computation to be executed by the accelerator involves more than one data array from software. Operating on different elements from the same array requires buffering of a set length &#x2018;N&#x2019; so that while element A[0] is on the output of the buffer A[N] is at the input to the buffer.</p>
<p id="p-0014" num="0013">With multiple data arrays interleaved, all arrays must be buffered by the same amount to line up the correct elements. Buffering is a limited resource on-chip, i.e. on the accelerator chip, and thus limits the maximum problem size the accelerator is able to deal with and the number of parallel compute pipelines. <figref idref="DRAWINGS">FIG. 2</figref> shows schematically part of an accelerator and in particular the compute process thereof. The compute process includes a DMA engine <b>16</b> arranged to receive data from two sources, data arrays Data A <b>18</b> and Data B <b>20</b>. In this particular example, the pipeline is arranged to execute the calculation
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>B[</i>0]*(<i>A[</i>0<i>]+A[N]*</i>2+<i>A[N+M]*</i>3)<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0015" num="0014">where N and M are the buffer lengths.</p>
<p id="p-0016" num="0015">Thus, the array Data B <b>20</b> needs to be delayed by N+M buffers (shown shaded) to line up the data items as the first calculation to be performed requires values for B[0] and A[N+M] (also A[0] and A[N]). The array Data B <b>20</b> must be delayed even if the computation does not need access to previous elements of array Data B <b>20</b> and hence the buffering is wasted. This is because the calculation cannot start with element B[0] until the accelerator has in its buffers the value of the element A[N+M]. Data from, in this case, both arrays are transferred over the bus to the accelerator causing significant use of the limited bus resource.</p>
<p id="p-0017" num="0016">There are known accelerators. U.S. Pat. No. 6,006,287 discloses use of interleaved multiple streams using a single DMA controller to remove the overhead of interleaving streams in software when using a single DMA engine. U.S. Pat. No. 5,894,560 discloses the use of interleaved multiple DMA channels using a single controller for favourable cost/performance using multiple IO devices with a single controller.</p>
<p id="p-0018" num="0017">According to a first aspect of embodiments of the invention, there is provided a method of transferring data from a data array within a main memory of a computer to an accelerator for processing, the method comprising; at the accelerator, requesting data from the main memory and generating a data stream between the main memory and the accelerator, the generated data stream including data from the data array; and, using an offset to determine the scheduling of array elements within the generated data stream.</p>
<p id="p-0019" num="0018">The invention in an embodiment provides a method of DMA data transfer between a main computer and an accelerator in which the accelerator is arranged to generate a data stream including data obtained by the DMA operation from the main memory. The use of offsets to determine the scheduling of array elements in the generated data stream means that the accelerator does not need to include the same buffers for storage of data that would previously have been required to perform certain types of operation. In the specific non-limiting case of a convolution between two data arrays stored in a computer main memory to which, in use, the accelerator might be connected, the accelerator does not include buffers for storing values from the data-sets. Rather the accelerator includes offsetting capability so that the data does not need to be stored in sequence in buffers in the accelerator but instead it is able to access data in the memory and provide it at the offset position within the generated data stream. In other words, instead of simply taking data from the front of the main memory data queues when the accelerator computation first starts, and then having to store it in buffers and/or send padding bytes over the bus, the accelerator is arranged to use offsets within the generated stream to ensure that data is sent to the accelerator just as it is required. It will be appreciated that the term &#x201c;array elements&#x201d; refers to units of data that might be transferred into the generated data stream on its way to the accelerator from the one or more data arrays. The array elements may be single bytes of data or pages of data from the array, or indeed any other appropriate unit or amount of data.</p>
<p id="p-0020" num="0019">In an embodiment, where multiple arrays are interleaved for the purpose of DMA transfer using a single channel, the offset of an array is the position in the interleaved data of the first page of that array. The need for buffering the array on the accelerator is thus obviated whilst enabling the transfer to start at any desired position within the stored array. The use of the bus is reduced by the use of an offset since the transmission of padding data bytes over the bus is obviated.</p>
<p id="p-0021" num="0020">It is generally desired to minimise the software overhead of data transfer between the CPU and the accelerator. This is the same as the consideration related to the need to maximise the rate of data transfer over the bus discussed above where software overhead is the bottleneck for data transfer. However, it includes the desire to free CPU resource for other compute operations. In addition, it is desirable to minimise the total compute time for an iteration, including data transfer time and accelerator compute time.</p>
<p id="p-0022" num="0021">Setting up the DMA operation incurs some software overhead. During this set-up operation, the DMA engine and accelerator <b>10</b> are idle. In cases where the computation occurs by repeated DMA of data through the accelerator, the set-up software overhead is critical to the entire computation. Thus, as the performance of the accelerator increases, the set-up time becomes a significant bottleneck to the speedup and operation of the accelerator. This can be understood by reference to <figref idref="DRAWINGS">FIG. 3</figref>, which shows schematically the duration of each compute iteration as performed by the accelerator. For each compute iteration it is necessary to transfer the data-set to and from the accelerator. Setting up the transfer takes some software set-up. The iteration time is the sum of the software set-up and transfer time.</p>
<p id="p-0023" num="0022">According to a second aspect of embodiments of the invention, there is provided a method of processing data using an accelerator arranged to receive data from a main memory and execute an operation on the data to process it, the method comprising; requesting a data transfer from the main memory to the accelerator; upon receipt of the data transfer request at the accelerator generating and storing a list of the memory locations of requested data; and upon receipt of a subsequent data transfer request accessing the stored list and, if the corresponding location is already present in the list, commencing the DMA transfer without generating a new list of memory locations.</p>
<p id="p-0024" num="0023">The stored list can be provided locally, i.e. on the accelerator, or alternatively as part of the main memory.</p>
<p id="p-0025" num="0024">In an alternative, a stored list is not used. Rather, the user explicitly re-sends data from the same array and re-cycles the scatter/gather list.</p>
<p id="p-0026" num="0025">A further problem arises where it is desired to minimise the total compute time for iteration, including data transfer time, accelerator compute time and CPU compute time. There are situations in which a compute operation will require, as well as operation of the accelerator, operation of the host or main computer <b>1</b> CPU <b>4</b>. A problem thus arises when the CPU <b>4</b> performs some of the computation for an iteration and that computation is dependent upon data from the accelerator. The CPU compute is dependent upon output data from the accelerator and the input data for the next iteration on the accelerator is dependent upon the CPU compute. As performance of the accelerator increases, the CPU time becomes a significant bottleneck to the speedup of the accelerator.</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 4</figref> shows a schematic representation of the duration of each compute iteration as performed by the accelerator and the CPU of the host system. Each compute iteration transfers the data-set to and from the accelerator. Controlling and setting up the transfer takes some software set-up. The iteration time is the sum of the software set-up, the transfer time and the CPU compute time. An example of such a situation is a 3 dimensional convolution. The computation of boundary elements is extremely complex and would usually be done by the main CPU and not the logic (e.g. FPGA) of the accelerator. In practice, due to the complexity and speed of operation of the processor, this part of the process can take as long as the entire accelerator computation process, generating a factor of 2 increase in the whole operation time.</p>
<p id="p-0028" num="0027">According to a third aspect of embodiments of the invention, there is provided a method of processing a data-set on a computer having a central processing unit for processing data, using an accelerator coupled to the computer, the accelerator including a programmable logic device for processing the data-set, the method comprising: processing in parallel data of the data-set on the main computer CPU and the accelerator.</p>
<p id="p-0029" num="0028">Accordingly, in contrast to known system where there is a strict series relationship between the operation of an accelerator and the CPU with the processing of a data-set, in the present method, processing of the data-set between the main computer CPU and the accelerator is performed in parallel such that the overall time for processing the data can be comparatively reduced.</p>
<p id="p-0030" num="0029">The reason for computing the boundary elements on the CPU is their complexity. The reason that the boundary computation on CPU can take as long as the accelerator (even though there is much less data) is due to the fact that the CPU is typically 100 to 200 times slower than the accelerator. In a 3D convolution example, a typical mesh size is 1000&#xd7;1000&#xd7;1000 (10<sup>9 </sup>points). There are 1000&#xd7;1000&#xd7;6 boundary points corresponding to the 6 faces of the cube, so computation of these points corresponds to a little over half a percent of the total amount of computation.</p>
<p id="p-0031" num="0030">The CPU computes about 0.5% (6&#xd7;10<sup>6</sup>/10<sup>9</sup>) of the points at approx 0.5% of the speed, and so takes as long as the accelerator per time-step.</p>
<p id="p-0032" num="0031">Preferably, the method according to the third aspect comprises setting a marker in the data set such that upon reaching the marker the central processing unit of the main computer is activated to process data.</p>
<p id="p-0033" num="0032">In one non-limiting example, the processing comprises the execution of a 3 dimensional convolution, in which the boundary conditions of the convolution are performed by the central processing unit of the main computer. Whereas conventionally doing such an operation using an accelerator it would have been necessary to perform all the processing of the non-boundary region and then once this had been done, then do all the boundary regions, using the present method the boundary regions can be computed at stages in parallel during the computation of the non-boundary regions such that the overall process time is reduced.</p>
<p id="p-0034" num="0033">Preferably, one or more markers or milestones are set when an edge of the volume being convolved is reached.</p>
<p id="p-0035" num="0034">In all of the first three aspects of embodiments of the invention methods are provided for increasing the efficiency and/or speed of operation of, or data transfer to or from, an accelerator for use with a computer system having a main memory.</p>
<p id="p-0036" num="0035">According to a fourth aspect of embodiments of the invention, there is provided a computer program, optionally stored on a computer readable medium, which when run on a programmable logic device provided on an accelerator causes the accelerator to execute the method of any of the first to third aspect of the invention.</p>
<p id="p-0037" num="0036">According to a fifth aspect of embodiments of the invention, there is an accelerator for connection to a main computer having a central processing unit and main computer memory including at least one data array, the accelerator including logic to execute a computation process and being arranged to generate a data stream including data from the data array within the main memory, the accelerator comprising: a logic device arranged to be programmed to execute a desired computation process; and a device driver arranged to control the request of data from a main memory of a computer to which, in use, the accelerator is connected, the driver being arranged to do one or more of the following: (a) using an offset to determine the scheduling of array elements within the generated data stream; (b) upon receipt of the DMA data transfer request at the accelerator generating in the accelerator a list of the memory locations of requested data; copying the list to a stored list; and upon subsequent DMA data transfer request accessing the stored list and, if the corresponding location is already present, commencing the DMA transfer without generating a new list of memory locations; and, (c) set a marker in the compute pipeline of the accelerator such that upon reaching the marker the central processing unit of the main computer is activated to process data returning from the accelerator.</p>
<p id="p-0038" num="0037">According to a sixth aspect of embodiments of the invention, there is provided a computer or computer system arranged to perform the method of any of the first to third aspects of the invention. In one aspect, there is provided a computer system, including: a computer having main memory and a central processing unit; and an accelerator according to the fifth aspect of the invention.</p>
<p id="p-0039" num="0038">Any of the features provided by the dependent claims may be provided in combination with any one or more other of such features together with the features of one or more of the independent claims.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0040" num="0039">Embodiments of the invention will now be described by way of example with reference to the accompanying drawings, in which:</p>
<p id="p-0041" num="0040"><figref idref="DRAWINGS">FIG. 1</figref> shows a schematic representation of a computer system;</p>
<p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. 2</figref> shows schematically part of an accelerator and in particular the compute process thereof;</p>
<p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. 3</figref> shows schematically the duration of a compute iteration as performed by an accelerator system;</p>
<p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. 4</figref> shows a simplified view of a schematic representation of the duration of each compute iteration as performed by the accelerator and the CPU of the host system;</p>
<p id="p-0045" num="0044"><figref idref="DRAWINGS">FIG. 5</figref> shows schematically part of an accelerator and in particular the compute process thereof;</p>
<p id="p-0046" num="0045"><figref idref="DRAWINGS">FIGS. 6A and 6B</figref> show the steps in a scatter gather process;</p>
<p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. 7</figref> shows a schematic time progression of a compute process using an embodiment of the invention;</p>
<p id="p-0048" num="0047"><figref idref="DRAWINGS">FIG. 7A</figref> shows a schematic representation of a three-dimensional volume;</p>
<p id="p-0049" num="0048"><figref idref="DRAWINGS">FIG. 8</figref> shows a detailed schematic representation of the data flow path using an accelerator according to an embodiment of the invention; and,</p>
<p id="p-0050" num="0049"><figref idref="DRAWINGS">FIG. 9</figref> shows a schematic representation of data pages of a data transfer.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0051" num="0050"><figref idref="DRAWINGS">FIG. 5</figref> shows schematically part of an accelerator and in particular the compute process thereof. The accelerator <b>24</b>, like the accelerator shown in and described above with reference to <figref idref="DRAWINGS">FIG. 2</figref>, is arranged perform a convolution of two data-sets, Data A <b>26</b> and Data B <b>28</b> from within memory (not shown) on a main computer <b>1</b>. The accelerator <b>24</b> includes a DMA engine <b>30</b> to control data flow between the accelerator <b>24</b> and the data sources Data A <b>26</b> and Data B <b>28</b> which might be the memory of a host system (not shown in detail). It will be appreciated that the data transfer between the main computer <b>1</b> and the accelerator <b>24</b> will typically be via a data bus on the main computer as shown in <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0052" num="0051">In contrast to the example of <figref idref="DRAWINGS">FIG. 2</figref>, in this case the accelerator does not include buffers for storing values from the data-set B. Rather the DMA engine <b>30</b> includes offsetting capability so that data from the data-set B does not need to be stored in sequence in buffers in the accelerator. Instead, the DMA engine is able to access data from the host memory and, using the offsets, provide this into the generated data stream at a required position. Instead of simply taking data from the front of the queues <b>26</b> and <b>28</b> when the accelerator computation first starts, the DMA engine is arranged to use offsets within the generated data stream. This means that it is not necessary to transmit padding bytes over the bus as it would have been previously. It will be appreciated that in <figref idref="DRAWINGS">FIG. 5</figref> the generation of a data stream e.g. an interleaved data stream, is not shown explicitly. The generation of a data stream is explained in detail below with reference to <figref idref="DRAWINGS">FIG. 8</figref>.</p>
<p id="p-0053" num="0052">In known systems, the compute pipeline contains buffers to line up data items from different data arrays (streams). Buffering is essential to look ahead in the stream to compute with data items at different offsets. Such a need arises where a convolution is performed for example.</p>
<p id="p-0054" num="0053">In an example of the present system, as will be described in detail below with reference to <figref idref="DRAWINGS">FIG. 8</figref>, the accelerator functions by generating a data stream. Where more than one array is to be processed, the generated data stream is interleaved. The generated stream is made up of component streams and each component stream has an offset set in the device driver. The device driver schedules DMA so that the transfer of each array starts after the offset. One component stream has an offset of zero to start the overall transfer. The DMA engine transfers data according to the schedule and inserts dummy data (typically zeros) to pad the data up to the offset. There is no transfer of dummy or &#x201c;padding&#x201d; data over the bus.</p>
<p id="p-0055" num="0054">Thus, in effect, the buffers for Data Array B are pushed from the accelerator memory to main memory. Accelerator memory is costly whereas main memory is already used to store the array. Referring again to <figref idref="DRAWINGS">FIG. 5</figref>, the accelerator is set-up to perform the function
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>B[</i>0]*(<i>A[</i>0<i>]+A[N]</i>*2<i>+A[N+M]*</i>3)<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0056" num="0055">Previously N and M were the buffer lengths necessary to store the values for the B array that are necessary to perform the compute. This is because the first value to be output from the accelerator requires as inputs both the values B[0] and A[N+M] (and also A[N] and A[0]). In other words even though, as far as the B factor is concerned the computation can start as soon as the first entry is received from the host memory, it must wait until all values for A up to A[N+M] are stored in the accelerator until it can start to compute. Conventionally, plural dummy bytes would have been transmitted over the bus so that within the generated stream, there was some data to fill the slots corresponding to the padded component stream. Thus, memory is used in the accelerator for storing values of B that are not actually needed for the first calculations. The value of B[N+M] would not in fact be needed until the value A[2(N+M)] is used by the accelerator. The use of offsets within the DMA driver addresses this problem since convolution can start on the first cycle as soon as A[N+M] is available and no buffering is needed for the values of B. The dummy data that may well still be needed in the accelerator compute pipeline is generated on board the accelerator and so its transmission does not utilise the scarce resource of the system bus.</p>
<p id="p-0057" num="0056">The scheduling of data, the DMA operation, the use of component streams and the formation of the generated data stream will be described in greater detail below with reference to <figref idref="DRAWINGS">FIG. 8</figref>. It will be understood that technical advance as described with reference to <figref idref="DRAWINGS">FIG. 5</figref> is the use of one or more offsets to reduce the memory requirements of an accelerator and to reduce the pressure or competition for resource on the bus connecting the accelerator and the main computer.</p>
<p id="p-0058" num="0057">As explained above, it is generally desired to minimise the software overhead of data transfer between the CPU and the accelerator and also to minimise the total compute time for an iteration, including data transfer time, accelerator compute time and, where appropriate, CPU compute time.</p>
<p id="p-0059" num="0058">As is well known, Direct Memory Access (DMA) allows certain hardware subsystems within a computer to access system memory for reading and/or writing independently of the central processing unit. &#x201c;Scatter/gather&#x201d; DMA allows the transfer of data to and from multiple memory areas in a single DMA transaction and may be thought of as the connecting together of multiple simple DMA requests. Scatter/gather DMA allows the transfer in a single operation of data to/from user memory areas that are non-contiguous in physical memory due to virtual memory paging. Setting up the DMA operation incurs some software overhead. During this set-up operation, the DMA engine and accelerator <b>10</b> are idle.</p>
<p id="p-0060" num="0059">In known systems, each scatter/gather DMA operation requires software overhead to lock pages in physical memory and generate a scatter/gather list. <figref idref="DRAWINGS">FIG. 6A</figref> shows a schematic representation of such a system. As can be seen, at step <b>32</b> a user starts a DMA process by generating a DMA request. Next, at step <b>34</b>, the pages of main memory that include the addresses to be accessed in the DMA operation are locked. At step <b>36</b>, a scatter/gather list is generated. The scatter gather list includes in it the pointers to and sizes of data that are to be transferred. Finally, at step <b>38</b>, the DMA process is performed. In the case of an accelerator, as would be expected, frequent DMA processes are required.</p>
<p id="p-0061" num="0060"><figref idref="DRAWINGS">FIG. 6B</figref> shows a schematic representation of the steps in a scatter/gather process according to an embodiment of the invention. In this case, once a scatter/gather list has been created, at step <b>37</b> a cache list is created which includes all the pointers that are used in the DMA process. The pages in main memory are kept locked. Then, for subsequent DMA transfers the cache list is checked for a transfer with the same address/size. If the transfer hits the cache, i.e. there is an entry in the cache that corresponds to the transfer request, then it is possible to skip directly to the actual DMA transfer (the dotted path in <figref idref="DRAWINGS">FIG. 6B</figref>). If there is a cache miss, i.e. there is no entry in the cache that corresponds to the transfer request, then the process proceeds as in <figref idref="DRAWINGS">FIG. 6A</figref>.</p>
<p id="p-0062" num="0061">Thus, with reference to <figref idref="DRAWINGS">FIG. 6B</figref>, at step <b>40</b>, a user starts a DMA process. Next, at step <b>42</b> before the step of locking pages and a check is made of the stored cached scatter gather list. If there is a hit, i.e. indicating a request for repeated transfer of a data-set stored in the same location then, the DMA is simply performed. If there is a miss, then the steps <b>34</b> to <b>38</b> are repeated. The embodiment of the invention is based on the recognition that if a process is repeatedly performing a to or from the same locations in main memory the software overhead of set-up can be avoided. The need to recalculate the scatter/gather pointer lists is obviated in such cases. This significantly reduces the software overhead associated with a scatter/gather DMA process.</p>
<p id="p-0063" num="0062">In use, upon receipt of a first DMA data transfer request at the accelerator a list of the memory locations of requested data is generated in the accelerator. The generated list is then copied to local memory, e.g. to a local cache. The locally stored list can then be used as a look up table for future DMA requests. What this means that if a subsequent DMA request is in respect of data with the same address and size, then the already generated cached list can be used to execute the DMA transfer. There is no need to repeat the process of generating the scatter/gather list. The generation of the scatter/gather list can be software and processing intensive so a significant efficiency improvement can be made.</p>
<p id="p-0064" num="0063">As explained above, a further problem arises where it is desired to minimise the total compute time for iteration, including data transfer time, accelerator compute time and CPU compute time. In some situations a compute operation will require, as well operation of the accelerator, also operation of the host CPU. Where there is cross-dependency, i.e. the accelerator and the input data for the next iteration on the accelerator is dependent upon the CPU compute, the CPU time can provide a significant bottleneck and detrimental factor to speedup of the accelerator.</p>
<p id="p-0065" num="0064"><figref idref="DRAWINGS">FIG. 7</figref> shows a schematic representation of the time taken for a compute process that uses both an accelerator and also a host CPU. As explained above, in many such cases the total time taken for a single iteration is the sum of the set-up time, the time for the accelerator to do its processing and then the time taken for the host processor to do its processing. As can be seen in <figref idref="DRAWINGS">FIG. 7</figref>, in this example, the processing of the CPU is split up into discrete blocks that are interspersed with the accelerator processing. Thus the accelerator and the host CPU operate in parallel as opposed to in a strictly series manner.</p>
<p id="p-0066" num="0065">One way this can be achieved is by the setting of milestones within the accelerator process such that when a certain part of the processing has been done by the accelerator the values can be returned to the host CPU which can then do the corresponding part of its processing. This way, instead of waiting for an entire data-set to be processed by the accelerator before the CPU can operate, the host CPU can work in parallel with the accelerator. In effect this may be thought of as breaking the data-set into smaller parts with the use of appropriate milestones which means that when the final part of accelerator processing has been performed, the processing then required of the main computer CPU is significantly less.</p>
<p id="p-0067" num="0066">Thus, whereas in known systems, the CPU must wait until the data transfer is complete. In the present system, the CPU compute is split into chunks. Each chunk of CPU compute is started when the required data is available, in parallel with the rest of the data transfer.</p>
<p id="p-0068" num="0067"><figref idref="DRAWINGS">FIG. 7A</figref> shows a schematic representation of a three-dimensional volume on which is to be performed a 3D convolution by the accelerator. The volume represent a three-dimensional array of values and may, for example, comprise the results of a three-dimensional seismic survey as described above. The volume <b>60</b> may be thought of as being made up of an inner volume <b>62</b> and an outer &#x201c;case&#x201d; <b>64</b>. The outer case <b>64</b> includes all the components of the volume that are at the boundary of the volume <b>60</b>. In other words if each element of the volume <b>60</b> is itself cuboid, the &#x201c;boundary elements&#x201d; are those that share a surface with the surface of the volume <b>60</b> as a whole.</p>
<p id="p-0069" num="0068">The data transfer direction <b>66</b> indicates the direction that data is transferred to the accelerator from the host computer <b>1</b>. The inner cube <b>62</b> contains the values that are computed on the accelerator. The boundary case <b>64</b> contains the values that are computed on the host computer CPU <b>4</b>. In this example, the boundary computations are performed on the CPU and the inner cube computations are performed on the accelerator. Conventionally, to perform the boundary computations it would be necessary to wait until the data transfer of the inner cube <b>62</b> to the accelerator is complete.</p>
<p id="p-0070" num="0069">However, as can be seen, once the data transfer of the inner cube reaches the milestone &#x201c;Milestone <b>1</b>&#x201d;, the processor has sufficient data to perform the boundary computations for the first region of the volume <b>60</b>. Thus, in effect, the CPU compute operation is split into chunks and each chunk of the CPU computation is started when the required data is available, in parallel with the rest of the data transfer. This means that by the time the data transfer of the inner cube is completed, i.e. reaches Milestone <b>3</b> in <figref idref="DRAWINGS">FIG. 7A</figref> the boundary computations up to the point &#x201c;Milestone <b>2</b>&#x201d; have already been performed. There is therefore a relatively smaller amount of computation to be done at that stage by the CPU to complete the 3D convolution.</p>
<p id="p-0071" num="0070"><figref idref="DRAWINGS">FIG. 8</figref> shows a detailed schematic representation of the data flow path using an accelerator according to an embodiment of the invention.</p>
<p id="p-0072" num="0071">One suitable accelerator for carrying out the process improvements described above will now be described in detail. In a particular preferred embodiment, the accelerator typically includes three components:</p>
<p id="p-0073" num="0072">1. Software device driver.</p>
<p id="p-0074" num="0073">2. Hardware DMA engine.</p>
<p id="p-0075" num="0074">3. Hardware de-multiplexer</p>
<p id="p-0076" num="0075"><figref idref="DRAWINGS">FIG. 8</figref> shows the detailed operation of these components.</p>
<p id="p-0077" num="0076">As can be seen, in this specific example, data is being transferred from three data arrays Data A <b>44</b>, Data B <b>46</b> and Data C <b>48</b> for processing by the accelerator. The data arrays Data A <b>44</b>, Data B <b>46</b> and Data C <b>48</b> are stored in main, i.e. host, memory <b>49</b>. A device driver <b>50</b> is provided which might typically be implemented in software as part of the accelerator. The device driver <b>50</b> serves to generate an interleaved DMA schedule <b>51</b> of data which is used to produce one or more data streams <b>55</b> to be sent to the hardware, e.g. the FPGA, of the accelerator for processing. In the transfer of data a single interleaved or &#x201c;generated&#x201d; stream of data <b>56</b> is transferred from the main memory <b>49</b> to the accelerator. Later on in the operation and for the accelerator compute process(es), the stream is split up into component streams in dependence on the array from which each individual data element is retrieved.</p>
<p id="p-0078" num="0077">A hardware DMA engine <b>52</b> is provided to perform interleaved DMA requests from the arrays Data A <b>44</b>, Data B <b>46</b> and Data C <b>48</b> in main memory <b>49</b>. The DMA engine <b>52</b> is coupled either directly or via some intermediate structure to the main memory <b>49</b> such that upon receipt of and in dependence on the DMA schedule <b>51</b>, it is able to perform the data transfer <b>56</b> of data from the arrays <b>44</b>, <b>46</b> and <b>48</b> in the main memory. A de-multiplexer <b>54</b> is arranged to receive a multiplexed &#x201c;interleaved&#x201d; data stream <b>53</b> from the hardware DMA engine <b>52</b>.</p>
<p id="p-0079" num="0078">In use, when a DMA process is to occur, user software <b>47</b> calls the device driver with pointers to data arrays. Thus, the user software on the host informs the accelerator as to the data that is to be the subject of the DMA transfer. The user software calls the device driver (using a system call) with pointers to one or more of the arrays in main memory. Each array has an associated byte offset and size. The offset may be used such that buffers for one or more of the arrays <b>44</b>, <b>46</b> and <b>48</b> can be dispensed with further downstream as explained above with reference to <figref idref="DRAWINGS">FIG. 5</figref>. The offset is the point in the overall DMA transfer that the transfer of this array should start. In other words, the offset is the point in the overall DMA transfer (the interleaved stream) that a given array corresponding to a component stream starts.</p>
<p id="p-0080" num="0079">The size is the amount of data to transfer.</p>
<p id="p-0081" num="0080">As shown in <figref idref="DRAWINGS">FIG. 8</figref>, multiple arrays are interleaved for the purpose of DMA transfer using a single channel. The single channel represented schematically by the sequence <b>56</b> of data pages is made up of data from each of the arrays <b>44</b>, <b>46</b> and <b>48</b> in the main memory. An offset is used for one or more of the arrays which is the position in the interleaved data sequence <b>56</b> of the first page of that array.</p>
<p id="p-0082" num="0081">For example, assume there are three arrays (A, B and C) and that they are interleaved. Assume also for the sake of this particular example, that each page of each of the arrays A/B/C is 100 bytes. If the offsets of A,B,C are all zero, they can be interleaved A,B,C,A,B,C,A,B,C and so on. Suppose that an offset of B=200 and an offset for C=400. The data transferred in the lead stream (A) must be &#x3e;200 before any pages of B are transferred and &#x3e;400 before any pages of C are transferred. So A,A,B,A,B,A,B,C,A,B,C is now a valid interleave. To explain why it is valid, consider the amount of the lead stream transferred at each point:</p>
<p id="p-0083" num="0082">A(100),A(200),B,A(300),B,A(400),B,C,A,B,C.</p>
<p id="p-0084" num="0083">The motivation for offsetting is to send data to the accelerator just as it is required, to reduce the amount of buffering needed on the accelerator. The nature of computations such as 3D convolution is that they require the first item of each array at different times. In the example above, without the use of buffering to perform the same calculation the additional buffering requirement would have been 100 bytes for B and 300 bytes for C. So that the interleaved data stream can still be generated in the same way as previously the &#x201c;vacant&#x201d; slots that would have been used for the first entry from B and the first 3 entries for C are stuffed with zeroes, or other such dummy data, on the accelerator. Previously, these slots would also have been &#x201c;vacant&#x201d; in that the data from B and C would not have been sent until it was needed, but the zeroes, or other such dummy data, would have been transferred over the bus to the accelerator. This would use up the resource of bus bandwidth. The present system enables both a reduction in the buffering on the accelerator without increasing the bandwidth requirement on the system bus.</p>
<p id="p-0085" num="0084">Preferably, the target computer or host has a virtual memory system, so that these arrays are broken into pages and distributed about physical memory in a non-contiguous fashion. A typical page size is 4 Kbytes. The host operating system performs demand paging, swapping unused pages out to a disk.</p>
<p id="p-0086" num="0085">Next, the device driver <b>50</b> locates the pages associated with the user array(s) that are to be the subject of the DMA and locks them in physical memory so that the operating system cannot swap them out.</p>
<p id="p-0087" num="0086">Next, the device driver <b>50</b> generates a DMA schedule <b>51</b>. The device driver <b>50</b> generates a DMA schedule <b>51</b> for the user arrays. The input preferably includes the offset, size and list of pages for each array. The output schedule is a set of DMA descriptors. Each descriptor is a list of page addresses with a target stream id. A descriptor has associated first size (size of the first page transfer), last size (size of the last page transfer) and number of valid entries (up to 512).</p>
<p id="p-0088" num="0087">The user array is stored in physical memory as a partial page at the start, N whole pages and finally a partial page at the end. The first and last sizes are the size of the partial pages at the start/end. The N intermediate pages are all transfers of page size (a constant). A number of pages, address of each page and size of the first/last pages is sufficient information to transfer any array in main memory. This is shown schematically in <figref idref="DRAWINGS">FIG. 9</figref>.</p>
<p id="p-0089" num="0088">Table 1 below shows a schematic representation of a descriptor. Pages other than the first and the last are implicitly a full page in size (4 Kbytes). When using overlapping, the driver restricts the size of the descriptors (number of pages) to a user set &#x2018;DMA granularity&#x2019; to control the maximum data size transferred before the driver unblocks user software.</p>
<p id="p-0090" num="0089">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="84pt" align="left"/>
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="91pt" align="center"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="2" rowsep="1">TABLE 1</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>Address</entry>
<entry>Stream id</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="84pt" align="center"/>
<colspec colname="2" colwidth="42pt" align="left"/>
<colspec colname="3" colwidth="91pt" align="center"/>
<tbody valign="top">
<row>
<entry>0</entry>
<entry>0x00001E00</entry>
<entry>0</entry>
</row>
<row>
<entry>1</entry>
<entry>0x00002000</entry>
<entry>0</entry>
</row>
<row>
<entry>2</entry>
<entry>0x00003000</entry>
<entry>0</entry>
</row>
<row>
<entry>.</entry>
<entry/>
<entry>1</entry>
</row>
<row>
<entry>.</entry>
<entry/>
<entry>0</entry>
</row>
<row>
<entry>.</entry>
</row>
<row>
<entry>511&#x2003;</entry>
<entry>0x0001F000</entry>
<entry>1</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0091" num="0090">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="196pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>lead_stream = &#x3c;pick first stream with offset = 0&#x3e;</entry>
</row>
<row>
<entry/>
<entry>lead_stream_pos = 0</entry>
</row>
<row>
<entry/>
<entry>while(streams_done &#x3c; num_streams) {</entry>
</row>
<row>
<entry/>
<entry>&#x2003;for (s in steams)</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;if (s-&#x3e;offset &#x3c; lead_stream_pos) {</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;&#x2003;make_descriptor_entry(s-&#x3e;page_address[s-&#x3e;pos],</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;s-&#x3e;page_size[s-&#x3e;pos], s-&#x3e;id);</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;&#x2003;if (s == lead_stream)</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;&#x2003;&#x2003;load_stream_pos += s-&#x3e;page_size[s-&#x3e;pos];</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;&#x2003;s-&#x3e;pos++;</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;&#x2003;if (s-&#x3e;pos &#x3e;= s-&#x3e;total_number_of_pages)</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;&#x2003;&#x2003;{ streams_done++; s-&#x3e;pos = &#x2212;1}</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;}</entry>
</row>
<row>
<entry/>
<entry>}</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0092" num="0091">The above pseudo-code is an example of an Algorithm for generating DMA descriptor entries from a set of streams, each with a list of pages, an offset and a size. The algorithm serves to compute DMA descriptor entries by interleaving pages from all data streams <b>44</b>, <b>46</b> and <b>48</b>.</p>
<p id="p-0093" num="0092">First, the algorithm selects a &#x2018;lead stream&#x2019;, which is any stream with zero offset. Next, the algorithm generates descriptor entries in a round robin fashion for all streams with an offset greater than or equal to the current lead stream position. If all streams have zero offset, the streams are interleaved from the start. If a stream has non-zero offset, several pages of the other streams will be interleaved before the offset stream is included in the schedule.</p>
<p id="p-0094" num="0093">Once the DMA schedule <b>51</b> has been generated, the DMA engine <b>52</b> requests data according to the schedule. Thus, as shown in <figref idref="DRAWINGS">FIG. 8</figref>, the DMA schedule contains the entries (schematically shown) &#x201c;AABCAB&#x201d;. The data <b>56</b> as requested and obtained by the engine from the main memory is as specified in the schedule <b>51</b>. Thus, the schedule is effectively a list that the DMA engine <b>52</b> uses to select data for transfer.</p>
<p id="p-0095" num="0094">The DMA engine <b>52</b> traverses the descriptor list <b>51</b> and fetches/sends each page in the list from/to main memory <b>49</b>. Preferably, the DMA engine <b>52</b> communicates the stream id of the current page to the hardware de-multiplexer <b>54</b> so that the de-multiplexer is able to place the page in the correct stream. After each descriptor, the DMA engine <b>52</b> sends an interrupt to the host. The driver uses the interrupts to calculate the position in the stream and unblock a user application that is overlapped.</p>
<p id="p-0096" num="0095">In greater detail, the user gives the device driver <b>50</b> a &#x2018;hint&#x2019; of how often (for how much transferred data) a milestone will be set. The device driver <b>50</b> then restricts the size of the scatter/gather lists (above) to equal this size, so that the CPU is interrupted at that interval. The size of the scatter/gather list determines the amount of data transferred autonomously by DMA without interrupting the software. The driver then maintains the milestone by waiting for the appropriate number of interrupts from software. Alternatively, the milestones could be managed entirely by the DMA engine <b>52</b>. By managing the milestones in the device driver <b>50</b>, the hardware requirements for this function can be minimised.</p>
<p id="p-0097" num="0096">One way in which the milestones might be set is exemplified by the pseudocode as follows.</p>
<p id="p-0098" num="0097">
<tables id="TABLE-US-00003" num="00003">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>The user software operates in a loop:</entry>
</row>
<row>
<entry/>
<entry>For (x=0; x&#x3c;size; x+= block size) {</entry>
</row>
<row>
<entry/>
<entry>&#x2003;Set milestone at point x</entry>
</row>
<row>
<entry/>
<entry>&#x2003;Wait for milestone</entry>
</row>
<row>
<entry/>
<entry>&#x2003;Process data up to point x}</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0099" num="0098">Initially a range 0&#x3c;x&#x3c;size is specified. A milestone is set at the end of the range, i.e. at x=size. The accelerator executes the steps of its algorithm, i.e. processes the data, until it reaches the milestone x. The CPU depends on the calculations from the accelerator up to the value x to be able to compute the boundary conditions up to x. Therefore, once the milestone x is reached, the CPU has enough data to compute the boundary conditions up to the first milestone. This means that when the 3rd milestone is reached the boundary conditions up to the second milestone will have already been calculated.</p>
<p id="p-0100" num="0099">Last, the hardware de-multiplexes the arrays into data streams for processing by the accelerator. The hardware demultiplexer receives/sends data from/to the appropriate component stream as indicated by the current stream id from the DMA engine <b>52</b>.</p>
<p id="p-0101" num="0100">In practice the accelerator including the features discussed herein can be provided as an FPGA device or an ASIC or any other suitable hardware component. In one embodiment, the accelerator is provided as part of a PCI card or any other appropriate insertable means for connection to or arrangement in a host. In an embodiment the host and the accelerator can be provided as part of the same integrated unit. In other embodiments, the accelerator is a separate component that can be connected or disconnected to the host as desired or required. As will be understood, the use of FPGAs enables the precise computation of the accelerator to be customized for a specific application.</p>
<p id="p-0102" num="0101">Embodiments of the invention have been described with particular reference to the examples illustrated. However, it will be appreciated that variations and modifications may be made to the examples described within the scope of the invention. For example different forms of hardware and/or software may be used to implement the accelerator as appropriate. It will also be appreciated that the invention may be provided as a computer program or a set of instructions for programming programmable logic on a computer readable medium for storing and use on a computer or computer system.</p>
<p id="p-0103" num="0102">The invention provides a method of transferring data from a data array within a main memory of a computer to an accelerator for processing, the method comprising; at the accelerator, requesting data from the main memory and generating a data stream between the main memory and the accelerator, the generated data stream including data from the data array; and, using an offset to determine the scheduling of array elements within the generated data stream.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>The invention claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method of processing data using an accelerator arranged to receive data from a main memory and execute an operation on the data to process it, comprising;
<claim-text>requesting a DMA data transfer from a virtual address in the main memory to the accelerator;</claim-text>
<claim-text>upon receipt of the DMA data transfer request at the accelerator generating in the accelerator a list of the physical memory locations within the main memo of requested data corresponding to the virtual address;</claim-text>
<claim-text>copying the list to a stored list; and</claim-text>
<claim-text>upon subsequent DMA data transfer request accessing the stored list and, if the corresponding virtual address is already present, using the list of physical memory locations calculated for a previous DMA data transfer and commencing the DMA transfer without generating a new list of physical memory locations, wherein the stored list is a cached version of a DMA scatter/gather pointer list generated in respect of the DMA request.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, in which the stored list is stored in cache memory provided locally on the accelerator.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, in which stored list is provided as cache in main memory and re-sent to the accelerator when required.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. An accelerator for connection to a main computer having a central processing unit and main computer memory including at least one data array, the accelerator including logic to execute a computation process and being arranged to generate a data stream including data from the data array within the main memory, the accelerator comprising:
<claim-text>a logic device arranged to be programmed to execute a desired computation process; and</claim-text>
<claim-text>a device driver arranged to control the request of data from a virtual address in main memory of a computer to which, in use, the accelerator is connected, the driver being arranged to,</claim-text>
<claim-text>upon receipt of the DMA data transfer request at the accelerator, generate in the accelerator a list of the physical memory locations of requested data corresponding to the virtual address; copy the list to a stored list; and upon subsequent DMA data transfer request access the stored list and, if the corresponding virtual address is already present, use the list of physical memory locations calculated for a previous DMA data transfer and commence the DMA transfer without generating a new list of memory locations, wherein the stored list is a cached version of a DMA scatter/gather pointer list generated in respect of the DMA request.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. A computer program stored on a non-transitory computer readable medium, which when run on a programmable logic device provided on an accelerator causes the accelerator to execute the method of <claim-ref idref="CLM-00001">claim 1</claim-ref>.</claim-text>
</claim>
</claims>
</us-patent-grant>
