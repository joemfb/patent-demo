<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08626993-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08626993</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13300144</doc-number>
<date>20111118</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<us-term-of-grant>
<us-term-extension>243</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>13</main-group>
<subgroup>10</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>711103</main-classification>
</classification-national>
<invention-title id="d2e53">Method for tracking memory usages of a data processing system</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6658652</doc-number>
<kind>B1</kind>
<name>Alexander, III et al.</name>
<date>20031200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>7246139</doc-number>
<kind>B2</kind>
<name>Andoh</name>
<date>20070700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>2002/0163913</doc-number>
<kind>A1</kind>
<name>Oh</name>
<date>20021100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2003/0002194</doc-number>
<kind>A1</kind>
<name>Andoh</name>
<date>20030100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>2004/0123038</doc-number>
<kind>A1</kind>
<name>Shami et al.</name>
<date>20040600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2007/0226445</doc-number>
<kind>A1</kind>
<name>Nichols et al.</name>
<date>20070900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2010/0153352</doc-number>
<kind>A1</kind>
<name>Hahn et al.</name>
<date>20100600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2011/0205897</doc-number>
<kind>A1</kind>
<name>Pritam</name>
<date>20110800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00009">
<othercit>International Search Report and Written Opinion in Application No. PCT/US2012/056902, issued Dec. 10, 2012, pp. 1-10.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>23</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>8</number-of-drawing-sheets>
<number-of-figures>9</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20130132699</doc-number>
<kind>A1</kind>
<date>20130523</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Vaishampayan</last-name>
<first-name>Umesh S.</first-name>
<address>
<city>Santa Clara</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Chimene</last-name>
<first-name>Daniel A.</first-name>
<address>
<city>San Francisco</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Heller</last-name>
<first-name>Daniel S.</first-name>
<address>
<city>San Francisco</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Vaishampayan</last-name>
<first-name>Umesh S.</first-name>
<address>
<city>Santa Clara</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Chimene</last-name>
<first-name>Daniel A.</first-name>
<address>
<city>San Francisco</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Heller</last-name>
<first-name>Daniel S.</first-name>
<address>
<city>San Francisco</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Meyertons, Hood, Kivlin, Kowert &#x26; Goetzel, P.C.</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Apple Inc.</orgname>
<role>02</role>
<address>
<city>Cupertino</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Doan</last-name>
<first-name>Duc</first-name>
<department>2185</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Techniques for tracking memory usages of a data processing system are described herein. According to one embodiment, a memory manager is to perform a first lookup operation in a memory allocation table to identify an allocation entry based on a handle representing a memory address of a memory block allocated to a client and to retrieve a trace entry pointer from the allocation entry. The memory manager is then to perform a second lookup operation in a memory trace table to identify a trace entry based on the trace entry pointer and to increment a memory allocation count of the trace entry. The memory allocation count is utilized to indicate a likelihood of the client causing a memory leak.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="146.47mm" wi="202.86mm" file="US08626993-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="206.25mm" wi="177.04mm" orientation="landscape" file="US08626993-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="253.83mm" wi="171.11mm" orientation="landscape" file="US08626993-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="177.72mm" wi="184.32mm" orientation="landscape" file="US08626993-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="179.15mm" wi="165.27mm" orientation="landscape" file="US08626993-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="215.73mm" wi="196.00mm" orientation="landscape" file="US08626993-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="242.82mm" wi="192.36mm" orientation="landscape" file="US08626993-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="178.48mm" wi="160.19mm" orientation="landscape" file="US08626993-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="201.85mm" wi="169.67mm" orientation="landscape" file="US08626993-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">FIELD OF THE INVENTION</heading>
<p id="p-0002" num="0001">Embodiments of the present invention relate generally to data processing systems. More particularly, embodiments of the invention relate to a mechanism to track memory usages of a data processing system.</p>
<heading id="h-0002" level="1">BACKGROUND</heading>
<p id="p-0003" num="0002">A data processing system uses an operating system (OS) to manage the hardware and software resources of the computer. The OS is a software program that performs basic tasks, such as controlling and allocating memory, prioritizing the processing of instructions, controlling input and output devices, facilitating networking, and managing files. The OS also provides application program interfaces (APIs) to enable the application programs to interact with the hardware and software resources as well as with other application programs.</p>
<p id="p-0004" num="0003">As more and more services are becoming available for data processing systems, the number of programs running in a system has increased significantly. Each of these programs typically consumes a certain amount of resources such as memory. Some of the programs may cause memory leaks. For example, a program may allocate a block of memory and fail to properly release the memory block once it is done. Overtime, the available memory to be allocated to other programs becomes less and less. Although the density of memory devices continues to increase, memory capacities are still very limited.</p>
<p id="p-0005" num="0004">Usually, a system monitors memory usage by multiple running applications to ensure availability of a required capacity of free memory. In some systems, when memory usage reaches a critical level, the system takes memory management actions to increase the size of free memory, such as activating a garbage collection procedure to obtain allocated memories from applications which are no longer running. The system may also target a selected application, such as by simply killing the application. In some situations, it is useful or important to identify who causes the memory leaks in order to further improve the overall system. Typically, it is difficult to identify the cause of memory leaks within a single multipurpose program such as an operating system kernel. However, there has been a lack of an efficient mechanism to track or pinpoint the offenders that cause the memory leaks.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0006" num="0005">Embodiments of the invention are illustrated by way of example and not limitation in the figures of the accompanying drawings in which like references indicate similar elements.</p>
<p id="p-0007" num="0006"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram illustrating a system for tracking memory usages according to one embodiment of the invention.</p>
<p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram illustrating an example of an allocation table and a trace table according to one embodiment of the invention.</p>
<p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. 3</figref> is a flow diagram illustrating a method for allocating memory blocks according to one embodiment of the invention.</p>
<p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. 4</figref> is a flow diagram illustrating a method for deallocating memory blocks according to one embodiment of the invention.</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 5</figref> is pseudocode representing a program implementing a process of memory allocation according to one embodiment of the invention.</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 6</figref> is pseudocode representing a program implementing a process of memory deallocation according to one embodiment of the invention.</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 7</figref> is a flow diagram illustrating a method for allocating memory blocks according to another embodiment of the invention.</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 8</figref> is a screenshot illustrating a graphical user interface which may be used with an embodiment of the invention.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 9</figref> is a block diagram of a data processing system, which may be used with one embodiment of the invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0016" num="0015">Various embodiments and aspects of the inventions will be described with reference to details discussed below, and the accompanying drawings will illustrate the various embodiments. The following description and drawings are illustrative of the invention and are not to be construed as limiting the invention. Numerous specific details are described to provide a thorough understanding of various embodiments of the present invention. However, in certain instances, well-known or conventional details are not described in order to provide a concise discussion of embodiments of the present inventions.</p>
<p id="p-0017" num="0016">Reference in the specification to &#x201c;one embodiment&#x201d; or &#x201c;an embodiment&#x201d; means that a particular feature, structure, or characteristic described in conjunction with the embodiment can be included in at least one embodiment of the invention. The appearances of the phrase &#x201c;in one embodiment&#x201d; in various places in the specification do not necessarily all refer to the same embodiment.</p>
<p id="p-0018" num="0017">According to some embodiments, a memory manager of an operating system is configured to maintain a memory allocation table (also simply referred to as an allocation table) and a memory trace table (also simply referred to as a trace table) to keep track of memory allocation and deallocation of clients or owners that request the memory allocation. In one embodiment, the allocation table includes multiple entries, where each entry is indexed based on a memory address of an allocated block of memory. Each entry includes a pointer referencing to an entry of the trace table. The trace table includes multiple entries, where each entry is indexed by an identifier of a client or owner that requested the memory allocation.</p>
<p id="p-0019" num="0018">When a memory block is allocated to a client and referenced by a handle representing a memory address of the allocated memory block, a memory manager is configured to look up an allocation entry of the allocation table based on the handle to determine whether a pointer to the trace table has been stored therein. If the pointer exists, a trace entry of the trace table is accessed based on the pointer retrieved from the allocation table and the memory allocation information of the trace entry is updated. In one embodiment, a memory allocation count of the trace entry may be incremented in response to a memory allocation request and the memory allocation count may be decremented in response to a memory deallocation request. The memory allocation count may be used to indicate the likelihood that a client may request allocation of a memory block and does not properly deallocate the same (e.g., memory leak).</p>
<p id="p-0020" num="0019">In one embodiment, a client or owner of an allocated memory block may be represented by a backtrace of sequence of executable code or stack frames of a program that requested the memory allocation and/or deallocation. In a complicated multipurpose program, a backtrace is useful to more accurately identify a specific subset of the program's activities. Each of the entries in the allocation table is indexed based on a hash value of a handle of a memory allocation. Each of the entries in the trace table is indexed based on a hash value of a backtrace of a program that requested a memory allocation and/or memory deallocation. As a result, the memory manager can pinpoint based on the backtraces and their memory allocation counts which line or lines of executable code likely cause the memory leaks in an efficient way.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram illustrating a system for tracking memory usages according to one embodiment of the invention. System <b>100</b> as shown in <figref idref="DRAWINGS">FIG. 1</figref> may represent a variety of data processing systems or devices. For example, system <b>100</b> may present a client machine such as a desktop, laptop, a tablet, a mobile phone (e.g., Smartphone), a media player, or a combination thereof. Alternatively, system <b>100</b> may represent a server such as a Web server, an application server, or a backend server. Referring to <figref idref="DRAWINGS">FIG. 1</figref>, system <b>100</b> includes one or more programs <b>101</b>-<b>102</b> communicatively coupled to memory manager <b>103</b> via an API. Memory manager <b>103</b> may be implemented as a part of an operating system, which may be a variety of operating systems such as the Mac OS&#x2122; or iOS&#x2122; available from Apple&#xae; Inc. of Cupertino, Calif., the Windows&#x2122; operating system from Microsoft&#xae; Corporation of Redmond, Washington, a Unix&#xae; or Linux&#xae; operating system. Programs <b>101</b>-<b>102</b> and/or memory manager <b>103</b> may be running at a user level and/or at a kernel level of the operating system. For example, any of programs <b>101</b>-<b>102</b> may be running at a user level (e.g., applications) or at a kernel level (e.g., device driver) of an operating system.</p>
<p id="p-0022" num="0021">In one embodiment, memory manager <b>103</b> is configured to maintain memory usage map <b>104</b> having memory allocation table <b>105</b> and memory trace table <b>106</b>. Memory usage map <b>104</b> is configured to record memory usages such as memory allocations and/or deallocations by programs running within system <b>100</b> such as programs <b>101</b>-<b>102</b>. Memory usage map <b>104</b> may be maintained by the operating system in the system memory such as a random access memory (RAM) of system <b>100</b>.</p>
<p id="p-0023" num="0022">According to one embodiment, allocation table <b>105</b> and trace table <b>106</b> of memory usage map <b>104</b> are utilized to keep track of memory allocation and deallocation by clients or owners. An example of allocation table <b>105</b> and trace table <b>106</b> is shown in <figref idref="DRAWINGS">FIG. 2</figref> for the purpose of illustration. In one embodiment, referring to <figref idref="DRAWINGS">FIG. 2</figref>, allocation table <b>105</b> includes multiple entries, where each entry is indexed based on a memory address <b>201</b> of an allocated block of memory. Each entry includes a pointer <b>203</b> referencing to an entry of trace table <b>106</b>. Each entry of allocation table <b>105</b> may also include other optional information such as the actual memory address <b>202</b>. Trace table <b>106</b> includes multiple entries, where each entry is indexed by an identifier of a client or owner <b>204</b> that requested the memory allocation. Each trace entry of trace table <b>106</b> further includes memory allocation information <b>205</b> such as a memory allocation count and optionally other information such as the actual backtrace <b>206</b>. Note that allocation table <b>105</b> and trace table <b>106</b> as shown in <figref idref="DRAWINGS">FIG. 2</figref> are described for illustration purposes only; other formats may also be utilized and more or less information may be included therein.</p>
<p id="p-0024" num="0023">Referring back to <figref idref="DRAWINGS">FIGS. 1 and 2</figref>, when a memory block is allocated to a client and referenced by a handle representing a memory address of the allocated memory block, memory allocator <b>107</b> is configured to look up an allocation entry (e.g., allocation entry <b>207</b>) of allocation table <b>105</b> based on the handle (e.g., field <b>201</b> of allocation entry <b>207</b>) to determine whether a pointer or link to trace table <b>106</b> has been stored therein (e.g., field <b>203</b> of allocation entry <b>207</b>). If the pointer exists, a trace entry (e.g., trace entry <b>209</b>) of trace table <b>106</b> is accessed based on the pointer retrieved from allocation table <b>105</b> (e.g., field <b>204</b> of trace entry <b>209</b>) and the memory allocation information of the trace entry (e.g., field <b>205</b> of trace entry <b>209</b>) is updated. In one embodiment, the memory allocation information includes a memory allocation count of the trace entry, which may be incremented in response to a memory allocation request.</p>
<p id="p-0025" num="0024">According to one embodiment, when a request to deallocate a memory block referenced by a handle is received, memory deallocator <b>108</b> is configured to look up an allocation entry (e.g., allocation entry <b>208</b>) of allocation table <b>105</b> based on the handle (e.g., field <b>201</b> of allocation entry <b>208</b>) and to retrieve a pointer (e.g., field <b>203</b> of allocation entry <b>208</b>) referencing to a trace entry (e.g., trace entry <b>209</b>) of trace table <b>106</b>. Memory deallocator <b>108</b> is then to update the memory deallocation information (e.g., field <b>205</b> of trace entry <b>209</b>), for example, decrementing the memory allocation count of the trace entry. The memory allocation count may be used to indicate the likelihood that a client may request allocation of a memory block and does not properly deallocate the same when it is done (e.g., memory leak). In this embodiment, a positive memory allocation count may indicate that a program may allocate more memory blocks than the ones deallocated over a period of time. A program with a higher memory allocation count may be considered as a top or leading memory leak suspect. In one embodiment, memory manager <b>103</b> may maintain information concerning a list of one or more top memory leak suspects, for example, based on their respective memory allocation counts, for analysis and/or reporting purposes. For example, as shown in <figref idref="DRAWINGS">FIG. 8</figref>, a user can obtain the backtrace information of one or more top memory leak suspects based on the information from allocation table <b>105</b> and trace table <b>106</b> and send the information to other facilities for analysis purposes.</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 3</figref> is a flow diagram illustrating a method for allocating memory blocks according to one embodiment of the invention. For example, method <b>300</b> may be performed by memory manager <b>103</b> of <figref idref="DRAWINGS">FIG. 1</figref>. Referring to <figref idref="DRAWINGS">FIG. 3</figref>, at block <b>301</b>, a memory manager receives a request for allocating a block of memory from a client. In response to the request, at block <b>302</b>, memory manager allocates the requested memory block and obtains a handle (e.g., a starting memory address) to the allocated memory block. At block <b>303</b>, the memory manager populates memory allocation information in the entry associated with the client in the trace table. In one embodiment, a memory allocation count of the trace entry is incremented. The client may be represented by a backtrace of a sequence of executable code or stack frames that requested the memory allocation. At block <b>304</b>, the address of the trace entry is stored in the allocation entry corresponding to the handle of the memory allocation in the allocation table. Thereafter, the handle of the memory allocation is returned to the client at block <b>305</b> to complete the memory request process. <figref idref="DRAWINGS">FIG. 5</figref> is pseudocode representing a program implementing method <b>300</b> of <figref idref="DRAWINGS">FIG. 3</figref>.</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 4</figref> is a flow diagram illustrating a method for deallocating memory blocks according to one embodiment of the invention. For example, method <b>400</b> may be performed by memory manager <b>103</b> of <figref idref="DRAWINGS">FIG. 1</figref>. Referring to <figref idref="DRAWINGS">FIG. 4</figref>, at block <b>401</b>, a memory manager receives a request from a client for deallocating a block of memory referenced by a handle. In response to the request, at block <b>402</b>, the memory manager is configured to release the block of memory back to a memory pool. At block <b>403</b>, the memory manager is to look up a memory allocation table to locate an allocation entry based on the handle and to identify a trace entry pointer of a trace table corresponding to the handle. Based on the trace entry pointer, at block <b>404</b>, the memory manager is to update the memory allocation/deallocation information stored in a trace entry linked by the trace entry pointer, for example, including decrementing a memory allocation count of the trace entry. <figref idref="DRAWINGS">FIG. 6</figref> is pseudocode representing a program implementing method <b>400</b> of <figref idref="DRAWINGS">FIG. 4</figref>.</p>
<p id="p-0028" num="0027">The memory leak detection mechanism as described above may be implemented as part of an operating system or a plug-in or an extension of a kernel of an operating system. According to one embodiment, the memory leak detection mechanism may only be activated when there is a likelihood that someone is causing memory leaks. Initially according to one embodiment, the memory leak detection mechanism is inactive until the remaining memory available for allocation drops below a predetermined threshold. Typically, when a data processing system boots up, there are plenty of resources or memory available to be allocated to programs. Under such circumstances, there is no need to track memory leaks. When the available memory free for allocation drops below a predetermined threshold, according to one embodiment, the memory leak detection mechanism is activated. Often, a data processing system may have fewer memory leaks in which the available resources are sufficient enough to compensate the memory leaks without substantially impacting performance of the system. As a result, there may not be a need to detect the memory leak. Thus, the memory leak detection mechanism is activated only when it is needed to minimize resource consumption associated therewith.</p>
<p id="p-0029" num="0028">As described above, when a request for allocating memory is received, such a memory allocation is recorded in the allocation table and trace table set forth above. In one embodiment, in response to a memory allocation request, an entry associated with a handle of the allocated memory is examined in the allocation table and an entry associated with an owner of the allocated memory is examined in the trace table. The memory allocation information such as a memory allocation count of the trace entries is updated accordingly. For a particular handle of an allocated memory block, if there is no corresponding entry or entries in the allocation table or the trace table, a new entry is allocated or created in the allocation table or the trace table, for example, by storing a trace entry pointer in an entry of the allocation table and incrementing a memory allocation count in the associated trace entry in the trace table.</p>
<p id="p-0030" num="0029">Similarly, when a request for deallocating a memory block is received, the associated memory allocation count is decremented and the corresponding trace entry pointer in the associated allocation entry of the allocation table may be reset to a predetermined value such as a NULL or zero. If the memory allocation count of a particular trace entry reaches zero, it means that the particular trace entry is free to be allocated to someone else. Similarly, when the trace entry pointer of a particular allocation entry of the allocation table does not contain a valid trace entry pointer (e.g., NULL or zero), that particular allocation entry is free for allocation. According to one embodiment, in order to maintain a relatively small size of the allocation table and/or trace table and also to reproduce the CPU overhead associated with the bookkeeping, only samples of the memory allocation requests are recorded. For example, one out of N memory allocations may be recorded, which may be configurable based on a policy. In this way, although certain memory leak offenders may not be caught; however, frequent memory leak offenders will eventually be caught. This configuration can trap the major memory leak offenders while consuming less system resources or processing power for the memory leak detection.</p>
<p id="p-0031" num="0030">In one embodiment, a client or owner of an allocated memory block may be represented by a backtrace of sequence of executable code (e.g., backtrace of stack frames) that requested the memory allocation and/or deallocation. Each of the entries in the allocation table is indexed based on a hash value of a handle of a memory allocation. Each of the entries in the trace table is indexed based on a hash value of a backtrace of a program that requested a memory allocation and/or memory deallocation. As a result, the memory manager can pinpoint based on the backtraces and their memory allocation counts which lines of executable code likely causes the memory leaks.</p>
<p id="p-0032" num="0031">Referring back to <figref idref="DRAWINGS">FIGS. 1 and 2</figref>, the backtrace of any of programs <b>101</b>-<b>102</b> can be obtained by backtrace module <b>109</b> and provided to memory manager <b>103</b>. Backtrace module <b>109</b> may be implemented as an extension of a kernel of an operating system that allows, via an API, memory manager to obtain a backtrace of stack frames of a current thread that requested a memory allocation or deallocation. An example of a backtrace is shown in <figref idref="DRAWINGS">FIG. 8</figref>, which can be reported by analysis module <b>110</b> as part of memory usage report <b>111</b> (e.g., memory leak report). Memory usage report <b>111</b> can be further analyzed dynamically or offline to identify which of the programs currently installed in system <b>100</b> causes most memory leaks.</p>
<p id="p-0033" num="0032">Referring now to <figref idref="DRAWINGS">FIG. 2</figref>, allocation table <b>105</b> and trace table <b>106</b> may be implemented in a variety of forms such as arrays, data structures, data objects, or a combination thereof (e.g., a linked list of data structures). In one embodiment, allocation table <b>105</b> includes multiple entries that are indexed based on hash values of memory addresses associated with allocated memory blocks. For example, when a memory block is allocated, a handle of the memory block is obtained. An entry of allocation table <b>105</b> is identified based on a hash of the handle, where the hash can be generated using a variety of hash functions or algorithms such as Jenkins, FNV, SHA-1, or MD5 hash algorithms. That is, once the hash value of a handle is obtained, the hash value is utilized as an index in field <b>201</b> to locate an entry in allocation table <b>105</b>. In one embodiment, each entry of allocation table <b>105</b> further includes field <b>202</b> to store the actual handle or memory address of the memory allocation and field <b>203</b> to store a pointer referencing a trace entry of trace table <b>106</b>. Other information may also be stored in allocation table <b>105</b>.</p>
<p id="p-0034" num="0033">Similarly, according to one embodiment, trace table <b>106</b> includes multiple entries that are indexed based on a hash value of a backtrace representing a client or owner that requests the memory allocation or deallocation. For example, when a memory block is allocated for a client, a backtrace of the client is obtained from the operating system (e.g., via backtrace module <b>109</b>). An entry of trace table <b>106</b> is identified based on a hash of the backtrace, where the hash can be generated using a variety of hash functions or algorithms such as Jenkins, FNV, SHA-1, or MD5 hash algorithms. That is, once the hash value of the backtrace is obtained, the hash value is utilized as an index to field <b>204</b> to locate an entry in trace table <b>106</b>. In one embodiment, each entry of trace table <b>106</b> further includes field <b>205</b> to store memory allocation information associated with the entry, such as, for example, a memory allocation count. Each entry of trace table <b>106</b> further includes field <b>206</b> to store other information, such as the actual backtrace associated with the entry. Other information may also be stored in trace table <b>106</b>.</p>
<p id="p-0035" num="0034">As shown in <figref idref="DRAWINGS">FIG. 2</figref>, by using hashes of handles as indexes for allocation table <b>105</b> and hashes of backtraces as indexes for trace table <b>106</b>, according to one embodiment, the sizes of allocation table <b>105</b> and trace table <b>106</b> can be maintained in a reasonable size. That is, each of allocation table <b>105</b> and trace table <b>106</b> includes a fixed number of entries or slots which are identified or located based on the hashes of handles and backtrace, respectively. However, hashes of different values (e.g., handles or backtraces) may yield the same hash value (e.g., hash collision). As a result, sometimes multiple entries of allocation table <b>105</b> such as entries <b>207</b>-<b>208</b> may reference to the same trace entry <b>209</b> of trace table <b>106</b>. According to some embodiments, under certain circumstances, in order to limit the resource consumed by allocation table <b>105</b> and trace table <b>106</b>, certain memory allocations may not be recorded in allocation table <b>105</b> and trace table <b>106</b>. The system can only record memory allocations up to the total number of entries in allocation table <b>105</b> and trace table <b>106</b>. In some situations, when a new memory allocation is recorded, an early recorded one that occupies the same slot may be evicted from or overridden in the table, dependent upon the circumstances. As described above, although some memory leak offenders may not be caught at a particular point in time; however, a frequent memory leak offender will eventually be caught.</p>
<p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. 7</figref> is a flow diagram illustrating a method for allocating memory according to another embodiment of the invention. Method <b>700</b> may be performed by memory manager <b>103</b> of <figref idref="DRAWINGS">FIG. 1</figref>, which may be implemented as processing logic in software, hardware, or a combination thereof. Referring to <figref idref="DRAWINGS">FIGS. 2 and 7</figref>, in response to a memory allocation referenced by a handle, at block <b>701</b>, processing logic obtains a hash of the handle and a hash of a backtrace of a program that requested the memory allocation, and looks up allocation table <b>105</b> and trace table <b>106</b>. At block <b>702</b>, processing logic is to determine whether an allocation entry of allocation table <b>105</b> is free to be allocated to a client represented by the backtrace. In one embodiment, processing logic looks up in field <b>201</b> of allocation table <b>105</b> using a hash of the handle as an index to locate an allocation entry. Processing logic is then to examine field <b>203</b> of the allocation entry to determine whether there is trace entry pointer stored therein. If there is no trace entry pointer stored therein, the allocation entry is considered free to use.</p>
<p id="p-0037" num="0036">If it is determined that the allocation entry is free, at block <b>703</b>, processing logic then looks up trace table <b>106</b> using a hash of the backtrace as an index in field <b>204</b> to locate a trace entry. Processing logic then examines field <b>205</b> of the trace entry to determine whether the trace entry is free. In one embodiment, if field <b>205</b> contains certain memory allocation information, in this example, a non-zero memory allocation count, the trace entry is occupied; otherwise, the trace entry is free. If it is determined the trace entry is free (e.g., the current memory allocation is a new memory allocation and recorded the first time), at block <b>704</b>, processing logic is to populate the necessary information in both allocation table <b>105</b> and trace table <b>106</b>. In one embodiment, processing logic stores the actual memory handle in field <b>202</b> of the allocation entry and stores a memory address of the associated trace entry in field <b>203</b> of the allocation entry in allocation table <b>105</b>. In addition, processing logic further stores at least a portion of the actual backtrace in field <b>206</b> of the trace entry and increments a memory allocation count in field <b>205</b> of the trace entry in trace table <b>106</b>. In one embodiment, in order to limit the size of trace table <b>106</b>, only limited amount information of a backtrace (e.g., a predetermined number such as 15 of lines of code or stack frames) is stored in field <b>206</b> of a trace entry. By storing a memory address of a trace entry in field <b>203</b> of an allocation entry, the allocation entry is considered as occupied. Similarly, by storing a non-zero memory allocation count in field <b>205</b> of a trace entry, the trace entry becomes occupied.</p>
<p id="p-0038" num="0037">According to one embodiment, if it is determined at block <b>703</b> that the trace entry is occupied (e.g., a non-zero memory allocation count), at block <b>705</b>, processing logic is to determine whether the trace entry is associated with the same owner or client. In one embodiment, processing logic compares the actual backtrace of the current thread that requests the memory allocation with the backtrace that is currently stored in field <b>206</b> of the trace entry. If both backtraces are matched, the trace entry is owned by the same owner. If the trace entry is owned by the same owner, at block <b>706</b>, the memory allocation count stored in field <b>205</b> of the trace entry is incremented. At block <b>707</b>, the memory address of the trace entry is stored in field <b>203</b> of the allocation entry, which in turn indicates that the allocation entry is now occupied.</p>
<p id="p-0039" num="0038">Note that at this point, there may be multiple allocation entries referencing to the same trace entry. For example, if the memory allocation count of a trace entry is two, there may be at least two allocation entries in allocation table <b>105</b> associated with the corresponding trace entry of trace table <b>106</b>. That is, an owner may have allocated multiple memory blocks without releasing some of them. For example, referring to <figref idref="DRAWINGS">FIG. 2</figref>, it is assumed that an owner represented by a backtrace allocated a first memory block, which results in allocation entry <b>207</b> (based on a first handle) referencing to trace entry <b>209</b>. Subsequently, the same owner (e.g., same backtrace) allocates a second memory block, which results in allocation entry <b>208</b> (based on a second handle) referencing to the same trace entry <b>209</b> (because of the same backtrace). As a result, both allocation entries <b>207</b>-<b>208</b> reference to the same trace entry <b>209</b> having a memory allocation count of two.</p>
<p id="p-0040" num="0039">According to one embodiment, if it is determined at block <b>702</b> that the allocation entry is occupied, at block <b>708</b>, processing logic examines a trace entry referenced by the allocation entry to determine whether the trace entry is owned by the same owner (by comparing the backtrace as set forth above). In addition, processing logic may further compares the actual handle with the one stored in field <b>202</b> of the allocation entry to determine whether the memory allocation is the same as the one already recorded. If it is the same owner or same handle, processing logic may skip processing the current memory allocation, since it has already been processed. If it is not the same owner, at block <b>709</b>, a new trace entry is allocated to the new owner from trace table <b>106</b>. In addition, the trace entry pointer in field <b>203</b> is replaced with the address of the new trace entry and the memory allocation count of the new trace entry is incremented. Note that the allocation entry is now linked to the new trace entry instead of the old trace entry. At block <b>710</b>, the memory allocation count of the old trace entry in trace table <b>106</b> is decremented.</p>
<p id="p-0041" num="0040"><figref idref="DRAWINGS">FIG. 9</figref> is a block diagram of a data processing system, which may be used with one embodiment of the invention. For example, the system <b>900</b> may be used as part of system <b>100</b> as shown in <figref idref="DRAWINGS">FIG. 1</figref>. Note that while <figref idref="DRAWINGS">FIG. 9</figref> illustrates various components of a computer system, it is not intended to represent any particular architecture or manner of interconnecting the components; as such details are not germane to the present invention. It will also be appreciated that network computers, handheld computers, cell phones and other data processing systems which have fewer components or perhaps more components may also be used with the present invention. The computer system of <figref idref="DRAWINGS">FIG. 9</figref> may, for example, be an Apple Macintosh computer or MacBook, an IBM compatible PC, or a computer server.</p>
<p id="p-0042" num="0041">As shown in <figref idref="DRAWINGS">FIG. 9</figref>, the computer system <b>900</b>, which is a form of a data processing system, includes a bus or interconnect <b>902</b> which is coupled to one or more microprocessors <b>903</b> and a ROM <b>907</b>, a volatile RAM <b>905</b>, and a non-volatile memory <b>906</b>. The microprocessor <b>903</b> is coupled to cache memory <b>904</b>. The bus <b>902</b> interconnects these various components together and also interconnects these components <b>903</b>, <b>907</b>, <b>905</b>, and <b>906</b> to a display controller and display device <b>908</b>, as well as to input/output (I/O) devices <b>910</b>, which may be mice, keyboards, modems, network interfaces, printers, and other devices which are well-known in the art.</p>
<p id="p-0043" num="0042">Typically, the input/output devices <b>910</b> are coupled to the system through input/output controllers <b>909</b>. The volatile RAM <b>905</b> is typically implemented as dynamic RAM (DRAM) which requires power continuously in order to refresh or maintain the data in the memory. The non-volatile memory <b>906</b> is typically a magnetic hard drive, a magnetic optical drive, an optical drive, or a DVD RAM or other type of memory system which maintains data even after power is removed from the system. Typically, the non-volatile memory will also be a random access memory, although this is not required.</p>
<p id="p-0044" num="0043">While <figref idref="DRAWINGS">FIG. 9</figref> shows that the non-volatile memory is a local device coupled directly to the rest of the components in the data processing system, the present invention may utilize a non-volatile memory which is remote from the system; such as, a network storage device which is coupled to the data processing system through a network interface such as a modem or Ethernet interface. The bus <b>902</b> may include one or more buses connected to each other through various bridges, controllers, and/or adapters, as is well-known in the art. In one embodiment, the I/O controller <b>909</b> includes a USB (Universal Serial Bus) adapter for controlling USB peripherals. Alternatively, I/O controller <b>909</b> may include an IEEE-1394 adapter, also known as FireWire adapter, for controlling FireWire devices.</p>
<p id="p-0045" num="0044">Some portions of the preceding detailed descriptions have been presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the ways used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here, and generally, conceived to be a self-consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities.</p>
<p id="p-0046" num="0045">It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion, it is appreciated that throughout the description, discussions utilizing terms such as those set forth in the claims below, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission or display devices.</p>
<p id="p-0047" num="0046">The techniques shown in the figures can be implemented using code and data stored and executed on one or more electronic devices. Such electronic devices store and communicate (internally and/or with other electronic devices over a network) code and data using computer-readable media, such as non-transitory computer-readable storage media (e.g., magnetic disks; optical disks; random access memory; read only memory; flash memory devices; phase-change memory) and transitory computer-readable transmission media (e.g., electrical, optical, acoustical or other form of propagated signals&#x2014;such as carrier waves, infrared signals, digital signals).</p>
<p id="p-0048" num="0047">The processes or methods depicted in the preceding figures may be performed by processing logic that comprises hardware (e.g. circuitry, dedicated logic, etc.), firmware, software (e.g., embodied on a non-transitory computer readable medium), or a combination of both. Although the processes or methods are described above in terms of some sequential operations, it should be appreciated that some of the operations described may be performed in a different order. Moreover, some operations may be performed in parallel rather than sequentially.</p>
<p id="p-0049" num="0048">In the foregoing specification, embodiments of the invention have been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of the invention as set forth in the following claims. The specification and drawings are, accordingly, to be regarded in an illustrative sense rather than a restrictive sense.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A computer-implemented method for managing memory, the method comprising:
<claim-text>performing a first lookup operation in a memory allocation table to identify an allocation entry based on a handle representing a memory address of a memory block allocated to a client and to retrieve a trace entry pointer from the allocation entry; and</claim-text>
<claim-text>performing a second lookup operation in a memory trace table to identify a trace entry based on the trace entry pointer and to increment a memory allocation count of the trace entry, wherein the memory allocation count is utilized to indicate a likelihood of the client causing a memory leak.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the client is identified via a backtrace of a sequence of executable code of a program, and wherein the trace entry is indexed in the memory trace table based on a hash value of the backtrace.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the allocation entry of the memory allocation table is indexed based on a hash value of the handle.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>examining the allocation entry to determine whether the allocation entry is free to use by determining whether the allocation entry contains a trace entry pointer; and</claim-text>
<claim-text>updating the allocation entry with an address of the trace entry of the memory trace table if the allocation entry is free.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, further comprising:
<claim-text>examining the trace entry of the memory trace table to determine whether the memory allocation count is greater than a predetermined value, if the allocation entry is free; and</claim-text>
<claim-text>determining whether the client is the same owner of the trace entry of the memory trace table if the memory allocation count is greater than the predetermined value, wherein the memory allocation count of the trace entry is incremented if the client is the same owner of the trace entry.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, further comprising:
<claim-text>determining whether the client is the same owner of the trace entry of the memory trace table if the allocation entry is not free which references to an existing trace entry;</claim-text>
<claim-text>if the client is not the same owner, decrementing a memory allocation count of the existing trace entry; and updating the allocation entry of the memory allocation table with an address of the trace entry.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>in response to a request for deallocating a second memory block identified by a second handle, retrieving a second trace entry pointer from a second allocation entry from the memory allocation table based on the second handle; and</claim-text>
<claim-text>decrementing a memory allocation count of a second trace entry of the memory trace table based on the second trace entry pointer.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first and second lookup operations are performed on only samples of memory allocation requests.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising monitoring a memory usage level, wherein the first and second lookup operations are performed only if the memory usage level drops below a predetermined threshold.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. A non-transitory machine-readable storage medium having instructions stored therein, which when executed by a machine, cause the machine to perform a method for managing memory, the method comprising:
<claim-text>performing a first lookup operation in a memory allocation table to identify an allocation entry based on a handle representing a memory address of a memory block allocated to a client and to retrieve a trace entry pointer from the allocation entry; and</claim-text>
<claim-text>performing a second lookup operation in a memory trace table to identify a trace entry based on the trace entry pointer and to increment a memory allocation count of the trace entry, wherein the memory allocation count is utilized to indicate a likelihood of the client causing a memory leak.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The non-transitory machine-readable storage medium of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the client is identified via a backtrace of a sequence of executable code of a program, and wherein the trace entry is indexed in the memory trace table based on a hash value of the backtrace.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The non-transitory machine-readable storage medium of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the allocation entry of the memory allocation table is indexed based on a hash value of the handle.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The non-transitory machine-readable storage medium of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the method further comprises:
<claim-text>examining the allocation entry to determine whether the allocation entry is free to use by determining whether the allocation entry contains a trace entry pointer; and</claim-text>
<claim-text>updating the allocation entry with an address of the trace entry of the memory trace table if the allocation entry is free.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The non-transitory machine-readable storage medium of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the method further comprises:
<claim-text>examining the trace entry of the memory trace table to determine whether the memory allocation count is greater than a predetermined value, if the allocation entry is free; and</claim-text>
<claim-text>determining whether the client is the same owner of the trace entry of the memory trace table if the memory allocation count is greater than the predetermined value, wherein the memory allocation count of the trace entry is incremented if the client is the same owner of the trace entry.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The non-transitory machine-readable storage medium of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the method further comprises:
<claim-text>determining whether the client is the same owner of the trace entry of the memory trace table if the allocation entry is not free which references to an existing trace entry;</claim-text>
<claim-text>if the client is not the same owner,
<claim-text>decrementing a memory allocation count of the existing trace entry; and</claim-text>
<claim-text>updating the allocation entry of the memory allocation table with an address of the trace entry.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The non-transitory machine-readable storage medium of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the method further comprises:
<claim-text>in response to a request for deallocating a second memory block identified by a second handle, retrieving a second trace entry pointer from a second allocation entry from the memory allocation table based on the second handle; and</claim-text>
<claim-text>decrementing a memory allocation count of a second trace entry of the memory trace table based on the second trace entry pointer.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. A data processing system, comprising:
<claim-text>a memory configured to store a memory allocation table and a memory trace table; and</claim-text>
<claim-text>a memory allocation module configured to perform a first lookup operation in the memory allocation table to identify an allocation entry based on a handle representing a memory address of a memory block allocated to a client and to retrieve a trace entry pointer from the allocation entry, wherein the memory allocation module is configured to performe a second lookup operation in the memory trace table to identify a trace entry based on the trace entry pointer and to increment a memory allocation count of the trace entry, wherein the memory allocation count is utilized to indicate a likelihood of the client causing a memory leak.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The system of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the client is identified via a backtrace of a sequence of executable code of a program, and wherein the trace entry is indexed in the memory trace table based on a hash value of the backtrace.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The system of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the allocation entry of the memory allocation table is indexed based on a hash value of the handle.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The system of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the memory allocation module is configured to:
<claim-text>examine the allocation entry to determine whether the allocation entry is free to use by determining whether the allocation entry contains a trace entry pointer, and</claim-text>
<claim-text>update the allocation entry with an address of the trace entry of the memory trace table if the allocation entry is free.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The system of <claim-ref idref="CLM-00020">claim 20</claim-ref>, wherein the memory allocation module is configured to:
<claim-text>examine the trace entry of the memory trace table to determine whether the memory allocation count is greater than a predetermined value, if the allocation entry is free, and</claim-text>
<claim-text>determine whether the client is the same owner of the trace entry of the memory trace table if the memory allocation count is greater than the predetermined value, wherein the memory allocation count of the trace entry is incremented if the client is the same owner of the trace entry.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. The system of <claim-ref idref="CLM-00020">claim 20</claim-ref>, wherein the memory allocation module is configured to:
<claim-text>determine whether the client is the same owner of the trace entry of the memory trace table if the allocation entry is not free which references to an existing trace entry, and</claim-text>
<claim-text>if the client is not the same owner,
<claim-text>decrement a memory allocation count of the existing trace entry, and</claim-text>
<claim-text>update the allocation entry of the memory allocation table with an address of the trace entry.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00023" num="00023">
<claim-text>23. The system of <claim-ref idref="CLM-00017">claim 17</claim-ref>, further comprising a memory deallocation module configured to:
<claim-text>in response to a request for deallocating a second memory block identified by a second handle, retrieve a second trace entry pointer from a second allocation entry from the memory allocation table based on the second handle, and</claim-text>
<claim-text>decrement a memory allocation count of a second trace entry of the memory trace table based on the second trace entry pointer.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
