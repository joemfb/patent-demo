<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627317-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627317</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12873920</doc-number>
<date>20100901</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>577</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>455</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>46</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>718100</main-classification>
</classification-national>
<invention-title id="d2e53">Automatic identification of bottlenecks using rule-based expert knowledge</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>7739675</doc-number>
<kind>B2</kind>
<name>Klein</name>
<date>20100600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00002">
<othercit>Power; Design and use of a program execution analyzer; 1983; IBM Systems Journal, vol. 22, No. 3, pp. 271-294.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00003">
<othercit>Aguilera et al., Performance Debugging for Distributed Systems of Black Boxes, Symposium on Operating System Principles, ACM, 2003.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00004">
<othercit>Alexander et al., A unifying approach to performance analysis in the Java environment, IBM Systems Journal, 2000, vol. 39, No. 1.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00005">
<othercit>Ammons et al., Finding and Removing Performance Bottlenecks in Large Systems, The European Conference on Object-Oriented Programming, Springer, 2004.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00006">
<othercit>Darmawan et al., IBM Tivoli Composite Application Manager Family: Installation, Configuration, and Basic Usage, Jan. 2008.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00007">
<othercit>De Pauw et al., Visualizing the Execution of Java Programs, Software Visualization, State-of-the-art Survey, vol. 2269 of Lecture Notes in Computer Science, Springer-Verlag, 2002.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00008">
<othercit>Hall, Cpprofj: Aspect-Capable Call Path Profiling of Multi-Threaded Java Applications, Automated Software Engineering, IEEE Computer Society Press, 2002, pp. 107-116.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00009">
<othercit>Hollingsworth, Finding Bottlenecks in Large-scale Parallel Programs, PhD Thesis, University of Wisconsin, Aug. 1994.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00010">
<othercit>Host et al., Debugging Method Names, The European Conference on Object-Oriented Programming, 2009, abstract.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00011">
<othercit>Mitchell et al., Modeling Runtime Behavior in Framework-based Applications, The European Conference on Object-Oriented Programming, 2006.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00012">
<othercit>Srinivas et al., Summarizing Application Performance From a Components Perspective, Foundations of Software Engineering, 2005, pp. 136-145, vol. 30, No. 5, abstract.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00013">
<othercit>Borland Software Corporation, OptimizeIt Enterprise Suite, 2005, http://info.borland.com/devsupport/optimizeit/.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00014">
<othercit>Compuware, Compuware Vantage Analyzer, http://www.compuware.com/solutions/e2e<sub>&#x2014;</sub>brochures<sub>&#x2014;</sub>factsheets.asp.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00015">
<othercit>Eclipse, Eclipse Test &#x26; Performance Tools Platform Project, http://www.eclipse.org/tptp.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00016">
<othercit>HP, HP Diagnostics for J2EE, https://h10078.www1.hp.com/cda/hpms/display/main/hpms<sub>&#x2014;</sub>content.jsp?zn=bto&#x26;cp=1-11-15-25%5E761<sub>&#x2014;</sub>4000<sub>&#x2014;</sub>100<sub>&#x2014;</sub>.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00017">
<othercit>IBM, Compuware Vantage Analyzer, http://alphaworks.ibm.com/tech/dcva4j/download.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00018">
<othercit>IBM, IBM OMEGAMOM XE for WebSphere, http://www-01.ibm.com/software/tivoli/products/omegamon-xe-was.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00019">
<othercit>IBM, Thread and Monitor Dump Analyzer for Java, http://www.alphaworks.ibm.com/tech/jca.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00020">
<othercit>IBM, Tivoli Monitoring for Transaction Performace, http://www-01.ibm.com/software/tivoli/products/monitor-transaction.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00021">
<othercit>Sun Microsystems, HPROF JVM Profiler, http://java.sun.com/developer/technicalArticles/Programming/HPROF.html.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00022">
<othercit>Yourkit LLC, Yourkit Profiler, http://www.yourkit.com.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00023">
<othercit>Xu et al., Go With the Flow: Profiling Copies to Find Runtime Bloat, PLDI 2009: Proceedings of the 2009 ACM SIGPLAN Conference on Programming Language Design and implementation, 2009, pp. 419-430.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00024">
<othercit>Xu et al., Detecting Large-Scale System Problems by Mining Console Logs, Proceedings of the 26th International Conference on Machine Learning, Haifa, Israel, 2010.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00025">
<othercit>Yuan et al., Sherlog: Error Diagnosis by Connecting Clues from Run-Time Logs, ASPLOS'10, Mar. 13-17, 2010, Pittsburgh, Pennsylvania, USA.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00026">
<othercit>Zhao et al., Allocation Wall: A Limiting Factor of Java Applications on Emerging Multi-Core Platforms, OOPSLA '09 Proceeding of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>25</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>20</number-of-drawing-sheets>
<number-of-figures>25</number-of-figures>
</figures>
<us-related-documents>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61317512</doc-number>
<date>20100325</date>
</document-id>
</us-provisional-application>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20120054472</doc-number>
<kind>A1</kind>
<date>20120301</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Altman</last-name>
<first-name>Erik R.</first-name>
<address>
<city>Danbury</city>
<state>CT</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Arnold</last-name>
<first-name>Matthew R.</first-name>
<address>
<city>Ridgefield Park</city>
<state>NJ</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Mitchell</last-name>
<first-name>Nicholas M.</first-name>
<address>
<city>White Plains</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Altman</last-name>
<first-name>Erik R.</first-name>
<address>
<city>Danbury</city>
<state>CT</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Arnold</last-name>
<first-name>Matthew R.</first-name>
<address>
<city>Ridgefield Park</city>
<state>NJ</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Mitchell</last-name>
<first-name>Nicholas M.</first-name>
<address>
<city>White Plains</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Scully, Scott, Murphy &#x26; Presser, P.C.</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Percello, Esq.</last-name>
<first-name>Louis J.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Faherty</last-name>
<first-name>Corey S</first-name>
<department>2183</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Execution states of tasks are inferred from collection of information associated with runtime execution of a computer system. Collection of information may include infrequent samples of executing tasks, the samples which may provide inaccurate executing states. One or more tasks may be aggregated by one or more execution states for determining execution time, idle time, or system policy violations, or combinations thereof.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="57.91mm" wi="141.90mm" file="US08627317-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="270.26mm" wi="190.75mm" orientation="landscape" file="US08627317-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="249.60mm" wi="178.82mm" orientation="landscape" file="US08627317-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="259.08mm" wi="201.85mm" orientation="landscape" file="US08627317-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="256.20mm" wi="144.53mm" orientation="landscape" file="US08627317-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="248.24mm" wi="181.27mm" orientation="landscape" file="US08627317-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="249.00mm" wi="185.17mm" orientation="landscape" file="US08627317-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="202.69mm" wi="160.87mm" file="US08627317-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="180.68mm" wi="164.08mm" file="US08627317-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="238.08mm" wi="193.04mm" orientation="landscape" file="US08627317-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="223.94mm" wi="191.52mm" file="US08627317-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="180.00mm" wi="159.94mm" file="US08627317-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="256.20mm" wi="194.48mm" file="US08627317-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="240.37mm" wi="137.16mm" orientation="landscape" file="US08627317-20140107-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="247.48mm" wi="141.05mm" orientation="landscape" file="US08627317-20140107-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="225.38mm" wi="178.90mm" orientation="landscape" file="US08627317-20140107-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00016" num="00016">
<img id="EMI-D00016" he="221.40mm" wi="71.71mm" orientation="landscape" file="US08627317-20140107-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00017" num="00017">
<img id="EMI-D00017" he="240.37mm" wi="191.52mm" orientation="landscape" file="US08627317-20140107-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00018" num="00018">
<img id="EMI-D00018" he="257.73mm" wi="163.15mm" orientation="landscape" file="US08627317-20140107-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00019" num="00019">
<img id="EMI-D00019" he="252.14mm" wi="155.28mm" orientation="landscape" file="US08627317-20140107-D00019.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00020" num="00020">
<img id="EMI-D00020" he="228.09mm" wi="137.50mm" orientation="landscape" file="US08627317-20140107-D00020.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">The present application claims the benefit of U.S. Provisional Patent Application No. 61/317,512, filed on Mar. 25, 2010. That provisional application is incorporated herein by reference in its entirety.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">FIELD</heading>
<p id="p-0003" num="0002">The present application generally relates to computer systems and more particularly to identifying performance bottlenecks, idle time fault/policy violations and other process states in computer systems.</p>
<heading id="h-0003" level="1">BACKGROUND</heading>
<p id="p-0004" num="0003">Identifying performance problems, in particular scalability bottlenecks, is difficult and often left to a small number of performance experts. To know whether a system runs smoothly requires a careful collation of disparate observations. Typically, a performance expert knows the signifiers of certain classes of problems: e.g., errors in log files, or excessive time spent in garbage collection or waiting on data sources. After collecting as much data as is feasible to dredge from the system, the expert proceeds with the tedious task of altering and combining, and of applying rules, to interpret what the raw data implies about the quality of performance that the system currently achieves. Performance is often suboptimal due to a superposition of unrelated problems. The expert casts a wide net of data collection, in order to identify these problems so that they can be prioritized. Once the largest problem has been fixed, the process iterates.</p>
<p id="p-0005" num="0004">Few existing tools focus on identifying contended resources. However, those tools are not useful for identifying threads that are idle and unable to make progress. Rather, they generally focus on a particular class of problems, such as finding contended locks. That is, these tools focus on one point in the space of scalability analysis. Point tools can be effective once the class of a bottleneck is known. However, determining the class of a bottleneck, in itself, is a challenging step.</p>
<heading id="h-0004" level="1">BRIEF SUMMARY</heading>
<p id="p-0006" num="0005">A method and system for automatically identifying computer system performance bottlenecks and/or excess idle time may be provided. The method, in one aspect, may include collecting information associated with runtime execution of a computer system and inferring one or more execution states of one or more tasks within the system. The method may also include aggregating said one or more tasks by said one or more execution states for determining execution time, idle time, or system policy violations, or combinations thereof.</p>
<p id="p-0007" num="0006">A system for automatically identifying computer system performance bottlenecks using rule-based expert knowledge, in one aspect, may include a module operable to collect information associated with runtime execution of a computer system and infer one or more execution states of one or more tasks within the system. In another aspect, the system may also include an application interface operable to provide the summarized execution activity to a user. Yet in another aspect, the system may further include a user interface operable to provide the summarized execution activity to the user. The collected information may include infrequent samples of executing tasks.</p>
<p id="p-0008" num="0007">A computer readable storage medium storing a program of instructions executable by a machine to perform one or more methods described herein also may be provided.</p>
<p id="p-0009" num="0008">Further features as well as the structure and operation of various embodiments are described in detail below with reference to the accompanying drawings. In the drawings, like reference numbers indicate identical or functionally similar elements.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS</heading>
<p id="p-0010" num="0009"><figref idref="DRAWINGS">FIGS. 1A</figref>, <b>1</b>B, <b>1</b>C illustrate a method in one embodiment of automatically identifying bottlenecks in one embodiment of the present disclosure.</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 2</figref> is an architectural diagram illustrating functional components for a system that performs automatically identifying bottlenecks in one embodiment of the present disclosure.</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 3</figref> illustrates information that may be provided to the user in the form of a graphical user interface in one embodiment of the present disclosure.</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 4</figref> illustrates a structure of a JEE application.</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 5</figref> illustrates data sampled from a running JVM used for inferring the existence and nature of performance bottlenecks in one embodiment of the present disclosure.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 6</figref> illustrates examples of Wait States for samples inferred from information that includes monitor states and stack sample context inferences in one embodiment of the present disclosure.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 7A</figref> illustrates a wait state tree in one embodiment of the present disclosure.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 7B</figref> illustrates a category tree in one embodiment of the present disclosure.</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 8</figref> shows a call stack mapped to a stack of categories in one embodiment of the present disclosure.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 9</figref> illustrates a sample raw input from stack sampling in one embodiment of the present disclosure.</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 10</figref> illustrates a data model (structure) after clustering in one embodiment of the present disclosure.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 11</figref> illustrates a sample set of rules for categorizing in one embodiment of the present disclosure.</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 12</figref> illustrates a sample set of rules for inferring wait states in one embodiment of the present disclosure.</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 13</figref> illustrates an example report in one embodiment of the present disclosure.</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 14</figref> illustrates an example lock contention report in one embodiment of the present disclosure.</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 15</figref> illustrates an example deadlock report in one embodiment of the present disclosure.</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 16</figref> illustrates an example report that shows not enough load, in one embodiment of the present disclosure.</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 17</figref> illustrates an example report that show memory leak in one embodiment of the present disclosure.</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 18</figref> illustrates an example of a database bottleneck report in one embodiment of the present disclosure.</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 19</figref> illustrates an example report that shows a good throughput but filesystem bottleneck in one embodiment of the present disclosure.</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 20</figref> illustrates an example of a computer system, in which the systems and methodologies of the present disclosure may be carried out or executed.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0006" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIGS. 1A</figref>, <b>1</b>B, <b>1</b>C illustrate a method in one embodiment of automatically identifying bottlenecks and/or excess idle times of processes and/or threads. Referring to <figref idref="DRAWINGS">FIG. 1A</figref>, an application is running at <b>102</b>. There may be a plurality of applications running in the computer system, for instance, to perform one or more desired functions. The system and method of the present disclosure need not specifically run or start an application. Rather, the system and method of the present disclosure may work from data collected about the already running application on one or more computer systems. At <b>104</b>, information about the runtime execution of the computer system and running application is collected. The information about the runtime execution or the collected data may include but is not limited to, javacores or like system dumps, full trace of execution, vmstat information that includes virtual machine status information that shows machine utilization, and ps information that shows process utilization or status. The system and method of the present disclosure need not disrupt the running applications in order to obtain the runtime execution information or data. Further, they may be information that is collected infrequently.</p>
<p id="p-0032" num="0031">The information collected at <b>104</b> includes stack samples at <b>106</b>. The stack samples may include one or more process stack or thread stack or combinations thereof. A thread stack for example stores method calls, data, and operands which are pushed and popped into and out of the stack as the thread executes. A process stack stores similar elements.</p>
<p id="p-0033" num="0032">Optionally, the stack samples may be clustered at <b>108</b> resulting in one or more clustered stack samples at <b>110</b>. For example, raw data in the stack samples may indicate a thread executing the same instruction flow multiple times. Thus, duplicate or redundant call flow may be clustered into a single execution flow, for instance, for better manageability of data in the stack samples.</p>
<p id="p-0034" num="0033">At <b>112</b>, the stack samples, whether clustered (<b>110</b>) or raw (<b>106</b>), are categorized, producing one or more categorized stack samples at <b>114</b>. In one embodiment of the present disclosure, in order to categorize the stack samples, expert knowledge that includes rules for labeling a specific method found in the stack samples <b>120</b> and/or rules that determine whether or not a thread is running may be used and executed.</p>
<p id="p-0035" num="0034">That is, Method to Category Map at <b>120</b>, for example, may include set of rules to determine the category label for each stack frame. The rules may be defined based on expert knowledge of labeling various methods into a category. Details of this step are described further below with reference to <figref idref="DRAWINGS">FIG. 7B</figref>; a sample set of rules are shown in <figref idref="DRAWINGS">FIG. 11</figref>. Category to Thread State Map at <b>122</b>, for example, may include a set of rules for inferring wait states. Details of this step are described further below with reference to <figref idref="DRAWINGS">FIG. 7A</figref>; a sample set of rules are shown in <figref idref="DRAWINGS">FIG. 12</figref>.</p>
<p id="p-0036" num="0035">At <b>124</b>, monitors are extracted. The extract monitors step at <b>124</b> produces one or more monitor graphs <b>126</b>. Briefly, monitors are programming objects that achieve synchronization in concurrent programming. Monitors are implemented such that any of its methods are executed at most by one thread at a point in time, i.e., in mutual exclusion. Further, monitors also provide a mechanism for threads to temporarily give up exclusive access, in order to wait for some condition to be met, before regaining exclusive access and resuming their task. Monitors also have a mechanism for signaling other threads that such conditions have been met. Monitor graphs <b>126</b> show what threads are waiting on a critical section.</p>
<p id="p-0037" num="0036">At <b>116</b>, thread states are inferred using monitor graphs <b>126</b>, stack samples <b>114</b>, and maps (expert knowledge including e.g., various rules) <b>120</b>, <b>122</b>, producing the inferred thread states <b>118</b>. Further, information associated with the utilization of system resources <b>105</b> (e.g., disk usage/activity, network usage, and/or others) and garbage collection information <b>107</b> may be also used to infer thread states. The inferred thread states <b>118</b> provide information such as what a method on a stack is doing.</p>
<p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. 1B</figref> illustrates the details of inferred thread states, for example, the aggregation of inferred states. For instance, inferred states may be aggregated into runnable thread states <b>134</b> and waiting thread states <b>136</b>. Examples of states aggregated into runnable thread states <b>134</b> may include but not limited to, executing application work, executing garbage collection work, spinlocking, data copy (e.g., from network buffers). Such states may be displayed or presented as runnable pie chart graphics <b>130</b>. Examples of waiting thread states <b>136</b> may include but not limited to block on monitor, delayed by remote request, delayed by disk I/O (input/output), waiting for new application work, waiting for new garbage collection work, waiting at barrier (e.g., join after fork), and/or idle administrative thread. Such states also may be displayed or presented as waiting threads pie chart graphics <b>130</b>. Other types of graphic and non-graphic display or presentations may be provided for describing or presenting the inferred states.</p>
<p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. 1C</figref> illustrates detailed control flow for thread state inference, for example, inferring of blocked on monitor state for javacores. Stack samples at <b>140</b> are analyzed to extract monitors and generate monitor graph (e.g., as explained with reference to <figref idref="DRAWINGS">FIG. 1</figref> at <b>126</b>). At <b>142</b>, using the monitor graph, it may be determined whether a thread is blocked, i.e., waiting for a critical section. In the present disclosure, monitor graph is also referred to as lock graph. At <b>144</b>, if the thread is not blocked on monitor, the control (or logic of the method of the present disclosure) searches to infer other states. At <b>146</b>, it is determined that the thread is blocked on a monitor <b>148</b>. At <b>150</b>, the owner of the monitor <b>148</b> is determined. At <b>152</b>, a stack cluster of the monitor's owner is identified.</p>
<p id="p-0040" num="0039">At <b>154</b>, it is determined whether the owning stack sample is waiting to be notified on a condition variable. In the present disclosure, as in the standard terminology of Java&#x2122;, a monitor is either a condition variable or a lock. If no, at <b>156</b>, the thread is determined as being blocked, waiting on a monitor. Otherwise, at <b>158</b> the lock graph is inspected to determine the monitor <b>160</b> that the owning stack sample is waiting on. At <b>162</b>, the monitor's name is extracted and compared to the string, &#x201c;Thread public flags mutex&#x201d;. If the name of the monitor equals that string, then, at <b>156</b>, the thread is determined as being blocked, waiting on a monitor. Otherwise, at <b>144</b>, the control (or logic of the method of the present disclosure) searches to infer other states.</p>
<p id="p-0041" num="0040"><figref idref="DRAWINGS">FIG. 2</figref> is an architectural diagram illustrating functional components for a system that performs automatically identifying bottlenecks, idle time, fault/policy violations and other states of one or more processes in one embodiment of the present disclosure. As an example, Java&#x2122; code or other computer code <b>202</b> may include parsing functionalities <b>208</b> that, for example, javacores and native system dump data (pstack). The computer code <b>202</b> may also include one or more scripts (e.g., Javascript&#x2122; fixed code emitter and Javascript&#x2122; data model emitter) <b>210</b> or the like that emit expert knowledge rules (also referred to as a fixed code) and parsed stack sample data (also referred to as a data model). An example of parsed stack data in a form of a data model or structure is shown in <figref idref="DRAWINGS">FIG. 10</figref>.</p>
<p id="p-0042" num="0041">An engine <b>206</b> such as a standard Javascript&#x2122; engine or a processing module may apply the expert knowledge rules on the stack sample data and infer various states of the threads associated with the stack sample data. A Javascript&#x2122; engine may run by a Web Browser <b>204</b>, which may provide graphical user interface functionalities to the user.</p>
<p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. 3</figref> illustrates information that may be provided to the user in the form of a graphical user interface. Graphics such as a pie chart (<b>302</b>) or others may show the state of the threads and/or processes, for example, and why the threads are not running or blocked. The non-running threads may be grouped into different categories of reasons. The categories may include, for example, as shown at <b>302</b>, blocked monitor, delayed by remote request, delayed by disk input/output (I/O), waiting for work, idle admin thread, and others. A portion of the graphics, for instance, a pie slice may be further drilled down to present more details shown at <b>304</b>. For example, the details may show what program activity contributes to the pie slice; display raw stacks, and/or provide other information.</p>
<p id="p-0044" num="0043">More detail explanation of the above described method and component follows.</p>
<p id="p-0045" num="0044">The methodology of the present disclosure in one embodiment performs idle time analysis, for instance, and focusing on explaining idle time. Specifically, the methodology of the present disclosure in one embodiment tries to determine the root cause that leads to under-utilized processors. Additionally, the present disclosure in one embodiment also may provide for presenting information in a way that is easily consumable, and operate under restrictions typical of production deployment scenarios. In the present disclosure in one embodiment, a hierarchical abstraction of execution state presents a novel abstraction of concrete execution states, which provides a hierarchy of abstract states corresponding to different sources of idle time. Unlike traditional profiling tools, the present disclosure may present a high-level characterization of application behavior computed by an expert system. The expert system may be codified by a set of declarative rules, which a practitioner may easily customize. A methodology is presented in the present disclosure in one embodiment that infers behavior based on ubiquitous sampling mechanisms. The methodology may analyze performance effectively based on lightweight, non-intrusive sampling information available by default, for example, from standard Java&#x2122; Virtual Machines (JVMs) and operating systems. The end user need not restart, recompile, or otherwise modify the running application, for example, more readily allowing for wide-scale adoption of the methodology.</p>
<p id="p-0046" num="0045">In the present disclosure, the method and system (also referred collectively as a methodology) are explained with reference to an example case of performance diagnosis for a Java&#x2122; Enterprise Edition (JEE) application. However, it should be understood that the methodology of the present disclosure is not limited only to that application. <figref idref="DRAWINGS">FIG. 4</figref> illustrates a structure of a JEE application. A JEE application server, running Java&#x2122; code, sits in the middle of several communicating tiers of machines (e.g., like a hub) <b>402</b>; these tiers include clients, relational databases, and directory and caching services.</p>
<p id="p-0047" num="0046">To understand performance of this application, a methodology of the present disclosure in embodiment may use a Hub Sampling approach. With the approach, it is demonstrated how the analysis of only the Java&#x2122; tier can provide insight into bottlenecks in the system as a whole.</p>
<p id="p-0048" num="0047">Hub Sampling</p>
<p id="p-0049" num="0048">To identify primary bottlenecks in Java&#x2122;-hub applications, the methodology of the present disclosure in one embodiment collects samples of processor utilization and samples of the state of the Java&#x2122; threads. Production environments impose severe constraints on the types of monitoring and tools deemed acceptable. For example, code instrumentation is often a non-starter: many organizations will not rebuild an application with instrumentation, deploy a non-standard runtime system, or enable any non-trivial monitoring agent. Many organizations will not tolerate any observable performance overhead, except perhaps under limited and carefully controlled guidance. Additionally, many organizations will not tolerate large trace files, and will not allow any interactive access to the monitored systems.</p>
<p id="p-0050" num="0049">To work within these constraints, the methodology of the present disclosure in one embodiment may rely on ubiquitous monitoring technology, without requiring instrumentation or nontrivial agents. The methodology of the present disclosure in one embodiment also may make do with a relatively small corpus sample-based monitor data, collected during a small window and processed offline.</p>
<p id="p-0051" num="0050">The methodology of the present disclosure in one embodiment may use built-in sampling mechanisms most production JVMs provide, whereby the JVM will respond to signals and dump relatively small core (&#x201c;javacore&#x201d;) files with data representing the current JVM state.</p>
<p id="p-0052" num="0051"><figref idref="DRAWINGS">FIG. 5</figref> illustrates the data that is available from JVMs, without requiring any changes to an application's deployed configuration: the monitor graph <b>502</b>, which specifies the ownership and queuing relationships between threads and monitors; thread stack samples <b>504</b>; the conventional run state of each thread (i.e., Runnable, CondWait, Blocked, Parked); and a window of garbage collection events <b>506</b>. Furthermore, the methodology of the present disclosure in one embodiment uses infrequent samples, for example, acquired once or twice per minute, and provides results that yield surprising insight into the primary system bottlenecks.</p>
<p id="p-0053" num="0052">Idle Time Analysis</p>
<p id="p-0054" num="0053">Even with relatively infrequent samples, javacore dumps of JEE server applications can carry a tremendous volume of information. Consider simple stack samples: often stacks in a JEE application extend to several hundred stack frames spanning dozens of logical components from different vendors. Understanding the relevant information from even a single such stack requires a lot of work. Now consider that an application will typically have many dozens of threads performing various activities, and that to understand performance changes over time, one needs to inspect samples from at least several points in time. In this scenario, a tool can easily overwhelm a human with too much information. The fundamental problem is that the profile data lacks abstraction: there are too many distinct concrete methods in play, and a user cannot easily digest profile information spanning thousands of methods. While an expert with experience and intuition can probably navigate the raw data and diagnosis a problem, this task is usually too difficult for mere mortals.</p>
<p id="p-0055" num="0054">To address this problem, a methodology of the present disclosure in one embodiment analyzes the sample data and produces an abstract model of the application behavior, designed to illuminate bottlenecks. The analysis uses a set of expert rules to infer a hierarchical categorization of the state of threads across time. The rules depend on the participation of a thread in the monitor graph, and the names of methods on its call stack.</p>
<p id="p-0056" num="0055">In one aspect, the analysis machinery may be simple and run quickly, relying on pattern-matching and decision trees. However, the expert rules embody sophisticated understanding of various Java&#x2122; frameworks.</p>
<p id="p-0057" num="0056">At its coarsest level, the analysis assigns each thread an abstract state called a Wait State. A thread's Wait State specifies whether it is able to make forward progress, and if not, the nature of the hold up. Each state, such as &#x201c;Blocked&#x201d;, &#x201c;Disk&#x201d;, &#x201c;GC&#x201d;, and &#x201c;Network&#x201d;, represents a general class of delays, independent of application level details. In this way, the Wait States serve the same purpose as the conventional run states, but provide a richer semantics that helps identify bottlenecks. <figref idref="DRAWINGS">FIG. 6</figref> gives example inferences of Wait States. For a given example call stack associated with a trading application, the analysis would infer the Wait State &#x201c;Network&#x2019;, as the stack matches the pattern shown at <b>602</b> in <figref idref="DRAWINGS">FIG. 6</figref>.</p>
<p id="p-0058" num="0057">For each stack frame, a methodology of the present disclosure in one embodiment may compute an abstraction called a Category that represents the code or activity being performed by that method invocation. For example, a method invocation could indicate application-level activity such as Database Query, Client Communication, or JDBC Overhead. The methodology of the present disclosure in one embodiment may further label each stack sample with a Primary Category which best characterizes the activity being performed by an entire stack at the sampled moment in time.</p>
<p id="p-0059" num="0058">The abstract model of activity forms a hierarchy: a Wait State gives a coarse but meaningful abstraction of a class of behaviors. For more information, one can &#x201c;drill down&#x201d; through the model to see finer distinctions based on Primary Categories, stacks of Categories, and concrete stack samples without abstraction. This hierarchy provides a model for a user interface, which provides a high-level overview and the ability to drill down through layers of abstraction to pinpoint relevant details.</p>
<p id="p-0060" num="0059">The present disclosure in one embodiment provides for computing the abstraction described above based on a set of rules. The rules in one embodiment are defined declaratively by an expert based on knowledge of common methods in standard library and middleware stacks. Statistics and case studies indicate that the methodology is practical, and successfully identifies diverse sources of idle time.</p>
<p id="p-0061" num="0060">Hub Sampling is described in one embodiment in more detail herein. A methodology of the present disclosure in one embodiment relies on samples of processor activity and of the state of threads, for instance, in a JVM. The methodology of the present disclosure in one embodiment may take samples from the hub process (e.g., application server) of a multi-tier application, but can also collect data from any standard Java&#x2122; environment. Despite collecting no data from the other tiers, information from a hub process illuminates multi-tier bottlenecks.</p>
<p id="p-0062" num="0061">The following describes how a methodology of the present disclosure in one embodiment may collect information from a Java&#x2122; hub, for example, step <b>104</b> in <figref idref="DRAWINGS">FIG. 1A</figref>.</p>
<p id="p-0063" num="0062">Sampling Mechanisms</p>
<p id="p-0064" num="0063">A methodology of the present disclosure in one embodiment utilizes a collecting mechanism that is a low barrier to entry, since, many, if not most, potential users will reject any changes to deployment scripts, root permissions, kernel changes, specific software versions, or specialized monitoring agents. A methodology of the present disclosure in one embodiment collects samples of processor utilization, process utilization, and snapshots of Java&#x2122; activity using built-in mechanisms that are available on nearly every deployed Java&#x2122; system. Table 1 summarizes the mechanisms by which such a system may collect data.</p>
<p id="p-0065" num="0064">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="91pt" align="left"/>
<colspec colname="2" colwidth="49pt" align="left"/>
<colspec colname="3" colwidth="56pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="3" rowsep="1">TABLE 1</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>Data</entry>
<entry>UNIX</entry>
<entry>Windows</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>machine utilization</entry>
<entry>vmstat</entry>
<entry>typeperf</entry>
</row>
<row>
<entry/>
<entry>process utilization</entry>
<entry>ps</entry>
<entry>tasklist</entry>
</row>
<row>
<entry/>
<entry>Java&#x2009;&#x2122; state</entry>
<entry>kill -3</entry>
<entry>sendsignal</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0066" num="0065">Table 1 shows examples of the built-in mechanisms used in the present disclosure to sample the Java&#x2122; hub. Note &#x201c;kill-3&#x201d; does not terminate the signaled process, and 3 is the numeric code for SIGQUIT.</p>
<p id="p-0067" num="0066">A methodology of the present disclosure in one embodiment may also produce meaningful results with partial data. In practice, data sometimes arrives corrupted or prematurely terminated, due to a myriad of problems. For example, a target machine may run out of disk space while writing out data, the target JVM may have bugs in its data collection, or there may be simple user errors. If any of the sources of data described are incomplete, the methodology of the present disclosure in one embodiment may produce the best possible analysis based on the data available.</p>
<p id="p-0068" num="0067">Processor Utilization</p>
<p id="p-0069" num="0068">Most operating systems support non-intrusive processor utilization sampling. A methodology of the present disclosure in one embodiment attempts to collect time series of processor utilization at three levels of granularity: (1) for the whole machine, (2) for the process being monitored, and (3) for the individual threads within the process. For example, on UNIX platforms the methodology of the present disclosure in one embodiment may use vmstat and ps to collect this data.</p>
<p id="p-0070" num="0069">Java&#x2122; Thread Activity</p>
<p id="p-0071" num="0070">To monitor the state of Java threads, a methodology of the present disclosure in one embodiment may rely on the support built into JVMs to dump &#x201c;javacore&#x201d; files. The methodology of the present disclosure in one embodiment may support (parse) the javacore format produced in a system, for example, by IBM&#x2122; JVMs and the HotSpot JVM. The data that may be used to help diagnose process failures and deadlock can be sampled by issuing a signal to a running JVM process. Upon receiving this signal, the JVM stops running threads, and then writes out the information specified in <figref idref="DRAWINGS">FIG. 5</figref>. The JVM forces threads to quiesce using the same &#x201c;safepoint&#x201d; mechanism that is used by other standard JVM mechanisms, such as the garbage collector.</p>
<p id="p-0072" num="0071">IBM&#x2122; JVMs can produce javacore samples with fairly low perturbation. For a large application with several hundred threads with deep call stacks, writing out a javacore file may pause the application for several hundred milliseconds. As long as samples occur infrequently, writing javacores has a small effect on throughput. When the hub of a multi-tier application spans multiple processes, possibly running on multiple machines, a methodology of the present disclosure in one embodiment may choose one hub process at random. Thus, the methodology of the present disclosure may be applicable in multi-process environment, including cloud environment.</p>
<p id="p-0073" num="0072">The run states provided by the JVM and operating system are often inconsistent or imprecise, due to several complications. The first problem is that many JVM implementations quiesce threads at safepoints before dumping the javacore. Threads that are already quiesced (e.g., waiting to acquire a monitor) will be reported correctly as having a conventional run state of Blocked. However, any thread that was Runnable before triggering the dump will be reported to have a false run state of CondWait, since the thread was stopped by the JVM before writing the javacore file.</p>
<p id="p-0074" num="0073">The boundary between the JVM and the operating system introduces further difficulties with thread run states. The JVM and operating system (OS) each track the run state of a thread. The JVM may think a thread is Blocked, while the OS reports the same thread Runnable, in the midst of executing a spinlock. Spinning is sometimes a detail outside the JVM's jurisdiction, implemented in a native library called by the JVM. Similarly, the JVM may report a thread in a CondWait state, even though the thread is executing system code such as copying data out of network buffers or traversing directory entries in the filesystem implementation.</p>
<p id="p-0075" num="0074">Even if conventional run states were perfectly accurate, they often help little in diagnosing the nature of a bottleneck. Consider the conventional CondWait run state. One such thread may be waiting at a join point, in a fork join style of parallelism. Another thread, with the same CondWait run state, may be waiting for data from a remote source, such as a database. A third such thread may be a worker thread, idle only for want of work. For these reasons, a methodology of the present disclosure in one embodiment may instead compute on a richer thread state abstraction that distinguishes between these different types of states.</p>
<p id="p-0076" num="0075">The following describes a hierarchical abstraction of execution state. A methodology of the present disclosure in one embodiment may include an analysis that maps concrete program execution states into an abstract model, designed to illuminate root causes of idle time. The details of the abstraction hierarchy arise from a declarative specification. The analysis in one embodiment maps each sampled thread into an abstract state, which includes a pair of two elements called the Wait State and a stack of Categories. A Wait State encapsulates the status of a thread regarding its potential to make forward progress, while the a Category represents the code or activity being performed by a particular method invocation.</p>
<p id="p-0077" num="0076">The Wait State Abstraction</p>
<p id="p-0078" num="0077">The Wait State abstraction groups thread samples, assigning each sample a label representing common cases of forward progress (or the lack thereof). <figref idref="DRAWINGS">FIG. 7A</figref> shows an example of the hierarchy of Wait States which cover all possible concrete thread states. The analysis maps each concrete thread sample into exactly one node in the tree.</p>
<p id="p-0079" num="0078">At the coarsest level of the hierarchy <b>702</b>, the Wait State of a sampled thread indicates whether that thread is currently held up or making forward progress: Java threads may be either Waiting <b>704</b> or Runnable <b>706</b>. A third possibility may cover a thread executing native code (e.g., non-Java&#x2122;) that may not be characterized, in which case the thread is assigned Wait State Native Unknown <b>708</b>.</p>
<p id="p-0080" num="0079">For Java&#x2122; threads, the analysis partitions Waiting <b>704</b> and Runnable <b>706</b> into finer abstractions <b>710</b>, which convey more information regarding sources of idle time. For example, a Waiting thread might be waiting for data from some source (Awaiting Data), blocked on lock contention (Contention), or has put itself to sleep (Sleeping). As shown in <figref idref="DRAWINGS">FIG. 7</figref>, finer distinctions <b>712</b> are also possible. Consider a Sleeping thread: this could be part of a polling loop that contains a call to Thread.sleep (Poll); it could be the join in a fork join style of parallelism (Join); or it could be that the thread is a worker in a pool of threads, and is waiting for new work to arrive in the work queue (Awaiting Notification).</p>
<p id="p-0081" num="0080">Distinctions in Wait States may give a good first approximation of common sources of idle time in server applications. Furthermore, differences in Wait States may indicate fundamentally different types of problems that lead to idle time. A server application suffering from low throughput due to insufficient load would have many threads in the Awaiting Notification state. The solution to this problem might, for example, be to tune the load balancer. A system that improperly uses Thread.sleep suffers from a problem of a completely different nature. Similarly, having a preponderance of threads waiting for data from a database has radically different implications on the system health than many threads, also idle, suffering from lock contention.</p>
<p id="p-0082" num="0081">Thus, the Wait State gives a high-level description of the root cause of idle time in an application. The second part of the abstraction, the Category stack, gives a finer abstraction for pinpointing root causes.</p>
<p id="p-0083" num="0082">The Category Abstraction</p>
<p id="p-0084" num="0083">The Category abstraction in one embodiment assigns each stack frame a label representing the code or activity being performed by that method invocation. Category names provide a convenient abstraction that summarizes nested method invocations that implement larger units of functionality. Note that since each stack frame maps to a Category, each stack contains representatives from several Categories. To understand behavior of many stacks at a glance, it is useful to assign each stack a primary Category, which represents the Category which provides the best high-level characterization of the activity of the entire stack. For example, in an example stack sample, a JDBC Category may be chosen as the primary Category, based on priority logic that determines that the JDBC Category label conveys more information than other Categories in the stack, such as Networking or WebContainer.</p>
<p id="p-0085" num="0084"><figref idref="DRAWINGS">FIG. 7B</figref> shows an example of a subset of the Categories that may be modeled or established. As with Wait States, the Category abstract states form a tree. The primary distinction is drawn between activities, which name what a method is doing, and nicknames for common libraries and frameworks. Common activities include sorting and marshalling data, such as occurs in the handling of the extensible markup language (XML) data of Simple Object Access Protocol (SOAP) requests. Server applications may have dozens of administrative (Admin, in the figure) activities. These activities include background logging threads, cache eviction threads, and alarm threads that periodically probe for changes of files stored on disk.</p>
<p id="p-0086" num="0085">Category abstraction which reflects activities in well-known software components may be incomplete with respect to non-framework application code. A methodology of the present disclosure in one embodiment may include Category assignment, in the case of insufficient coverage of Category names. For example, a methodology of the present disclosure in one embodiment may assign &#x201c;Code Nickname&#x201d; <b>714</b> to application or software packages <b>714</b>. In one embodiment, a methodology of the present disclosure allows a practitioner to define new Category abstractions declaratively, in the specification of the analysis expert rules system.</p>
<p id="p-0087" num="0086">As shown in <figref idref="DRAWINGS">FIG. 7A</figref> and <figref idref="DRAWINGS">FIG. 7B</figref>, every concrete state, a sampled thread, may map to a pair of abstract states: a Wait State and a stack of Categories (one per frame). Every frame in a call stack may have a default name based on the invoked package, e.g., com.MyBank login( ) would be named MyBank Code.</p>
<p id="p-0088" num="0087"><figref idref="DRAWINGS">FIG. 8</figref> gives an example call stack, and the corresponding Category stack. The call stack is mapped to a stack of Categories, from which a primary Category (Database Communication) is chosen. For example, a call to the socketRead0 method belongs to the code that has been nicknamed Network. The com.mybank code has no nickname, nor known activity, and so is assigned its default name MyBank Code. The primary Category of this call stack is the highlighted Database Communication activity.</p>
<p id="p-0089" num="0088">Declarative rules indicate priorities used to choose the primary label for a stack. Sometimes the appropriate choice of priorities varies depending on who views the report. For example, in <figref idref="DRAWINGS">FIG. 8</figref>, if a network analyst were the primary viewer of the output, Network might be a better choice as the primary Category.</p>
<p id="p-0090" num="0089">Wait State Analysis Definition</p>
<p id="p-0091" num="0090">The above description informally introduced the abstraction. The following states more precisely the analysis performed by a methodology of the present disclosure in one embodiment:</p>
<p id="p-0092" num="0091">DEFINITION 1 (Wait State Analysis). Let k be the maximum stack depth of sampled threads, W be the tree of Wait States and C be the tree of Categories. We define a wait state analysis as a function that maps each sampled concrete thread state to an abstract state (w, c) &#x3b5; W&#xd7;C<sup>k</sup>. We say that w is the Wait State of a sampled thread, and c, its Category Stack, is a tuple whose components correspond to frames in the sampled call stack.</p>
<p id="p-0093" num="0092">DEFINITION 2 (Category Priorities and Primary Category). Let the call stack of a sampled thread contain methods m<sub>1</sub>, . . . , m<sub>k</sub>, and the output of a wait state analysis be (w, c), where the Categories are c=[c<sub>1</sub>, . . . , c<sub>k</sub>]. Each element of the Category mapping, m<sub>i</sub>&#x2192;c<sub>i</sub>, has a priority p<sub>i</sub>. The primary Category used by the sampled thread is that c<sub>i </sub>with maximum priority, and, in the case of ties, the one closest to the leaf invocation m<sub>1</sub>.</p>
<p id="p-0094" num="0093">The abstract model provides a backbone for progressive disclosure of details regarding thread activity, at a sampled moment in time. In practice, it may be most useful to start by clustering stack samples according to Wait State. A user request to focus on particular Wait States results in the navigation to a view that clusters the stack samples in that Wait State according to their primary Category. In this way, navigation of a user interface corresponds directly to traversals of the tree-structured abstract model.</p>
<p id="p-0095" num="0094">Analyzer</p>
<p id="p-0096" num="0095">An engine is now described that computes the analysis defined above. The analysis engine has three steps in one embodiment: 1) parse and transform the raw data, 2) infer Categories, and then 3) infer Wait States.</p>
<p id="p-0097" num="0096">ETL Step</p>
<p id="p-0098" num="0097">A methodology of the present disclosure in one embodiment may take input that includes raw javacore samples and raw output of machine utilization utilities. A pre-pass to the analysis performs an Extract-Transform-Load (ETL) step that parses the raw data and transforms it to a canonical form, which abstracts away irrelevant details that vary from platform to platform.</p>
<p id="p-0099" num="0098"><figref idref="DRAWINGS">FIG. 9</figref> provides a more detailed summary of the raw data available in a javacore thread sample, including the name of thread sampled, its native thread identifier (e.g. on UNIX, this turns out to be the address of the corresponding pthread data structure), the call stack as a list of method names, and information about how this thread interacts with the monitors. The raw input from stack sampling may provide this data for each sampled thread. Each monitor and thread has a hexadecimal address and a name (not shown).</p>
<p id="p-0100" num="0099">The ETL step consumes this data and produces the data model or data structure shown in <figref idref="DRAWINGS">FIG. 10</figref>. First, a methodology of the present disclosure may compute equivalence classes of thread samples, where two thread samples are considered equivalent if they represent the same stack of methods and locking status. <figref idref="DRAWINGS">FIG. 10</figref> labels these equivalence classes as call stack clusters. <figref idref="DRAWINGS">FIG. 10</figref> illustrates the input concrete data model, after clustering and optimization. This example shows that cluster c<b>1</b> (<b>1002</b>), which occurred 3592 times across all application samples, was invoked in thread t<b>3</b> in the second application sample (<b>1004</b>) (sample index <b>2</b>).</p>
<p id="p-0101" num="0100">The output model represents the data in a tabular fashion, similar to a relational database. Other format for the data model may be possible. Viewing the count row of the call stack clusters table in <figref idref="DRAWINGS">FIG. 10</figref> reveals that cluster c<b>1</b> occurred 3592 times across all application samples. Viewing table &#x201c;blocked&#x201d; <b>1006</b> in <figref idref="DRAWINGS">FIG. 10</figref> indicates that in the first and last application samples, cluster c<b>1</b> was waiting to enter the critical section guarded by monitor m<b>2</b>. Viewing the &#x201c;owned by&#x201d; table <b>1008</b> in turn reveals that m<b>2</b> was owned by cluster c<b>2</b>. In other words, thread stack c<b>1</b> was blocked on a monitor held by thread stack c<b>2</b>.</p>
<p id="p-0102" num="0101">Category Analysis</p>
<p id="p-0103" num="0102">A methodology of the present disclosure in one embodiment may rely on a pattern-matching system, driven by a set of rules to determine the Category label for each stack frame. The A methodology of the present disclosure in one embodiment may rely on a simple declarative specification of textual patterns that define Categories. The declarative rules that define the Category analysis define two models. The first model is a Category Tree, such as the one shown in <figref idref="DRAWINGS">FIG. 7B</figref>. A Category Tree provides the namespace, inheritance structure, and prioritization of the Category abstractions that are available as method labels. The second model is a set of rules. Each rule maps a regular expression over method names to a node in the Category Tree. For example, <figref idref="DRAWINGS">FIG. 11</figref> shows rules that, in part, define Database activity. The rules distinguish between five aspects of database activity: queries, batch queries, commits, rollbacks, iteration over result sets. This example illustrates how it is easy to define a Category Tree that is more precise than the one shown in <figref idref="DRAWINGS">FIG. 7B</figref>.</p>
<p id="p-0104" num="0103">Given these rules, the Category analysis engine iterates over every frame of every call stack cluster, looking for the highest-priority rule that matches each frame. In one embodiment, every method has an implicit Category, its package which is assigned to the Category's Code Nickname. Thus, if no Category rule applies to a frame, then the methodology of the present disclosure in one embodiment forms an ad hoc Category for that frame: a method P<b>1</b>/P<b>2</b>/P<b>3</b>/ . . . /Class.Method receives the Code Nickname P<b>2</b> Code.</p>
<p id="p-0105" num="0104">Wait State Analysis</p>
<p id="p-0106" num="0105">In addition to inferring Categories, methodology of the present disclosure in one embodiment infers a Wait State as illustrated in <figref idref="DRAWINGS">FIG. 7A</figref>. The analysis to infer Wait States in one embodiment combines three sources of information: processor utilization, the concrete data model (an example of which is shown in <figref idref="DRAWINGS">FIG. 10</figref>), and rules based on method names. The rules over method names, in some cases, may need the inspection of multiple frames in stack. This differs from the Category analysis, where each frame's Category is independent of other frames.</p>
<p id="p-0107" num="0106">The main challenge in using method names to infer a Wait State concerns handling imperfect knowledge of an application's state. For instance, the true Wait State of a sampled thread is, in many cases, not knowable. To fill this knowledge gap, the methodology of the present disclosure in one embodiment may use expert knowledge about the meaning of activities, based on method names. In one aspect, many aspects of Wait States depend on the meaning of native methods, and the use of native methods does not vary greatly from application to application.</p>
<p id="p-0108" num="0107">An algorithm for inferring proceeds as a sieve, looking for the Wait State that can be inferred with the most certainty. The algorithm uses data from the concrete data model (e.g., shown in <figref idref="DRAWINGS">FIG. 10</figref>) as well as a set of rules over method names, specified declaratively with patterns (analogous to the Category Analysis).</p>
<p id="p-0109" num="0108">The Wait State of a given call stack cluster c at sample index i is the first match found when traversing the following conditions, in order:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0109">1. Deadlock: if this stack cluster participates in a cycle of lock contention in the monitor graph; i.e., there is a cycle in the Blocked and Owned By relations.</li>
        <li id="ul0002-0002" num="0110">2. Lock Contention: if the stack cluster, at the moment in time of sample i, has an entry in the Blocked relation.</li>
        <li id="ul0002-0003" num="0111">3. Awaiting Notification: if the stack cluster, at the moment in time of sample i, has an entry in the Waiting relation.</li>
        <li id="ul0002-0004" num="0112">4. Spinlock: if the Wait State rule set defines a method in c that with high certainty, implies the use of spinlocking Many methods in the java.util.concurrent library fall in this high-certainty category.</li>
        <li id="ul0002-0005" num="0113">5. Awaiting Data from Disk, Network: if the rule set matches c as a use of a filesystem or a network interface. Most such rules need only inspect the leaf invocation of the stack, e.g. a socketRead native invocation is an indication that this stack sample cluster is awaiting data from the network. In some cases, requests for data are dispatched to a &#x201c;stub/tie&#x201d; method, as is common in LDAP or ORB implementations.</li>
        <li id="ul0002-0006" num="0114">6. Executing Java Code: if the method invoked by the top of the stack is not a native method, then c is assumed to be Runnable, executing Java code.</li>
        <li id="ul0002-0007" num="0115">7. Executing Native Code: if the method invoked by the top of the stack is a native method, and the rule set asserts that this native method is truly running, then the methodology of the present disclosure in one embodiment may infer that the native method is Runnable. The methodology of the present disclosure in one embodiment may treat native and Java&#x2122; invocations asymmetrically, to increase robustness. A Java&#x2122; method, unless it participates in the monitor graph, is almost certain to be Runnable. The same cannot be said of native methods. Native methods more often than not, serve the role of fetching data, rather than executing code. Therefore, the methodology of the present disclosure in one embodiment may require native methods to be whitelisted in order to be considered Runnable.</li>
        <li id="ul0002-0008" num="0116">8. JVM Services: if c has no call stack, it is assumed to be executing native services. Any compilation and Garbage Collection threads, spawned by the JVM itself, fall into this category. Even though these call stack samples have no call stacks, and unreliable thread states, they participate in the monitor graph. Thus, unless they are observed to be in a Contention or Awaiting Notification state, the methodology of the present disclosure in one embodiment may assume they are Runnable, executing JVM Services.</li>
        <li id="ul0002-0009" num="0117">9. Poll, IOWait, Join Point: if there exists a rule that describes the native method at the top of the stack as one of these variants of Sleeping.</li>
        <li id="ul0002-0010" num="0118">10. NativeUnknown: any call stack cluster with a native method at the top of the stack and not otherwise classified is placed into the NativeUnknown Wait State. This classification is in contrast to call stack clusters with Java&#x2122; leaf invocations, which are assumed to be Runnable. For robustness, the algorithm in one embodiment may require call stacks with native leaf invocations to be specified by rules to be in some particular Wait State. This allows users to quickly spot deficiencies in the rule set. In practice, the methodology of the present disclosure in one embodiment for handling of native methods is robust enough that this state fires rarely.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0110" num="0119">Rules for Wait States</p>
<p id="p-0111" num="0120">The syntax for declaring Wait State rules is more general than that for Category rules in one embodiment, which depend on exactly one method name. In particular, rules can specify antecedents which depend on a conjunction of frame patterns appearing together in a single stack, as illustrated in <figref idref="DRAWINGS">FIG. 12</figref>. For convenience, the rules engine allows a declarative specification of tags, which are auxiliary labels which can be attached to a stack to encode information consumed by other rules which produce Wait States. <figref idref="DRAWINGS">FIG. 12</figref> at <b>1202</b> shows an example that matches against two frames, and relies on an auxiliary tag (% CondVar) which labels various manifestations of waiting on a condition variable.</p>
<p id="p-0112" num="0121">Rule Coverage</p>
<p id="p-0113" num="0122">The present disclosure provides for a stable, and possibly small, set of rules that can achieve good coverage on range of diverse inputs. For the Category analysis, a small number of rules are used to capture a wide range of Categories. Table 4 at (a) characterizes most of the Category rules that may be defined. For example, a rule set may cover five common JDBC libraries, including IBM&#x2122; DB2 and Microsoft&#x2122; SqlServer, with only 72 rules. The number of rules specific to a particular JDBC implementation lies on the order of 10-20, as shown in Table 4 at (b). The rules are stable across versions of any one implementation. For example, the same set of rules may cover known versions and platforms of the DB2&#x2122; JDBC driver, for example, three versions of the code and four platforms.</p>
<p id="p-0114" num="0123">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="105pt" align="left"/>
<colspec colname="2" colwidth="84pt" align="center"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="2" rowsep="1">TABLE 3</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>Wait Sate Rule</entry>
<entry>#Rules</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>Waiting on Condition Variable</entry>
<entry>26</entry>
</row>
<row>
<entry/>
<entry>Native Runnable</entry>
<entry>22</entry>
</row>
<row>
<entry/>
<entry>Awaiting Data from Disk, Network</entry>
<entry>16</entry>
</row>
<row>
<entry/>
<entry>Spinlock</entry>
<entry>12</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0115" num="0124">
<tables id="TABLE-US-00003" num="00003">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="105pt" align="center"/>
<colspec colname="2" colwidth="7pt" align="center"/>
<colspec colname="3" colwidth="84pt" align="center"/>
<colspec colname="4" colwidth="7pt" align="center"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="4" rowsep="1">TABLE 4</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry namest="offset" nameend="4" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>(a) Rules, by Category</entry>
<entry/>
<entry>(b) Database, by provider</entry>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="center"/>
<colspec colname="3" colwidth="42pt" align="left"/>
<colspec colname="4" colwidth="49pt" align="center"/>
<tbody valign="top">
<row>
<entry/>
<entry>Category</entry>
<entry># Rules</entry>
<entry>Category</entry>
<entry># Rules</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="4" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="42pt" align="left"/>
<colspec colname="4" colwidth="49pt" align="char" char="."/>
<tbody valign="top">
<row>
<entry/>
<entry>Database</entry>
<entry>72</entry>
<entry>DB2</entry>
<entry>18</entry>
</row>
<row>
<entry/>
<entry>Administrative</entry>
<entry>59</entry>
<entry>MySQL</entry>
<entry>14</entry>
</row>
<row>
<entry/>
<entry>Client Communication</entry>
<entry>41</entry>
<entry>Oracle</entry>
<entry>12</entry>
</row>
<row>
<entry/>
<entry>Disk, Network I/O</entry>
<entry>46</entry>
<entry>Apache</entry>
<entry>8</entry>
</row>
<row>
<entry/>
<entry>Waiting for Work</entry>
<entry>30</entry>
<entry>SqlServer</entry>
<entry>6</entry>
</row>
<row>
<entry/>
<entry>Marshalling</entry>
<entry>30</entry>
</row>
<row>
<entry/>
<entry>JEE</entry>
<entry>22</entry>
</row>
<row>
<entry/>
<entry>Classloader</entry>
<entry>13</entry>
</row>
<row>
<entry/>
<entry>Logging</entry>
<entry>12</entry>
</row>
<row>
<entry/>
<entry>LDAP</entry>
<entry>6</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="4" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0116" num="0125">A Software Tool/System</p>
<p id="p-0117" num="0126">The methodology of the present disclosure, for example, based on the abstractions and analyses described above, may be implemented as a software-as-a-service deployed in a computer system infrastructure. The tool further may include a user interface module that may provide various information and interactions with a user, for instance.</p>
<p id="p-0118" num="0127">Tool Architecture</p>
<p id="p-0119" num="0128">In general, the tool is designed to have a low barrier to entry, to be simple and easy to use. The tool may be implemented as a service. Using the tool may involve three steps:
<ul id="ul0003" list-style="none">
    <li id="ul0003-0001" num="0000">
    <ul id="ul0004" list-style="none">
        <li id="ul0004-0001" num="0129">1. Collect one or more javacores. This can be done manually, or by using a data collection script the methodology of the present disclosure in one embodiment may generate that collects machine utilization and process utilization.</li>
        <li id="ul0004-0002" num="0130">2. Upload the collected data to a server through a web interface.</li>
        <li id="ul0004-0003" num="0131">3. View the report in a browser.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0120" num="0132">A service architecture may offer the following advantages:
<ul id="ul0005" list-style="none">
    <li id="ul0005-0001" num="0000">
    <ul id="ul0006" list-style="none">
        <li id="ul0006-0001" num="0133">Zero-install. The user can use the methodology of the present disclosure without having to install any software.</li>
        <li id="ul0006-0002" num="0134">Easy to collaborate. A report can be shared and discussed by forwarding a single URL.</li>
        <li id="ul0006-0003" num="0135">Incrementally refined knowledge base. By having access to the data submitted to the service, a service team can monitor the reports being generated and continually improve the knowledge base when existing rules prove insufficient.</li>
        <li id="ul0006-0004" num="0136">Cross-report analysis. Having access to a large number of reports allows looking for trends that may not stand out clearly in a single report.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0121" num="0137">A service-based tool includes a network connection to the server, for example, from a customer site. Privacy concerns with uploading the data to a central server may be mitigated by a server behind a corporate firewall. A clone service may be also deployed on a client's own server to satisfy more strict privacy requirements.</p>
<p id="p-0122" num="0138">User Interface</p>
<p id="p-0123" num="0139"><figref idref="DRAWINGS">FIG. 13</figref> shows a screenshot of a report being viewed in a Web Browser, e.g., Mozilla Firefox&#x2122;. The report is intended to be scanned from top to bottom, as this order aligns with the logical progression of questions an expert would likely ask when diagnosing a performance problem.</p>
<p id="p-0124" num="0140">Activity Summary</p>
<p id="p-0125" num="0141">The top portion of the report presents a high-level view of the application's behavior. The pie charts on the left present data averaged over the whole collection period, while timelines on the right show how the behavior changed over time. The top row shows the machine utilization during the collection period, breaking down the activity into four possible categories: Your Application (the Java&#x2122; program being monitored), Garbage Collection, Other Processes, and Idle. This overview appears in the report first because it represents the first property one usually checks when debugging a performance problem. In this particular report, the CPU utilization drops to zero roughly &#x2153; of the way through the collection period, a common occurrence when problems arise in a multi-tier application.</p>
<p id="p-0126" num="0142">The second and third rows report the Wait State of all threads found running in the JVM. The second row shows threads that are Runnable, while the third row shows threads that are Waiting. Each bar in the timeline represents the data from one Javacore. This example shows as many as 65 Runnable threads for the first 8 javacores taken, at which point all runnable activity ceased, and the number of Waiting threads shot up to 140, all in Wait State Delayed by Remote Request. This label corresponds to the &#x201c;Awaiting Data&#x201d; in <figref idref="DRAWINGS">FIG. 7A</figref>. Skimming the top portion of the report enables a user to quickly see that CPU idle time follows from threads backing up in a remote request to another tier.</p>
<p id="p-0127" num="0143">Category Viewer</p>
<p id="p-0128" num="0144">The lower left hand pane of the report shows a breakdown of most active Categories executing in the application. Clicking on a pie slice or bar in the above charts causes the Category pane to drill down, showing the Category breakdown for the Wait State that was clicked. This report shows that all but one of the threads in Wait State Delayed by Remote Request were executing Category Getting Data from Database. This indicates that the source of this problem stems from the database becoming slow or unresponsive. The utility of the tool may stem from the ease with which the user can narrow down the problem to the database, without having even looked at logs from the database machine.</p>
<p id="p-0129" num="0145">Stack Viewer</p>
<p id="p-0130" num="0146">Glancing at the commonly occurring Wait States and Category activity often suffices to rapidly identify bottlenecks; however, the tool may provide one additional level of drilldown. Selecting a bar in the report opens a stack viewer pane to display all call stacks that match the selected Wait State and Category. Stacks are sorted by most common occurrence to help identify the most important bottlenecks. Having full stack samples available has proven valuable not only for understanding performance problems, but for fixing them. The stacks allow mapping back to source code with full context and exact lines of code where the backups are occurring. Passing this information on to the application developers is often sufficient for them to identify a fix. The presence of thread stacks makes the tool useful not only for analyzing waiting threads, but also for identifying program hot spots. Clicking on the Runnable Threads pie slice causes the Stack Viewer to display the most commonly occurring running threads. Browsing the top candidates often produces surprising results such as seeing &#x201c;logging activity&#x201d; or &#x201c;date formatter&#x201d; appear near the top, suggesting wasted cycles and easy opportunities for streamlining the code.</p>
<p id="p-0131" num="0147">In one aspect, the user interface of the present disclosure may take minimalistic approach, striving to present a small amount of semantically rich data to users rather than overloading them with mountains of raw data. The tool may be effective for quick analysis of performance problems. The pairing of the analyses together with drilldown to full stack traces has proven to be a powerful combination. The abstractions of the present disclosure guide the user's focus in the right direction, and present a set of concrete thread stacks that can be used to confirm the hypotheses. A user also may view the full stack traces to quickly confirm the abstractions.</p>
<p id="p-0132" num="0148">The methodology of the present disclosure in one embodiment may be coded in a combination of Java&#x2122; and Javascript. The ETL step of parsing the raw data and producing the data model (e.g., <figref idref="DRAWINGS">FIG. 2</figref> at <b>208</b> and <b>210</b>) may run in Java&#x2122; and execute on the server once, when a report is created. The remaining analyses (Wait State analysis and Category analysis) may run in Javascript and execute in the browser (e.g., <figref idref="DRAWINGS">FIG. 2</figref> at <b>204</b>) each time a report is loaded. This design may allow users to modify the rules or select alternate rules configurations without a round trip to the server. This design also allows reports, once generated, to be viewed in headless mode without a server present; the browser can load the report off a local disk and maintain full functionality of the report. Other design configurations are possible.</p>
<p id="p-0133" num="0149">Lock Contention and Deadlock</p>
<p id="p-0134" num="0150"><figref idref="DRAWINGS">FIG. 14</figref> illustrates a sample report on a 48-core system. The Waiting Threads timeline shows a sudden and sustained surge of Blocked on Monitor; i.e. threads seeking a lock and not receiving it, and thus being blocked from making progress. Looking at the Category breakdown suggests that lock contention comes from miscellaneous APACHE OPENJPA Code. The thread stacks from this category identify the location of the lock contention as line <b>364</b> of getMetaDataLocking( ). Sometimes locking issues go beyond contention to the point of deadlock or livelock. When the tool of the present disclosure detects a cycle in the monitor graph, their Wait State is Blocked on Deadlock. This situation appears in <figref idref="DRAWINGS">FIG. 15</figref>. Looking at the thread stacks at the lower right of the report suggests that the threads are waiting for a lock in the logging infrastructure method SystemOutStream.processEvent( ) line <b>277</b>. With this information, a programmer could look at the code and try to determine the reason for the deadlock.</p>
<p id="p-0135" num="0151">Not Enough Load</p>
<p id="p-0136" num="0152">The example report shown in <figref idref="DRAWINGS">FIG. 16</figref> shows that the machine was 67% idle, and the timeline confirms that utilization was consistently low during the entire monitoring period. The Waiting Threads piechart indicates that threads spend most of their time Delayed by Remote Request. Digging more deeply, the Category view indicates that the remote request on which the threads are delayed is client communication using an HTTP protocol. In this case, the performance problem is not with the server machine, but that the amount of data being received from the client machine is not sufficient to keep the server busy. Indeed it is possible that there is no problem in this situation, other than that the server may be over provisioned for this workload. To determine whether the client is generating a small amount data or if the network between the client and server is under-provisioned to handle the request traffic, a network utility such as netstat could be employed, or the CPU utilization of client machines could be investigated.</p>
<p id="p-0137" num="0153">Memory Leak</p>
<p id="p-0138" num="0154">The tool of the present disclosure may also detect memory leaks. As shown in <figref idref="DRAWINGS">FIG. 17</figref>, a memory leak can be detected by looking at just the first timeline, which shows garbage collection activity over time. In this example, initially the non-GC work dominates, but over time the garbage collection activity increases until it eventually consuming most of the non-idle CPU cycles. The large increase in garbage collection as time passes is strong evidence that the heap is inadequate for the amount of live memory; either the heap size is not appropriate for the workload, or that the application has a memory leak.</p>
<p id="p-0139" num="0155">Database Bottleneck</p>
<p id="p-0140" num="0156"><figref idref="DRAWINGS">FIG. 18</figref> presents an example of a database bottleneck. Unlike <figref idref="DRAWINGS">FIG. 13</figref> where the database became completely unresponsive, in this case the database is simply struggling to keep up with the application server's requests. Over time the server's utilization varies between approximately 10% and 85%, and these dips in utilization correlate roughly with the spikes in the number of threads in Waiting state Delayed by Remote Request and Category Getting Data from Database, thus pointing to the likely source of the delay. Clicking on the orange bar for Getting Data from Database reveals the thread stacks that a developer can analyze to determine key parts of the application delayed by the database, and try to reduce the load generated against the database. Alternatively, the database could be optimized or deployed on faster hardware.</p>
<p id="p-0141" num="0157">Disk I/O Affecting Latency</p>
<p id="p-0142" num="0158"><figref idref="DRAWINGS">FIG. 19</figref> shows an example report where filesystem activity is limiting performance. The top two pie charts and timelines show that there is enough Java&#x2122; code activity to keep the CPUs well-utilized. However, the Waiting activity show a significant number of threads in Wait State Delayed by Disk I/O, and CategoryFilesystem Metadata Operations, suggesting room for improvement with faster disks, or by restructuring the code to perform fewer disk operations. Reducing these delays would improve latency, since each transaction would spend less time waiting on Disk I/O, but such improvement would have other benefits as well. Even though the four CPUs on this machine are currently well utilized, this application will likely scale poorly on larger machines. As the number of processors increases, the frequent disk access delays will eventually become a scaling bottleneck. The tool of the present disclosure can help identify these scaling limiters early in the development process.</p>
<p id="p-0143" num="0159">The methodology of the present disclosure may be used for performance analysis of modern enterprise-class server applications as well. For instance, performance bottlenecks in these applications differ qualitatively from bottlenecks in smaller, stand-alone systems. Small applications and benchmarks often suffer from central processing unit (CPU)-intensive hot spots. Enterprise-class multi-tier applications often suffer from problems that manifest not as hot spots, but as idle time indicating a lack of forward motion. Many factors can contribute to undesirable idle time, including locking problems, excessive system-level activities like garbage collection, various resource constraints, and problems driving load.</p>
<p id="p-0144" num="0160">Part of the challenges of performance analysis for modern enterprise-class server applications may stem from the fact that these systems run across multiple physical tiers, and their software comprises many components from different vendors and middleware stacks. Many of these applications support a high degree of concurrency, serving thousands or even millions of concurrent user requests. They support rich and frequent interactions with other systems, with no intervening human think time. Many server applications manipulate large data sets, requiring substantial network and disk infrastructure to support bandwidth requirements. With these requirements and complexities, such applications face untold difficulties when attempting to scale for heavy production loads. With dozens of industrial applications, every individual deployment introduces a unique set of challenges, due to issues specific to a particular configuration. Any change to key configuration parameters, such as machine topology, application parameters, code versions, and load characteristics, can cause severe performance problems due to unanticipated interactions.</p>
<p id="p-0145" num="0161">Part of the challenge arises from the sheer diversity of potential pitfalls. Even a single process can suffer from any number of bottlenecks, including concurrency issues from thread locking behavior, excessive garbage collection load due to temporary object churn, and saturating the machine's memory bandwidth. Any of these problems may appear as a serialization bottleneck in that the application fails to use multiple threads effectively; however, one needs to drill down further to find the root cause. Other problems can arise from limited capacity of physical resources including disk I/O and network links. A load balancer may not effectively distribute load to application clones. When performance testing, testers often encounter problems generating load effectively. In such cases, the primary bottleneck may be processor or memory saturation on a remote node, outside the system-undertest.</p>
<p id="p-0146" num="0162">Furthermore, many profiling and performance understanding tools may be inappropriate for commercial server environments. Many tools rely on restarting or instrumenting an application, which is often forbidden in commercial deployment environments. Similarly, many organizations will not deploy any unapproved monitoring agents, nor tolerate any significant perturbation of the running system. In practice, diagnosing performance problems under such constraints resembles detective work, where the analyst pieces together clues from incomplete information.</p>
<p id="p-0147" num="0163">Addressing performance analysis under these constraints, the methodology of the present disclosure in one aspect performs idle time analysis, for instance, focusing on explaining idle time rather than what an application is doing. The methodology of the present disclosure may diagnose the root cause of idle time in server applications. Given lightweight samples of system (e.g., Java&#x2122;) activity on a single tier, the methodology of the present disclosure may pinpoint the primary bottleneck on a multi-tier system. The methodology may center on an informative abstraction of the states of idleness observed in a running program. This abstraction allows the methodology of the present disclosure to distinguish, for example, between hold-ups on a database machine, insufficient load, lock contention in application code, and a conventional bottleneck due to a hot (busy or congested) method. To compute the abstraction, the present application also provides for an expert system based on an extensible set of declarative rules. A system or a methodology of the present disclosure for diagnosing the cause of idle time in an application (e.g., a server application) may be deployed on the fly (i.e., dynamically on a running system and application), without modifying or restarting the application.</p>
<p id="p-0148" num="0164">As will be appreciated by one skilled in the art, aspects of the present invention may be embodied as a system, method or computer program product. Accordingly, aspects of the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a &#x201c;circuit,&#x201d; &#x201c;module&#x201d; or &#x201c;system.&#x201d; Furthermore, aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium(s) having computer readable program code embodied thereon.</p>
<p id="p-0149" num="0165">Any combination of one or more computer readable medium(s) may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be, for example, but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, or device, or any suitable combination of the foregoing. More specific examples (a non-exhaustive list) of the computer readable storage medium would include the following: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), an optical fiber, a portable compact disc read-only memory (CD-ROM), an optical storage device, a magnetic storage device, or any suitable combination of the foregoing. In the context of this document, a computer readable storage medium may be any tangible medium that can contain, or store a program for use by or in connection with an instruction execution system, apparatus, or device.</p>
<p id="p-0150" num="0166">A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein, for example, in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms, including, but not limited to, electro-magnetic, optical, or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate, propagate, or transport a program for use by or in connection with an instruction execution system, apparatus, or device.</p>
<p id="p-0151" num="0167">Program code embodied on a computer readable medium may be transmitted using any appropriate medium, including but not limited to wireless, wireline, optical fiber cable, RF, etc., or any suitable combination of the foregoing.</p>
<p id="p-0152" num="0168">Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages, including an object oriented programming language such as Java, Smalltalk, C++ or the like and conventional procedural programming languages, such as the &#x201c;C&#x201d; programming language or similar programming languages. The program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).</p>
<p id="p-0153" num="0169">Aspects of the present invention are described below with reference to flowchart illustrations and/or block diagrams of methods, apparatus (systems) and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and/or block diagrams, and combinations of blocks in the flowchart illustrations and/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions/acts specified in the flowchart and/or block diagram block or blocks.</p>
<p id="p-0154" num="0170">These computer program instructions may also be stored in a computer readable medium that can direct a computer, other programmable data processing apparatus, or other devices to function in a particular manner, such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function/act specified in the flowchart and/or block diagram block or blocks.</p>
<p id="p-0155" num="0171">The computer program instructions may also be loaded onto a computer, other programmable data processing apparatus, or other devices to cause a series of operational steps to be performed on the computer, other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions/acts specified in the flowchart and/or block diagram block or blocks.</p>
<p id="p-0156" num="0172">The flowchart and block diagrams in the figures illustrate the architecture, functionality, and operation of possible implementations of systems, methods and computer program products according to various embodiments of the present invention. In this regard, each block in the flowchart or block diagrams may represent a module, segment, or portion of code, which comprises one or more executable instructions for implementing the specified logical function(s). It should also be noted that, in some alternative implementations, the functions noted in the block may occur out of the order noted in the figures. For example, two blocks shown in succession may, in fact, be executed substantially concurrently, or the blocks may sometimes be executed in the reverse order, depending upon the functionality involved. It will also be noted that each block of the block diagrams and/or flowchart illustration, and combinations of blocks in the block diagrams and/or flowchart illustration, can be implemented by special purpose hardware-based systems that perform the specified functions or acts, or combinations of special purpose hardware and computer instructions.</p>
<p id="p-0157" num="0173">Referring now to <figref idref="DRAWINGS">FIG. 20</figref>, the systems and methodologies of the present disclosure may be carried out or executed in a computer system that includes a processing unit <b>2</b>, which houses one or more processors and/or cores, memory and other systems components (not shown expressly in the drawing) that implement a computer processing system, or computer that may execute a computer program product. The computer program product may comprise media, for example a hard disk, a compact storage medium such as a compact disc, or other storage devices, which may be read by the processing unit <b>2</b> by any techniques known or will be known to the skilled artisan for providing the computer program product to the processing system for execution.</p>
<p id="p-0158" num="0174">The computer program product may comprise all the respective features enabling the implementation of the methodology described herein, and which&#x2014;when loaded in a computer system&#x2014;is able to carry out the methods. Computer program, software program, program, or software, in the present context means any expression, in any language, code or notation, of a set of instructions intended to cause a system having an information processing capability to perform a particular function either directly or after either or both of the following: (a) conversion to another language, code or notation; and/or (b) reproduction in a different material form.</p>
<p id="p-0159" num="0175">The computer processing system that carries out the system and method of the present disclosure may also include a display device such as a monitor or display screen <b>4</b> for presenting output displays and providing a display through which the user may input data and interact with the processing system, for instance, in cooperation with input devices such as the keyboard <b>6</b> and mouse device <b>8</b> or pointing device. The computer processing system may be also connected or coupled to one or more peripheral devices such as the printer <b>10</b>, scanner (not shown), speaker, and any other devices, directly or via remote connections. The computer processing system may be connected or coupled to one or more other processing systems such as a server <b>10</b>, other remote computer processing system <b>14</b>, network storage devices <b>12</b>, via any one or more of a local Ethernet, WAN connection, Internet, etc. or via any other networking methodologies that connect different computing systems and allow them to communicate with one another. The various functionalities and modules of the systems and methods of the present disclosure may be implemented or carried out distributedly on different processing systems (e.g., <b>2</b>, <b>14</b>, <b>16</b>), or on any single platform, for instance, accessing data stored locally or distributedly on the network.</p>
<p id="p-0160" num="0176">The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein, the singular forms &#x201c;a&#x201d;, &#x201c;an&#x201d; and &#x201c;the&#x201d; are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms &#x201c;comprises&#x201d; and/or &#x201c;comprising,&#x201d; when used in this specification, specify the presence of stated features, integers, steps, operations, elements, and/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, elements, components, and/or groups thereof.</p>
<p id="p-0161" num="0177">The corresponding structures, materials, acts, and equivalents of all means or step plus function elements, if any, in the claims below are intended to include any structure, material, or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description, but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.</p>
<p id="p-0162" num="0178">Various aspects of the present disclosure may be embodied as a program, software, or computer instructions embodied in a computer or machine usable or readable medium, which causes the computer or machine to perform the steps of the method when executed on the computer, processor, and/or machine. A program storage device readable by a machine, tangibly embodying a program of instructions executable by the machine to perform various functionalities and methods described in the present disclosure is also provided.</p>
<p id="p-0163" num="0179">The system and method of the present disclosure may be implemented and run on a general-purpose computer or special-purpose computer system. The computer system may be any type of known or will be known systems and may typically include a processor, memory device, a storage device, input/output devices, internal buses, and/or a communications interface for communicating with other computer systems in conjunction with communication hardware and software, etc.</p>
<p id="p-0164" num="0180">The terms &#x201c;computer system&#x201d; and &#x201c;computer network&#x201d; as may be used in the present application may include a variety of combinations of fixed and/or portable computer hardware, software, peripherals, and storage devices. The computer system may include a plurality of individual components that are networked or otherwise linked to perform collaboratively, or may include one or more stand-alone components. The hardware and software components of the computer system of the present application may include and may be included within fixed and portable devices such as desktop, laptop, server. A module may be a component of a device, software, program, or system that implements some &#x201c;functionality&#x201d;, which can be embodied as software, hardware, firmware, electronic circuitry, or etc.</p>
<p id="p-0165" num="0181">The embodiments described above are illustrative examples and it should not be construed that the present invention is limited to these particular embodiments. Thus, various changes and modifications may be effected by one skilled in the art without departing from the spirit or scope of the invention as defined in the appended claims.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>We claim:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for automatically identifying computer system performance bottlenecks and/or excess idle time, comprising:
<claim-text>collecting information associated with runtime execution of a computer system;</claim-text>
<claim-text>inferring, using a processor, one or more execution states of one or more tasks within the system based on the information,</claim-text>
<claim-text>wherein the one or more execution states comprises one or more of runnable thread states and waiting thread states,</claim-text>
<claim-text>wherein the inferring further comprises extracting one or more monitors, the monitors being programming objects that achieve synchronization in concurrent programming, the one or more extracted monitors providing information as to what threads are waiting on a critical section, and</claim-text>
<claim-text>wherein the inferred one or more execution states provide information as to what a method on a stack associated with the runtime execution is doing.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the collected information includes infrequent samples of executing tasks or the collected information specifies inaccurate execution states or combinations thereof.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the collected information includes full traces of executing tasks.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the step of inferring applies rule-based expert knowledge to infer the one or more execution states.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the rule-based expert knowledge maps names of tasks to an execution state.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the rule-based expert knowledge maps names of internal context of tasks to an execution state.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further including aggregating said one or more tasks by said one or more execution states for determining execution time, idle time, or system policy violations, or combinations thereof.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the inferred execution states are further, hierarchically, subcategorized into one or more categories based on common execution tasks.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the one or more categories include one or more of:
<claim-text>a category indicating that an executing task is delayed by waiting on one or more requests the executing task has made to an external service provider,</claim-text>
<claim-text>a category indicating that an executing task is delayed by waiting on one or more requests the t executing task has made to local disks,</claim-text>
<claim-text>a category indicating that an executing task is delayed by waiting on data from a client machine</claim-text>
<claim-text>a category indicating that an executing task is ready and waiting for one or more new requests to the service that the executing task provides,</claim-text>
<claim-text>a category indicating that an executing task is waiting for one or more sub-tasks that are executing in one or more other executing tasks to complete,</claim-text>
<claim-text>a category indicating that an executing task is currently executing work,</claim-text>
<claim-text>a category indicating that an executing task is unable to proceed because machine resources are being used by other system facilities,</claim-text>
<claim-text>a category indicating that an executing task is unable to proceed because machine resources are being used by another set of tasks unrelated to the executing task, or combinations thereof.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the collected information include one or more samples of thread stacks, process stacks, or resource utilization, or combinations thereof.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the one or more tasks include a thread, a process or combinations thereof.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the automatically categorizing is performed by applying one or more rules based on method names found in the samples, the sample including at least thread stacks.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the information is collected without restarting an application or altering its command-line invocation or combinations thereof.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. A system for automatically identifying computer system performance bottlenecks using rule-based expert knowledge, comprising:
<claim-text>a processor;</claim-text>
<claim-text>a module operable to collect information associated with runtime execution of a computer system and infer one or more execution states of one or more tasks within the system based on the information,</claim-text>
<claim-text>wherein the one or more execution states comprises one or more of runnable thread states and waiting thread states,</claim-text>
<claim-text>wherein the module is further operable to extract one or more monitors, the monitors being programming objects that achieve synchronization in concurrent programming, the one or more extracted monitors providing information as to what threads are waiting on a critical section, and</claim-text>
<claim-text>wherein the inferred one or more execution states provide information as to what a method on a stack associated with the runtime execution is doing.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The system of <claim-ref idref="CLM-00014">claim 14</claim-ref>, further including:
<claim-text>an application interface operable to provide the summarized execution activity to a user.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The system of <claim-ref idref="CLM-00015">claim 15</claim-ref>, further including:
<claim-text>a user interface operable to provide the summarized execution activity to the user.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The system of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the collected information includes infrequent samples of executing tasks.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The system of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the collected information includes full traces of executing tasks.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The system of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the step of inferring applies rule-based expert knowledge to infer the one or more execution states.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. A computer readable storage medium, excluding signal per se, storing a program of instructions executable by a machine to perform a method of automatically identifying computer system performance bottlenecks using rule-based expert knowledge, comprising:
<claim-text>collecting information associated with runtime execution of a computer system; and</claim-text>
<claim-text>inferring one or more execution states of one or more tasks within the system based on the information,</claim-text>
<claim-text>wherein the one or more execution states comprises one or more of runnable thread states and waiting thread states,</claim-text>
<claim-text>wherein the inferring further comprises extracting one or more monitors, the monitors being programming objects that achieve synchronization in concurrent programming, the one or more extracted monitors providing information as to what threads are waiting on a critical section, and</claim-text>
<claim-text>wherein the inferred one or more execution states provide information as to what a method on a stack associated with the runtime execution is doing.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The computer readable storage medium of <claim-ref idref="CLM-00020">claim 20</claim-ref>, wherein the collected information includes infrequent samples of executing tasks.</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. The computer readable storage medium of <claim-ref idref="CLM-00020">claim 20</claim-ref>, wherein the collected information includes full traces of executing tasks.</claim-text>
</claim>
<claim id="CLM-00023" num="00023">
<claim-text>23. The computer readable storage medium of <claim-ref idref="CLM-00020">claim 20</claim-ref>, wherein the step of inferring applies rule-based expert knowledge to infer the one or more execution states.</claim-text>
</claim>
<claim id="CLM-00024" num="00024">
<claim-text>24. The computer readable storage medium of <claim-ref idref="CLM-00020">claim 20</claim-ref>, wherein the rule-based expert knowledge maps names of tasks to an execution state.</claim-text>
</claim>
<claim id="CLM-00025" num="00025">
<claim-text>25. The computer readable storage medium of <claim-ref idref="CLM-00020">claim 20</claim-ref>, further including:
<claim-text>aggregating said one or more tasks by said one or more execution states for determining execution time, idle time, or system policy violations, or combinations thereof.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
