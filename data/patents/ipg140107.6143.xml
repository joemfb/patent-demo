<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627267-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627267</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>11025987</doc-number>
<date>20050103</date>
</document-id>
</application-reference>
<us-application-series-code>11</us-application-series-code>
<priority-claims>
<priority-claim sequence="01" kind="national">
<country>KR</country>
<doc-number>10-2004-0021183</doc-number>
<date>20040329</date>
</priority-claim>
</priority-claims>
<us-term-of-grant>
<us-term-extension>1575</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>45</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>717100</main-classification>
<further-classification>717140</further-classification>
<further-classification>712202</further-classification>
<further-classification>713  2</further-classification>
</classification-national>
<invention-title id="d2e71">Apparatus and method for initializing system global variables by using multiple load/store instructions</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6157999</doc-number>
<kind>A</kind>
<name>Rossbach et al.</name>
<date>20001200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712243</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6170998</doc-number>
<kind>B1</kind>
<name>Yamamoto et al.</name>
<date>20010100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6289434</doc-number>
<kind>B1</kind>
<name>Roy</name>
<date>20010900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712 32</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6363473</doc-number>
<kind>B1</kind>
<name>Volentine et al.</name>
<date>20020300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712202</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>6484289</doc-number>
<kind>B1</kind>
<name>Hsu</name>
<date>20021100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714820</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>6493816</doc-number>
<kind>B1</kind>
<name>Munroe et al.</name>
<date>20021200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711209</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>6553426</doc-number>
<kind>B2</kind>
<name>H&#xf6;lzle et al.</name>
<date>20030400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>6662298</doc-number>
<kind>B2</kind>
<name>Heller</name>
<date>20031200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713  2</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>6839835</doc-number>
<kind>B2</kind>
<name>Kawade et al.</name>
<date>20050100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713  2</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>7159105</doc-number>
<kind>B2</kind>
<name>Rothman et al.</name>
<date>20070100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>7181608</doc-number>
<kind>B2</kind>
<name>Fallon et al.</name>
<date>20070200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713  2</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>7251811</doc-number>
<kind>B2</kind>
<name>Rosner et al.</name>
<date>20070700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717138</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>7325176</doc-number>
<kind>B2</kind>
<name>Larson et al.</name>
<date>20080100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714718</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>7340561</doc-number>
<kind>B2</kind>
<name>Collins</name>
<date>20080300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711105</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>7464243</doc-number>
<kind>B2</kind>
<name>Haridas et al.</name>
<date>20081200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711170</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>2002/0161993</doc-number>
<kind>A1</kind>
<name>Chan et al.</name>
<date>20021000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713  2</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>2003/0018846</doc-number>
<kind>A1</kind>
<name>Fanning</name>
<date>20030100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711  5</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00018">
<document-id>
<country>US</country>
<doc-number>2004/0143752</doc-number>
<kind>A1</kind>
<name>Kumar</name>
<date>20040700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713200</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00019">
<document-id>
<country>US</country>
<doc-number>2005/0027940</doc-number>
<kind>A1</kind>
<name>Zimmer et al.</name>
<date>20050200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711117</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00020">
<document-id>
<country>CN</country>
<doc-number>1035571</doc-number>
<kind>A</kind>
<date>19890900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00021">
<document-id>
<country>CN</country>
<doc-number>1138172</doc-number>
<kind>A</kind>
<date>19961200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00022">
<document-id>
<country>CN</country>
<doc-number>1234549</doc-number>
<kind>A</kind>
<date>19991100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00023">
<document-id>
<country>KR</country>
<doc-number>10-2004-0008552</doc-number>
<date>20040100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00024">
<document-id>
<country>KR</country>
<doc-number>10-2005-0039954</doc-number>
<date>20050500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00025">
<othercit>Mucci et al. &#x201c;The CacheBench Report&#x201d;, 1998, University of Tennessee Computer Science Tech Report, retrieved from: http://icl.cs.utk.edu/projects/llcbench/cachebench.pdf.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00026">
<othercit>Prinz et al. &#x201c;C Pocket Reference&#x201d;, 2003, O'Reilly, pp. 109-110.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00027">
<othercit>Jones et al. &#x201c;Sams Teach Yourself C in 21 days&#x201d;, 2003, Sams Publishing, pp. 579-580.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
</us-references-cited>
<number-of-claims>16</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>712202</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>713  2</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>713  1</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>717100</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>717140</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>6</number-of-drawing-sheets>
<number-of-figures>6</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20050228968</doc-number>
<kind>A1</kind>
<date>20051013</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Yang</last-name>
<first-name>Jin-Woo</first-name>
<address>
<city>Ichon-shi</city>
<country>KR</country>
</address>
</addressbook>
<residence>
<country>KR</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Yoon</last-name>
<first-name>Seung-Jun</first-name>
<address>
<city>Ichon-shi</city>
<country>KR</country>
</address>
</addressbook>
<residence>
<country>KR</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Yang</last-name>
<first-name>Jin-Woo</first-name>
<address>
<city>Ichon-shi</city>
<country>KR</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Yoon</last-name>
<first-name>Seung-Jun</first-name>
<address>
<city>Ichon-shi</city>
<country>KR</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>H.C. Park &#x26; Associates, PLC</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Pantech Co., Ltd.</orgname>
<role>03</role>
<address>
<city>Seoul</city>
<country>KR</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Do</last-name>
<first-name>Chat</first-name>
<department>2193</department>
</primary-examiner>
<assistant-examiner>
<last-name>Dinh</last-name>
<first-name>Lynda</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">An apparatus and method for initializing system global variables by using a multiple load/store instruction is disclosed. The apparatus includes: a first storing unit for storing a system global variable initialization function and initialization functions using multiple load/store instruction; a second storing unit for storing a return address; a control unit for storing a first return address to the second storing unit when the system global variable initialization function is called for initializing the system global variable, initializing the system global variables by calling the initialization functions using multiple load/store instruction while performing the system global variable function and performing a rest of system global variable initialization function by finding and executing an execution sequence based on the first return address stored in the second storing unit; and a third storing unit for storing the system global variables initialized according to the control unit.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="118.62mm" wi="141.05mm" file="US08627267-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="140.89mm" wi="153.42mm" file="US08627267-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="195.33mm" wi="135.38mm" orientation="landscape" file="US08627267-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="212.77mm" wi="144.70mm" orientation="landscape" file="US08627267-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="231.06mm" wi="166.45mm" orientation="landscape" file="US08627267-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="239.35mm" wi="169.42mm" orientation="landscape" file="US08627267-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="154.01mm" wi="147.07mm" file="US08627267-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">FIELD OF THE INVENTION</heading>
<p id="p-0002" num="0001">The present invention relates to an apparatus and a method for initializing system global variables by using a multiple load/store instruction; and, more particularly, to an apparatus and a method for initializing system global variables by storing a return address of a function initializing system global variables into common registers and using a multiple load/store instruction in order to reduce initialization time.</p>
<heading id="h-0002" level="1">DESCRIPTION OF RELATED ARTS</heading>
<p id="p-0003" num="0002">A system having a central processing unit (CPU) such as a wireless communication terminal performs several initialization processes when the system is powered on or a reset button of the system is activated. During the initialization processes, a mess amount of system global variables of software programs operating and controlling the system are initialized. Accordingly, the system spends comparatively long time for performing the initialization processes. The system global variables can be divided into two categories such as zero initialization data (ZI data) which is initialized into 0 and read/write data (RW data) which is initialized into a predetermined data.</p>
<p id="p-0004" num="0003">In a conventional method for initializing the system global variable is performed before an operating system of the system is initialized. Therefore, a function including a multiple load/store instruction cannot be used since the function would even clear the return address of the function itself, which is stored in a stack, and the stack is also a part of the global variables.</p>
<p id="p-0005" num="0004">The multiple load instruction reads multiple bytes of data and the multiple store instruction stores the multiple bytes of data. That is, the multiple load/store instruction processes data in a unit of a predetermined number of bytes at once, to increase a process time of load and store operation. However, a &#x201c;memset&#x201d; function using a STM instruction of C programming language cannot be used for initializing the system global variable since the operating system is initialized after the system global variables are initialized in the conventional method.</p>
<p id="p-0006" num="0005">Accordingly, the conventional method uses &#x201c;for-loop&#x201d; statement for initializing the system global variables as follows.</p>
<p id="p-0007" num="0006">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>void init_ram(void)</entry>
</row>
<row>
<entry/>
<entry>{</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;&#x2003;int *a;</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;&#x2003;for(a= start address of ZI data; a&#x3c; end address</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;of ZI data; a++)</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;&#x2003;{</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;*a=0;</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;&#x2003;}</entry>
</row>
<row>
<entry/>
<entry>for(a= start address of RW data; a&#x3c; end address</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;&#x2002;of RW data; a++)</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;&#x2003;{</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;*a=*(address containing a predetermined value for</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;initializing ++);</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;&#x2003;}</entry>
</row>
<row>
<entry/>
<entry>}</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0008" num="0007">As shown, the function void init_ram(void) initializes the ZI data and the RW data by using &#x201c;for&#x201d; statement. The &#x201c;for&#x201d; statement reads and processes the ZI and the RW data by one word at a time. Accordingly, the system spends comparatively long time for the initializing processes compared to the system using multiple load/store instructions.</p>
<p id="p-0009" num="0008">As mentioned above, there is a time delay occurred for initializing the system global variables when the system is powered on or the system is reset. The time delay is increased corresponding to the size and the complexity of the software programs operating and controlling the system. Therefore, the time delay problem would be more serious since the size and the complexity of the software program will be incredibly increased according to rapid development of electrical systems.</p>
<heading id="h-0003" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0010" num="0009">It is, therefore, an object of the present invention to provide an apparatus and a method initializing system global variables by using a multiple load/store instruction in order to reduce time for initialization of system global variables.</p>
<p id="p-0011" num="0010">It is another object of the present invention to provide an apparatus and a method for initializing system global variables by storing a return address into common registers.</p>
<p id="p-0012" num="0011">In accordance with one aspect of the present invention, there is provided an apparatus for initializing system global variables by using multiple load/store instruction, the apparatus including: a first storing unit for storing a system global variable and initialization functions using multiple load/store instruction; a second storing unit for storing a return address; a control unit for storing a first return address of the system global variable initialization function to the second storing unit when the system global variable initialization function is called for initializing the system global variable, initializing the system global variables by calling the initialization functions using multiple load/store instruction during performing the system global variable function and performing a rest of system global variable initialization function by finding and executing an execution sequence based on the first return address stored in the second storing unit; and a third storing unit for storing the system global variables initialized according to the control unit.</p>
<p id="p-0013" num="0012">In accordance with another aspect of the present invention, there is provided a method for initializing system global variables by using multiple load/store instruction, the method comprising the steps of: a) calling a system global variable initialization function when a control unit of a system starts initializing the system global variables; b) storing a return address of the system global variable initialization function in a return general-purpose register in a storing unit which is not initialized by the control unit of the system; c) calling an initializing function using the multiple load/store instruction during performing the system global variable initialization function and initializing the system global variables; and d) performing a rest of the system global variable initialization function by finding and executing an execution sequence based on the first return address stored in the storing unit after completing performing the initialization function.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0014" num="0013">The above and other objects and features of the present invention will be better understood with regard to the following description of the preferred embodiments given in conjunction with the accompanying drawings, in which:</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram showing a wireless communication terminal having an apparatus for initializing a system global variable by using a multiple load/store instruction in accordance with a preferred embodiment of the present invention;</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 2-5</figref> is a view for explaining operations of calling functions and storing returning address in accordance with a preferred embodiment of the present invention; and</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 6</figref> is a flowchart showing operations of an apparatus and a method for initializing system global variable in accordance with a preferred embodiment of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION OF THE INVENTION</heading>
<p id="p-0018" num="0017">Hereinafter, an apparatus and a method for initializing system global variables in accordance with a preferred embodiment of the present invention will be described in more detail with reference to the accompanying drawings.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram showing a wireless communication terminal having an apparatus for initializing a system global variable by using a block input/output instruction in accordance with a preferred embodiment of the present invention.</p>
<p id="p-0020" num="0019">As shown, the wireless communication terminal <b>100</b> having the apparatus for initializing the system global variables includes a wireless transceiver <b>110</b>, a central processing unit <b>120</b> (CPU), a compression/decompression (CODEC) <b>130</b>, a memory <b>140</b>, an audio output device <b>150</b>, a displayer <b>160</b>, an input device (key pad) <b>170</b>, an audio input device <b>180</b> and an antenna <b>190</b>.</p>
<p id="p-0021" num="0020">The wireless transceiver <b>110</b> receives and transmits a radio frequency signal through the antenna <b>190</b>.</p>
<p id="p-0022" num="0021">The CPU <b>120</b> controls operations of the wireless communication terminal <b>100</b>. In detail, the CPU <b>120</b> stores a return address of a system global variable initialization function when the wireless communication terminal <b>100</b> is powered on and the CPU <b>120</b> calls the initialization function using multiple load/store instructions for initializing the system global variables. Furthermore, the CPU <b>120</b> controls execution sequence of operating the wireless communication terminal <b>100</b> including the system global variable initialization function and the initialization function based on to the stored return address.</p>
<p id="p-0023" num="0022">The compression/decompression (CODEC) <b>130</b> converts a radio frequency signal from the wireless transceiver <b>110</b> into an audio data and outputs the audio data through the audio output device <b>180</b>. Furthermore, the CODEC <b>130</b> converts a voice signal inputted from an audio input device <b>180</b> into a digital data and transmits the digital data to the CPU <b>120</b> and transmitting the digital data through the wireless transceiver <b>110</b>.</p>
<p id="p-0024" num="0023">The memory <b>140</b> stores programs operating and controlling the wireless communication terminal <b>100</b>, file systems of images, characters and icons, the system global variable initialization function and the initialization function using multiple load/store instructions. The memory <b>140</b> also stores initialized system global variable according to the CPU <b>120</b>.</p>
<p id="p-0025" num="0024">The audio output device <b>150</b> outputs audio data included the radio frequency signal from the wireless transceiver <b>110</b> according to a control of the CPU <b>120</b>.</p>
<p id="p-0026" num="0025">The displayer <b>160</b> displays data according to the control of the CPU <b>120</b>.</p>
<p id="p-0027" num="0026">The input device (key pad) <b>170</b> receives input data such as telephone number and menu selection information from a user.</p>
<p id="p-0028" num="0027">The audio input device (mic) <b>180</b> receives a voice signal and transmits the input voice signal to the CODEC <b>130</b>.</p>
<p id="p-0029" num="0028">The CPU <b>120</b> includes a predetermined number of registers. Each of the registers is a small size of memory space temporally storing a instruction or data. That is, each of the registers is an inside memory of the CPU for storing a predetermined length of binary data for mathematical calculation, logical calculation, analysis and transmission. An access time of the register is comparatively faster than any other memories such as main memory, hard disk and floppy disk.</p>
<p id="p-0030" num="0029">The registers are categorized according to it's purpose as general-purpose registers for temporarily storing a result of mathematical and logical calculations; a program counter for storing an address of currently executed instruction; and a link register for storing a return address of a function. ARM, one of the most widely used CPU for the wireless communication system includes 16 registers (<b>0</b>-<b>15</b>) and 15<sup>th </sup>register is the link register.</p>
<p id="p-0031" num="0030">When the wireless communication terminal is powered on or reset, the CPU of the wireless communication terminal executes a program having a set of instructions for controlling operations of the wireless communication terminal including initialization processes according to execution sequences of the program. The program includes various functions for initializing the system global variables, external devices and hardware of the wireless communication terminal system. When one of the functions is called during executing the program, the return address of the function is stored in the link register. After performing the called function, a rest of the program is executed by finding a start execution sequence of the rest of program, which is a next execution sequence to the execution sequence calling the called function, based on the return address stored in the link register. The link register stores the return address of the called function.</p>
<p id="p-0032" num="0031">In case of calling a second function during executing a first function, a return address of the first function (calling function) is copied in a stack and a return address of the second function (called function) is written into the link register. An operation of calling function and storing return address is explained in detail by referring to <figref idref="DRAWINGS">FIGS. 2 to 5</figref>.</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIGS. 2 to 5</figref> are views for explaining operation procedures of calling functions and storing returning address in accordance with a preferred embodiment of the present invention.</p>
<p id="p-0034" num="0033">It assumes that a program including a plurality of functions and the program is executed according to execution sequences of the program. Referring to the <figref idref="DRAWINGS">FIG. 2</figref>, when a first function is called while executing the program, a first return address of the first function is stored in a link register <b>21</b>. In <figref idref="DRAWINGS">FIG. 3</figref>, if a second function is called during performing the first function, the first return address stored in the link register <b>21</b> is stored in a stack <b>23</b> and a second return address of the second function is stored in the link register <b>21</b>. Moreover, if a third function is called while the second function is being performed, the second return address stored in the linke register <b>21</b> is stored in the stack <b>23</b> and a third return address is newly stored in the link register <b>21</b>. The return address stores a return address of lately called function and the stack <b>23</b> stores a plurality of return addresses of functions in reverse order of calling functions.</p>
<p id="p-0035" num="0034">After completing the execution of a function, the link register <b>21</b> is firstly checked and an execution sequence is performed based on the return address stored in the link register for returning to a calling function of the function. After returning to the calling function, the stack <b>23</b> is checked. If there are any return addresses, a top of the stack is read as a return address of the calling function and the read return address is written into the link register. For example, after completing the third function, a rest of the second function is performed by executing an execution sequence based on the third return address stored in the link register. After returning to the second function based on the third return address, the stack <b>23</b> is checked and top of the stack <b>23</b> is read as the second return address for the second function. The second return address is written into the link register. After completing the second function, a rest of the first function is performed by executing an execution sequence based on the second return address stored in the link register and the top of the stack is read as the first return address and written into the link register. Finally, when the first function is completely executed, a rest of the program calling the first function, is performed by executing the execution sequence based on the first return address stored in the link register.</p>
<p id="p-0036" num="0035">In the present invention, a program controlling the wireless communication terminal includes a system global variable initialization function and an initialization function. While executing the program, the program calls the system global variable initialization function and an initialization function using a multiple load/store instruction. In addition, the system global variable initialization function calls the initialization function. When the program calls the system global variable initialization function, a first return address of the system global variable initialization function is stored in the link register. Furthermore, when the system global variable initialization function calls the initialization function, the first return address stored in the return address is copied into another general-purpose register and a second return address of the initialization function is stored in the link register.</p>
<p id="p-0037" num="0036">Conventionally, when a calling function for initializing system global variables calls a called function during performing the calling function, a return address of the called function is stored into the return address <b>21</b> and a link register of the calling function is copied into the stack <b>23</b>. As depicted in <figref idref="DRAWINGS">FIG. 4</figref>, however, the stack <b>23</b> is initialized to have null data after initializing the system global variable by the called function since the stack <b>23</b> is also one of system global variables. Therefore, the rest of the calling function cannot be executed since the return address of the calling function, which has been stored in the stack <b>23</b>, is also deleted. This explains why such function as &#x2018;memset&#x2019; could not be used as initialization function conventionally, even though it is much faster than simple &#x2018;for-loop&#x2019;.</p>
<p id="p-0038" num="0037">For overcoming the above mentioned problem of the conventional method, the first return address of the system global variable initialization function is stored in another general-purpose register in the CPU before calling the initialization function using multiple load/store instruction or before storing the second return address of the initialization function at the link register. After performing the system global variable initialization function, the first return address stored in another general-purpose register <b>22</b> is re-stored into the link register <b>21</b> and the rest of the program is performed by finding and executing a next execution sequence of the program to the execution sequence calling the system global variable initialization function based on the stored first return address.</p>
<p id="p-0039" num="0038">Referring to <figref idref="DRAWINGS">FIG. 5</figref>, operations of initialization procedure is explained in detail.</p>
<p id="p-0040" num="0039">At first, the system global variable initialization function is called for performing initialization processes by the CPU <b>120</b> while the program controlling the wireless communication terminal is executing. The first return address of the system global variable initialization function is stored into the link register and, at the same time, the first return address stored in the return address is also copied into another general-purpose register in the CPU. If the initialization function is called while the system global variable initialization function is performed, the second return address of the initialization function is newly stored in the link register.</p>
<p id="p-0041" num="0040">For another example, the system global variable initialization function is called for performing initialization processes by the CPU <b>126</b> during the program controlling the wireless communication terminal is executing. The first return address of the system global variable initialization function is stored in the link register <b>21</b>. When an initialization function is called during the execution of the system global variable initialization function, the first return address of the system global variable initialization function is copied into another general-purpose register <b>22</b> of the CPU <b>12</b> and the second return address of the initialization function is stored in the link register <b>21</b>.</p>
<p id="p-0042" num="0041">After performing the initialization function, the rest of the system global variable initialization function is performed by finding and executing a next execution sequence to the execution sequence calling the initialization function based on the second return address stored in the link register <b>21</b>. After returning to the system global variable initialization function, the first return address stored in another general-purpose register <b>22</b> is copied into the link register <b>21</b>. After performing the rest of the system global variable initialization function, the rest of the program is performed by finding and executing the next executing sequence to the executing sequence calling the system global variable initialization function according to the first return address stored in the link register <b>21</b>.</p>
<p id="p-0043" num="0042">In a preferred embodiment of the present invention, the system global variable initialization function orderly calls a memset function and a memcpy function as the initialization functions. The memset function and the memcpy function initialize the system global variables by using the multiple load/store instructions in order to reduce a time for initializing system global variables. Any other functions using multiple load/store instruction can be used for initializing the system global variables instead of the memset function and the memcpy function.</p>
<p id="p-0044" num="0043">The memory <b>140</b> includes a non-volatile memory such as ROM and a volatile memory RAM. The non-volatile memory stores the program of controlling the wireless communication terminal, a file system, images, characters and icons, the system global variable initialization function and the initialization function using block input/output instruction. The volatile memory stores the system global variables, which are initialized according to the control of the CPU <b>120</b>.</p>
<p id="p-0045" num="0044">The read only memory (ROM) is a memory device storing non-volatile data. The ROM allows to read stored data in high-speed but writing data in the ROM is very limited.</p>
<p id="p-0046" num="0045">The random access memory (RAM) is a memory device allowing writing and reading data to/from memory elements. The RAM has advantages to allow a writing operation and reading operation at low cost, small size, low electric power consumption and high-speed access.</p>
<p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. 6</figref> is a flowchart showing operations of an apparatus and a method for initializing system global variable in accordance with a preferred embodiment of the present invention.</p>
<p id="p-0048" num="0047">As shown, when a wireless communication terminal is powered on or reset, a program controlling operations of the wireless communication terminal is performed at step S<b>601</b>. The program calls a system global variable initialization function stored in a ROM for initializing system global variables at step S<b>602</b>.</p>
<p id="p-0049" num="0048">The CPU stores a first return address of the system global variable initialization function in the return address and the code should be executed to copy that address in a free general-purpose register for performing the rest of the program after performing the system global variable initialization function at step S<b>603</b>. The rest of the program is performed by finding and executing a next execution sequence to the execution sequence calling the system global variable initialization function based on the first return address.</p>
<p id="p-0050" num="0049">That is, the CPU stores the first return address of the system global variable initialization function in the return address when the program calls the system global variable initialization function. After the CPU stores the first return address into the return address, the code should be executed which stores that first return address in another general-purpose register.</p>
<p id="p-0051" num="0050">As mentioned above, the first return address should be stored in other general-purpose register before calling the system global variable initialization function or the first return address should be stored after calling the system global variable initialization function and before storing the first return address in the return address.</p>
<p id="p-0052" num="0051">After storing the first return address, the system global variables are initialized by calling an initialization function using multiple load/store instruction at step S<b>604</b>.</p>
<p id="p-0053" num="0052">The system global variable initialization function (void init_ram(void)) and the initialization function using multiple load/store instruction (memset, memcpy) are shown as follows.</p>
<p id="p-0054" num="0053">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>void init_ram(void)</entry>
</row>
<row>
<entry>{</entry>
</row>
<row>
<entry>&#x2003;&#x2003;memset(start address of ZI data, 0, end addres of ZI data &#x2212; start</entry>
</row>
<row>
<entry>&#x2003;&#x2003;&#x2003;&#x2003;address of ZI data +1);</entry>
</row>
<row>
<entry>&#x2003;&#x2003;memcpy(start address of RW data, address having initialization</entry>
</row>
<row>
<entry>&#x2003;&#x2003;&#x2003;&#x2003;value, size of RW data)</entry>
</row>
<row>
<entry>}</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0055" num="0054">The system global variable initialization function (void int_ram(void)) of the present invention calls the initialization functions memset function and memcpy function in order.</p>
<p id="p-0056" num="0055">The memset function initializes system global variables to &#x201c;0&#x201d; by processing predetermined bytes of system global variable at once. Generally this function is implemented using multiple load/store instruction for speed-up. That is, the ZI data stored in a RAM of the wireless communication terminal is initialized in a block unit. In the preferred embodiment of the present invention, the memset function is used as an initialization function, but any other functions processing multiple bytes of data at each instruction, can be used.</p>
<p id="p-0057" num="0056">The memcpy function is a function copying n bytes of data stored in a first memory location into a second memory location and is used in the preferred embodiment of the present invention for initializing the RW data. That is, the memcpy function reads the initialization value of the system global variables stored in the ROM and copies it to a corresponding memory location of RAM for initialization of system global variables.</p>
<p id="p-0058" num="0057">When the system global variable initialization function calls the memset function, a second return address of the memset function is newly stored in the link register. After performing the memset function, the rest of the system global variable is performed by finding and executing next execution sequence to an executing sequence calling the memset function based on the second return address stored in the return address.</p>
<p id="p-0059" num="0058">The call of and the return from the memcpy function is done in the same way as the memset function.</p>
<p id="p-0060" num="0059">After completing the execution of the system global variable initialization function, the CPU reads the first return address of the system global variable initialization function, which is stored in another general-purpose register. And the rest of the program is performed by finding and executing next execution sequence to an executing sequence calling the system global variable initialization function based on the first return address stored in another general-purpose register.</p>
<p id="p-0061" num="0060">The present invention mentioned above can be applied to any electric device having a central process unit (CPU) supporting multiple load/store instruction. That is, the present invention can decrease a boot time of electric devices having the CPU such as a computer and a wireless communication terminal.</p>
<p id="p-0062" num="0061">As mentioned above, the present invention can decrease a time spent for initializing system global variables by storing a return address in one of the general purpose registers in a central processing unit and using a multiple load/store instruction function.</p>
<p id="p-0063" num="0062">The present invention contains subject matter related to Korean patent application No. KR 2004-0021183, filed in the Korean patent office on Mar. 29, 2004, the entire contents of which being incorporated herein by reference.</p>
<p id="p-0064" num="0063">While the present invention has been described with respect to certain preferred embodiments, it will be apparent to those skilled in the art that various changes and modifications may be made without departing from the spirit and scope of the invention as defined in the following claims.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. An apparatus for initializing system global variables by using multiple load/store instruction, the apparatus comprising:
<claim-text>a first storing unit to store a system global variable initialization function and an initialization function using multiple load/store instruction;</claim-text>
<claim-text>a second storing unit to store a return address;</claim-text>
<claim-text>a stack in a memory for initialization and a link register;</claim-text>
<claim-text>a control unit to copy a first return address of the system global variable initialization function to the link register as a most recent return address of a currently called function, and to copy the first return address from the link register to the second storing unit when the system global variable initialization function is called for initializing the system global variables, to initialize the system global variables including the stack in a block unit of a predetermined number of bytes by calling the initialization function using multiple load/store instruction during performing the system global variable initialization function, to copy the first return address from the second storing unit to the stack after initializing the stack, wherein the link register stores a second return address of the initialization function as a most recent return address of a currently called function, to copy the first return address from the stack to the link register, and to perform a rest of a system initialization by finding and executing an execution sequence based on the first return address stored in the link register; and</claim-text>
<claim-text>a third storing unit to store the system global variables initialized according to the control unit,</claim-text>
<claim-text>wherein the second storing unit is a general-purpose register that is not initialized during the initializing the system global variables, and the link register is not initialized during the initializing the system global variables,</claim-text>
<claim-text>wherein the control unit reads the first return address stored in the second storing unit and writes the first return address to the link register after performing the initialization function, and</claim-text>
<claim-text>wherein the multiple load/store instruction comprises a memset function according to a C programming language, and reads or writes multiple bytes of data in a block unit of a predetermined number of bytes.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the second storing unit is a general-purpose register in the control unit.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The apparatus of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the control unit stores the first return address of the system global variable initialization function in the second storing unit when the initialization function is called while the system global variable initialization function is performed, stores the second return address of the initialization function in the link register, initializes the system global variables including the stack by using multiple load/store instruction, and performs the rest of the system global variable initialization function by finding and executing an execution sequence based on the second return address stored in the link register.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The apparatus of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the first storing unit, the second storing unit, the third storing unit and the control unit are included in a wireless communication terminal.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The apparatus of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the first storing unit, the second storing unit, the third storing unit and the control unit are included in a computer, or in any other electrical devices.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the control unit stores second return address of the initialization function in the link register when the initialization function is called while performing the system global variable initialization function, initializes system global variables including the stack by using the multiple load/store instruction, and performs the rest of the system global variable initialization function by finding and executing an execution sequence based on the second return address in the link register.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first storing unit is a read only memory (ROM) and the third storing unit is a random access memory (RAM).</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first return address stored in the second storing unit is protected when the multiple load/store instruction initializes the system global variables including the stack in the block unit of the predetermined number of bytes.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. A method for initializing system global variables by using multiple load/store instruction, the method comprising the steps of:
<claim-text>a) calling a system global variable initialization function when a control unit of a system starts initializing the system global variables;</claim-text>
<claim-text>b) storing a first return address of the system global variable initialization function in a storing unit which is not initialized by the control unit of the system;</claim-text>
<claim-text>c) calling an initializing function using the multiple load/store instruction while performing the system global variable initialization function and initializing the system global variables including a stack in a memory for initialization in a block unit of a predetermined number of bytes, wherein the step c) comprises:
<claim-text>c-1) initializing zero initialization (ZI) data of the system global variables using multiple load/store instruction, which has a first byte length, by calling a function initializing ZI data, and</claim-text>
<claim-text>c-2) initializing read/write (RW) data of the system global variables using multiple load/store instruction, which has a second byte length, by calling a function initializing RW data;</claim-text>
</claim-text>
<claim-text>d) copying the first return address stored in a general-purpose register included in the storing unit to the stack after initializing the stack, and copying the first return address from the stack into a link register after the completion of the initialization function using the multiple load/store instruction, wherein the first return address stored in the general-purpose register is copied to the link register after initializing the system global variables; and</claim-text>
<claim-text>e) performing a rest of a system initialization by finding and executing an execution sequence based on the first return address,</claim-text>
<claim-text>wherein the multiple load/store instruction comprises a memset function according to a C programming language, and reads or writes multiple bytes of data in a block unit of a predetermined number of bytes.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein in step b), the storing unit includes the general-purpose register, and the control unit stores the first return address in the link register and the general-purpose register when calling the system global variable initialization function.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein in step e), a second return address of the initialization function is stored in the link register when the initialization function is called while performing the system global variable initialization function, the system global variables including the stack are initialized by using the multiple load/store instruction, and the rest of the system global variable initialization function is performed by finding and executing an execution sequence based on the second return address stored in the link register.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein in step b) and c), the first return address of the system global variable initialization function stored in the link register is copied to the general-purpose register when the initialization function is called while performing the system global variable initialization function, a second return address of the initialization function is stored in the link register, the system global variables are initialized by using multiple load/store instruction, and the rest of the system global variable initialization function is performing by finding and executing an execution sequence based on the second return address stored in the link register.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein in the step c-1), the control unit calls the function initializing ZI data while performing the system global variable initialization function and the ZI data stored in a random access memory (RAM) is initialized using multiple load/store instruction.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein in the step c-2), the function initializing RW data reads a predetermined value stored in a read only memory (ROM) in a block unit and copies the predetermined value to a predetermined location of RW data located in a random access memory (RAM) using multiple load/store instruction for initializing RW data.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. An apparatus for initializing system global variables by using multiple load/store instruction, the apparatus comprising:
<claim-text>a first storing unit to store a system global variable initialization function and an initialization function using multiple load/store instruction;</claim-text>
<claim-text>a second storing unit to store a return address;</claim-text>
<claim-text>a stack in a memory for initialization and a link register;</claim-text>
<claim-text>a control unit to copy a first return address of the system global variable initialization function to the link register as a most recent return address of a currently called function, and to copy the first return address from the link register to the second storing unit when the system global variable initialization function is called for initializing the system global variables, to initialize the system global variables including the stack in a block unit of a predetermined number of bytes by calling the initialization function using multiple load/store instruction during performing the system global variable initialization function, to copy the first return address from the second storing unit to the stack after initializing the stack, wherein the link register stores a second return address of the initialization function as a most recent return address of a currently called function, to read the first return address from the second storing unit after initializing the stack, to write the first return address retrieved from the second storing unit to the link register, and to perform a rest of a system initialization by finding and executing an execution sequence based on the first return address stored in the link register; and</claim-text>
<claim-text>a third storing unit to store the system global variables initialized according to the control unit,</claim-text>
<claim-text>wherein the control unit reads the first return address stored in the second storing unit and writes the first return address to the link register after performing the initialization function,</claim-text>
<claim-text>wherein the second storing unit is a register that is not initialized during the initializing the system global variables, and the link register is not initialized during the initializing the system global variables, and</claim-text>
<claim-text>wherein the multiple load/store instruction comprises a memset function or a memcpy function according to a C programming language, and reads or writes multiple bytes of data in a block unit of a predetermined number of bytes at once.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The apparatus of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the control unit stores the first return address of the system global variable initialization function in the second storing unit when the initialization function is called while the system global variable initialization function is performed, stores second return address of the initialization function in the link register, initializes the system global variables including the stack by using multiple load/store instruction, and performs the rest of the system global variable initialization function by finding and executing an execution sequence based on the second return address stored in the link register. </claim-text>
</claim>
</claims>
</us-patent-grant>
