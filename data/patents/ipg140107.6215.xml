<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627339-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627339</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12018987</doc-number>
<date>20080124</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>1127</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>13</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>719315</main-classification>
<further-classification>719313</further-classification>
</classification-national>
<invention-title id="d2e53">Service-oriented architecture component processing model</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>7873679</doc-number>
<kind>B2</kind>
<name>Knipp</name>
<date>20110100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707810</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>2003/0041178</doc-number>
<kind>A1</kind>
<name>Brouk et al.</name>
<date>20030200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709313</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>2004/0034540</doc-number>
<kind>A1</kind>
<name>Chen et al.</name>
<date>20040200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>705  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2006/0085243</doc-number>
<kind>A1</kind>
<name>Cooper et al.</name>
<date>20060400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>705  8</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>2006/0168132</doc-number>
<kind>A1</kind>
<name>Bunter et al.</name>
<date>20060700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709219</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2007/0288891</doc-number>
<kind>A1</kind>
<name>Aakolk et al.</name>
<date>20071200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717114</main-classification></classification-national>
</us-citation>
</us-references-cited>
<number-of-claims>12</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>5</number-of-drawing-sheets>
<number-of-figures>5</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20090193432</doc-number>
<kind>A1</kind>
<date>20090730</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>McKegney</last-name>
<first-name>Ross</first-name>
<address>
<city>Toronto</city>
<country>CA</country>
</address>
</addressbook>
<residence>
<country>CA</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Vandergoot</last-name>
<first-name>Jacob</first-name>
<address>
<city>Bradford</city>
<country>CA</country>
</address>
</addressbook>
<residence>
<country>CA</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>McKegney</last-name>
<first-name>Ross</first-name>
<address>
<city>Toronto</city>
<country>CA</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Vandergoot</last-name>
<first-name>Jacob</first-name>
<address>
<city>Bradford</city>
<country>CA</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Novak Druce Connolly Bove + Quigg LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Onat</last-name>
<first-name>Umut</first-name>
<department>2194</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A service-oriented architecture can include a service provider comprising a plurality of service objects, each service object comprising a self-describing, self-contained, platform independent, modular unit of application logic. The service oriented architecture further includes a service object among the plurality of service objects that is a service implementation having a pre-ordained message processing system. The service implementation can respond to client requests at different levels of granularity and can use a common transfer object message format that separates a business object into its constituent parts. The common set of operations can include at least the Read, Create, Update, Delete, and Execute functions.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="171.96mm" wi="194.73mm" file="US08627339-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="203.12mm" wi="88.39mm" orientation="landscape" file="US08627339-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="210.40mm" wi="173.06mm" orientation="landscape" file="US08627339-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="199.05mm" wi="180.09mm" orientation="landscape" file="US08627339-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="210.74mm" wi="172.47mm" orientation="landscape" file="US08627339-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="199.98mm" wi="179.07mm" orientation="landscape" file="US08627339-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND</heading>
<p id="p-0002" num="0001">1. Field of the Invention</p>
<p id="p-0003" num="0002">The present invention relates to the fields of computing and networking and, more particularly, to a service-oriented architecture for enterprises that support multiple interface channels.</p>
<p id="p-0004" num="0003">2. Description of the Related Art</p>
<p id="p-0005" num="0004">Within any competitive market, businesses strive to distinguish their products and services from those of their competitors. One way to accomplish this is by positioning themselves within different markets of commerce favored by consumers. These markets can include store-front markets and mail-based markets, such as direct marketing by mail and catalogue based marketing. Markets can also include telephony markets and Internet-based markets, with Internet markets showing a strong increase in market share within recent years.</p>
<p id="p-0006" num="0005">Customers increasingly expect to be able to interact with a business enterprise seamlessly across multiple markets using different interface channels. For example, a customer purchasing a book from a bookstore chain via a Web site (Internet interface channel) expects to be able to return the book at a local store (store-front interface channel). Similarly, a purchaser of an item from a department catalog (postal mail interface channel) expects to be to contact a service representative through a toll free phone number (telephone interface channel) to determine shipment status. In yet another example, bank customers expect to be able to monitor account activity and conduct transactions through automatic teller machines (kiosk or self-service channel) as well as through a bank's Web site (Internet interface channel).</p>
<p id="p-0007" num="0006">Business enterprises have conventionally established different software systems for each the various interface channels and/or for each of the various markets at which products or services are provided. That is, one software system can be designed for employee use at store fronts. A separate software system can be used by customer service representatives and interactive voice response systems that provide telephony based services to customers. Yet another software system can provide Web-based access to customers. Another software system can be used for employee payroll and for business expense accounting. Still another software system can be used for enterprise logistics, item warehousing, and item procurement.</p>
<p id="p-0008" num="0007">It can be difficult to construct interfaces between each of these varying systems of a business enterprise so that information within the systems is synchronized. A lack of synchronization, however, can result in a shortcoming in a customer's experience, as a customer's information from one channel is not available through another channel. In extreme cases, different store-fronts or outlets of the same interface channel, such as different retail outlets, will not have data synchronized with one another, so that a customer's interactions with one retail outlet are not available to the customer or service agent at a different retail outlet.</p>
<p id="p-0009" num="0008">One of the key technical challenges in developing a software system based on a service oriented architecture (SOA) architectural style is determining the right level of granularity for services. The foundations of SOA can be found in the distributed object programming models such as Distributed COM (DCOM), CORBA, and Java Remote Method Invocation (RMI), however those prior models were more a scale-up from object-oriented programming than a true component service programming model. The challenge is that these services range in granularity from document processing (for example, receiving as input a ledger, request for quote (RFQ), or other large complex document) to simple remote method invocation as previously seen in distributed object processing.</p>
<p id="p-0010" num="0009">When considering all of the above factors, it is not surprising that enterprises spend enormous sums attempting to maintain, integrate, and update their software systems to provide the appropriate level of granularity in a number of different services. Many of these enterprises find that their expensive and tightly coupled software systems become outdated too quickly or is too inflexible to permit a new desired innovation to be implemented, without an infrastructure redesign, which is often cost prohibitive. Thus, even the best conventionally implemented enterprise software systems that initially provide a competitive advantage can become a competitive liability in years to come.</p>
<p id="p-0011" num="0010">A new approach for implementing software systems among an enterprise is needed. This approach should utilize a new component service processing model as further described below.</p>
<heading id="h-0002" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0012" num="0011">A service-oriented architecture provides a service oriented architecture with sufficient flexibility in granularity to support scale-up from a simplest action affecting a sub-part of a business object to actions affecting entire business objects or even lists of business objects.</p>
<p id="p-0013" num="0012">In one embodiment, a service-oriented architecture software system or processing model can include a service provider comprising a plurality of service objects where each service object can include a self-describing, self-contained, platform independent, modular unit of application logic and where a service object among the plurality of service objects can be a service implementation having a pre-ordained message processing system. The service implementation can respond to client requests at different levels of granularity and can use a common transfer object message format that separates a business object into its header and body. The business object can be decomposable into its constituent parts where the business objects are supported by a common set of operations. As noted above, the system or model can support scale-up from a simplest action affecting a sub-part of a business object to actions affecting entire business objects or even lists of business objects. The common set of operations can include Read, Create, Update, Delete, Execute or Broadcast.</p>
<p id="p-0014" num="0013">When a client invokes a Read operation, the service implementation takes a structured action list and uses the structured action list to resolve a list of business objects to be retrieved where the action list will also indicate a level of detail requested and where the system also handles access control, based on same structured actions and business object types. When a client invokes an Update operation, the service implementation takes a structured action list and uses the structured action list to resolve a list of business objects to be modified and where the action list describes the precise part of the business objects to be affected using XPath or a similar notation that allows for reference to a precise part of the business object. When a client invokes an Execute operation, the service implementation takes a structured action list and uses the structured action list to resolve a list of business objects to be processed wherein the execute operation contains information describing not only which business objects to be updated, but precisely what actions to execute against the business objects. When a client invokes a Broadcast operation, the service implementation takes a structured action list and resolves a list of business objects to be modified using the structured action list, the action list describing the precise part of the business objects to be affected using XPath or a similar notation that allows for reference to a precise part of the business object.</p>
<p id="p-0015" num="0014">It should be noted that various aspects of the invention can be implemented as a program for controlling computing equipment to implement the functions described herein, or a program for enabling computing equipment to perform processes corresponding to the steps disclosed herein. This program may be provided by storing the program in a magnetic disk, an optical disk, a semiconductor memory, any other recording medium, or can also be provided as a digitally encoded signal conveyed via a carrier wave. The described program can be a single program or can be implemented as multiple subprograms, each of which interact within a single computing device or interact in a distributed fashion across a network space.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0016" num="0015">There are shown in the drawings, embodiments which are presently preferred, it being understood, however, that the invention is not limited to the precise arrangements and instrumentalities shown.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram of a service-oriented software system or architecture including a service implementation in accordance with an embodiment of the present invention.</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 2</figref> is another block diagram of a service-oriented software system illustrating a Get processing pattern in accordance with an embodiment of the present invention.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 3</figref> is a block diagram of a service-oriented software system illustrating a Change processing pattern in accordance with an embodiment of the present invention.</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 4</figref> is a block diagram of a service-oriented software system illustrating a process request processing pattern in accordance with an embodiment of the present invention.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 5</figref> is a block diagram of a service-oriented software system illustrating a Sync processing pattern in accordance with an embodiment of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION OF THE INVENTION</heading>
<p id="p-0022" num="0021">A system and method for solving a multi-channel problem as described above can be achieved using a service-oriented architecture that provides a consistent, re-usable method for consistently integrating any type of customer or employee interaction with any business process across the enterprise or on-demand utility, while also providing flexible granularity.</p>
<p id="p-0023" num="0022">In order to provide consistent access to business processes across channels, a common set of business logic can be used to provide a singular method of access to data and function. Employing a service-oriented architecture can provide a framework that links channel applications with enterprise data and functions through a single, common integration layer. The architecture can provide a consistent, re-usable method for consistently integrating any type of customer or employee interaction with any business process across the enterprise or on demand utility.</p>
<p id="p-0024" num="0023">A service-oriented architecture is based on the composition of a set of services that &#x201c;provide&#x201d; application functions. Utilizing an object-oriented approach to enterprise integration leverages the latest techniques for application development to maximize business function delivery and minimize effort. Among the benefits provided by a service-oriented architecture approach combined with a web services based implementation are simplification, abstraction, and loose coupling.</p>
<p id="p-0025" num="0024">With respect to simplification, interactions can be described in simple XML-based messages with no complex infrastructure. Web services can be self-describing, self-contained modular applications. Such a system and technique can use open standards for description, discovery and invocation of service requests (for example, WSL, SOAP, and HTTP).</p>
<p id="p-0026" num="0025">With respect to abstraction, a service architecture can expose application functionality as &#x201c;generic&#x201d; business functions. Web services can be web-based, local or distributed and services can hide implementation of core systems. Such embodiments can separate adapter development from integration work.</p>
<p id="p-0027" num="0026">With respect to the benefit of loose-coupling, such service integration can lower the amount of coordination between service suppliers and consumers and can maintain platform and implantation neutrality. Such a system can programmatically discover services and invoke such services over a network. A service is defined with a standard, published interface that includes the information exchanged by a service interaction. These peer services are organized into domains along business functions. Service consumers bind to the service providers through the published interfaces to invoke the appropriate service. In the case where a service provider endpoint is unknown, a consumer may perform a search for the provider in a well-known directory. Since the service consumers and providers operate in this loosely coupled fashion, the method of binding can be dynamic or done at runtime. An underlying data model to define parameters is crucial since the service consumer and provider rely on a common, platform-independent method of information exchange.</p>
<p id="p-0028" num="0027">Service providers can be the instantiation of a service-oriented architecture. They can be used to enable access to enterprise systems and functions using standardized SOAP XML messages over a common network protocol. Using this approach minimizes the amount of work and infrastructure required to integrate local clients and application servers with centralized resources.</p>
<p id="p-0029" num="0028">The proposed embodiments herein can address such challenges through a new component service processing model. The processing model elaborates a common structure for business objects, with a decomposable methodology for handling common operations against such business objects. This processing model can allow for the same service to support both the simple &#x201c;chatty&#x201d; interactions required by some clients, and the document-level processing required by others. A high-level depiction of the interactions in an SOA context are illustrated in the system <b>100</b> of <figref idref="DRAWINGS">FIG. 1</figref> which includes a client <b>102</b> coupled to a service proxy <b>104</b>, a binding <b>106</b>, and a service interface <b>108</b> coupled to a service implementation <b>110</b>.</p>
<p id="p-0030" num="0029">The system <b>100</b> is a generic depiction which can be implemented in any number of ways but has the common characteristics of &#x2018;services&#x2019; exposing an interface that clients can invoke. The binding between the client and service is often configurable (for example, to support web services over HTTP, web services over JMS, local binding, etc). As a result, the client program is only responsible for interacting with a proxy to the service, and the details of the binding to the implementation are determined later. This general programming model is well known and defined, with numerous available implementations. What remains undefined is how precisely the service implementation (<b>110</b>) will process the incoming messages. There are known open standards for message processing, including the OAGIS standard, however, even these standards lack the concept of a pre-ordained message processing mechanism.</p>
<p id="p-0031" num="0030">In existing processing mechanisms, the service implementation uses its discretion in determining how to process an incoming service requests. The embodiments herein improve on the state of the art by providing a general-purpose processing model that can assure a component service implementation that it will be able to effectively respond to client requests at different levels of granularity. This methodology greatly simplifies the client programming model, by providing a common consistent approach to service interactions.</p>
<p id="p-0032" num="0031">The embodiments herein start with a common transfer object message format that can decompose or separate the business object into its constituent parts such as its header and body. The business object format should be structured, such that it is decomposable into its constituent parts. A common set of operations that are supported against these business objects can also be used. These can include, for example, Read, Create, Update, Delete, etc.</p>
<p id="p-0033" num="0032">The common message format and action list are pre-requisites to the development of a processing model for SOA services, but are generally not sufficient. In the case of an exemplar implementation, the OAGIS open standard message format can be used. The present embodiments leverage a standard message structure and supported operations, in conjunction with the SOA architectural style denoted above, and build upon it with a processing model that addresses the key challenges in the design and construction of service implementations.</p>
<p id="p-0034" num="0033">Illustrations of the processing model in the context of supported operations can provide further insight into the benefits provided by the processing model. Such supported operations can include functions or operations such as the Read, Update, Execute, and Broadcast operations.</p>
<p id="p-0035" num="0034">When the client invokes a Read operation, the service implementation takes the structured action list and uses it to resolve a list of business objects to be retrieved. The action list will also indicate a level of detail requested (for example, to retrieve a summary or detailed representation of the matching business objects). The processing model will use a common processing algorithm to retrieve the required information from its data repository and return it to the client. The processing model can also handle access control, based on the same structured actions and business object types.</p>
<p id="p-0036" num="0035">When the client invokes an Update operation, the service implementation takes the structured action list and uses it to resolve the list of business objects to be modified, and also precisely notes which parts of those business objects will be affected. The action list describes the precise part of the business objects to be affected using XPath or similar notation that allows for reference to a precise part of the business object. In this manner, an Update action could prescribe that the service should update an entire business object, or simply change a subpart of the business object. As with Read, access control can be applied to the specific actions and business object types.</p>
<p id="p-0037" num="0036">When the client invokes an Execute operation, the service implementation takes the structured action list and uses it to resolve the list of business objects to be processed. The execute action will contain information describing not only which business objects to be updated, but precisely what actions to execute against these objects.</p>
<p id="p-0038" num="0037">The Broadcast processing is virtually identical to Update processing, the only difference being the semantics of the calling sequence. As with Update, the Broadcast message includes an action list that indicates precisely which parts of the referenced business objects to modify. In essence, this is a methodology that supports scale-up from the simplest action affecting a sub-part of a business object, to actions affecting entire business objects or even lists of business objects. Given a common processing model simplifies the development of reusable/recomposable services, and also the development of clients of the services.</p>
<p id="p-0039" num="0038">Referring to the system <b>200</b> of <figref idref="DRAWINGS">FIG. 2</figref>, the following describes an implementation of the processing model based on the OAGIS message standard and using code assets following the Controller and Command patterns to handle the decomposition of task execution. The Service Oriented Architecture Get Processing pattern involves a controller command <b>202</b> or &#x201c;Get Controller&#x201d; that delegates to task commands <b>204</b> and <b>206</b>. In particular the task commands involve (1) a Fetch command <b>204</b> that pulls the data for the requested business objects from the persistence layer having a business object persistence manager <b>208</b> and transforms it into the OAGIS logical structure; and (2) an optional Compose command <b>206</b> that is used to augment the Business Objects (BOs) retrieved by the fetch, for example, to add computed values or aggregate with content from an alternate data source.</p>
<p id="p-0040" num="0039">In particular, the GetNoun command is the controller command <b>202</b> that will extract the search information from the request, delegate to a fetch command to return the list of nouns that match the expression and show verb response and package the response in the ShowNoun response. The GetNoun command can use the XPath selector approach to choose the appropriate fetch command implementation to retrieve the data. Although a default implementation can be used in most cases, an extension allows for additional business logic to be added for particular search expressions. Optionally, for those access profiles that can include additional information based on business logic or from an external system, the controller command <b>202</b> can instantiate an instance of a compose command for a particular access profile to populate more data. The compose command is optional and should be used in those cases where the information cannot be retrieved from the persistence layer <b>208</b>.</p>
<p id="p-0041" num="0040">The default fetch implementation will use the Business Object Manager (BOM) passing the search expression extracted from the Get verb. This search expression includes the XPath, access profile and paging information. The BOM in turn will use the logical mediators and data service to retrieve the data and convert it to its logical representation. The result of the BOM will be the paging information and logical nouns matching the expression. This information will be passed back by the fetch command which the GetNoun command will wTap in the ShowNoun response.</p>
<p id="p-0042" num="0041">Below is a detailed flow description of the Get processing pattern as illustrated in <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="h-0005" num="0000">1. The Business Object Document (BOD) processor sets the GetBOD on the GetNounCmd.</p>
<p id="h-0006" num="0000">2. The BOD processor invokes the GetNounCmd.</p>
<p id="h-0007" num="0000">3. The GetNounCmd parses the Get verb (using SearchExpression)</p>
<p id="h-0008" num="0000">4. The GetNounCmd will use the command factory to instantiate a FetchNounCmd. (The FetchNounCmd implementation will be instantiated based on interface name and XPath key).</p>
<p id="h-0009" num="0000">5. The GetNounCmd will set the Get verb and parsed Get verb on the FetchNotmCmd.</p>
<p id="h-0010" num="0000">6. The GetNounCmd invokes the FetchNounCmd.</p>
<p id="h-0011" num="0000">7. The FetchNounCmd will obtain an handle of the BOPM and execute the findObjects passing in the parsed Get verb.</p>
<p id="h-0012" num="0000">8. The BOM will execute the expression and return the logical Nouns and paging information.</p>
<p id="h-0013" num="0000">9. The FetchNounCmd will create the Show response.</p>
<p id="h-0014" num="0000">10. The GetNounCmd will ask for the list of Nouns and Show from the FetchNounCmd.</p>
<p id="h-0015" num="0000">11. The GetNounCmd will use the command factory to instantiate a ComposeNounCmd. (The ComposeNounCmd implementation will be instantiated based on the interface name and the access profile of the request).</p>
<p id="h-0016" num="0000">12. Only if a ComposeNounCmd is found; otherwise this step is skipped.</p>
<p id="p-0043" num="0042">(1) The GetNounCmd will set the Get verb, parsed Get verb and List of nouns from the FetchNounCmd.</p>
<p id="p-0044" num="0043">(2) The GetNounCmd invokes the ComposeNounCmd.</p>
<p id="p-0045" num="0044">(3) The ComposeNounCmd will process the list of Nouns and add more data to the existing list. More data can either be calculated by some business function or retrieved from the BOPM or another external service.</p>
<p id="h-0017" num="0000">13. The GetNounCmd creates the ShowBOD response and sets the Show verb from the FetchNounCmd and the List of Nouns (which may be updated by the ComposeNounCmd).</p>
<p id="p-0046" num="0045">With a Service Oriented Integration (SOI) implementation, the Change requests will be mapped to an existing Commerce controller commands and the requested Business Object Document is converted into the name value pair parameters that is passed to the controller command. This is for reuse of the existing business logic and enabling them as a service. But there are limitation using this model since it is difficult to represent structure objects into name value pairs. Another limitation is that the change request can only have one action.</p>
<p id="p-0047" num="0046">As part of the SOA programming model the limitation of one action in the change request is lifted to make valuable services that is not limited by the implementation. As a result of removing this restriction and having the ability to deal with structured objects, a pattern should be defined on how to process these requests. The purpose for this pattern is that all implementations behave the same so that it is easy for customers to understand the implementation of a change service and more importantly understand the extension points.</p>
<p id="p-0048" num="0047">For a change request processing pattern, the logic can be broken into three types of commands as shown in part in the system <b>300</b> of <figref idref="DRAWINGS">FIG. 3</figref>. The first command is the Change controller command <b>302</b> that helps to break the request into smaller tasks and execute these tasks. These smaller task commands will act upon parts of a noun instead of the entire noun. The controller command <b>302</b> also attempts to fetch the required data for the request upfront and passes this data to other task commands <b>304</b> so the command will use and update common data elements. This is to avoid data collision between task commands where they may act upon the same data and to avoid the performance overhead of each task commit changes and the next task must read from the database to pick up those changes. Once all the tasks are executed, the data read upfront will be persisted so the changes will be committed in the database.</p>
<p id="p-0049" num="0048">The second type of command is the business logic (Create, Update and Delete) CUD task commands that perform the appropriate action on the noun. This task deals with a particular part of the noun and is passed to the action to perform on the part of the noun that has changed and on the original request noun along with the data that was retrieved by the controller. The controller can have many instances of these task commands to act upon the many parts that are being changed as part of the message. The controller is responsible for executing the different task commands to perform the entire change operation. These business logic CUD tasks just need to work with nouns and understand how to deal with a particular part being modified.</p>
<p id="p-0050" num="0049">The final type of command is any post business logic <b>306</b> that may result because of a change of that part of the noun. These business logic tasks may not be necessary but there are cases where post evaluation on the changed business object will be needed as a result of changing specific parts. The change controller <b>302</b> will create instances of these business tasks and execute them after performing the change actions. These tasks will be given the actions performed on the part, the original request noun and the currently read and updated data that has not been persisted yet. These business logic tasks are optional so if no implementation is found, then the change controller will assume no additional business logic is required. As in the previous example, the system <b>300</b> further includes a Business Object Persistence Manager <b>308</b>.</p>
<p id="p-0051" num="0050">Below is a detail flow description of the Change processing pattern as illustrated in <figref idref="DRAWINGS">FIG. 3</figref>.</p>
<p id="h-0018" num="0000">1. The BOD processor sets the ChangeBOD on the ChangeNounCmd.</p>
<p id="h-0019" num="0000">2. The BOD processor invokes the ChangeNounCmd.</p>
<p id="h-0020" num="0000">3. The ChangeNounCmd parses the ChangeBOD, extracting the nouns and the actions associated with the noun.</p>
<p id="h-0021" num="0000">4. The ChangeNounCmd performs a read operation to resolve the specified Nouns. The read will return a Map containing each noun and the corresponding persistence container for the noun.</p>
<p id="p-0052" num="0051">5. The ChangeNounCmd performs a simple validation to ensure the nouns have been resolved and any other global validation logic. These validation errors are captured. current context can perform the specified actions on the specified nouns. These access control errors are captured.
<br/>
6. The ChangeNounCmd performs access control to ensure the current user under the current context can perform the specified actions on the specified nouns. These access control errors are captured.
<br/>
7. If validation or access control errors were reported, an application exception is raised containing all the errors and processing is stopped. If no errors occur, processing continues.
<br/>
8. The ChangeNounCmd instantiates the change part action and change part post action task commands and set the initial resolved objects and the nouns that will be involved for that task with a list of actions for each noun.
<br/>
9. For each change part action task command, the read and validate are invoked to retrieve additional data and validate the actions. All validation errors that occur are captured.
<br/>
10. If any validation error results, an application exception is raised containing all the validation errors and processing is stopped. If no validation errors occur, the processing continues.
<br/>
11. Each change part action task command is invoked. If an exception occurs, processing halts and the exception is thrown.
</p>
<p id="p-0053" num="0052">(1) The change part will iterate through the nouns and perform the specified actions for that noun part.</p>
<p id="p-0054" num="0053">(2) After all the nouns part actions have been performed, the save is called to persist changes on the data which was read by the task command.</p>
<p id="h-0022" num="0000">12. Each change part post action task command is invoked. If an exception occurs, processing halts and the exception is thrown.</p>
<p id="h-0023" num="0000">13. The ChangeNounCmd calls save( ) to persist any changes made to the original objects retrieve during the initial read.</p>
<p id="h-0024" num="0000">14. The ChangeNounCmd calls buildResponseBusinessObjectDocument( ) to create the appropriate response for the request and that response is returned.</p>
<p id="p-0055" num="0054">The SOI implementation of a process request is similar to that of a SOI implementation of a change request. This means that the existing message mapping feature will be used to transform the Process OAGIS request to a particular controller command passing resolved name value pairs resolved from the message. Because of this implementation, it limits the ability of the service where the one action per request rule was still maintained.</p>
<p id="p-0056" num="0055">Based on a new programming model or SOA Process Processing Pattern <b>400</b> as illustrated in <figref idref="DRAWINGS">FIG. 4</figref>, the restriction of one action per request is lifted but the rule is that the process action must act upon the entire noun. Unlike the change implementation where the change affects parts of the noun, the process applies to the noun specified in the request. Based on the information within a noun will control the actions of the business logic. Similar to the design pattern of Change process pattern, the Process pattern consists of a Process controller <b>402</b> which will read common data across the actions within the request and instantiate a task command implementations <b>404</b> for those actions and execute them. This pattern is a much simplified version than the pattern required for processing the Change request shown in <figref idref="DRAWINGS">FIG. 3</figref>. Again, as in the previous examples, the system <b>400</b> further includes a Business Object Persistence Manager <b>406</b>.</p>
<p id="p-0057" num="0056">Below is a detail flow description of the SOA Process processing pattern as illustrated in <figref idref="DRAWINGS">FIG. 4</figref>.</p>
<p id="h-0025" num="0000">1. The BOD processor sets the ProcessBOD on the ProcessNounCmd.</p>
<p id="h-0026" num="0000">2. The BOD processor invokes the ProcessNounCmd.</p>
<p id="h-0027" num="0000">3. The ProcessNounCmd parses the ProcessBOD, extracting the nouns and the actions associated with the noun.</p>
<p id="h-0028" num="0000">4. The ProcessNounCmd performs a read operation to resolve the specified Nouns. The read will return a Map containing each noun and the corresponding persistence container for the noun.</p>
<p id="h-0029" num="0000">5. The ProcessNounCmd performs a simple validation to ensure the nouns have been resolved and any other global validation logic. These validation errors are captured.</p>
<p id="h-0030" num="0000">6. The ProcessNounCmd performs access control to ensure the current user under the current context can perform the specified actions on the specified nouns. These access control errors are captured.</p>
<p id="h-0031" num="0000">7. If validation or access control errors were reported, an application exception is raised containing all the errors and processing is stopped. If no errors occur, processing continues.</p>
<p id="h-0032" num="0000">8. The ProcessNounCmd instantiates the process action task commands and set the initial resolved objects, the noun and action expression that will be involved for that action task.</p>
<p id="h-0033" num="0000">9. For each process action task command, the read and validate are invoked to retrieve additional data and validate the actions. All validation errors that occur are captured.</p>
<p id="h-0034" num="0000">10. If any validation error results, an application exception is raised containing all the validation errors and processing is stopped. If no validation errors occur, the processing continues.</p>
<p id="h-0035" num="0000">11. Each process action task command is invoked. If an exception occurs, processing halts and the exception is thrown.</p>
<p id="h-0036" num="0000">12. The ProcessNounCmd calls save( ) to persist any changes made to the original objects retrieve during the initial read.</p>
<p id="h-0037" num="0000">13. The ProcessNounCmd calls buildAcknowledgeBusinessObjectDocument( ) to create the appropriate response for the request and that response is returned.</p>
<p id="p-0058" num="0057">Synchronization or sync requests send out notifications when data has changed for a system that contains the master data record. The sync request will contain the updated version of the business object and sends out notification to all other listening systems to update their version of the business object.</p>
<p id="p-0059" num="0058">Although the purpose of sync requests is for a system to synchronize the information pertaining to the business object, the processing pattern for a sync request is similar to the change processing pattern illustrated previously in <figref idref="DRAWINGS">FIG. 3</figref>. When processing the sync request, the system will be updating its copy of the business object with the data from the sync request. The sync request will contain actions of what triggered the message to be sent and these actions correspond with the actions of a change request. In some cases, additional business logic will be required but this business logic may be different then the actual change logic.</p>
<p id="p-0060" num="0059">The classes involved with a sync request will be similar as Change processing pattern, except that the Sync implementation will be explicitly created to account for the slight differences of processing a Sync request. There will be reuse of objects so common commands can be reused for both service requests with some slight differences in the interfaces. A Sync process pattern or model <b>500</b> is just an extension of the change processing pattern and in one embodiment as shown in <figref idref="DRAWINGS">FIG. 5</figref> can include a Sync Noun controller <b>502</b>, a Sync Noun Part Task <b>504</b>, a Post Sync Noun Part Task <b>506</b> as well as a Business Object Persistence Manager <b>508</b>. Refer to Change processing pattern above for detail flow and access control.</p>
<p id="p-0061" num="0060">The present invention may be realized in hardware, software, or a combination of hardware and software. The present invention may be realized in a centralized fashion in one computer system or in a distributed fashion where different elements are spread across several interconnected computer systems. Any kind of computer system or other apparatus adapted for carrying out the methods described herein is suited. A typical combination of hardware and software may be a general purpose computer system with a computer program that, when being loaded and executed, controls the computer system such that it carries out the methods described herein.</p>
<p id="p-0062" num="0061">The present invention also may be embedded in a computer program product, which comprises all the features enabling the implementation of the methods described herein, and which when loaded in a computer system is able to carry out these methods. Computer program in the present context means any expression, in any language, code or notation, of a set of instructions intended to cause a system having an information processing capability to perform a particular function either directly or after either or both of the following: a) conversion to another language, code or notation; b) reproduction in a different material form.</p>
<p id="p-0063" num="0062">This invention may be embodied in other forms without departing from the spirit or essential attributes thereof. Accordingly, reference should be made to the following claims, rather than to the foregoing specification, as indicating the scope of the invention.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A service-oriented component processing system for solving multi-channel problems, the service-oriented component processing system comprising:
<claim-text>a processor;</claim-text>
<claim-text>a memory;</claim-text>
<claim-text>a first module for causing the processor to provide a service provider comprising a plurality of service objects, each service object comprising a self-describing, self-contained, platform independent, modular unit of application logic; and</claim-text>
<claim-text>a second module for causing the processor to provide a service object among the plurality of service objects to operate as a service implementation having a pre-ordained message processing system using a common transfer object message format that separates business objects into a header and a body,</claim-text>
<claim-text>wherein the service implementation is configured to respond to a client invocation of a Read operation by taking a structured action list and using the structured action list to resolve a list of business objects to be retrieved and responding to the Read operation with data for each of the business objects in the list of business objects to be retrieved via a persistence layer of the service implementation, the data for each of the business objects is in one of a detailed form or a summary form based on a configuration of the invocation of the Read operation indicated in the structured action list, and wherein the processing system for the Read operation comprises a Get controller command that invokes:
<claim-text>an appropriate Fetch task command selected by using an XPath to obtain data via the persistence layer corresponding to the data specified in the client invocation of the Read operation to yield obtained data and to transform the obtained data into an OAGIS logical structure, where the Fetch task command uses the persistence layer passing a search expression, the search expression comprising the XPath, an access profile, and paging information, and</claim-text>
<claim-text>an optional Compose task command for selectively augmenting the obtained data with content from an alternate source when a portion of the data specified in the client invocation of the Read operation is unavailable via the persistence layer, where the Compose task command is based on an interface name and the access profile,</claim-text>
</claim-text>
<claim-text>wherein the service implementation is configured to respond to a client invocation of an Update operation by taking the structured action list and using the structured action list to resolve a list of business objects to be modified and where the action list describes precise parts of the business objects to be modified using a notation that allows for reference to a precise part of a business object, and wherein the processing system for the Update operation comprises a Change controller command that fetches data to be updated, performs validation and access control on the data to be updated, and invokes:
<claim-text>a Change task command for updating the data to be updated, and</claim-text>
<claim-text>an optional Post Change task command for evaluating changes to the business objects.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the service implementation responds to client requests at different levels of granularity.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein each of the business objects is arranged and constructed to be decomposable into its constituent parts.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The system of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the business objects are supported by a common set of operations.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the system supports scale-up from an action affecting a sub-part of one of the business objects to actions affecting entire business objects or lists of business objects.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein when the client invokes an Execute operation, the service implementation takes a structured action list and uses the structured action list to resolve a list of business objects to be processed, wherein the execute operation contains information describing which business objects to be updated and what actions to execute against the business objects, and wherein the processing system for the Execute operation comprises a Process controller command that fetches the data and invokes an Action task command for performing the action on the data.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein when the client invokes a Broadcast operation, the service implementation takes a structured action list and uses the structured action list to resolve a list of business objects to be modified and where the action list describes the precise part of the business objects to be affected using a notation that allows for reference to a precise part of the business object, and wherein the processing system for the Broadcast operation comprises a Sync controller command that fetches the data and invokes at least one Sync task command for updating of the data and Post Sync task command for evaluating syncing of the business objects.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. A computer readable storage having stored thereon a computer program for implementing, via a computer, a service-oriented architecture component processing model for processing messages to a service implementation for solving multi-channel problems, the computer program comprising a plurality of code sections for:
<claim-text>implementing a service provider comprising a plurality of service objects, each service object comprising a self-describing, self-contained, platform independent, modular unit of application logic;</claim-text>
<claim-text>implementing a service object among the plurality of service objects being a service implementation having a pre-ordained message processing system using a common transfer object message format that separates business objects into a header and a body; and</claim-text>
<claim-text>configuring the service implementation to respond to client requests at different levels of granularity,</claim-text>
<claim-text>wherein the service implementation is configured to respond to a client invocation of a Read operation by taking a structured action list and using the structured action list to resolve a list of business objects to be retrieved and responding to the Read operation with data for each of the business objects in the list of business objects to be retrieved via a persistence layer of the service implementation, the data for each of the business objects is in one of a detailed form or a summary form based on a configuration of the invocation of the Read operation indicated in the structured action list, and wherein the processing system for the Read operation comprises a Get controller command that invokes:</claim-text>
<claim-text>an appropriate Fetch task command selected by using an XPath to obtain data via the persistence layer corresponding to the data specified in the client invocation of the Read operation to yield obtained data and to transform the obtained data into an OAGIS logical structure, where the Fetch task command uses the persistence layer passing a search expression, the search expression comprising the XPath, an access profile, and paging information, and</claim-text>
<claim-text>an optional Compose task command for selectively augmenting the obtained data with content from an alternate source when a portion of the data specified in the client invocation of the Read operation is unavailable via the persistence layer, where the Compose task command is based on an interface name and the access profile,</claim-text>
<claim-text>wherein the service implementation is configured to respond to a client invocation of an Update operation by taking the structured action list and using the structured action list to resolve a list of business objects to be modified and where the action list describes precise parts of the business objects to be modified using a notation that allows for reference to a precise part of a business object, and wherein the processing system for the Update operation comprises a Change controller command that fetches data to be updated, performs validation and access control on the data to be updated, and invokes:
<claim-text>a Change task command for updating the data to be updated, and</claim-text>
<claim-text>an optional Post Change task command for evaluating changes to the business objects.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The computer-readable storage of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein each of the business objects is arranged and constructed to be decomposable into its constituent parts.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The computer-readable storage of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the model is configured to support scale-up from an action affecting a sub-part of at least one of the business objects to actions affecting entire business objects or lists of business objects.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The computer-readable storage of <claim-ref idref="CLM-00008">claim 8</claim-ref>, further comprising code sections for, responsive to the client invoking an Execute operation, configuring the service implementation to take a structured action list and use the structured action list to resolve a list of business objects to be processed, wherein the Execute operation contains information describing which business objects to be updated and what actions to execute against the business objects, and wherein the processing system for the Execute operation comprises a Process controller command that fetches the data and invokes an Action task command for performing the action on the data.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The computer-readable storage of <claim-ref idref="CLM-00008">claim 8</claim-ref>, further comprising code sections for, responsive to the client invoking a Broadcast operation, the service implementation takes a structured action list and uses the structured action list to resolve a list of business objects to be modified and where the action list describes the precise part of the business objects to be affected using a notation that allows for reference to a precise part of the business object, and wherein the processing system for the Broadcast operation comprises a Sync controller command that fetches the data and invokes at least one Sync task command for updating of the data and Post Sync task command for evaluating syncing of the business objects. </claim-text>
</claim>
</claims>
</us-patent-grant>
