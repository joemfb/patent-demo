<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08624899-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08624899</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12890760</doc-number>
<date>20100927</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>256</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>T</subclass>
<main-group>1</main-group>
<subgroup>00</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>T</subclass>
<main-group>15</main-group>
<subgroup>40</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>345442</main-classification>
<further-classification>345418</further-classification>
<further-classification>345441</further-classification>
</classification-national>
<invention-title id="d2e53">Arc spline GPU rasterization for cubic Bezier drawing</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5046023</doc-number>
<kind>A</kind>
<name>Katsura et al.</name>
<date>19910900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>345619</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>7239319</doc-number>
<kind>B2</kind>
<name>Loop</name>
<date>20070700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>345467</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>2004/0001061</doc-number>
<kind>A1</kind>
<name>Stollnitz et al.</name>
<date>20040100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2007/0097121</doc-number>
<kind>A1</kind>
<name>Loop et al.</name>
<date>20070500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>2007/0097123</doc-number>
<kind>A1</kind>
<name>Loop et al.</name>
<date>20070500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2010/0013854</doc-number>
<kind>A1</kind>
<name>Michail</name>
<date>20100100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00007">
<othercit>&#x201c;Direct GPU Rendering of Curves and Surfaces&#x201d; Retrieved at &#x3c;&#x3c;http://web.archive.org/web/20090305111216/http://research.microsoft.com/en-us/projects/gpu<sub>&#x2014;</sub>rendering<sub>&#x2014;</sub>curves<sub>&#x2014;</sub>and<sub>&#x2014;</sub>surfaces/default.aspx&#x3e;&#x3e;, Published on Mar. 5, 2009.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00008">
<othercit>Ri{hacek over (s)}kus, Aleksas, &#x201c;Approximation of a Cubic Bezier Curve by Circular Arcs and Vice Versa&#x201d;, Retrieved at &#x3c;&#x3c; http://itc.ktu.lt/itc354/Riskus354.pdf &#x3e;&#x3e;, Information Technology and Control, vol. 35, No. 4, 2006, p. 371-378.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00009">
<othercit>Andrew, &#x201c;Convert Ellipse to Cubic Bezier&#x201d;, Retrieved at &#x3c;&#x3c; http://www.mail-archive.com/svg-developers@yahoogroups.com/msg03305.html &#x3e;&#x3e;, Apr. 10, 2005, pp. 4.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00010">
<othercit>Plant, Darrel, &#x201c;Working with Cubic Paths in a Quadratic World&#x201d;, Retrieved at &#x3c;&#x3c; http://www.informit.com/articles/article.aspx?p=24821&#x26;seqNum=5 &#x3e;&#x3e;, Jan. 4, 2002, pp. 3.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00011">
<othercit>Onstott, Scott, &#x201c;Bezier Splines in SketchUp Using Ruby Scripts&#x201d;, Retrieved at &#x3c;&#x3c; http://www.aecbytes.com/ tipsandtricks/2009/issue42-sketchup.html &#x3e;&#x3e;, May 22, 2009, Issue 42, pp. 8.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00012">
<othercit>&#x201c;Direct GPU Rendering of Curves and Surfaces&#x201d;, Retrieved at &#x3c;&#x3c; http://research.microsoft.com/en-us/projects/gpu<sub>&#x2014;</sub>rendering<sub>&#x2014;</sub>curves<sub>&#x2014;</sub>and<sub>&#x2014;</sub>surfaces/default.aspx &#x3e;&#x3e;, Jun. 21, 2010, pp. 2.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00013">
<othercit>Loop, et al., &#x201c;Rendering Vector Art on the GPU&#x201d;, Retrieved at &#x3c;&#x3c; http://http.developer.nvidia.com/GPUGems3/gpugems3<sub>&#x2014;</sub>ch25.html &#x3e;&#x3e;, Jun. 18, 2010, pp. 19.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00014">
<othercit>Muizelaar, Jeff, &#x201c;Geometry Homework&#x201d;, Retrieved at &#x3c;&#x3c; http://muizelaar.blogspot.com/ &#x3e;&#x3e;, Oct. 7, 2009, pp. 7.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00015">
<othercit>Loop, Charles et al.; &#x201c;Resolution Independent Curve Rendering using Programmable Graphics Hardware&#x201d;; ACM Transactions on Graphics (Proceedings of SIGGRAPH 2005) 24(3); 2005; 10 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>20</number-of-claims>
<us-exemplary-claim>20</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>4</number-of-drawing-sheets>
<number-of-figures>4</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20120075310</doc-number>
<kind>A1</kind>
<date>20120329</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Michail</last-name>
<first-name>Ashraf A.</first-name>
<address>
<city>Redmond</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Teitlebaum</last-name>
<first-name>David B.</first-name>
<address>
<city>Seattle</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Furtwangler</last-name>
<first-name>Brandon C.</first-name>
<address>
<city>Bothell</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Michail</last-name>
<first-name>Ashraf A.</first-name>
<address>
<city>Redmond</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Teitlebaum</last-name>
<first-name>David B.</first-name>
<address>
<city>Seattle</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Furtwangler</last-name>
<first-name>Brandon C.</first-name>
<address>
<city>Bothell</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Chin IP, PLLC</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Chin</last-name>
<first-name>David</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Microsoft Corporation</orgname>
<role>02</role>
<address>
<city>Redmond</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Richer</last-name>
<first-name>Aaron M</first-name>
<department>2677</department>
</primary-examiner>
<assistant-examiner>
<last-name>Craddock</last-name>
<first-name>Robert</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A curve drawing system is described herein that rasterizes arc splines in the GPU of a computer for cubic Bezier drawing of strokes and thin features. The curve drawing system first converts a cubic Bezier representation into an arc spline representation. Then the curve drawing system uses a similar approach to Loop/Blinn modified to cause the pixel shader to perform a point-in-circular-arc test instead of a point-in-Bezier test. Calculating arc radius is a much simpler operation than the alternatives and can be easily and efficiently performed by the pixel shader. Since the stroke of an arc spline is also an arc spline, the drawing system provides a resolution-independent representation of strokes. Thus, the curve drawing system allows several previously difficult graphical features to be efficiently drawn by readily available legacy hardware and used in software programs that are designed to run on a wide variety of hardware.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="158.41mm" wi="82.04mm" file="US08624899-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="125.39mm" wi="179.32mm" file="US08624899-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="170.94mm" wi="90.68mm" file="US08624899-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="171.53mm" wi="83.90mm" file="US08624899-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="139.78mm" wi="185.25mm" file="US08624899-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND</heading>
<p id="p-0002" num="0001">Computer programs over the years have become more and more visually appealing using various graphical techniques. Aside from its main function, a typical computer program today has an enormous amount of graphical calculation going on under the hood. For example, programs often render fonts using resolution-independent vector graphics that can be easily scaled and manipulated with various transforms. Programs often render buttons and other graphical user interface (GUI) elements with a smooth, rounded edge, and so forth. To avoid interfering with the program, designers often strive to offload as much of the graphical burden to a dedicated Graphics Processing Unit (GPU) as possible. Curves are often approximated using cubic Bezier splines, and using the GPU to draw a cubic Bezier involves translation into a representation such as a set of triangles, a pixel shader, and a vertex shader that a GPU can draw.</p>
<p id="p-0003" num="0002">One common type of drawing request that is difficult to handle in the GPU using existing techniques are stroked cubic Beziers. Cubic Beziers curves are a useful approximation for drawing thin curved lines. However, a stroke involves a thickness of the line whereby related lines some distance from the original are to be drawn and the space between the lines is to be filled. For example, a thick font or curved button with a shadow might involve a stroked cubic Bezier. On the other hand, very thin features, particularly at the sub-pixel level, are also difficult to draw using the GPU.</p>
<p id="p-0004" num="0003">To support fast animation of cubic Beziers, any representation should remain scale independent and be reused when the transform has changed across frames. One known approach to solve this problem is the Loop/Blinn algorithm (Loop, Charles, and Jim Blinn. 2005. &#x201c;Resolution Independent Curve Rendering using Programmable Graphics Hardware.&#x201d; In ACM Transactions on Graphics (Proceedings of SIGGRAPH 2005) 24(3), pp. 1000-1008.), which evaluates the cubic Bezier in a pixel shader and enables resolution-independent drawing of cubic Beziers. Unfortunately, this approach is not capable of efficiently drawing stroked cubic Beziers curves, which are common in vector graphics. In particular, a stroke of a cubic Bezier is not itself a cubic Bezier and evaluating the distance from a cubic Bezier is not a simple operation to perform in a pixel shader. In addition, the Loop/Blinn algorithm is not suited to drawing thin features since it relies on non-overlapping curve decomposition, which is not always possible with a thin curve stroke. Even a thickness of one pixel may produce incorrect rendering results.</p>
<p id="p-0005" num="0004">For artistic strokes, such as textures that follow the curve of a stroke, length along the curve can be used to texture map a stroke template along the curve. This information is not readily available with the Loop/Blinn algorithm in the pixel shader. Most scale-independent rendering solutions for MICROSOFT&#x2122; DIRECTX&#x2122; 9 hardware are based on the Loop/Blinn approach. More recent MICROSOFT&#x2122; DIRECTX&#x2122; 11 hardware can solve the problem with hardware tessellation using a multi-sample buffer. However, cutting-edge hardware is slowly adopted.</p>
<heading id="h-0002" level="1">SUMMARY</heading>
<p id="p-0006" num="0005">A curve drawing system is described herein that rasterizes arc splines in the GPU of a computer for cubic Bezier drawing of strokes and thin features. The curve drawing system first converts a cubic Bezier representation into an arc spline representation. Then the curve drawing system uses a similar approach to Loop/Blinn modified to cause the pixel shader to perform a point-in-circular-arc test instead of a point-in-Bezier test. Calculating arc radius is a much simpler operation than the alternatives and can be performed easily and efficiently by the pixel shader. Since the stroke of an arc spline is also an arc spline, the drawing system provides a resolution-independent representation of strokes. Thus, the curve drawing system allows several previously difficult graphical features to be efficiently drawn by readily available legacy hardware and used in software programs that are designed to run on a wide variety of hardware.</p>
<p id="p-0007" num="0006">This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram that illustrates components of the curve drawing system, in one embodiment.</p>
<p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. 2</figref> is a flow diagram that illustrates processing of the curve drawing system to draw a stroked cubic Bezier curve, in one embodiment.</p>
<p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. 3</figref> is a flow diagram that illustrates processing of the curve drawing system to handle drawing of advanced curves using a GPU, in one embodiment.</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 4</figref> is a display diagram that illustrates a thin stroked circle rendered by the curve drawing system, in one embodiment.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0012" num="0011">A curve drawing system is described herein that rasterizes arc splines in the GPU of a computer for cubic Bezier drawing of strokes and thin features. The curve drawing system first converts a cubic Bezier representation into an arc spline representation. Several techniques for doing so are well known in the art (e.g., Riskus, Aleksas. 2006. &#x201c;Approximation of a Cubic Bezier Curve by Circular Arcs and Vice Versa.&#x201d; In Information Technology and Control, 2006, Vol. 35, No. 4, pp. 371-378). Then the curve drawing system uses a similar approach to Loop/Blinn modified to cause the pixel shader to perform a point-in-circular-arc test instead of a point-in-Bezier test. Calculating arc radius is a much simpler operation than the alternatives and can be performed easily and efficiently by the pixel shader. Alternatively or additionally, the curve drawing system can encode two or more curves in each triangle and intersect these curves to allow thin features to be represented. Since the stroke of an arc spline is also an arc spline, the drawing system provides a resolution-independent representation of strokes. The curve length is trivial to compute for a circular arc, and this approach enables artistic strokes. The representation of two or more curves in each triangle and intersecting the curves allows for thin, sub-pixel features. Thus, the curve drawing system allows several advanced but common and previously difficult graphical features to be efficiently drawn by readily available legacy hardware and used in software programs that are designed to run on a wide variety of hardware.</p>
<p id="p-0013" num="0012">As described further herein, the curve drawing system solves the stroke problem by: 1) converting a cubic Bezier into an arc spline representation using an algorithm such as Riskus, 2) using a modified Loop/Blinn approach to perform a point-in-circular-arc test instead of a point-in-Bezier test, and 3) in each test, encoding two or more curves instead of one and intersecting those curves to allow for thin features to be drawn. Since the stroke of an arc spline is also an arc spline, this provides a resolution-independent representation of strokes. In addition, the curve arc length is trivial to compute for a circular arc, and this approach enables artistic strokes. The curve drawing system accomplishes the second step by encoding each arc in a triangle. Since both line segments and arcs have to be encoded, an encoding with the arc radius is not used since this would result in infinite distances in the case of lines (or near straight curves) which cannot be used in a point-in-arc test. In some embodiments, the curve drawing system solves this problem by instructing the pixel shader to assume all arcs are centered at coordinates (0, 0) with radius one and the texture units on the triangle are used to map the coordinate system of the actual arc to the unit circle. This encoding can represent a straight edge by duplicating a texture coordinate, which is equivalent to an infinitesimally small segment of the circular arc.</p>
<p id="p-0014" num="0013">The curve drawing system also modifies a typical representation that encodes one curve per triangle to encode two (or more) curves per triangle and intersect them to allow for thin features. For example, suppose an arbitrary cubic pixel is subdivided into a set of triangles such that each triangle contains a left curve and a right curve. The intersection of these two curves allows for a thin vertical line or curve to be represented. With this representation, the point-in-circle test as well as the anti-aliasing approach discussed by Loop/Blinn can be performed with the following pixel shader for both the left and right curves. For purposes of illustration, this sample is simplified but those of ordinary skill in the art will recognize that it can be easily modified to provide more information on the outside/inside of the arc with a sign bit.</p>
<p id="p-0015" num="0014">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>// Compute distance from left/right arcs from the unique cube</entry>
</row>
<row>
<entry/>
<entry>dist[0] = dot(vs.pos1, vs.pos1);</entry>
</row>
<row>
<entry/>
<entry>dist[1] = dot(vs.pos2, vs.pos2);</entry>
</row>
<row>
<entry/>
<entry>dist = sqrt(dist);</entry>
</row>
<row>
<entry/>
<entry>// Compute anti-aliasing based on distance to curve</entry>
</row>
<row>
<entry/>
<entry>float2 alpha = clamp(0.5 + (1.0 &#x2212; dist)/(abs(ddx(dist)) +</entry>
</row>
<row>
<entry/>
<entry>abs(ddy(dist))), 0, 1);</entry>
</row>
<row>
<entry/>
<entry>// Sample the texture at that position and output a texture color</entry>
</row>
<row>
<entry/>
<entry>return textureSampler.Sample(g_samLinear, vs.pos1)*(alpha[0]&#x2212;</entry>
</row>
<row>
<entry/>
<entry>alpha[1])*vs.Color;</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram that illustrates components of the curve drawing system, in one embodiment. The system <b>100</b> includes an input component <b>110</b>, a representation conversion component <b>120</b>, a triangulation component <b>130</b>, a point-in-arc test component <b>140</b>, a fill component <b>150</b>, a curve encoding component <b>160</b>, an antialiasing component <b>170</b>, and a rendering component <b>180</b>. Each of these components is described in further detail herein.</p>
<p id="p-0017" num="0016">The input component <b>110</b> receives a cubic Bezier representation of a path describing one or more shapes. For example, a drawing program may output an image of an object using one or more cubic Bezier curves. The input component <b>110</b> receives one or more data structures that describe the curves and the region or regions that are defined as interior and exterior of the curves. For example, for a TrueType font, a letter can be described by one or more cubic Bezier curves with the letter defined as the interior and any background or open space in the letter defined as exterior. The interior portions are filled during rendering to create the expected displayed shape. The system <b>100</b> may be implemented within a software program or as an externally callable module or component. The input component <b>110</b> receives input using one or more programmatic conventions well known to those of ordinary skill in the art. For example, the component <b>110</b> may expose a function for invoking the system <b>100</b> and may receive a description of a path to draw in one or more data structures received as parameters to the function.</p>
<p id="p-0018" num="0017">The representation conversion component <b>120</b> converts the received cubic Bezier representation into an arc spline representation. Whereas several control points define a cubic Bezier, an arc spline is typically defined as several arcs of circles having a particular origin and radius. The two representations are similar and both easily rendered. However, whereas it is very difficult to determine distance from a particular point on a cubic Bezier curve (a common computation for strokes), it is much easier to determine distance from an arc spline, which is typically simply a modification of the radius. Conversion back and forth between cubic Bezier representation and arc spline representation can be efficiently performed by modern CPUs or graphics hardware.</p>
<p id="p-0019" num="0018">The triangulation component <b>130</b> produces a set of triangles that represents the interior region of the path defined by the arc spline representation. Modern graphics hardware renders many shapes as triangles, and the triangulation component <b>130</b> converts a shape defined in any other representation into a set of triangles that can be passed to the graphics hardware for rendering. In typical cubic Bezier representations, triangulation is performed based on drawing triangles to each of the Bezier control points and adding additional triangles for any regions having sharp edges or other features not covered in triangulation between the control points.</p>
<p id="p-0020" num="0019">The point-in-arc test component <b>140</b> determines whether a particular point lies within an arc defined by the arc spline representation. This test is a replacement of the Bezier-based test used by the Loop/Blinn algorithm. The modified test operates on paths represented by arc splines to determine whether a particular point lies within the interior region of a path defined by arc splines. The test can be efficiently performed in modern graphics hardware using a pixel shader or other techniques. Typically, the test involves a distance comparison between the point and the origin of the arc circle. The radius of the arc circle can be used to determine if the point is inside or outside the arc. In some embodiments, triangulation is performed on a CPU while the point-in-arc test is performed in a pixel shader while rendering the triangles.</p>
<p id="p-0021" num="0020">The fill component <b>150</b> fills in the set of triangles to visually represent a shape to be rendered based on the received path. The fill component may apply a particular color or texture to the filled region to compose the interior of the path. For example, for a letter of a font, the fill may include a black foreground color representing the letter and a white background color representing the surface on which the letter is rendered.</p>
<p id="p-0022" num="0021">The curve encoding component <b>160</b> encodes two or more curves within a single triangle for representing thin features. In the past, each triangle typically would include a single curve and algorithms like Loop/Blinn used extra care to ensure that no two triangles overlapped to avoid producing undesirable visual artifacts. Where overlapping occurred, such methods further decompose the curves until overlapping is no longer present. This technique makes it difficult to render thin features, which often occur at a sub-pixel level. The curve encoding component <b>160</b> can place multiple curves within the same triangle and intersect the curves to create complex shapes. This technique is particularly well suited to rendering thin features that were difficult with previous techniques.</p>
<p id="p-0023" num="0022">The antialiasing component <b>170</b> smoothes edges of curves approximated by triangles to avoid visible rough edges. Without antialiasing, objects rendered using triangulation can appear jagged and appear to turn on and off as they move and overlap pixels in different patterns. Antialiasing alleviates such visual artifacts by approximating a smooth edge along jagged surfaces, such as by super-sampling the point-in-arc tests within the pixel shader after triangulation. Those of ordinary skill in the art will recognize numerous available techniques for applying antialiasing prior to rendering.</p>
<p id="p-0024" num="0023">The rendering component <b>180</b> renders the resulting shape produced by the other components. The rendering component <b>180</b> may include specialized graphics hardware, such as a GPU including pixel and/or vertex shaders for efficient rendering. The rendering component <b>180</b> produces a visual representation of the shape on a screen or other display device so that the shape is visible to the user.</p>
<p id="p-0025" num="0024">The computing device on which the system is implemented may include a central processing unit, memory, input devices (e.g., keyboard and pointing devices), output devices (e.g., display devices), and storage devices (e.g., disk drives or other non-volatile storage media). The memory and storage devices are computer-readable storage media that may be encoded with computer-executable instructions (e.g., software) that implement or enable the system. In addition, the data structures and message structures may be stored or transmitted via a data transmission medium, such as a signal on a communication link. Various communication links may be used, such as the Internet, a local area network, a wide area network, a point-to-point dial-up connection, a cell phone network, and so on.</p>
<p id="p-0026" num="0025">Embodiments of the system may be implemented in various operating environments that include personal computers, server computers, handheld or laptop devices, multiprocessor systems, microprocessor-based systems, programmable consumer electronics, digital cameras, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, set top boxes, systems on a chip (SOCs), and so on. The computer systems may be cell phones, personal digital assistants, smart phones, personal computers, programmable consumer electronics, digital cameras, and so on.</p>
<p id="p-0027" num="0026">The system may be described in the general context of computer-executable instructions, such as program modules, executed by one or more computers or other devices. Generally, program modules include routines, programs, objects, components, data structures, and so on that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments.</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 2</figref> is a flow diagram that illustrates processing of the curve drawing system to draw a stroked cubic Bezier curve, in one embodiment. Beginning in block <b>210</b>, the system receives a cubic Bezier representation of a visual object to be rendered. For example, the system may receive the representation from a drawing program or GUI component of a software application. The cubic Bezier representation describes the visual object in using resolution-independent vector graphics. Cubic Beziers curves are described by four points, a start point, an endpoint, and two control points. The control points &#x201c;pull&#x201d; the curve in the direction of the control points, but the curve does not actually pass through the control points. Additional control points can be added to further refine the curve shape. A Bezier spline is simply multiple Bezier curves attached end-to-end. While a cubic Bezier representation is great at describing many types of curves, it is difficult to calculate distance from various points of the curve, such as to draw a thick stroke or artistic stroke.</p>
<p id="p-0029" num="0028">Continuing in block <b>220</b>, the system converts the cubic Bezier representation into an arc spline representation. An arc spline representation includes multiple circular arcs that have start and end points, an origin point, and a radius (which can be inferred from the other points). The circular arcs approximate the same shape as the cubic Bezier representation. However, unlike the cubic Bezier representation it is much simpler to determine distance from a curve defined by an arc spline, as distance typically involves a quantifiable difference in the radius from the origin point. Thus, once in the arc spline representation, strokes and other distance-based relationships to the curve can be calculated using readily available graphics hardware, such as pixel shaders of a GPU. This representation works well up to 200&#xd7; zoom and stays fairly resolution independent. In addition, an arc spline representation maintains the continuity of the original cubic Bezier representation, which would be difficult to achieve using linear approximation of the Bezier curves.</p>
<p id="p-0030" num="0029">Continuing in block <b>230</b>, the system triangulates the visual object described by the arc spline representation to produce one or more triangles for rendering. Triangulation describes the shape of the visual object using a set of triangles that are common for rendering with modern graphical hardware. Those of ordinary skill in the art will recognize numerous well-known techniques for converting cubic Bezier and arc spline representations into one or more triangles for rendering. Interior triangles can be treated as degenerate arcs that are filled. In some embodiments, the system may optionally render the arcs themselves (e.g., using a geometry shader), rather than a triangulated representation. Selection of this option may depend on determining whether appropriate hardware is available. Continuing in block <b>240</b>, the system renders the triangles with an arc spline pixel shader. Continuing in block <b>250</b>, the system performs one or more point-in-arc tests during the rendering process for rendering the arc spline representation to determine one or more points that lie within the visual object represented by the arc spline representation. The point-in-arc test replaces the point-in-Bezier test that would be used for directly rendering the cubic Bezier representation (e.g., using the Loop/Blinn approach).</p>
<p id="p-0031" num="0030">During rendering, the system fills the visual object based on the arc spline representation and triangulation. The interior of the visual object may be defined by convention (e.g., the area to the right of each curve arc or Bezier curve) or explicitly in one or more data structures that accompany the representation of the spline. The fill may include one or more colors or textures, and may be applied by pixel shaders or other available graphical hardware.</p>
<p id="p-0032" num="0031">Continuing in block <b>260</b>, the system displays the visual object using graphical hardware. For example, the system may invoke a GPU with the triangulation output and one or more pixel shaders to render the visual object efficiently. As the object changes (e.g., through user activity such as resizing or the nature of the object such as video playback), the system may transform a previously described representation of the object within the graphics hardware using well-known techniques. After block <b>260</b>, these steps conclude.</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 3</figref> is a flow diagram that illustrates processing of the curve drawing system to handle drawing of advanced curves using hardware GPU, in one embodiment. Beginning in block <b>310</b>, the system receives a graphical representation of a thin stroke that includes overlapping curves. For example, a thin stroke defined by a cubic Bezier curve may include two curves that define each edge of the stroke (e.g., the left and right sides of an artistic pen stroke). During triangulation using existing techniques (e.g., Loop/Blinn), overlapping curves are eliminated by adding additional control points or other subdividing techniques to avoid overlapping triangles, which leads to an inability to represent thin features.</p>
<p id="p-0034" num="0033">Continuing in block <b>320</b>, the system encodes a first curve in a triangle associated with the graphical representation of the thin stroke. During triangulation, curves are represented by one or more triangles. Using existing techniques, only one curve is encoded per triangle, and additional curves are placed in separate triangles that do not overlap the first. Continuing in block <b>330</b>, the system encodes a second curve in the same triangle as the first curve. Unlike previous techniques, the system can place two or more curves in the same triangle. This allows the curves to interact through intersection so that thin features can be easily represented and overlapping is no longer a problem. In some embodiments, the system may encode additional curves within the same triangle, such as to allow definition of more complex overlapping shapes.</p>
<p id="p-0035" num="0034">Continuing in block <b>340</b>, the system determines an intersection of the first and second curves within the triangle. The intersection may define a filled area between the two curves or other visual object having then features to be rendered. Continuing in block <b>350</b>, the system fills an interior region of the thin stroke determined by the intersection of the first and second curves within the triangulated area. For example, the system may apply a color or texture between the two curves to define a visual object like a pen stroke or letter of a font. Continuing in block <b>360</b>, the system renders the triangle or triangles that include the received thin stroke using graphical hardware. For example, the system may pass the triangles as parameters in one or more instructions to a GPU. After block <b>360</b>, these steps conclude.</p>
<p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. 4</figref> is a display diagram that illustrates a thin stroked circle rendered by the curve drawing system, in one embodiment. The diagram includes a first triangle <b>410</b> and a second triangle. The triangles are typical triangles resulting from triangulation in preparation for rendering a visual object to graphical hardware. Within the triangles are two circles, an inner circle <b>430</b> and an outer circle <b>440</b>. The circles may be defined by a cubic Bezier approximation (e.g., using four cubic Bezier curves), an arc spline representation as described further herein, or other suitable representation for defining the circles. The circles define a thin interior region <b>450</b> that represent a thin visual object to be rendered.</p>
<p id="p-0037" num="0036">Using existing techniques, this type of rendering is not possible without subdividing the first triangle <b>410</b> and second triangle <b>420</b> until each triangle includes only one curve and no triangles overlap. For very thin features, such as those that are small enough to be at the pixel or sub-pixel level, this level of subdivision is not available or at least inefficient. By allowing multiple curves to be encoded within the same triangle, the curve drawing system eliminates the need for excessive work to eliminate overlap, and instead allows calculations that can reasonably and efficiently be performed in widely available graphical hardware. For example, half of the inner circle <b>430</b> and outer circle <b>440</b> can both be encoded within the same triangle <b>410</b>. The intersection defined by the interior region <b>450</b> can be determined by a pixel shader and filled using a specified fill pattern.</p>
<p id="p-0038" num="0037">In some embodiments, the curve drawing system operates on higher or lower order Bezier curves. For example, although conversion from cubic Bezier curves has been described herein, the system can also be applied to quadratic or other Bezier parameterizations, as well as other splines and polynomials. In addition, the system is suitable for converting from other representations (e.g., non-Bezier) that do not allow for efficient calculation of features a specified distance from the curve. Thus, where cubic Beziers representations are mentioned herein, they are provided only as examples, and those of ordinary skill in the art will recognize that the system can be easily extended to accommodate other representations by converting to the arc spline representation described herein.</p>
<p id="p-0039" num="0038">In some embodiments, the curve drawing system encodes more than two curves or splines within the same triangle (e.g., either half of <figref idref="DRAWINGS">FIG. 4</figref>). The system can allow additional splines to define shapes that would overlap or cause other difficulties in traditional representations. Modern pixel shaders can handle calculations related to intersection and other interactions of a certain number of splines within a triangular region. By allowing a complexity of splines up to the available pixel shader limits, the system allows complex rendering to be performed efficiently and with fewer calculations than existing techniques.</p>
<p id="p-0040" num="0039">From the foregoing, it will be appreciated that specific embodiments of the curve drawing system have been described herein for purposes of illustration, but that various modifications may be made without deviating from the spirit and scope of the invention. Accordingly, the invention is not limited except as by the appended claims.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>We claim:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A computer-implemented method for drawing a stroked curve, the method comprising:
<claim-text>receiving a Bezier representation of a visual object to be rendered, wherein the visual object is a stroke of a Bezier curve, and wherein the stroke of the Bezier curve is not a Bezier curve;</claim-text>
<claim-text>converting the Bezier representation into an arc spline representation;</claim-text>
<claim-text>triangulating the visual object described by the arc spline representation to produce one or more triangles for rendering;</claim-text>
<claim-text>performing one or more point-in-arc tests during rendering to determine one or more points that lie within the visual object represented by the arc spline representation; and</claim-text>
<claim-text>displaying the visual object using graphical hardware,</claim-text>
<claim-text>wherein the preceding steps are performed by at least one processor.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein receiving the Bezier representation comprises receiving the representation from a graphical user interface component of a software application.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein receiving the Bezier representation comprises an artistic stroke related to one or more Bezier curves.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein receiving the Bezier representation comprises receiving a Bezier spline comprised of multiple Bezier curves that describe the visual object.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein converting to an arc spline representation comprises identifying multiple circular arcs that approximate the same shape as the Bezier representation.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein converting to an arc spline representation comprises converting to a representation from which distance to the curve can be determined within available graphics hardware.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the point-in-arc test allows determining a distance of a feature of the visual object from the arc spline without performing calculations from the Bezier representation.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein triangulating comprises representing a shape of the visual object using a set of triangles for rendering with graphical hardware.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising rendering at least one arc in the arc spline representation directly with graphical hardware without using the triangulated representation.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising filling the visual object based on the arc spline representation and triangulation.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein displaying the visual object comprises invoking a graphics processing unit (GPU) and providing the rendered output.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein rendering the visual object comprises invoking one or more pixel shaders to render the visual object efficiently.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. A computer system for resolution-independent rendering of advanced curved objects, the system comprising:
<claim-text>a processor and memory configured to execute software instructions embodied within the following components;</claim-text>
<claim-text>an input component configured to receive a Bezier representation of a path describing one or more shapes, wherein the path is a stroke of a Bezier curve, and wherein the stroke of the Bezier curve is not itself a Bezier curve;</claim-text>
<claim-text>a representation conversion component configured to convert the received Bezier representation into an arc spline representation;</claim-text>
<claim-text>a triangulation component configured to produce a set of triangles that represent an interior region of the path defined by the arc spline representation;</claim-text>
<claim-text>a point-in-arc test component configured to determine whether a particular point lies within an arc defined by the arc spline representation;</claim-text>
<claim-text>fill component configured to fill in the set of triangles to visually represent a shape to be rendered based on the received path; and</claim-text>
<claim-text>a rendering component configured to render the resulting shape produced by the other components using graphics hardware to produce a visual representation of the shape on a display device.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The system of <claim-ref idref="CLM-00013">claim 13</claim-ref> wherein the input component is further configured to receive one or more data structures that describe the curves, and the region or regions that are defined as interior and exterior of the curves, wherein the interior portions are filled during rendering to create a displayed shape.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The system of <claim-ref idref="CLM-00013">claim 13</claim-ref> wherein the representation conversion component is further configured to convert control points that define the Bezier curve to arcs of circles having a particular origin and radius that define an arc spline, wherein the arc spline representation allows determining distance for features near the arc spline based on radius.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The system of <claim-ref idref="CLM-00013">claim 13</claim-ref> wherein the point-in-arc test component is further configured to operate on paths represented by an arc spline to determine whether a particular point lies within the interior region of a path defined by the arc spline.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The system of <claim-ref idref="CLM-00013">claim 13</claim-ref> wherein the triangulation component is further configured to produce a representation of a shape that can be rendered by graphics hardware.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The system of <claim-ref idref="CLM-00013">claim 13</claim-ref> further comprising a curve encoding component configured to encode two or more curves within a single triangle and determining an intersection of the curves for representing thin features.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The system of <claim-ref idref="CLM-00013">claim 13</claim-ref> further comprising an antialiasing component configured to smooth edges of curves approximated by triangles to avoid visible rough edges.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. A computer-readable memory having instructions stored therein for controlling a computer system to draw advanced curves that include thin features, wherein the instructions, upon execution, cause a processor to perform actions comprising:
<claim-text>receiving a graphical representation of a thin stroke that, upon triangulation, includes one or more overlapping triangles, wherein triangulation represents one or more curves using one or more triangles that can be drawn by graphical hardware;</claim-text>
<claim-text>encoding a first curve in a triangle associated with the graphical representation of the thin stroke;</claim-text>
<claim-text>encoding a second curve in the same triangle as the first curve, wherein encoding both curves in the same triangle allows the curves to interact through intersection so that thin features can be represented without eliminating overlapping triangles;</claim-text>
<claim-text>determining an intersection of the first and second curves within the triangle, wherein the intersection defines at least one filled area between the two curves;</claim-text>
<claim-text>filling an interior region of the thin stroke determined by the intersection of the first and second curves within the triangulated area; and</claim-text>
<claim-text>rendering the triangle that includes the received thin stroke by invoking graphical hardware.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
