<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08626811-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08626811</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12770996</doc-number>
<date>20100430</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>884</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>7</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>7</main-group>
<subgroup>38</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>H</section>
<class>04</class>
<subclass>L</subclass>
<main-group>9</main-group>
<subgroup>00</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>H</section>
<class>04</class>
<subclass>L</subclass>
<main-group>9</main-group>
<subgroup>38</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>H</section>
<class>04</class>
<subclass>K</subclass>
<main-group>1</main-group>
<subgroup>00</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>708491</main-classification>
<further-classification>708492</further-classification>
<further-classification>380 28</further-classification>
<further-classification>380255</further-classification>
</classification-national>
<invention-title id="d2e53">Method and apparatus for providing flexible bit-length moduli on a block Montgomery machine</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5144574</doc-number>
<kind>A</kind>
<name>Morita</name>
<date>19920900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>708491</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5499299</doc-number>
<kind>A</kind>
<name>Takenaka et al.</name>
<date>19960300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>380 28</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>5751620</doc-number>
<kind>A</kind>
<name>Monier</name>
<date>19980500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>5982900</doc-number>
<kind>A</kind>
<name>Ebihara et al.</name>
<date>19991100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>380 30</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>6175850</doc-number>
<kind>B1</kind>
<name>Ishii et al.</name>
<date>20010100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>708491</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>6356636</doc-number>
<kind>B1</kind>
<name>Foster et al.</name>
<date>20020300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>6735611</doc-number>
<kind>B2</kind>
<name>Vanstone</name>
<date>20040500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>7536564</doc-number>
<kind>B2</kind>
<name>Liardet et al.</name>
<date>20090500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713194</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2004/0220989</doc-number>
<kind>A1</kind>
<name>Elbe et al.</name>
<date>20041100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>708492</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2006/0064453</doc-number>
<kind>A1</kind>
<name>Fischer et al.</name>
<date>20060300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>708620</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2006/0222175</doc-number>
<kind>A1</kind>
<name>Itoh et al.</name>
<date>20061000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>380 28</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2006/0235921</doc-number>
<kind>A1</kind>
<name>Itoh et al.</name>
<date>20061000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>708492</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2007/0168411</doc-number>
<kind>A1</kind>
<name>Hubert</name>
<date>20070700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>708492</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2007/0185948</doc-number>
<kind>A1</kind>
<name>Elbe et al.</name>
<date>20070800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>708400</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>2007/0260664</doc-number>
<kind>A1</kind>
<name>Bertoni et al.</name>
<date>20071100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>708490</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>2009/0086961</doc-number>
<kind>A1</kind>
<name>Sauzet et al.</name>
<date>20090400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>2010/0023571</doc-number>
<kind>A1</kind>
<name>Furukawa et al.</name>
<date>20100100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>708491</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00018">
<document-id>
<country>US</country>
<doc-number>2010/0064142</doc-number>
<kind>A1</kind>
<name>Matsuzaki</name>
<date>20100300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713189</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00019">
<document-id>
<country>EP</country>
<doc-number>1845442</doc-number>
<kind>A1</kind>
<date>20071000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00020">
<document-id>
<country>EP</country>
<doc-number>1939838</doc-number>
<kind>A1</kind>
<date>20080700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00021">
<document-id>
<country>EP</country>
<doc-number>1975906</doc-number>
<kind>A1</kind>
<date>20081000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00022">
<document-id>
<country>WO</country>
<doc-number>WO 2004/114124</doc-number>
<kind>A1</kind>
<date>20041200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00023">
<othercit>Jinook Song and In-Cheol Park, &#x201c;Division-less high-radix interleaved modular multiplication using a scaled modulus,&#x201d; 2011 International SoC Design Conference (ISOCC), pp. 215-218, Nov. 2011.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00024">
<othercit>Orup, H.; &#x201c;Simplifying Quotient Determination in High-Radix Modular Multiplication&#x201d;; 12<sup>th </sup>IEEE Symposium on Computer Arithmetic, Jul. 19 to 21, 1005; pp. 193 to 199; IEEE Computer Society Press.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00025">
<othercit>Menezes, A. et al.; Handbook of Applied Cryptography; 1997; pp. 591 to 634; Chapter 14: Efficient Implementation; CRC Press, Boca Raton, Florida.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00026">
<othercit>Verhoof, Paul; Search Report from corresponding European Application No. 10161699.3; search completed Sep. 16, 2010.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00027">
<othercit>Mikkelsen, Gert; &#x201c;Implementing Multi-Precision Modular Arithmetic From a Classical Approach to Montgomery Reduction&#x201d;; Dec. 14, 2005.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00028">
<othercit>Menezes, A. et al.; Handbook of Applied Cryptography; 1997; pp. 600 to 620; CRC Press, Boca Raton, Florida.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>21</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>708491-492</main-classification>
<additional-info>unstructured</additional-info>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>708620</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>380 28</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>380 30</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>380 44</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>713189</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>7</number-of-drawing-sheets>
<number-of-figures>8</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20110270906</doc-number>
<kind>A1</kind>
<date>20111103</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Lambert</last-name>
<first-name>Robert John</first-name>
<address>
<city>Cambridge</city>
<country>CA</country>
</address>
</addressbook>
<residence>
<country>CA</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Poeluev</last-name>
<first-name>Yuri</first-name>
<address>
<city>Waterloo</city>
<country>CA</country>
</address>
</addressbook>
<residence>
<country>CA</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Lambert</last-name>
<first-name>Robert John</first-name>
<address>
<city>Cambridge</city>
<country>CA</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Poeluev</last-name>
<first-name>Yuri</first-name>
<address>
<city>Waterloo</city>
<country>CA</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<last-name>So</last-name>
<first-name>Wilfred P.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Orange</last-name>
<first-name>John R. S.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="03" rep-type="attorney">
<addressbook>
<orgname>Blake Cassels &#x26; Graydon LLP.</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Certicom Corp.</orgname>
<role>03</role>
<address>
<city>Mississauga</city>
<country>CA</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Ngo</last-name>
<first-name>Chuong D</first-name>
<department>2193</department>
</primary-examiner>
<assistant-examiner>
<last-name>Sandifer</last-name>
<first-name>Matthew</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Techniques are disclosed for utilizing a block Montgomery machine designed only to operate at a fixed block length to perform operations using non-block length (flexible)moduli. In one embodiment, a new modulus n&#x2032; is obtained having a block length equal to the fixed block length of the Montgomery machine or a multiple thereof. At least one modular additive operation is performed with the new modulus n&#x2032;, and at least one modular multiplicative operation is performed with the non-block length modulus n. In this way, the result of the at least one additive operation is sufficiently reduced when a carry stems from the additive operation.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="166.88mm" wi="98.98mm" file="US08626811-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="241.47mm" wi="187.28mm" file="US08626811-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="204.64mm" wi="100.08mm" file="US08626811-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="63.25mm" wi="175.01mm" file="US08626811-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="208.53mm" wi="111.08mm" file="US08626811-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="142.07mm" wi="100.08mm" file="US08626811-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="184.66mm" wi="103.97mm" file="US08626811-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="111.68mm" wi="106.51mm" file="US08626811-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">TECHNICAL FIELD</heading>
<p id="p-0002" num="0001">The following relates generally to methods and apparatuses for implementing modular arithmetic operations in a computing device, and has particular utility in computing devices used in cryptographic systems.</p>
<heading id="h-0002" level="1">BACKGROUND</heading>
<p id="p-0003" num="0002">A cryptographic system is a computer system that uses cryptography, typically to secure or authenticate data communication between a pair of computing devices connected to one another through a data communication link in the system. Each computing device has a cryptographic unit with the processing capacity to implement one or more cryptographic protocols used to secure or authenticate the data communication. The cryptographic protocols typically perform arithmetic operations on the bit strings representing parameters in the protocols to produce a bit string representing the output from the protocol.</p>
<p id="p-0004" num="0003">Computing devices in a cryptographic system are often required to perform arithmetic operations in which modular arithmetic is necessary. For example, a computing device may be required to multiply two integers modulo some n. The classical approach to performing this operation is to first perform the multiplication of the integers and then divide the product by the modulus n. The remainder from the division represents the modular reduction. However, performing the modular reduction of an integer by dividing the integer by the modulus n to obtain the remainder can be relatively computationally expensive. Therefore, other modular reduction techniques have been developed that attempt to increase the computational efficiency of modular reduction.</p>
<p id="p-0005" num="0004">One such technique is the method of Montgomery modular reduction, referred to as Montgomery reduction for short. Montgomery reduction is known in the art and is discussed in detail, for example, in section 14.3.2 of the <i>Handbook of Applied Cryptography</i>, Menezes et al., CRC Press, 1997. Montgomery reduction benefits from the fact that steps of multiplication and shifting are generally faster than division on most computing machines. Montgomery reduction also relies on performing certain precomputations, and by doing so many calculations can be done faster. Also, as opposed to classical methods of reduction-from-above, such as Euclidean division, Montgomery reduction reduces from below, that is, the method proceeds by clearing the least-significant portions of the unreduced quantity, leaving the remainder in the upper portion, and therefore benefits from excluding carries that may otherwise interfere with the already cleared portion.</p>
<p id="p-0006" num="0005">In Montgomery reduction, calculations with respect to a modulus n are carried out with the aid of an auxiliary number R called the Montgomery radix or base. R is chosen such that R&#x3e;n and such that the greatest common divisor of R and n is one, i.e. gcd(R,n)=1. When the modulus n is an odd (often prime) number, a good choice of R is typically the first convenient power of two larger than the modulus n; i.e., R=2<sup>r</sup>, where r is an integer chosen such that R is the first convenient power of two greater than the modulus n. The Montgomery reduction of a number T is the quantity given by computing TR<sup>&#x2212;1 </sup>mod n. This computation requires the values T, R, n, and &#x3bc;=(&#x2212;n)<sup>&#x2212;1 </sup>mod 2<sup>w</sup>, where w is an integer, typically representing the bit size of a word (or block) of the value being operated on. The value &#x3bc; is used to effect the Montgomery reduction. A summary of Montgomery reduction follows.</p>
<p id="p-0007" num="0006">A computational engine performing Montgomery reduction receives as an input the modulus n, precomputed values R=2<sup>r </sup>and &#x3bc;, and the integer Ton which Montgomery reduction is to be performed. For Montgomery reduction to operate correctly, the property must hold that gcd(n,R)=1 and T&#x3c;nR. The computational engine performs the following computations to obtain the value TR<sup>&#x2212;1 </sup>mod n:</p>
<p id="p-0008" num="0007">1. A&#x2190;T (Notation: A=(a<sub>2d&#x2212;1 </sub>. . . a<sub>1</sub>a<sub>0</sub>)<sub>b </sub>where b=2<sup>w </sup>and d is the number of words of the modulus n&#x2014;note that d=r/w).</p>
<p id="p-0009" num="0008">2. For i=0 to d&#x2212;1 do the following:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0009">2.1 u<sub>i</sub>&#x2190;a<sub>i</sub>&#x3bc; mod b</li>
        <li id="ul0002-0002" num="0010">2.2 A&#x2190;A+u<sub>i</sub>nb<sup>i </sup></li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0010" num="0011">3. A&#x2190;A/b<sup>d </sup></p>
<p id="p-0011" num="0012">4. If then A&#x2190;A&#x2212;n</p>
<p id="p-0012" num="0013">5. Return (A).</p>
<p id="h-0003" num="0000">The value A returned equals TR<sup>&#x2212;1 </sup>mod n.</p>
<p id="p-0013" num="0014">It is noted that sometimes the final reduction (step 4) in Montgomery reduction is omitted, for example, to counter side channel attacks if the modulus n is secret. In such a scenario, the value returned TR<sup>&#x2212;1 </sup>is not fully reduced mod n, but is equivalent to the fully reduced value (mod n). That is, the output of the Montgomery reduction is a value that is congruent to TR<sup>&#x2212;1 </sup>mod n modulo n.</p>
<p id="p-0014" num="0015">The technique of Montgomery multiplication is also known in the art and is described, for example, in section 14.3.2 of the <i>Handbook of Applied Cryptography</i>, Menezes et al., CRC Press, 1997. The Montgomery multiplication of two numbers a and b is the Montgomery reduction of their product, computed as a<img id="CUSTOM-CHARACTER-00001" he="3.13mm" wi="2.46mm" file="US08626811-20140107-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>b=abR<sup>&#x2212;1 </sup>mod n. Techniques such as Montgomery exponentiation, described in section 14.6.1 of the <i>Handbook of Applied Cryptography</i>, Menezes et al., CRC Press, 1997, utilize Montgomery multiplication to increase computational efficiency. A summary of Montgomery multiplication follows.</p>
<p id="p-0015" num="0016">A computational engine performing Montgomery multiplication receives as an input the modulus n, precomputed values R=2<sup>r </sup>and &#x3bc;, and the integers x and y on which Montgomery multiplication is to be performed. For Montgomery multiplication to operate correctly, it must be the case that gcd(n,R)=1. It is usual that 0&#x2266;x,y&#x3c;n. The computational engine performs the following computations to obtain the value xyR<sup>&#x2212;1 </sup>mod n:</p>
<p id="p-0016" num="0017">1. A&#x2190;0 (Notation: A=(a<sub>d</sub>a<sub>d&#x2212;1 </sub>. . . a<sub>1</sub>a<sub>0</sub>)<sub>b </sub>where b=2<sup>w </sup>and d is the number of words of the modulus n&#x2014;note that d=r/w).</p>
<p id="p-0017" num="0018">2. For i=0 to d&#x2212;1 do the following:
<ul id="ul0003" list-style="none">
    <li id="ul0003-0001" num="0000">
    <ul id="ul0004" list-style="none">
        <li id="ul0004-0001" num="0019">2.1 u<sub>i</sub>&#x2190;(a<sub>0</sub>+x<sub>i</sub>y<sub>0</sub>)&#x3bc; mod b</li>
        <li id="ul0004-0002" num="0020">2.2 A&#x2190;(A+x<sub>i</sub>y+u<sub>i</sub>n)/b</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0018" num="0021">3. If A&#x2267;n then A&#x2190;A&#x2212;n</p>
<p id="p-0019" num="0022">4. Return (A).</p>
<p id="h-0004" num="0000">The value A returned is xyR<sup>&#x2212;1 </sup>mod n.</p>
<p id="p-0020" num="0023">As with Montgomery reduction, the final reduction (step 3) in Montgomery multiplication may be omitted if side channel attacks are a concern. In this case, the output of the Montgomery reduction is a value congruent to xyR<sup>&#x2212;1 </sup>mod n modulo n.</p>
<p id="p-0021" num="0024">Typically, calculations using Montgomery reduction are carried out on numbers in their Montgomery form. The Montgomery form of a number a is computed as &#xe2;=aR mod n. Modular addition or subtraction (modulo n) of values in Montgomery form produces results in Montgomery form. Additionally, Montgomery multiplication of values in Montgomery form also produces values in Montgomery form, i.e., &#xe2;<img id="CUSTOM-CHARACTER-00002" he="3.13mm" wi="2.46mm" file="US08626811-20140107-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>{circumflex over (b)}=aR&#xb7;bRR<sup>&#x2212;1 </sup>mod n=abR mod n. Conveniently, conversion to Montgomery form may be carried out via the Montgomery multiplication &#xe2;=a<img id="CUSTOM-CHARACTER-00003" he="3.13mm" wi="2.46mm" file="US08626811-20140107-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>R<sup>2</sup>=aR mod n, and conversion from Montgomery form back to regular (non-Montgomery) or canonical form may be carried out by either the Montgomery reduction: &#xe2;R<sup>&#x2212;1 </sup>mod n=a mod n, or by the Montgomery multiplication: &#xe2;<img id="CUSTOM-CHARACTER-00004" he="3.13mm" wi="2.46mm" file="US08626811-20140107-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>1=aRR<sup>&#x2212;1</sup>=a mod n.</p>
<p id="p-0022" num="0025">A computing device in a cryptographic system will often have a computational engine for calculating the Montgomery product of two numbers. This computational engine is typically referred to as a Montgomery machine or Montgomery engine. The machine may be implemented in a hardware or software module, and is configured to operate on a set of parameters to produce a result. For example, the machine may perform the Montgomery multiplication on two inputs a and b and output the result a<img id="CUSTOM-CHARACTER-00005" he="3.13mm" wi="2.46mm" file="US08626811-20140107-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>b. Such a Montgomery machine can therefore also be used to convert to and from Montgomery form and to perform Montgomery reduction. For converting to Montgomery form, the machine accepts a and R<sup>2 </sup>as inputs and computes the output &#xe2;=a<img id="CUSTOM-CHARACTER-00006" he="3.13mm" wi="2.46mm" file="US08626811-20140107-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>R<sup>2</sup>=aR mod n. Conversely, for converting back to canonical form, the machine accepts a and 1 as inputs and computes the output &#xe2;<img id="CUSTOM-CHARACTER-00007" he="3.13mm" wi="2.46mm" file="US08626811-20140107-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>1=a. To calculate the Montgomery reduction of &#xe2; value a, the machine accepts a and 1 as inputs and computes a<img id="CUSTOM-CHARACTER-00008" he="3.13mm" wi="2.46mm" file="US08626811-20140107-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>1=aR<sup>&#x2212;1 </sup>mod n as the output.</p>
<p id="p-0023" num="0026">The Montgomery machine is typically provided with the value of the modulus n and perhaps the value of the Montgomery radix R (or an equivalent value such as r). The machine then computes the value &#x3bc;, which is utilized as a precomputed value in subsequent operations. Alternatively, the Montgomery radix R may instead be computed by the machine and/or the value &#x3bc; may instead be provided to the Montgomery machine. The value R<sup>2 </sup>is then computed from the Montgomery radix R=2<sup>r </sup>and stored for use by the Montgomery machine to convert numbers into their Montgomery form. Note that R is a fixed point of Montgomery multiplication (i.e. R<img id="CUSTOM-CHARACTER-00009" he="3.13mm" wi="2.46mm" file="US08626811-20140107-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>R=R) and therefore it is not possible to obtain R<sup>2 </sup>mod n by simply performing the Montgomery multiplication of R with itself. The computation of R<sup>2 </sup>mod n can instead be performed by utilizing a series of addition and multiplication/squaring operations. For example, one way to perform the computation is as follows: (1) start with the value R=2<sup>r&#x2212;1</sup>; (2) add this value to itself: (2<sup>r&#x2212;1</sup>+2<sup>r&#x2212;1</sup>)mod n=2<sup>r </sup>mod n; (3) add the resulting value to itself: (2<sup>r </sup>mod n+2<sup>r </sup>mod n)mod n=2<sup>r+1 </sup>mod n; (4) square the resulting value using Montgomery multiplication: 2<sup>r+1 </sup>mod n<img id="CUSTOM-CHARACTER-00010" he="3.13mm" wi="2.46mm" file="US08626811-20140107-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>2<sup>r+1 </sup>mod n=2<sup>r+2 </sup>mod n; and (5) continue squaring the resulting value via Montgomery multiplication until the value 2<sup>r+r/2 </sup>mod n<img id="CUSTOM-CHARACTER-00011" he="3.13mm" wi="2.46mm" file="US08626811-20140107-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>2<sup>r+r/2 </sup>mod n=2<sup>r+r </sup>mod n=R<sup>2 </sup>mod n is obtained.</p>
<p id="p-0024" num="0027">The computation of R<sup>2 </sup>mod n utilizing a series of addition and multiplication/squaring operations, such as those described above, is known in the art. Many variations are also known, including variations that modify the order in which the adding and multiplying/squaring is performed. For example, one variation of performing the computation R<sup>2 </sup>mod n is as follows: (1) calculate the two's complement of n: R&#x2212;n; (2) add this value to itself to yield (R&#x2212;n)+(R&#x2212;n)=(2R)mod n; and (3) multiply (2R)mod n by itself r times using Montgomery multiplication to yield R<sup>2 </sup>mod n:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>(2<i>R</i>)mod <i>n</i><img id="CUSTOM-CHARACTER-00012" he="3.13mm" wi="2.46mm" file="US08626811-20140107-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/><i>(</i>2<i>R</i>)mod <i>n</i><img id="CUSTOM-CHARACTER-00013" he="3.13mm" wi="2.46mm" file="US08626811-20140107-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/><i> . . . </i><img id="CUSTOM-CHARACTER-00014" he="3.13mm" wi="2.46mm" file="US08626811-20140107-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/><i>(</i>2<i>R</i>)mod <i>n=</i><img id="CUSTOM-CHARACTER-00015" he="3.13mm" wi="13.38mm" file="US08626811-20140107-P00002.TIF" alt="custom character" img-content="character" img-format="tif"/><i>=R</i><sup>2 </sup>mod <i>n. </i><?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0025" num="0028">Many variations for computing R<sup>2 </sup>mod n are known in the art, two of which are shown above. In all of these variations, a series of addition and multiplication and/or squaring operations are performed. Also, in all of these variations, if the final reduction step is omitted in the Montgomery multiplication operations, the value R<sup>2 </sup>computed may not be fully reduced (i.e. it may not be R<sup>2 </sup>mod n per se), but it will be congruent to R<sup>2 </sup>mod n modulo n.</p>
<p id="p-0026" num="0029">Typically, Montgomery machines are limited only to performing operations with moduli of a fixed bit-length, or multiples of this length. Such machines are referred to as block Montgomery machines. The block-length of a block Montgomery machine is often 32, 64, 128 or 256 bits, with allowable bit-lengths for the moduli consisting of multiples of this block length. Such a structure is disadvantageous when implementing schemes that use moduli having bit lengths not equal to the fixed bit-length of the Montgomery machine (or a multiple thereof).</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0005" level="1">BRIEF DESCRIPTION</heading>
<p id="p-0027" num="0030">Embodiments will now be described by way of example only with reference to the accompanying drawings in which:</p>
<p id="p-0028" num="0031"><figref idref="DRAWINGS">FIG. 1</figref> is a schematic block diagram of a cryptographic communication system;</p>
<p id="p-0029" num="0032"><figref idref="DRAWINGS">FIG. 2</figref> is a schematic block diagram of the cryptographic module of <figref idref="DRAWINGS">FIG. 1</figref> having a block Montgomery machine;</p>
<p id="p-0030" num="0033"><figref idref="DRAWINGS">FIG. 3</figref> is a schematic of an embodiment of a method of calculating the value R<sup>2</sup>;</p>
<p id="p-0031" num="0034"><figref idref="DRAWINGS">FIG. 4</figref> is a schematic block diagram showing the conversion of a non-block-length modulus into a new modulus having a bit length equal to a block length of a Montgomery machine;</p>
<p id="p-0032" num="0035"><figref idref="DRAWINGS">FIG. 5</figref> is a schematic of another embodiment of a method of calculating the value R<sup>2</sup>;</p>
<p id="p-0033" num="0036"><figref idref="DRAWINGS">FIG. 6</figref> is a schematic of an embodiment of a method of calculating a single atomic modular operation;</p>
<p id="p-0034" num="0037"><figref idref="DRAWINGS">FIG. 7</figref> is a schematic of an embodiment of a method of calculating a sequence of modular arithmetic operations; and</p>
<p id="p-0035" num="0038"><figref idref="DRAWINGS">FIG. 8</figref> is a schematic of an embodiment of a method of performing modular operations using a modulus n.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0006" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0036" num="0039">It has been recognized that Montgomery machines having a fixed block length present difficulties whenever arithmetic operations with respect to moduli of other bit lengths are required, whether for calculations in Rivest-Shamir-Adleman (RSA), the digital signature algorithm (DSA), or Diffie-Hellman (DH) cryptographic schemes at these non-block-length moduli, or for computation of points in elliptic curves (EC) or hyper elliptic curves HEC, together referred to as (H)EC. Specifically, it has been recognized that if a block Montgomery machine is used with a modulus n that has a bit length that is not equal to the block length of the Montgomery machine (or its multiple), then in some modular operations (e.g. modular addition or modular subtraction) in which the result contains a carry/borrow out of the upper block (i.e. when the result becomes bigger than the maximum allowed by the machine), the step of automatically subtracting or adding the modulus n once is not necessarily sufficient since n will not have the required top bit set in the uppermost block. The result will therefore not be sufficiently reduced and subsequent calculations may then be incorrect.</p>
<p id="p-0037" num="0040">For example, the National Institute of Standards &#x26; Technology (NIST) standards contain ECC point-order moduli at 521 bits. A block Montgomery machine as described earlier, designed for fixed moduli that are multiples of a typical binary-power block length (16 bits, 32 bits, etc.) cannot directly be used for modular calculations at an unsupported bit-length, such as at 521 bits. If such a block Montgomery machine is operated with the 521 bit-length modulus n, then during some of the modular operations in which the result contains a carry/borrow out of the upper block, the step of automatically subtracting or adding the modulus n once is not necessarily sufficient since n will not have the required top bit set in the uppermost block. The result will not be sufficiently reduced by the addition/subtraction of n and subsequent calculations may then be incorrect.</p>
<p id="p-0038" num="0041">Therefore, in general terms, the following provides a method and apparatus for utilizing a block Montgomery machine designed only to operate at a fixed block length to perform operations using non-block length (flexible)moduli. For example, it has been recognized that when performing multiplicative operations using a block Montgomery machine having a fixed block length, the non-block length modulus can be directly utilized to produce correct values. For additive operations (e.g. addition and subtraction), a shifted or scaled modulus can be obtained and used. As an example, methods of computing the R<sup>2 </sup>value using the non-block length and shifted moduli are provided.</p>
<p id="p-0039" num="0042">As will also be described in detail below, for a sequence of modular operations employing the flexible moduli, where the machine maintains the results in Montgomery form, a shifted or scaled modulus and corresponding precomputed Montgomery values yield correct and efficient sequential computations.</p>
<p id="p-0040" num="0043">By utilizing the described techniques, an existing or standard Montgomery machine can be used to support non-block length moduli calculations.</p>
<p id="p-0041" num="0044">Embodiments will now be described with reference to the figures. It will be appreciated that for simplicity and clarity of illustration, where considered appropriate, reference numerals may be repeated among the figures to indicate corresponding or analogous elements. In addition, numerous specific details are set forth in order to provide a thorough understanding of the embodiments described herein. However, it will be understood by those of ordinary skill in the art that the embodiments described herein may be practiced without these specific details. In other instances, well-known methods, procedures and components have not been described in detail so as not to obscure the embodiments described herein. Also, the description is not to be considered as limiting the scope of the embodiments described herein.</p>
<p id="p-0042" num="0045">It will also be appreciated that that any module, component, or device exemplified herein that executes instructions may include or otherwise have access to computer readable media such as storage media, computer storage media, or data storage devices (removable and/or non-removable) such as, for example, magnetic disks, optical disks, or tape. Computer storage media may include volatile and non-volatile, removable and non-removable media implemented in any method or technology for storage of information, such as computer readable instructions, data structures, program modules, or other data. Examples of computer storage media include RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by an application, module, or both. Any such computer storage media may be part of the device or accessible or connectable thereto. Any application or module herein described may be implemented using computer readable/executable instructions that may be stored or otherwise held by such computer readable media.</p>
<p id="p-0043" num="0046">Referring first to <figref idref="DRAWINGS">FIG. 1</figref>, a cryptographic system <b>10</b> generally comprises a first correspondent <b>12</b> that communicates with a second correspondent <b>14</b> over a communication channel <b>16</b>. The correspondents <b>12</b> and <b>14</b> are data communication devices such as computers or computing devices, mobile devices, PDAs, etc., that respond to user inputs to configure and transmit messages. Each correspondent includes a cryptographic unit or module <b>18</b>, which either has its own memory <b>20</b> for storing inputs, outputs and intermediate portions of cryptographic operations, or has access to an external memory <b>20</b> that is part of the correspondent (<b>12</b>, <b>14</b>). It can be seen that in the embodiment shown in <figref idref="DRAWINGS">FIG. 1</figref>, the first correspondent <b>12</b> includes a memory <b>20</b> external to the cryptographic module <b>18</b> and the second correspondent <b>14</b> includes memory <b>20</b> that is internal to the cryptographic module <b>18</b> to illustrate that the capability to store data can be provided in any suitable arrangement. It will also be appreciated that the memory <b>20</b> can be external to and accessible (e.g. via a network connection etc.) to the correspondent <b>12</b>, <b>14</b> (not shown) if necessary or desired.</p>
<p id="p-0044" num="0047">The cryptographic module <b>18</b> is configured to perform cryptographic operations such as encryption/decryption, signing and modular arithmetic, etc. For the purposes of illustration, it will be assumed that the cryptographic module <b>18</b> is configured for performing elliptic curve cryptographic (ECC) operations, although it will be appreciated that operations based on other underlying groups used in cryptographic systems may be utilized.</p>
<p id="p-0045" num="0048">The cryptographic module <b>18</b> includes a block Montgomery machine <b>22</b> (also called a block Montgomery engine <b>22</b>), further details of which are shown in <figref idref="DRAWINGS">FIG. 2</figref>. It will be appreciated that the cryptographic module <b>18</b> and any component thereof may be implemented as an apparatus in either hardware or software (computer readable instructions stored on a computer readable medium).</p>
<p id="p-0046" num="0049">As can be seen in <figref idref="DRAWINGS">FIG. 2</figref>, the cryptographic module <b>18</b> includes a controller <b>23</b>, the block Montgomery machine <b>22</b>, and a memory <b>30</b>. The block Montgomery machine <b>22</b> comprises a register file <b>26</b> and an arithmetic logic unit (ALU) <b>28</b>.</p>
<p id="p-0047" num="0050">It will be appreciated that the memory <b>30</b> may instead be included in the machine <b>22</b>, rather than external to the machine <b>22</b> as illustrated. It will also be appreciated that the memory <b>30</b> may comprise all or part of the memory <b>20</b> (shown in <figref idref="DRAWINGS">FIG. 1</figref>) or may be provided as a separate component in the cryptographic module <b>18</b> as shown. The memory <b>30</b> may include random access memory (RAM), read only memory (ROM) and/or any other type of suitable memory structure.</p>
<p id="p-0048" num="0051">The register file <b>26</b> comprises a group of general purpose registers, which can be used as intermediate storage for cryptographic operations performed for and by the cryptographic module <b>18</b>. The register file <b>26</b> communicates with the ALU <b>28</b> via data input buses <b>32</b>. The ALU <b>28</b> comprises integer arithmetic circuitry. A data output or result bus <b>34</b> is provided from the ALU <b>28</b> to the register file <b>26</b> for writing results of computations performed in the ALU <b>28</b> to the register file <b>26</b>.</p>
<p id="p-0049" num="0052">Computational operations of the ALU <b>28</b> are controlled via programmed instructions residing in or accessible to the controller <b>23</b>. A memory bus <b>36</b> is also provided to enable the controller <b>23</b> and the machine <b>22</b> to utilize memory <b>30</b> when performing and outputting results of the cryptographic operations. Typically, the machine <b>22</b> is utilized in an existing host computer system and the controller <b>23</b> receives control signals from the host system and communicates data to the register file <b>26</b> and ALU <b>28</b>.</p>
<p id="p-0050" num="0053">The general purpose registers that make up the register file <b>26</b> are made up of a certain number of blocks, each having a fixed length, e.g. 128 bits. As is known in the art, the blocks are used to store data during computations; i.e., the block computations are performed, intermediate results are stored in a combination of registers and memory, and the complete multi-block computation is built up from block-length component computations.</p>
<p id="p-0051" num="0054">The machine <b>22</b> is configured to convert numbers into Montgomery form, perform modular arithmetic operations (e.g. additive and multiplicative operations) on values in Montgomery form, and convert the results out of Montgomery form. The components and digital logic necessary for implementing such operations are known in the art, and it will be appreciated that <figref idref="DRAWINGS">FIG. 2</figref> does not illustrate all of the components and logic necessary for performing such operations. On the contrary, <figref idref="DRAWINGS">FIG. 2</figref> has been simplified for the purposes of illustration. The ALU <b>28</b> shown in <figref idref="DRAWINGS">FIG. 2</figref> is used to perform modular addition and/or modular subtraction and is utilized during the execution of Montgomery multiplication.</p>
<p id="p-0052" num="0055">The ALU <b>28</b> is of a fixed length, typically 16, 32, 64, etc. bits. To perform, for example, the addition of two values stored in the register file <b>26</b>, first the low-order blocks of the two values are added. The resulting block-carry is incorporated into the addition of the next-order blocks, which will result eventually in a possible block-carry emanating from the highest order blocks of the input. When implementing modular addition, the highest order block carry triggers a subtraction by the modulus n. Assuming the bit length of n is equal to the block length of the machine <b>22</b> (i.e., assuming n has the uppermost bit of the uppermost block equal to one), the automatic subtraction by the modulus n is sufficient to reduce the value of the addition modulo n. A similar situation occurs for modular subtraction, in which the highest order block borrow can is made to trigger an automatic addition of n. Therefore, it can be seen that if the bit length of n is not equal to the block length of the machine <b>22</b>, carries/borrows stemming from the uppermost block may not be reduced by the addition/subtraction of n, which may result in a value that is not sufficiently reduced (i.e., that is not less than the value n).</p>
<p id="p-0053" num="0056">During operation, the Montgomery machine <b>22</b> typically first goes through an initialization process in which values &#x3bc; and R<sup>2 </sup>mod n are computed, so that these values can be stored and subsequently used as precomputed values in performing Montgomery multiplication and in converting canonical values into Montgomery form. In order to compute p and R<sup>2 </sup>mod n, the Montgomery machine <b>22</b> first obtains the modulus n and Montgomery radix R (or an equivalent value such as r). For example, the modulus n may have been input by a user and transferred from memory of the cryptographic module <b>18</b> to the machine <b>22</b>. The Montgomery radix R may have also been input by a user, or instead generated by the Montgomery machine <b>22</b> as R=2<sup>r</sup>, where r is an integer generated such that R is the first convenient power of two greater than the modulus n.</p>
<p id="p-0054" num="0057">The value &#x3bc; is then computed by the machine <b>22</b> as &#x3bc;=(&#x2212;n)<sup>&#x2212;1 </sup>mod 2<sup>w</sup>, as described earlier. In an alternative embodiment, &#x3bc; can instead be provided to the machine <b>22</b>.</p>
<p id="p-0055" num="0058">Next, R<sup>2 </sup>mod n is computed. As explained earlier, the calculation of R<sup>2 </sup>mod n involves a series of modular addition and multiplication/squaring operations. Therefore, when R<sup>2 </sup>mod n is calculated via modular addition and multiplication/squaring operations, if the bit length of the modulus n is not equal to the block length of the machine <b>22</b>, then carries stemming from the uppermost block may not be sufficiently reduced by adding/subtracting the modulus n.</p>
<p id="p-0056" num="0059">It has been recognized that this problem can be obviated by generating and utilizing a new block-length modulus n&#x2032; to perform modular additions/subtractions, while still performing Montgomery multiplication/squaring using the original non-block-length modulus n for the multiplication/squaring operations.</p>
<p id="p-0057" num="0060">The new modulus n&#x2032; is generated by the cryptographic module <b>18</b> to have a bit length equal to the block length of the machine <b>22</b>, and can be obtained, for example, directly from modulus n. For example, block-length modulus n&#x2032; can be obtained by simply shifting (multiplying by 2) the modulus n until the most-significant bit of the most-significant block becomes a one. Alternatively, if n is odd, an odd modulus n&#x2032; can be obtained using n by performing the computation n&#x2032;=kn, where k is an odd integer and is chosen to yield a modulus n&#x2032; having a bit length equal to the block length, or instead by performing the calculation n&#x2032;=(2<sup>s</sup>+C)n, where C is a small odd integer (e.g. 1) and where s is an integer chosen to yield a modulus n&#x2032; having a bit length equal to the block length. In some embodiments, k and/or s can be generated randomly, in which case the variation in the resulting computations may be employed as a countermeasure against leakage of the operand values as they undergo computation in the machine <b>22</b>. It will be appreciated that n&#x2032; may be calculated once and then stored (for example in memory <b>30</b>) and retrieved whenever a modular addition/subtraction is required, or that instead n&#x2032; may be generated directly from n each time a single (or sequence of) modular addition/subtraction operations are required.</p>
<p id="p-0058" num="0061">With reference to <figref idref="DRAWINGS">FIG. 3</figref>, an embodiment of a method of calculating the value R<sup>2 </sup>mod n will now be described in which the modulus n has a bit length less than the block length of the block Montgomery machine <b>22</b>. In this embodiment, for the purposes of illustration, it is assumed that the block length of the machine <b>22</b> is 16 bits, and that the modulus is n=1549, which is 11 bits long (1549=11000001101<sub>2</sub>). It will be appreciated, of course, that this block length and modulus is chosen to simplify illustration. Typically, ECC operations will be calculated in the 100's of bits and RSA/DSA/DH operations will be calculated in the 1000's of bits.</p>
<p id="p-0059" num="0062">Turning therefore to step <b>302</b>, the cryptographic module <b>18</b> first operates upon the modulus n to obtain a block-length odd modulus n&#x2032; that has a length of 16 bits (the block length of the machine <b>22</b>). For example, in one embodiment, the modulus n is multiplied by k=37 to obtain n&#x2032;=37(1549)=57313=1101111111100001<sub>2</sub>, as shown in <figref idref="DRAWINGS">FIG. 4</figref>.</p>
<p id="p-0060" num="0063">Next, in step <b>304</b>, a value R is obtained by the cryptographic module <b>18</b> for use in the Montgomery operations. In this embodiment, the value R is computed as the first convenient power of two greater than the modulus n&#x2032;. Therefore, R=2<sup>r</sup>=2<sup>16</sup>. Note that this value of R still satisfies the criteria that R&#x3e;n&#x2032; and gcd(R,n&#x2032;)=1.</p>
<p id="p-0061" num="0064">The value R<sup>2 </sup>mod n is then calculated using a series of addition/multiplication steps in which modular addition is performed using the block-length modulus n&#x2032; and in which Montgomery multiplication is performed using the original modulus n. As described earlier, there are many different ways to obtain R<sup>2 </sup>mod n using a series of additions and multiplications. One such way is outlined in steps <b>306</b> to <b>312</b> below.</p>
<p id="p-0062" num="0065">In step <b>306</b>, the machine <b>22</b> first generates the two's complement of n&#x2032; by performing the computation R&#x2212;n&#x2032;=8223. Then, in step <b>308</b>, this value is added to itself using modular addition in the ALU <b>28</b> to obtain ((R&#x2212;n&#x2032;)+(R&#x2212;n&#x2032;))mod n&#x2032;=(2R)mod n&#x2032;=16446. Note that R&#x2212;n&#x2032; is used instead of R itself since R&#x2212;n&#x2032; has a bit length that does not exceed 16 bits (unlike R before reduction, which is 17 bits). Conveniently, since the block Montgomery machine <b>22</b> operates using the block-length modulus n&#x2032;, if there are carries stemming from the uppermost block when calculating (R&#x2212;n&#x2032;)+(R&#x2212;n&#x2032;), the value will be sufficiently reduced by the automatic subtraction of the modulus n&#x2032;.</p>
<p id="p-0063" num="0066">Next, in step <b>310</b> the cryptographic module <b>18</b> then retrieves the original modulus n and calculates the corresponding &#x3bc;=(&#x2212;n)<sup>&#x2212;1 </sup>mod 2<sup>w</sup>, or this may instead be provided as an initial input to the machine <b>22</b> by the cryptographic module <b>18</b>.</p>
<p id="p-0064" num="0067">Then, in step <b>312</b>, the value (2R)mod n&#x2032; from step <b>308</b> is multiplied by itself r=16 times using Montgomery multiplication with the original modulus n to obtain R<sup>2 </sup>mod n; i.e., <img id="CUSTOM-CHARACTER-00016" he="3.13mm" wi="14.48mm" file="US08626811-20140107-P00003.TIF" alt="custom character" img-content="character" img-format="tif"/>=R<sup>2 </sup>mod n=781 This is computed as follows:</p>
<p id="p-0065" num="0068">
<maths id="MATH-US-00001" num="00001">
<math overflow="scroll">
  <mrow>
    <mrow>
      <mrow>
        <mrow>
          <mo>(</mo>
          <mrow>
            <mn>2</mn>
            <mo>&#x2062;</mo>
            <msup>
              <mrow>
                <mi>R</mi>
                <mo>&#x2062;</mo>
                <mi>mod</mi>
                <mo>&#x2062;</mo>
                <mi>n</mi>
              </mrow>
              <mi>&#x2032;</mi>
            </msup>
          </mrow>
          <mo>)</mo>
        </mrow>
        <mo>&#x2297;</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <mn>2</mn>
            <mo>&#x2062;</mo>
            <msup>
              <mrow>
                <mi>R</mi>
                <mo>&#x2062;</mo>
                <mi>mod</mi>
                <mo>&#x2062;</mo>
                <mi>n</mi>
              </mrow>
              <mi>&#x2032;</mi>
            </msup>
          </mrow>
          <mo>)</mo>
        </mrow>
      </mrow>
      <mo>=</mo>
      <mrow>
        <mrow>
          <mrow>
            <mo>(</mo>
            <mrow>
              <mn>2</mn>
              <mo>&#x2062;</mo>
              <msup>
                <mrow>
                  <mi>R</mi>
                  <mo>&#x2062;</mo>
                  <mi>mod</mi>
                  <mo>&#x2062;</mo>
                  <mi>n</mi>
                </mrow>
                <mi>&#x2032;</mi>
              </msup>
            </mrow>
            <mo>)</mo>
          </mrow>
          <mo>&#x2062;</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <mn>2</mn>
              <mo>&#x2062;</mo>
              <msup>
                <mrow>
                  <mi>R</mi>
                  <mo>&#x2062;</mo>
                  <mi>mod</mi>
                  <mo>&#x2062;</mo>
                  <mi>n</mi>
                </mrow>
                <mi>&#x2032;</mi>
              </msup>
            </mrow>
            <mo>)</mo>
          </mrow>
          <mo>&#x2062;</mo>
          <mrow>
            <mo>(</mo>
            <msup>
              <mi>R</mi>
              <mrow>
                <mo>-</mo>
                <mn>1</mn>
              </mrow>
            </msup>
            <mo>)</mo>
          </mrow>
          <mo>&#x2062;</mo>
          <mi>mod</mi>
          <mo>&#x2062;</mo>
          <mstyle>
            <mspace width="0.3em" height="0.3ex"/>
          </mstyle>
          <mo>&#x2062;</mo>
          <mi>n</mi>
        </mrow>
        <mo>=</mo>
        <mrow>
          <mn>4</mn>
          <mo>&#x2062;</mo>
          <mrow>
            <mi>R</mi>
            <mo>&#x2062;</mo>
            <mi>mod</mi>
            <mo>&#x2062;</mo>
            <mi>n</mi>
          </mrow>
        </mrow>
      </mrow>
    </mrow>
    <mo>;</mo>
  </mrow>
</math>
</maths>
<maths id="MATH-US-00001-2" num="00001.2">
<math overflow="scroll">
  <mrow>
    <mrow>
      <mrow>
        <mrow>
          <mo>(</mo>
          <mrow>
            <mn>4</mn>
            <mo>&#x2062;</mo>
            <mrow>
              <mi>R</mi>
              <mo>&#x2062;</mo>
              <mi>mod</mi>
              <mo>&#x2062;</mo>
              <mi>n</mi>
            </mrow>
          </mrow>
          <mo>)</mo>
        </mrow>
        <mo>&#x2297;</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <mn>2</mn>
            <mo>&#x2062;</mo>
            <msup>
              <mrow>
                <mi>R</mi>
                <mo>&#x2062;</mo>
                <mi>mod</mi>
                <mo>&#x2062;</mo>
                <mi>n</mi>
              </mrow>
              <mi>&#x2032;</mi>
            </msup>
          </mrow>
          <mo>)</mo>
        </mrow>
      </mrow>
      <mo>=</mo>
      <mrow>
        <mrow>
          <mrow>
            <mo>(</mo>
            <mrow>
              <mn>4</mn>
              <mo>&#x2062;</mo>
              <mrow>
                <mi>R</mi>
                <mo>&#x2062;</mo>
                <mi>mod</mi>
                <mo>&#x2062;</mo>
                <mi>n</mi>
              </mrow>
            </mrow>
            <mo>)</mo>
          </mrow>
          <mo>&#x2062;</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <mn>2</mn>
              <mo>&#x2062;</mo>
              <msup>
                <mrow>
                  <mi>R</mi>
                  <mo>&#x2062;</mo>
                  <mi>mod</mi>
                  <mo>&#x2062;</mo>
                  <mi>n</mi>
                </mrow>
                <mi>&#x2032;</mi>
              </msup>
            </mrow>
            <mo>)</mo>
          </mrow>
          <mo>&#x2062;</mo>
          <mrow>
            <mo>(</mo>
            <msup>
              <mi>R</mi>
              <mrow>
                <mo>-</mo>
                <mn>1</mn>
              </mrow>
            </msup>
            <mo>)</mo>
          </mrow>
          <mo>&#x2062;</mo>
          <mrow>
            <mi>mod</mi>
            <mo>&#x2062;</mo>
            <mi>n</mi>
          </mrow>
        </mrow>
        <mo>=</mo>
        <mrow>
          <mn>8</mn>
          <mo>&#x2062;</mo>
          <mrow>
            <mi>R</mi>
            <mo>&#x2062;</mo>
            <mi>mod</mi>
            <mo>&#x2062;</mo>
            <mi>n</mi>
          </mrow>
        </mrow>
      </mrow>
    </mrow>
    <mo>;</mo>
  </mrow>
</math>
</maths>
<maths id="MATH-US-00001-3" num="00001.3">
<math overflow="scroll">
  <mrow>
    <mstyle>
      <mspace width="4.4em" height="4.4ex"/>
    </mstyle>
    <mo>&#x2062;</mo>
    <mrow>
      <mrow>
        <mrow>
          <mi>&#x2026;</mi>
          <mo>&#x2062;</mo>
          <mstyle>
            <mtext>
</mtext>
          </mstyle>
          <mo>(</mo>
          <mrow>
            <mrow>
              <mo>(</mo>
              <msup>
                <mn>2</mn>
                <mrow>
                  <mi>r</mi>
                  <mo>-</mo>
                  <mn>1</mn>
                </mrow>
              </msup>
              <mo>)</mo>
            </mrow>
            <mo>&#x2062;</mo>
            <mi>R</mi>
            <mo>&#x2062;</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>&#x2062;</mo>
            <mi>mod</mi>
            <mo>&#x2062;</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>&#x2062;</mo>
            <mi>n</mi>
          </mrow>
          <mo>)</mo>
        </mrow>
        <mo>&#x2297;</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <mn>2</mn>
            <mo>&#x2062;</mo>
            <mi>R</mi>
            <mo>&#x2062;</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>&#x2062;</mo>
            <mi>mod</mi>
            <mo>&#x2062;</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>&#x2062;</mo>
            <msup>
              <mi>n</mi>
              <mi>&#x2032;</mi>
            </msup>
          </mrow>
          <mo>)</mo>
        </mrow>
      </mrow>
      <mo>=</mo>
      <mrow>
        <mrow>
          <mrow>
            <mo>(</mo>
            <mrow>
              <mrow>
                <mo>(</mo>
                <msup>
                  <mn>2</mn>
                  <mrow>
                    <mi>r</mi>
                    <mo>-</mo>
                    <mn>1</mn>
                  </mrow>
                </msup>
                <mo>)</mo>
              </mrow>
              <mo>&#x2062;</mo>
              <mi>R</mi>
              <mo>&#x2062;</mo>
              <mstyle>
                <mspace width="0.3em" height="0.3ex"/>
              </mstyle>
              <mo>&#x2062;</mo>
              <mi>mod</mi>
              <mo>&#x2062;</mo>
              <mstyle>
                <mspace width="0.3em" height="0.3ex"/>
              </mstyle>
              <mo>&#x2062;</mo>
              <mi>n</mi>
            </mrow>
            <mo>)</mo>
          </mrow>
          <mo>&#x2062;</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <mn>2</mn>
              <mo>&#x2062;</mo>
              <mi>R</mi>
              <mo>&#x2062;</mo>
              <mstyle>
                <mspace width="0.3em" height="0.3ex"/>
              </mstyle>
              <mo>&#x2062;</mo>
              <mi>mod</mi>
              <mo>&#x2062;</mo>
              <mstyle>
                <mspace width="0.3em" height="0.3ex"/>
              </mstyle>
              <mo>&#x2062;</mo>
              <msup>
                <mi>n</mi>
                <mi>&#x2032;</mi>
              </msup>
            </mrow>
            <mo>)</mo>
          </mrow>
          <mo>&#x2062;</mo>
          <mrow>
            <mo>(</mo>
            <msup>
              <mi>R</mi>
              <mrow>
                <mo>-</mo>
                <mn>1</mn>
              </mrow>
            </msup>
            <mo>)</mo>
          </mrow>
          <mo>&#x2062;</mo>
          <mi>mod</mi>
          <mo>&#x2062;</mo>
          <mstyle>
            <mspace width="0.3em" height="0.3ex"/>
          </mstyle>
          <mo>&#x2062;</mo>
          <mi>n</mi>
        </mrow>
        <mo>=</mo>
        <mrow>
          <mrow>
            <mrow>
              <mi>R</mi>
              <mo>&#xb7;</mo>
              <mi>R</mi>
            </mrow>
            <mo>&#x2062;</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>&#x2062;</mo>
            <mi>mod</mi>
            <mo>&#x2062;</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>&#x2062;</mo>
            <mi>n</mi>
          </mrow>
          <mo>=</mo>
          <mrow>
            <msup>
              <mi>R</mi>
              <mn>2</mn>
            </msup>
            <mo>&#x2062;</mo>
            <mi>mod</mi>
            <mo>&#x2062;</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>&#x2062;</mo>
            <mrow>
              <mi>n</mi>
              <mo>.</mo>
            </mrow>
          </mrow>
        </mrow>
      </mrow>
    </mrow>
  </mrow>
</math>
</maths>
</p>
<p id="p-0066" num="0069">Finally, in step <b>314</b> the value R<sup>2 </sup>mod n=781 is stored in memory <b>30</b> for subsequent use in converting values to Montgomery form. The value R mod n may also be computed, if desired, by performing in the machine <b>22</b> the computation
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>R</i><sup>2 </sup>mod <i>n</i><img id="CUSTOM-CHARACTER-00017" he="3.13mm" wi="2.46mm" file="US08626811-20140107-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>1=(<i>R</i><sup>2 </sup>mod <i>n</i>)&#xb7;1<i>&#xb7;R</i><sup>&#x2212;1 </sup>mod <i>n=</i>478.<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0067" num="0070">In the embodiment shown in <figref idref="DRAWINGS">FIG. 3</figref>, it will be appreciated that the final reduction step in the Montgomery multiplication operations may be omitted, in which case the value R<sup>2 </sup>obtained at the end of step <b>312</b> will not be fully reduced (i.e. it will not be R<sup>2 </sup>mod n=781 per se), but will be congruent to R<sup>2 </sup>mod n=781 modulo n. If desired, further operations can be performed to reduce the magnitude of R<sup>2 </sup>mod n. For example, a given value of R<sup>2 </sup>can be replaced by (R<sup>2</sup><img id="CUSTOM-CHARACTER-00018" he="3.13mm" wi="2.46mm" file="US08626811-20140107-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>R<sup>2</sup>)<img id="CUSTOM-CHARACTER-00019" he="3.13mm" wi="2.46mm" file="US08626811-20140107-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>1, which is often smaller than R<sup>2 </sup>if R<sup>2 </sup>was not already minimal.</p>
<p id="p-0068" num="0071">It can therefore be seen from the method in <figref idref="DRAWINGS">FIG. 3</figref> that the block Montgomery machine <b>22</b> utilizes the block-length modulus n&#x2032; when performing modular addition operations, and the machine <b>22</b> utilizes the original modulus n when performing Montgomery multiplication operations. It has been recognized that the modulus n&#x2032;, which has a bit length equal to the block length of the machine <b>22</b>, can be used to ensure that carries stemming from the uppermost block during modular addition/subtraction are sufficiently reduced via the automatic single addition/subtraction of the modulus. However, it has also been recognized that due to the structure of the algorithm for performing Montgomery multiplication, the Montgomery multiplication does not require a modulus n&#x2032; having a bit length equal to the block length of the machine <b>22</b> to obtain a correct output, but instead can operate using the original modulus n.</p>
<p id="p-0069" num="0072">Turning now to <figref idref="DRAWINGS">FIG. 5</figref>, another embodiment of a method of calculating the value R<sup>2 </sup>mod n will be described in which the modulus n has a bit length less than a multiple of the block length of the block Montgomery machine <b>22</b>. In this embodiment, the block length of the block Montgomery machine <b>22</b> is 128 bits, and therefore the machine <b>22</b> is designed to operate with a modulus having a bit length that is a multiple of 128 bits. However, advantageously, the cryptographic module <b>18</b> uses this machine <b>22</b> to perform modular arithmetic operations using a modulus n that has a bit length of 521 bits, as described in the steps below.</p>
<p id="p-0070" num="0073">First in step <b>502</b>, the cryptographic module <b>18</b> operates on the modulus n to obtain a block-length modulus n&#x2032; that has a bit length equal to 640 bits, which is the first multiple of 128 greater than 521 (128&#xd7;5=640 bits). For example, in one embodiment, the modulus n has the value (in hexadecimal): n=0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c968899c47aebb6fb71e913864098.</p>
<p id="p-0071" num="0074">An odd random value k is generated having an appropriate value such that kn is 640 bits long. For example, in one embodiment, the value k=0x688a7fe8015bd7e31b0f2dec5f19bd is generated, and n&#x2032;=kn is computed to obtain n&#x2032;=0xd114ffd002b7afc6361e5bd8be33b5fffffffffffffffffffffffffffffffffffdae0bc2de2a1d46c7fc8e517744d9ab4c03377c33a67d8689beb5b52edae50e480e32sf21a47124c064a00f285974b3.</p>
<p id="p-0072" num="0075">Next, in step <b>504</b>, a value R is generated by the cryptographic module <b>18</b> for use in the Montgomery operations. The value R is computed as the first convenient power of two greater than the modulus n&#x2032;. Therefore, R=2<sup>r</sup>=2<sup>640</sup>.</p>
<p id="p-0073" num="0076">The value R<sup>2 </sup>mod n is then calculated using a series of addition/multiplication steps in which modular addition is performed using the block-length modulus n&#x2032; and in which Montgomery multiplication is performed using the original modulus n. As described earlier, there are many different ways to obtain R<sup>2 </sup>mod n using a series of additions and multiplications. Another such way is outlined in steps <b>506</b> to <b>512</b> below.</p>
<p id="p-0074" num="0077">First, in step <b>506</b>, the value s=2<sup>639 </sup>is added to itself modulo n&#x2032;, that is, (s+s)mod n&#x2032;=2<sup>640 </sup>mod n&#x2032;. Note that the value s is used since it has a bit length that does not exceed 640 bits (unlike R before reduction, which is 641 bits long). Conveniently, since the block Montgomery machine <b>22</b> operates using the block-length modulus n&#x2032;, if there are carries stemming from the uppermost block when calculating s+s, the value will be sufficiently reduced by the automatic subtraction of the modulus n&#x2032;.</p>
<p id="p-0075" num="0078">Next, in step <b>508</b>, the value 2<sup>640 </sup>mod n&#x2032; is added to itself 5 times using modular addition modulo n&#x2032; to obtain (2<sup>640 </sup>mod n&#x2032;+2<sup>640 </sup>mod n&#x2032;+2<sup>640 </sup>mod n&#x2032;+2<sup>640 </sup>mod n&#x2032;+2<sup>640 </sup>mod n&#x2032;+2<sup>640 </sup>mod n&#x2032;)mod n&#x2032;=2<sup>645 </sup>mod n&#x2032;. As with step <b>506</b>, since the block Montgomery machine <b>22</b> operates using the block-length modulus n&#x2032;, if there are carries stemming from the uppermost block when calculating this addition, the value will be sufficiently reduced by the automatic subtraction of the modulus n&#x2032;.</p>
<p id="p-0076" num="0079">Next, in step <b>510</b>, the cryptographic module <b>18</b> then retrieves the original modulus n. The machine <b>22</b> then calculates the corresponding &#x3bc;=(&#x2212;n)<sup>&#x2212;1 </sup>mod 2<sup>w</sup>, or this may instead be provided as an initial input to the machine <b>22</b> by the cryptographic module <b>18</b>.</p>
<p id="p-0077" num="0080">Then, in step <b>512</b>, the value 2<sup>645 </sup>mod n&#x2032; from step <b>508</b> is squared repeatedly using Montgomery multiplication until the value 2<sup>640+640 </sup>mod n=R<sup>2 </sup>mod n is obtained. Specifically, this is computed as follows:</p>
<p id="p-0078" num="0081">
<maths id="MATH-US-00002" num="00002">
<math overflow="scroll">
  <mrow>
    <mrow>
      <mrow>
        <mrow>
          <mo>(</mo>
          <mrow>
            <msup>
              <mn>2</mn>
              <mn>645</mn>
            </msup>
            <mo>&#x2062;</mo>
            <mi>mod</mi>
            <mo>&#x2062;</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>&#x2062;</mo>
            <msup>
              <mi>n</mi>
              <mi>&#x2032;</mi>
            </msup>
          </mrow>
          <mo>)</mo>
        </mrow>
        <mo>&#x2297;</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <msup>
              <mn>2</mn>
              <mn>645</mn>
            </msup>
            <mo>&#x2062;</mo>
            <mi>mod</mi>
            <mo>&#x2062;</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>&#x2062;</mo>
            <msup>
              <mi>n</mi>
              <mi>&#x2032;</mi>
            </msup>
          </mrow>
          <mo>)</mo>
        </mrow>
      </mrow>
      <mo>=</mo>
      <mrow>
        <mrow>
          <mrow>
            <mo>(</mo>
            <mrow>
              <msup>
                <mn>2</mn>
                <mn>645</mn>
              </msup>
              <mo>&#x2062;</mo>
              <mi>mod</mi>
              <mo>&#x2062;</mo>
              <mstyle>
                <mspace width="0.3em" height="0.3ex"/>
              </mstyle>
              <mo>&#x2062;</mo>
              <msup>
                <mi>n</mi>
                <mi>&#x2032;</mi>
              </msup>
            </mrow>
            <mo>)</mo>
          </mrow>
          <mo>&#x2062;</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <msup>
                <mn>2</mn>
                <mn>645</mn>
              </msup>
              <mo>&#x2062;</mo>
              <mi>mod</mi>
              <mo>&#x2062;</mo>
              <mstyle>
                <mspace width="0.3em" height="0.3ex"/>
              </mstyle>
              <mo>&#x2062;</mo>
              <msup>
                <mi>n</mi>
                <mi>&#x2032;</mi>
              </msup>
            </mrow>
            <mo>)</mo>
          </mrow>
          <mo>&#x2062;</mo>
          <msup>
            <mi>R</mi>
            <mrow>
              <mo>-</mo>
              <mn>1</mn>
            </mrow>
          </msup>
          <mo>&#x2062;</mo>
          <mi>mod</mi>
          <mo>&#x2062;</mo>
          <mstyle>
            <mspace width="0.3em" height="0.3ex"/>
          </mstyle>
          <mo>&#x2062;</mo>
          <mi>n</mi>
        </mrow>
        <mo>=</mo>
        <mrow>
          <msup>
            <mn>2</mn>
            <mrow>
              <mn>640</mn>
              <mo>+</mo>
              <mn>10</mn>
            </mrow>
          </msup>
          <mo>&#x2062;</mo>
          <mi>mod</mi>
          <mo>&#x2062;</mo>
          <mstyle>
            <mspace width="0.3em" height="0.3ex"/>
          </mstyle>
          <mo>&#x2062;</mo>
          <mi>n</mi>
        </mrow>
      </mrow>
    </mrow>
    <mo>;</mo>
  </mrow>
</math>
</maths>
<maths id="MATH-US-00002-2" num="00002.2">
<math overflow="scroll">
  <mrow>
    <mrow>
      <mrow>
        <mrow>
          <mo>(</mo>
          <mrow>
            <msup>
              <mn>2</mn>
              <mrow>
                <mn>640</mn>
                <mo>+</mo>
                <mn>10</mn>
              </mrow>
            </msup>
            <mo>&#x2062;</mo>
            <mi>mod</mi>
            <mo>&#x2062;</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>&#x2062;</mo>
            <mi>n</mi>
          </mrow>
          <mo>)</mo>
        </mrow>
        <mo>&#x2297;</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <msup>
              <mn>2</mn>
              <mrow>
                <mn>640</mn>
                <mo>+</mo>
                <mn>10</mn>
              </mrow>
            </msup>
            <mo>&#x2062;</mo>
            <mi>mod</mi>
            <mo>&#x2062;</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>&#x2062;</mo>
            <mi>n</mi>
          </mrow>
          <mo>)</mo>
        </mrow>
      </mrow>
      <mo>=</mo>
      <mrow>
        <mrow>
          <mrow>
            <mo>(</mo>
            <mrow>
              <msup>
                <mn>2</mn>
                <mrow>
                  <mn>640</mn>
                  <mo>+</mo>
                  <mn>10</mn>
                </mrow>
              </msup>
              <mo>&#x2062;</mo>
              <mi>mod</mi>
              <mo>&#x2062;</mo>
              <mstyle>
                <mspace width="0.3em" height="0.3ex"/>
              </mstyle>
              <mo>&#x2062;</mo>
              <mi>n</mi>
            </mrow>
            <mo>)</mo>
          </mrow>
          <mo>&#x2062;</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <msup>
                <mn>2</mn>
                <mrow>
                  <mn>640</mn>
                  <mo>+</mo>
                  <mn>10</mn>
                </mrow>
              </msup>
              <mo>&#x2062;</mo>
              <mi>mod</mi>
              <mo>&#x2062;</mo>
              <mstyle>
                <mspace width="0.3em" height="0.3ex"/>
              </mstyle>
              <mo>&#x2062;</mo>
              <mi>n</mi>
            </mrow>
            <mo>)</mo>
          </mrow>
          <mo>&#x2062;</mo>
          <msup>
            <mi>R</mi>
            <mrow>
              <mo>-</mo>
              <mn>1</mn>
            </mrow>
          </msup>
          <mo>&#x2062;</mo>
          <mi>mod</mi>
          <mo>&#x2062;</mo>
          <mstyle>
            <mspace width="0.3em" height="0.3ex"/>
          </mstyle>
          <mo>&#x2062;</mo>
          <mi>n</mi>
        </mrow>
        <mo>=</mo>
        <mrow>
          <msup>
            <mn>2</mn>
            <mrow>
              <mn>640</mn>
              <mo>+</mo>
              <mn>20</mn>
            </mrow>
          </msup>
          <mo>&#x2062;</mo>
          <mi>mod</mi>
          <mo>&#x2062;</mo>
          <mstyle>
            <mspace width="0.3em" height="0.3ex"/>
          </mstyle>
          <mo>&#x2062;</mo>
          <mi>n</mi>
        </mrow>
      </mrow>
    </mrow>
    <mo>;</mo>
  </mrow>
</math>
</maths>
<maths id="MATH-US-00002-3" num="00002.3">
<math overflow="scroll">
  <mrow>
    <mrow>
      <mrow>
        <mrow>
          <mo>(</mo>
          <mrow>
            <msup>
              <mn>2</mn>
              <mrow>
                <mn>640</mn>
                <mo>+</mo>
                <mn>20</mn>
              </mrow>
            </msup>
            <mo>&#x2062;</mo>
            <mi>mod</mi>
            <mo>&#x2062;</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>&#x2062;</mo>
            <mi>n</mi>
          </mrow>
          <mo>)</mo>
        </mrow>
        <mo>&#x2297;</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <msup>
              <mn>2</mn>
              <mrow>
                <mn>640</mn>
                <mo>+</mo>
                <mn>20</mn>
              </mrow>
            </msup>
            <mo>&#x2062;</mo>
            <mi>mod</mi>
            <mo>&#x2062;</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>&#x2062;</mo>
            <mi>n</mi>
          </mrow>
          <mo>)</mo>
        </mrow>
      </mrow>
      <mo>=</mo>
      <mrow>
        <mrow>
          <mrow>
            <mo>(</mo>
            <mrow>
              <msup>
                <mn>2</mn>
                <mrow>
                  <mn>640</mn>
                  <mo>+</mo>
                  <mn>20</mn>
                </mrow>
              </msup>
              <mo>&#x2062;</mo>
              <mi>mod</mi>
              <mo>&#x2062;</mo>
              <mstyle>
                <mspace width="0.3em" height="0.3ex"/>
              </mstyle>
              <mo>&#x2062;</mo>
              <mi>n</mi>
            </mrow>
            <mo>)</mo>
          </mrow>
          <mo>&#x2062;</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <msup>
                <mn>2</mn>
                <mrow>
                  <mn>640</mn>
                  <mo>+</mo>
                  <mn>20</mn>
                </mrow>
              </msup>
              <mo>&#x2062;</mo>
              <mi>mod</mi>
              <mo>&#x2062;</mo>
              <mstyle>
                <mspace width="0.3em" height="0.3ex"/>
              </mstyle>
              <mo>&#x2062;</mo>
              <mi>n</mi>
            </mrow>
            <mo>)</mo>
          </mrow>
          <mo>&#x2062;</mo>
          <msup>
            <mi>R</mi>
            <mrow>
              <mo>-</mo>
              <mn>1</mn>
            </mrow>
          </msup>
          <mo>&#x2062;</mo>
          <mi>mod</mi>
          <mo>&#x2062;</mo>
          <mstyle>
            <mspace width="0.3em" height="0.3ex"/>
          </mstyle>
          <mo>&#x2062;</mo>
          <mi>n</mi>
        </mrow>
        <mo>=</mo>
        <mrow>
          <msup>
            <mn>2</mn>
            <mrow>
              <mn>640</mn>
              <mo>+</mo>
              <mn>40</mn>
            </mrow>
          </msup>
          <mo>&#x2062;</mo>
          <mi>mod</mi>
          <mo>&#x2062;</mo>
          <mstyle>
            <mspace width="0.3em" height="0.3ex"/>
          </mstyle>
          <mo>&#x2062;</mo>
          <mi>n</mi>
        </mrow>
      </mrow>
    </mrow>
    <mo>;</mo>
  </mrow>
</math>
</maths>
<maths id="MATH-US-00002-4" num="00002.4">
<math overflow="scroll">
  <mrow>
    <mstyle>
      <mspace width="4.4em" height="4.4ex"/>
    </mstyle>
    <mo>&#x2062;</mo>
    <mrow>
      <mrow>
        <mrow>
          <mi>&#x2026;</mi>
          <mo>&#x2062;</mo>
          <mstyle>
            <mtext>
</mtext>
          </mstyle>
          <mo>(</mo>
          <mrow>
            <msup>
              <mn>2</mn>
              <mrow>
                <mn>640</mn>
                <mo>+</mo>
                <mn>320</mn>
              </mrow>
            </msup>
            <mo>&#x2062;</mo>
            <mi>mod</mi>
            <mo>&#x2062;</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>&#x2062;</mo>
            <mi>n</mi>
          </mrow>
          <mo>)</mo>
        </mrow>
        <mo>&#x2297;</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <msup>
              <mn>2</mn>
              <mrow>
                <mn>640</mn>
                <mo>+</mo>
                <mn>320</mn>
              </mrow>
            </msup>
            <mo>&#x2062;</mo>
            <mi>mod</mi>
            <mo>&#x2062;</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>&#x2062;</mo>
            <mi>n</mi>
          </mrow>
          <mo>)</mo>
        </mrow>
      </mrow>
      <mo>=</mo>
      <mrow>
        <mrow>
          <mrow>
            <mo>(</mo>
            <mrow>
              <msup>
                <mn>2</mn>
                <mrow>
                  <mn>640</mn>
                  <mo>+</mo>
                  <mn>320</mn>
                </mrow>
              </msup>
              <mo>&#x2062;</mo>
              <mi>mod</mi>
              <mo>&#x2062;</mo>
              <mstyle>
                <mspace width="0.3em" height="0.3ex"/>
              </mstyle>
              <mo>&#x2062;</mo>
              <mi>n</mi>
            </mrow>
            <mo>)</mo>
          </mrow>
          <mo>&#x2062;</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <msup>
                <mn>2</mn>
                <mrow>
                  <mn>640</mn>
                  <mo>+</mo>
                  <mn>320</mn>
                </mrow>
              </msup>
              <mo>&#x2062;</mo>
              <mi>mod</mi>
              <mo>&#x2062;</mo>
              <mstyle>
                <mspace width="0.3em" height="0.3ex"/>
              </mstyle>
              <mo>&#x2062;</mo>
              <mi>n</mi>
            </mrow>
            <mo>)</mo>
          </mrow>
          <mo>&#x2062;</mo>
          <msup>
            <mi>R</mi>
            <mrow>
              <mo>-</mo>
              <mn>1</mn>
            </mrow>
          </msup>
          <mo>&#x2062;</mo>
          <mi>mod</mi>
          <mo>&#x2062;</mo>
          <mstyle>
            <mspace width="0.3em" height="0.3ex"/>
          </mstyle>
          <mo>&#x2062;</mo>
          <mi>n</mi>
        </mrow>
        <mo>=</mo>
        <mrow>
          <mrow>
            <msup>
              <mn>2</mn>
              <mrow>
                <mn>640</mn>
                <mo>+</mo>
                <mn>640</mn>
              </mrow>
            </msup>
            <mo>&#x2062;</mo>
            <mi>mod</mi>
            <mo>&#x2062;</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>&#x2062;</mo>
            <mi>n</mi>
          </mrow>
          <mo>=</mo>
          <mrow>
            <msup>
              <mi>R</mi>
              <mn>2</mn>
            </msup>
            <mo>&#x2062;</mo>
            <mi>mod</mi>
            <mo>&#x2062;</mo>
            <mstyle>
              <mspace width="0.3em" height="0.3ex"/>
            </mstyle>
            <mo>&#x2062;</mo>
            <mrow>
              <mi>n</mi>
              <mo>.</mo>
            </mrow>
          </mrow>
        </mrow>
      </mrow>
    </mrow>
  </mrow>
</math>
</maths>
</p>
<p id="p-0079" num="0082">Finally, in step <b>514</b> the value R<sup>2 </sup>mod n is stored in memory <b>30</b> for subsequent use in converting values to Montgomery form.</p>
<p id="p-0080" num="0083">It will be appreciated that in the embodiment shown in <figref idref="DRAWINGS">FIG. 5</figref> the final reduction step in the Montgomery multiplication operations may be omitted, in which case the value R<sup>2 </sup>obtained at the end of step <b>512</b> will not be fully reduced (i.e. it will not be R<sup>2 </sup>mod n), but will be congruent to R<sup>2 </sup>mod n modulo n.</p>
<p id="p-0081" num="0084">As with the method of <figref idref="DRAWINGS">FIG. 3</figref>, in the method of <figref idref="DRAWINGS">FIG. 5</figref> the block Montgomery machine <b>22</b> utilizes the block-length modulus n&#x2032; when performing modular addition operations, and the machine <b>22</b> utilizes the original modulus n when performing modular Montgomery multiplication operations.</p>
<p id="p-0082" num="0085">The embodiments shown in <figref idref="DRAWINGS">FIGS. 3 and 5</figref> are specific examples in which the cryptographic module <b>18</b> obtains the value R<sup>2 </sup>mod n using a block Montgomery machine <b>22</b> having a block length that is not equal to (or a multiple of) the modulus n. R<sup>2 </sup>mod n can be computed using many variations of the modular addition and multiplication algorithms shown in <figref idref="DRAWINGS">FIGS. 3 and 5</figref>, all of which involve a series of modular addition and/or subtraction operations and a series of multiplication and/or squaring operations. It will be appreciated that the method embodied by <figref idref="DRAWINGS">FIGS. 3 and 5</figref> can be generalized to any such variation of computing R<sup>2 </sup>as follows: (1) generate a shifted modulus n&#x2032; having a bit length equal to the bit length of the block Montgomery machine <b>22</b> (or a multiple thereof); and (2) calculate R<sup>2 </sup>using the modulus n&#x2032; to perform each modular additive operation and the original modulus n to perform each Montgomery multiplicative operation. Advantageously, the methods described with reference to <figref idref="DRAWINGS">FIGS. 3 and 5</figref> involve first performing a series of additive operations using the block length modulus n&#x2032;, and then performing a series of multiplicative operations using the original modulus n, rather than switching back and forth between the two moduli. This is particularly advantageous if the machine <b>22</b> has only a single register for storing modulus values.</p>
<p id="p-0083" num="0086">The embodiments described above disclose methods for computing the value R<sup>2 </sup>using a block Montgomery machine <b>22</b> having a block length that is not equal to (or a multiple of) the bit length of the modulus n. Upon completion of the calculation of R<sup>2</sup>, the Montgomery machine <b>22</b> finishes its initialization process. &#x3bc;=(&#x2212;n)<sup>&#x2212;1 </sup>mod 2<sup>w </sup>and R<sup>2 </sup>have been computed and can now be used as precomputed values to perform subsequent operations in the Montgomery machine <b>22</b> and to convert values into their Montgomery form.</p>
<p id="p-0084" num="0087">Therefore, subsequently, the Montgomery machine <b>22</b> performs a series of arithmetic operations using the original non-block length modulus. Most or all of these operations will be multiplicative, and therefore using the non-block length modulus n does not pose a problem. However, some of these operations may be additive (e.g. when operating on points of an elliptic curve). Nevertheless, it is typically assumed that the values being added are small enough and that the number of consecutive additive operations between a multiplicative operation are few enough such that a carry will not be required. This cannot be assumed when calculating R<sup>2 </sup>due to the relatively large values of entities being added, but is often safe to assume when subsequently performing a series of arithmetic operations using the machine <b>22</b>. With such an assumption, it is therefore possible to perform arithmetic operations using the non-block length modulus n. The p and R<sup>2 </sup>values computed as described earlier are used as precomputed values by the machine <b>22</b> in performing such arithmetic operations.</p>
<p id="p-0085" num="0088">However, it may be the case that the machine <b>22</b> is required to perform a single additive operation, or perhaps a series of consecutive additive operations, and that it cannot be assumed that there will not be a carry. In this case, the additive operation(s) can be performed using the shifted modulus n&#x2032;. For example, an embodiment is shown in <figref idref="DRAWINGS">FIG. 6</figref> in which two values a and b are added modulo n.</p>
<p id="p-0086" num="0089">First, in step <b>602</b>, the Montgomery machine <b>22</b> utilizes the modulus n to convert the values a and b into their Montgomery form by performing the Montgomery multiplications &#xe2;=a<img id="CUSTOM-CHARACTER-00020" he="3.13mm" wi="2.46mm" file="US08626811-20140107-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>R<sup>2 </sup>mod n=a(R<sup>2 </sup>mod n mod n=aR mod n and {circumflex over (b)}=b<img id="CUSTOM-CHARACTER-00021" he="3.13mm" wi="2.46mm" file="US08626811-20140107-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>R<sup>2 </sup>mod n=b(R<sup>2 </sup>mod n mod n=bR mod n. The precomputed value R<sup>2 </sup>mod n required by the machine <b>22</b> for this computation is computed during initialization, for example, using the method of <figref idref="DRAWINGS">FIG. 3</figref> or <figref idref="DRAWINGS">FIG. 5</figref>.</p>
<p id="p-0087" num="0090">Assume a modular addition is required. Therefore, in step <b>604</b>, the block-length modulus n&#x2032; is retrieved from memory <b>30</b> or is calculated from n, for example, in the manner shown in step <b>302</b> of <figref idref="DRAWINGS">FIG. 3</figref> or step <b>502</b> <figref idref="DRAWINGS">FIG. 5</figref>.</p>
<p id="p-0088" num="0091">Next, in step <b>606</b>, the values &#xe2; and {circumflex over (b)} are added in the ALU <b>28</b> of the machine <b>22</b> modulo n&#x2032; to yield &#x109;=(&#xe2;+{circumflex over (b)})mod n&#x2032;. Conveniently, since the block Montgomery machine <b>22</b> operates using the modulus n&#x2032;, if there are carries stemming from the uppermost block when calculating &#xe2;+{circumflex over (b)}, the value will be sufficiently reduced by the automatic subtraction of the modulus n&#x2032;.</p>
<p id="p-0089" num="0092">Finally, in step <b>608</b>, the Montgomery machine <b>22</b> retrieves the modulus n, and the value &#x109; is converted from Montgomery form to canonical form by computing the Montgomery multiplication:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>&#x109;</i><img id="CUSTOM-CHARACTER-00022" he="3.13mm" wi="2.46mm" file="US08626811-20140107-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>1=((<i>&#xe2;+{circumflex over (b)}</i>)mod <i>n</i>&#x2032;)<i>R</i><sup>&#x2212;1 </sup>mod <i>n</i>=((<i>a+b</i>)<i>R </i>mod <i>n</i>&#x2032;)<i>R</i><sup>&#x2212;1 </sup>mod <i>n</i>=(<i>a+b</i>)mod <i>n=c. </i><?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0090" num="0093">It will be appreciated that in the Montgomery multiplication steps described above, the final reduction step may be omitted, in which case the values may not be fully reduced, but will be congruent to the fully reduced value modulo n.</p>
<p id="p-0091" num="0094">In the embodiments described above, the values &#x3bc; and R<sup>2 </sup>are first calculated and then used as precomputed values in a series of arithmetic operations in the Montgomery machine <b>22</b>. The value R<sup>2 </sup>is either fully reduced mod n or are congruent to the fully reduced value modulo n.</p>
<p id="p-0092" num="0095"><figref idref="DRAWINGS">FIG. 7</figref> discloses an alternative embodiment in which all arithmetic operations (both additive and multiplicative) are performed using the shifted modulus n&#x2032;. Whilst such a method may be disadvantageous in the sense that it is unnecessary to perform multiplicative operations using the shifted modulus n&#x2032;, such a method is beneficial in that it allows a series of arithmetic operations to be performed that accommodates the need for occasional reductions of either a carry or borrow from the upper block without switching between modulus n and shifted modulus n&#x2032;.</p>
<p id="p-0093" num="0096">First in step <b>702</b>, the block-length modulus n&#x2032; is retrieved from memory <b>30</b> or is calculated from n, for example, in the manner shown in step <b>302</b> of <figref idref="DRAWINGS">FIG. 3</figref> or step <b>502</b> <figref idref="DRAWINGS">FIG. 5</figref>. For example, in one embodiment, the modulus n&#x2032; is calculated by generating a number k and calculating n&#x2032;=(2<sup>k</sup>+1)n, where k is generated such that the bit length of n&#x2032; is equal to the block length of the machine <b>22</b> (or a multiple thereof).</p>
<p id="p-0094" num="0097">Next, in step <b>704</b>, the block Montgomery machine <b>22</b> computes the value &#x3bc;&#x2032;=(&#x2212;n&#x2032;)<sup>&#x2212;1 </sup>mod 2<sup>w</sup>. Alternatively, this may instead be provided as an initial input to the machine <b>22</b> by the cryptographic module <b>18</b>.</p>
<p id="p-0095" num="0098">Then, in step <b>706</b>, R=2<sup>r </sup>is obtained where r is the bit length of n&#x2032;, and cryptographic module <b>18</b> computes the value R<sup>2 </sup>mod n&#x2032; (or a value congruent to R<sup>2 </sup>mod n&#x2032; modulo n&#x2032;). This is different from the embodiments described with reference to <figref idref="DRAWINGS">FIGS. 3 and 5</figref>, which compute R<sup>2 </sup>mod n (or a value congruent to R<sup>2 </sup>mod n modulo n). Specifically, to compute R<sup>2 </sup>mod n&#x2032;, an add and multiply/square algorithm is applied, as is known in the art, but all operations in the Montgomery machine <b>22</b> (i.e. both the additive operations and the Montgomery multiplicative operations) are performed modulo n&#x2032;.</p>
<p id="p-0096" num="0099">Next, in step <b>708</b>, the sequence of modular arithmetic operations are performed using the Montgomery machine <b>22</b>. All operations are performed modulo n&#x2032;, The canonical values are converted into Montgomery form using R<sup>2 </sup>mod n&#x2032; and intermediate results are stored in Montgomery faun in register file <b>26</b> as necessary. The precomputed value &#x3bc;&#x2032; is used by the machine <b>22</b> to perform the multiplicative operations. All operations in the sequence will be reduced modulo n&#x2032;, regardless of whether the operations are additive operations or multiplicative operations. If there are carries stemming from the uppermost block during any calculations, the value will be sufficiently reduced by the automatic addition or subtraction of the modulus n&#x2032;.</p>
<p id="p-0097" num="0100">Once the sequence of modular operations are complete, in step <b>710</b>, the result, {circumflex over (d)}, is stored (for example in register file <b>26</b>) and the Montgomery machine <b>22</b> retrieves the original non-block-length modulus n. The corresponding &#x3bc; is also calculated by (or provided to) the machine <b>22</b>.</p>
<p id="p-0098" num="0101">Finally, in step <b>712</b>, the result, {circumflex over (d)}, is converted from Montgomery form to canonical form by computing the Montgomery multiplication:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>{circumflex over (d)}</i><img id="CUSTOM-CHARACTER-00023" he="3.13mm" wi="2.46mm" file="US08626811-20140107-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/>1<i>=dR</i><sup>&#x2212;1 </sup>mod <i>n</i>=(<i>dR </i>mod <i>n</i>&#x2032;)<i>R</i><sup>&#x2212;1 </sup>mod <i>n=d </i>mod <i>n. </i><?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0099" num="0102">In view of the specific embodiments described with reference to <figref idref="DRAWINGS">FIGS. 1 to 7</figref>, <figref idref="DRAWINGS">FIG. 8</figref> discloses generally a method for performing modular operations using a modulus n. The method is performed by a Montgomery machine having a fixed block length. The modulus n has a block length different from the fixed block length of the Montgomery machine or a multiple thereof. The method includes the following operations. First, in step <b>802</b>, the Montgomery machine obtains a new modulus n&#x2032; having a block length equal to the fixed block length of the Montgomery machine or a multiple thereof. For example, the new modulus n&#x2032; can be obtained by operating on the modulus n to derive the new modulus n&#x2032;. Next, in step <b>804</b>, the Montgomery machine performs at least one modular additive operation with the new modulus n&#x2032;. In this way, a carry stemming from the additive operation results in the reduction of the result of the additive operation by n&#x2032;. Then, in step <b>806</b>, the Montgomery machine performs at least one modular multiplicative operation with the modulus n.</p>
<p id="p-0100" num="0103">As an example, the additive and multiplicative operations performed in <figref idref="DRAWINGS">FIG. 8</figref> can be used to compute R<sup>2 </sup>mod n (or a value congruent to R<sup>2 </sup>mod n modulo n). As another example, a result of the modular operations can be stored in memory (e.g. in memory <b>20</b> or <b>30</b>) for subsequent retrieval by the Montgomery machine.</p>
<p id="p-0101" num="0104">Although the above techniques have been described with reference to certain specific embodiments, various modifications thereof will be apparent to those skilled in the art without departing from the spirit and scope of the claims appended hereto.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-math idrefs="MATH-US-00001 MATH-US-00001-2 MATH-US-00001-3" nb-file="US08626811-20140107-M00001.NB">
<img id="EMI-M00001" he="18.03mm" wi="76.20mm" file="US08626811-20140107-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00002 MATH-US-00002-2 MATH-US-00002-3 MATH-US-00002-4" nb-file="US08626811-20140107-M00002.NB">
<img id="EMI-M00002" he="32.09mm" wi="76.20mm" file="US08626811-20140107-M00002.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-claim-statement>The invention claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for performing modular operations using a modulus n in a cryptographic system, the method being performed by a computing device including a Montgomery machine having a fixed block length; the modulus n having a block length different from the fixed block length of the Montgomery machine or a multiple thereof; the method comprising:
<claim-text>the Montgomery machine obtaining a new modulus n&#x2032; having a block length equal to the fixed block length of the Montgomery machine or a multiple thereof;</claim-text>
<claim-text>the Montgomery machine obtaining a value representative of a Montgomery radix R;</claim-text>
<claim-text>the Montgomery machine performing at least one modular additive operation with the new modulus n&#x2032;, whereby a carry stemming from the at least one modular additive operation results in reduction of a result of the at least one modular additive operation by n&#x2032;;</claim-text>
<claim-text>the Montgomery machine obtaining a value &#x3bc;&#x2032; of the form &#x3bc;&#x2032;=(&#x2212;n&#x2032;)<sup>&#x2212;1 </sup>mod 2<sup>w</sup>, wherein w is an integer;</claim-text>
<claim-text>the Montgomery machine performing at least one modular multiplicative operation with the modulus n to convert a result of the modular operations out of Montgomery form; and</claim-text>
<claim-text>the Montgomery machine storing the result of the modular operations in memory for subsequent retrieval by the Montgomery machine: and</claim-text>
<claim-text>wherein the at least one modular multiplicative operation utilizes the value &#x3bc;&#x2032;, and wherein the at least one modular additive operation is used in computing R<sup>2 </sup>mod n&#x2032; or a value congruent to R<sup>2 </sup>mod n&#x2032;, and wherein the result of the modular operations is used to implement one or more cryptographic protocols in the cryptographic system.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein said obtaining a new modulus n&#x2032; comprises the Montgomery machine operating on the modulus n to derive the new modulus n&#x2032;.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref> wherein said operating on the modulus n to derive the new modulus n&#x2032; comprises the Montgomery machine shifting the modulus n until a most-significant bit of a most-significant block of the modulus n is equal to one.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref> wherein the new modulus n&#x2032; is of the form n&#x2032;=kn, wherein k is an odd integer.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref> wherein k is randomly generated by the Montgomery machine.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref> wherein the new modulus n&#x2032; is of the form n&#x2032;=(2<sup>x</sup>+C) n, wherein s and C are integers.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref> wherein C=1.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref> wherein s is randomly generated by the Montgomery machine.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. A device including a memory and a Montgomery machine in a cryptographic system, the Montgomery machine having a fixed block length and used for performing modular operations using a modulus n, the modulus n having a block length different from the fixed block length of the Montgomery machine or a multiple thereof; the device configured to perform operations comprising:
<claim-text>the Montgomery machine obtaining a new modulus n&#x2032; having a block length equal to the fixed block length of the Montgomery machine or a multiple thereof;</claim-text>
<claim-text>the Montgomery machine obtaining a value representative of a Montgomery radix R;</claim-text>
<claim-text>the Montgomery machine performing at least one modular additive operation with the new modulus n&#x2032;, whereby a carry stemming from the at least one modular additive operation results in reduction of a result of the at least one modular additive operation by n&#x2032;;</claim-text>
<claim-text>the Montgomery machine obtaining a value &#x3bc;&#x2032; of the form &#x3bc;&#x2032;=(&#x2212;n&#x2032;)<sup>&#x2212;1 </sup>mod 2<sup>w</sup>, wherein w is an integer;</claim-text>
<claim-text>the Montgomery machine performing at least one modular multiplicative operation with the modulus n to convert a result of the modular operations out of Montgomery form; and</claim-text>
<claim-text>the Montgomery machine storing the result of the modular operations in memory for subsequent retrieval by the Montgomery machine; and</claim-text>
<claim-text>wherein the at least one modular multiplicative operation utilizes the value &#x3bc;&#x2032;, and wherein the at least one modular additive operation is used in computing R<sup>2 </sup>mod n&#x2032; or a value congruent to R<sup>2 </sup>mod n&#x2032;, and wherein the result of the modular operations is used to implement one or more cryptographic protocols in the cryptographic system.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The device of <claim-ref idref="CLM-00009">claim 9</claim-ref> wherein said obtaining a new modulus n&#x2032; comprises the Montgomery machine operating on the modulus n to derive the new modulus n&#x2032;.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The device of <claim-ref idref="CLM-00010">claim 10</claim-ref> wherein said operating on the modulus n to derive the new modulus n&#x2032; comprises the Montgomery machine shifting the modulus n until a most-significant bit of a most-significant block of the modulus n is equal to one.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The device of <claim-ref idref="CLM-00010">claim 10</claim-ref> wherein the new modulus n&#x2032; is of the form n&#x2032;=kn, wherein k is an odd integer.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The device of <claim-ref idref="CLM-00012">claim 12</claim-ref> wherein k is randomly generated by the Montgomery machine.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The device of <claim-ref idref="CLM-00010">claim 10</claim-ref> wherein the new modulus n&#x2032; is of the form n&#x2032;=(2<sup>s</sup>+C)n, wherein s and C are integers.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The device of <claim-ref idref="CLM-00014">claim 14</claim-ref> wherein C=1.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. A non-transitory computer readable medium having stored thereon computer readable instructions for performing modular operations using a modulus n, the modular operations being performed by a Montgomery machine in a cryptographic system having a fixed block length; the modulus n having a block length different from the fixed block length of the Montgomery machine or a multiple thereof; the computer readable instructions comprising instructions for:
<claim-text>obtaining a new modulus n&#x2032; having a block length equal to the fixed block length of the Montgomery machine or a multiple thereof;</claim-text>
<claim-text>the Montgomery machine obtaining a value representative of a Montgomery radix R;</claim-text>
<claim-text>performing at least one modular additive operation with the new modulus n&#x2032;, whereby a carry stemming from the at least one modular additive operation results in reduction of a result of the at least one modular additive operation by n&#x2032;;</claim-text>
<claim-text>the Montgomery machine obtaining a value &#x3bc;&#x2032; of the form &#x3bc;&#x2032;=(&#x2212;n&#x2032;)<sup>&#x2212;1 </sup>mod 2<sup>w</sup>, wherein w is an integer;</claim-text>
<claim-text>performing at least one modular multiplicative operation with the modulus n to convert a result of the modular operations out of Montgomery form; and</claim-text>
<claim-text>storing the result of the modular operations in memory for subsequent retrieval by the Montgomery machine: and</claim-text>
<claim-text>wherein the at least one modular multiplicative operation utilizes the value &#x3bc;&#x2032;, and wherein the at least one modular additive operation is used in computing R<sup>2 </sup>mod n&#x2032; or a value congruent to R<sup>2 </sup>mod n&#x2032;, and wherein the result of the modular operations is used to implement one or more cryptographic protocols in the cryptographic system.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The non-transitory computer readable medium of <claim-ref idref="CLM-00016">claim 16</claim-ref> wherein said obtaining a new modulus n&#x2032; comprises operating on the modulus n to derive the new modulus n&#x2032;.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The non-transitory computer readable medium of <claim-ref idref="CLM-00017">claim 17</claim-ref> wherein the new modulus n&#x2032; is of the form n&#x2032;=kn, wherein k is an odd integer.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The non-transitory computer readable medium of <claim-ref idref="CLM-00018">claim 18</claim-ref> wherein k is randomly generated by the Montgomery machine.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The non-transitory computer readable medium of <claim-ref idref="CLM-00017">claim 17</claim-ref> wherein the new modulus n&#x2032; is of the form n&#x2032;=(2<sup>s</sup>+C)n, wherein s and C are integers.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The non-transitory computer readable medium of <claim-ref idref="CLM-00020">claim 20</claim-ref> wherein C=1. </claim-text>
</claim>
</claims>
</us-patent-grant>
