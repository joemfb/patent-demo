<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08626781-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08626781</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12980582</doc-number>
<date>20101229</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>245</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>7</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>707758</main-classification>
<further-classification>707765</further-classification>
<further-classification>707769</further-classification>
<further-classification>711100</further-classification>
<further-classification>711108</further-classification>
</classification-national>
<invention-title id="d2e53">Priority hash index</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>8239584</doc-number>
<kind>B1</kind>
<name>Rabe et al.</name>
<date>20120800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711170</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>2005/0071571</doc-number>
<kind>A1</kind>
<name>Luick</name>
<date>20050300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711137</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>2006/0018551</doc-number>
<kind>A1</kind>
<name>Patterson</name>
<date>20060100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>382229</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2008/0052436</doc-number>
<kind>A1</kind>
<name>Sharma et al.</name>
<date>20080200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710301</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>2008/0065639</doc-number>
<kind>A1</kind>
<name>Choudhary</name>
<date>20080300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2008/0243941</doc-number>
<kind>A1</kind>
<name>Beyer</name>
<date>20081000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2009/0049086</doc-number>
<kind>A1</kind>
<name>Hsu et al.</name>
<date>20090200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707103 R</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2009/0187546</doc-number>
<kind>A1</kind>
<name>Hamilton Whyte</name>
<date>20090700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  3</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2010/0098318</doc-number>
<kind>A1</kind>
<name>Anderson</name>
<date>20100400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2010/0199036</doc-number>
<kind>A1</kind>
<name>Siewert et al.</name>
<date>20100800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711112</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2011/0196855</doc-number>
<kind>A1</kind>
<name>Wable et al.</name>
<date>20110800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707711</main-classification></classification-national>
</us-citation>
<us-citation>
<nplcit num="00012">
<othercit>Qwertie, CPTrie: A Sorted Data Structure for .NET&#x2014;Published Date: Mar. 31, 2010 http://www.codeproject.com/KB/recipes/cptrie.aspx.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00013">
<othercit>Askitis, Nikolas, et al., HAT-Trie: A Cache-Conscious Trie-Based Data Structure for Strings&#x2014;Published Date: 2007 http://crpit.com/confpapers/CRPITV62Askitis.pdf.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00014">
<othercit>Woo, Dong Hyuk, et al., Reducing Energy of Virtual Cache Synonym Lookup using Bloom Filters&#x2014;Published Date: 2006 http://www.cecs.uci.edu/&#x2dc;papers/esweek06/cases/p179.pdf.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00015">
<othercit>Chu, Yuan-Sun, et al., ASIC Design of Fast IP Lookup for Next Generation IP Router&#x2014;Published Date: 2005 http://eeweb.poly.edu/labs/hsnl/docs/private/security/01465464.pdf.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00016">
<othercit>Fitzpatrick, Brad, Distributed Caching with MemCached&#x2014;Published Date: Aug. 1, 2004 http://www.linuxjournal.com/article/7451.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00017">
<othercit>Acharya, Anurag, et al., Adaptive Algorithms for Cache-Efficient Trie Search&#x2014;Published Date: Jul. 7, 1998 http://game.cs.ucsb.edu/research/tech<sub>&#x2014;</sub>reports/reports/1998-19.ps.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00018">
<othercit>Debnath, Biplob, et al., ChunkStash: Speeding Up Inline Storage Deduplication Using Flash Memory&#x2014;Retrieved Date: Aug. 13, 2010 http://research.microsoft.com/pubs/132038/paper.pdf.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>10</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>707711</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707758</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707765</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707769</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711100</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711108</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>5</number-of-drawing-sheets>
<number-of-figures>4</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20120173510</doc-number>
<kind>A1</kind>
<date>20120705</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Risvik</last-name>
<first-name>Knut Magne</first-name>
<address>
<city>Mo I Rana</city>
<country>NO</country>
</address>
</addressbook>
<residence>
<country>NO</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Hopcroft</last-name>
<first-name>Michael</first-name>
<address>
<city>Kirkland</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Bennett</last-name>
<first-name>John G.</first-name>
<address>
<city>Bellevue</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="004" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Kalyanaraman</last-name>
<first-name>Karthik</first-name>
<address>
<city>Bellevue</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="005" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Chilimbi</last-name>
<first-name>Trishul</first-name>
<address>
<city>Seattle</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="006" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Shen</last-name>
<first-name>Hui</first-name>
<address>
<city>Beijing</city>
<country>CN</country>
</address>
</addressbook>
<residence>
<country>CN</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Risvik</last-name>
<first-name>Knut Magne</first-name>
<address>
<city>Mo I Rana</city>
<country>NO</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Hopcroft</last-name>
<first-name>Michael</first-name>
<address>
<city>Kirkland</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Bennett</last-name>
<first-name>John G.</first-name>
<address>
<city>Bellevue</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="004" designation="us-only">
<addressbook>
<last-name>Kalyanaraman</last-name>
<first-name>Karthik</first-name>
<address>
<city>Bellevue</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="005" designation="us-only">
<addressbook>
<last-name>Chilimbi</last-name>
<first-name>Trishul</first-name>
<address>
<city>Seattle</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="006" designation="us-only">
<addressbook>
<last-name>Shen</last-name>
<first-name>Hui</first-name>
<address>
<city>Beijing</city>
<country>CN</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Shook Hardy &#x26; Bacon LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Microsoft Corporation</orgname>
<role>02</role>
<address>
<city>Redmond</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Alam</last-name>
<first-name>Hosain</first-name>
<department>2166</department>
</primary-examiner>
<assistant-examiner>
<last-name>Tang</last-name>
<first-name>Jieying</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A priority hash index provides efficient lookup of posting lists for search query terms. The priority hash index is a data structure in which hash values for terms are distributed across multiple storage devices based on importance of the terms and access speeds of the storage devices. Terms are grouped into search lists with each search list including a storage location on each storage device. When a search query is received, a term is identified and hashed to a location on the first storage device and to generate a unique hash value for the term. The locations on the storage device for the term's search list are sequentially read until the hash value for the term is located to access the posting list for the term.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="165.86mm" wi="215.90mm" file="US08626781-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="205.06mm" wi="171.70mm" file="US08626781-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="237.07mm" wi="188.04mm" orientation="landscape" file="US08626781-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="242.49mm" wi="125.31mm" orientation="landscape" file="US08626781-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="270.43mm" wi="166.20mm" file="US08626781-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="273.05mm" wi="184.66mm" file="US08626781-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND</heading>
<p id="p-0002" num="0001">The amount of information and content available on the Internet continues to grow rapidly. Given the vast amount of information, search engines have been developed to facilitate searching for electronic documents. In particular, users may search for information and documents by entering search queries comprising one or more terms that may be of interest to the user. After receiving a search query from a user, a search engine identifies documents and/or web pages that are relevant based on the search query. Because of its utility, web searching, that is, the process of finding relevant web pages and documents for user issued search queries has arguably become the most popular service on the Internet today.</p>
<p id="p-0003" num="0002">Search engines operate by crawling documents and indexing information regarding the documents in a search index. Search indexes are often comprised of posting lists for the various terms found in the crawled documents. Each posting list identifies the documents in which a particular term was found. When a search query is received, the search engine employs the search index to identify documents relevant to the search query. Use of a search index in this manner allows for fast retrieval of information for queries. Without a search index, a search engine would need to search the corpus of documents to find relevant results, which would take an unacceptable amount of time.</p>
<p id="p-0004" num="0003">When performing searches, search engines typically employ various mechanisms to provide fast lookup of search query terms in order to locate and retrieve posting lists. Tree-based structures and in-memory hash tables are examples of common methods used for this purpose. However, these existing mechanisms are not truly efficient when scaling up to very large numbers of indexed objects, and the lookup performance may not be sufficient.</p>
<heading id="h-0002" level="1">SUMMARY</heading>
<p id="p-0005" num="0004">This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used as an aid in determining the scope of the claimed subject matter.</p>
<p id="p-0006" num="0005">Embodiments of the present invention relate to a priority hash index that provides efficient lookup of posting lists for search query terms. The priority hash index is a data structure in which hash values for terms are distributed across a hierarchy of storage devices of varying access speed based on term importance from fastest storage to slowest storage. Some storage devices include entries that each includes a hash value with an address of a posting list. In some instances, posting lists are stored inline if the posting lists are small enough. Additionally, if a storage device in the hierarchy has significant input/output latency (e.g., a hard disk drive) such that accessing the device multiple times would significantly affect performance, the posting lists may be stored inline on the storage device. For instance, in some embodiments, storage devices higher in the hierarchy may store entries that each includes a hash value with an address of a posting list, while a final storage device may store posting lists inline with hash values. Terms are grouped into search lists with each search list including a location on each storage device for storing hash values for terms in the search list. When a search query is received, a term is identified and hashed to select a location at a first device and to generate a hash value that is unique to the term. The locations of the storage devices for the search list for the term are sequentially read to locate an entry matching the hash value and to access a posting list for the term.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0007" num="0006">The present invention is described in detail below with reference to the attached drawing figures, wherein:</p>
<p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram of an exemplary computing environment suitable for use in implementing embodiments of the present invention;</p>
<p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. 2</figref> is a diagram illustrating a priority hash index for a search index in accordance with an embodiment of the present invention;</p>
<p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. 3</figref> is a block diagram of an exemplary system in which embodiments of the present invention may be employed; and</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 4</figref> is a flow diagram showing a method for accessing data in a search index using a priority hash index in accordance with an embodiment of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0012" num="0011">The subject matter of the present invention is described with specificity herein to meet statutory requirements. However, the description itself is not intended to limit the scope of this patent. Rather, the inventors have contemplated that the claimed subject matter might also be embodied in other ways, to include different steps or combinations of steps similar to the ones described in this document, in conjunction with other present or future technologies. Moreover, although the terms &#x201c;step&#x201d; and/or &#x201c;block&#x201d; may be used herein to connote different elements of methods employed, the terms should not be interpreted as implying any particular order among or between various steps herein disclosed unless and except when the order of individual steps is explicitly described.</p>
<p id="p-0013" num="0012">Embodiments of the present invention relate to a priority hash index that is a data structure that resides on several layers of storage devices to provide for efficient lookup of posting lists for terms in a search index. It should be noted that &#x201c;term&#x201d; is used broadly herein to refer to a single word or multiple words (e.g., phrases, n-grams, n-tuples, etc.) found in documents indexed by the search index.</p>
<p id="p-0014" num="0013">The priority hash index is structured around providing &#x201c;search lists&#x201d; for groups of terms indexed by the search system index. Conceptually, a search list is a list structure that is distributed across storage locations on each of the storage devices. The terms in each search list are hashed to unique numbers from which two hash values are derived. The first hash value for all terms in a search list select the same location on a first storage device, which serves as the starting point into the search list. The second hash values disambiguate the various terms in a search list and are stored in the different storage devices based on term importance (highest to lowest) from the fastest storage device to slowest storage device. Term importance may be based on factors such as the length of the posting list associated with the term or access statistics.</p>
<p id="p-0015" num="0014">In some embodiments of the present invention, higher levels of storage devices (i.e., faster storage devices) store data entries that each generally includes a hash value for a term and an address of a posting list for the term. In some instances, if a posting list is short, the posting list may be stored inline with the hash value. In contrast, lower levels (or the lowest level) of storage (i.e., the slowest storage device(s)) include data entries that each generally includes a hash value for a term with the posting list for the term stored inline. In particular, if a storage device in the hierarchy has significant input/output latency (e.g., a hard disk drive) such that accessing the device multiple times would significantly affect performance, the posting lists may be stored inline on that storage device.</p>
<p id="p-0016" num="0015">In operation, when a search query is received, a term is identified and hashed to derive two hash values. The first hash value selects a storage location in a first storage device. The storage location is read to determine whether it contains a data entry for the second hash value. If a data entry that includes the second hash value is found at the storage location, an address of the posting list for the term is retrieved from the data entry and used to access the posting list. For instance, the first storage device may be RAM while the posting list is stored in a hard disk drive. As such, the address stored on RAM corresponds with the location on the hard disk drive storing the posting list for the term.</p>
<p id="p-0017" num="0016">If the storage location on the first storage device does not contain the second hash value, the process continues by retrieving an address of a storage location on the next storage device in the hierarchy of storage devices. The storage location on the next storage device contains the continuation of the search list. The process may continue by sequentially reading storage locations on storage devices in the hierarchy until the second hash value is located. If the second hash value is found at a storage location on the last storage device, the posting list is stored inline with the second hash value. As such, only one access the last storage device (i.e., the slowest storage device) would be required to access the posting list.</p>
<p id="p-0018" num="0017">Accordingly, in one aspect, an embodiment of the present invention is directed to a system for storing a priority hash index for a search engine. The system includes a first data storage device of a first type. The first data storage device has a plurality of storage locations, wherein a first storage location on the first data storage device stores a plurality of data entries each containing a hash value corresponding with a term and an address locating a posting list for the term. The first storage location also stores an address of a second storage location on a second data storage device. The second data storage device is of a second type and has a plurality of storage locations, wherein the second storage location on the second data storage device stores a plurality of data entries each containing a hash value corresponding with a term and an address locating a posting list for the term. The second storage location also stores an address of a third storage location within a third data storage device. The third data storage device is of a third type and has a plurality of storage locations, wherein the third storage location on the third data storage device stores a plurality of data entries each containing a hash value corresponding with a term and a posting list for the term.</p>
<p id="p-0019" num="0018">In another embodiment, an aspect of the invention is directed a method for accessing data from a search index. The method includes receiving a hash value corresponding with a search term from a search query. The method also include identifying a first storage location on a first storage device and determining if the hash value is stored at the first storage location. If the hash value is stored at the first storage location, the method includes retrieving an address of a posting list from the first storage location and using that address to access the posting list. If the hash value is not stored at the first storage location, the method includes retrieving an address of a second storage location on a second storage device from the first storage location. The method then includes determining if the hash value is stored at the second storage location. If the hash value is stored at the second storage location, the method includes retrieving an address of a posting list from the second storage location and using that address to access the posting list. If the hash value is not stored at the second storage location, the method includes retrieving an address of a third storage location on a third storage device from the second storage location. The method then includes determining if the hash value is stored at the third storage location. If the hash value is not stored at the third storage location, the method includes determining to abandon searching for the hash value. If the hash value is stored at the third storage location, the method includes accessing a posting list from the third storage location.</p>
<p id="p-0020" num="0019">A further embodiment of the present invention is directed to one or more computer-storage media storing computer-useable instructions that, when used by a computing device, cause the computing device to perform a method. The method includes receiving a search query, identifying a term from the search query, and hashing the term to generate a first hash value and a second hash value. The method also includes identifying a cacheline in a RAM corresponding with the first hash value, the cacheline containing a plurality of data entries each including a hash value corresponding with a given term and an address of a posting list for the given term. The method further includes determining whether the cacheline contains the second hash value. If the cacheline contains the second hash value, the method includes retrieving from the cacheline an address of a posting list corresponding with the second hash value and using that address to access the posting list. If the cacheline does not contain the second hash value, the method includes retrieving from the cacheline an address of a page in a flash-based solid state device containing a plurality of data entries each including a hash value corresponding with a given term and an address of a posting list for the given term. The method then includes determining whether the page contains the second hash value. If the page contains the second hash value, the method includes retrieving from the page an address of a posting list corresponding with the second hash value and using that address to access the posting list. If the page does not contain the second hash value, the method includes employing a bloom filter stored in the page. If the second hash value fails the bloom filter, the method includes determining to abandon searching for the second hash value. If the second hash value passes the bloom filter, the method includes retrieving from the page an address of a page file in a hard disk drive containing a plurality of data entries each including a hash value corresponding with a given term and a posting list for the given term. The method then includes determining whether the page file contains the second hash value. If the page file does not contain the second hash value, the method includes determining to abandon searching for the second hash value. If the page file contains the second hash value, the method includes accessing from the page file a posting list corresponding with the second hash value.</p>
<p id="p-0021" num="0020">Having described an overview of embodiments of the present invention, an exemplary operating environment in which embodiments of the present invention may be implemented is described below in order to provide a general context for various aspects of the present invention. Referring initially to <figref idref="DRAWINGS">FIG. 1</figref> in particular, an exemplary operating environment for implementing embodiments of the present invention is shown and designated generally as computing device <b>100</b>. Computing device <b>100</b> is but one example of a suitable computing environment and is not intended to suggest any limitation as to the scope of use or functionality of the invention. Neither should the computing device <b>100</b> be interpreted as having any dependency or requirement relating to any one or combination of components illustrated.</p>
<p id="p-0022" num="0021">The invention may be described in the general context of computer code or machine-useable instructions, including computer-executable instructions such as program modules, being executed by a computer or other machine, such as a personal data assistant or other handheld device. Generally, program modules including routines, programs, objects, components, data structures, etc., refer to code that perform particular tasks or implement particular abstract data types. The invention may be practiced in a variety of system configurations, including hand-held devices, consumer electronics, general-purpose computers, more specialty computing devices, etc. The invention may also be practiced in distributed computing environments where tasks are performed by remote-processing devices that are linked through a communications network.</p>
<p id="p-0023" num="0022">With reference to <figref idref="DRAWINGS">FIG. 1</figref>, computing device <b>100</b> includes a bus <b>110</b> that directly or indirectly couples the following devices: memory <b>112</b>, one or more processors <b>114</b>, one or more presentation components <b>116</b>, input/output (I/O) ports <b>118</b>, input/output components <b>120</b>, and an illustrative power supply <b>122</b>. Bus <b>110</b> represents what may be one or more busses (such as an address bus, data bus, or combination thereof). Although the various blocks of <figref idref="DRAWINGS">FIG. 1</figref> are shown with lines for the sake of clarity, in reality, delineating various components is not so clear, and metaphorically, the lines would more accurately be grey and fuzzy. For example, one may consider a presentation component such as a display device to be an I/O component. Also, processors have memory. The inventors recognize that such is the nature of the art, and reiterate that the diagram of <figref idref="DRAWINGS">FIG. 1</figref> is merely illustrative of an exemplary computing device that can be used in connection with one or more embodiments of the present invention. Distinction is not made between such categories as &#x201c;workstation,&#x201d; &#x201c;server,&#x201d; &#x201c;laptop,&#x201d; &#x201c;hand-held device,&#x201d; etc., as all are contemplated within the scope of <figref idref="DRAWINGS">FIG. 1</figref> and reference to &#x201c;computing device.&#x201d;</p>
<p id="p-0024" num="0023">Computing device <b>100</b> typically includes a variety of computer-readable media. Computer-readable media can be any available media that can be accessed by computing device <b>100</b> and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer-readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer-readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computing device <b>100</b>. Communication media typically embodies computer-readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term &#x201c;modulated data signal&#x201d; means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer-readable media.</p>
<p id="p-0025" num="0024">Memory <b>112</b> includes computer-storage media in the form of volatile and/or nonvolatile memory. The memory may be removable, non-removable, or a combination thereof. Exemplary hardware devices include solid-state memory, hard drives, optical-disc drives, etc. Computing device <b>100</b> includes one or more processors that read data from various entities such as memory <b>112</b> or I/O components <b>120</b>. Presentation component(s) <b>116</b> present data indications to a user or other device. Exemplary presentation components include a display device, speaker, printing component, vibrating component, etc.</p>
<p id="p-0026" num="0025">I/O ports <b>118</b> allow computing device <b>100</b> to be logically coupled to other devices including I/O components <b>120</b>, some of which may be built in. Illustrative components include a microphone, joystick, game pad, satellite dish, scanner, printer, wireless device, etc.</p>
<p id="p-0027" num="0026">Turning now to <figref idref="DRAWINGS">FIG. 2</figref>, a diagram is provided that illustrates a priority hash index for a search index in accordance with an embodiment of the present invention. As previously indicated, the priority hash index is a data structure that facilitates efficient lookup of posting lists for terms submitted in search queries. The priority hash index shown in <figref idref="DRAWINGS">FIG. 2</figref> resides on three storage devices, RAM <b>202</b>, a flash-based solid state device (SSD) <b>204</b>, and a hard disk drive (HDD) <b>206</b>. It should be noted that other types of storage devices may be employed within the scope of embodiments of the present invention. Additionally, although <figref idref="DRAWINGS">FIG. 2</figref> illustrates a priority hash index spread across three storage devices, a priority hash index in accordance with various embodiments of the present invention may employ two or more storage devices.</p>
<p id="p-0028" num="0027">In accordance with embodiments of the present invention, terms indexed by the search index are grouped into &#x201c;search lists.&#x201d; Each search list includes a portion of the terms indexed by the search index and is stored across the three layers of storage: RAM <b>202</b>, the SSD <b>204</b>, and the HDD <b>206</b>. For instance, <figref idref="DRAWINGS">FIG. 2</figref> illustrates a number of terms <b>208</b> that are part of a search list. The terms <b>208</b> are each hashed to a unique hash value. Any of a variety of different hash functions may be employed within the various embodiments of the present invention. By way of example only and not limitation, the MD4 hash function may be employed.</p>
<p id="p-0029" num="0028">In embodiments, hashing the terms provides two hash values. The two hash values may be separate values or may be portions of a larger hash value generated by the hash function. The first hash value serves to identify the search list, while the second hash value serves to disambiguate the various terms in each search list.</p>
<p id="p-0030" num="0029">By way of illustration, the first hash value for each term in the group of terms <b>208</b> selects a cacheline <b>210</b> in the RAM <b>202</b>. As such, the cacheline <b>210</b> serves as the entry point into the search list for the group of terms <b>208</b>. Each of the other cachelines in the RAM <b>202</b> serve as the entry point into a different search list comprising a different set of terms indexed by the search index.</p>
<p id="p-0031" num="0030">The second hash values for the group of terms <b>208</b> are spread across the three layers of storage from fastest storage to slowest storage based on the importance of the terms. For instance, hash values for the most important terms are stored in RAM <b>202</b>, hash values for the next most important terms are stored on the SSD <b>204</b>, and hash values for the least important terms are stored on the HDD <b>206</b>. Importance of terms may be based on a number of factors in various embodiments of the present invention. For instance, importance of terms may be based on the length of the posting lists for the terms. In particular, longer posting lists could signify greater importance. Importance of terms may also be based on access statistics regarding the frequency with which each term is historically accessed in response to search queries. Terms that are accessed more frequently may be considered more important. In some embodiments, term importance may be based on a ranking function (e.g., BM25f ranking function or a generic ranking function F(a, q)=(0 . . . 1)).</p>
<p id="p-0032" num="0031">As shown in <figref idref="DRAWINGS">FIG. 2</figref>, the cacheline <b>210</b> in the RAM <b>202</b> includes a number of data entries <b>212</b>. Each data entry includes a hash value and the address of a posting list for the term corresponding with that hash value. In some embodiments, the posting lists may be stored at various locations on the HDD <b>206</b>, and the address of each data entry may correspond with a location on the HDD <b>206</b> at which a posting list is stored. In the example shown in <figref idref="DRAWINGS">FIG. 2</figref>, the cacheline <b>210</b> includes data entries for ten hash values. These hash values correspond with the ten most important terms in the search list.</p>
<p id="p-0033" num="0032">The cacheline <b>210</b> also includes an address <b>214</b> of a location <b>216</b> (e.g., a page) on the SSD <b>204</b>. The location <b>216</b> on the SSD <b>204</b> includes the continuation of the search list that was started at the cacheline <b>210</b> on the RAM <b>202</b>. As shown in <figref idref="DRAWINGS">FIG. 2</figref>, the location <b>216</b> includes a number of data entries <b>218</b>. Each data entry includes a hash value and the address of a posting list for the term corresponding with that hash value. In some embodiments, the posting lists may be stored at various locations on the HDD <b>206</b>, and the address of each data entry may correspond with a location on the HDD <b>206</b> at which a posting list is stored. In the example shown in <figref idref="DRAWINGS">FIG. 2</figref>, the location <b>216</b> includes data entries for 244 hash values. These hash values correspond with the next most important terms after the first ten stored in the cacheline <b>210</b>.</p>
<p id="p-0034" num="0033">The location <b>216</b> on the SSD <b>204</b> also stores a bloom filter <b>220</b>. The bloom filter may be constructed based on the remaining hash values of the search list that are stored in the HDD <b>206</b>. The location <b>216</b> on the SSD <b>204</b> further includes the address <b>222</b> of a location <b>224</b> (e.g., page file) on the HDD <b>206</b>. The location <b>224</b> on the HDD <b>224</b> includes the continuation of the search list, continuing from the data entries stored at the location <b>216</b> on the SSD <b>204</b>. As shown in <figref idref="DRAWINGS">FIG. 2</figref>, the location <b>224</b> on the HDD <b>224</b> includes a number of data entries <b>226</b>. Each data entry includes a hash value and the posting list for the term corresponding with that hash value. In other words, posting lists are stored inline with the hash values on the HDD <b>224</b>, as opposed to storing addresses as on the RAM <b>202</b> and the SSD <b>204</b>. In the example shown in <figref idref="DRAWINGS">FIG. 2</figref>, the location <b>216</b> includes data entries for 1240 hash values. These hash values correspond with the least important terms in the search list.</p>
<p id="p-0035" num="0034">In some embodiments, short posting lists may be stored inline in the RAM <b>202</b> and/or the SSD <b>204</b>. In particular, if a posting list for a term stored on the RAM <b>202</b> or the SSD <b>204</b> is shorter than some threshold such that it will not consume too much storage space, the posting list may be stored on the RAM <b>202</b> or the SSD <b>204</b> with the hash value for the term as opposed to storing the posting list elsewhere and proving an address on the RAM <b>202</b> or the SSD <b>204</b>. This avoids seeks to the HDD <b>206</b> in the case of short posting lists.</p>
<p id="p-0036" num="0035">In operation, when a search query is received, a term is identified and hashed to generate a first and second hash value. For instance, the first hash value for a term in the group of terms <b>208</b> would select the cacheline <b>210</b> as an entry point into the search list. The data entries at the cacheline are read to determine if they contain the second hash value for the term. If so, the posting list address associated with the stored hash value is used to access the posting list for the term. If not, the SSD address <b>214</b> is retrieved from the cacheline <b>210</b> and used to access the location <b>216</b> on the SSD <b>204</b>. The data entries stored at the location <b>216</b> on the SSD <b>204</b> are read to determine if they contain the second hash value. If so, the posting list address with the stored hash value is used to access the posting list for the term. If not, the bloom filer <b>220</b> is checked to determine if the second hash value is likely contained by the continuation of the search list on the HDD <b>206</b>. The bloom filter is used as this point as the next step will be to access the HDD <b>206</b>, which is extremely slow compared to accessing the RAM <b>202</b> and the SSD <b>204</b>. If the second hash value fails the bloom filter, the second hash value is not stored on the HDD <b>206</b> and the process is abandoned. As such, an unnecessary access to the HDD <b>206</b> is avoided. Alternatively, if the second hash value passes the bloom filter, the HDD address <b>222</b> is retrieved from the location <b>216</b> on the SSD <b>204</b> and used to access the location <b>224</b> on the HDD <b>206</b>. The data entries <b>226</b> stored at the location <b>224</b> on the HDD <b>206</b> are read to determine if they contain the second hash value. If so, the posting list stored in association with the second hash value is accessed. Because the posting lists for the hash values stored on the HDD <b>206</b> are stored inline with the hash values, only one access to the HDD <b>206</b> is required to locate the hash value and retrieve the corresponding posting list. If the data entries <b>226</b> do not contain the second hash value, the process is abandoned as the term is not indexed by the search system.</p>
<p id="p-0037" num="0036">Accordingly, the priority hash index of <figref idref="DRAWINGS">FIG. 2</figref> illustrates a three layered data structure across RAM <b>202</b>, SSD <b>204</b>, and HDD <b>206</b>. This allows for a bounded search to turn up posting lists with at most one short SSD read and one short HDD read.</p>
<p id="p-0038" num="0037">Referring next to <figref idref="DRAWINGS">FIG. 3</figref>, a block diagram is provided illustrating an exemplary system <b>300</b> in which embodiments of the present invention may be employed. It should be understood that this and other arrangements described herein are set forth only as examples. Other arrangements and elements (e.g., machines, interfaces, functions, orders, and groupings of functions, etc.) can be used in addition to or instead of those shown, and some elements may be omitted altogether. Further, many of the elements described herein are functional entities that may be implemented as discrete or distributed components or in conjunction with other components, and in any suitable combination and location. Various functions described herein as being performed by one or more entities may be carried out by hardware, firmware, and/or software. For instance, various functions may be carried out by a processor executing instructions stored in memory.</p>
<p id="p-0039" num="0038">Among other components not shown, the system <b>300</b> may include a user device <b>302</b>, content server <b>304</b>, and search engine server <b>306</b>. Each of the components shown in <figref idref="DRAWINGS">FIG. 3</figref> may be any type of computing device, such as computing device <b>100</b> described with reference to <figref idref="DRAWINGS">FIG. 1</figref>, for example. The components may communicate with each other via a network <b>308</b>, which may include, without limitation, one or more local area networks (LANs) and/or wide area networks (WANs). Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, and the Internet. It should be understood that any number of user devices, content servers, and search engine servers may be employed within the system <b>300</b> within the scope of the present invention. Each may comprise a single device or multiple devices cooperating in a distributed environment. For instance, the search engine server <b>306</b> may comprise multiple devices arranged in a distributed environment that collectively provide the functionality of the search engine server <b>306</b> described herein. Additionally, other components not shown may also be included within the system <b>300</b>.</p>
<p id="p-0040" num="0039">The search engine server <b>306</b> generally operates to receive search queries from user devices, such as the user device <b>302</b>, and to provide search results in response to the search queries. The search engine server <b>306</b> includes, among other things, an indexing component <b>310</b>, a user interface component <b>312</b>, and an index access component <b>314</b>.</p>
<p id="p-0041" num="0040">The indexing component <b>310</b> operates to index data regarding documents maintained by content servers, such as the content server <b>304</b>. For instance, a crawling component (not shown) may be employed to crawl content servers and access information regarding documents maintained by the content servers. The indexing component <b>310</b> then indexes data regarding the crawled documents in the search index <b>316</b>, including posting lists for terms identified in the document. In embodiments, the indexing component <b>310</b> also generates a priority hash index for efficient lookup of terms in the search index. As discussed previously, the priority hash index is spread across multiple types of storage devices. For instance, in one embodiment, the priority hash index is stored on RAM, a flash-based SDD, and a HDD. Hash values for terms are stored on the storage devices based on importance of terms with hash values of more important terms filling the fastest storage device first and hash values of less important terms being stored on slower storage devices.</p>
<p id="p-0042" num="0041">The user interface component <b>312</b> provides an interface to user devices, such as the user device <b>302</b>, that allows users to submit search queries to the search engine server <b>306</b> and to receive search results from the search engine server <b>306</b>. The user device <b>302</b> may be any type of computing device employed by a user to submit search queries and receive search results. By way of example only and not limitation, the user device <b>302</b> may be a desktop computer, a laptop computer, a tablet computer, a mobile device, or other type of computing device. The user device <b>302</b> may include an application that allows a user to enter a search query and submit the search query to the search engine server <b>306</b> to retrieve search results. For instance, the user device <b>302</b> may include a web browser that includes a search input box or allows a user to access a search page to submit a search query. Other mechanisms for submitting search queries to search engines are contemplated to be within the scope of embodiments of the present invention.</p>
<p id="p-0043" num="0042">When a search query is received via the user interface component <b>312</b>, one or more terms are identified from the search query. The index access component <b>314</b> then operates to identify a posting list for each term in the search index <b>316</b>. The index access component <b>314</b> employs the priority hash index generated by the indexing component <b>310</b> to identify a location at which the posting list for each term is stored. In embodiments, the index access component <b>314</b> hashes a term to identify a location on the first storage device and to generate a hash value that is used to identify a posting list for the term. The index access component <b>310</b> sequentially accesses each storage device storing the priority hash index until the hash value for the term is located and then retrieves the corresponding posting list (unless the term is not indexed in which case the process is abandoned).</p>
<p id="p-0044" num="0043">Posting lists retrieved by the index access component <b>314</b> for the terms in a received search query are used to generate search results for the search query. The search results may then be communicated to the user device <b>302</b> by the user interface component <b>312</b> such that the search results may be presented to the end user who submitted the search query.</p>
<p id="p-0045" num="0044">With reference now to <figref idref="DRAWINGS">FIG. 4</figref>, a flow diagram is provided that illustrates a method <b>400</b> for access data from a search index via a priority hash index in accordance with an embodiment of the present invention. Initially, a search query is received by a search engine, as shown at block <b>402</b>. The search query may include one or more terms. At least one term is identified for further processing, as shown at block <b>404</b>. The term is hashed at block <b>406</b> by applying a hash function to the term. Any of a variety of different hash functions may be employed within the various embodiments of the present invention. By way of example only and not limitation, the MD4 hash function may be employed.</p>
<p id="p-0046" num="0045">The processing of hashing the term at block <b>406</b> may include generating two hash values. In one embodiment, a large hash value is generated, from which two smaller and uncorrelated hash values are generated. By way of example only and not limitation, a 72 bit hash may be generated, from which a first hash value containing 24 bits and a second hash value containing 48 bits may be derived. The first hash value may be used to identify a search list, while the second hash value may be used to disambiguate the multiple entries in the search list.</p>
<p id="p-0047" num="0046">The first hash value is used to identify a storage location within a first storage device, as shown at block <b>408</b>. In one embodiment, the first storage device is RAM, and the storage location is a cacheline in the RAM. The storage location includes a number of data entries, each of which includes a hash value and an address of a posting list.</p>
<p id="p-0048" num="0047">The identified storage location on the first storage device is read to determine if it contains the second hash value determined for the term, as shown at block <b>410</b>. If it is determined that the storage location on the first storage device contains the second hash value at block <b>412</b>, the address stored with the second hash value is retrieved from the storage location on the first storage device, as shown at block <b>414</b>. The address corresponds with a posting list for the term. As such, the posting list for the term is accessed, as shown at block <b>416</b>. The posting list is used to generate search results, as shown at block <b>418</b>. The search results are provided for returning to the end user in response to the original search query, as shown at block <b>420</b>.</p>
<p id="p-0049" num="0048">If it is determined at block <b>412</b> that the storage location on the first storage device does not contain the second hash value, an address of a storage location on a second storage device is retrieved from the storage location on the first storage device, as shown at block <b>422</b>. In one embodiment, the second storage device is a flash-based solid state device, and the storage location is a page on the flash-based solid state device. The storage location on the second storage device also includes a number of data entries, each of which includes a hash value and an address of a posting list.</p>
<p id="p-0050" num="0049">The identified storage location on the second storage device is read to determine if it contains the second hash value determined for the term, as shown at block <b>424</b>. If it is determined that the storage location on the second storage device contains the second hash value at block <b>426</b>, the address stored with the second hash value is retrieved from the storage location on the second storage device, as shown at block <b>428</b>. The address corresponds with a posting list for the term. As such, the posting list for the term is accessed, as shown at block <b>430</b>. The posting list is used to generate search results, as shown at block <b>432</b>. The search results are provided for returning to the end user in response to the original search query, as shown at block <b>434</b>.</p>
<p id="p-0051" num="0050">If it is determined at block <b>426</b> that the storage location on the second storage device does not contain the second hash value, a bloom filter stored at the storage location on the second storage device is checked to determine if the continuation of the search list likely contains the second hash, as shown at block <b>436</b>. If it is determined at block <b>438</b> that the second hash value fails the bloom filter, the access process is abandoned at block <b>440</b> as the term is not indexed in the search index. Alternatively, if the second hash value passes the bloom filter at block <b>438</b>, an address of a storage location on a third storage device is retrieved from the storage location on the second storage device, as shown at block <b>442</b>. In one embodiment, the second storage device is a hard disk drive, and the storage location is a page file on the hard disk drive. The storage location on the third storage device includes a number of data entries, each of which includes a hash value and a corresponding posting list.</p>
<p id="p-0052" num="0051">The identified storage location on the third storage device is read to determine if it contains the second hash value determined for the term, as shown at block <b>444</b>. If it is determined at block <b>446</b> that the storage location on the third storage device does not contain the second hash value, the access process is abandoned at block <b>448</b> as the term is not indexed in the search index. Alternatively, if it is determined at block <b>446</b> that the storage location on the third storage device contains the second hash value, the posting list stored in association with the second hash value at the storage location on the third storage device is accessed, as shown at block <b>440</b>. The posting list is used to generate search results, as shown at block <b>442</b>. The search results are provided for returning to the end user in response to the original search query, as shown at block <b>444</b>.</p>
<p id="p-0053" num="0052">As can be understood, embodiments of the present invention provide a priority hash index that allows for efficient lookup of posting lists for terms in a search query to generate search results in response to the search query.</p>
<p id="p-0054" num="0053">The present invention has been described in relation to particular embodiments, which are intended in all respects to be illustrative rather than restrictive. Alternative embodiments will become apparent to those of ordinary skill in the art to which the present invention pertains without departing from its scope.</p>
<p id="p-0055" num="0054">From the foregoing, it will be seen that this invention is one well adapted to attain all the ends and objects set forth above, together with other advantages which are obvious and inherent to the system and method. It will be understood that certain features and subcombinations are of utility and may be employed without reference to other features and subcombinations. This is contemplated by and is within the scope of the claims.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for accessing data from a search index, the method comprising:
<claim-text>receiving a hash value corresponding with a search term from a search query;</claim-text>
<claim-text>identifying a first storage location on a first storage device that stores a plurality of data entries each containing an entry hash value corresponding with both a term and an address locating a posting list for the term, the first storage location also storing an address of a second storage location on a second data storage device, the address comprises a continuing search list for identifying the hash value;</claim-text>
<claim-text>upon determining that the hash value is stored at the first storage location:
<claim-text>(1) retrieving an address of a posting list from the first storage location is retrieved; and</claim-text>
<claim-text>(2) accessing the address in the posting list;</claim-text>
</claim-text>
<claim-text>upon determining that the hash value is not stored at the first storage location:
<claim-text>(1) retrieving an address of the second storage location on the second storage device from the first storage location;</claim-text>
</claim-text>
<claim-text>upon determining that the hash value is stored at the second storage location:
<claim-text>(1) retrieving an address of a posting list from the second storage location; and</claim-text>
<claim-text>(2) accessing the address in the posting list;</claim-text>
</claim-text>
<claim-text>upon determining that the hash value is not stored at the second storage location:
<claim-text>(1) retrieving an address of a third storage location on a third storage device from the second storage location;</claim-text>
</claim-text>
<claim-text>upon determining that the hash value is not stored at the third storage location:
<claim-text>(1) determining to abandon searching for the hash value; and</claim-text>
</claim-text>
<claim-text>upon determining that the hash value is stored at the third storage location:
<claim-text>(1) accessing the posting list from the third storage location.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first storage location on the first storage device is identified based on a second hash value corresponding with the search term.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein a posting list is accessed, and wherein the method further includes:
<claim-text>generating search results using the posting list; and</claim-text>
<claim-text>providing the search results in response to the search query for presentation to an end user.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first data storage device is a RAM and the first storage location is a cacheline, wherein the second data storage device is a flash-based solid state device and the second storage location is a page, and wherein the third data storage device is a hard disk drive and the third storage location is a page file.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein importance of a term is determined based on at least one selected from the following: a length of a posting list for the term; and access frequency of a posting list for the term.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein a plurality of hash values are stored on the first, second, and third storage devices from fastest- to slowest-speed storage device based on importance of terms associated with the hash values.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein retrieving the address of the third storage location on the third storage device from the second storage location upon determining that the hash value is not stored at the second storage location includes checking a bloom filter stored at the second storage location and determining that the hash value passes the boom filter.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. One or more computer-storage media hardware memory devices storing computer-useable instructions that, when used by a computing device, cause the computing device to perform a method comprising:
<claim-text>receiving a search query;</claim-text>
<claim-text>identifying a term from the search query;</claim-text>
<claim-text>hashing the term to generate a first hash value and a second hash value;</claim-text>
<claim-text>identifying a cacheline in a RAM corresponding with the first hash value, the cacheline containing a plurality of data entries each including a hash value corresponding with a given term and an address of a posting list for the given term, the cacheline having an address of a page in a flash-based solid state device, the address comprises a continuing search list for identifying the hash value;</claim-text>
<claim-text>upon determining that the cacheline contains the second hash value:
<claim-text>(1) retrieving from the cacheline an address of a posting list corresponding with the second hash value and using that address to access the posting list;</claim-text>
</claim-text>
<claim-text>upon determining that the cacheline does not contain the second hash value:
<claim-text>(1) retrieving from the cacheline the address of the page in the flash-based solid state device containing a plurality of data entries each including a hash value corresponding with a given term and an address of a posting list for the given term;</claim-text>
</claim-text>
<claim-text>upon determining that the page contains the second hash value:
<claim-text>(1) retrieving from the page an address of a posting list corresponding with the second hash value and using that address to access the posting list;</claim-text>
</claim-text>
<claim-text>upon determining that the page does not contain the second hash value:
<claim-text>(1) employing a bloom filter stored in the page;</claim-text>
</claim-text>
<claim-text>upon the second hash value failing the bloom filter:
<claim-text>(1) determining to abandon searching for the second hash value;</claim-text>
</claim-text>
<claim-text>upon the second hash value passing the bloom filter:
<claim-text>(1) retrieving from the page an address of a page file in a hard disk drive containing a plurality of data entries each including a hash value corresponding with a given term and a posting list for the given term;</claim-text>
</claim-text>
<claim-text>upon determining that the page file does not contain the second hash value:
<claim-text>(1) determining to abandon searching for the second hash value; and</claim-text>
</claim-text>
<claim-text>upon determining that the page file contains the second hash value:
<claim-text>(1) accessing from the page file a posting list corresponding with the second hash value.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The one or more computer storage media of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein first hash value and second hash value are portions of a single hash value.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The one or more computer storage media of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein a posting list is accessed, and wherein the method further includes:
<claim-text>generating search results using the posting list; and</claim-text>
<claim-text>providing the search results in response to the search query for presentation to an end user. </claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
