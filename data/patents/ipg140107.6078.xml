<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627202-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627202</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12889330</doc-number>
<date>20100923</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<priority-claims>
<priority-claim sequence="01" kind="national">
<country>CA</country>
<doc-number>2702137</doc-number>
<date>20100514</date>
</priority-claim>
</priority-claims>
<us-term-of-grant>
<us-term-extension>362</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>715242</main-classification>
<further-classification>715234</further-classification>
</classification-national>
<invention-title id="d2e71">Update and serialization of XML documents</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6675353</doc-number>
<kind>B1</kind>
<name>Friedman</name>
<date>20040100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>715239</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6772413</doc-number>
<kind>B2</kind>
<name>Kuznetsov</name>
<date>20040800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717136</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6959415</doc-number>
<kind>B1</kind>
<name>Soderberg et al.</name>
<date>20051000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>715234</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>7231394</doc-number>
<kind>B2</kind>
<name>Walker et al.</name>
<date>20070600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>  1  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>7398200</doc-number>
<kind>B2</kind>
<name>Ie et al.</name>
<date>20080700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>704  9</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>8082493</doc-number>
<kind>B2</kind>
<name>Sthanikam et al.</name>
<date>20111200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>715234</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>8082496</doc-number>
<kind>B1</kind>
<name>Leeds et al.</name>
<date>20111200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>715255</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>8196135</doc-number>
<kind>B2</kind>
<name>LaFontaine</name>
<date>20120600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717174</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>8423518</doc-number>
<kind>B2</kind>
<name>Lafontaine et al.</name>
<date>20130400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707692</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>8429526</doc-number>
<kind>B2</kind>
<name>Sthanikam et al.</name>
<date>20130400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>715255</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2003/0167446</doc-number>
<kind>A1</kind>
<name>Thomas</name>
<date>20030900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>715513</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2005/0097110</doc-number>
<kind>A1</kind>
<name>Nishanov</name>
<date>20050500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2007/0005622</doc-number>
<kind>A1</kind>
<name>Fernandez et al.</name>
<date>20070100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2007/0271305</doc-number>
<kind>A1</kind>
<name>Chandraseker et al.</name>
<date>20071100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>2008/0098412</doc-number>
<kind>A1</kind>
<name>Zhou et al.</name>
<date>20080400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>2008/0140705</doc-number>
<kind>A1</kind>
<name>Luo</name>
<date>20080600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707103 R</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>2009/0006429</doc-number>
<kind>A1</kind>
<name>Champion et al.</name>
<date>20090100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00018">
<document-id>
<country>US</country>
<doc-number>2009/0006450</doc-number>
<kind>A1</kind>
<name>Champion et al.</name>
<date>20090100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00019">
<document-id>
<country>US</country>
<doc-number>2009/0172042</doc-number>
<kind>A1</kind>
<name>Bracha et al.</name>
<date>20090700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707201</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00020">
<document-id>
<country>US</country>
<doc-number>2009/0248624</doc-number>
<kind>A1</kind>
<name>Lammel et al.</name>
<date>20091000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00021">
<document-id>
<country>US</country>
<doc-number>2009/0254808</doc-number>
<kind>A1</kind>
<name>Yuan et al.</name>
<date>20091000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00022">
<othercit>Liu et al., &#x201c;Effective and Efficient Update of XML in RDBMS,&#x201d; SIGMOD'07, Jun. 12-14, 2007, Beijing, China, pp. 925-936.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00023">
<othercit>Kogan et al., &#x201c;Optimizing Runtime XML Processing in RElational Databases,&#x201d; Microsoft Corporation, S. Bressan et al. (Eds.): XSym 2005, LNCS 3671, pp. 222-236, Springer-Verlag Berlin Heidelberg 2005.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00024">
<othercit>Fernandes et al., &#x201c;inflatable XML Processing&#x201d;, pp. 2-20; 2005.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>17</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>715234</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>715242</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>11</number-of-drawing-sheets>
<number-of-figures>11</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20110283179</doc-number>
<kind>A1</kind>
<date>20111117</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>De Magalhaes</last-name>
<first-name>Arthus L</first-name>
<address>
<city>Toronto</city>
<country>CA</country>
</address>
</addressbook>
<residence>
<country>CA</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>De Magalhaes</last-name>
<first-name>Arthus L</first-name>
<address>
<city>Toronto</city>
<country>CA</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>North Shore Patents, P.C.</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Baillie</last-name>
<first-name>Michele Liu</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Dyer</last-name>
<first-name>Andrew</first-name>
<department>2176</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A method, system, and computer program product for updating and serialization of a document, includes: assigning a unique ID to each node created in the document; materializing a root element start tag of the document; materializing a start tag for a child element of the root element; determining whether a change to the child element is required; in response to determining that the change to the child element is not required, skipping content of the child element; in response to determining that the change to the child element is required, updating the child element to form an updated element; pushing updated information for the child element into a mutation map; and serializing the document using the mutation map.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="180.85mm" wi="207.26mm" file="US08627202-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="228.77mm" wi="154.94mm" file="US08627202-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="152.82mm" wi="152.57mm" file="US08627202-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="206.33mm" wi="172.47mm" file="US08627202-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="215.82mm" wi="182.46mm" file="US08627202-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="190.58mm" wi="170.10mm" file="US08627202-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="231.90mm" wi="179.92mm" file="US08627202-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="215.90mm" wi="207.09mm" file="US08627202-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="197.78mm" wi="144.10mm" file="US08627202-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="180.09mm" wi="137.58mm" file="US08627202-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="203.12mm" wi="104.48mm" file="US08627202-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="188.72mm" wi="154.77mm" file="US08627202-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">The present application claims priority to Canadian Patent Application No. 2702137, filed on May 14, 2010.</p>
<heading id="h-0002" level="1">BACKGROUND</heading>
<p id="p-0003" num="0002">1. Technical Field</p>
<p id="p-0004" num="0003">This disclosure relates generally to processing of documents in a data processing system and more specifically for random update and serialization of XML documents.</p>
<p id="p-0005" num="0004">2. Description of the Related Art</p>
<p id="p-0006" num="0005">Many applications need to perform random updates to an extensible markup language (XML) document followed by serialization of the entire document. The applications for such scenario are numerous, because the need to update and serialize XML documents is a core requirement of many services oriented architecture (SOA) transactions and products. In current processing environments, streams of data are processed that cannot be reset, such as incoming network data. A capability of performing random access and updates of documents represented in the streams of data is in very high demand. Furthermore, serialization of such documents is a next natural step that most applications require, with both steps having a common need for memory and time efficiency.</p>
<p id="p-0007" num="0006">A typical need in document processing systems is to dramatically reduce time spent handling XML documents. Applications and associated products need to very efficiently update part of a document and serialize the resulting document for consumption in other parts of a system. A bottleneck typically occurs with unnecessary materialization of a whole document into objects, due to a random update nature of these applications. Generally existing XML parsing solutions appear to focus on the reading of the document rather than managing updates to the content efficiently.</p>
<p id="p-0008" num="0007">A general solution to update an XML document uses a Document Object Model (DOM), which typically has very poor performance because of the materialization of the complete document into objects. On the other hand, a general fast serialization solution for XML documents uses Simple API for XML, (SAX) or Streaming API for XML (StAX), but neither solution provides a capability to randomly update. In an example of a current solution, a hybrid representation of materialized and un-materialized data is only sequential. The solution is only capable of materializing a portion of the document in document order and leaving the rest of the document un-materialized.</p>
<p id="p-0009" num="0008">In another example of a current solution, an &#x201c;inflatable node&#x201d; is used which requires references to the offset in the byte array. This means a &#x201c;wrapper&#x201d; in the form of the inflatable node must exist for each node. The inflatable node information requires additional memory, thereby adding to memory requirements of the document.</p>
<p id="p-0010" num="0009">In another example of a current solution data is always in binary form and a process to update that binary data is provided. However, any updates from memory have to be converted into a correct binary format first before being applied. The process also has a drawback because a mutation in one part of the binary data might require changes in other parts of the data stream.</p>
<p id="p-0011" num="0010">In another example of attempting to solve both requirements of efficiently updating part of a document and serializing the resulting document, a typical solution uses Eclipse&#x2122; Modeling Framework (EMF). Although use of EMF is an improvement over DOM, the solution still lacks optimal random update and serialization that many products require. EMF loads the entire document in memory and therefore typically does not have the necessary performance required, especially for scenarios where only small parts of the document are mutated.</p>
<heading id="h-0003" level="1">BRIEF SUMMARY</heading>
<p id="p-0012" num="0011">Embodiments of a method, system, and computer program product for updating and serialization a document assign a unique ID to each node created in the document, materialize a root element start tag of the document, materialize a start tag for a child element of the root element and determine whether a change to the child element is required. In response to determining that the change to the child element is not required, the method, system and computer program product skip content of the child element. In response to determining that the change to the child element is required, the method, system and computer program product update the child element to form an updated element. The method, system and computer program product further push updated information for the child element into a mutation map and serialize the document using the mutation map.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS</heading>
<p id="p-0013" num="0012">For a more complete understanding of this disclosure, reference is now made to the following brief description, taken in conjunction with the accompanying drawings and detailed description, wherein like reference numerals represent like parts.</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram of an exemplary data processing system operable for various embodiments of the disclosure;</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 2</figref>, is a block diagram of components of an update and serialization system in accordance with various embodiments;</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 3</figref> is a textual representation of a sample document portion, in accordance with one embodiment of the disclosure;</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 4</figref> is a textual representation of another sample document portion, in accordance with one embodiment of the disclosure;</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 5</figref> is a textual representation of an encapsulation example in accordance with various embodiments of the disclosure;</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 6</figref> is a textual representation of a serialization example in accordance with various embodiments of the disclosure;</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 7</figref> is a flowchart of a sub-tree fragment process example in accordance with various embodiments of the disclosure;</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 8</figref> is a flowchart of a unique identifier process example in accordance with various embodiments of the disclosure;</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 9</figref> is a flowchart of a &#x201c;mutation map&#x201d; process example in accordance with various embodiments of the disclosure;</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 10</figref> is a flowchart of a serialization process example in accordance with various embodiments of the disclosure; and</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 11</figref> is a flowchart of an update and serialization process example in accordance with various embodiments of the disclosure.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0025" num="0024">Although an illustrative implementation of one or more embodiments is provided below, the disclosed systems and/or methods may be implemented using any number of techniques. This disclosure should in no way be limited to the illustrative implementations, drawings, and techniques illustrated below, including the exemplary designs and implementations illustrated and described herein, but may be modified within the scope of the appended claims along with their full scope of equivalents.</p>
<p id="p-0026" num="0025">As will be appreciated by one skilled in the art, the present disclosure may be embodied as a system, method or computer program product. Accordingly, the present disclosure may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a &#x201c;circuit,&#x201d; &#x201c;module,&#x201d; or &#x201c;system.&#x201d; Furthermore, the present invention may take the form of a computer program product tangibly embodied in any medium of expression with computer usable program code embodied in the medium.</p>
<p id="p-0027" num="0026">Computer program code for carrying out operations of the present disclosure may be written in any combination of one or more programming languages, including an object oriented programming language such as Java&#x2122;, Smalltalk, C++, or the like and conventional procedural programming languages, such as the &#x201c;C&#x201d; programming language or similar programming languages. Java and all Java-based trademarks and logos are trademarks of Sun Microsystems, Inc., in the United States, other countries or both. The program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).</p>
<p id="p-0028" num="0027">The present disclosure is described below with reference to flowchart illustrations and/or block diagrams of methods, apparatus, systems, and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and/or block diagrams, and combinations of blocks in the flowchart illustrations and/or block diagrams, can be implemented by computer program instructions.</p>
<p id="p-0029" num="0028">These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions/acts specified in the flowchart and/or block diagram block or blocks. These computer program instructions may also be stored in a computer readable medium that can direct a computer or other programmable data processing apparatus to function in a particular manner, such that the instructions stored in the computer readable medium produce an article of manufacture including instruction means which implement the function/act specified in the flowchart and/or block diagram block or blocks.</p>
<p id="p-0030" num="0029">The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer-implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions/acts specified in the flowchart and/or block diagram block or blocks.</p>
<p id="p-0031" num="0030">Turning now to <figref idref="DRAWINGS">FIG. 1</figref> a block diagram of an exemplary data processing system operable for various embodiments of the disclosure is presented. In this illustrative example, data processing system <b>100</b> includes communications fabric <b>102</b>, which provides communications between processor unit <b>104</b>, memory <b>106</b>, persistent storage <b>108</b>, communications unit <b>110</b>, input/output (I/O) unit <b>112</b>, and display <b>114</b>.</p>
<p id="p-0032" num="0031">Processor unit <b>104</b> serves to execute instructions for software that may be loaded into memory <b>106</b>. Processor unit <b>104</b> may be a set of one or more processors or may be a multi-processor core, depending on the particular implementation. Further, processor unit <b>104</b> may be implemented using one or more heterogeneous processor systems in which a main processor is present with secondary processors on a single chip. As another illustrative example, processor unit <b>104</b> may be a symmetric multi-processor system containing multiple processors of the same type.</p>
<p id="p-0033" num="0032">Memory <b>106</b> and persistent storage <b>108</b> are examples of storage devices <b>116</b>. A storage device is any piece of hardware that is capable of storing information, such as, for example without limitation, data, program code in functional form, and/or other suitable information either on a temporary basis and/or a permanent basis. Memory <b>106</b>, in these examples, may be, for example, a random access memory or any other suitable volatile or non-volatile storage device. Persistent storage <b>108</b> may take various forms depending on the particular implementation. For example, persistent storage <b>108</b> may contain one or more components or devices. For example, persistent storage <b>108</b> may be a hard drive, a flash memory, a rewritable optical disk, a rewritable magnetic tape, or some combination of the above. The media used by persistent storage <b>108</b> also may be removable. For example, a removable hard drive may be used for persistent storage <b>108</b>.</p>
<p id="p-0034" num="0033">Communications unit <b>110</b>, in these examples, provides for communications with other data processing systems or devices. In these examples, communications unit <b>110</b> is a network interface card. Communications unit <b>110</b> may provide communications through the use of either or both physical and wireless communications links.</p>
<p id="p-0035" num="0034">Input/output unit <b>112</b> allows for input and output of data with other devices that may be connected to data processing system <b>100</b>. For example, input/output unit <b>112</b> may provide a connection for user input through a keyboard, a mouse, and/or some other suitable input device. Further, input/output unit <b>112</b> may send output to a printer. Display <b>114</b> provides a mechanism to display information to a user.</p>
<p id="p-0036" num="0035">Instructions for the operating system, applications and/or programs may be located in storage devices <b>116</b>, which are in communication with processor unit <b>104</b> through communications fabric <b>102</b>. In these illustrative examples the instructions are in a functional form on persistent storage <b>108</b>. These instructions may be loaded into memory <b>106</b> for execution by processor unit <b>104</b>. The processes of the different embodiments may be performed by processor unit <b>104</b> using computer-implemented instructions, which may be located in a memory, such as memory <b>106</b>.</p>
<p id="p-0037" num="0036">These instructions are referred to as program code, computer usable program code, or computer readable program code that may be read and executed by a processor in processor unit <b>104</b>. The program code in the different embodiments may be embodied on different physical or tangible computer readable media, such as memory <b>106</b> or persistent storage <b>108</b>.</p>
<p id="p-0038" num="0037">Program code <b>118</b> is located in a functional form on computer readable media <b>120</b> that is selectively removable and may be loaded onto or transferred to data processing system <b>100</b> for execution by processor unit <b>104</b>. Program code <b>118</b> and computer readable media <b>120</b> form computer program product <b>122</b> in these examples. In one example, computer readable media <b>120</b> may be in a tangible form, such as, for example, an optical or magnetic disc that is inserted or placed into a drive or other device that is part of persistent storage <b>108</b> for transfer onto a storage device, such as a hard drive that is part of persistent storage <b>108</b>. In a tangible form, computer readable media <b>120</b> also may take the form of a persistent storage, such as a hard drive, a thumb drive, or a flash memory that is connected to data processing system <b>100</b>. The tangible form of computer readable media <b>120</b> is also referred to as computer recordable storage media. In some instances, computer readable media <b>120</b> may not be removable.</p>
<p id="p-0039" num="0038">Alternatively, program code <b>118</b> may be transferred to data processing system <b>100</b> from computer readable media <b>120</b> through a communications link to communications unit <b>110</b> and/or through a connection to input/output unit <b>112</b>. The communications link and/or the connection may be physical or wireless in the illustrative examples. The computer readable media also may take the form of non-tangible media, such as communications links or wireless transmissions containing the program code.</p>
<p id="p-0040" num="0039">In some illustrative embodiments, program code <b>118</b> may be downloaded over a network to persistent storage <b>108</b> from another device or data processing system for use within data processing system <b>100</b>. For instance, program code stored in a computer readable storage medium in a server data processing system may be downloaded over a network from the server to data processing system <b>100</b>. The data processing system providing program code <b>118</b> may be a server computer, a client computer, or some other device capable of storing and transmitting program code <b>118</b>.</p>
<p id="p-0041" num="0040">The different components illustrated for data processing system <b>100</b> are not meant to provide architectural limitations to the manner in which different embodiments may be implemented. The different illustrative embodiments may be implemented in a data processing system including components in addition to or in place of those illustrated for data processing system <b>100</b>. Other components shown in <figref idref="DRAWINGS">FIG. 1</figref> can be varied from the illustrative examples shown. The different embodiments may be implemented using any hardware device or system capable of executing program code. As one example, the data processing system may include organic components integrated with inorganic components and/or may be comprised entirely of organic components excluding a human being. For example, a storage device may be comprised of an organic semiconductor.</p>
<p id="p-0042" num="0041">As another example, a storage device in data processing system <b>100</b> may be any hardware apparatus that may store data. Memory <b>106</b>, persistent storage <b>108</b> and computer readable media <b>120</b> are examples of storage devices in a tangible form.</p>
<p id="p-0043" num="0042">In another example, a bus system may be used to implement communications fabric <b>102</b> and may be comprised of one or more buses, such as a system bus or an input/output bus. Of course, the bus system may be implemented using any suitable type of architecture that provides for a transfer of data between different components or devices attached to the bus system. Additionally, a communications unit may include one or more devices used to transmit and receive data, such as a modem or a network adapter. Further, a memory may be, for example, memory <b>106</b> or a cache such as found in an interface and memory controller hub that may be present in communications fabric <b>102</b>.</p>
<p id="p-0044" num="0043">According to an illustrative embodiment, a computer-implemented process for updating and serialization, assigns a unique ID to each node created in a document, materializes a root element start tag of the document, materializes a start tag for a child element of the root element and determines whether a change is required. Responsive to a determination that a change is not required, skips content of the child element and responsive to a determination that a change is required, updates the child element to form an updated element. The computer-implemented process further pushes updated information for the child element into a mutation map and serializes the document using the mutation map.</p>
<p id="p-0045" num="0044">Using data processing system <b>100</b> of <figref idref="DRAWINGS">FIG. 1</figref> as an example, an illustrative embodiment provides the computer-implemented process stored in memory <b>106</b>, executed by processor unit <b>104</b>, for updating and serialization. Processor unit <b>104</b> assigns a unique ID to each node created in a document, materializes a root element start tag of the document, materializes a start tag for a child element of the root element and determines whether a change is required. Responsive to a determination that a change is not required, processor unit <b>104</b> skips content of the child element and responsive to a determination that a change is required, updates the child element to form an updated element in memory <b>106</b>. Processor unit <b>104</b> further pushes updated information for the child element into a mutation map maintained in storage devices <b>116</b> and serializes the document using the mutation map.</p>
<p id="p-0046" num="0045">In an alternative embodiment, program code <b>118</b> containing the computer-implemented process may be stored within computer readable media <b>120</b> as computer program product <b>122</b>. In another illustrative embodiment, the process for updating and serialization may be implemented in an apparatus comprising a communications fabric, a memory connected to the communications fabric, wherein the memory contains computer executable program code, a communications unit connected to the communications fabric, an input/output unit connected to the communications fabric, a display connected to the communications fabric, and a processor unit connected to the communications fabric. The processor unit of the apparatus executes the computer executable program code to direct the apparatus to perform the process.</p>
<p id="p-0047" num="0046">With reference to <figref idref="DRAWINGS">FIG. 2</figref>, a block diagram of an update and serialization system in accordance with various embodiments of the disclosure is presented. Update and serialization system <b>200</b> is an example of an embodiment of the disclosure.</p>
<p id="p-0048" num="0047">Update and serialization system <b>200</b> is an enhanced system that avoids materializing data into objects as much as possible. A &#x201c;lazy materialization&#x201d; technique provided by update and serialization system <b>200</b> enables an application to randomly update parts of a document efficiently because a performance impact of initiating new objects in memory is reduced. The enhanced system provides a capability, including mutation map <b>202</b>, sub-tree fragment process <b>204</b>, unique ID process <b>206</b>, mutation map process <b>208</b> and enhanced parser <b>210</b>, to re-use original document data for efficient hybrid serialization between mutated objects and original unchanged portions of the document.</p>
<p id="p-0049" num="0048">Deferred materialization while randomly updating the document is provided through use of sub-tree fragment process <b>204</b>. Sub-tree fragment process <b>204</b> is a process that encapsulates a specific region of a document and corresponding context information to enable enhanced parser <b>210</b> to resume parsing of a fragment at a later time. Concurrent with each update, mutation map process <b>208</b> provides a listing of all the updates and regions of unchanged data between updated nodes maintained in a data structure of mutation map <b>202</b>. This unique data structure enables optimized serialization, which will not materialize any unnecessary additional nodes.</p>
<p id="p-0050" num="0049">A skipped sub-tree fragment reference is used to serialize the contents of a node that has been moved to a different container, (and updated) without materializing a single associated sub-tree node, which further demonstrates the effectiveness of mutation map <b>202</b> data structure. The enhanced system provides a capability to move containers from one XML document in memory to another document, change the name, and serialize the data efficiently.</p>
<p id="p-0051" num="0050">Mutation map <b>202</b> is a data structure that can have two possible entries (elements) in the form of a reference to a node object that has been mutated, or a reference to a native representation of a certain region of the document. The purpose of mutation map <b>202</b> is to provide a &#x201c;serialization map&#x201d; that will indicate to update and serialization system framework, which native sections to re-use and which mutated nodes to traverse, all in proper document order to provide an accurate and correct output. This hybrid data structure provides a capability for efficient serialization of a mutated document.</p>
<p id="p-0052" num="0051">Mutation map process <b>208</b> is a process used to create and maintain mutation map <b>202</b>. Mutation map process <b>208</b> is a process for maintaining a proper sequence of items associated with a document being processed. The items refer to native sections to re-use and mutated nodes to traverse.</p>
<p id="p-0053" num="0052">Sub-tree fragment process <b>204</b> is a process providing a capability to define and encapsulate information related to a document fragment into a single object called a skipped sub-tree fragment. The skipped sub-tree fragment is stored within the skipped element of the document and is used when the content is traversed at a later time.</p>
<p id="p-0054" num="0053">Unique ID process <b>206</b> is a process providing a capability to assign a unique integer value to each node of a document. Assignment of a unique ID enables a node comparison operation to identify correct sequencing of a node relative to another node in the document stream.</p>
<p id="p-0055" num="0054">Enhanced parser <b>210</b> provides a capability to parse extensible markup language documents using the other components of update and serialization system <b>200</b>. Enhanced parser <b>210</b> is enabled to use mutation map <b>202</b> for efficient serialization of an updated document.</p>
<p id="p-0056" num="0055">With reference to <figref idref="DRAWINGS">FIG. 3</figref>, a textual representation of an example of a document portion, in accordance with one embodiment of the disclosure is presented. Document portion <b>300</b> is a code snippet representing an element hierarchy in a nested XML document.</p>
<p id="p-0057" num="0056">Using the example of <figref idref="DRAWINGS">FIG. 3</figref> a series of operations is performed on elements of document portion <b>300</b> including changing a value of &#x3c;second_child&#x3e; <b>312</b> to &#x201c;5678,&#x201d; changing a value of &#x3c;inner_second_child&#x3e; <b>308</b> to &#x201c;new value&#x201d; and serialize the updated document.</p>
<p id="p-0058" num="0057">To accomplish changing a value of &#x3c;second_child&#x3e; <b>312</b> to &#x201c;5678,&#x201d;&#x3c;root_element&#x3e; <b>302</b> is materialized. Only the start-tag of &#x3c;root_element&#x3e; <b>302</b> is materialized initially. A child of &#x3c;root_element&#x3e; <b>302</b>, in the form of &#x3c;first_child&#x3e; <b>304</b> is materialized as well. Again only the start-tag of &#x3c;first_child&#x3e; <b>304</b> is materialized initially. The contents of &#x3c;first_child&#x3e; <b>304</b> bounded by &#x3c;first_child&#x3e; <b>304</b> start-tag and &#x3c;first_child&#x3e; <b>310</b> end-tag are skipped using a &#x201c;sub-tree fragment process&#x201d; described later in <figref idref="DRAWINGS">FIG. 7</figref>.</p>
<p id="p-0059" num="0058">Another process used concurrently, is a process for unique ID assignment of nodes. This process provides a capability to insert elements into a &#x201c;mutation map&#x201d; data structure. The process for unique ID assignment of nodes further enables rapid comparison of the document order of two nodes. The process for unique ID assignment of nodes is further described in <figref idref="DRAWINGS">FIG. 8</figref>.</p>
<p id="p-0060" num="0059">After skipping the element of &#x3c;first_child&#x3e; <b>304</b> and storing the associated skipped sub-tree fragment inside of the element, &#x3c;second_child&#x3e; <b>312</b> is materialized and the value is changed. As soon as the value of &#x3c;second_child&#x3e; <b>312</b> is changed, a &#x201c;mutation map&#x201d; process is used. The mutation map process is further described in <figref idref="DRAWINGS">FIG. 9</figref>.</p>
<p id="p-0061" num="0060">The operation of changing the value of &#x3c;second_child&#x3e; <b>312</b> is complete. Returning to &#x3c;first_child&#x3e; <b>304</b> an element of &#x3c;inner_first_child&#x3e; <b>306</b> is processed to materialize only the start-tag. The remainder of &#x3c;inner_first_child&#x3e; <b>306</b> is skipped using the sub-tree fragment process, to arrive at &#x3c;inner_second_child&#x3e; <b>308</b>, which is now updated. The process of updating &#x3c;inner_second_child&#x3e; <b>308</b> pushes the element into a mutation map before the entry of &#x3c;second_child&#x3e; <b>312</b>. The order is determined by comparison of the values of the two node IDs. The operation of changing the value of &#x3c;inner_second_child&#x3e; <b>308</b> to &#x201c;new value&#x201d; is complete.</p>
<p id="p-0062" num="0061">Examination of the mutation map reveals a set of items reflecting the operations performed, including:</p>
<p id="h-0006" num="0000">item 1=reference to the region from the beginning of document up to the character before the &#x3c;inner_second_child&#x3e; <b>308</b> start tag,</p>
<p id="h-0007" num="0000">item 2=reference to the mutated &#x3c;inner_second_child&#x3e; <b>308</b> node,</p>
<p id="h-0008" num="0000">item 3=reference to region from the character after the &#x3c;inner_second_child&#x3e; <b>308</b> end tag up to the character before &#x3c;second_child&#x3e; <b>312</b></p>
<p id="h-0009" num="0000">item 4=reference to the mutated &#x3c;second_child&#x3e; <b>312</b> node,</p>
<p id="h-0010" num="0000">item 5=reference to the region from the character after the &#x3c;second_child&#x3e; <b>312</b> end tag up to the end of the document.</p>
<p id="p-0063" num="0062">The mutation map efficiently &#x201c;maps&#x201d; the serialization process. The native references to certain regions of the document will be used to output that data quickly, while the mutated nodes will be traversed to output respective updated data. The end result will be an updated document that is correct and accurate. The processes just described improve efficiency by avoiding unnecessary object materialization. The serialization operation for the document is complete.</p>
<p id="p-0064" num="0063">With reference to <figref idref="DRAWINGS">FIG. 4</figref>, a textual representation of another example of a portion of a document in accordance with various embodiments of the disclosure is presented. Document portion <b>400</b> provides a code snippet for an example of randomly choosing members of a document, moving and updating members into a new container and serializing a newly built XML document using techniques of update and serialization system <b>200</b> of <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0065" num="0064">In this example members of an incoming message request are selected, and another XML document is created, which is serialized for a framework to consume. The example includes an operation which obtains a value of &#x3c;item:policyID&#x3e; <b>406</b>, appends a string of &#x201c;123&#x201d; and pushes the updated value into a new child (called &#x3c;customer_ID&#x3e;) of &#x3c;customer_archive&#x3e;. The example further obtains an item of &#x3c;form:originalReport&#x3e; <b>404</b> and pushes the item into a new child (called &#x3c;incident_report&#x3e;) of &#x3c;customer_archive&#x3e;. The example further serializes the newly built &#x3c;customer_archive&#x3e; document.</p>
<p id="p-0066" num="0065">When performing the first operation, nodes of &#x3c;form:requestInfo&#x3e; <b>402</b> and &#x3c;form:originalReport&#x3e; <b>404</b> are skipped using the sub-tree fragment skipping process of <figref idref="DRAWINGS">FIG. 7</figref>. The changed (appended &#x201c;123&#x201d;) value of &#x3c;item:policyID&#x3e; <b>406</b> is copied into the &#x3c;customer_archive&#x3e;, with the new name &#x3c;customer_ID&#x3e;). Note that &#x3c;form:originalReport&#x3e; <b>404</b> had an item comprising a &#x201c;10 MB&#x201d; child, which was not materialized because the parent element was skipped. Because a new child is added to the new XML document (with root &#x3c;customer_archive&#x3e;), the new child will be pushed into the new document mutation map, using the mutation map process of <figref idref="DRAWINGS">FIG. 9</figref>.</p>
<p id="p-0067" num="0066">In the second operation &#x3c;form:originalReport&#x3e; <b>404</b> is revisited, and a reference to it is copied into &#x3c;customer_archive&#x3e; by mutating just the start-tag of &#x3c;form:originalReport&#x3e; <b>404</b> to make the name &#x3c;incident_report&#x3e;. Using the unique ID process of <figref idref="DRAWINGS">FIG. 8</figref>, a determination is made that the new node comes before the mutated &#x3c;customer_ID&#x3e; node. A feature of the mutation map process of <figref idref="DRAWINGS">FIG. 9</figref> is used to avoid unnecessary materialization. This node contains sub-tree contents, which are intact and contain over 10 MB of data. Because the node was skipped once; the boundaries of an associated sub-tree region are already identified. This information is placed inside a &#x201c;region reference&#x201d; item that follows the &#x3c;incident_report&#x3e; item entry in the mutation map.</p>
<p id="p-0068" num="0067">The serialization operation may now be performed efficiently. Using the sequence indicated in the mutation map, serialization begins with the start-tag of &#x3c;incident_report&#x3e;, followed by the native region of &#x3c;form:originalReport&#x3e; <b>404</b> (without materialization), followed by the mutated node &#x3c;customer_ID&#x3e;.</p>
<p id="p-0069" num="0068">This above example further demonstrates the efficiency of random update and serialization system <b>200</b> of <figref idref="DRAWINGS">FIG. 2</figref>. Embodiments of the disclosure can be applied to a vast series of scenarios including query and copy of specific values, modification of elements anywhere, in a document that require the resulting mutated document to be serialized and be consumed by a next application.</p>
<p id="p-0070" num="0069">With reference to <figref idref="DRAWINGS">FIG. 5</figref>, a textual representation of an encapsulation example in accordance with various embodiments of the disclosure is presented. Example <b>500</b> provides a sample of encapsulation of context information used to ensure serialization is effectively performed using techniques of update and serialization system <b>200</b> of <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0071" num="0070">Using techniques of update and serialization system <b>200</b> of <figref idref="DRAWINGS">FIG. 2</figref> all contexts related to the skipped content of an XML document, such as namespaces and schema information is encapsulated. The technique also provides a capability for serialization-time namespace handling in a manner not previously supported in typical current solutions. Using example <b>500</b>, consider document <b>502</b> and document <b>504</b>.</p>
<p id="p-0072" num="0071">Document <b>502</b> is traversed to reach &#x3c;payload&#x3e; element <b>506</b>, without materializing any of sub-tree elements in document <b>502</b>. A move of &#x3c;payload&#x3e; element <b>506</b> from document <b>502</b> to the last child of element &#x3c;target&#x3e; <b>508</b> in document <b>504</b> is scheduled. Placement of the element is after header element <b>510</b> at proposed location <b>512</b>. Details of this mutation (the &#x201c;move&#x201d;) illustrate how the update and serialization process of the disclosure optimizes for random updates of an XML document followed by serialization.</p>
<p id="p-0073" num="0072">The contents of &#x3c;payload&#x3e; element <b>506</b> are skipped but information associated with the in-scope namespaces, schema information, parsing DFA, is gathered. This information is encapsulated into a fragment. When the fragment (comprising a skipped sub-tree) is moved into a new target, one of the previous in-scope namespaces (ns0) is identified as no longer in-scope in the new target. However the namespace might be needed in an un-materialized portion of &#x3c;payload&#x3e; element <b>506</b>. Therefore the namespace declaration is carried forward with &#x3c;payload&#x3e; element <b>506</b>, as seen in <figref idref="DRAWINGS">FIG. 6</figref>.</p>
<p id="p-0074" num="0073">With reference to <figref idref="DRAWINGS">FIG. 6</figref>, a textual representation of a serialization example in accordance with various embodiments of the disclosure is presented. Example <b>600</b> provides a continuation of the encapsulation of context information of <figref idref="DRAWINGS">FIG. 5</figref> to ensure serialization is effectively performed using techniques of update and serialization system <b>200</b> of <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0075" num="0074">Code snippet <b>602</b> depicts &#x3c;payload&#x3e; element <b>506</b> relocated into document <b>504</b> of <figref idref="DRAWINGS">FIG. 5</figref>. In terms of serialization, &#x3c;payload&#x3e; element <b>506</b> can now safely be serialized on its own (re-using the bytes for the un-materialized portion) while still producing a well-formed XML document. Typical previous solutions related to this subject do not handle namespaces because of issues such as this, where special handling and guards must be in place to ensure all serialized documents can be read again as well-formed XML documents.</p>
<p id="p-0076" num="0075">To expand on this example, schema information that was encapsulated with this fragment can be examined. For example in code snippet <b>604</b>, &#x3c;first_child&#x3e; in &#x3c;payload&#x3e; element <b>606</b> could have a schema element declaration that specified a default value of &#x201c;ON&#x201d; for an attribute called &#x201c;performance&#x201d;. An illustrative embodiment keeps track of the schema type of the skipped element and the proper deterministic finite automaton (DFA) and related states internal to an enhanced parser, providing a capability to validate the skipped and moved &#x3c;first_child&#x3e; element and properly receive the &#x201c;performance&#x201d; attribute from the schema. Therefore the correct form of document <b>604</b> can be serialized to become document <b>604</b> comprising &#x3c;payload&#x3e; element <b>606</b>.</p>
<p id="p-0077" num="0076">Having namespace and schema related information available during serialization, even after mutation (the move) has occurred across documents, can be essential in producing well-formed and valid XML documents. The update and serialization framework double checks to ensure data to be serialized is well formed by checking in-scope namespaces against namespaces declared in the element that will be serialized. In the original document, document <b>502</b> of <figref idref="DRAWINGS">FIG. 5</figref>, if &#x3c;payload&#x3e; element <b>506</b> was serialized immediately without moving the element into another tree first, the update and serialization framework would first mutate the start tag of &#x3c;payload&#x3e; element <b>506</b> to contain the namespace declaration for &#x201c;ns0&#x201d;, and then proceed to serialize with a mutation map hybrid structure which is the mutated start tag of &#x3c;payload&#x3e; and the un-materialized sub-tree. The result will be the well-formed XML document of document <b>608</b>.</p>
<p id="p-0078" num="0077">With reference to <figref idref="DRAWINGS">FIG. 7</figref>, a flowchart of a sub-tree fragment process example in accordance with various embodiments of the disclosure is presented. Process <b>700</b> provides an example of a sub-tree fragment process used in the skipping of element contents of a document portion <b>300</b> of <figref idref="DRAWINGS">FIG. 3</figref> using techniques of update and serialization system <b>200</b> of <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0079" num="0078">Process <b>700</b> starts (step <b>702</b>) and identifies a skipped sub-tree region to form an identified region (step <b>704</b>). For example, a region to be skipped may be defined by data corresponding to the area that starts at the character following the &#x3c;first_child&#x3e; <b>304</b> start-tag of <figref idref="DRAWINGS">FIG. 3</figref> and ends at the character preceding the &#x3c;/first_child&#x3e; <b>310</b> end-tag. An important distinction is made between a reference and a copy of a document. Typically every parser uses some form of temporary internal storage of the document, such as data buffers, and it is this internal representation of the document that should be referenced, for example, the start and end offset of the skipped region. Process <b>700</b> creates a reference to data of the identified region (step <b>706</b>).</p>
<p id="p-0080" num="0079">Process <b>700</b> collects all contexts pertaining to the skipped sub-tree (step <b>708</b>). The context information typically includes such items as namespace declarations, schema types, parser events, DFA states, and other descriptive information related to the data. Process <b>700</b> encapsulates the content data and the context into a single object known as a &#x201c;skipped sub-tree fragment&#x201d; (step <b>710</b>). Process <b>700</b> stores the &#x201c;skipped sub tree fragment&#x201d; into a skipped element (step <b>712</b>) and terminates (step <b>714</b>). In the example, the &#x201c;skipped sub tree fragment&#x201d; is stored into the skipped element of &#x3c;first_child&#x3e; <b>304</b> of <figref idref="DRAWINGS">FIG. 3</figref> to be used if the content is traversed at a later time.</p>
<p id="p-0081" num="0080">With reference to <figref idref="DRAWINGS">FIG. 8</figref>, a flowchart of a unique identifier process in accordance with various embodiments of the disclosure is presented. Process <b>800</b> provides an example of a unique identifier process for document order comparison used in the techniques of update and serialization system <b>200</b> of <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0082" num="0081">Process <b>800</b> starts (step <b>802</b>) and initializes a global integer counter for each node (step <b>804</b>). A counter maintains an identifying unique value or count for each of the nodes of a document being processed. Process <b>800</b> builds a node (step <b>806</b>). Process <b>800</b> increments a counter for the node that was built (step <b>808</b>). For example, in a hierarchy of nodes, each node of a lower level of a hierarchy has a unique number identifying the node and indicating a relative position with respect to other nodes in the hierarchy. Until a node is skipped, the count number is assigned in normal order. For example, a first element of a document, &#x3c;root_element&#x3e;, receives an identifier of 1 and a next element in sequence, a &#x3c;first_child&#x3e;, receives an identifier of 2. When a node is skipped, the counter continues regularly because there is no need to keep track of how many nodes are skipped, which makes the process more efficient. Continuing the example, a next sequential element, &#x3c;second_child&#x3e;, receives an identifier of 3.</p>
<p id="p-0083" num="0082">Process <b>800</b> determines whether a skipped node is revisited (step <b>810</b>). When a determination is made that a skipped node is revisited a &#x201c;yes&#x201d; result is obtained. When a determination is made that a skipped node is not revisited a &#x201c;no&#x201d; result is obtained. When a &#x201c;yes&#x201d; result is obtained, a &#x201c;.&#x201d; is appended for each sub-tree level of the node to form a node ID (step <b>812</b>). For example, when the skipped &#x3c;first_child&#x3e; node is revisited and traversed to children, an ID of 1.1 is assigned to an &#x3c;inner_first_child&#x3e; node, and ID of 1.1.1 to a corresponding first child of the &#x3c;inner_first_child&#x3e; node. When a &#x201c;no&#x201d; result is obtained, process <b>800</b> skips to step <b>814</b>.</p>
<p id="p-0084" num="0083">Process <b>800</b> compare two nodes for document order, using node IDs (step <b>814</b>). Node ID comparison is performed using the string of level identifiers for each node of the comparison. Process <b>800</b> performs for every &#x201c;level&#x201d; (a level is the number between the dots &#x201c;.&#x201d;), a comparison of the identifier numbers of each node. Process <b>800</b> identifies a node with a lower identifier, of the pair of nodes to form an identified node (step <b>816</b>). Process <b>800</b> places the lowest identified node first in the document (step <b>818</b>) and terminates thereafter. For example, a deeply nested node with an identifier of 3.4.5.3.7.18.2 can be very quickly determined to come prior to the node with an identifier of 3.4.5.3.7.18.3. Sequencing of nodes may thus be performed to ensure document order.</p>
<p id="p-0085" num="0084">With reference to <figref idref="DRAWINGS">FIG. 9</figref>, a flowchart of a &#x201c;mutation map&#x201d; process example in accordance with various embodiments of the disclosure is presented. Process <b>900</b> provides an example of a &#x201c;mutation map&#x201d; data structure and associated process used in the techniques of update and serialization system <b>200</b> of <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0086" num="0085">The &#x201c;mutation map&#x201d; is a data structure that can have two possible types of entries or elements in the form of a reference to a node object that has been mutated, or a reference to a native representation of a certain region of the document. The purpose of the &#x201c;mutation map&#x201d; is to provide a &#x201c;serialization map&#x201d; that defines what native sections to re-use and what mutated nodes to traverse, all in document order to provide an accurate and correct output. This hybrid data structure provides a capability for fast serialization of a mutated document.</p>
<p id="p-0087" num="0086">Process <b>900</b> starts (step <b>902</b>) and receives a mutated node for insertion in a mutation map data structure to form a receive node (step <b>904</b>). Process <b>900</b> identifies an insertion point for the received node to form an identified insertion point (step <b>906</b>). Process <b>900</b> inserts a reference to the received node at the identified insertion point into a mutation map (step <b>908</b>).</p>
<p id="p-0088" num="0087">The map is searched (binary search) to find the correct insertion spot for the node that has been mutated using a unique ID previously assigned using the unique identifier process <b>800</b> of <figref idref="DRAWINGS">FIG. 8</figref>. The incoming mutated node is compared with all other nodes inside the mutation map to maintain the mutation map in document order.</p>
<p id="p-0089" num="0088">Process <b>900</b> calculates a native representation (should be simple pointers such as object/integer pair for buffers) corresponding to a region between the mutated node, as the received node, and siblings of the mutated node in the mutation map (step <b>910</b>). Process <b>900</b> terminates thereafter (step <b>912</b>).</p>
<p id="p-0090" num="0089">With reference to <figref idref="DRAWINGS">FIG. 10</figref>, a flowchart of a serialization process example in accordance with various embodiments of the disclosure is presented. Process <b>1000</b> provides an example of a portion of a serialization process used in the update and serialization system <b>200</b> of <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0091" num="0090">Process <b>1000</b> starts (step <b>1002</b>) and determines whether the mutated node has contents mutated (step <b>1004</b>). When a determination is made that the mutated node has contents mutated, a &#x201c;yes&#x201d; result is obtained. When a determination is made that the mutated node does not have contents mutated, a &#x201c;no&#x201d; result is obtained. When a &#x201c;yes&#x201d; result is obtained process <b>1000</b> traverses content of the mutated node during serialization (step <b>1006</b>) with process <b>1000</b> terminating thereafter (step <b>1010</b>).</p>
<p id="p-0092" num="0091">When a &#x201c;no&#x201d; result is obtained in step <b>1004</b>, process <b>1000</b> defines a region item as a next item in the mutation map (step <b>1008</b>) with process <b>1000</b> terminating thereafter (step <b>1010</b>). For nodes that have only the start-tag mutated (including namespace and attribute declarations), the mutation map will have a more advanced &#x201c;region item&#x201d; as a next item in the map. The region of native data that can be re-used includes the sub-tree content of the node. Processing is typically fast when the node itself has been skipped, because a skipped sub-tree fragment reference is used to identify exact boundaries of the content reference.</p>
<p id="p-0093" num="0092">With reference to <figref idref="DRAWINGS">FIG. 11</figref>, a flowchart of an update and serialization process example in accordance with various embodiments of the disclosure is presented. Process <b>1100</b> provides an example of an update and serialization process used in update and serialization system <b>200</b> of <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0094" num="0093">Process <b>1100</b> starts (step <b>1102</b>) and assigns a unique ID to each node created (step <b>1104</b>). Assigning a unique ID uses the unique identifier process of process <b>800</b> of <figref idref="DRAWINGS">FIG. 8</figref>. Process <b>1100</b> materializes a root element start tag (step <b>1106</b>). The root element is the first element of the document structure being processed. Process <b>1100</b> materializes a child element start tag (step <b>1108</b>). The child element is a first child of the root element.</p>
<p id="p-0095" num="0094">Process <b>1100</b> determines whether a change is required (step <b>1110</b>). A change may be required to the child element to update information associated with the child element. When a determination is made that a change is required, a &#x201c;yes&#x201d; result is obtained. When a determination is made that a change is not required, a &#x201c;no&#x201d; result is obtained.</p>
<p id="p-0096" num="0095">When a &#x201c;no&#x201d; result is obtained in step <b>1110</b>, process <b>1100</b> skips the content of the child element using a sub-tree fragment process described in sub-tree fragment process <b>700</b> of <figref idref="DRAWINGS">FIG. 7</figref>. When a &#x201c;yes&#x201d; result is obtained in step <b>1110</b>, process <b>1100</b> updates the element to form an updated element (step <b>1112</b>). Process <b>1100</b> pushes information from the updated element to a mutation map using mutation map process of process <b>900</b> of <figref idref="DRAWINGS">FIG. 9</figref> (step <b>1114</b>).</p>
<p id="p-0097" num="0096">Process <b>1100</b> determines whether a next child exists (step <b>1118</b>). When a determination is made that child exists, a &#x201c;yes&#x201d; result is obtained. When a determination is made that a child does not exist, a &#x201c;no&#x201d; result is obtained. When a &#x201c;yes&#x201d; result is obtained, process <b>1100</b> loops back to step <b>1108</b> to process remaining child elements. When a &#x201c;no&#x201d; result is obtained process <b>1100</b> determines whether an inner child exists (step <b>1120</b>). When a determination is made that an inner child exists, a &#x201c;yes&#x201d; result is obtained. When a determination is made that an inner child does not exist, a &#x201c;no&#x201d; result is obtained.</p>
<p id="p-0098" num="0097">When a &#x201c;yes&#x201d; result is obtained, process <b>1100</b> loops back to step <b>1108</b> to process remaining inner child elements. When a &#x201c;no&#x201d; result is obtained, process <b>1100</b> serializes the document in document order (step <b>1122</b>) and terminates thereafter (step <b>1124</b>).</p>
<p id="p-0099" num="0098">Thus is provided in one illustrative embodiment, a computer-implemented process for updating and serialization, which assigns a unique ID to each node created in a document, materializes a root element start tag of the document, materializes a start tag for a child element of the root element and determines whether a change is required. Responsive to a determination that a change is not required, skips content of the child element and responsive to a determination that a change is required, updates the child element to form an updated element. The computer-implemented process further pushes updated information for the child element into a mutation map and serializes the document using the mutation map.</p>
<p id="p-0100" num="0099">The flowchart and block diagrams in the figures illustrate the architecture, functionality, and operation of possible implementations of systems, methods, and computer program products according to various embodiments of the present invention. In this regard, each block in the flowchart or block diagrams may represent a module, segment, or portion of code, which comprises one or more executable instructions for implementing a specified logical function. It should also be noted that, in some alternative implementations, the functions noted in the block might occur out of the order noted in the figures. For example, two blocks shown in succession may, in fact, be executed substantially concurrently, or the blocks may sometimes be executed in the reverse order, depending upon the functionality involved. It will also be noted that each block of the block diagrams and/or flowchart illustration, and combinations of blocks in the block diagrams and/or flowchart illustration, can be implemented by special purpose hardware-based systems that perform the specified functions or acts, or combinations of special purpose hardware and computer instructions.</p>
<p id="p-0101" num="0100">The corresponding structures, materials, acts, and equivalents of all means or step plus function elements in the claims below are intended to include any structure, material, or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description, but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.</p>
<p id="p-0102" num="0101">The invention can take the form of an entirely hardware embodiment, an entirely software embodiment or an embodiment containing both hardware and software elements. In a preferred embodiment, the invention is implemented in software, which includes but is not limited to firmware, resident software, microcode, and other software media that may be recognized by one skilled in the art.</p>
<p id="p-0103" num="0102">It is important to note that while the present invention has been described in the context of a fully functioning data processing system, those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in the form of a computer readable medium of instructions and a variety of forms and that the present invention applies equally regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable-type media, such as a floppy disk, a hard disk drive, a RAM, CD-ROMs, DVD-ROMs, and transmission-type media, such as digital and analog communications links, wired or wireless communications links using transmission forms, such as, for example, radio frequency and light wave transmissions. The computer readable media may take the form of coded formats that are decoded for actual use in a particular data processing system</p>
<p id="p-0104" num="0103">A data processing system suitable for storing and/or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code, bulk storage, and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.</p>
<p id="p-0105" num="0104">Input/output or I/O devices (including but not limited to keyboards, displays, pointing devices, etc.) can be coupled to the system either directly or through intervening I/O controllers.</p>
<p id="p-0106" num="0105">Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems, cable modems, and Ethernet cards are just a few of the currently available types of network adapters.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A computer-implemented method for updating and serialization of a document, comprising:
<claim-text>assigning a unique ID to each node created in the document according to a global integer counter for each node built, comprising:
<claim-text>determining whether a given node is revisited;</claim-text>
<claim-text>in response to determining that the given node is revisited, appending a predefined symbol for each sub-tree level of the given node to a node ID of the given node to form a current node ID;</claim-text>
</claim-text>
<claim-text>materializing a root node start tag of the document;</claim-text>
<claim-text>materializing a start tag for a first child node, a second child node, and a third child node of the root node, wherein the first child node, the second child node, and the third child node are sibling nodes, wherein the second child node is ordered between the first child node and the third child node;</claim-text>
<claim-text>determining whether a data value change to the first child node, the second child node, and the third child node is required;</claim-text>
<claim-text>in response to determining that the data value change to the first child node and any sub-nodes of the first child node are not required, skipping first content of the first child node and the sub-nodes of the first child node, and creating a first reference to the first skipped content;</claim-text>
<claim-text>in response to determining that the data value change to the second child node is required, creating an updated node in memory to replace the second child node and creating a second reference to the updated node;</claim-text>
<claim-text>in response to determining that the data value change to the third child node any sub-nodes of the third child node are not required, skipping second content of the third child content and the sub-nodes of the third child nodes, and creating a third reference to the second skipped content;</claim-text>
<claim-text>pushing the first reference, the second reference, and the third reference into a mutation map; and</claim-text>
<claim-text>serializing the document using the first reference, the second reference, and the third reference in the mutation map, wherein the serialized document comprises the first skipped content obtained from the document, the updated node, and the second skipped content obtained from the document.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The computer-implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the assigning the unique ID to each node created in the document further comprises:
<claim-text>comparing two node IDs for a document order using the current node IDs;</claim-text>
<claim-text>identifying a node with a lower node ID to form an identified node; and</claim-text>
<claim-text>placing the identified node in the document prior to a remaining node of the two node IDs.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The computer-implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the creating of the first reference to the skipped content further comprises:
<claim-text>identifying a skipped sub-tree region of the document to form an identified region;</claim-text>
<claim-text>creating the first reference to data of the identified region;</claim-text>
<claim-text>collecting contexts pertaining to the identified region to form collected contexts;</claim-text>
<claim-text>encapsulating data content and the collected contexts into a skipped sub-tree fragment; and</claim-text>
<claim-text>storing the skipped sub-tree fragment into a skipped node.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The computer-implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the pushing of first reference and the second reference node into the mutation map further comprises:
<claim-text>receiving a mutated node to form a received node;</claim-text>
<claim-text>identifying an insertion point in the mutation map for the received node to form an identified insertion point;</claim-text>
<claim-text>adding the second reference to the received node at the identified insertion point in the mutation map; and</claim-text>
<claim-text>calculating a native representation corresponding to a region between the received node and siblings of the received node.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The computer-implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the serializing the document using the mutation map further comprises:
<claim-text>determining whether a received node has contents mutated;</claim-text>
<claim-text>in response to determining that the received node does not have contents mutated, defining a region item as a next item in the mutation map using the first reference for reuse of the skipped content from the document; and</claim-text>
<claim-text>in response to determining that the received node has contents mutated, traversing content of the received node as a mutated node using the second reference.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The computer-implemented method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the region item further comprises:
<claim-text>a region of native data suitable for the reuse comprising sub-tree content associated with the received node.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. A computer program product for updating and serialization a document, comprising:
<claim-text>a computer readable storage device containing computer executable program code stored thereon, the computer executable program code comprising:</claim-text>
<claim-text>computer executable program code for assigning a unique ID to each node created in the document according to a global integer counter for each node built, comprising:
<claim-text>computer executable program code for determining whether a given node is revisited;</claim-text>
<claim-text>computer executable program code for, in response to determining that the given node is revisited, appending a predefined symbol for each sub-tree level of the given node to a node ID of the skipped node to form a current node ID;</claim-text>
</claim-text>
<claim-text>computer executable program code for materializing a root node start tag of the document;</claim-text>
<claim-text>computer executable program code for materializing a start tag for a first child node, a second child node, and a third child node of the root node, wherein the first child node, the second child node, and the third child node are sibling nodes, wherein the second child node is ordered between the first child node and the third child node;</claim-text>
<claim-text>computer executable program code for determining whether a data value change to the first child node, the second child node, and the third child node is required;</claim-text>
<claim-text>computer executable program code for skipping first content of the first child node and any sub-nodes of the first child node, and creating a first reference to the first skipped content in response to determining that the data value change to the first child node and the sub-nodes of the first child node is not required;</claim-text>
<claim-text>computer executable program code for creating an updated node in memory to replace the second child node and creating a second reference to the updated node in response to determining that the data value change to the second child node is required;</claim-text>
<claim-text>computer executable program code for skipping second content of the third child node and any sub-nodes of the third child node, and creating a third reference to the second skipped content in response to determining that the data value change to the third child node and the sub-nodes of the third child node is not required;</claim-text>
<claim-text>computer executable program code for pushing the first reference, the second reference, and the third reference into a mutation map; and</claim-text>
<claim-text>computer executable program code for serializing the document using the first reference, the second reference, and the third reference in the mutation map, wherein the serialized document comprises the first skipped content obtained from the document, the updated node, and the second skipped content obtained from the document.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The computer program product of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein computer executable program code for assigning the unique ID to each node created in the document further comprises:
<claim-text>computer executable program code for comparing two node IDs for a document order using the current node IDs;</claim-text>
<claim-text>computer executable program code for identifying a node with a lower node ID to form an identified node; and</claim-text>
<claim-text>computer executable program code for placing the identified node in the document prior to a remaining node of the two node IDs.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The computer program product of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein computer executable program code for creating the first reference to the skipped content further comprises:
<claim-text>computer executable program code for identifying a skipped sub-tree region of the document to form an identified region;</claim-text>
<claim-text>computer executable program code for creating the first reference to data of the identified region;</claim-text>
<claim-text>computer executable program code for collecting contexts pertaining to the identified region to form collected contexts;</claim-text>
<claim-text>computer executable program code for encapsulating data content and the collected contexts into a skipped sub-tree fragment; and</claim-text>
<claim-text>computer executable program code for storing the skipped sub-tree fragment into a skipped node.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The computer program product of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein computer executable program code for pushing the first reference and the second reference into the mutation map further comprises:
<claim-text>computer executable program code for receiving a mutated node to form a received node;</claim-text>
<claim-text>computer executable program code for identifying an insertion point in the mutation map for the received node to form an identified insertion point;</claim-text>
<claim-text>computer executable program code for adding the second reference to the received node at the identified insertion point in the mutation map; and</claim-text>
<claim-text>computer executable program code for calculating a native representation corresponding to a region between the received node and siblings of the received node.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The computer program product of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein computer executable program code for serializing the document using the mutation map further comprises:
<claim-text>computer executable program code for determining whether a received node has contents mutated;</claim-text>
<claim-text>computer executable program code for defining a region item as a next item in the mutation map using the first reference for reuse of the skipped content from the document, in response to determining that the received node des onto have contents mutated; and</claim-text>
<claim-text>computer executable program code for traversing content of the received node as a mutated node using the second reference, in response to determining that the received node has contents mutated.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The computer program product of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the region item further comprises:
<claim-text>a region of native data suitable for the reuse comprising sub-tree content associated with the received node.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. A system for updating and serialization a document, comprising:
<claim-text>a communications fabric;</claim-text>
<claim-text>a memory operatively coupled to the communications fabric, wherein the memory comprises computer executable program code; and</claim-text>
<claim-text>a processor unit operatively coupled to the communications fabric, wherein the processor unit executes the computer executable program code to direct the system to:
<claim-text>assign a unique ID to each node created in the document according to a global integer counter for each node built, comprising:
<claim-text>determine whether a given node is revisited;</claim-text>
<claim-text>in response to determining that the given node is revisited, append a predefined symbol for each sub-tree level of the given node to a node ID of the given node to form a current node ID;</claim-text>
</claim-text>
<claim-text>materialize a root node start tag of the document;</claim-text>
<claim-text>materialize a start tag for a first child node, a second child node, and a third child node of the root node, wherein the first child node, the second child node, and the third child node are sibling nodes, wherein the second child node is ordered between the first child node and the third child node;</claim-text>
<claim-text>determine whether a data value change to the first child node, the second child node, and the third child node is required;</claim-text>
<claim-text>in response to determining that the data value change to the first child node and any sub-nodes of the first child node are not required, skip first content of the first child node and the sub-nodes of the first child node, and create a first reference to the first skipped content;</claim-text>
<claim-text>in response to determining that the data value change to the second child node is required, creating an updated node in memory to replace the second child node and create a second reference to the updated node;</claim-text>
<claim-text>in response to determining that the data value change to the third child node and any sub-nodes of the third child node are not required, skip second content of the third child node and the sub-nodes of the third child node, and create a third reference to the second skipped content;</claim-text>
<claim-text>push the first reference, the second reference, and the third reference into a mutation map; and</claim-text>
<claim-text>serialize the document using the first reference, the second reference, and the third reference in the mutation map, wherein the serialized document comprises the first skipped content obtained from the document, the updated node, and the second skipped content obtained from the document.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The system of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the processor unit executes the computer executable program code to assign the unique ID to each node created in the document further directs the system to:
<claim-text>compare two node IDs for a document order using the current node IDs;</claim-text>
<claim-text>identify a node with a lower node ID to form an identified node; and</claim-text>
<claim-text>place the identified node in the document prior to a remaining node of the two node IDs.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The system of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the processor unit executes the computer executable program code to create the first reference to the skipped content further directs the system to:
<claim-text>identify a skipped sub-tree region of the document to form an identified region;</claim-text>
<claim-text>create the first reference to data of the identified region;</claim-text>
<claim-text>collect contexts pertaining to the identified region to form collected contexts;</claim-text>
<claim-text>encapsulate data content and the collected contexts into a skipped sub-tree fragment; and</claim-text>
<claim-text>store the skipped sub-tree fragment into a skipped node.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The system of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the processor unit executes the computer executable program code to push the first reference and the second reference into the mutation map further directs the system to:
<claim-text>receive a mutated node to form a received node;</claim-text>
<claim-text>identify an insertion point in the mutation map for the received node to form an identified insertion point;</claim-text>
<claim-text>add the second reference to the received node at the identified insertion point in the mutation map; and</claim-text>
<claim-text>calculate a native representation corresponding to a region between the received node and siblings of the received node.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The system of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the processor unit executes the computer executable program code to serialize the document using the mutation map further directs the system to:
<claim-text>determine whether a received node has contents mutated;</claim-text>
<claim-text>in response to determining that the received node does not have contents mutated, define a region item as a next item in the mutation map using the first reference for reuse of the skipped content from the document; and</claim-text>
<claim-text>in response to determining that the received node has contents mutated, traverse content of the received node as a mutated node using the second reference. </claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
