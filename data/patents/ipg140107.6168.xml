<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627292-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627292</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12370742</doc-number>
<date>20090213</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>1055</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>44</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>11</main-group>
<subgroup>00</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>717127</main-classification>
<further-classification>717124</further-classification>
<further-classification>717126</further-classification>
<further-classification>714 15</further-classification>
</classification-national>
<invention-title id="d2e53">STM with global version overflow handling</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6182286</doc-number>
<kind>B1</kind>
<name>Sigal et al.</name>
<date>20010100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717122</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6691304</doc-number>
<kind>B1</kind>
<name>Zhang et al.</name>
<date>20040200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717127</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>7117492</doc-number>
<kind>B2</kind>
<name>Ikeda et al.</name>
<date>20061000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717170</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>7536517</doc-number>
<kind>B2</kind>
<name>Harris</name>
<date>20090500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711150</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>7774647</doc-number>
<kind>B2</kind>
<name>Vertes</name>
<date>20100800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714 15</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>8132158</doc-number>
<kind>B2</kind>
<name>Wang et al.</name>
<date>20120300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717127</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2001/0018763</doc-number>
<kind>A1</kind>
<name>Ikeda et al.</name>
<date>20010800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717  3</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2005/0155019</doc-number>
<kind>A1</kind>
<name>Levine et al.</name>
<date>20050700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717127</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2007/0028056</doc-number>
<kind>A1</kind>
<name>Harris</name>
<date>20070200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711150</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2007/0143741</doc-number>
<kind>A1</kind>
<name>Harris</name>
<date>20070600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2007/0169031</doc-number>
<kind>A1</kind>
<name>Harris</name>
<date>20070700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717140</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2007/0198978</doc-number>
<kind>A1</kind>
<name>Dice et al.</name>
<date>20070800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718100</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2007/0239943</doc-number>
<kind>A1</kind>
<name>Dice et al.</name>
<date>20071000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2008/0022054</doc-number>
<kind>A1</kind>
<name>Hertzberg et al.</name>
<date>20080100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>2008/0120484</doc-number>
<kind>A1</kind>
<name>Zhang et al.</name>
<date>20080500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>2008/0140962</doc-number>
<kind>A1</kind>
<name>Pattabiraman et al.</name>
<date>20080600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>2008/0163220</doc-number>
<kind>A1</kind>
<name>Wang et al.</name>
<date>20080700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00018">
<document-id>
<country>US</country>
<doc-number>2008/0244354</doc-number>
<kind>A1</kind>
<name>Wu et al.</name>
<date>20081000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714755</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00019">
<document-id>
<country>US</country>
<doc-number>2008/0256074</doc-number>
<kind>A1</kind>
<name>Lev et al.</name>
<date>20081000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  8</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00020">
<document-id>
<country>US</country>
<doc-number>2009/0077540</doc-number>
<kind>A1</kind>
<name>Zhou et al.</name>
<date>20090300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717126</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00021">
<document-id>
<country>US</country>
<doc-number>2010/0180257</doc-number>
<kind>A1</kind>
<name>Dern</name>
<date>20100700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717124</main-classification></classification-national>
</us-citation>
<us-citation>
<nplcit num="00022">
<othercit>Harris, T., et al., Optimizing Memory Transactions, Proceedings of the 2006 ACM SIGPLAN conference on Programming language design and implementation, 2006, pp. 14-25, [retrieved on Aug. 26, 2013], Retrieved from the Internet: &#x3c;URL:http://dl.acm.org/&#x3e;.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00023">
<othercit>Minh, C. C., et al., An Effective Hybrid Transactional Memory System with Strong Isolation Guarantees, Proceedings of the 34th annual international symposium on Computer architecture, 2007, pp. 69-80, [retrieved on Aug. 26, 2013], Retrieved from the Internet: &#x3c;URL:http://dl.acm.org/&#x3e;.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00024">
<othercit>Harris et,al. &#x201c;Transactional Memory: An Overview&#x201d;, Retrieved at&#x3c;&#x3c;http://intl.ieeexplore.ieee.org/iel5/40/4292046/04292053.pdf?tp=&#x26;isnumber=&#x26;arnumber=4292053&#x3e;&#x3e;, May-Jun. 2007, pp. 8-29.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00025">
<othercit>Spear et al.&#x201c;Privatization Techniques for Software Transactional Memory&#x201d;, Retrieved at&#x3c;&#x3c;http://www.cs.rochester.edu/u/scott/papers/2007<sub>&#x2014;</sub>TR915.pdf&#x3e;&#x3e;, Feb. 2007, pp. 1-17.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00026">
<othercit>Menon et,al. &#x201c; Practical Weak-Atomicity Semantics for Java STM&#x201d;, Retrieved at&#x3c;&#x3c;http://delivery.acm.org/10.1145/1380000/1378588/p314-menon.pdf?key1=1378588&#x26;key2=7622397121&#x26;coll=GUIDE&#x26;dl=GUIDE&#x26;CFID=39460839&#x26;CFTOKEN=71933308&#x3e;&#x3e;, pp. 314-325. (Published Jun. 16, 2008).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00027">
<othercit>Scott et al.&#x201c;Conflict Detection and Validation Strategies for Software Transactional Memory&#x201d;, Retrieved at&#x3c;&#x3c;https://www.cs.rochester.edu/u/scott/papers/2006<sub>&#x2014;</sub>DISC<sub>&#x2014;</sub>conflict.pdf&#x3e;&#x3e;, p. 15. (Published Sep. 19, 2006).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00028">
<othercit>SHAVIT1 et al.&#x201c;Transactional Locking II&#x201d;, Retrieved at&#x3c;&#x3c;http://research.sun.com/scalable/pubs/DISC2006.pdf&#x3e;&#x3e;, p. 15. (Published Sep. 19, 2006).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00029">
<othercit>MENON1 et al.&#x201c;Enforcing Isolation and Ordering in STM&#x201d;, Retrieved at&#x3c;&#x3c;http://www.cs.washington.edu/homes/djg/papers/tm<sub>&#x2014;</sub>pldi07.pdf&#x3e;&#x3e;, p. 11. (Published Jun. 11, 2007).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00030">
<othercit>ISARD&#x2020; et al.&#x201c;Semantics of Transactional Memory and Automatic Mutual Exclusion&#x201d;, Retrieved at&#x3c;&#x3c;http://research.microsoft.com/&#x2dc;tharris/papers/2008-popl.pdf&#x3e;&#x3e;, p. 12. (Published Jan. 10, 2008).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>19</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>8</number-of-drawing-sheets>
<number-of-figures>10</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20100211931</doc-number>
<kind>A1</kind>
<date>20100819</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Levanoni</last-name>
<first-name>Yosseff</first-name>
<address>
<city>Redmond</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Detlefs</last-name>
<first-name>David L.</first-name>
<address>
<city>Issaquah</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Zhu</last-name>
<first-name>Weirong</first-name>
<address>
<city>Kirkland</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="004" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Harris</last-name>
<first-name>Timothy L.</first-name>
<address>
<city>Cambridge</city>
<country>GB</country>
</address>
</addressbook>
<residence>
<country>GB</country>
</residence>
</us-applicant>
<us-applicant sequence="005" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Magruder</last-name>
<first-name>Michael M.</first-name>
<address>
<city>Carnation</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="006" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Tolton</last-name>
<first-name>Matthew B.</first-name>
<address>
<city>Kirkland</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Levanoni</last-name>
<first-name>Yosseff</first-name>
<address>
<city>Redmond</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Detlefs</last-name>
<first-name>David L.</first-name>
<address>
<city>Issaquah</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Zhu</last-name>
<first-name>Weirong</first-name>
<address>
<city>Kirkland</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="004" designation="us-only">
<addressbook>
<last-name>Harris</last-name>
<first-name>Timothy L.</first-name>
<address>
<city>Cambridge</city>
<country>GB</country>
</address>
</addressbook>
</inventor>
<inventor sequence="005" designation="us-only">
<addressbook>
<last-name>Magruder</last-name>
<first-name>Michael M.</first-name>
<address>
<city>Carnation</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="006" designation="us-only">
<addressbook>
<last-name>Tolton</last-name>
<first-name>Matthew B.</first-name>
<address>
<city>Kirkland</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Microsoft Corporation</orgname>
<role>02</role>
<address>
<city>Redmond</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Dao</last-name>
<first-name>Thuy</first-name>
<department>2192</department>
</primary-examiner>
<assistant-examiner>
<last-name>St Leger</last-name>
<first-name>Geoffrey</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A software transactional memory system is provided with overflow handling. The system includes a global version counter with an epoch number and a version number. The system accesses the global version counter prior to and subsequent to memory accesses of transactions to validate read accesses of the transaction. The system includes mechanisms to detect global version number overflow and may allow some or all transactions to execute to completion subsequent to the global version number overflowing. The system also provides publication, privatization, and granular safety properties.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="251.88mm" wi="180.09mm" file="US08627292-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="213.61mm" wi="168.83mm" file="US08627292-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="251.46mm" wi="183.56mm" file="US08627292-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="269.66mm" wi="190.50mm" file="US08627292-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="178.31mm" wi="200.66mm" file="US08627292-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="167.05mm" wi="111.00mm" file="US08627292-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="218.19mm" wi="187.37mm" file="US08627292-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="273.56mm" wi="174.07mm" orientation="landscape" file="US08627292-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="156.55mm" wi="164.59mm" file="US08627292-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND</heading>
<p id="p-0002" num="0001">Computer programs may be written to allow different portions (e.g., threads) of the program to be executed concurrently. In order to execute different portions of the program concurrently, the computer system or the program typically includes some mechanism to manage the memory accesses of the different portions to ensure that the portions access common memory locations in the desired order.</p>
<p id="p-0003" num="0002">Transactional memory systems allow programmers to designate transactions in a program that may be executed as if the transactions are executing in isolation (i.e., independently of other transactions and other sequences of instructions in the program). Transactional memory systems manage the memory accesses of transactions by executing the transactions in such a way that the effects of a transaction may be rolled back or undone if two or more transactions attempt to access the same memory location in a conflicting manner. Transactional memory systems may be implemented using hardware and/or software components.</p>
<p id="p-0004" num="0003">Many software transactional memory (STM) systems allow programmers to include both transactional and non-transactional code in their programs. In order to be practically efficient and pay-for-play, STM systems may provide weak atomicity where no general guarantee is made for interaction between transactional and non-transactional code. However, some commonly used code idioms, such as forms of privatization and publication, may behave incorrectly in STM systems with weak atomicity if privatization safety and publication safety are not provided. In addition, memory locations in STM systems with weak atomicity may be locked and managed with a granularity that covers more than one individually accessible memory location. For example, STM systems may operate with an object-based granularity where locking and conflict management occur at an object level and include all fields of an object. In such systems, an STM system may provide granular safety to ensure that transactional accesses to one field of an object do not adversely affect non-transactional access to another field of the object. Although STM systems may provide safety properties such as privatization, publication, and granular safety, these safety properties typically introduce at least some cost, overhead, and/or complexity into STM systems.</p>
<heading id="h-0002" level="1">SUMMARY</heading>
<p id="p-0005" num="0004">This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.</p>
<p id="p-0006" num="0005">A software transactional memory system is provided with global version counter overflow handling. The system includes a global version counter with an epoch number and a version number. The system accesses the global version counter prior to and subsequent to memory accesses of transactions to validate read accesses of the transaction. The system includes mechanisms to detect global version number overflow and may allow some or all transactions to execute to completion subsequent to the global version number overflowing. The system also provides publication, privatization, and granular safety properties.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0007" num="0006">The accompanying drawings are included to provide a further understanding of embodiments and are incorporated in and constitute a part of this specification. The drawings illustrate embodiments and together with the description serve to explain principles of embodiments. Other embodiments and many of the intended advantages of embodiments will be readily appreciated as they become better understood by reference to the following detailed description. The elements of the drawings are not necessarily to scale relative to each other. Like reference numerals designate corresponding similar parts.</p>
<p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram illustrating an embodiment of a software transactional memory system.</p>
<p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram illustrating an embodiment of variables generated and used by a software transactional memory system.</p>
<p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. 3</figref> is a flow chart illustrating an embodiment of a method for executing a transaction in a software transactional memory system.</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIGS. 4A-4B</figref> are block diagrams illustrating embodiments of validating read accesses.</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 5</figref> is a flow chart illustrating an embodiment of a method performed by an epoch barrier that is invoked when global counter overflow occurs.</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 6</figref> is a block diagram illustrating an embodiment of variables generated and used by a software transactional memory system that allows transactions to complete regardless of when global version number overflow occurs.</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 7</figref> is a flow chart illustrating an embodiment of a method for managing a global version number range.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 8</figref> is a block diagram illustrating an embodiment of a compiler system with a compiler that is configured to compile source code with software transactional memory transactions.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 9</figref> is a block diagram illustrating an embodiment of a computer system configured to implement a software transactional memory system.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0017" num="0016">In the following Detailed Description, reference is made to the accompanying drawings, which form a part hereof, and in which is shown by way of illustration specific embodiments in which the invention may be practiced. In this regard, directional terminology, such as &#x201c;top,&#x201d; &#x201c;bottom,&#x201d; &#x201c;front,&#x201d; &#x201c;back,&#x201d; &#x201c;leading,&#x201d; &#x201c;trailing,&#x201d; etc., is used with reference to the orientation of the Figure(s) being described. Because components of embodiments can be positioned in a number of different orientations, the directional terminology is used for purposes of illustration and is in no way limiting. It is to be understood that other embodiments may be utilized and structural or logical changes may be made without departing from the scope of the present invention. The following detailed description, therefore, is not to be taken in a limiting sense, and the scope of the present invention is defined by the appended claims.</p>
<p id="p-0018" num="0017">It is to be understood that the features of the various exemplary embodiments described herein may be combined with each other, unless specifically noted otherwise.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram illustrating an embodiment of a software transactional memory (STM) system <b>10</b>. STM system <b>10</b> represents a runtime mode of operation in a computer system, such as computer system <b>200</b> shown in <figref idref="DRAWINGS">FIG. 9</figref> and described in additional detail below, where the computer system is executing instructions to run STM code <b>12</b>.</p>
<p id="p-0020" num="0019">STM system <b>10</b> includes STM code <b>12</b>, an STM library <b>14</b>, and a runtime environment <b>16</b>. STM system <b>10</b> is configured to manage the execution of STM transactions <b>20</b> that form atomic blocks in STM code <b>12</b> to allow transactions <b>20</b> to be executed atomically and, if desired, to rollback or undo changes made by transactions <b>20</b>. To do so, STM system <b>10</b> tracks memory accesses by transactions <b>20</b> to objects <b>30</b> using a log <b>34</b> for each executing transaction <b>20</b>.</p>
<p id="p-0021" num="0020">STM code <b>12</b> includes a set of one or more transactions <b>20</b>. Each transaction <b>20</b> includes a sequence of instructions that is designed to execute atomically, i.e., as if the sequence is executing in isolation from other transactions <b>20</b> in STM code <b>12</b>. Each transaction <b>20</b> includes an atomic block designator <b>22</b> that indicates that a corresponding portion of STM code <b>12</b> is a transaction <b>20</b>. Each transaction <b>20</b> also includes zero or more memory accesses <b>24</b> that read from and/or write to one or more objects <b>30</b> as indicated by arrows <b>32</b>. Transactions <b>20</b> also include invocations <b>26</b> of STM primitives, which may be added by a compiler such as a compiler <b>122</b> shown in <figref idref="DRAWINGS">FIGS. 8 and 9</figref> and described in additional detail below, that call functions in STM library <b>14</b>. The STM primitives of STM library <b>14</b> return results to transactions <b>20</b> as indicated by function calls and returns <b>28</b>.</p>
<p id="p-0022" num="0021">STM library <b>14</b> includes STM primitives and instructions executable by the computer system in conjunction with runtime environment <b>16</b> to implement STM system <b>10</b>. The STM primitives of STM library <b>14</b> that are callable by transactions <b>20</b> include management primitives that implement start, commit, and abort functions in STM library <b>14</b>. A transaction <b>20</b> calls the start function to initiate the management of the transaction <b>20</b> by STM library <b>14</b>. A transaction <b>20</b> calls the commit function to finalize the results of the transaction <b>20</b> in memory system <b>204</b>, if successful. A transaction <b>20</b> calls the abort function to roll back or undo the results of the transaction <b>20</b> in memory system <b>204</b>.</p>
<p id="p-0023" num="0022">The STM primitives of STM library <b>14</b> that are callable by transactions <b>20</b> also include memory access primitives that manage accesses to objects <b>30</b> that are written and/or read by a transaction <b>20</b>. The memory access primitives access a set of one or more transactional locks <b>42</b> for each object <b>30</b>. In one embodiment, STM system <b>10</b> uses the object header of objects <b>30</b> to store the corresponding transactional locks <b>42</b>. Each transactional lock <b>42</b> indicates whether a corresponding object <b>30</b> or portion of a corresponding object <b>30</b> is locked or unlocked for writing and/or reading. When an object <b>30</b> is locked for writing, the corresponding transactional lock <b>42</b> includes an address or other reference that locates an entry for the object <b>30</b> in a write log <b>34</b>W in one embodiment. When an object <b>30</b> is locked for reading (i.e., in response to a pessimistic read access), the corresponding transactional lock <b>42</b> includes a version number of the object <b>30</b> determined from a global version number <b>51</b>B (shown in <figref idref="DRAWINGS">FIG. 2</figref>) and a pessimistic read counter (e.g., to allow multiple concurrent read accesses to the object <b>30</b>). When an object <b>30</b> is not locked for writing or reading, the corresponding transactional lock <b>42</b> includes a version number of the object <b>30</b> determined from global version number <b>51</b>B in this embodiment.</p>
<p id="p-0024" num="0023">For each non-array object <b>30</b>, the memory access primitives may access a single transactional lock <b>42</b> that locks or unlocks the non-array object <b>30</b> for writing and/or reading. For each array object <b>30</b>, the memory access primitives may access a set of one or more transactional lock <b>42</b> where each transaction lock <b>42</b> in the set locks or unlocks a corresponding portion of the array object <b>30</b> for writing and/or reading. Runtime environment <b>16</b> creates and manages the transactional lock(s) <b>42</b> for each object <b>30</b>. In other embodiments, separate transactional locks <b>42</b> may be used for different portions of objects <b>30</b>.</p>
<p id="p-0025" num="0024">The memory access primitives of STM library <b>14</b> generate and manage a set of one or more STM logs <b>34</b> for each transaction currently being executed. Each set of STM logs <b>34</b> includes a write log <b>34</b>W and a read log <b>34</b>R in one embodiment. Each write log <b>34</b>W includes an entry for each object <b>30</b> that is written by a transaction <b>20</b> where each entry includes an address of a corresponding object <b>30</b>, the version number from the transactional lock <b>42</b> of the corresponding object <b>30</b>, and an address or other reference that locates a shadow copy of the corresponding object <b>30</b>. Each read log <b>34</b>R includes an entry for each object <b>30</b> that is read by a transaction <b>20</b> where each entry includes a reference that locates the transactional lock <b>42</b> of a corresponding object <b>30</b>.</p>
<p id="p-0026" num="0025">Runtime environment <b>16</b> may be any suitable combination of runtime libraries, a virtual machine (VM), an operating system (OS) functions, such as functions provided by an OS <b>222</b> shown in <figref idref="DRAWINGS">FIG. 9</figref> and described in additional detail below, and/or compiler functions, such as functions provided by compiler <b>122</b> shown in <figref idref="DRAWINGS">FIGS. 8 and 9</figref> and described in additional detail below.</p>
<p id="p-0027" num="0026">In one embodiment, STM system <b>10</b> provides weak atomicity between transactional code (i.e., transactions <b>20</b>) and non-transactional code in STM code <b>12</b> and performs locking and conflict management of objects <b>30</b> at an object granularity for non-array objects <b>30</b> or at a portion of an object granularity for array objects <b>30</b>. With weak atomicity, STM system <b>10</b> does not provide any general guarantees for interactions between transactional and non-transactional code when STM code <b>12</b> is executed. To prevent incorrect code behaviors that may occur with weak atomicity, STM system <b>10</b> provides safety properties that include privatization, publication, and granular safety. STM system <b>10</b> implements these safety properties by generating and using global, transaction, and object variables to manage the execution of transactions <b>20</b> as shown in <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0028" num="0027">The global variables generated by STM system <b>10</b>, as indicated by an arrow <b>50</b>, include a global version (GV) counter <b>51</b> and a commit version (CV) counter <b>52</b>. GV <b>51</b> represents a time-stamp of the most recently completed transaction <b>20</b> and is used to provide a version number to each transaction <b>20</b>. In one embodiment, GV <b>51</b> is a 64-bit quad word where the most-significant (64-N) bits represent an epoch number (EPOCH) <b>51</b>A and the least-significant N bits represents a version number (VERSION) <b>51</b>B where N is the maximum number of bits allowed to represent a version number stored in the transactional lock <b>42</b> of an object <b>30</b>. In other embodiments, GV <b>51</b>, epoch number <b>51</b>A, and version number <b>51</b>B may have other suitable sizes.</p>
<p id="p-0029" num="0028">Epoch number <b>51</b>A and version number <b>51</b>B are initialized to zero or other known values. Version number <b>51</b>B is incremented as part of the validation and commit process by each transaction <b>20</b> as described in additional detail below. Epoch number <b>51</b>A is incremented each time version number <b>51</b>B overflows. Epoch number <b>51</b>A may be incremented automatically in response to an atomic increment of GV <b>51</b> that causes version number <b>51</b>B to overflow in one embodiment.</p>
<p id="p-0030" num="0029">STM system <b>10</b> uses GV <b>51</b> to implement global versioning for transactions <b>20</b>. With global versioning, STM system <b>10</b> may guarantee that a given transaction <b>20</b> can detect conflicting writes by other transactions <b>20</b> that commit after the given transaction <b>20</b> starts. As a result, STM system <b>10</b> uses the global versioning from GV <b>51</b> to ensure publication safety.</p>
<p id="p-0031" num="0030">Because version number <b>51</b>B has a relatively small number of bits in some embodiments, version number <b>51</b>B may overflow in response to version number <b>51</b>B being incremented when the value of version number <b>51</b>B has reached a maximum value that may be represented by the number of bits of version number <b>51</b>B. With a relatively small number of bits (e.g., where the size of version number <b>51</b>B is limited by the number of bits of a transactional lock <b>42</b> that are available to store a version number), version number <b>51</b>B may overflow with some frequency, particularly where STM system <b>10</b> executes a relatively large number of transactions <b>20</b>.</p>
<p id="p-0032" num="0031">If all transactions <b>20</b> continue to execute subsequent to version number <b>51</b>B overflowing, STM system <b>10</b> may fail to detect conflicts between transactions <b>20</b> in some instances and falsely detect conflicts between transactions <b>20</b> in other instances. As a result, some conflicting transactions <b>20</b> may commit incorrectly, rather than rolling back and re-executing, and other consistent transactions <b>20</b> may roll back and re-execute unnecessarily, rather than committing.</p>
<p id="p-0033" num="0032">In one embodiment, STM system <b>10</b> rolls back and re-executes all executing transactions <b>20</b> in response to version number <b>51</b>B overflowing, i.e., in response to epoch number <b>51</b>A incrementing when version number <b>51</b>B (i.e., GV <b>51</b>) is incremented. In other embodiments, STM system <b>10</b> may manage transactions <b>20</b> in other suitable ways in response to version number <b>51</b>B overflowing to prevent conflicts from going undetected and/or prevent false conflicts from being detected.</p>
<p id="p-0034" num="0033">CV counter <b>52</b> represents the version number of the transaction <b>20</b> whose turn it is to commit and is a K bit integer. CV counter <b>52</b> is compared to the least-significant K bits of write version numbers of transactions <b>20</b> (assigned from GV <b>51</b>) to determine the commit order of transactions <b>20</b>. In one embodiment, CV counter <b>52</b> is a 32-bit double word that is initialized to one (i.e., K is equal to 32). In other embodiments, CV counter <b>52</b> is another size and/or is initialized to another suitable value. STM system <b>10</b> uses CV counter <b>52</b> to serialize the commits of transactions <b>20</b> and ensure privatization safety in conjunction with the buffering of write accesses.</p>
<p id="p-0035" num="0034">The transaction variables generated by STM system <b>10</b>, as indicated by an arrow <b>54</b>, include a first read version (RV<b>1</b>) <b>55</b>, a second read version (RV<b>2</b>) <b>56</b>, a write version (WV) <b>57</b>, and a minimum version (MIN) <b>58</b>. For each transaction <b>20</b>, STM system <b>10</b> stores the value of GV <b>51</b> as RV<b>1</b> <b>55</b> when a transaction <b>20</b> begins. For a read only transactions <b>20</b>, STM system <b>10</b> stores the value of GV <b>51</b> as RV<b>2</b> <b>56</b> after a transaction <b>20</b> completes any memory accesses but before the transaction <b>20</b> validates and commits. For read and write transactions <b>20</b>, STM system <b>10</b> stores an atomically incremented value of GV <b>51</b> as WV <b>57</b> and stores a decremented version of WV <b>57</b> as RV<b>2</b> <b>56</b> (i.e., RV<b>2</b>=WV&#x2212;1) after a transaction <b>20</b> completes any memory accesses but before the transaction <b>20</b> validates and commits.</p>
<p id="p-0036" num="0035">STM system <b>10</b> initially stores a maximum possible version number of all objects <b>30</b> as MIN <b>58</b> and updates MIN <b>58</b> for each pessimistic read access and read-after-write access (i.e., a read access to an object <b>30</b> that has already been accessed for writing by the same transaction <b>20</b>) as follows. For each read-after-write access, STM system <b>10</b> accesses the stored version number of the object <b>30</b> that is being read from log <b>34</b>W and updates MIN <b>58</b> to be equal to the stored version number of the object <b>30</b> if the stored version number is greater than RV<b>1</b> <b>55</b> and is less than MIN <b>58</b>. For each pessimistic read access that is not write locked or is write locked by the current transaction <b>20</b> or other transactions <b>20</b> in the same transaction nest as the current transaction <b>20</b>, STM system <b>10</b> accesses the version number of the object <b>30</b> that is being read from transactional lock <b>42</b> and updates MIN <b>58</b> to be equal to the version number from transactional lock <b>42</b> if the version number from transactional lock <b>42</b> is greater than RV<b>1</b> <b>55</b> and is less than MIN <b>58</b>.</p>
<p id="p-0037" num="0036">The object variables generated by STM system <b>10</b>, as indicated by an arrow <b>60</b>, include a bitmap <b>62</b> for each object <b>30</b> that is written. STM system <b>10</b> is configured to operate in a buffered write mode of operation. In the buffered write mode of operation, STM library <b>14</b> causes a shadow copy <b>63</b> to be made for each object <b>30</b> that is written by a transaction <b>20</b> as indicated by an arrow <b>64</b>. Transaction <b>20</b> performs all writes for an object <b>30</b> to the shadow copy <b>63</b> rather than to the object <b>30</b> directly.</p>
<p id="p-0038" num="0037">Each object <b>30</b> includes any number of fields that encompass a set of bytes By(<b>1</b>) through By(P) <b>31</b>, where P is greater than or equal to one and represents the Pth byte <b>31</b>, that correspond to bytes By(<b>1</b>) through By(P) <b>65</b> in a shadow copy <b>63</b> when the shadow copy <b>63</b> is populated. For each shadow copy <b>63</b>, a corresponding bitmap <b>62</b> includes bits B(<b>1</b>) through B(P) <b>66</b> such that there is a one-to-one correspondence between bits <b>66</b> and bytes <b>65</b>.</p>
<p id="p-0039" num="0038">With eager population of shadow copies <b>63</b> (i.e., objects <b>30</b> are copied into shadow copies <b>63</b> when the shadow copies <b>63</b> are created), STM library <b>14</b> sets each bit <b>66</b> to indicate whether a corresponding byte <b>65</b> has been written by a transaction <b>20</b>. When a transaction <b>20</b> commits, STM library <b>14</b> copies only those bytes <b>65</b> that have been written (i.e., modified) by transaction <b>20</b> back into the corresponding bytes <b>31</b> in object <b>30</b> as indicated by an arrow <b>67</b>.</p>
<p id="p-0040" num="0039">With lazy population of shadow copies <b>63</b> (i.e., portions of objects <b>30</b> are copied into shadow copies <b>63</b> only when first read by a transaction <b>20</b>), STM library <b>14</b> sets each bit <b>66</b> to indicate whether a corresponding byte <b>65</b> has been read or written by a transaction <b>20</b>. When STM library <b>14</b> performs a read with lazy population, if the corresponding bits <b>66</b> are not set, STM library <b>14</b> populates the corresponding portion of the shadow copy <b>63</b> from the object <b>30</b> and sets the corresponding bits <b>66</b> in bitmap <b>62</b>. STM library <b>14</b> then reads from the shadow copy <b>63</b>. When STM library <b>14</b> performs a write with lazy population, STM library <b>14</b> sets the corresponding bits <b>66</b> in bitmap <b>62</b> and then writes directly to the shadow copy <b>63</b>. When a transaction <b>20</b> commits, STM library <b>14</b> copies only those bytes <b>65</b> that have been accessed by transaction <b>20</b> back into the corresponding bytes <b>31</b> in object <b>30</b> as indicated by arrow <b>67</b>.</p>
<p id="p-0041" num="0040">In another embodiment, STM library <b>14</b> may use two bitmaps <b>62</b> (not shown) when a shadow copy <b>63</b> is created. STM library <b>14</b> uses one of the bitmaps <b>62</b> as a write bitmap for writes and the other of the bitmaps <b>62</b> as a read bitmap for reads. During commit, STM library <b>14</b> commits the portions of shadow copies <b>63</b> with corresponding bits set in the write bitmaps.</p>
<p id="p-0042" num="0041">By using bitmaps <b>62</b>, STM library <b>14</b> prevents any bytes <b>31</b> in objects <b>30</b> that have been written by non-transactional code during a transaction <b>20</b> from being undesirably overwritten by the transaction <b>20</b>. Bitmaps <b>62</b>, therefore, provide granular safety in STM system <b>10</b>.</p>
<p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. 3</figref> is a flow chart illustrating an embodiment of a method for executing a transaction <b>20</b> in a STM system <b>10</b>. STM library <b>14</b> performs the following algorithm using the global, transaction, and object variables shown in <figref idref="DRAWINGS">FIG. 2</figref> to execute each transaction <b>20</b>.</p>
<p id="p-0044" num="0043">In <figref idref="DRAWINGS">FIG. 3</figref>, a transaction <b>20</b> is started in STM system <b>10</b> as indicated in a block <b>70</b>. When the transaction <b>20</b> starts, STM library <b>14</b> creates variables RV<b>1</b> <b>55</b>, RV<b>2</b> <b>56</b>, WV <b>57</b>, and MIN <b>58</b> for the transaction <b>20</b>. STM system <b>10</b> accesses GV <b>51</b> and sets RV<b>1</b> <b>55</b> equal to the value of GV <b>51</b> prior to performing any memory accesses as indicated in a block <b>71</b>.</p>
<p id="p-0045" num="0044">STM library <b>14</b> then allows the transaction <b>20</b> to execute and perform any write and/or read memory accesses to objects <b>30</b> as indicated in a block <b>72</b>.</p>
<p id="p-0046" num="0045">To access an object <b>30</b> for writing, the transaction <b>20</b> invokes a memory access primitive that opens the object <b>30</b> for writing. STM library <b>14</b> acquires a transactional lock <b>42</b> corresponding to the object <b>30</b> for the transaction <b>20</b> if the lock is available. If the object <b>30</b> is not available (i.e., the object <b>30</b> is locked by another transaction <b>20</b>), then STM library <b>14</b> detects a conflict between the current transaction <b>20</b> and the other transaction <b>20</b> and may rollback and re-execute the current transaction <b>20</b>. If the object <b>30</b> is locked by the current transaction <b>20</b>, then STM library <b>14</b> has already acquired the transactional lock <b>42</b> corresponding to the object <b>30</b> for the transaction <b>20</b>. Once a corresponding transaction lock <b>42</b> is acquired, STM library <b>14</b> causes each write access <b>32</b> to be made to a shadow copy <b>63</b> of a corresponding object <b>30</b>, causes an entry corresponding to the write access <b>32</b> to be stored in log <b>34</b>W, and causes corresponding bits <b>66</b> in a corresponding bitmap <b>62</b> to be set. In one embodiment, the shadow copy <b>63</b> may be stored in log <b>34</b>W for non-array objects <b>30</b> and the shared shadow copy <b>63</b> may be stored separately from log <b>34</b>W for array objects <b>30</b>. In other embodiments, the shadow copy <b>63</b> and shared shadow copy <b>63</b> may be stored in other suitable locations.</p>
<p id="p-0047" num="0046">To access an object <b>30</b> for reading, the transaction <b>20</b> invokes a memory access primitive that opens the object <b>30</b> for reading. If the object <b>30</b> is not locked, STM library <b>14</b> causes an entry corresponding to the read access to be stored in read log <b>34</b>R. If the read access is a pessimistic read access, STM library <b>14</b> also acquires a transactional lock <b>42</b> for the object <b>30</b>. If the object <b>30</b> is locked for write access by another transaction <b>20</b>, then STM library <b>14</b> detects a conflict between the current transaction <b>20</b> and the other transaction <b>20</b> and may rollback and re-execute the current transaction <b>20</b>. If the object <b>30</b> is locked by the current transaction <b>20</b>, then STM library <b>14</b> may cause an entry corresponding to the read access to be stored in read log <b>34</b>R or set a flag corresponding to the object <b>30</b> in write log <b>34</b>W to indicate that the object <b>30</b> was also read. STM library <b>14</b> causes a read access <b>32</b> that occurs before a designated object <b>30</b> has been opened for writing by the transaction <b>20</b> to be made directly from the corresponding object <b>30</b>. STM library <b>14</b> causes each read access <b>32</b> that occurs after a designated object <b>30</b> has been opened for writing by a transaction <b>20</b> to be made from the corresponding shadow copy <b>63</b>.</p>
<p id="p-0048" num="0047">After all memory accesses have been performed but before validating read accesses, STM library <b>14</b> again accesses GV <b>51</b>. STM library <b>14</b> atomically increments GV <b>51</b>, sets WV <b>57</b> equal to the incremented value of GV <b>51</b>, and sets RV<b>2</b> <b>56</b> equal to the WV <b>57</b> minus one (i.e., the non-incremented value of GV <b>51</b>) as indicated in a block <b>73</b>. STM library <b>14</b> determines whether version number <b>51</b>B has overflowed since the transaction <b>20</b> began by comparing the epoch number in RV<b>1</b> <b>55</b> (e.g., the uppermost 64-Nbits) to the epoch number in RV<b>2</b> <b>56</b> (e.g., the uppermost 64-Nbits) as indicated in a block <b>74</b>. If version number <b>51</b>B has overflowed, then STM library <b>14</b> rolls back and re-executes transaction <b>20</b> as indicated in a block <b>75</b>. To roll back transaction <b>20</b>, STM library <b>14</b> uses log <b>34</b>W to cause the shadow copies <b>63</b> to be discarded and stores the version numbers in log <b>34</b>W as the version numbers of the corresponding objects <b>30</b>. STM library <b>14</b> then repeats the functions of at least blocks <b>71</b> through <b>74</b> in re-executing the transaction <b>20</b>.</p>
<p id="p-0049" num="0048">If version number <b>51</b>B has not overflowed, then STM library <b>14</b> determines whether RV<b>1</b> <b>55</b> is equal to RV<b>2</b> <b>56</b> as indicated in a block <b>76</b>. If RV<b>1</b> <b>55</b> is equal to RV<b>2</b> <b>56</b>, then GV <b>51</b> has not changed since the current transaction began which indicates that no other transactions <b>20</b> have started commit processing subsequent to the current transaction <b>20</b>. Accordingly, STM library <b>14</b> detects that all read accesses of the current transaction <b>20</b> are consistent without further validating the read accesses.</p>
<p id="p-0050" num="0049">If RV<b>1</b> <b>55</b> is not equal to RV<b>2</b> <b>56</b>, then STM library <b>14</b> attempts to further validate the read accesses of the transaction <b>20</b> using RV<b>1</b> <b>55</b>, RV<b>2</b> <b>56</b>, and MIN <b>58</b>, and log <b>34</b>R as indicated in a block <b>77</b>.</p>
<p id="p-0051" num="0050">To validate optimistic read accesses, STM library <b>14</b> compares the current version number in a corresponding transaction lock <b>42</b> for each object <b>30</b> indicated in read log <b>34</b>R as indicated by arrows <b>82</b> to RV<b>1</b> <b>55</b> and RV<b>2</b> <b>56</b> as indicated by arrows <b>83</b> in <figref idref="DRAWINGS">FIG. 4A</figref>. If a current version number is less than or equal to RV<b>1</b> <b>55</b>, then the corresponding object <b>30</b> has not been changed since the current transaction <b>20</b> began and the read access is consistent. If a current version number is greater than RV<b>2</b> <b>56</b>, then the corresponding object <b>30</b> also has not been changed since the current transaction <b>20</b> began and the read access is consistent. STM library <b>14</b> determines that the read access is consistent because no other transaction <b>20</b> has been given a commit version (i.e., an incremented value of GV <b>51</b>) higher than RV<b>2</b> <b>56</b> in the present epoch and thus, the current version number was produced by a transaction <b>20</b> from a previous epoch (i.e., a transaction <b>20</b> with a different epoch value than the current transaction <b>20</b>).</p>
<p id="p-0052" num="0051">If a current version number is greater than RV<b>1</b> <b>55</b> and less than or equal to RV<b>2</b> <b>56</b>, then STM library <b>14</b> determines that the read access is inconsistent. In this case, the current version number of the corresponding object <b>30</b> was either produced by a concurrent transaction <b>20</b> or by a transaction <b>20</b> in a previous epoch. Because STM library <b>14</b> cannot readily determine whether the current version number of the corresponding object <b>30</b> was produced in the present or a previous epoch, STM library <b>14</b> conservatively determines that the read access is inconsistent.</p>
<p id="p-0053" num="0052">With the above validation scheme for optimistic reads, the range of values between RV<b>1</b> <b>55</b> and RV<b>2</b> <b>56</b> (inclusive of RV<b>2</b> <b>56</b>) is expected to be small compared to the whole version number range of version number <b>51</b>B for most cases. As a result, the chance of falsely invalidating a read access (e.g., by invalidating a read access if a current version number of an object <b>30</b> is greater than RV<b>1</b> <b>55</b> and less than or equal to RV<b>2</b> <b>56</b>) is likely to also be small.</p>
<p id="p-0054" num="0053">To validate pessimistic read accesses and both optimistic and pessimistic read-after-write accesses, STM library <b>14</b> compares MIN <b>58</b> to RV<b>2</b> <b>56</b> as indicated by an arrow <b>84</b> in <figref idref="DRAWINGS">FIG. 4B</figref>. MIN <b>58</b> is updated during read accesses as described above. If MIN <b>58</b> is less than or equal to RV<b>2</b> <b>56</b>, STM library <b>14</b> determines that at least one pessimistic read or read-after-write access is possibly inconsistent. If at least one pessimistic read or read-after-write access is possibly inconsistent, at least one object <b>30</b> associated with a pessimistic read or read-after-write access from the current transaction <b>20</b> may have been written by another transaction <b>20</b> after the current transaction <b>20</b> began but before the object <b>30</b> was locked pessimistically by the current transaction <b>20</b>. Thus, at least one pessimistic read or read-after-write access was to an object <b>30</b> with a version number that was greater than RV<b>1</b> <b>55</b> and less than or equal to RV<b>2</b> <b>56</b>. By using MIN <b>58</b>, STM library <b>14</b> avoids validating each pessimistic read and read-after-write access in log <b>34</b>R individually. In addition, STM library <b>14</b> may omit recording the version number of objects <b>30</b> for pessimistic read and read-after-write accesses in log <b>34</b>R.</p>
<p id="p-0055" num="0054">If any of the read accesses (i.e., the optimistic read accesses, the pessimistic read accesses, or the read-after-write accesses) are not consistent, then STM library <b>14</b> determines that a conflict may exist and the read accesses are invalid. If the read accesses are invalid, then STM library <b>14</b> rolls back and re-executes the current transaction <b>20</b> as indicated in block <b>75</b>.</p>
<p id="p-0056" num="0055">If all of the read accesses are consistent, then STM library <b>14</b> writes back any shadow copies <b>63</b> that were created by the transaction <b>20</b> to the corresponding objects <b>30</b> using log <b>34</b>W as indicated in a block <b>78</b>. As described above, STM library <b>14</b> writes back only those fields <b>65</b> in the shadow copies <b>63</b> that have been written by the transaction <b>20</b> as indicated by the corresponding bitmaps <b>62</b>.</p>
<p id="p-0057" num="0056">STM library <b>14</b> then waits until the value of CV <b>52</b> is equal to the value of WV <b>57</b>. Once the value of CV <b>52</b> is equal to the value of WV <b>57</b>, STM library <b>14</b> commits the transaction <b>20</b> by incrementing CV <b>52</b>, releases all acquired transactional locks <b>42</b>, and stores the value of WV <b>57</b> as the version number of all objects <b>30</b> that are unlocked as indicated in a block <b>79</b>. STM library <b>14</b> ends the transaction as indicated in a block <b>80</b>.</p>
<p id="p-0058" num="0057">For STM transactions <b>20</b> that include only read accesses (i.e., do not include any write accesses), STM library <b>14</b> modifies the above algorithm to omit incrementing GV <b>51</b> and setting WV <b>57</b> in block <b>73</b>. In block <b>73</b>, STM library <b>14</b> accesses GV <b>51</b> and sets RV<b>2</b> <b>56</b> equal to GV <b>51</b>. STM library <b>14</b> also omits the functions of blocks <b>78</b> and <b>79</b>.</p>
<p id="p-0059" num="0058">In addition, since a read-only transaction <b>20</b> has no way to prevent transactions <b>20</b> that start after the read-only transaction <b>20</b> from committing while the read-only transaction <b>20</b> is validating, STM library <b>14</b> reads GV <b>51</b> as read version <b>3</b> (RV<b>3</b>) (not shown) and performs the function of block <b>74</b> with RV<b>3</b> subsequent to performing the function of block <b>77</b> to ensure that another transaction <b>20</b> did not cause overflow to occur while the read-only transaction <b>20</b> is validating. STM library <b>14</b> rolls back and re-executes read-only transactions <b>20</b> in response to detecting overflow.</p>
<p id="p-0060" num="0059">Further, STM library <b>14</b> maintains a variable MIN_OPT (not shown) for use with STM transactions <b>20</b> that include only read accesses. STM library <b>14</b> initializes MIN_OPT to be equal to a maximum possible version number of all objects <b>30</b>. While validating optimistic read accesses, STM library <b>14</b> sets MIN_OPT to be equal to a current version number of an object <b>30</b> indicated in read log <b>34</b>R if the current version number is greater than RV<b>2</b> <b>56</b> and less than MIN_OPT. After re-verifying that overflow did not occur, STM library <b>14</b> determines that the read-only transaction <b>20</b> is inconsistent if MIN_OPT is greater than RV<b>2</b> <b>56</b> and less than or equal to RV<b>3</b>. By doing so, STM library <b>14</b> ensures that younger read and write transactions <b>20</b> did not cause overflow of GV<b>51</b> prior to a read-only transaction <b>20</b> committing. STM library <b>14</b> also ensures that younger read and write transactions <b>20</b> that commit prior to an older, read-only transaction <b>20</b> do not conflict with the older, read-only transaction <b>20</b>. STM library <b>14</b> rolls back and re-executes any inconsistent read-only transactions <b>20</b>.</p>
<p id="p-0061" num="0060">For nested transactions <b>20</b> (i.e., transactions <b>20</b> that are called within another transaction <b>20</b>), STM library <b>14</b> modifies the above algorithm by initializing RV<b>1</b> <b>55</b> to be equal to RV<b>1</b> <b>55</b> of the top-level transaction <b>20</b> and initializing MIN <b>58</b> to be equal to MIN <b>58</b> of the transaction <b>20</b> that called the nested transaction <b>20</b>. STM library <b>14</b> may omit the function of block <b>77</b> (i.e., the validation of read accesses) for a nested transaction <b>20</b> and rely on the validation of read accesses by the parent or top-level transaction <b>20</b> of the nested transaction <b>20</b>. In addition, STM library <b>14</b> updates MIN <b>58</b> of a parent transaction <b>20</b> each time a nested transaction <b>20</b> commits if MIN <b>58</b> of the nested transaction is less than MIN <b>58</b> of the parent transaction <b>20</b>. If STM library <b>14</b> determines that a nested transaction <b>20</b> is inconsistent, STM library <b>14</b> rolls back all transactions <b>20</b> in the nest including the top-level transaction <b>20</b>. STM library <b>14</b> then re-executes the top-level transaction <b>20</b>.</p>
<p id="p-0062" num="0061">In the above embodiments, STM library <b>14</b> uses bitmaps <b>62</b> to provide granular safety as described above. STM library <b>14</b> includes a field barrier that manages bitmaps <b>62</b> by setting bit fields <b>66</b> for corresponding fields <b>65</b> in shadow copies <b>63</b> that are written by a transaction <b>20</b>. STM library <b>14</b> executes the field barrier for each write access to ensure granular safety. STM library <b>14</b>, however, may omit the execution of the field barrier for read accesses while maintaining granular safety. For read-only accesses, STM library <b>14</b> does not create a shadow copy <b>63</b> and thus, there is no granular safety concern. For read-after-write accesses (i.e., reads of objects <b>30</b> that have been previously opened for writing by the same transaction <b>20</b>), the above embodiments provide consistent read accesses to corresponding shadow copies <b>63</b> with bitmaps <b>62</b> managed by field barriers corresponding to the write accesses. Accordingly, STM library <b>14</b> may omit the field barrier for read accesses and provide granular safety without additional overhead for read accesses where shadow copies <b>63</b> are eagerly populated.</p>
<p id="p-0063" num="0062">In the above embodiments, STM library <b>14</b> rolls back and re-executes all executing transactions <b>20</b> when overflow of version number <b>51</b>B occurs. As a result, a large transaction <b>20</b> may be unable to finish in a given epoch if many small transactions <b>20</b> consume the whole version number space of version number <b>51</b>B before the large transaction <b>20</b> finishes.</p>
<p id="p-0064" num="0063">In another embodiment, STM library <b>14</b> includes an epoch barrier that may allow executing transactions <b>20</b>, including any large transactions <b>20</b>, to commit when overflow of version number <b>51</b>B occurs. STM library <b>14</b> invokes the epoch barrier each time overflow of version number <b>51</b>B occurs.</p>
<p id="p-0065" num="0064"><figref idref="DRAWINGS">FIG. 5</figref> is a flow chart illustrating an embodiment of a method performed by an epoch barrier included in STM library <b>14</b>. As shown in <figref idref="DRAWINGS">FIG. 5</figref>, STM library <b>14</b> suspends all threads that are executing active transactions <b>20</b> as indicated in a block <b>91</b>. STM library <b>14</b> also prevents any remaining threads from starting new transactions as indicated in a block <b>92</b>. STM library <b>14</b> validates the read accesses of each suspended transaction <b>20</b> as indicated in a block <b>93</b>.</p>
<p id="p-0066" num="0065">STM library <b>14</b> rolls back any inconsistent transactions <b>20</b> and applies a transformation to consistent transactions <b>20</b> as indicated in a block <b>94</b>. STM library <b>14</b> transforms the consistent transactions <b>20</b> by setting RV<b>1</b> <b>55</b> in each consistent transaction <b>20</b> to zero, setting the version number in transactional lock <b>42</b> of each object <b>30</b> that is in a read log <b>34</b>R of one or more of the consistent transactions <b>20</b> to zero, and setting the version number in each entry of each write log <b>34</b>W of the consistent transactions <b>20</b> to zero. By setting all write log entries to zero, STM library <b>14</b> causes any of the transactions <b>20</b> that may roll back later to set the version numbers of corresponding objects <b>30</b> to zero. STM library <b>14</b> also sets MIN <b>58</b> to zero.</p>
<p id="p-0067" num="0066">After the transformations have been applied, STM library <b>14</b> restarts execution of the transformed transactions <b>20</b> as indicated in a block <b>95</b>. By doing so, STM library <b>14</b> allows the transformed transactions <b>20</b> to execute to completion by either committing or detecting a conflict and rolling back. After all transformed transactions <b>20</b> complete, STM library <b>14</b> completes the epoch barrier and resumes normal execution.</p>
<p id="p-0068" num="0067">In another embodiment, STM library <b>14</b> manages a global version number range to allow transactions <b>20</b> to complete regardless of when global version number overflow occurs. In this embodiment, GV <b>51</b> forms a single version number value with a range a range of [0, MAX_GV] where MAX_GV is the maximum value that may be represented by GV <b>51</b>. GV <b>51</b> is not subdivided into epoch <b>51</b>A and version number <b>51</b>B as shown in the embodiment of <figref idref="DRAWINGS">FIG. 2</figref> in this embodiment. STM system <b>10</b> generates and uses the variables shown in <figref idref="DRAWINGS">FIG. 6</figref> in addition to those shown in <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0069" num="0068">The variables generated by this embodiment of STM system <b>10</b> include an oldest object version number (OLDEST_OBJECT_VN) <b>101</b>, an oldest transaction version number (OLDEST_TX_VN) <b>102</b>, and a threshold value <b>103</b> as indicated by arrow <b>50</b>. Oldest object version number <b>101</b> is the oldest version number (other than zero) for any object <b>30</b> in the heap (i.e., the oldest version number stored in a transaction lock <b>42</b> of an object <b>30</b> or a log <b>34</b>W). Oldest transaction version number <b>102</b> is the oldest version number among all active transactions <b>20</b> (i.e., the oldest value of GV <b>51</b> assigned to an active transaction <b>20</b>). Threshold value <b>103</b> is a threshold value that is used to set a maximum size of the global version number range (i.e., the set of values between oldest object version number <b>101</b> and GV <b>51</b> inclusive).</p>
<p id="p-0070" num="0069">In one embodiment, STM system <b>10</b> initializes the version number of each object <b>30</b> to a special reserved value not in the range [0, MAX_GV], e.g. MAX_GV+1, to indicate that the object <b>30</b> has not been written. In other embodiments, instead of using the range [0, MAX_GV], STM system <b>10</b> uses the range [1, MAX_GV] and reserves the value of zero to denote objects that have not yet been written. Since zero is less than any other values in the global version number range of GV <b>51</b>, the use of zero may expedite some of the validation tests and may also be advantageous when allocating new objects <b>30</b> and initializing the state of new objects <b>30</b> to all-zeros.</p>
<p id="p-0071" num="0070">In the embodiments described below, STM system <b>10</b> uses zero as the special version number value for new objects <b>30</b>. In addition, STM system <b>10</b> handles all ranges of values and comparisons based on logical values rather than actual values. For example, the actual value of GV <b>51</b> may be less than the actual value of oldest object version number <b>101</b> after GV <b>51</b> overflows and is wrapped.</p>
<p id="p-0072" num="0071">In this embodiment, STM system <b>10</b> initializes oldest object version number <b>101</b> to be zero and initializes oldest transaction version number <b>102</b> and GV <b>51</b> to be one. STM system <b>10</b> maintains the following invariants during execution of transactions <b>20</b>. Each object <b>30</b> in the heap has a version number (VN) such that either oldest object version number <b>101</b> is less than or equal to VN which is less than or equal to GV <b>51</b> or VN is equal to zero. Each active transaction <b>20</b> has a version number such that oldest transaction version number <b>102</b> is less than or equal to RV<b>1</b> <b>55</b> which is less than or equal to GV <b>51</b>. For each active transaction <b>20</b>, the version numbers of objects <b>30</b> in read log <b>34</b>R contain version numbers in the range between oldest object version number <b>101</b> and GV <b>51</b> inclusive. When a transaction <b>20</b> commits, the transaction <b>20</b> stamps the transaction lock <b>42</b> of objects <b>30</b> with version numbers in the range between oldest transaction version number <b>102</b> and GV <b>51</b> inclusive.</p>
<p id="p-0073" num="0072"><figref idref="DRAWINGS">FIG. 7</figref> is a flow chart illustrating an embodiment of a method for managing the global version number range. STM library <b>14</b> determines whether the global version number range exceeds a maximum size as indicated in a block <b>110</b>. STM library <b>14</b> determines that the global version number range exceeds a maximum size if the number of values between oldest object version number <b>101</b> and GV <b>51</b> inclusive exceeds the maximum value that may be represented by GV <b>51</b> (i.e., MAX_GV) minus threshold value <b>103</b>.</p>
<p id="p-0074" num="0073">Any time that the global version number range exceeds a maximum, STM library <b>14</b> suspends all threads as indicated in a block <b>112</b> and performs global version number compaction on all objects <b>30</b> and transaction logs <b>34</b>. In one embodiment, STM library <b>14</b> performs the compaction by traversing the heap and replacing all version numbers in objects <b>30</b> and transaction logs <b>34</b> that are greater than or equal to oldest object version number <b>101</b> and less than oldest transaction version number <b>102</b> with zero and by setting oldest object version number <b>101</b> equal to oldest transaction version number <b>102</b>. In another embodiment, STM library <b>14</b> performs the compaction by traversing the heap and replacing all version numbers in objects <b>30</b> and transaction logs <b>34</b> that are greater than or equal to oldest object version number <b>101</b> and less than oldest transaction version number <b>102</b> with oldest transaction version number <b>102</b>.</p>
<p id="p-0075" num="0074">These embodiments do not roll back and re-execute transactions when GV <b>51</b> overflows. In addition, these embodiments may be integrated with a garbage collection infrastructure that suspends threads and traverses the heap. Accordingly, global version number compaction may be performed as part of garbage collection or concurrently with garbage collection.</p>
<p id="p-0076" num="0075">The above embodiments unify the global version and the commit ticket into an algorithm by using global version counter <b>51</b>. The read access validation algorithm may account for any global version overflow to avoid false invalidations and avoid traversing the heap to re-number all objects <b>30</b> after each global version overflow. The above embodiments may also ensure granular safety for an STM system without changing read accesses.</p>
<p id="p-0077" num="0076">The above embodiments of STM system <b>10</b> implement encounter-time locking (ETL) by locking objects <b>30</b> when objects <b>30</b> are written (e.g., while performing memory accesses in block <b>72</b> of <figref idref="DRAWINGS">FIG. 3</figref>). In other embodiments, STM system <b>10</b> implements commit-time locking (CTL) where objects <b>30</b> are locked by transactions <b>20</b> when transactions <b>20</b> begin commit processing (e.g., subsequent to block <b>72</b> and prior to block <b>73</b> in <figref idref="DRAWINGS">FIG. 3</figref>). In these embodiments, write logs <b>34</b>W include a list of write accesses to objects <b>30</b> that are locked using transaction locks <b>42</b> when corresponding transactions <b>20</b> begin commit processing. STM system <b>10</b> detects a conflict if any objects <b>30</b> identified in a write log <b>34</b>W of a transaction <b>20</b> are locked, as indicated in corresponding transaction locks <b>42</b>, when the transaction <b>20</b> begins commit processing.</p>
<p id="p-0078" num="0077"><figref idref="DRAWINGS">FIG. 8</figref> is a block diagram illustrating an embodiment of a compiler system <b>120</b> with a compiler <b>122</b> that is configured to compile source code <b>124</b> with STM transactions <b>20</b>.</p>
<p id="p-0079" num="0078">Compiler system <b>120</b> represents a compile mode of operation in a computer system, such as computer system <b>200</b> shown in <figref idref="DRAWINGS">FIG. 9</figref> and described in additional detail below, where the computer system is executing instructions to compile code <b>124</b> into STM code <b>12</b>. In one embodiment, compiler system <b>120</b> includes a just-in-time (JIT) compiler system that operates in the computer system in conjunction with a runtime environment executed by an operating system (OS), such as OS <b>222</b> shown in <figref idref="DRAWINGS">FIG. 9</figref> and described in additional detail below, STM library <b>14</b>, and any additional runtime libraries (not shown). In another embodiment, compiler system <b>120</b> includes a stand-alone compiler system that produces STM code <b>12</b> for execution on the same or a different computer system.</p>
<p id="p-0080" num="0079">Code <b>124</b> includes a set of one or more STM transactions <b>20</b>. Each STM transaction <b>20</b> includes an atomic block designator <b>22</b> that indicates to compiler <b>122</b> that a corresponding portion of code <b>124</b> is an STM transaction <b>20</b>. Each STM transaction <b>20</b> may include zero or more memory accesses <b>24</b> that read from and/or write to an object <b>30</b>. Code <b>124</b> may be any suitable source code written in a language such as Java or C# or any suitable bytecode such as Common Intermediate Language (CIL), Microsoft Intermediate Language (MSIL), or Java bytecode.</p>
<p id="p-0081" num="0080">Compiler <b>122</b> accesses or otherwise receives code <b>124</b> with transactions <b>20</b> that include memory accesses <b>24</b>. Compiler <b>122</b> identifies memory accesses <b>24</b> and compiles code <b>124</b> into STM code <b>12</b> with invocations <b>26</b> of STM memory access primitives in STM library <b>14</b> for each memory access <b>24</b>. Compiler <b>122</b> performs any desired conversion of the set of instructions of code <b>124</b> into a set of instructions that are executable by a designated computer system and includes the set of instructions in STM code <b>12</b>.</p>
<p id="p-0082" num="0081"><figref idref="DRAWINGS">FIG. 9</figref> is a block diagram illustrating an embodiment of a computer system <b>200</b> configured to implement STM system <b>10</b>.</p>
<p id="p-0083" num="0082">Computer system <b>200</b> includes one or more processor packages <b>202</b>, memory system <b>204</b>, zero or more input/output devices <b>206</b>, zero or more display devices <b>208</b>, zero or more peripheral devices <b>210</b>, and zero or more network devices <b>212</b>. Processor packages <b>202</b>, memory system <b>204</b>, input/output devices <b>206</b>, display devices <b>208</b>, peripheral devices <b>210</b>, and network devices <b>212</b> communicate using a set of interconnections <b>214</b> that includes any suitable type, number, and configuration of controllers, buses, interfaces, and/or other wired or wireless connections.</p>
<p id="p-0084" num="0083">Computer system <b>200</b> represents any suitable processing device configured for a general purpose or a specific purpose. Examples of computer system <b>200</b> include a server, a personal computer, a laptop computer, a tablet computer, a personal digital assistant (PDA), a mobile telephone, and an audio/video device. The components of computer system <b>200</b> (i.e., processor packages <b>202</b>, memory system <b>204</b>, input/output devices <b>206</b>, display devices <b>208</b>, peripheral devices <b>210</b>, network devices <b>212</b>, and interconnections <b>214</b>) may be contained in a common housing (not shown) or in any suitable number of separate housings (not shown).</p>
<p id="p-0085" num="0084">Processor packages <b>202</b> each include one or more execution cores. Each execution core is configured to access and execute instructions stored in memory system <b>204</b>. The instructions may include a basic input output system (BIOS) or firmware (not shown), OS <b>222</b>, STM code <b>12</b>, STM library <b>14</b>, runtime environment <b>16</b>, compiler <b>122</b>, and code <b>124</b>. Each execution core may execute the instructions in conjunction with or in response to information received from input/output devices <b>206</b>, display devices <b>208</b>, peripheral devices <b>210</b>, and/or network devices <b>212</b>.</p>
<p id="p-0086" num="0085">Computer system <b>200</b> boots and executes OS <b>222</b>. OS <b>222</b> includes instructions executable by execution cores to manage the components of computer system <b>200</b> and provide a set of functions that allow programs to access and use the components. OS <b>222</b> executes runtime environment <b>16</b> to allow STM code <b>12</b> and STM library <b>14</b> to be executed. In one embodiment, OS <b>222</b> is the Windows operating system. In other embodiments, OS <b>222</b> is another operating system suitable for use with computer system <b>200</b>.</p>
<p id="p-0087" num="0086">Computer system <b>200</b> executes compiler <b>122</b> to generate STM code <b>12</b> from code <b>124</b>. Compiler <b>122</b> accesses or otherwise receives code <b>124</b> and transforms code <b>124</b> into STM code <b>12</b> for execution by computer system <b>200</b>. Compiler <b>122</b> performs any desired conversion of the set of instructions of code <b>124</b> into a set of instructions that are executable by computer system <b>200</b> and includes the set of instructions in STM code <b>12</b>. Compiler <b>122</b> also identifies blocks <b>20</b> in code <b>124</b> from transaction designators <b>22</b> and modifies blocks <b>20</b> in STM code <b>12</b> to include invocations of STM primitives <b>26</b>.</p>
<p id="p-0088" num="0087">In one embodiment, compiler <b>122</b> includes a just-in-time (JIT) compiler that operates in computer system <b>200</b> in conjunction with OS <b>222</b>, runtime environment <b>16</b>, and STM library <b>14</b>. In another embodiment, compiler <b>122</b> includes a stand-alone compiler that produces STM code <b>12</b> for execution on computer system <b>200</b> or another computer system (not shown).</p>
<p id="p-0089" num="0088">Computer system <b>200</b> executes runtime environment <b>16</b> and STM library <b>14</b> to allow STM code <b>12</b>, and transactions <b>20</b> therein, to be executed in computer system <b>200</b> as described above.</p>
<p id="p-0090" num="0089">Memory system <b>204</b> includes any suitable type, number, and configuration of volatile or non-volatile storage devices configured to store instructions and data. The storage devices of memory system <b>204</b> represent computer readable storage media that store computer-executable instructions including STM code <b>12</b>, STM library <b>14</b>, runtime environment <b>16</b>, OS <b>222</b>, compiler <b>122</b>, and code <b>124</b>. The instructions are executable by computer system <b>200</b> to perform the functions and methods of STM code <b>12</b>, STM library <b>14</b>, runtime environment <b>16</b>, OS <b>222</b>, compiler <b>122</b>, and code <b>124</b> as described herein. Memory system <b>204</b> stores instructions and data received from processor packages <b>202</b>, input/output devices <b>206</b>, display devices <b>208</b>, peripheral devices <b>210</b>, and network devices <b>212</b>. Memory system <b>204</b> provides stored instructions and data to processor packages <b>202</b>, input/output devices <b>206</b>, display devices <b>208</b>, peripheral devices <b>210</b>, and network devices <b>212</b>. Examples of storage devices in memory system <b>204</b> include hard disk drives, random access memory (RAM), read only memory (ROM), flash memory drives and cards, and magnetic and optical disks.</p>
<p id="p-0091" num="0090">Input/output devices <b>206</b> include any suitable type, number, and configuration of input/output devices configured to input instructions or data from a user to computer system <b>200</b> and output instructions or data from computer system <b>200</b> to the user. Examples of input/output devices <b>206</b> include a keyboard, a mouse, a touchpad, a touchscreen, buttons, dials, knobs, and switches.</p>
<p id="p-0092" num="0091">Display devices <b>208</b> include any suitable type, number, and configuration of display devices configured to output textual and/or graphical information to a user of computer system <b>200</b>. Examples of display devices <b>208</b> include a monitor, a display screen, and a projector.</p>
<p id="p-0093" num="0092">Peripheral devices <b>210</b> include any suitable type, number, and configuration of peripheral devices configured to operate with one or more other components in computer system <b>200</b> to perform general or specific processing functions.</p>
<p id="p-0094" num="0093">Network devices <b>212</b> include any suitable type, number, and configuration of network devices configured to allow computer system <b>200</b> to communicate across one or more networks (not shown). Network devices <b>212</b> may operate according to any suitable networking protocol and/or configuration to allow information to be transmitted by computer system <b>200</b> to a network or received by computer system <b>200</b> from a network.</p>
<p id="p-0095" num="0094">Although specific embodiments have been illustrated and described herein, it will be appreciated by those of ordinary skill in the art that a variety of alternate and/or equivalent implementations may be substituted for the specific embodiments shown and described without departing from the scope of the present invention. This application is intended to cover any adaptations or variations of the specific embodiments discussed herein. Therefore, it is intended that this invention be limited only by the claims and the equivalents thereof.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method performed by a software transactional memory (STM) system in a computer system, the method comprising:
<claim-text>storing a first read value of a global version counter prior to performing a read access of a first transaction;</claim-text>
<claim-text>storing a second read value of the global version counter subsequent to performing the read access of the first transaction;</claim-text>
<claim-text>detecting an overflow of the global version counter in response to a version number in the global version counter being incremented when the version number has reached a maximum value;</claim-text>
<claim-text>rolling back and re-executing the first transaction that was executing when the overflow occurred in response to detecting the overflow;</claim-text>
<claim-text>validating the read access using the first read value and the second read value including determining that the read access of the first transaction are consistent in response to the first read value and the second read value being equal;</claim-text>
<claim-text>if the read access is consistent, write back shadow copies and when write version is equal to commit version, increment commit version and store write version as version number for written objects; and</claim-text>
<claim-text>if the read access is inconsistent, rolling back and re-executing the first transaction.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising:
<claim-text>determining that any additional read accesses of the first transaction are consistent in response to the first read value and the second read value being equal.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the read access is an optimistic read access.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising:
<claim-text>determining that the read access is consistent in response to a current version number corresponding to an object of the read access being less than or equal to the first read value.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising:
<claim-text>determining that the read access is consistent in response to a current version number corresponding to an object of the read access being greater than the second read value.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising:
<claim-text>determining that the read access is inconsistent in response to a current version number corresponding to an object of the read access being greater than the first read value and less than or equal to the second read value.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref> further comprising:
<claim-text>the rolling back and re-executing the first transaction is in response to the determining that the read access is inconsistent.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the read access is one of a pessimistic read access or a read-after-write access.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising:
<claim-text>storing a maximum possible version number of a set of objects accessible by the STM system as a minimum value;</claim-text>
<claim-text>updating the minimum value in response to performing the read access, the read access being a pessimistic read access or read-after-write access; and</claim-text>
<claim-text>determining that at least one of a set of read accesses of the first transaction that includes the read access is inconsistent in response to the minimum value being less than or equal to the second read value.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref> further comprising:
<claim-text>updating the minimum value to be equal to a version number from a write log corresponding to an object of the read access in response to the version number being greater than the first read value and less than the minimum value.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref> further comprising:
<claim-text>updating the minimum value to be equal to a version number of an object of the read access in response to the version number being greater than the first read value and less than the minimum value and the read access being a pessimistic read access.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. A computer readable storage memory storing computer-executable instructions that, when executed by a computer system, perform a method comprising:
<claim-text>storing a first read value of a global version counter prior to performing a read access of a first transaction;</claim-text>
<claim-text>storing a second read value of the global version counter subsequent to performing the read access of the first transaction;</claim-text>
<claim-text>detecting an overflow of the global version counter in response to a version number in the global version counter being incremented when the version number has reached a maximum value;</claim-text>
<claim-text>rolling back and re-executing the first transaction that was executing when the overflow occurred in response to detecting the overflow;</claim-text>
<claim-text>validating the read access using the first read value and the second read value including determining that the read access of the first transaction are consistent in response to the first read value and the second read value being equal;</claim-text>
<claim-text>if the read access is consistent, write back shadow copies and when write version is equal to commit version, increment commit version and store write version as version number for written objects; and</claim-text>
<claim-text>if the read access is inconsistent, rolling back and re-executing the first transaction.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The computer readable storage memory of <claim-ref idref="CLM-00012">claim 12</claim-ref>, the method further comprising:
<claim-text>detecting that the first transaction has a read access that is inconsistent; and</claim-text>
<claim-text>rolling back and re-executing the first transaction in response to determining that the read access is inconsistent.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The computer readable storage memory of <claim-ref idref="CLM-00012">claim 12</claim-ref>, the method further comprising:
<claim-text>applying a transformation to a second transaction executing when the overflow occurred; and</claim-text>
<claim-text>allowing the second transaction to execute to completion subsequent to applying the transformation.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The computer readable storage memory of <claim-ref idref="CLM-00014">claim 14</claim-ref>, the method further comprising:
<claim-text>validating a set of read accesses of the second transaction prior to applying the transformation.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The computer readable storage memory of <claim-ref idref="CLM-00014">claim 14</claim-ref>, the method further comprising:
<claim-text>applying the transformation by setting a read version of the second transaction to zero, setting a first version number of a first object in a read log of the second transaction to zero, and setting a second version number in a write log that corresponds to a second object to zero.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. A method performed by a software transactional memory (STM) system in a computer system, the method comprising:
<claim-text>determining that a global version number range exceeds a maximum size;</claim-text>
<claim-text>suspending a set of threads being executed by the computer system in response to determining that the global version number range exceeds the maximum size; and</claim-text>
<claim-text>performing global version number compaction on a set of objects managed by the STM system and a set of logs corresponding to a set of transactions being executed by the STM system, the global version number compaction including replacing version numbers in the set of objects and the set of logs that are greater than or equal to an oldest object version number and less than an oldest transaction version number.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The method of <claim-ref idref="CLM-00017">claim 17</claim-ref> further comprising:
<claim-text>replacing a first version number of a first object with one of zero or the oldest transaction version number; and</claim-text>
<claim-text>replacing a second version number in a transaction log with one of zero or the oldest transaction version number, the second version number corresponding to a second object.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The method of <claim-ref idref="CLM-00017">claim 17</claim-ref> further comprising:
<claim-text>performing the global version number compaction as part of garbage collection. </claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
