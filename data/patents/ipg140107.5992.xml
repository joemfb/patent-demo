<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627114-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627114</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13180675</doc-number>
<date>20110712</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<us-term-of-grant>
<us-term-extension>40</us-term-extension>
<disclaimer>
<text>This patent is subject to a terminal disclaimer.</text>
</disclaimer>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>12</main-group>
<subgroup>14</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>30</subgroup>
<symbol-position>L</symbol-position>
<classification-value>N</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>713193</main-classification>
<further-classification>713165</further-classification>
<further-classification>713166</further-classification>
</classification-national>
<invention-title id="d2e55">Authenticating a data access request to a dispersed storage network</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>4092732</doc-number>
<kind>A</kind>
<name>Ouchi</name>
<date>19780500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5454101</doc-number>
<kind>A</kind>
<name>Mackay et al.</name>
<date>19950900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>5485474</doc-number>
<kind>A</kind>
<name>Rabin</name>
<date>19960100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>5774643</doc-number>
<kind>A</kind>
<name>Lubbers et al.</name>
<date>19980600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>5802364</doc-number>
<kind>A</kind>
<name>Senator et al.</name>
<date>19980900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>5809285</doc-number>
<kind>A</kind>
<name>Hilland</name>
<date>19980900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>5890156</doc-number>
<kind>A</kind>
<name>Rekieta et al.</name>
<date>19990300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>5987622</doc-number>
<kind>A</kind>
<name>Lo Verso et al.</name>
<date>19991100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>5991414</doc-number>
<kind>A</kind>
<name>Garay et al.</name>
<date>19991100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>6012159</doc-number>
<kind>A</kind>
<name>Fischer et al.</name>
<date>20000100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>6058454</doc-number>
<kind>A</kind>
<name>Gerlach et al.</name>
<date>20000500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>6128277</doc-number>
<kind>A</kind>
<name>Bruck et al.</name>
<date>20001000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>6175571</doc-number>
<kind>B1</kind>
<name>Haddock et al.</name>
<date>20010100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>6192472</doc-number>
<kind>B1</kind>
<name>Garay et al.</name>
<date>20010200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>6256688</doc-number>
<kind>B1</kind>
<name>Suetaka et al.</name>
<date>20010700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>6272658</doc-number>
<kind>B1</kind>
<name>Steele et al.</name>
<date>20010800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>6301604</doc-number>
<kind>B1</kind>
<name>Nojima</name>
<date>20011000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00018">
<document-id>
<country>US</country>
<doc-number>6356949</doc-number>
<kind>B1</kind>
<name>Katsandres et al.</name>
<date>20020300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00019">
<document-id>
<country>US</country>
<doc-number>6366995</doc-number>
<kind>B1</kind>
<name>Vilkov et al.</name>
<date>20020400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00020">
<document-id>
<country>US</country>
<doc-number>6374336</doc-number>
<kind>B1</kind>
<name>Peters et al.</name>
<date>20020400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00021">
<document-id>
<country>US</country>
<doc-number>6415373</doc-number>
<kind>B1</kind>
<name>Peters et al.</name>
<date>20020700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00022">
<document-id>
<country>US</country>
<doc-number>6418539</doc-number>
<kind>B1</kind>
<name>Walker</name>
<date>20020700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00023">
<document-id>
<country>US</country>
<doc-number>6449688</doc-number>
<kind>B1</kind>
<name>Peters et al.</name>
<date>20020900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00024">
<document-id>
<country>US</country>
<doc-number>6567948</doc-number>
<kind>B2</kind>
<name>Steele et al.</name>
<date>20030500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00025">
<document-id>
<country>US</country>
<doc-number>6571282</doc-number>
<kind>B1</kind>
<name>Bowman-Amuah</name>
<date>20030500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00026">
<document-id>
<country>US</country>
<doc-number>6609223</doc-number>
<kind>B1</kind>
<name>Wolfgang</name>
<date>20030800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00027">
<document-id>
<country>US</country>
<doc-number>6718361</doc-number>
<kind>B1</kind>
<name>Basani et al.</name>
<date>20040400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00028">
<document-id>
<country>US</country>
<doc-number>6760808</doc-number>
<kind>B2</kind>
<name>Peters et al.</name>
<date>20040700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00029">
<document-id>
<country>US</country>
<doc-number>6785768</doc-number>
<kind>B2</kind>
<name>Peters et al.</name>
<date>20040800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00030">
<document-id>
<country>US</country>
<doc-number>6785783</doc-number>
<kind>B2</kind>
<name>Buckland</name>
<date>20040800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00031">
<document-id>
<country>US</country>
<doc-number>6826711</doc-number>
<kind>B2</kind>
<name>Moulton et al.</name>
<date>20041100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00032">
<document-id>
<country>US</country>
<doc-number>6879596</doc-number>
<kind>B1</kind>
<name>Dooply</name>
<date>20050400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00033">
<document-id>
<country>US</country>
<doc-number>7003688</doc-number>
<kind>B1</kind>
<name>Pittelkow et al.</name>
<date>20060200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00034">
<document-id>
<country>US</country>
<doc-number>7024451</doc-number>
<kind>B2</kind>
<name>Jorgenson</name>
<date>20060400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00035">
<document-id>
<country>US</country>
<doc-number>7024609</doc-number>
<kind>B2</kind>
<name>Wolfgang et al.</name>
<date>20060400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00036">
<document-id>
<country>US</country>
<doc-number>7080101</doc-number>
<kind>B1</kind>
<name>Watson et al.</name>
<date>20060700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00037">
<document-id>
<country>US</country>
<doc-number>7103824</doc-number>
<kind>B2</kind>
<name>Halford</name>
<date>20060900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00038">
<document-id>
<country>US</country>
<doc-number>7103915</doc-number>
<kind>B2</kind>
<name>Redlich et al.</name>
<date>20060900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00039">
<document-id>
<country>US</country>
<doc-number>7111115</doc-number>
<kind>B2</kind>
<name>Peters et al.</name>
<date>20060900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00040">
<document-id>
<country>US</country>
<doc-number>7140044</doc-number>
<kind>B2</kind>
<name>Redlich et al.</name>
<date>20061100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00041">
<document-id>
<country>US</country>
<doc-number>7146644</doc-number>
<kind>B2</kind>
<name>Redlich et al.</name>
<date>20061200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00042">
<document-id>
<country>US</country>
<doc-number>7155745</doc-number>
<kind>B1</kind>
<name>Shin et al.</name>
<date>20061200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>726 27</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00043">
<document-id>
<country>US</country>
<doc-number>7171493</doc-number>
<kind>B2</kind>
<name>Shu et al.</name>
<date>20070100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00044">
<document-id>
<country>US</country>
<doc-number>7222133</doc-number>
<kind>B1</kind>
<name>Raipurkar et al.</name>
<date>20070500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00045">
<document-id>
<country>US</country>
<doc-number>7240236</doc-number>
<kind>B2</kind>
<name>Cutts et al.</name>
<date>20070700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00046">
<document-id>
<country>US</country>
<doc-number>7272613</doc-number>
<kind>B2</kind>
<name>Sim et al.</name>
<date>20070900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00047">
<document-id>
<country>US</country>
<doc-number>2002/0062422</doc-number>
<kind>A1</kind>
<name>Butterworth et al.</name>
<date>20020500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00048">
<document-id>
<country>US</country>
<doc-number>2002/0166079</doc-number>
<kind>A1</kind>
<name>Ulrich et al.</name>
<date>20021100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00049">
<document-id>
<country>US</country>
<doc-number>2003/0018927</doc-number>
<kind>A1</kind>
<name>Gadir et al.</name>
<date>20030100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00050">
<document-id>
<country>US</country>
<doc-number>2003/0037261</doc-number>
<kind>A1</kind>
<name>Meffert et al.</name>
<date>20030200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00051">
<document-id>
<country>US</country>
<doc-number>2003/0065617</doc-number>
<kind>A1</kind>
<name>Watkins et al.</name>
<date>20030400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00052">
<document-id>
<country>US</country>
<doc-number>2003/0084020</doc-number>
<kind>A1</kind>
<name>Shu</name>
<date>20030500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00053">
<document-id>
<country>US</country>
<doc-number>2004/0024963</doc-number>
<kind>A1</kind>
<name>Talagala et al.</name>
<date>20040200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00054">
<document-id>
<country>US</country>
<doc-number>2004/0122917</doc-number>
<kind>A1</kind>
<name>Menon et al.</name>
<date>20040600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00055">
<document-id>
<country>US</country>
<doc-number>2004/0215998</doc-number>
<kind>A1</kind>
<name>Buxton et al.</name>
<date>20041000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00056">
<document-id>
<country>US</country>
<doc-number>2004/0228493</doc-number>
<kind>A1</kind>
<name>Ma et al.</name>
<date>20041100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00057">
<document-id>
<country>US</country>
<doc-number>2005/0100022</doc-number>
<kind>A1</kind>
<name>Ramprashad</name>
<date>20050500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00058">
<document-id>
<country>US</country>
<doc-number>2005/0114594</doc-number>
<kind>A1</kind>
<name>Corbett et al.</name>
<date>20050500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00059">
<document-id>
<country>US</country>
<doc-number>2005/0125593</doc-number>
<kind>A1</kind>
<name>Karpoff et al.</name>
<date>20050600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00060">
<document-id>
<country>US</country>
<doc-number>2005/0131993</doc-number>
<kind>A1</kind>
<name>Fatula, Jr.</name>
<date>20050600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00061">
<document-id>
<country>US</country>
<doc-number>2005/0132070</doc-number>
<kind>A1</kind>
<name>Redlich et al.</name>
<date>20050600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00062">
<document-id>
<country>US</country>
<doc-number>2005/0144382</doc-number>
<kind>A1</kind>
<name>Schmisseur</name>
<date>20050600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00063">
<document-id>
<country>US</country>
<doc-number>2005/0229069</doc-number>
<kind>A1</kind>
<name>Hassner</name>
<date>20051000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00064">
<document-id>
<country>US</country>
<doc-number>2006/0047907</doc-number>
<kind>A1</kind>
<name>Shiga et al.</name>
<date>20060300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00065">
<document-id>
<country>US</country>
<doc-number>2006/0101399</doc-number>
<kind>A1</kind>
<name>Murayama et al.</name>
<date>20060500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717120</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00066">
<document-id>
<country>US</country>
<doc-number>2006/0136448</doc-number>
<kind>A1</kind>
<name>Cialini et al.</name>
<date>20060600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00067">
<document-id>
<country>US</country>
<doc-number>2006/0156059</doc-number>
<kind>A1</kind>
<name>Kitamura</name>
<date>20060700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00068">
<document-id>
<country>US</country>
<doc-number>2006/0224603</doc-number>
<kind>A1</kind>
<name>Correll, Jr.</name>
<date>20061000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00069">
<document-id>
<country>US</country>
<doc-number>2007/0079081</doc-number>
<kind>A1</kind>
<name>Gladwin et al.</name>
<date>20070400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00070">
<document-id>
<country>US</country>
<doc-number>2007/0079082</doc-number>
<kind>A1</kind>
<name>Gladwin et al.</name>
<date>20070400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00071">
<document-id>
<country>US</country>
<doc-number>2007/0079083</doc-number>
<kind>A1</kind>
<name>Gladwin et al.</name>
<date>20070400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00072">
<document-id>
<country>US</country>
<doc-number>2007/0088970</doc-number>
<kind>A1</kind>
<name>Buxton et al.</name>
<date>20070400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00073">
<document-id>
<country>US</country>
<doc-number>2007/0174192</doc-number>
<kind>A1</kind>
<name>Gladwin et al.</name>
<date>20070700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00074">
<document-id>
<country>US</country>
<doc-number>2007/0214285</doc-number>
<kind>A1</kind>
<name>Au et al.</name>
<date>20070900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00075">
<document-id>
<country>US</country>
<doc-number>2007/0234110</doc-number>
<kind>A1</kind>
<name>Soran et al.</name>
<date>20071000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00076">
<document-id>
<country>US</country>
<doc-number>2007/0283167</doc-number>
<kind>A1</kind>
<name>Venters, III et al.</name>
<date>20071200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00077">
<document-id>
<country>US</country>
<doc-number>2009/0094251</doc-number>
<kind>A1</kind>
<name>Gladwin et al.</name>
<date>20090400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00078">
<document-id>
<country>US</country>
<doc-number>2009/0094318</doc-number>
<kind>A1</kind>
<name>Gladwin et al.</name>
<date>20090400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00079">
<document-id>
<country>US</country>
<doc-number>2010/0023524</doc-number>
<kind>A1</kind>
<name>Gladwin et al.</name>
<date>20100100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00080">
<othercit>Shamir; How to Share a Secret; Communications of the ACM; vol. 22, No. 11; Nov. 1979; pp. 612-613.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00081">
<othercit>Rabin; Efficient Dispersal of Information for Security, Load Balancing, and Fault Tolerance; Journal of the Association for Computer Machinery; vol. 36, No. 2; Apr. 1989; pp. 335-348.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00082">
<othercit>Chung; An Automatic Data Segmentation Method for 3D Measured Data Points; National Taiwan University; pp. 1-8; 1998.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00083">
<othercit>Plank, T1: Erasure Codes for Storage Applications; FAST2005, 4th Usenix Conference on File Storage Technologies; Dec. 13-16, 2005; pp. 1-74.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00084">
<othercit>Wildi; Java iSCSi Initiator; Master Thesis; Department of Computer and Information Science, University of Konstanz; Feb. 2007; 60 pgs.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00085">
<othercit>Legg; Lightweight Directory Access Protocol (LDAP): Syntaxes and Matching Rules; IETF Network Working Group; RFC 4517; Jun. 2006; pp. 1-50.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00086">
<othercit>Zeilenga; Lightweight Directory Access Protocol (LDAP): Internationalized String Preparation; IETF Network Working Group; RFC 4518; Jun. 2006; pp. 1-14.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00087">
<othercit>Smith; Lightweight Directory Access Protocol (LDAP): Uniform Resource Locator; IETF Network Working Group; RFC 4516; Jun. 2006; pp. 1-15.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00088">
<othercit>Smith; Lightweight Directory Access Protocol (LDAP): String Representation of Search Filters; IETF Network Working Group; RFC 4515; Jun. 2006; pp. 1-12.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00089">
<othercit>Zeilenga; Lightweight Directory Access Protocol (LDAP): Directory Information Models; IETF Network Working Group; RFC 4512; Jun. 2006; pp. 1-49.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00090">
<othercit>Sciberras; Lightweight Directory Access Protocol (LDAP): Schema for User Applications; IETF Network Working Group; RFC 4519; Jun. 2006; pp. 1-33.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00091">
<othercit>Harrison; Lightweight Directory Access Protocol (LDAP): Authentication Methods and Security Mechanisms; IETF Network Working Group; RFC 4513; Jun. 2006; pp. 1-32.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00092">
<othercit>Zeilenga; Lightweight Directory Access Protocol (LDAP): Technical Specification Road Map; IETF Network Working Group; RFC 4510; Jun. 2006; pp. 1-8.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00093">
<othercit>Zeilenga; Lightweight Directory Access Protocol (LDAP): String Representation of Distinguished Names; IETF Network Working Group; RFC 4514; Jun. 2006; pp. 1-15.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00094">
<othercit>Sermersheim; Lightweight Directory Access Protocol (LDAP): The Protocol; IETF Network Working Group; RFC 4511; Jun. 2006; pp. 1-68.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00095">
<othercit>Satran, et al.; Internet Small Computer Systems Interface (iSCSI); IETF Network Working Group; RFC 3720; Apr. 2004; pp. 1-257.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00096">
<othercit>Xin, et al.; Evaluation of Distributed Recovery in Large-Scale Storage Systems; 13th IEEE International Symposium on High Performance Distributed Computing; Jun. 2004; pp. 172-181.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>22</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>24</number-of-drawing-sheets>
<number-of-figures>33</number-of-figures>
</figures>
<us-related-documents>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61369812</doc-number>
<date>20100802</date>
</document-id>
</us-provisional-application>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20120030736</doc-number>
<kind>A1</kind>
<date>20120202</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Resch</last-name>
<first-name>Jason K.</first-name>
<address>
<city>Chicago</city>
<state>IL</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Leggette</last-name>
<first-name>Wesley</first-name>
<address>
<city>Oak Park</city>
<state>IL</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Resch</last-name>
<first-name>Jason K.</first-name>
<address>
<city>Chicago</city>
<state>IL</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Leggette</last-name>
<first-name>Wesley</first-name>
<address>
<city>Oak Park</city>
<state>IL</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Garlick &#x26; Markison</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Markison</last-name>
<first-name>Timothy W.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Cleversafe, Inc.</orgname>
<role>02</role>
<address>
<city>Chicago</city>
<state>IL</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Perungavoor</last-name>
<first-name>Venkat</first-name>
<department>2496</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A method to authenticate a data access request begins by a data accessing module sending the data access request to a data storage module and continues with the data storage module sending an authentication request to an authenticating module. The method continues with the authenticating module outputting a verification request destined for the data accessing module, where the verification request includes a verification code that is generated based on the authentication request. The method continues with the data accessing module outputting a verification response that includes a modified verification code that is generated based on the verification code and a credential. The method continues with the authenticating module outputting an authentication response to the data storage module, where the authentication response is generated based on the verification response, and continues with the data storage module facilitating the data access request when the authentication response is favorable.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="195.41mm" wi="250.78mm" file="US08627114-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="250.53mm" wi="197.36mm" orientation="landscape" file="US08627114-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="226.23mm" wi="167.22mm" orientation="landscape" file="US08627114-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="238.17mm" wi="186.52mm" orientation="landscape" file="US08627114-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="250.53mm" wi="194.14mm" orientation="landscape" file="US08627114-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="231.99mm" wi="182.03mm" orientation="landscape" file="US08627114-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="219.20mm" wi="174.92mm" orientation="landscape" file="US08627114-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="215.31mm" wi="120.48mm" orientation="landscape" file="US08627114-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="226.23mm" wi="180.68mm" orientation="landscape" file="US08627114-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="101.85mm" wi="171.70mm" orientation="landscape" file="US08627114-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="105.07mm" wi="181.36mm" orientation="landscape" file="US08627114-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="219.20mm" wi="171.11mm" orientation="landscape" file="US08627114-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="96.77mm" wi="171.11mm" orientation="landscape" file="US08627114-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="214.80mm" wi="176.95mm" orientation="landscape" file="US08627114-20140107-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="220.47mm" wi="186.52mm" orientation="landscape" file="US08627114-20140107-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="251.21mm" wi="183.30mm" orientation="landscape" file="US08627114-20140107-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00016" num="00016">
<img id="EMI-D00016" he="242.91mm" wi="189.65mm" orientation="landscape" file="US08627114-20140107-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00017" num="00017">
<img id="EMI-D00017" he="192.28mm" wi="140.97mm" orientation="landscape" file="US08627114-20140107-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00018" num="00018">
<img id="EMI-D00018" he="107.02mm" wi="178.82mm" orientation="landscape" file="US08627114-20140107-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00019" num="00019">
<img id="EMI-D00019" he="257.64mm" wi="186.52mm" orientation="landscape" file="US08627114-20140107-D00019.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00020" num="00020">
<img id="EMI-D00020" he="162.14mm" wi="185.17mm" orientation="landscape" file="US08627114-20140107-D00020.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00021" num="00021">
<img id="EMI-D00021" he="119.21mm" wi="176.19mm" orientation="landscape" file="US08627114-20140107-D00021.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00022" num="00022">
<img id="EMI-D00022" he="205.06mm" wi="101.85mm" orientation="landscape" file="US08627114-20140107-D00022.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00023" num="00023">
<img id="EMI-D00023" he="115.99mm" wi="194.14mm" orientation="landscape" file="US08627114-20140107-D00023.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00024" num="00024">
<img id="EMI-D00024" he="245.45mm" wi="189.65mm" orientation="landscape" file="US08627114-20140107-D00024.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CROSS REFERENCE TO RELATED PATENTS</heading>
<p id="p-0002" num="0001">This patent application is claiming priority under 35 USC &#xa7;119 to a provisionally filed patent application entitled DISPERSED STORAGE NETWORK ACCESS REQUEST AUTHENTICATION, having a provisional filing date of Aug. 2, 2010, and a provisional Ser. No. 61/369,812, which is incorporated by reference in its entirety and made part of the present U.S. Utility Patent Application for all purposes.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">STATEMENT REGARDING FEDERALLY SPONSORED RESEARCH OR DEVELOPMENT</heading>
<p id="p-0003" num="0002">Not Applicable</p>
<heading id="h-0003" level="1">INCORPORATION-BY-REFERENCE OF MATERIAL SUBMITTED ON A COMPACT DISC</heading>
<p id="p-0004" num="0003">Not Applicable</p>
<heading id="h-0004" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0005" num="0004">1. Technical Field of the Invention</p>
<p id="p-0006" num="0005">This invention relates generally to computing systems and more particularly to data storage solutions within such computing systems.</p>
<p id="p-0007" num="0006">2. Description of Related Art</p>
<p id="p-0008" num="0007">Computers are known to communicate, process, and store data. Such computers range from wireless smart phones to data centers that support millions of web searches, stock trades, or on-line purchases every day. In general, a computing system generates data and/or manipulates data from one form into another. For instance, an image sensor of the computing system generates raw picture data and, using an image compression program (e.g., JPEG, MPEG, etc.), the computing system manipulates the raw picture data into a standardized compressed image.</p>
<p id="p-0009" num="0008">With continued advances in processing speed and communication speed, computers are capable of processing real time multimedia data for applications ranging from simple voice communications to streaming high definition video. As such, general-purpose information appliances are replacing purpose-built communications devices (e.g., a telephone). For example, smart phones can support telephony communications but they are also capable of text messaging and accessing the internet to perform functions including email, web browsing, remote applications access, and media communications (e.g., telephony voice, image transfer, music files, video files, real time video streaming. etc.).</p>
<p id="p-0010" num="0009">Each type of computer is constructed and operates in accordance with one or more communication, processing, and storage standards. As a result of standardization and with advances in technology, more and more information content is being converted into digital formats. For example, more digital cameras are now being sold than film cameras, thus producing more digital pictures. As another example, web-based programming is becoming an alternative to over the air television broadcasts and/or cable broadcasts. As further examples, papers, books, video entertainment, home video, etc. are now being stored digitally, which increases the demand on the storage function of computers.</p>
<p id="p-0011" num="0010">A typical computer storage system includes one or more memory devices aligned with the needs of the various operational aspects of the computer's processing and communication functions. Generally, the immediacy of access dictates what type of memory device is used. For example, random access memory (RAM) memory can be accessed in any random order with a constant response time, thus it is typically used for cache memory and main memory. By contrast, memory device technologies that require physical movement such as magnetic disks, tapes, and optical discs, have a variable response time as the physical movement can take longer than the data transfer, thus they are typically used for secondary memory (e.g., hard drive, backup memory, etc.).</p>
<p id="p-0012" num="0011">A computer's storage system will be compliant with one or more computer storage standards that include, but are not limited to, network file system (NFS), flash file system (FFS), disk file system (DFS), small computer system interface (SCSI), internet small computer system interface (iSCSI), file transfer protocol (FTP), and web-based distributed authoring and versioning (WebDAV). These standards specify the data storage format (e.g., files, data objects, data blocks, directories, etc.) and interfacing between the computer's processing function and its storage system, which is a primary function of the computer's memory controller.</p>
<p id="p-0013" num="0012">Despite the standardization of the computer and its storage system, memory devices fail; especially commercial grade memory devices that utilize technologies incorporating physical movement (e.g., a disc drive). For example, it is fairly common for a disc drive to routinely suffer from bit level corruption and to completely fail after three years of use. One solution is to a higher-grade disc drive, which adds significant cost to a computer.</p>
<p id="p-0014" num="0013">Another solution is to utilize multiple levels of redundant disc drives to replicate the data into two or more copies. One such redundant drive approach is called redundant array of independent discs (RAID). In a RAID device, a RAID controller adds parity data to the original data before storing it across the array. The parity data is calculated from the original data such that the failure of a disc will not result in the loss of the original data. For example, RAID 5 uses three discs to protect data from the failure of a single disc. The parity data, and associated redundancy overhead data, reduces the storage capacity of three independent discs by one third (e.g., n&#x2212;1=capacity). RAID 6 can recover from a loss of two discs and requires a minimum of four discs with a storage capacity of n&#x2212;2.</p>
<p id="p-0015" num="0014">While RAID addresses the memory device failure issue, it is not without its own failures issues that affect its effectiveness, efficiency and security. For instance, as more discs are added to the array, the probability of a disc failure increases, which increases the demand for maintenance. For example, when a disc fails, it needs to be manually replaced before another disc fails and the data stored in the RAID device is lost. To reduce the risk of data loss, data on a RAID device is typically copied on to one or more other RAID devices. While this addresses the loss of data issue, it raises a security issue since multiple copies of data are available, which increases the chances of unauthorized access. Further, as the amount of data being stored grows, the overhead of RAID devices becomes a non-trivial efficiency issue.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWING(S)</heading>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 1</figref> is a schematic block diagram of an embodiment of a computing system in accordance with the invention;</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 2</figref> is a schematic block diagram of an embodiment of a computing core in accordance with the invention;</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 3</figref> is a schematic block diagram of an embodiment of a distributed storage processing unit in accordance with the invention;</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 4</figref> is a schematic block diagram of an embodiment of a grid module in accordance with the invention;</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 5</figref> is a diagram of an example embodiment of error coded data slice creation in accordance with the invention;</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 6A</figref> is a flowchart illustrating an example of authenticating a request in accordance with the invention;</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 6B</figref> is a flowchart illustrating an example of refreshing a local authentication list in accordance with the invention;</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 7A</figref> is a diagram illustrating an example of an authentication sequence bounce diagram in accordance with the invention;</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 7B</figref> is a flowchart illustrating an example of authenticating a data access request in accordance with the invention;</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 7C</figref> is a flowchart illustrating an example of processing an authentication request in accordance with the invention;</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 8A</figref> is a flowchart illustrating an example of acquiring an authentication token in accordance with the invention;</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 8B</figref> is a flowchart illustrating an example of processing an authentication token request in accordance with the invention;</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 9</figref> is a flowchart illustrating an example of processing a request in accordance with the invention;</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 10</figref> is a flowchart illustrating an example of retrieving error coded data slices in accordance with the invention;</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 11</figref> is a flowchart illustrating an example of processing a write request in accordance with the invention;</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 12</figref> is a flowchart illustrating an example of determining storage generation operational modes in accordance with the invention;</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 13</figref> is a flowchart illustrating an example of manipulating pre-slice data in accordance with the invention;</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 14</figref> is a flowchart illustrating an example of error correcting a data slice in accordance with the invention;</p>
<p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. 15A</figref> is a schematic block diagram of an embodiment of a pillar assignment of a dispersed storage network memory in accordance with the invention;</p>
<p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. 15B</figref> is a schematic block diagram of another embodiment of a pillar assignment of a dispersed storage network memory in accordance with the invention;</p>
<p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. 15C</figref> is a schematic block diagram of another embodiment of a pillar assignment of a dispersed storage network memory in accordance with the invention;</p>
<p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. 15D</figref> is a schematic block diagram of another embodiment of a pillar assignment of a dispersed storage network memory in accordance with the invention;</p>
<p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. 16</figref> is a flowchart illustrating an example of implementing a storage policy in accordance with the invention;</p>
<p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. 17A</figref> is a schematic block diagram of another embodiment of a pillar assignment of a dispersed storage network memory in accordance with the invention;</p>
<p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. 17B</figref> is a schematic block diagram of another embodiment of a pillar assignment of a dispersed storage network memory in accordance with the invention;</p>
<p id="p-0041" num="0040"><figref idref="DRAWINGS">FIG. 17C</figref> is a schematic block diagram of another embodiment of a pillar assignment of a dispersed storage network memory in accordance with the invention;</p>
<p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. 18</figref> is a flowchart illustrating an example of expanding and contracting storage resources in accordance with the invention;</p>
<p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. 19</figref> is a schematic block diagram of an embodiment of a communication system in accordance with the invention;</p>
<p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. 20</figref> is a flowchart illustrating an example of acquiring a content broadcast in accordance with the invention;</p>
<p id="p-0045" num="0044"><figref idref="DRAWINGS">FIG. 21</figref> is a flowchart illustrating an example of generating a content broadcast in accordance with the invention;</p>
<p id="p-0046" num="0045"><figref idref="DRAWINGS">FIG. 22</figref> is a table illustrating an example of wireless configuration and pillar assignments in accordance with the invention;</p>
<p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. 23</figref> is a flowchart illustrating another example of acquiring a content broadcast in accordance with the invention; and</p>
<p id="p-0048" num="0047"><figref idref="DRAWINGS">FIG. 24</figref> is a flowchart illustrating another example of acquiring a content broadcast in accordance with the invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0006" level="1">DETAILED DESCRIPTION OF THE INVENTION</heading>
<p id="p-0049" num="0048"><figref idref="DRAWINGS">FIG. 1</figref> is a schematic block diagram of a computing system <b>10</b> that includes one or more of a first type of user devices <b>12</b>, one or more of a second type of user devices <b>14</b>, at least one distributed storage (DS) processing unit <b>16</b>, at least one DS managing unit <b>18</b>, at least one storage integrity processing unit <b>20</b>, and a distributed storage network (DSN) memory <b>22</b> coupled via a network <b>24</b>. The network <b>24</b> may include one or more wireless and/or wire lined communication systems; one or more private intranet systems and/or public internet systems; and/or one or more local area networks (LAN) and/or wide area networks (WAN).</p>
<p id="p-0050" num="0049">The DSN memory <b>22</b> includes a plurality of distributed storage (DS) units <b>36</b> for storing data of the system. Each of the DS units <b>36</b> includes a processing module and memory and may be located at a geographically different site than the other DS units (e.g., one in Chicago, one in Milwaukee, etc.). The processing module may be a single processing device or a plurality of processing devices. Such a processing device may be a microprocessor, micro-controller, digital signal processor, microcomputer, central processing unit, field programmable gate array, programmable logic device, state machine, logic circuitry, analog circuitry, digital circuitry, and/or any device that manipulates signals (analog and/or digital) based on hard coding of the circuitry and/or operational instructions. The processing module may have an associated memory and/or memory element, which may be a single memory device, a plurality of memory devices, and/or embedded circuitry of the processing module. Such a memory device may be a read-only memory, random access memory, volatile memory, non-volatile memory, static memory, dynamic memory, flash memory, cache memory, and/or any device that stores digital information. Note that if the processing module includes more than one processing device, the processing devices may be centrally located (e.g., directly coupled together via a wired and/or wireless bus structure) or may be distributedly located (e.g., cloud computing via indirect coupling via a local area network and/or a wide area network). Further note that when the processing module implements one or more of its functions via a state machine, analog circuitry, digital circuitry, and/or logic circuitry, the memory and/or memory element storing the corresponding operational instructions may be embedded within, or external to, the circuitry comprising the state machine, analog circuitry, digital circuitry, and/or logic circuitry. Still further note that, the memory element stores, and the processing module executes, hard coded and/or operational instructions corresponding to at least some of the steps and/or functions illustrated in <figref idref="DRAWINGS">FIGS. 1-24</figref>.</p>
<p id="p-0051" num="0050">Each of the user devices <b>12</b>-<b>14</b>, the DS processing unit <b>16</b>, the DS managing unit <b>18</b>, and the storage integrity processing unit <b>20</b> may be a portable computing device (e.g., a social networking device, a gaming device, a cell phone, a smart phone, a personal digital assistant, a digital music player, a digital video player, a laptop computer, a handheld computer, a video game controller, and/or any other portable device that includes a computing core) and/or a fixed computing device (e.g., a personal computer, a computer server, a cable set-top box, a satellite receiver, a television set, a printer, a fax machine, home entertainment equipment, a video game console, and/or any type of home or office computing equipment). Such a portable or fixed computing device includes a computing core <b>26</b> and one or more interfaces <b>30</b>, <b>32</b>, and/or <b>33</b>. An embodiment of the computing core <b>26</b> will be described with reference to <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0052" num="0051">With respect to the interfaces, each of the interfaces <b>30</b>, <b>32</b>, and <b>33</b> includes software and/or hardware to support one or more communication links via the network <b>24</b> and/or directly. For example, interfaces <b>30</b> support a communication link (wired, wireless, direct, via a LAN, via the network <b>24</b>, etc.) between the first type of user device <b>14</b> and the DS processing unit <b>16</b>. As another example, DSN interface <b>32</b> supports a plurality of communication links via the network <b>24</b> between the DSN memory <b>22</b> and the DS processing unit <b>16</b>, the first type of user device <b>12</b>, and/or the storage integrity processing unit <b>20</b>. As yet another example, interface <b>33</b> supports a communication link between the DS managing unit <b>18</b> and any one of the other devices and/or units <b>12</b>, <b>14</b>, <b>16</b>, <b>20</b>, and/or <b>22</b> via the network <b>24</b>.</p>
<p id="p-0053" num="0052">In general and with respect to data storage, the system <b>10</b> supports three primary functions: distributed network data storage management, distributed data storage and retrieval, and data storage integrity verification. In accordance with these three primary functions, data can be distributedly stored in a plurality of physically different locations and subsequently retrieved in a reliable and secure manner regardless of failures of individual storage devices, failures of network equipment, the duration of storage, the amount of data being stored, attempts at hacking the data, etc.</p>
<p id="p-0054" num="0053">The DS managing unit <b>18</b> performs distributed network data storage management functions, which include establishing distributed data storage parameters, performing network operations, performing network administration, and/or performing network maintenance. The DS managing unit <b>18</b> establishes the distributed data storage parameters (e.g., allocation of virtual DSN memory space, distributed storage parameters, security parameters, billing information, user profile information, etc.) for one or more of the user devices <b>12</b>-<b>14</b> (e.g., established for individual devices, established for a user group of devices, established for public access by the user devices, etc.). For example, the DS managing unit <b>18</b> coordinates the creation of a vault (e.g., a virtual memory block) within the DSN memory <b>22</b> for a user device (for a group of devices, or for public access). The DS managing unit <b>18</b> also determines the distributed data storage parameters for the vault. In particular, the DS managing unit <b>18</b> determines a number of slices (e.g., the number that a data segment of a data file and/or data block is partitioned into for distributed storage) and a read threshold value (e.g., the minimum number of slices required to reconstruct the data segment).</p>
<p id="p-0055" num="0054">As another example, the DS managing module <b>18</b> creates and stores, locally or within the DSN memory <b>22</b>, user profile information. The user profile information includes one or more of authentication information, permissions, and/or the security parameters. The security parameters may include one or more of encryption/decryption scheme, one or more encryption keys, key generation scheme, and data encoding/decoding scheme.</p>
<p id="p-0056" num="0055">As yet another example, the DS managing unit <b>18</b> creates billing information for a particular user, user group, vault access, public vault access, etc. For instance, the DS managing unit <b>18</b> tracks the number of times user accesses a private vault and/or public vaults, which can be used to generate a per-access bill. In another instance, the DS managing unit <b>18</b> tracks the amount of data stored and/or retrieved by a user device and/or a user group, which can be used to generate a per-data-amount bill.</p>
<p id="p-0057" num="0056">The DS managing unit <b>18</b> also performs network operations, network administration, and/or network maintenance. As at least part of performing the network operations and/or administration, the DS managing unit <b>18</b> monitors performance of the devices and/or units of the system <b>10</b> for potential failures, determines the devices and/or unit's activation status, determines the devices' and/or units' loading, and any other system level operation that affects the performance level of the system <b>10</b>. For example, the DS managing unit <b>18</b> receives and aggregates network management alarms, alerts, errors, status information, performance information, and messages from the devices <b>12</b>-<b>14</b> and/or the units <b>16</b>, <b>20</b>, <b>22</b>. For example, the DS managing unit <b>18</b> receives a simple network management protocol (SNMP) message regarding the status of the DS processing unit <b>16</b>.</p>
<p id="p-0058" num="0057">The DS managing unit <b>18</b> performs the network maintenance by identifying equipment within the system <b>10</b> that needs replacing, upgrading, repairing, and/or expanding. For example, the DS managing unit <b>18</b> determines that the DSN memory <b>22</b> needs more DS units <b>36</b> or that one or more of the DS units <b>36</b> needs updating.</p>
<p id="p-0059" num="0058">The second primary function (i.e., distributed data storage and retrieval) begins and ends with a user device <b>12</b>-<b>14</b>. For instance, if a second type of user device <b>14</b> has a data file <b>38</b> and/or data block <b>40</b> to store in the DSN memory <b>22</b>, it send the data file <b>38</b> and/or data block <b>40</b> to the DS processing unit <b>16</b> via its interface <b>30</b>. As will be described in greater detail with reference to <figref idref="DRAWINGS">FIG. 2</figref>, the interface <b>30</b> functions to mimic a conventional operating system (OS) file system interface (e.g., network file system (NFS), flash file system (FFS), disk file system (DFS), file transfer protocol (FTP), web-based distributed authoring and versioning (WebDAV), etc.) and/or a block memory interface (e.g., small computer system interface (SCSI), internet small computer system interface (iSCSI), etc.). In addition, the interface <b>30</b> may attach a user identification code (ID) to the data file <b>38</b> and/or data block <b>40</b>.</p>
<p id="p-0060" num="0059">The DS processing unit <b>16</b> receives the data file <b>38</b> and/or data block <b>40</b> via its interface <b>30</b> and performs a distributed storage (DS) process <b>34</b> thereon (e.g., an error coding dispersal storage function). The DS processing <b>34</b> begins by partitioning the data file <b>38</b> and/or data block <b>40</b> into one or more data segments, which is represented as Y data segments. For example, the DS processing <b>34</b> may partition the data file <b>38</b> and/or data block <b>40</b> into a fixed byte size segment (e.g., 2<sup>1 </sup>to 2<sup>n </sup>bytes, where n=&#x3e;2) or a variable byte size (e.g., change byte size from segment to segment, or from groups of segments to groups of segments, etc.).</p>
<p id="p-0061" num="0060">For each of the Y data segments, the DS processing <b>34</b> error encodes (e.g., forward error correction (FEC), information dispersal algorithm, or error correction coding) and slices (or slices then error encodes) the data segment into a plurality of error coded (EC) data slices <b>42</b>-<b>48</b>, which is represented as X slices per data segment. The number of slices (X) per segment, which corresponds to a number of pillars n, is set in accordance with the distributed data storage parameters and the error coding scheme. For example, if a Reed-Solomon (or other FEC scheme) is used in an n/k system, then a data segment is divided into n slices, where k number of slices is needed to reconstruct the original data (i.e., k is the threshold). As a few specific examples, the n/k factor may be 5/3; 6/4; 8/6; 8/5; 16/10.</p>
<p id="p-0062" num="0061">For each slice <b>42</b>-<b>48</b>, the DS processing unit <b>16</b> creates a unique slice name and appends it to the corresponding slice <b>42</b>-<b>48</b>. The slice name includes universal DSN memory addressing routing information (e.g., virtual memory addresses in the DSN memory <b>22</b>) and user-specific information (e.g., user ID, file name, data block identifier, etc.).</p>
<p id="p-0063" num="0062">The DS processing unit <b>16</b> transmits the plurality of EC slices <b>42</b>-<b>48</b> to a plurality of DS units <b>36</b> of the DSN memory <b>22</b> via the DSN interface <b>32</b> and the network <b>24</b>. The DSN interface <b>32</b> formats each of the slices for transmission via the network <b>24</b>. For example, the DSN interface <b>32</b> may utilize an internet protocol (e.g., TCP/IP, etc.) to packetize the slices <b>42</b>-<b>48</b> for transmission via the network <b>24</b>.</p>
<p id="p-0064" num="0063">The number of DS units <b>36</b> receiving the slices <b>42</b>-<b>48</b> is dependent on the distributed data storage parameters established by the DS managing unit <b>18</b>. For example, the DS managing unit <b>18</b> may indicate that each slice is to be stored in a different DS unit <b>36</b>. As another example, the DS managing unit <b>18</b> may indicate that like slice numbers of different data segments are to be stored in the same DS unit <b>36</b>. For example, the first slice of each of the data segments is to be stored in a first DS unit <b>36</b>, the second slice of each of the data segments is to be stored in a second DS unit <b>36</b>, etc. In this manner, the data is encoded and distributedly stored at physically diverse locations to improved data storage integrity and security. Further examples of encoding the data segments will be provided with reference to one or more of <figref idref="DRAWINGS">FIGS. 2-24</figref>.</p>
<p id="p-0065" num="0064">Each DS unit <b>36</b> that receives a slice <b>42</b>-<b>48</b> for storage translates the virtual DSN memory address of the slice into a local physical address for storage. Accordingly, each DS unit <b>36</b> maintains a virtual to physical memory mapping to assist in the storage and retrieval of data.</p>
<p id="p-0066" num="0065">The first type of user device <b>12</b> performs a similar function to store data in the DSN memory <b>22</b> with the exception that it includes the DS processing. As such, the device <b>12</b> encodes and slices the data file and/or data block it has to store. The device then transmits the slices <b>11</b> to the DSN memory via its DSN interface <b>32</b> and the network <b>24</b>.</p>
<p id="p-0067" num="0066">For a second type of user device <b>14</b> to retrieve a data file or data block from memory, it issues a read command via its interface <b>30</b> to the DS processing unit <b>16</b>. The DS processing unit <b>16</b> performs the DS processing <b>34</b> to identify the DS units <b>36</b> storing the slices of the data file and/or data block based on the read command. The DS processing unit <b>16</b> may also communicate with the DS managing unit <b>18</b> to verify that the user device <b>14</b> is authorized to access the requested data.</p>
<p id="p-0068" num="0067">Assuming that the user device is authorized to access the requested data, the DS processing unit <b>16</b> issues slice read commands to at least a threshold number of the DS units <b>36</b> storing the requested data (e.g., to at least 10 DS units for a 16/10 error coding scheme). Each of the DS units <b>36</b> receiving the slice read command, verifies the command, accesses its virtual to physical memory mapping, retrieves the requested slice, or slices, and transmits it to the DS processing unit <b>16</b>.</p>
<p id="p-0069" num="0068">Once the DS processing unit <b>16</b> has received a read threshold number of slices for a data segment, it performs an error decoding function and de-slicing to reconstruct the data segment. When Y number of data segments has been reconstructed, the DS processing unit <b>16</b> provides the data file <b>38</b> and/or data block <b>40</b> to the user device <b>14</b>. Note that the first type of user device <b>12</b> performs a similar process to retrieve a data file and/or data block.</p>
<p id="p-0070" num="0069">The storage integrity processing unit <b>20</b> performs the third primary function of data storage integrity verification. In general, the storage integrity processing unit <b>20</b> periodically retrieves slices <b>45</b>, and/or slice names, of a data file or data block of a user device to verify that one or more slices have not been corrupted or lost (e.g., the DS unit failed). The retrieval process mimics the read process previously described.</p>
<p id="p-0071" num="0070">If the storage integrity processing unit <b>20</b> determines that one or more slices is corrupted or lost, it rebuilds the corrupted or lost slice(s) in accordance with the error coding scheme. The storage integrity processing unit <b>20</b> stores the rebuild slice, or slices, in the appropriate DS unit(s) <b>36</b> in a manner that mimics the write process previously described.</p>
<p id="p-0072" num="0071"><figref idref="DRAWINGS">FIG. 2</figref> is a schematic block diagram of an embodiment of a computing core <b>26</b> that includes a processing module <b>50</b>, a memory controller <b>52</b>, main memory <b>54</b>, a video graphics processing unit <b>55</b>, an input/output (IO) controller <b>56</b>, a peripheral component interconnect (PCI) interface <b>58</b>, at least one IO device interface module <b>62</b>, a read only memory (ROM) basic input output system (BIOS) <b>64</b>, and one or more memory interface modules. The memory interface module(s) includes one or more of a universal serial bus (USB) interface module <b>66</b>, a host bus adapter (HBA) interface module <b>68</b>, a network interface module <b>70</b>, a flash interface module <b>72</b>, a hard drive interface module <b>74</b>, and a DSN interface module <b>76</b>. Note the DSN interface module <b>76</b> and/or the network interface module <b>70</b> may function as the interface <b>30</b> of the user device <b>14</b> of <figref idref="DRAWINGS">FIG. 1</figref>. Further note that the IO device interface module <b>62</b> and/or the memory interface modules may be collectively or individually referred to as IO ports.</p>
<p id="p-0073" num="0072">The processing module <b>50</b> may be a single processing device or a plurality of processing devices. Such a processing device may be a microprocessor, micro-controller, digital signal processor, microcomputer, central processing unit, field programmable gate array, programmable logic device, state machine, logic circuitry, analog circuitry, digital circuitry, and/or any device that manipulates signals (analog and/or digital) based on hard coding of the circuitry and/or operational instructions. The processing module <b>50</b> may have an associated memory and/or memory element, which may be a single memory device, a plurality of memory devices, and/or embedded circuitry of the processing module <b>50</b>. Such a memory device may be a read-only memory, random access memory, volatile memory, non-volatile memory, static memory, dynamic memory, flash memory, cache memory, and/or any device that stores digital information. Note that if the processing module <b>50</b> includes more than one processing device, the processing devices may be centrally located (e.g., directly coupled together via a wired and/or wireless bus structure) or may be distributedly located (e.g., cloud computing via indirect coupling via a local area network and/or a wide area network). Further note that when the processing module <b>50</b> implements one or more of its functions via a state machine, analog circuitry, digital circuitry, and/or logic circuitry, the memory and/or memory element storing the corresponding operational instructions may be embedded within, or external to, the circuitry comprising the state machine, analog circuitry, digital circuitry, and/or logic circuitry. Still further note that, the memory element stores, and the processing module <b>50</b> executes, hard coded and/or operational instructions corresponding to at least some of the steps and/or functions illustrated in <figref idref="DRAWINGS">FIGS. 1-24</figref>.</p>
<p id="p-0074" num="0073"><figref idref="DRAWINGS">FIG. 3</figref> is a schematic block diagram of an embodiment of a dispersed storage (DS) processing module <b>34</b> of user device <b>12</b> and/or of the DS processing unit <b>16</b>. The DS processing module <b>34</b> includes a gateway module <b>78</b>, an access module <b>80</b>, a grid module <b>82</b>, and a storage module <b>84</b>. The DS processing module <b>34</b> may also include an interface <b>30</b> and the DSnet interface <b>32</b> or the interfaces <b>68</b> and/or <b>70</b> may be part of user <b>12</b> or of the DS processing unit <b>14</b>. The DS processing module <b>34</b> may further include a bypass/feedback path between the storage module <b>84</b> to the gateway module <b>78</b>. Note that the modules <b>78</b>-<b>84</b> of the DS processing module <b>34</b> may be in a single unit or distributed across multiple units.</p>
<p id="p-0075" num="0074">In an example of storing data, the gateway module <b>78</b> receives an incoming data object that includes a user ID field <b>86</b>, an object name field <b>88</b>, and the data field <b>40</b> and may also receive corresponding information that includes a process identifier (e.g., an internal process/application ID), metadata, a file system directory, a block number, a transaction message, a user device identity (ID), a data object identifier, a source name, and/or user information. The gateway module <b>78</b> authenticates the user associated with the data object by verifying the user ID <b>86</b> with the managing unit <b>18</b> and/or another authenticating unit.</p>
<p id="p-0076" num="0075">When the user is authenticated, the gateway module <b>78</b> obtains user information from the management unit <b>18</b>, the user device, and/or the other authenticating unit. The user information includes a vault identifier, operational parameters, and user attributes (e.g., user data, billing information, etc.). A vault identifier identifies a vault, which is a virtual memory space that maps to a set of DS storage units <b>36</b>. For example, vault <b>1</b> (i.e., user <b>1</b>'s DSN memory space) includes eight DS storage units (X=8 wide) and vault <b>2</b> (i.e., user <b>2</b>'s DSN memory space) includes sixteen DS storage units (X=16 wide). The operational parameters may include an error coding algorithm, the width n (number of pillars X or slices per segment for this vault), a read threshold T, a write threshold, an encryption algorithm, a slicing parameter, a compression algorithm, an integrity check method, caching settings, parallelism settings, and/or other parameters that may be used to access the DSN memory layer.</p>
<p id="p-0077" num="0076">The gateway module <b>78</b> uses the user information to assign a source name <b>35</b> to the data. For instance, the gateway module <b>60</b> determines the source name <b>35</b> of the data object <b>40</b> based on the vault identifier and the data object. For example, the source name may contain a file identifier (ID), a vault generation number, a reserved field, and a vault identifier (ID). As another example, the gateway module <b>78</b> may generate the file ID based on a hash function of the data object <b>40</b>. Note that the gateway module <b>78</b> may also perform message conversion, protocol conversion, electrical conversion, optical conversion, access control, user identification, user information retrieval, traffic monitoring, statistics generation, configuration, management, and/or source name determination.</p>
<p id="p-0078" num="0077">The access module <b>80</b> receives the data object <b>40</b> and creates a series of data segments <b>1</b> through Y <b>90</b>-<b>92</b> in accordance with a data storage protocol (e.g., file storage system, a block storage system, and/or an aggregated block storage system). The number of segments Y may be chosen or randomly assigned based on a selected segment size and the size of the data object. For example, if the number of segments is chosen to be a fixed number, then the size of the segments varies as a function of the size of the data object. For instance, if the data object is an image file of 4,194,304 eight bit bytes (e.g., 33,554,432 bits) and the number of segments Y=131,072, then each segment is 256 bits or 32 bytes. As another example, if segment sized is fixed, then the number of segments Y varies based on the size of data object. For instance, if the data object is an image file of 4,194,304 bytes and the fixed size of each segment is 4,096 bytes, the then number of segments Y=1,024. Note that each segment is associated with the same source name.</p>
<p id="p-0079" num="0078">The grid module <b>82</b> receives the data segments and may manipulate (e.g., compression, encryption, cyclic redundancy check (CRC), etc.) each of the data segments before performing an error coding function of the error coding dispersal storage function to produce a pre-manipulated data segment. After manipulating a data segment, if applicable, the grid module <b>82</b> error encodes (e.g., Reed-Solomon, Convolution encoding, Trellis encoding, etc.) the data segment or manipulated data segment into X error coded data slices <b>42</b>-<b>44</b>.</p>
<p id="p-0080" num="0079">The value X, or the number of pillars (e.g., X=16), is chosen as a parameter of the error coding dispersal storage function. Other parameters of the error coding dispersal function include a read threshold T, a write threshold W, etc. The read threshold (e.g., T=10, when X=16) corresponds to the minimum number of error-free error coded data slices required to reconstruct the data segment. In other words, the DS processing module <b>34</b> can compensate for X&#x2212;T (e.g., 16&#x2212;10=6) missing error coded data slices per data segment. The write threshold W corresponds to a minimum number of DS storage units that acknowledge proper storage of their respective data slices before the DS processing module indicates proper storage of the encoded data segment. Note that the write threshold is greater than or equal to the read threshold for a given number of pillars (X).</p>
<p id="p-0081" num="0080">For each data slice of a data segment, the grid module <b>82</b> generates a unique slice name <b>37</b> and attaches it thereto. The slice name <b>37</b> includes a universal routing information field and a vault specific field and may be 48 bytes (e.g., 24 bytes for each of the universal routing information field and the vault specific field). As illustrated, the universal routing information field includes a slice index, a vault ID, a vault generation, and a reserved field. The slice index is based on the pillar number and the vault ID and, as such, is unique for each pillar (e.g., slices of the same pillar for the same vault for any segment will share the same slice index). The vault specific field includes a data name, which includes a file ID and a segment number (e.g., a sequential numbering of data segments <b>1</b>-Y of a simple data object or a data block number).</p>
<p id="p-0082" num="0081">Prior to outputting the error coded data slices of a data segment, the grid module may perform post-slice manipulation on the slices. If enabled, the manipulation includes slice level compression, encryption, CRC, addressing, tagging, and/or other manipulation to improve the effectiveness of the computing system.</p>
<p id="p-0083" num="0082">When the error coded data slices of a data segment are ready to be outputted, the grid module <b>82</b> determines which of the DS storage units <b>36</b> will store the EC data slices based on a dispersed storage memory mapping associated with the user's vault and/or DS storage unit attributes. The DS storage unit attributes may include availability, self-selection, performance history, link speed, link latency, ownership, available DSN memory, domain, cost, a prioritization scheme, a centralized selection message from another source, a lookup table, data ownership, and/or any other factor to optimize the operation of the computing system. Note that the number of DS storage units <b>36</b> is equal to or greater than the number of pillars (e.g., X) so that no more than one error coded data slice of the same data segment is stored on the same DS storage unit <b>36</b>. Further note that EC data slices of the same pillar number but of different segments (e.g., EC data slice <b>1</b> of data segment <b>1</b> and EC data slice <b>1</b> of data segment <b>2</b>) may be stored on the same or different DS storage units <b>36</b>.</p>
<p id="p-0084" num="0083">The storage module <b>84</b> performs an integrity check on the outbound encoded data slices and, when successful, identifies a plurality of DS storage units based on information provided by the grid module <b>82</b>. The storage module <b>84</b> then outputs the encoded data slices <b>1</b> through X of each segment <b>1</b> through Y to the DS storage units <b>36</b>. Each of the DS storage units <b>36</b> stores its EC data slice(s) and maintains a local virtual DSN address to physical location table to convert the virtual DSN address of the EC data slice(s) into physical storage addresses.</p>
<p id="p-0085" num="0084">In an example of a read operation, the user device <b>12</b> and/or <b>14</b> sends a read request to the DS processing unit <b>14</b>, which authenticates the request. When the request is authentic, the DS processing unit <b>14</b> sends a read message to each of the DS storage units <b>36</b> storing slices of the data object being read. The slices are received via the DSnet interface <b>32</b> and processed by the storage module <b>84</b>, which performs a parity check and provides the slices to the grid module <b>82</b> when the parity check was successful. The grid module <b>82</b> decodes the slices in accordance with the error coding dispersal storage function to reconstruct the data segment. The access module <b>80</b> reconstructs the data object from the data segments and the gateway module <b>78</b> formats the data object for transmission to the user device.</p>
<p id="p-0086" num="0085"><figref idref="DRAWINGS">FIG. 4</figref> is a schematic block diagram of an embodiment of a grid module <b>82</b> that includes a control unit <b>73</b>, a pre-slice manipulator <b>75</b>, an encoder <b>77</b>, a slicer <b>79</b>, a post-slice manipulator <b>81</b>, a pre-slice de-manipulator <b>83</b>, a decoder <b>85</b>, a de-slicer <b>87</b>, and/or a post-slice de-manipulator <b>89</b>. Note that the control unit <b>73</b> may be partially or completely external to the grid module <b>82</b>. For example, the control unit <b>73</b> may be part of the computing core at a remote location, part of a user device, part of the DS managing unit <b>18</b>, or distributed amongst one or more DS storage units.</p>
<p id="p-0087" num="0086">In an example of write operation, the pre-slice manipulator <b>75</b> receives a data segment <b>90</b>-<b>92</b> and a write instruction from an authorized user device. The pre-slice manipulator <b>75</b> determines if pre-manipulation of the data segment <b>90</b>-<b>92</b> is required and, if so, what type. The pre-slice manipulator <b>75</b> may make the determination independently or based on instructions from the control unit <b>73</b>, where the determination is based on a computing system-wide predetermination, a table lookup, vault parameters associated with the user identification, the type of data, security requirements, available DSN memory, performance requirements, and/or other metadata.</p>
<p id="p-0088" num="0087">Once a positive determination is made, the pre-slice manipulator <b>75</b> manipulates the data segment <b>90</b>-<b>92</b> in accordance with the type of manipulation. For example, the type of manipulation may be compression (e.g., Lempel-Ziv-Welch, Huffman, Golomb, fractal, wavelet, etc.), signatures (e.g., Digital Signature Algorithm (DSA), Elliptic Curve DSA, Secure Hash Algorithm, etc.), watermarking, tagging, encryption (e.g., Data Encryption Standard, Advanced Encryption Standard, etc.), adding metadata (e.g., time/date stamping, user information, file type, etc.), cyclic redundancy check (e.g., CRC32), and/or other data manipulations to produce the pre-manipulated data segment.</p>
<p id="p-0089" num="0088">The encoder <b>77</b> encodes the pre-manipulated data segment <b>92</b> using a forward error correction (FEC) encoder (and/or other type of erasure coding and/or error coding) to produce an encoded data segment <b>94</b>. The encoder <b>77</b> determines which forward error correction algorithm to use based on a predetermination associated with the user's vault, a time based algorithm, user direction, DS managing unit direction, control unit direction, as a function of the data type, as a function of the data segment <b>92</b> metadata, and/or any other factor to determine algorithm type. The forward error correction algorithm may be Golay, Multidimensional parity, Reed-Solomon, Hamming, Bose Ray Chauduri Hocquenghem (BCH), Cauchy-Reed-Solomon, or any other FEC encoder. Note that the encoder <b>77</b> may use a different encoding algorithm for each data segment <b>92</b>, the same encoding algorithm for the data segments <b>92</b> of a data object, or a combination thereof.</p>
<p id="p-0090" num="0089">The encoded data segment <b>94</b> is of greater size than the data segment <b>92</b> by the overhead rate of the encoding algorithm by a factor of X/T, where X is the width or number of slices, and T is the read threshold. In this regard, the corresponding decoding process can accommodate at most X&#x2212;T missing EC data slices and still recreate the data segment <b>92</b>. For example, if X=16 and T=10, then the data segment <b>92</b> will be recoverable as long as 10 or more EC data slices per segment are not corrupted.</p>
<p id="p-0091" num="0090">The slicer <b>79</b> transforms the encoded data segment <b>94</b> into EC data slices in accordance with the slicing parameter from the vault for this user and/or data segment <b>92</b>. For example, if the slicing parameter is X=16, then the slicer <b>79</b> slices each encoded data segment <b>94</b> into 16 encoded slices.</p>
<p id="p-0092" num="0091">The post-slice manipulator <b>81</b> performs, if enabled, post-manipulation on the encoded slices to produce the EC data slices. If enabled, the post-slice manipulator <b>81</b> determines the type of post-manipulation, which may be based on a computing system-wide predetermination, parameters in the vault for this user, a table lookup, the user identification, the type of data, security requirements, available DSN memory, performance requirements, control unit directed, and/or other metadata. Note that the type of post-slice manipulation may include slice level compression, signatures, encryption, CRC, addressing, watermarking, tagging, adding metadata, and/or other manipulation to improve the effectiveness of the computing system.</p>
<p id="p-0093" num="0092">In an example of a read operation, the post-slice de-manipulator <b>89</b> receives at least a read threshold number of EC data slices and performs the inverse function of the post-slice manipulator <b>81</b> to produce a plurality of encoded slices. The de-slicer <b>87</b> de-slices the encoded slices to produce an encoded data segment <b>94</b>. The decoder <b>85</b> performs the inverse function of the encoder <b>77</b> to recapture the data segment <b>90</b>-<b>92</b>. The pre-slice de-manipulator <b>83</b> performs the inverse function of the pre-slice manipulator <b>75</b> to recapture the data segment <b>90</b>-<b>92</b>.</p>
<p id="p-0094" num="0093"><figref idref="DRAWINGS">FIG. 5</figref> is a diagram of an example of slicing an encoded data segment <b>94</b> by the slicer <b>79</b>. In this example, the encoded data segment <b>94</b> includes thirty-two bits, but may include more or less bits. The slicer <b>79</b> disperses the bits of the encoded data segment <b>94</b> across the EC data slices in a pattern as shown. As such, each EC data slice does not include consecutive bits of the data segment <b>94</b> reducing the impact of consecutive bit failures on data recovery. For example, if EC data slice <b>2</b> (which includes bits <b>1</b>, <b>5</b>, <b>9</b>, <b>13</b>, <b>17</b>, <b>25</b>, and <b>29</b>) is unavailable (e.g., lost, inaccessible, or corrupted), the data segment can be reconstructed from the other EC data slices (e.g., 1, 3 and 4 for a read threshold of 3 and a width of 4).</p>
<p id="p-0095" num="0094"><figref idref="DRAWINGS">FIG. 6A</figref> is a flowchart illustrating an example of authenticating a request. The method begins with step <b>102</b> where a processing module (e.g., of a dispersed storage (DS) processing unit) receives a credential from a requester (e.g., a user device). The method continues at step <b>104</b> where the processing module determines whether the credential matches an approved credential from a local authentication list. The determination may be based on whether the credential matches an approved credential in the local authentication list and whether the credential in the local authentication list has not expired (e.g., from a time perspective). The local authentication list includes one or more previously approved credentials (e.g., received from an authentication authority) and an associated one or more timestamps such that a timestamp is paired with each approved credential. The timestamp indicates at least one of how long the credential is approved and when the credential expires. For example, the processing module determines that the credential is approved when the credential matches at least one of the one or more previously approved credentials and the at least one of the one or more previously approved credentials has not expired. The method branches to step <b>108</b> when the processing module determines that the credential does not match the approved credential in the local authentication list. The method continues to step <b>106</b> when the processing module determines that the credential matches the approved credential in the local authentication list. The method continues at step <b>106</b> where the processing module executes an associated request.</p>
<p id="p-0096" num="0095">The method continues at step <b>108</b> where the processing module determines whether the credential matches an approved credential in a remote authentication list (e.g., a list of the authentication authority). For example, the processing module sends an authentication request message to the authentication authority that includes the credential. The processing module receives an authentication response message that indicates whether the credential matches an approved credential in the remote authentication list. The processing module determines that the credential is approved when the authentication response message includes an indication that the credential matches an approved credential in the remote authentication list. The method branches to step <b>112</b> when the processing module determines that the credential matches the approved credential in the remote authentication list. The method continues to step <b>110</b> when the processing module determines that the credential does not match the approved credential and the remote authentication list. The method continues at step <b>110</b> where the processing module rejects the associated request when the processing module determines that the credential is not approved. For example, the processing module sends a reject message to the requester to reject the associated request. Alternatively, the processing module may execute the method as discussed in <figref idref="DRAWINGS">FIG. 6B</figref> when the processing module does not receive the authentication response message in a timely manner (e.g., unable to access the remote authentication list).</p>
<p id="p-0097" num="0096">The method continues at step <b>112</b> where the processing module creates a time stamped approved credential in the local authentication list when the processing module determines that the credential matches the approved credential in the remote authentication list. For example, the processing module stores the credential and an associated expiration timestamp in the local authentication list. The method continues at step <b>114</b> where the processing module executes the associated request.</p>
<p id="p-0098" num="0097"><figref idref="DRAWINGS">FIG. 6B</figref> is a flowchart illustrating an example of refreshing a local authentication list. The method begins with step <b>116</b> where a processing module (e.g., of a dispersed storage (DS) processing unit) identifies an expired approved credential in a local authentication list. The identification may be based on comparing an expiration timestamp associated with the approved credential to a current time. For example, the processing module determines that the approved credential is expired when the current time is greater than the expiration timestamp. The method continues at step <b>118</b> where the processing module determines whether a remote authentication list is accessible. The determination may be based on whether an authorization authority containing the remote authentication list is accessible (e.g., online). For example, the processing module determines that the remote authentication list is accessible when the processing module receives an accessibility response message from the authorization authority in response to receiving an accessibility inquiry message from the processing module. The method branches to step <b>122</b> when the processing module determines that the remote authentication list is not accessible. The method continues to step <b>120</b> when the processing module determines that the remote authentication list is accessible. The method continues at step <b>120</b> where the processing module deletes the expired approved credential from the local authentication list. The method continues at step <b>122</b> where the processing module converts the expired approved credential to an active approved credential when the processing module determines that the remote authentication list is not accessible. For example, the processing module extends the expiration timestamp associated with the expired approved credential to convert the expired approved credential to an active approved credential. In an instance, the processing module extends the expiration timestamp by one day.</p>
<p id="p-0099" num="0098"><figref idref="DRAWINGS">FIG. 7A</figref> is a diagram illustrating an example of an authentication sequence bounce diagram between a user device <b>12</b>, a dispersed storage (DS) unit <b>36</b>, and a DS managing unit <b>18</b>. The sequence begins with a data accessing module (e.g., user device <b>12</b>) of a dispersed storage network (DSN) sending a data access request <b>124</b> to a data storage module (e.g., DS unit <b>36</b>, DS processing unit <b>16</b>) of the DSN. Alternatively, or in addition to, the data accessing module sends a set of data access requests <b>124</b> to a set of data storage modules of the DSN. A data access request includes one or more of a read request, a write request, a list request, a delete request, and an edit request. The sequence continues where the data storage module identifies an authenticating module (e.g., DS managing unit <b>18</b>) of the DSN for the data accessing module based on the data access request. For example, the data storage module extracts a user device identifier (ID) from the data access request and utilizes the user device ID in an authenticating module table lookup. The sequence continues where the data storage module sends an authentication request <b>126</b> to the authenticating module, wherein the authentication request <b>126</b> includes at least a portion of the data access request. For example, the authentication request includes the user device ID, a request type, and a data ID.</p>
<p id="p-0100" num="0099">The sequence continues where the authenticating module outputs a verification request <b>128</b> destined for the data accessing module, wherein the verification request <b>128</b> includes a verification code that is generated based on the authentication request. A verification code may be unique for the data access request and user ID and may include one or more of a random number, a random string of characters, a nonce, a sequential number, and a number based on a table lookup. The outputting of the verification request by the authentication module includes sending the verification request to the data storage module and forwarding, by the data storage module, the verification request to the data accessing module.</p>
<p id="p-0101" num="0100">The sequence continues where the data accessing module outputs a verification response <b>130</b> destined for the authenticating module, wherein the verification response <b>130</b> includes a modified verification code that is generated based on the verification code and a credential. The credential includes at least one of a locally stored password, a remotely retrieved stored password, a password from a user input, a key, and an authenticator. The generating of the modified verification code includes one or more of performing a verifying function (e.g., a deterministic function, a hashing function, encryption, other mathematical manipulation) on the verification code and the credential to produce the modified verification code; generating a second random string of characters; obtaining a certificate chain; generating a signature over the second random string of characters and the verification request; and obtaining a signature algorithm indicator. The signature is generated utilizing a private key associated with the data accessing module. The outputting of the verification response <b>130</b> by the data accessing module includes sending the verification response <b>130</b> to the data storage module and forwarding, by the data storage module, the verification response <b>130</b> to the authenticating module.</p>
<p id="p-0102" num="0101">The sequence continues where the authenticating module outputs an authentication response <b>132</b> to the data storage module, wherein the authentication response <b>132</b> is generated based on the verification response <b>130</b>. The generating of the authentication response <b>132</b> includes performing the verifying function on the verification code and a reference credential to produce a reference verification code, comparing the modified verification code with the reference verification code, and when the comparison is favorable, generating the authentication response <b>132</b> to indicate a favorable authentication. A reference credential includes a stored credential. Alternatively, the generating of the authentication response <b>132</b> includes verifying the signature of the verification response <b>130</b>, utilizing a public key associated with the data accessing module, and when the verifying is favorable, generating the authentication response <b>132</b> to indicate a favorable authentication.</p>
<p id="p-0103" num="0102">The sequence continues where the data storage module facilitates the data access request when the authentication response <b>132</b> is favorable. The facilitation may include outputting a data access response <b>134</b> to the data accessing module. For example, the data storage module outputs a data access response <b>134</b> that includes an encoded data slice that corresponds to a slice name when the data access request <b>124</b> includes a read request for the slice name. The method of operation of the data storage module and the authenticating module is discussed in greater detail of reference to <figref idref="DRAWINGS">FIGS. 7B and 7C</figref>.</p>
<p id="p-0104" num="0103"><figref idref="DRAWINGS">FIG. 7B</figref> is a flowchart illustrating an example of authenticating a data access request. The method begins with step <b>136</b> where a processing module (e.g., of a storage module) receives a data access request from a data accessing module of a dispersed storage network (DSN). The method continues at step <b>138</b> where the processing module identifies an authenticating module for the data accessing module based on the data access request. The method continues at step <b>140</b> where the processing module sends an authentication request to the authenticating module of the DSN, wherein the authentication request includes at least a portion of the data access request. The method continues at step <b>142</b> where the processing module receives an authentication response from the authenticating module, wherein the authentication response is generated based on a verification response of the data accessing module. The method continues at step <b>144</b> with a processing module facilitates the data access request when the authentication response is favorable.</p>
<p id="p-0105" num="0104"><figref idref="DRAWINGS">FIG. 7C</figref> is a flowchart illustrating an example of processing an authentication request. The method begins with step <b>146</b> where a processing module (e.g., of an authenticating module) receives an authentication request from a data storage module of a dispersed storage network (DSN), wherein the authentication request includes at least a portion of a data access request of a data accessing module of the DSN. The method continues at step <b>148</b> where the processing module outputs a verification request destined for the data accessing module, wherein the verification request includes a verification code that is generated based on the authentication request. The method continues at step <b>150</b> where the processing module receives a verification response, wherein the verification response includes a modified verification code that is generated by the data accessing module based on the verification code and a credential. The method continues at step <b>152</b> where the processing module outputs an authentication response that is generated based on the verification response, wherein, the data access request is authenticated when the authentication response is favorable. The generating the authentication response includes performing a verifying function on the verification code and a reference credential to produce a reference verification code, comparing the modified verification code with the reference verification code, and when the comparison is favorable, generating the authentication response to indicate a favorable authentication.</p>
<p id="p-0106" num="0105"><figref idref="DRAWINGS">FIG. 8A</figref> is a flowchart illustrating an example of acquiring an authentication token. The method begins at step <b>154</b> where a processing module (e.g., a user device) generates and sends an authentication token request message that includes a credential. The credential includes one or more of a user device identifier (ID), a password, a hash of the password, and a signature. For example, the processing module of a user device sends the request to an authentication authority (e.g., a DS managing unit). The authentication authority receives the authentication token request message and generates an authentication token response message in response. The method of operation of the authentication authority is discussed in greater detail with reference to <figref idref="DRAWINGS">FIG. 8B</figref>. The method continues at step <b>156</b> where the processing module receives the authentication token response message. The authentication token response message includes an authentication token, wherein the token includes one or more of a permission, a timestamp associated with the permission, and a signature signed by the authentication authority.</p>
<p id="p-0107" num="0106">The method continues at step <b>158</b> where the processing module generates a dispersed storage network (DSN) access request. The generation may be based on one or more of a user input, an application output, a read sequence, a write sequence, an access requirement, and a transfer requirement. For example, the processing module executes a storage sequence of a data object by generating a write request as the DSN access request. The method continues at step <b>160</b> where the processing module determines whether the authentication token is applicable to the request. The processing module determines that the authentication token is applicable to the request when the request is allowable based on permissions associated with the authentication token. For example, the processing module determines that the authentication token is applicable to the request when the request is a write request and a permission allows the processing module to perform an associated write sequence (e.g., for a particular vault). The method repeats back to step <b>154</b> when the processing module determines that the authentication token is not applicable. The method continues to step <b>162</b> when the processing module determines that the authentication token is applicable.</p>
<p id="p-0108" num="0107">The method continues at step <b>162</b> where the processing module sends a request message that includes the DSN access request and the authentication token. For example, the processing module sends the request message to a dispersed storage (DS) unit to write an encoded data slice to the DS unit. The method of operation to process the request message is discussed in greater detail with reference to <figref idref="DRAWINGS">FIG. 9</figref>.</p>
<p id="p-0109" num="0108"><figref idref="DRAWINGS">FIG. 8B</figref> is a flowchart illustrating an example of processing an authentication token request. The method begins with step <b>164</b> where a processing module (e.g., of an authentication authority) receives an authentication token request message that includes a credential. For example, the processing module receives the authentication token request from a user device. The method continues at step <b>166</b> where the processing module verifies the credential (e.g., comparing a decrypted signature to a hash of the request message). At step <b>166</b>, the processing module determines whether the credential is valid based on comparing an element of the credential to a stored representation of the credential. For example the processing module determines that the credential is valid when a comparison of a password of the credential to a stored password associated with an identification of a user device indicates that the password and the stored password are substantially the same. The method branches to step <b>170</b> when the processing module determines that the credential is valid. The processing module continues to step <b>168</b> when the processing module determines that the credential is not valid. The method continues at step <b>168</b> where the processing module rejects the authentication token request when the processing module determines that the credential is not valid. For example, the processing module rejects the authentication token request by sending an authentication token reject response message to the user device.</p>
<p id="p-0110" num="0109">The method continues at step <b>170</b> where the processing module determines permissions based on one or more of information contained in the authentication token request message, a query, a lookup, predetermination, a message, and a command. For example, the processing module determines the permissions by a lookup into a permissions table associated with a user device identifier (ID) included in the authentication token request message. The method continues at step <b>172</b> where the processing module determines a token expiration. The determination may be based on one or more of a requester identification, a predetermined time, a time associated with the requester identification, a request type, a message, and a command. The method continues at step <b>174</b> where the processing module generates a signature for the authentication token. For example, the processing module generates an encrypted hash of the permissions and token expiration (and any other elements of the authentication token) utilizing a private key associated with the processing module. The method continues at step <b>176</b> where the processing module generates an authentication token by aggregating the permissions, the token expiration, and the signature. The method continues at step <b>178</b> where the processing module sends the authentication token (e.g., to the user device).</p>
<p id="p-0111" num="0110"><figref idref="DRAWINGS">FIG. 9</figref> is a flowchart illustrating an example of processing a request message. The method begins with step <b>180</b> where a processing module (e.g., of a dispersed storage (DS) unit) receives a request message that includes an authentication token. The method continues at step <b>182</b> where the processing module determines whether a signature associated with the authentication token is valid (e.g., indicating valid when a comparison of a decrypted signature to a hash of the authentication token indicates that they are substantially the same). The method branches to step <b>186</b> when the processing module determines that the signature is valid. The method continues to step <b>184</b> when the processing module determines that the signature is not valid. The method continues at step <b>184</b> where the processing module rejects the request message when the processing module determines that the signature is not valid. For example, the processing module sends a reject response message to a requester associated with the request.</p>
<p id="p-0112" num="0111">The method continues at step <b>186</b> where the processing module determines valid permissions based on permissions included in the authentication token. The method continues at step <b>188</b> where the processing module determines whether the valid permissions are applicable to the request. For example, the processing module determines that the valid permissions are applicable when the valid permissions substantially encompasses the request. For instance, the processing module determines that the valid permissions are applicable when the valid permissions allow a read request to access vault <b>100</b> for a user device identifier (ID) <b>356</b> and the request is from user device ID <b>356</b> to read data from vault <b>100</b>.</p>
<p id="p-0113" num="0112">The method branches to step <b>192</b> when the processing module determines that the valid permissions are applicable. The method continues to step <b>190</b> when the processing module determines that the valid permissions are not applicable. The method continues at step <b>190</b> where the processing module rejects the request message when the processing module determines that the valid permissions are not applicable. For example, the processing module sends the reject response message to the requester and a DS managing unit. The method continues at step <b>192</b> where the processing module executes a request of the request message in accordance with the valid permissions when the processing module determines that the valid permissions are applicable. For example, the processing module accesses vault <b>100</b> for device ID <b>356</b>.</p>
<p id="p-0114" num="0113"><figref idref="DRAWINGS">FIG. 10</figref> is a flowchart illustrating an example of retrieving error coded data slices. The method begins with step <b>194</b> where a processing module (e.g., of a dispersed storage (DS) processing module) determines a data segment to retrieve. The determination may be based on one or more of an access request, a data object name, a source name, a data segment identifier, a list, a query, a message, and a command. For example, the processing module receives a data object retrieval request message and determines the data segment to retrieve based on converting a data object name of the data object into a source name of the data object. The method continues at step <b>196</b> where the processing module determines DS units to retrieve slices based on one or more of the data segment identifier, the source name, a slice name, and a virtual dispersed storage network (DSN) address to physical location table lookup.</p>
<p id="p-0115" num="0114">The method continues at step <b>198</b> where the processing module determines performance parameters. The performance parameters may include one or more of input port bandwidth limitations, link speeds, a current average input port loading, DS unit performance history, a number of DS units, error coding dispersal storage function parameters, and retrieval sequences in progress. For example, the processing module determines the performance parameters to include a 100 Mb per second input port bandwidth limitation and a current average input port loading of 60 Mb per second.</p>
<p id="p-0116" num="0115">The method continues at step <b>200</b> where the processing module determines a retrieval method based on one or more of the performance parameters, a performance threshold, a number of DS units, a priority indicator, a performance indicator, a security indicator, a command, and a message. The retrieval method includes sequencing the sending of retrieval messages to the DS units in a timed pattern such that the average input port loading is less than the input port bandwidth limitation. For example, processing module spaces the retrievals in time to avoid exceeding an input port bandwidth limitation.</p>
<p id="p-0117" num="0116">The method continues at step <b>202</b> where the processing module sends retrieval messages in accordance with the retrieval method. The processing module may change the retrieval method based on updated performance parameters during the sending of the retrieval messages. The method continues at step <b>204</b> where the processing module receives error coded data slices from the DS units. The processing module may update the performance parameters based on performance of receiving of the error coded data slices. The method continues at step <b>206</b> where the processing module decodes the error coded data slices in accordance with an error coding dispersal storage function to produce the data segment.</p>
<p id="p-0118" num="0117"><figref idref="DRAWINGS">FIG. 11</figref> is a flowchart illustrating an example of processing a write request. The method begins with step <b>208</b> where a processing module (e.g., of a dispersed storage (DS) unit) receives a write request regarding an encoded data slice. The write request includes one or more of a write request opcode, a slice name, an encoded data slice, and a slice length. The method continues at step <b>210</b> where the processing module determines whether the write request pertains to deleting the encoded data slice from a memory space (e.g., a memory space of a memory associated with the processing module). The determining whether the write request pertains to deleting the encoded data slice includes interpreting the slice length field of the write request, indicating that the write request pertains to deleting the encoded data slice when the slice length field includes a first value, and indicating that the write request does not pertain to deleting the encoded data slice when the slice length field includes a second value. Such a value includes at least one of a number, a delete flag, and a delete code. For example, a first value includes a number zero and a second value includes a non-zero number. The method branches to step <b>218</b> when the processing module determines that the write request does not pertain to deleting the encoded data slice. The method continues to step <b>212</b> when the processing module determines that the write request pertains to deleting the encoded data slice.</p>
<p id="p-0119" num="0118">The method continues at step <b>212</b> where the processing module stores a deletion marker regarding the encoded data slice when the write request pertains to deleting the encoded data slice. For example, the processing module stores the deletion marker in a local directory. The method continues at step <b>214</b> where the processing module determines when to delete the encoded data slice based on the deletion marker and in accordance with a deletion scheme. The determining when to delete the encoded data slice includes at least one of deleting the encoded data slice when memory availability compares unfavorably to a memory availability threshold, deleting the encoded data slice when a predetermined period of time has expired after receiving the write request, deleting the encoded data slice when utilization of the memory space compares unfavorably to a memory space usage threshold, and deleting the encoded data slice based on a deletion instruction of the write request (e.g., receiving an instruction to immediately delete).</p>
<p id="p-0120" num="0119">The memory availability includes a number of available bytes of a memory associated with the processing module (e.g., of a DS unit). For example, the processing module determines that memory availability compares unfavorably to the memory availability threshold when memory availability is less than the memory availability threshold. The utilization of the memory space includes a number of utilized bytes of a memory associated with one of the processing module (e.g., of a DS unit) and a vault (e.g., associated with one or more user devices such as a vault). For example, the processing module determines that utilization of the memory space compares unfavorably to the memory space usage threshold when utilization of the memory space is greater than the memory space usage threshold. The method loops back to step <b>214</b> when the processing module determines not to delete the encoded data slice. The method continues to step <b>216</b> one the processing module determines to delete the encoded data slice. The method continues at step <b>216</b> where the processing module deletes the encoded data slice. For example, the processing module deletes the encoded data slice from the memory and deletes the deletion marker from the local directory.</p>
<p id="p-0121" num="0120">The method continues at step <b>218</b> where the processing module determines whether storing the encoded data slice is allowable when the write request does not pertain to deleting the encoded data slice, wherein the encoded data slice is received with the write request. The determining whether the storing the encoded data slice is allowable includes at least one of indicating that storing the received encoded data slice is allowable when the received encoded data slice is associated with a directory file (e.g., based on a flag, a query, directory information associated with the write request, matching a slice name, a message, and a command), indicating that storing the received encoded data slice is allowable when memory availability compares favorably to a memory availability threshold, and indicating that storing the received encoded data slice is allowable when utilization of the memory space compares favorably to a memory space usage threshold. The method branches to step <b>222</b> when the processing module determines that storing the encoded data slice is allowable. The method continues to step <b>220</b> when the processing module determines that storing the encoded data slice is not allowable. The method continues at step <b>220</b> where the processing module sends an error response message to a requesting entity when the storing is not allowable. The method continues at step <b>222</b> where the processing module stores the received encoded data slice when the storing is allowable.</p>
<p id="p-0122" num="0121"><figref idref="DRAWINGS">FIG. 12</figref> is a flowchart illustrating an example of determining storage generation operational modes. The method begins with step <b>240</b> where a processing module (e.g., of a dispersed storage (DS) processing module) determines generations based on one or more of a generation list, which generation the process left off with last time, an error message, a vault identifier, a message, and a command. The method continues at step <b>242</b> where the processing module determines a status of DS unit storage sets associated with the generations, wherein the DS unit storage set determinations are based on one or more of a lookup, a query, a list, a message, and a command. The status may include one or more of a ping time, a write speed indicator, a read speed indicator, an availability history, a reliability history, cost, power availability, and utilization. The method continues at step <b>244</b> where the processing module determines loading requirements. The loading requirements include at least one of read operations per unit of time and write operations per unit of time. The determination may be based on one or more of a read history record, a write history record, a number of readers predictor, a number of writers predictor, a read activity predictor, and a write activity predictor. For example, the processing module determines the loading requirements to include 15,000 read operations per minute and 1,000 write operations per minute based on aggregating the historical and predictive records.</p>
<p id="p-0123" num="0122">The method continues at step <b>246</b> where the processing module determines which generations to be write capable based on one or more of a status of the DS unit storage sets, the loading requirements, system preferences, a message, and a command. For example, the processing module determines DS unit storage set <b>500</b> to be write capable when the status of DS unit storage set <b>500</b> indicates that memory utilization is less than a utilization threshold. As another example, the processing module determines DS unit storage sets <b>430</b>, <b>395</b>, and <b>632</b> to be write capable when the loading requirements indicates a number of predicted writers is greater than a number of writers threshold. In such an instance, a system performance improvement is realized by activating multiple DS unit storage sets to process write sequence activity from many writers.</p>
<p id="p-0124" num="0123">The method continues at step <b>248</b> where the processing module determines which generations to be read capable based on one or more of the status of the DS unit storage sets, the loading requirements, system preferences, a message, and a command. For example, the processing module determines DS unit storage set <b>700</b> to be read capable when the status of DS unit storage set <b>600</b> indicates that memory utilization is near a utilization threshold. As another example, the processing module determines DS unit storage sets <b>111</b>, <b>327</b>, and <b>948</b> to be read capable when the loading requirements indicates a number of predicted readers is greater than a number of readers threshold. In such an instance, a system performance improvement is realized by activating multiple DS unit storage sets to process read sequence activity from many readers.</p>
<p id="p-0125" num="0124">The method continues at step <b>250</b> where the processing module determines generation modes. The generations modes includes one or more of DS unit power off, DS unit power on, DS unit memory spin down, DS unit memory spin up, DS unit off-line, and DS unit online. Such a determination may be based on one or more of which generations are write capable, which generations are read capable, status of the DS unit storage sets, loading requirements, system preferences, a message, and a command. For example, the processing module determines the generation mode for DS unit storage set <b>948</b> to be DS unit memory spin down when loading requirements indicates that system performance is satisfactory without utilizing DS unit storage set <b>948</b>. The method continues at step <b>252</b> where the processing module sends mode control request messages to the DS unit storage sets in accordance with the generation modes.</p>
<p id="p-0126" num="0125"><figref idref="DRAWINGS">FIG. 13</figref> is a flowchart illustrating an example of manipulating pre-slice data. The method begins with step <b>254</b> where a processing module (e.g., of a dispersed storage (DS) processing unit) receives a data segment. For example, a processing module receives the data segment with metadata associated with the data segment. The metadata may include one or more of a data object name, a data object type, magic values, header information, data object content attributes, data object size, a user identifier (ID), a priority indicator, a security indicator, an integrity check indicator, an encryption indicator, a compression indicator, and a performance indicator. The method continues at step <b>256</b> where the processing module determines whether to statistically test the data segment. The determination may be based on the metadata. For example, the processing module determines to not statistically test the data segment when the metadata indicates that a file name extension is associated with a data object type that is already compressed. The method branches to step <b>264</b> when the processing module determines to not statistically test the data segment. The method continues to step <b>258</b> when the processing module determines to statistically test the data segment.</p>
<p id="p-0127" num="0126">The method continues at step <b>258</b> where the processing module statistically tests the data segment to determine compressibility. For example, the processing module compresses a portion of the data segment and compares a resulting compressed portion to the portion to determine if the difference is more than a compressibility threshold. The method continues at step <b>260</b> where the processing module determines whether to apply a compression codec based on the statistical test. For example, the processing module determines to not apply the compression codec when the statistical test indicates that the difference between the compressed portion and a portion is less than the compressibility threshold. The method branches to step <b>264</b> when the processing module determines to not apply the compression codec. The method continues to step <b>262</b> when the processing module determines to apply the compression codec. The method continues at step <b>262</b> where the processing module determines the compression codec when the processing module determines to apply the compression codec. The determination may be based on one or more of the statistical test (e.g., compressibility), a compression codec table lookup, a compression codec matching algorithm, a message, and a command.</p>
<p id="p-0128" num="0127">The method continues at step <b>264</b> where the processing module determines whether to apply an encryption codec based on determining whether the data segment is already encrypted. For example, the processing module analyzes the data segment to determine a randomness factor and compares the randomness factor to a randomness threshold. Next, the processing module indicates to apply the encryption codec when the comparison indicates that the randomness factor is greater than the randomness threshold. As another example, the processing module determines that the data segment is encrypted based on the security indicator and/or encryption indicator of the metadata. The method branches to step <b>268</b> when the processing module determines to not apply the encryption codec. The method continues to step <b>266</b> when the processing module determines to apply the encryption codec. The method continues at step <b>266</b> where the processing module determines the encryption codec when the processing module determines to apply the encryption codec. The determination may be based on one or more of the randomness factor, the security indicator, the encryption indicator, an encryption codec table lookup, an encryption codec matching algorithm, a message, and a command.</p>
<p id="p-0129" num="0128">The method continues at step <b>268</b> where the processing module determines whether to apply an integrity check codec based on determining whether an integrity check has already been applied to the data segment. For example, the processing module analyzes the data segments to determine if one or more of a signature, a hash, a checksum have been applied. As another example, the processing module determines that the integrity check has already been applied to the data segment based on the integrity check indicator of the metadata. The method branches to step <b>272</b> when the processing module determines to not apply the integrity check codec. The method continues to step <b>270</b> when the processing module determines to apply the integrity check codec. The method continues at step <b>270</b> where the processing module determines the integrity check codec when the processing module determines to apply the integrity check codec. The determination may be based on one or more of the integrity check determination, the integrity check indicator, an integrity check codec table lookup, an integrity check codec matching algorithm, a message, and a command.</p>
<p id="p-0130" num="0129">The method continues at step <b>272</b> where the processing module performs the codec functions on the data segment in accordance with the compression codec, the encryption codec, and the integrity check codec as previously determined. For example, the processing module applies all three codec types to the data segment when all three codec types are desired. As another example, the processing module applies none of the three codec types to the data segment when none of the codec types are desired. As yet another example, the processing module applies one codec type but not the other two codec types. In addition, the processing module may update a codec stack to indicate the ordering of the codec functions as applied to the data segment to enable subsequent post-slice data de-manipulation in the reverse order. The method may continue to apply more codecs to the data segment in the same or more categories. For example, the processing module may apply the compression codec, the encryption codec, a second encryption codec and the integrity check codec.</p>
<p id="p-0131" num="0130"><figref idref="DRAWINGS">FIG. 14</figref> is a flowchart illustrating an example of error correcting a data slice. The method begins with step <b>274</b> where a processing module (e.g., a dispersed storage (DS) processing unit) receives a data segment retrieval request. For example, the processing module retrieves a plurality of data segments to re-create a data object by generating a plurality of retrieval requests for the plurality of data segments. The method continues at step <b>276</b> where the processing module generates a plurality of data slice retrieval requests to retrieve a decode threshold number of error coded data slices in response to receiving the data segment retrieval request. For example, the processing module receives a source name associated with the data segment, determines a plurality of slice names for the data segment, determines a plurality of DS units associated with the plurality of slice names, and sends the plurality of data slice retrieval requests to the plurality of DS units. At step <b>276</b>, the processing module receives a decode threshold number of error coded data slices in response to the plurality of retrieval requests.</p>
<p id="p-0132" num="0131">The method continues at step <b>278</b> where the processing module decodes the error coded data slices in accordance with an error coding dispersal storage function to produce a decoded data segment and a validity indicator. For example, the processing module calculates a hash of the decoded data segment to produce the validity indicator. At step <b>278</b>, the processing module determines whether the decoded data segment is valid by comparing a stored validity indicator (e.g., associated with the data segment) with the validity indicator. The processing module determines that the decoded data segment is valid when the stored validity indicator and the validity indicator are substantially the same. The method branches to step <b>282</b> when the processing module determines that the decoded data segment is not valid. The method continues to step <b>280</b> when the processing module determines that the decoded data segment is valid. The method continues at step <b>280</b> where the processing module utilizes the decoded data segment as the data segment when the processing module determines that the decoded data segment is valid.</p>
<p id="p-0133" num="0132">The method continues at step <b>282</b> where the processing module determines a pillar combination such that the pillar combination specifies which pillars to retrieve and utilize data slices in an attempt to re-create a valid decoded data segment. Such a determination may be based on one or more of the pillar width, the threshold, a number of pillar combinations, which pillar combinations resulted in a previous test with a valid decoded data segment, and which pillar combinations resulted in a previous test with an invalid the decoded data segment. The processing module may utilize one or more techniques to determine the one or more data slices in error. For example, the processing module may choose to utilize slices from different pillar groups to initially determine where an error is sourced from. In an instance, the processing module may choose to utilize pillars <b>1</b>-<b>3</b> in a first test and pillars <b>3</b>-<b>5</b> in a second test when the pillar width is 5 and the threshold is 3. As another technique, the processing module may eliminate one pillar at a time. In an instance, the processing module may choose to utilize the following pillar combinations to eliminate pillar <b>2</b>: <b>1</b>, <b>3</b>, <b>4</b>; <b>1</b>, <b>3</b>, <b>5</b>; <b>1</b>, <b>4</b>, <b>5</b>; and <b>3</b>, <b>4</b>, <b>5</b>.</p>
<p id="p-0134" num="0133">The method continues at step <b>284</b> where the processing module retrieves error coded data slices of other pillar(s) in accordance with the pillar combination. The processing module may retrieve data slices of all of the pillars at once and subsequently perform the validity testing of decoded data segments from different combinations of pillars. The method continues at step <b>286</b> where the processing module decodes the error coded data slices in accordance with the error coding dispersal storage function to produce a subsequent decoded data segment and a subsequent validity indicator. At step <b>286</b>, the processing module determines whether the subsequent decoded data segment is valid. The method branches back to step <b>282</b> (e.g., to try another pillar combination) when the processing module determines that the subsequent decoded data segment is not valid. The method continues to step <b>290</b> when the processing module determines that the subsequent decoded data segment is valid.</p>
<p id="p-0135" num="0134">The method continues at step <b>290</b> where the processing module utilizes the subsequent decoded data segment as the data segment when the processing module determines that the subsequent data segment is valid. Alternatively, or in addition to, the processing module may end the testing loop when the error status has been determined for each data slice (e.g., each of the data slices in error have been identified). Alternatively, the process fails if all possible pillar combinations have been tried without producing a valid subsequent decoded data segment.</p>
<p id="p-0136" num="0135">The method continues at step <b>292</b> where the processing module encodes the data segment in accordance with the error coding dispersal storage function to produce an error-free set of error coded data slices. The method continues at step <b>294</b> where the processing module compares the retrieved error coded data slices to the error-free set of error coded data slices to identify the retrieved error coded data slice(s) (and pillars) in error (e.g., a difference signifies an error). The method continues at step <b>296</b> where the processing module sends an error-free error coded data slice to a DS unit, wherein the DS unit corresponds to the pillar of the retrieved error coded data slice in error. The DS unit replaces the error coded data slice in error with the error-free error coded data slice. Alternatively, or in addition to, the processing module initiates a rebuilding process to identify and repair data slices in error.</p>
<p id="p-0137" num="0136"><figref idref="DRAWINGS">FIGS. 15A-15D</figref> depict an example of a dispersed storage network (DSN) memory where a first plurality of DS units <b>36</b> are implemented in a local location and a second plurality of DS units <b>36</b> are implemented in a remote location. For example, the local location is proximate to a DS processing unit utilized to store and retrieve data slices to the DSN memory and the remote location is not proximate to the DS processing unit and the local location. As such, the network <b>24</b> operably couples the DS processing unit to the plurality of DS units <b>36</b> at the remote location. <figref idref="DRAWINGS">FIGS. 15A-15D</figref> individually depict configuration examples of error coding dispersal storage function parameters (e.g., pillar width, threshold) and pillar assignments to DS units of one or both of the plurality of DS units. Note that the configurations are associated with a storage policy that includes optimization objectives such as cost, reliability, security, and performance. The configurations and objectives are discussed in greater detail with reference to <figref idref="DRAWINGS">FIGS. 15A-15D</figref>. A method to determine and implement the configuration of the storage policy is discussed in greater detail with reference to <figref idref="DRAWINGS">FIG. 16</figref>.</p>
<p id="p-0138" num="0137"><figref idref="DRAWINGS">FIG. 15A</figref> is a schematic block diagram of an embodiment of a pillar assignment of a dispersed storage network (DSN) memory. The DSN memory includes a plurality of dispersed storage (DS) units <b>36</b> at a local location <b>298</b> and a plurality of DS units <b>36</b> at a remote location <b>300</b>. Combinations of DS units <b>36</b> from one or both of the local location <b>298</b> and the remote location <b>300</b> may be assigned to form a DS unit storage set in accordance with a system design objective, wherein the DS unit storage set accommodates storing a pillar width number (n) of encoded data slices as a set of encode slices. For example, pillars <b>1</b>-<b>5</b> of a set of encoded data slices are assigned to five DS units <b>36</b> of the local location <b>298</b> when a pillar width n=5 and a decode threshold k=3 (e.g., no pillars of the set of encoded data slices are assigned to DS units of the remote location <b>300</b>). Such a configuration may be associated with a system designed objective of low-cost since utilized DS units <b>36</b> are all located at the local location <b>298</b> (e.g., no remote location <b>300</b> costs) and the pillar width is relatively low as compared to other configurations thus lowering costs associated DS units <b>36</b>.</p>
<p id="p-0139" num="0138"><figref idref="DRAWINGS">FIG. 15B</figref> is a schematic block diagram of another embodiment of a pillar assignment of a dispersed storage network (DSN) memory. The DSN memory includes a plurality of dispersed storage (DS) units <b>36</b> at a local location <b>298</b> and a plurality of DS units <b>36</b> at a remote location <b>300</b>. In an implementation example, pillars <b>1</b>-<b>3</b> of a set of encoded data slices are assigned to three DS units <b>36</b> of the local location <b>298</b> and pillars <b>4</b>-<b>5</b> of the set of encoded data slices are assigned two DS units <b>36</b> of the remote location <b>300</b> when a pillar width n=5 and a decode threshold k=2. Such a configuration may be associated with a system designed objective of improved reliability since a decode threshold number of pillars are included in both the local location <b>298</b> and the remote location <b>300</b>. As such, data may be retrieved from one location even when the other location is not available</p>
<p id="p-0140" num="0139"><figref idref="DRAWINGS">FIG. 15C</figref> is a schematic block diagram of another embodiment of a pillar assignment of a dispersed storage network (DSN) memory. The DSN memory includes a plurality of dispersed storage (DS) units <b>36</b> at a local location <b>298</b> and a plurality of DS units <b>36</b> at a remote location <b>300</b>. In an implementation example, pillars <b>1</b>-<b>5</b> of a set of encoded data slices are assigned to five DS units <b>36</b> of the local location <b>298</b> and pillars <b>6</b>-<b>10</b> of the set of encoded data slices are assigned five DS units <b>36</b> of the remote location <b>300</b> when a pillar width n=10 and a decode threshold k=6. Such a configuration may be associated with a system designed objective of improved security since the decode threshold is relatively high with respect to the pillar width, encoded data slices of the pillars are stored in more than one location, and a decode threshold number of encoded data slices does not exist at a single location.</p>
<p id="p-0141" num="0140"><figref idref="DRAWINGS">FIG. 15D</figref> is a schematic block diagram of another embodiment of a pillar assignment of a dispersed storage network (DSN) memory. The DSN memory includes a plurality of dispersed storage (DS) units <b>36</b> at a local location <b>298</b> and a plurality of DS units <b>36</b> at a remote location <b>300</b>. In an implementation example, pillars <b>1</b>-<b>5</b> of a set of encoded data slices are assigned to five DS units <b>36</b> of the local location <b>298</b> and pillars <b>6</b>-<b>10</b> of the set of encoded data slices are assigned five DS units <b>36</b> of the remote location <b>300</b> when a pillar width n=10 and a decode threshold k=4. Such a configuration may be associated with a system designed objective of improved reliability since a decode threshold number of pillars are stored in both locations and the decode threshold is relatively low with respect to the pillar width. As such, there are 210 ways (e.g., 10 choose 4) to successfully retrieve a decode threshold number of encoded data slices from DS units <b>36</b> of the remote location <b>298</b> and the remote location <b>300</b>.</p>
<p id="p-0142" num="0141"><figref idref="DRAWINGS">FIG. 16</figref> is a flowchart illustrating an example of implementing a storage policy. The method begins with step <b>302</b> where a processing module (e.g., of a dispersed storage (DS) processing unit) determines a current storage policy. The current storage policy may include one or more of a storing policy, a retrieving policy, an aggregate storing and retrieving policy. The determination may be based on one or more of a lookup, a query, a list, a message, and a command. The method continues at step <b>304</b> where the processing module determines storage requirements, wherein the requirements includes one or more objectives related to cost, reliability, performance, and security. The determination may be based on one or more of a cost requirement, a reliability requirement, a performance requirement, a security requirement, a user input, an indicator, an error message, a request, a message, and a command.</p>
<p id="p-0143" num="0142">The method continues at step <b>306</b> where the processing module determines a new storage policy based on one or more of the current storage policy, a policy guideline, minimum requirements, and the storage requirements. For example, the processing module determines a new storage policy to lower costs when there was no current storage policy and the storage requirements indicate a low-cost is favored over other objectives. As another example, the processing module determines the new storage policy to optimize reliability when the current storage policy is optimized for cost and the storage requirements indicate that reliability is now preferred over cost.</p>
<p id="p-0144" num="0143">The method continues at step <b>308</b> where the processing module determines available storage resources (e.g., DS units, locations of DS units, network connectivity availability, etc.). The determination may be based on one or more of a table lookup, a list, a query, a message, and a command. For example, the processing module determines the available resources to include a first group of five DS units at a local location and a second group of five DS units at a remote location. The method continues at step <b>310</b> where the processing module determines an optimized configuration of storage resources based on the new storage policy and the available storage resources. The determination includes selecting one alternative configuration of a plurality of alternative configurations of the storage resources based on evaluating a fit of the alternative configuration to the new storage policy and storage requirements. The evaluation may include analyzing individual parameters of cost, reliability, and security.</p>
<p id="p-0145" num="0144">The method continues at step <b>312</b> where the processing module determines whether cost optimization is required based on the optimized configuration. The method branches to step <b>316</b> when the processing module determines that cost optimization is not required. The method continues at step <b>314</b> where the processing module optimizes the configuration for cost (e.g., one location, a small pillar width) when the processing module determines to optimize for cost. The method continues at step <b>316</b> where the processing module determines whether reliability optimization is required based on the optimized configuration. The method branches to step <b>320</b> when the processing module determines that reliability optimization is not required. The method continues at step <b>318</b> where the processing module optimizes the configuration for reliability (e.g., greater than one location, a small threshold) when the processing module determines to optimize for reliability. The method continues at step <b>320</b> where the processing module determines whether security optimization is required based on the optimized configuration. The method branches to step <b>324</b> when the processing module determines that security optimization is not required. The method continues that step <b>322</b> where the processing module optimizes the configuration for security (e.g., greater than one location, a larger threshold) when the processing module determines to optimize for security.</p>
<p id="p-0146" num="0145">The method continues at step <b>324</b> where the processing module determines whether to move slices based on the optimized configuration. For example, the processing module determines to move slices from a DS unit of the local location to a DS unit of the remote location to address improved reliability and/or or security. The method branches to step <b>328</b> when the processing module determines to not move slices. The method continues at step <b>326</b> where processing module moves error coded data slices when the processing module determines to move data slices. The method continues at step <b>328</b> where the processing module determines whether to re-encode error coded data slices based on the optimized configuration. For example, the processing module determines to re-encode when changing error coding dispersal storage function parameters (e.g., a new pillar width, a new threshold). The method branches to step <b>332</b> when the processing module determines to not re-encode error encoded data slices. The method continues at step <b>330</b> where the processing module re-encodes error coded data slices (e.g., retrieve the old slices, decode the old slices to produce a data segment, encode the data segment to produce re-encoded data slices, store the re-encoded data slices, delete the old slices) when the processing module determines to re-encode error coded data slices. The method continues at step <b>332</b> where the method ends.</p>
<p id="p-0147" num="0146"><figref idref="DRAWINGS">FIGS. 17A-17C</figref> depict an example of a dispersed storage network (DSN) memory that includes a variable number of dispersed storage (DS) units <b>36</b> depicting a migration scenario from a starting step of <figref idref="DRAWINGS">FIG. 17A</figref>, to a mid-step of <figref idref="DRAWINGS">FIG. 17B</figref>, to an ending step of <figref idref="DRAWINGS">FIG. 17C</figref>. At each step, the DS units <b>36</b> are assigned pillars of a corresponding set of encoded data slices in accordance with error coding dispersal storage function parameters (e.g., pillar width, decode threshold, etc.). The migration scenario steps support migration objectives including expanding and contracting storage resources. For example, the storage resources may be expanded to support a migration objective to add more DS units <b>36</b> and/or retire older DS units <b>36</b>. As another example, the storage resources may be contracted support a migration objective to shrink a number of DS units <b>36</b>. As illustrated, the DS units <b>36</b> of <figref idref="DRAWINGS">FIGS. 17A-17C</figref> are configured to support a migration objective to retire three of five DS units by adding three DS units, temporarily resulting in eight DS units <b>36</b>, followed by retirement of three original DS units <b>36</b> to end the scenario with five DS units <b>36</b>. The migration objectives and configurations are discussed in greater detail with reference to <figref idref="DRAWINGS">FIGS. 17A-17C</figref>. A method to expand and contract storage resources is discussed in greater detail with reference to <figref idref="DRAWINGS">FIG. 18</figref>.</p>
<p id="p-0148" num="0147"><figref idref="DRAWINGS">FIG. 17A</figref> is a schematic block diagram of another embodiment of a pillar assignment of a dispersed storage network (DSN) memory. Five dispersed storage (DS) units <b>36</b> correspond to a step <b>1</b> of a migration scenario when a pillar width is 5 and a decode threshold is 3. A migration objective may include retiring three of the five DS units <b>36</b>. For example, the three DS units <b>36</b> may have aged past a DS unit age threshold where it is desired to retire DS units that have aged past the threshold. As another example, error messages and/or performance history may indicate that the three DS units <b>36</b> should be retired.</p>
<p id="p-0149" num="0148"><figref idref="DRAWINGS">FIG. 17B</figref> is a schematic block diagram of another embodiment of a pillar assignment of a dispersed storage network (DSN) memory. Three dispersed storage (DS) units <b>36</b> are newly provisioned resulting in eight DS units <b>36</b> correspond to a step <b>2</b> of a migration scenario when a pillar width is expanded to 8 and a decode threshold remains 3. As such, the three newly provisioned DS units <b>36</b> are assigned to expansion pillars <b>6</b>-<b>8</b>. A migration objective may include retiring a first three of an initial five DS units <b>36</b> without moving encoded data slices from the first three DS units <b>36</b>.</p>
<p id="p-0150" num="0149">At step <b>2</b> of the migration scenario, encoded data slices corresponding to the expansion pillars are generated and stored in the three expansion DS units <b>36</b>. For example, a decode threshold number of encoded data slices are retrieved from the initial five DS units <b>36</b>, the encoded slices are decoded in accordance with an error coding dispersal storage function (e.g., n=5) to produce a data segment, the data segment is encoded in accordance with new error coding dispersal storage function parameters (e.g., n=8) to produce encoded data slices corresponding to the expansion pillars.</p>
<p id="p-0151" num="0150"><figref idref="DRAWINGS">FIG. 17C</figref> is a schematic block diagram of another embodiment of a pillar assignment of a dispersed storage network (DSN) memory. Three dispersed storage (DS) units <b>36</b> of an initial five DS units <b>36</b> are retired resulting in five DS units <b>36</b> correspond to a step <b>3</b> of a migration scenario when a pillar width was expanded to 8 and a decode threshold remains 3. As such, there is no need to modify encoded data slices of the remaining three DS units <b>36</b> corresponding to pillars <b>4</b>-<b>6</b> since data segments can be successfully decoded based on retrieving a decode threshold number (e.g., 3 pillars) of data slices from any of the remaining DS units. In such a migration scenario, a total number of DS units <b>36</b> and the decode threshold is the same in steps <b>1</b> and <b>3</b> and there are still 5 choose 3 ways to retrieve the decode threshold number of encoded data slices.</p>
<p id="p-0152" num="0151"><figref idref="DRAWINGS">FIG. 18</figref> is a flowchart illustrating an example of expanding and contracting storage resources. The method begins with step <b>334</b> where a processing module (e.g., dispersed storage (DS) processing unit) determines storage performance based on one or more of a query, and error message, a lookup, a message, and a command. Storage performance may include one or more of memory device uptime, mean time to failure, mean time to repair, access latency, access bandwidth, and network performance. The method continues at step <b>336</b> where the processing module determines a storage provisioning schedule based on one more of the storage performance, storage requirements, a previous schedule, a command, a lookup, a query, a request, and a message. The storage provisioning schedule may include one or more of an expansion requirement, a contraction requirement, a provisioning schedule, and a de-provisioning schedule.</p>
<p id="p-0153" num="0152">The method continues at step <b>338</b> where the processing module determines whether to expand storage. Expansion of storage may include one more of adding memory devices, adding DS units, adding a dispersed storage network (DSN) memory, activating dormant storage, and allocating more memory of already provisioned memory devices. The determination may be based on one or more of the provisioning schedule, the storage performance, an expansion indicator, a storage requirement, and a comparison of the storage performance to the requirement. For example, the processing module determines to expand storage when the storage provisioning schedule indicates that more storage is to be added when the storage performance indicates a 10% fall of the mean time to failure in any ten day period. The method branches to step <b>344</b> when the processing module determines to not expand storage. The method continues to step <b>340</b> when the processing module determines to expand storage.</p>
<p id="p-0154" num="0153">The method continues at step <b>340</b> where the processing module facilitates provisioning and allocation of storage. For example, the processing module sends a message to a DS managing unit communicating a need to add more DS units to a system. As another example, the processing module activates dormant DS units. As yet another example, the processing module allocates more memory of an existing DS unit to a vault. As a still further example, the processing module determines a new pillar width. The method continues at step <b>342</b> where the processing module encodes and stores slices. For example, the processing module re-encodes data slices in accordance with a new pillar width and stores re-encoded data slices in newly allocated storage. As another example, the processing module retrieves encoded data slices of a corresponding vault and sends the encoded data slices to the newly allocated storage.</p>
<p id="p-0155" num="0154">The method continues at step <b>344</b> where the processing module determines whether to contract storage. Contraction of storage may include one more of deactivating memory devices, removing DS units, deactivating DS units, removing a DSN memory, turning off active storage, and de-allocating memory of provisioned memory devices. The determination may be based on one or more of a de-provisioning schedule, storage performance, a contraction indicator, a storage requirement, and a comparison of the storage performance to a requirement. For example, the processing module determines to contract storage when the storage de-provisioning schedule indicates that storage is to be removed when the storage performance indicates a 20% rise of the mean time to failure in any ten day period. The method repeats back to step <b>334</b> when the processing module determines to not contract storage. The method continues to step <b>346</b> when the processing module determines to contract storage.</p>
<p id="p-0156" num="0155">The method continues at step <b>346</b> where the processing module facilitates de-provisioning and de-allocation of storage. The de-provisioning and de-allocation may include one or more of deactivating a memory device, deactivating a DS unit, deactivating a DSN memory, de-allocating memory from one or more faults, turning off the memory device, turning off a DS unit, and retrieving slices from a primary memory device and storing them in a different memory device or DS unit followed by turning off the primary memory device. The method repeats back to step <b>334</b>.</p>
<p id="p-0157" num="0156"><figref idref="DRAWINGS">FIG. 19</figref> is a schematic block diagram of an embodiment of a communication system. The system includes a site <b>1</b>, a site <b>2</b>, a user device <b>1</b>, and a user device <b>2</b>. The site <b>1</b> includes a DS processing module <b>1</b> and a plurality of n transmitter receiver (TR) modules <b>11</b>-<b>1</b><i>n</i>. The site <b>2</b> includes a DS processing module <b>1</b> and a plurality of n TR modules <b>21</b>-<b>2</b><i>n</i>. The user device <b>1</b> and the user device <b>2</b> includes a DS processing module <b>34</b> and a plurality of n TR modules <b>1</b>-<i>n</i>. The TR modules may be implemented as at least one of n wireless hardware transceivers or fewer than n frequency multiplexed, time multiplexed, or the like, as n software modules operating on one hardware transceiver (e.g., a software defined radio (SDR)), and as n software modules operating on two or more hardware transceivers (e.g., software defined radios).</p>
<p id="p-0158" num="0157">The DS processing modules <b>1</b>-<b>2</b> receive broadcast content <b>348</b> (e.g., video, multimedia, audio, music, voice, data streaming, etc.), determine error coding dispersal storage function parameters, encode the broadcast content to produce error encoded data slices of n pillars in accordance with the error coding dispersal storage function parameters, determine a wireless configuration, configure TR modules <b>11</b>-<b>1</b><i>n </i>and <b>21</b>-<b>2</b><i>n </i>in accordance with the wireless configuration, and send the error encoded data slices via the TR modules to produce pillar <b>1</b>-<i>n </i>communication as wireless signals. For example, DS processing module <b>1</b> sends error encoded data slices of all 16 pillars from TR modules <b>11</b>-<b>1</b><i>n </i>as wireless signals when a pillar width is 16 (e.g., pillar <b>1</b> communication from TR module <b>11</b>, pillar <b>2</b> communication from TR module <b>12</b>, pillar <b>3</b> communication from TR module <b>13</b>, etc.). As another example, DS processing module <b>2</b> sends pillar <b>3</b> communication from TR module <b>23</b>, through sending pillar <b>16</b> communications from TR module <b>2</b><i>n </i>when the pillar width is 16. The method of operation of the DS processing modules <b>1</b>-<b>2</b> is discussed in greater detail with reference to <figref idref="DRAWINGS">FIG. 21</figref>.</p>
<p id="p-0159" num="0158">The TR modules communicate wireless signals with other TR modules of the system and may operate in accordance with one or more wireless industry protocol standards including but not limited to universal mobile telecommunications system (UMTS), global system for mobile communications (GSM), long term evolution (LTE), wideband code division multiplexing (WCDMA), IEEE 802.11, IEEE 802.16, WiMax, Bluetooth, or any other local area network (LAN), wide area network (WAN), personal area network (PAN) or like wireless protocol. As such, any two, four, or any number of TR modules may utilize one or more of the same or different wireless protocols. For example, TR module <b>11</b> may utilize GSM and TR module <b>12</b> may simultaneously utilize IEEE 802.16.</p>
<p id="p-0160" num="0159">The TR modules <b>1</b>-<i>n </i>may utilize similar or different performance levels (e.g., speed in bits per second) of the wireless signals. For example, TR module <b>14</b> may communicate at 100 kilo bits per second (Kbps) via pillar <b>4</b> communication wireless signals in accordance with the WCDMA standard and TR module <b>17</b> may simultaneously communicate at 3.3 mega bits per second (Mbps) via pillar <b>7</b> communication wireless signals in accordance with IEEE 802.11 standard. As another example, TR module <b>14</b> and TR module <b>17</b> may both function in accordance with the IEEE802.16 standard but operate at different performance levels. For instance, TR module <b>14</b> may communicate at 350 kilo bits per second via pillar <b>4</b> communication wireless signals in accordance with the IEEE 802.16 standard and TR module <b>17</b> may simultaneously communicate at 675 kilo bits per second via pillar <b>7</b> communication wireless signals in accordance with IEEE 802.16 standard. Since software defined radios are possible in some embodiments, such protocols may be changed over time according to a predetermined security algorithm whereby the protocol is changing over time.</p>
<p id="p-0161" num="0160">Site <b>1</b> and site <b>2</b> communicate with each other to facilitate coordination of the transmission of pillar communications. For example, such coordination communication is facilitated via a wireless inter-site communication <b>350</b>. As another example, the coordination communication is facilitated via a wireline inter-site communication. In an example of coordination, site <b>1</b> sends a message to site <b>2</b> that site <b>1</b> will transmit pillars <b>1</b>-<b>5</b> and site <b>2</b> will transmit pillars <b>6</b>-<b>8</b> of the same data segment when the pillar width is 8.</p>
<p id="p-0162" num="0161">The DS processing module <b>34</b> of user device <b>1</b> or <b>2</b> receives the broadcast content by determining a wireless configuration for TR modules <b>1</b>-<i>n</i>, configuring the TR modules in accordance with the wireless configuration, determining error coding dispersal storage function parameters, receiving pillar communication via of the TR modules, decoding received data slices from the pillar communication in accordance with the error coding dispersal storage function parameters to produce the broadcast content <b>348</b>. For example, user device <b>1</b> receives pillar <b>1</b>-<i>n </i>communications from site <b>1</b> to receive a decode threshold number of error encoded data slices to decode reproducing the broadcast content <b>348</b>. As another example, user device <b>2</b> receives pillar <b>1</b>-<b>2</b> communications from site <b>1</b> and pillar <b>3</b>-<i>n </i>communications from site <b>2</b> to receive a decode threshold number of error encoded data slices to decode producing the broadcast content <b>348</b>. As yet another example, user device <b>2</b> receives pillar <b>1</b>-<b>2</b> communications from user device <b>1</b> via an inter-device wireless communication <b>352</b> and pillar <b>3</b>-<i>n </i>communications from site <b>2</b> to receive a decode threshold number of error encoded data slices to decode reproducing the broadcast content <b>348</b>. The inter-device wireless communications <b>352</b> is utilized to communicate pillar communications and coordination information between two or more user devices. The coordination information includes requests and responses to forward particular pillar communications. For example, user device <b>2</b> sends a pillar <b>1</b>-<b>2</b> communication request via the inter-device wireless communication <b>352</b> to user device <b>1</b>. User device <b>1</b> forwards pillar <b>1</b>-<b>2</b> communications to user device <b>2</b> via inter-device wireless communications <b>352</b> in response. The method of operation of the DS processing module of the user devices <b>1</b>-<b>2</b> is discussed in greater detail with reference to <figref idref="DRAWINGS">FIGS. 20</figref>, <b>23</b>, and <b>24</b>.</p>
<p id="p-0163" num="0162"><figref idref="DRAWINGS">FIG. 20</figref> is a flowchart illustrating an example of acquiring a content broadcast. The method begins with step <b>354</b> where a processing module (e.g., of a user device) determining a mapping of encoded data slices to wireless channels for wireless communication of data, wherein a data segment of the data is encoded in accordance with a dispersed storage error encoding protocol to produce a set of encoded data slices and wherein a first encoded data slice of the set of encoded data slices is associated with a first wireless channel of a set of wireless channels. The mapping includes one or more of a pillar to wireless channel mapping, wherein the dispersed storage error encoding protocol prescribes a set of pillars, a data segment to wireless channel mapping, and an encoded data slice pattern to wireless channel mapping (e.g., a combination of pillars and segments).</p>
<p id="p-0164" num="0163">As a mapping example, the processing module determines to receive pillars <b>1</b>-<b>2</b> from site <b>1</b> and pillars <b>3</b>-<b>16</b> from site <b>2</b> when the processing module determines that pillars <b>1</b>-<b>2</b> can only be received from site <b>1</b> and pillars <b>3</b>-<b>16</b> can only be received from site <b>2</b>. As another example, the processing module determines to receive pillars <b>1</b>-<b>8</b> from site <b>1</b> and pillars <b>9</b>-<b>16</b> from site <b>2</b> when all 16 pillars are transmitted from both sites and the wireless signal quality indicator indicates that pillar <b>1</b>-<b>8</b> communications from site <b>1</b> is preferred to pillar <b>1</b>-<b>8</b> communications from site <b>2</b> and that pillar <b>9</b>-<b>16</b> communications from site <b>2</b> is preferred to pillar <b>9</b>-<b>16</b> communications from site <b>1</b>. As yet another example, the processing module determines wireless parameters to optimize a resulting wireless signal quality indicator. For instance, the processing module determines to utilize a slower wireless signal to improve reliability of the wireless communications.</p>
<p id="p-0165" num="0164">The determining of the mapping may be based on at least one of receiving a broadcast indicator, a broadcast status indicator, a user device data requirement (e.g., another user device desires the same data segment), a previously utilized access method, a data access response, a message, a pillar broadcast indicator, and a wireless signal indicator. For example, the processing module determines the mapping to include a first mapping of a first collective of encoded data slices of the set of encoded data slices to at least one wireless channel of a first transmission site and a second mapping of a second collective of encoded data slices of the set of encoded data slices to at least one wireless channel of a second transmission site.</p>
<p id="p-0166" num="0165">The method continues at step <b>356</b> where the processing module configures, in accordance with the mapping, receivers of a wireless communication device to receive, via a set of wireless channels, at least some of the set of encoded data slices to produce configured receivers. The configuring the receivers includes configuring a first receiver of the receivers to receive the first encoded data slice via a first wireless channel of the set of wireless channels, configuring a second receiver of the receivers to receive a second encoded data slice of the set of encoded data slices via a second wireless channel of the set of wireless channels, and configuring a third receiver of the receivers to receive a third encoded data slice of the set of encoded data slices via a third wireless channel of the set of wireless channels. At step <b>356</b>, the processing module configures, in accordance with the mapping, a first receiver of the receivers to receive at least some of the set of encoded data slices via a first wireless channel of the set of wireless channels and a second receiver of the receivers to receive at least some of the second set of encoded data slices via a second wireless channel of the set of wireless channels when a second data segment of the data is encoded in accordance with the dispersed storage error encoding protocol to produce a second set of encoded data slices.</p>
<p id="p-0167" num="0166">At step <b>356</b>, the processing module may generate a configuration signal regarding optimal operational characteristics of at least one of the configured receivers and facilitate transmission of the configuration signal. For example, the processing module facilitates transmission of the configuration signal to a transmitter corresponding to at least one receiver such that transmitter configuration includes information of the configuration signal.</p>
<p id="p-0168" num="0167">The method continues at step <b>358</b> where the processing module facilitates the configured receivers to receive encoded data slices of the set of encoded data slices to produce received encoded data slices. At step <b>358</b>, the processing module facilitates the first receiver to receive the encoded data slices of the set of encoded data slices to produce the received encoded data slices and facilitates the second receiver to receive encoded data slices of the second set of encoded data slices to produce second received encoded data slices when the second data segment of the data is encoded in accordance with the dispersed storage error encoding protocol to produce the second set of encoded data slices.</p>
<p id="p-0169" num="0168">The method continues at step <b>360</b> where the processing module determines whether at least a decode threshold number of received encoded data slices have been received within a predetermined period of time. At step <b>360</b>, the processing module determines whether at least a decode threshold number of the second received encoded data slices have been received when the second data segment of the data is encoded in accordance with the dispersed storage error encoding protocol to produce the second set of encoded data slices. The method branches to step <b>364</b> when the processing module determines that the decode threshold number of received encoded data slices have not been received within the predetermined period of time. The method continues to step <b>362</b> when the processing module determines that the decode threshold number of received encoded data slices have been received.</p>
<p id="p-0170" num="0169">The method continues at step <b>362</b> where the processing module decodes the received encoded data slices to recapture the data segment when at least the decode threshold number of received encoded data slices have been received. At step <b>362</b>, the processing module decodes the second received encoded data slices to recapture the second data segment when at least the decode threshold number of the second received encoded data slices have been received. Alternatively, the method may loop back to step <b>360</b> when more data segments are to be recaptured.</p>
<p id="p-0171" num="0170">The method continues at step <b>364</b> where the processing module determines whether the mapping is sub-optimal based on wireless communication conditions when the decode threshold number of encoded data slices have not been received within the predetermined period of time. The determining whether the mapping is sub-optimal includes at least one of determining that a performance indicator associated with at least one of the configured receivers compares unfavorably to a performance threshold and determining that a signaling indicator associated with the at least one of the configured receivers compares unfavorably to the performance threshold. The performance indicator includes one or more of a received bit rate, a number of encoded slices received per second, a number of pillars received per second, which pillars are being received, and which pillars are not been received. The signaling indicator includes one or more of a received bit rate, a received bit error rate, an interference level, a loss of wireless signal indicator, and a wireless signal level indicator.</p>
<p id="p-0172" num="0171">The method repeats back to step <b>362</b> continue to receive encoded data slices when the processing module determines that the mapping is not sub-optimal. The method continues to step <b>366</b> when the processing module determines that the mapping is sub-optimal. The method continues at step <b>366</b> where the processing module determines a second mapping of encoded data slices to wireless channels based on the wireless communication conditions when the mapping is sub-optimal. The method loops back to step <b>356</b> to configure receivers in accordance with the second mapping.</p>
<p id="p-0173" num="0172"><figref idref="DRAWINGS">FIG. 21</figref> is a flowchart illustrating an example of generating a content broadcast. The method begins with step <b>390</b> where a processing module (e.g., of a dispersed storage (DS) processing unit) determines data to broadcast based on one or more of a data segment indicator, a next data segment of a data object indicator, an application request, a user input, a message, a request from a user device, a request from a site, and a command. The method continues at step <b>392</b> where the processing module determines a wireless configuration based on one or more of a quality level indicator of a wireless communications path from a site to one or more user devices, user devices within wireless range, required pillars, and which pillars are being transmitted by which transceiver (TR) module. The wireless configuration may include one or more of wireless parameters for the TR modules, configuring TR modules to broadcast particular pillars, and indicating that one or more other sites and/or user devices broadcast particular pillars.</p>
<p id="p-0174" num="0173">The method continues at step <b>394</b> where the processing module configures the wireless. The configuring includes sending wireless configuration information to TR modules associated with one or more sites and/or one or more user devices. The method continues at step <b>396</b> where the processing module encodes a data segment in accordance with an error coding dispersal storage function to produce error coded data slices. The method continues at step <b>398</b> where the processing module sends the error coded data slices utilizing the TR modules as pillar communications via wireless signals. The method continues at step <b>400</b> where the processing module determines whether enough data has been sent based on one or more of a number of data segments in the data object, a number of data slices sent, a number of data segments sent, a number of outstanding data segments to be sent, and a number of outstanding data slices to be sent. The method branches back to step <b>390</b> when the processing module determines that enough data has been sent. The method continues to step <b>402</b> when the processing module determines that not enough data has been sent.</p>
<p id="p-0175" num="0174">The method continues at step <b>402</b> where the processing module determines whether to reconfigure the wireless based on one or more of monitoring a wireless signal quality level indicator indicating performance of the wireless communications paths (e.g., receiving feedback from one or more user devices), a performance threshold, and comparing the wireless signal quality level to the performance threshold. For example, the processing module determines to reconfigure the wireless when receiving a request from a user device to start sending more pillars via a particular wireless communications path that is more favorable for the user device. As another example, the processing module determines to reconfigure the wireless to increase the speed of a TR module when receiving a message from a user device that indicates that a transmission speed is too slow on an associated wireless communications path. As yet another example, the processing module determines to reconfigure the wireless to align with a configuration objective (e.g., cost, performance, reliability, a balance between these factors, etc.) where the configuration objective may be determined based on a predetermination, a lookup, a user device requests, a performance driven dynamic, and from another site. Configuration objectives, wireless configuration, and pillars assignments are discussed in greater detail with reference to <figref idref="DRAWINGS">FIG. 22</figref>. The method branches back to step <b>396</b> when the processing module determines not to reconfigure the wireless. The method branches back to step <b>392</b> when the processing module determines to reconfigure the wireless.</p>
<p id="p-0176" num="0175"><figref idref="DRAWINGS">FIG. 22</figref> is a table illustrating an example of wireless configuration and pillar assignments <b>420</b>. The wireless configuration and pillar assignments <b>420</b> represents pillar number and communication speed assignments for each transceiver (TR) of a plurality of TR modules <b>1</b>-<b>5</b> in accordance with an optimization objective when a pillar width is five. The optimization objectives includes cost, performance, reliability, balance A (e.g., mixed objectives), and balance B. A cost field <b>422</b> includes a pillars field <b>432</b> and a speed field <b>434</b>, a performance field <b>424</b> includes a pillars field <b>436</b> and a speed field <b>438</b>, a reliability field <b>426</b> includes a pillars field <b>440</b> and a speed field <b>442</b>, a balance A field <b>428</b> includes a pillars field <b>444</b> and a speed field <b>446</b>, and a balance B field <b>430</b> includes a pillars field <b>448</b> and a speed field <b>450</b>. Each pillars field <b>432</b>, <b>436</b>, <b>440</b>, <b>444</b>, <b>448</b> includes one or more pillar numbers of encoded data slices that are to be transmitted from a corresponding transceiver of TR <b>1</b>-<b>5</b>. Each speed field <b>434</b>, <b>438</b>, <b>442</b>, <b>446</b>, <b>450</b> includes a relative speed indicator for transmission of the one or more pillar numbers of encoded data slices that are to be transmitted from the corresponding transceiver of TR <b>1</b>-<b>5</b>.</p>
<p id="p-0177" num="0176">In a cost optimized example, TR module <b>1</b> transmits pillars <b>1</b>-<b>5</b> at a normal 1&#xd7; relative wireless speed. Using one TR module may lower cost as desired. In a performance optimized example, TR module <b>1</b> transmits pillar <b>1</b> at a 2&#xd7; relative wireless speed, TR module <b>2</b> transmits pillar <b>2</b> at 2&#xd7;, TR module <b>3</b> transmits pillar <b>3</b> at 2&#xd7;, TR module <b>4</b> transmits pillar <b>4</b> at 2&#xd7;, and TR module <b>5</b> transmits pillar <b>5</b> at 2&#xd7;. A performance improvement is provided by sending pillars <b>1</b>-<b>5</b> simultaneously via parallel communications paths. In a reliability optimized example, TR modules <b>1</b>-<b>5</b> transmit pillars <b>1</b>-<b>5</b> as in the performance optimized example but at a 1&#xd7; speed.</p>
<p id="p-0178" num="0177">In a balance A optimized example, TR modules <b>1</b>-<b>3</b> transmit pillars <b>1</b>-<b>3</b> at the 1&#xd7; relative wireless speed and TR module <b>4</b> transmits pillars <b>4</b>-<b>5</b> at the 2&#xd7; relative wireless speed. A balance is provided between cost and reliability by utilizing one less TR module but yet at a similar throughput as the reliability optimized example. In a balance B optimized example, TR module <b>1</b> transmits pillars <b>1</b>-<b>2</b> at a 4&#xd7; speed, TR module <b>2</b> transmits pillars <b>3</b>-<b>4</b> at a 4&#xd7; speed, and TR module <b>3</b> transmits pillar <b>5</b> at a 2&#xd7; speed. Note that a balance is provided between cost and performance by utilizing two fewer TR modules but yet at a similar throughput as the performance example. Note that a decode threshold number of encoded data slices are received at a 2&#xd7; rate even when any one of the TR modules is not operable.</p>
<p id="p-0179" num="0178"><figref idref="DRAWINGS">FIG. 23</figref> is a flowchart illustrating another example of acquiring a content broadcast. The method begins with step <b>452</b> where a processing module (e.g., of a user device) acquires wireless signals from two or more sites. The wireless signal acquisition may include one or more of scanning, searching channels from a predetermined list, searching channels from a previous wireless cyclist, searching channels based on location, and searching all channels. The method continues at step <b>454</b> where the processing module determines transmit wireless configuration of two or more sites based on one or more of receiving the transmit wireless configuration information from the two or more sites and analyzing received information to extract transmit wireless configuration information (e.g., pillar number assignment to wireless paths).</p>
<p id="p-0180" num="0179">The method continues at step <b>456</b> where the processing module determines receive wireless configuration to enable receiving data slices of desired pillars based on one or more of a wireless quality level indicator, an indicator of sites within range, an indicator of user devices within range, and a pillar to wireless communications path assignment indicator. The method continues at step <b>458</b> where the processing module configures wireless transceiver (TR) modules in accordance with the receive wireless configuration by sending the receive wireless configuration information to the TR modules associated with the processing module. The method continues at step <b>460</b> where the processing module receives encoded data slices via reception of wireless signals from transmitting TR modules of the two or more sites. The method continues at step <b>462</b> where the processing module decodes the encoded data slices from the two or more sites in accordance with an error coding dispersal storage function to produce reconstructed data segments.</p>
<p id="p-0181" num="0180">The method continues at step <b>464</b> where the processing module determines whether to reconfigure the receive wireless configuration. The determination may be based on one or more of the wireless quality level indicator, the indicator of sites within range, the indicator of user devices within range, and the pillar to wireless communications path assignment indicator. The method branches back to step <b>460</b> when the processing module determines not to reconfigure the receive wireless configuration. The method loops back to step <b>452</b> when the processing module determines to reconfigure the receive wireless.</p>
<p id="p-0182" num="0181"><figref idref="DRAWINGS">FIG. 24</figref> is a flowchart illustrating another example of acquiring a content broadcast, which includes similar steps to <figref idref="DRAWINGS">FIG. 23</figref>. The method begins with steps <b>452</b>-<b>462</b> of <figref idref="DRAWINGS">FIG. 23</figref> where a processing module (e.g., of a user device) acquires wireless signals from two or more sites, determines transmit wireless configuration of the two or more sites, determines a receive wireless configuration, configures transceiver (TR) wireless modules in accordance with the receive wireless configuration, receives encoded data slices via wireless communications from the two or more sites, and reconstructs data segments utilizing data slices from the two or more sites. The method continues at step <b>478</b> where the processing module determines whether data reception performance is below a performance threshold. The determination may be based on one or more of a received data rate indicator, a received data error indicator, a threshold, a comparison of data reception performance to the threshold, a wireless quality level indicator, an indicator of sites within range, an indicator of user devices within range, and a pillar to wireless communications path assignment indicator. The method repeats back to step <b>460</b> of <figref idref="DRAWINGS">FIG. 23</figref> when the processing module determines that the data reception performance is not below a threshold. The method continues to step <b>480</b> when the processing module determines that the data reception performance is below a threshold.</p>
<p id="p-0183" num="0182">The method continues at step <b>40</b> where the processing module acquires wireless signals from a sending user device transmitting copies of the encoded data slices. The wireless signal acquisition may be based on scanning wireless signals of the user device and/or sending a request message to another user device to request that it relay the copies of the encode slices. The method continues at step <b>482</b> where the processing module determines transmit wireless configuration of one or more of the sending user device based on receiving information from the user device and/or by extracting information from one or more pillar communications and of the two or more sites.</p>
<p id="p-0184" num="0183">The method continues at step <b>484</b> where the processing module re-determines the receive wireless configuration based on the transmit wireless configuration of the sending user device and/or the transmit wireless configuration of the two or more sites. The processing module may determine to receive pillar communications from two or more sites and another user device. The method continues at step <b>486</b> where the processing module configures a wireless TR modules associated with the processing module in accordance with the receive wireless configuration. The method continues at step <b>488</b> where the processing module receives encoded data slices (e.g., including copies) via wireless from the two or more sites and/or the sending user device.</p>
<p id="p-0185" num="0184">The method continues at step <b>490</b> where the processing module decodes the received encoded data slices in accordance with an error coding dispersal storage function to produce reconstructed data segments. The method continues at step <b>492</b> where the processing module determines whether to reconfigure the wireless based on the wireless performance and/or the received data. The method repeats back to step <b>488</b> when the processing module determines not to reconfigure the wireless. The method loops back to the step <b>480</b> when the processing module determines to reconfigure the wireless.</p>
<p id="p-0186" num="0185">As may be used herein, the terms &#x201c;substantially&#x201d; and &#x201c;approximately&#x201d; provides an industry-accepted tolerance for its corresponding term and/or relativity between items. Such an industry-accepted tolerance ranges from less than one percent to fifty percent and corresponds to, but is not limited to, component values, integrated circuit process variations, temperature variations, rise and fall times, and/or thermal noise. Such relativity between items ranges from a difference of a few percent to magnitude differences. As may also be used herein, the term(s) &#x201c;operably coupled to&#x201d;, &#x201c;coupled to&#x201d;, and/or &#x201c;coupling&#x201d; includes direct coupling between items and/or indirect coupling between items via an intervening item (e.g., an item includes, but is not limited to, a component, an element, a circuit, and/or a module) where, for indirect coupling, the intervening item does not modify the information of a signal but may adjust its current level, voltage level, and/or power level. As may further be used herein, inferred coupling (i.e., where one element is coupled to another element by inference) includes direct and indirect coupling between two items in the same manner as &#x201c;coupled to&#x201d;. As may even further be used herein, the term &#x201c;operable to&#x201d; or &#x201c;operably coupled to&#x201d; indicates that an item includes one or more of power connections, input(s), output(s), etc., to perform, when activated, one or more its corresponding functions and may further include inferred coupling to one or more other items. As may still further be used herein, the term &#x201c;associated with&#x201d;, includes direct and/or indirect coupling of separate items and/or one item being embedded within another item. As may be used herein, the term &#x201c;compares favorably&#x201d;, indicates that a comparison between two or more items, signals, etc., provides a desired relationship. For example, when the desired relationship is that signal <b>1</b> has a greater magnitude than signal <b>2</b>, a favorable comparison may be achieved when the magnitude of signal <b>1</b> is greater than that of signal <b>2</b> or when the magnitude of signal <b>2</b> is less than that of signal <b>1</b>.</p>
<p id="p-0187" num="0186">While the transistors in the above described figure(s) is/are shown as field effect transistors (FETs), as one of ordinary skill in the art will appreciate, the transistors may be implemented using any type of transistor structure including, but not limited to, bipolar, metal oxide semiconductor field effect transistors (MOSFET), N-well transistors, P-well transistors, enhancement mode, depletion mode, and zero voltage threshold (VT) transistors.</p>
<p id="p-0188" num="0187">The present invention has also been described above with the aid of method steps illustrating the performance of specified functions and relationships thereof. The boundaries and sequence of these functional building blocks and method steps have been arbitrarily defined herein for convenience of description. Alternate boundaries and sequences can be defined so long as the specified functions and relationships are appropriately performed. Any such alternate boundaries or sequences are thus within the scope and spirit of the claimed invention.</p>
<p id="p-0189" num="0188">The present invention has been described, at least in part, in terms of one or more embodiments. An embodiment of the present invention is used herein to illustrate the present invention, an aspect thereof, a feature thereof, a concept thereof, and/or an example thereof. A physical embodiment of an apparatus, an article of manufacture, a machine, and/or of a process that embodies the present invention may include one or more of the aspects, features, concepts, examples, etc. described with reference to one or more of the embodiments discussed herein.</p>
<p id="p-0190" num="0189">The present invention has been described above with the aid of functional building blocks illustrating the performance of certain significant functions. The boundaries of these functional building blocks have been arbitrarily defined for convenience of description. Alternate boundaries could be defined as long as the certain significant functions are appropriately performed. Similarly, flow diagram blocks may also have been arbitrarily defined herein to illustrate certain significant functionality. To the extent used, the flow diagram block boundaries and sequence could have been defined otherwise and still perform the certain significant functionality. Such alternate definitions of both functional building blocks and flow diagram blocks and sequences are thus within the scope and spirit of the claimed invention. One of average skill in the art will also recognize that the functional building blocks, and other illustrative blocks, modules and components herein, can be implemented as illustrated or by discrete components, application specific integrated circuits, processors executing appropriate software and the like or any combination thereof.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A computer implemented method comprises:
<claim-text>sending, by a data accessing module of a dispersed storage network (DSN), a data access request to a data storage module of the DSN;</claim-text>
<claim-text>sending, by the data storage module, an authentication request to an authenticating module of the DSN, wherein the authentication request includes at least a portion of the data access request;</claim-text>
<claim-text>outputting, by the authenticating module, a verification request destined for the data accessing module, wherein the verification request includes a verification code that is generated based on the authentication request;</claim-text>
<claim-text>outputting, by the data accessing module, a verification response destined for the authenticating module, wherein the verification response includes a modified verification code that is generated based on the verification code and a credential;</claim-text>
<claim-text>outputting, by the authenticating module, an authentication response to the data storage module, wherein the authentication response is generated based on the verification response; and</claim-text>
<claim-text>facilitating, by the data storage module, the data access request when the authentication response is favorable.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The computer implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the sending the authentication request further comprises:
<claim-text>identifying, by the data storage module, the authenticating module for the data accessing module based on the data access request.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The computer implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the data access request comprises one or more of:
<claim-text>a read request;</claim-text>
<claim-text>a write request;</claim-text>
<claim-text>a list request;</claim-text>
<claim-text>a delete request; and</claim-text>
<claim-text>an edit request.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The computer implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the outputting of the verification request by the authentication module comprises:
<claim-text>sending the verification request to the data storage module; and</claim-text>
<claim-text>forwarding, by the data storage module, the verification request to the data accessing module.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The computer implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the outputting of the verification response by the data accessing module comprises:
<claim-text>sending the verification response to the data storage module; and</claim-text>
<claim-text>forwarding, by the data storage module, the verification response to the authenticating module.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The computer implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the generating the modified verification code comprises:
<claim-text>performing a verifying function on the verification code and the credential to produce the modified verification code.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The computer implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the generating the authentication response comprises:
<claim-text>performing a verifying function on the verification code and a reference credential to produce a reference verification code;</claim-text>
<claim-text>comparing the modified verification code with the reference verification code; and</claim-text>
<claim-text>when the comparison is favorable, generating the authentication response to indicate a favorable authentication.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. A computer implemented method comprises:
<claim-text>receiving a data access request from a data accessing module of a dispersed storage network (DSN);</claim-text>
<claim-text>sending an authentication request to an authenticating module of the DSN, wherein the authentication request includes at least a portion of the data access request;</claim-text>
<claim-text>receiving an authentication response from the authenticating module, wherein the authentication response is generated based on a verification response of the data accessing module; and</claim-text>
<claim-text>facilitating the data access request when the authentication response is favorable.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The computer implemented method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the sending the authentication request further comprises:
<claim-text>identifying the authenticating module for the data accessing module based on the data access request.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. A computer implemented method comprises:
<claim-text>receiving an authentication request from a data storage module of a dispersed storage network (DSN), wherein the authentication request includes at least a portion of a data access request of a data accessing module of the DSN;</claim-text>
<claim-text>outputting a verification request destined for the data accessing module, wherein the verification request includes a verification code that is generated based on the authentication request;</claim-text>
<claim-text>receiving a verification response, wherein the verification response includes a modified verification code that is generated by the data accessing module based on the verification code and a credential; and</claim-text>
<claim-text>outputting an authentication response that is generated based on the verification response, wherein, the data access request is authenticated when the authentication response is favorable.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The computer implemented method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the generating the authentication response comprises:
<claim-text>performing a verifying function on the verification code and a reference credential to produce a reference verification code;</claim-text>
<claim-text>comparing the modified verification code with the reference verification code; and</claim-text>
<claim-text>when the comparison is favorable, generating the authentication response to indicate a favorable authentication.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. A dispersed storage network (DSN) comprises:
<claim-text>a data accessing unit that includes:
<claim-text>an data access unit interface; and</claim-text>
<claim-text>a data access processing module;</claim-text>
</claim-text>
<claim-text>a data storage unit that includes:
<claim-text>a data storage interface; and</claim-text>
<claim-text>a data storage processing module; and</claim-text>
</claim-text>
<claim-text>an authenticating unit that includes:
<claim-text>an authenticating interface; and</claim-text>
<claim-text>an authenticating processing module, wherein:</claim-text>
<claim-text>the data accessing unit sends, via the data accessing interface, a data access request to the data storage unit;</claim-text>
<claim-text>the data storage unit sends, via the data storage interface, an authentication request to the authenticating unit, wherein the authentication request includes at least a portion of the data access request;</claim-text>
<claim-text>the authenticating unit outputs, via the authenticating interface, a verification request destined for the data accessing unit, wherein the verification request includes a verification code that is generated based on the authentication request;</claim-text>
<claim-text>the data accessing unit outputs, via the data accessing interface, a verification response destined for the authenticating unit, wherein the verification response includes a modified verification code that is generated based on the verification code and a credential;</claim-text>
<claim-text>the authenticating unit outputs, via the authenticating interface, an authentication response to the data storage unit, wherein the authentication response is generated based on the verification response; and</claim-text>
<claim-text>the data storage unit facilitates the data access request when the authentication response is favorable.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The DSN of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the data storage unit further functions to send the authentication request by:
<claim-text>identifying, by the data storage processing module, the authenticating unit for the data accessing module based on the data access request.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The DSN of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the data access request comprises one or more of:
<claim-text>a read request;</claim-text>
<claim-text>a write request;</claim-text>
<claim-text>a list request;</claim-text>
<claim-text>a delete request; and</claim-text>
<claim-text>an edit request.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The DSN of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the authenticating unit functions to output the verification request by:
<claim-text>sending, via the authenticating interface, the verification request to the data storage unit; and</claim-text>
<claim-text>forwarding, by the data storage interface, the verification request to the data accessing unit.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The DSN of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the data accessing unit functions to output the verification response by:
<claim-text>sending, via the data accessing interface, the verification response to the data storage module; and</claim-text>
<claim-text>forwarding, by the data storage interface, the verification response to the authenticating unit.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The DSN of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the authenticating unit functions to generate the modified verification code by:
<claim-text>performing, by the authenticating processing module, a verifying function on the verification code and the credential to produce the modified verification code.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The DSN of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the authenticating unit functions to generate the authentication response by:
<claim-text>performing, by the authenticating processing module, a verifying function on the verification code and a reference credential to produce a reference verification code;</claim-text>
<claim-text>comparing, by the authenticating processing module, the modified verification code with the reference verification code; and</claim-text>
<claim-text>when the comparison is favorable, generating, by the authenticating processing module, the authentication response to indicate a favorable authentication.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. A computer comprises:
<claim-text>an interface;</claim-text>
<claim-text>a memory; and</claim-text>
<claim-text>a processing module operable to:
<claim-text>receive, via the interface, a data access request from a data accessing module of a dispersed storage network (DSN);</claim-text>
<claim-text>send, via the interface, an authentication request to an authenticating module of the DSN, wherein the authentication request includes at least a portion of the data access request;</claim-text>
<claim-text>receive, via the interface, an authentication response from the authenticating module, wherein the authentication response is generated based on a verification response of the data accessing module; and</claim-text>
<claim-text>facilitate the data access request when the authentication response is favorable.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The computer of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein the processing module further functions to send the authentication request by:
<claim-text>identifying the authenticating module for the data accessing module based on the data access request.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. A computer comprises:
<claim-text>an interface;</claim-text>
<claim-text>a memory; and</claim-text>
<claim-text>a processing module operable to:
<claim-text>receive, via the interface, an authentication request from a data storage module of a dispersed storage network (DSN), wherein the authentication request includes at least a portion of a data access request of a data accessing module of the DSN;</claim-text>
<claim-text>output, via the interface, a verification request destined for the data accessing module, wherein the verification request includes a verification code that is generated based on the authentication request;</claim-text>
<claim-text>receive, via the interface, a verification response, wherein the verification response includes a modified verification code that is generated by the data accessing module based on the verification code and a credential; and</claim-text>
<claim-text>output, via the interface, an authentication response that is generated based on the verification response, wherein, the data access request is authenticated when the authentication response is favorable.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. The computer of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the processing module functions to generate the authentication response by:
<claim-text>performing a verifying function on the verification code and a reference credential to produce a reference verification code;</claim-text>
<claim-text>comparing the modified verification code with the reference verification code; and</claim-text>
<claim-text>when the comparison is favorable, generating the authentication response to indicate a favorable authentication.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
