<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08626987-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08626987</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12912997</doc-number>
<date>20101027</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<priority-claims>
<priority-claim sequence="01" kind="national">
<country>KR</country>
<doc-number>10-2010-0042077</doc-number>
<date>20100504</date>
</priority-claim>
</priority-claims>
<us-term-of-grant>
<us-term-extension>287</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>13</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>711103</main-classification>
<further-classification>711E12002</further-classification>
<further-classification>707693</further-classification>
</classification-national>
<invention-title id="d2e71">Flash memory system and defragmentation method</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6038636</doc-number>
<kind>A</kind>
<name>Brown et al.</name>
<date>20000300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711103</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6205529</doc-number>
<kind>B1</kind>
<name>Shagam</name>
<date>20010300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711170</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6397311</doc-number>
<kind>B1</kind>
<name>Capps</name>
<date>20020500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711165</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>7212440</doc-number>
<kind>B2</kind>
<name>Gorobets</name>
<date>20070500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>7401174</doc-number>
<kind>B2</kind>
<name>So et al.</name>
<date>20080700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>7725506</doc-number>
<kind>B1</kind>
<name>Stringham</name>
<date>20100500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707822</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2004/0153762</doc-number>
<kind>A1</kind>
<name>Flynn et al.</name>
<date>20040800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2006/0015683</doc-number>
<kind>A1</kind>
<name>Ashmore et al.</name>
<date>20060100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2008/0010395</doc-number>
<kind>A1</kind>
<name>Mylly et al.</name>
<date>20080100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711100</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2008/0155175</doc-number>
<kind>A1</kind>
<name>Sinclair et al.</name>
<date>20080600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2008/0201518</doc-number>
<kind>A1</kind>
<name>Kim et al.</name>
<date>20080800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2008/0279005</doc-number>
<kind>A1</kind>
<name>France</name>
<date>20081100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2008/0282024</doc-number>
<kind>A1</kind>
<name>Biswas et al.</name>
<date>20081100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2009/0094433</doc-number>
<kind>A1</kind>
<name>Thomas et al.</name>
<date>20090400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711172</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>2010/0146333</doc-number>
<kind>A1</kind>
<name>Yong et al.</name>
<date>20100600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>2010/0185806</doc-number>
<kind>A1</kind>
<name>Pruthi et al.</name>
<date>20100700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711103</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>2010/0262799</doc-number>
<kind>A1</kind>
<name>Lasser et al.</name>
<date>20101000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00018">
<document-id>
<country>JP</country>
<doc-number>08129509</doc-number>
<kind>A</kind>
<date>19960500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00019">
<document-id>
<country>JP</country>
<doc-number>2005202942</doc-number>
<kind>A</kind>
<date>20050700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00020">
<document-id>
<country>JP</country>
<doc-number>2007018499</doc-number>
<kind>A</kind>
<date>20070100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00021">
<document-id>
<country>JP</country>
<doc-number>2007066326</doc-number>
<kind>A</kind>
<date>20070300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00022">
<document-id>
<country>JP</country>
<doc-number>4059002</doc-number>
<kind>B2</kind>
<date>20080300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00023">
<document-id>
<country>JP</country>
<doc-number>2008158773</doc-number>
<kind>A</kind>
<date>20080700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00024">
<document-id>
<country>JP</country>
<doc-number>2008159013</doc-number>
<kind>A</kind>
<date>20080700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00025">
<document-id>
<country>JP</country>
<doc-number>2008527586</doc-number>
<kind>A</kind>
<date>20080700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00026">
<document-id>
<country>KR</country>
<doc-number>1020070102507</doc-number>
<kind>A</kind>
<date>20071000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00027">
<document-id>
<country>KR</country>
<doc-number>1020080056491</doc-number>
<kind>A</kind>
<date>20080600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00028">
<document-id>
<country>KR</country>
<doc-number>1020080075706</doc-number>
<kind>A</kind>
<date>20080800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00029">
<document-id>
<country>KR</country>
<doc-number>1020090101673</doc-number>
<kind>A</kind>
<date>20090900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00030">
<document-id>
<country>KR</country>
<doc-number>1020090108695</doc-number>
<kind>A</kind>
<date>20091000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00031">
<document-id>
<country>WO</country>
<doc-number>9844420</doc-number>
<kind>A1</kind>
<date>19981000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>15</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>711103</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711E12002</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707693</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>21</number-of-drawing-sheets>
<number-of-figures>22</number-of-figures>
</figures>
<us-related-documents>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61255119</doc-number>
<date>20091027</date>
</document-id>
</us-provisional-application>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20110099326</doc-number>
<kind>A1</kind>
<date>20110428</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Jung</last-name>
<first-name>Dawoon</first-name>
<address>
<city>Hwaseong-si</city>
<country>KR</country>
</address>
</addressbook>
<residence>
<country>KR</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Kwon</last-name>
<first-name>Moon Sang</first-name>
<address>
<city>Seoul</city>
<country>KR</country>
</address>
</addressbook>
<residence>
<country>KR</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Shin</last-name>
<first-name>Dong Jun</first-name>
<address>
<city>Hwaseong-si</city>
<country>KR</country>
</address>
</addressbook>
<residence>
<country>KR</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Jung</last-name>
<first-name>Dawoon</first-name>
<address>
<city>Hwaseong-si</city>
<country>KR</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Kwon</last-name>
<first-name>Moon Sang</first-name>
<address>
<city>Seoul</city>
<country>KR</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Shin</last-name>
<first-name>Dong Jun</first-name>
<address>
<city>Hwaseong-si</city>
<country>KR</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Volentine &#x26; Whitt, PLLC</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Samsung Electronics Co., Ltd.</orgname>
<role>03</role>
<address>
<city>Suwon-si, Gyeonggi-do</city>
<country>KR</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Dudek, Jr.</last-name>
<first-name>Edward</first-name>
<department>2186</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Provided is a flash memory system supporting flash defragmentation. The flash memory system includes a host and a flash storage device. In response to a flash defragmentation command by the host, the flash storage device performs flash defragmentation by grouping fragments stored in fragmented blocks of a flash memory on a flash memory management unit basis. The flash memory management unit may be a memory block or page. The flash storage device performs the flash defragmentation regardless of the arrangement order of fragmented files stored in the flash memory.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="189.65mm" wi="268.56mm" file="US08626987-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="150.28mm" wi="190.92mm" file="US08626987-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="229.02mm" wi="170.60mm" orientation="landscape" file="US08626987-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="239.44mm" wi="93.13mm" file="US08626987-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="96.69mm" wi="110.66mm" file="US08626987-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="255.02mm" wi="147.83mm" orientation="landscape" file="US08626987-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="212.94mm" wi="180.34mm" file="US08626987-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="223.77mm" wi="112.10mm" orientation="landscape" file="US08626987-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="116.67mm" wi="119.13mm" file="US08626987-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="227.67mm" wi="179.32mm" file="US08626987-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="223.10mm" wi="180.00mm" file="US08626987-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="216.83mm" wi="108.54mm" orientation="landscape" file="US08626987-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="265.51mm" wi="158.33mm" file="US08626987-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="271.78mm" wi="188.47mm" orientation="landscape" file="US08626987-20140107-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="124.38mm" wi="169.16mm" file="US08626987-20140107-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="210.82mm" wi="85.43mm" orientation="landscape" file="US08626987-20140107-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00016" num="00016">
<img id="EMI-D00016" he="246.21mm" wi="157.65mm" file="US08626987-20140107-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00017" num="00017">
<img id="EMI-D00017" he="141.82mm" wi="138.68mm" file="US08626987-20140107-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00018" num="00018">
<img id="EMI-D00018" he="218.86mm" wi="136.91mm" orientation="landscape" file="US08626987-20140107-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00019" num="00019">
<img id="EMI-D00019" he="192.96mm" wi="175.85mm" file="US08626987-20140107-D00019.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00020" num="00020">
<img id="EMI-D00020" he="168.15mm" wi="163.58mm" file="US08626987-20140107-D00020.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00021" num="00021">
<img id="EMI-D00021" he="174.75mm" wi="169.84mm" file="US08626987-20140107-D00021.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">This U.S. non-provisional patent application claims priority under 35 U.S.C. &#xa7;119 to Korean Patent Application No. 10-2010-0042077 filed on May 4, 2010, and to U.S. Provisional Application No. 61/255,119 filed on Oct. 27, 2009, the collective the subject matter of which is hereby incorporated by reference.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">BACKGROUND</heading>
<p id="p-0003" num="0002">The present inventive concept relates to memory systems, and more particularly to flash memory systems supporting flash memory defragmentation operations. The inventive concept also relates to methods of defragmenting flash memory.</p>
<p id="p-0004" num="0003">Unlike memory systems incorporating a hard disk, a flash memory system does not support a direct data overwrite operation. Instead, flash memory systems must perform an erase operation and then perform a write operation to effectively implement a rewrite or overwrite operation for data stored in the constituent flash memory. As is conventionally understood, flash memory performs erase operations on a memory block basis, and such operations typically require a lengthy period of execution time. These characteristics of flash memory make it difficult to directly apply a conventional hard disk file system to a flash memory system. That is, file systems and related data management approaches applied to memory systems incorporating a hard disk can not be applied to flash memory systems without significant adaptation. One common approach to the adaptation of legacy hard disk files systems to emerging flash memory systems (e.g., solid state drives or SSDs) requires the use of a so-called flash translation layer (FTL). The FTL is middleware that essentially translates the commands and operations defined within a hard disk file system into commands and operations compatible with a flash memory system. Thus, from the point of view of a host device generating and receiving data from the memory system, the FTL enables data to be read from and written to the flash memory system as if it were a conventional hard disk system.</p>
<p id="p-0005" num="0004">Available memory space is valuable commodity within electronic systems and devices. The continuous random use of any memory space leads to some degree of memory space fragmentation. That is, the processes of writing data (or data files) to memory, deleting data from memory, and overwriting stored data results in fragmentation of available memory space. Too much fragmentation of memory space can slow the overall operation of the host device.</p>
<p id="p-0006" num="0005">Hence, memory defragmentation (or defrag) is an operation that reduces the degree of fragmentation within a memory, or within a file system controlling the allocation of space within a memory. Defrag operations are conventionally applied to the hard disk of memory systems. Defrag improves operating speed of a memory system by reorganizing, concatenating and/or compacting fragmented data (or fragmented data files) within memory. Periodic defragmentation helps maintain the optimal performance of memory systems and constituent data storage media by reducing the file system overhead and data search time caused by excessive fragmentation.</p>
<heading id="h-0003" level="1">SUMMARY</heading>
<p id="p-0007" num="0006">Embodiments of the inventive concept provide flash memory systems supporting flash defragmentation, and related methods of defragmentation.</p>
<p id="p-0008" num="0007">Embodiments of the inventive concept provide an inventive defragmentation technique that is different from conventionally understood defragmentation techniques. Namely, embodiments of the inventive concept apply defragmentation to flash memory within a flash memory system to thereby reduce unnecessary data transfers by the flash memory system and improve overall performance.</p>
<p id="p-0009" num="0008">In certain embodiments of the inventive concept, a system comprises; a host configured to control a flash defragmentation operation defragmenting a flash memory arranged in a plurality of blocks, and a data storage device comprising the flash memory and configured to perform the flash defragmentation operation by reading fragments from in a plurality of fragmented blocks among the plurality of blocks, and grouping the fragments on the basis of a defined flash memory management unit.</p>
<p id="p-0010" num="0009">In certain embodiments of the inventive concept, a data storage unit comprises; a flash memory arranged in a plurality of blocks including a free block and a plurality of fragmented blocks storing a plurality of fragments, and a control unit configured to control a defragmentation operation defragmenting the flash memory and comprising a flash translation layer (FTL) configured to receive logical addresses and convert the logical addresses to corresponding physical addresses of the flash memory with reference to a mapping table, wherein during the defragmentation operation the control unit is further configured to read a subset of fragments among the plurality of fragments without regard to an arrangement order of the plurality of fragments as stored in the fragmented blocks, and write the subset of fragments in the free block.</p>
<p id="p-0011" num="0010">In certain embodiments of the inventive concept, a method of defragmenting a flash memory operated under the control of a host, the flash memory being arranged in a plurality of blocks including a free block and a plurality of fragmented blocks respectively storing at least one fragment, the method comprises; identifying a plurality of fragments stored in the plurality of fragmented blocks according to corresponding logical addresses, converting the logical addresses to corresponding physical addresses using a flash translation layer (FTL), using the physical addresses, reading a subset of fragments in the plurality of fragments from at least one of the plurality of fragmented blocks, grouping the subset of fragments within a grouping memory having a size defined by a flash management unit, and writing the grouped subset of fragments from the grouping memory to the free block.</p>
<p id="p-0012" num="0011">In certain embodiments of the inventive concept, a system comprises a host and a data storage device, the host comprises an application controlling execution of a defragmentation operation defragmenting a data storage device storing data used by the application. Operating within this system a method comprises; identifying a plurality of fragments stored in the memory, determining whether the data storage device is a hard disk drive (HDD), or a solid state drive (SSD) comprising a flash memory arranged in a plurality of blocks including a plurality of fragmented blocks and a free block, if the data storage device is a HDD, defining the defragmentation operation as a first type defragmentation operation compatible with storage of the data in the HDD, wherein the first type defragmentation operation is executed in accordance with logical addresses for the plurality of fragments defined by sector addresses of the HDD, and if the data storage device is a SSD, defining the defragmentation operation as a second type defragmentation operation compatible with storage of the data in the SSD, wherein the second type defragmentation operation is executed in accordance with the logical addresses of the plurality of fragments, wherein the second type defragmentation operation comprises; converting the logical addresses to corresponding physical addresses of the flash memory using a flash translation layer (FTL), using the physical addresses, reading a subset of fragments in the plurality of fragments from the plurality of fragmented blocks, grouping the subset of fragments into a grouping memory having a size defined by a flash management unit, and writing the grouped subset of fragments from the grouping memory to the free block.</p>
<p id="p-0013" num="0012">In certain embodiments of the inventive concept, method of defragmenting a flash memory, the flash memory being arranged in a plurality of blocks including a free block and a plurality of fragmented blocks storing a plurality of fragments, and the method comprises; managing a mapping table correlating externally applied logical addresses with physical addresses for the flash memory using a flash translation layer (FTL), identifying the plurality of fragmented blocks and a plurality of fragments stored in the plurality of fragmented blocks, and reading a subset of fragments among the plurality of fragments without regard to an arrangement order of the plurality of fragments as stored in the fragmented blocks, and writing the subset of fragments in the free block.</p>
<p id="p-0014" num="0013">In certain embodiments of the inventive concept a method of defragmenting a flash memory arranged in a plurality of blocks, each comprising a plurality of pages, the method comprises; identifying a plurality of fragmented blocks among the plurality of blocks, identifying a plurality of fragments stored in the fragmented blocks, identifying N free pages of one fragmented block, reading N fragments among the plurality of fragments from one of the plurality of fragmented blocks other than the one fragmented block without regard of an arrangement order of the N fragments as stored in the plurality of fragmented blocks, and writing the N fragments to fill the N free pages to thereby convert the one fragmented block to a new non-fragmented block.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0015" num="0014">The accompanying drawings are included to provide a further understanding of the inventive concept, and are incorporated in and constitute a part of this specification. The drawings illustrate exemplary embodiments of the inventive concept and, together with the description, serve to explain principles of the inventive concept. In the drawings:</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 1</figref> is a conceptual diagram illustrating the effects of a defragmentation operation performed on a hard disk;</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram of a flash memory system according to an exemplary embodiment of the inventive concept;</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 3</figref> is a block diagram illustrating a software layer structure of the flash memory system of <figref idref="DRAWINGS">FIG. 2</figref>;</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIGS. 4 and 5</figref> are diagrams illustrating a flash translation layer (FTL);</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIGS. 6 and 7</figref> illustrate a block mapping method performed using a virtual mapping table;</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 8</figref> illustrates a block structure of a file system of <figref idref="DRAWINGS">FIGS. 2 and 3</figref>;</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 9</figref> is a diagram illustrating a defragmentation size, a defragmentation start sector, and the number of sectors;</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 10</figref> is a diagram illustrating flash defragmentation by a host;</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIGS. 11 and 12</figref> are diagrams illustrating the results of flash defragmentation of <figref idref="DRAWINGS">FIG. 10</figref>;</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 13</figref> is a flow chart illustrating a flash defragmentation method of <figref idref="DRAWINGS">FIG. 10</figref>;</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 14</figref> is a diagram illustrating flash defragmentation by a flash storage device;</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIGS. 15 and 16</figref> are diagrams illustrating the results of flash defragmentation of <figref idref="DRAWINGS">FIG. 14</figref>;</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 17</figref> is a flow chart illustrating a flash defragmentation method of <figref idref="DRAWINGS">FIG. 14</figref>;</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 18</figref> illustrates an example of a host system incorporating both an SSD and HDD and capable of running competent defragmentation operations for each;</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 19</figref> illustrates an example of applying flash defragmentation to a memory card according to an exemplary embodiment of the inventive concept;</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 20</figref> is a block diagram illustrating an example of implementing flash defragmentation in a solid state drive (SSD) according to an exemplary embodiment of the inventive concept;</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 21</figref> is a block diagram illustrating an SSD controller of <figref idref="DRAWINGS">FIG. 19</figref>; and</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 22</figref> is a block diagram illustrating an example of implementing flash defragmentation in a flash memory module according to an exemplary embodiment of the inventive concept.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION OF THE EMBODIMENTS</heading>
<p id="p-0034" num="0033">Certain embodiments of the inventive concept will now be described in some additional detail with reference to the accompanying drawings. The inventive concept may, however, be embodied in many different forms and should not be construed as being limited to only the illustrated embodiments. Rather, these embodiments are provided so that this disclosure will be thorough and complete, and will fully convey the scope of the inventive concept to those skilled in the art.</p>
<p id="p-0035" num="0034">As noted above, defragmentation (or defrag) is an operation that reorganizes, concatenates, and/or compacts data otherwise inefficiently stored in memory. Data is typically stored in memory according to a defined memory space allocation scheme. The allocation scheme may use an allocation block of fixed or variable size to store data in memory. Since this allocation block is rarely the same size as data stored in the memory, a certain level of data fragmentation inherently arises as data is read from and written to memory.</p>
<p id="p-0036" num="0035">For example, as one or more applications is run by a host (e.g., a processor or CPU) data related to the applications is read from and written to memory. Much of this data is associated with files defined by a file system (or file system manager) running on the host. Such files may be large or small and may be stored according to one or more allocation blocks in the memory. As this data (and corresponding data files) are manipulated, revised, updated, overwritten and deleted it becomes increasingly fragmented. That is, more and more data (or data file) fragments are created as the application(s) are run on the host.</p>
<p id="p-0037" num="0036">In this context, the term &#x201c;fragment&#x201d; is used to denote a data file, or data file portion stored in memory that is related to, operationally associated with, or operationally defined by one or more applications or a file system running on a host. Respective fragments are usually stored in a discontiguous manner across multiple memory blocks, but this need not be the case in all circumstances. Those skilled in the art will recognize that the presence of relatively more fragments in a memory tends to generate relatively more memory space fragmentation. Thus, there is a direct relationship between the number of &#x201c;fragments&#x201d; stored in memory and resulting &#x201c;fragmented memory space&#x201d;. Indeed, some conventional defragmentation operations use the term fragment to denote relatively small (and less useful) portions of available memory space.</p>
<p id="p-0038" num="0037">The discontiguous (or scattered) storage of fragments in a memory slows the execution of the application(s) on the host, since the disparate fragments must be searched for across an expanding range of memory blocks in the memory system. Thus, execution of a defragmentation operation reduces search time by physically rearranging (re-storing) discontiguously stored fragments into more proximate memory space. Conventionally, by coherently grouping application-related (or file-related) fragments in a data storage device (e.g., a hard disk or semiconductor memory), search time within the memory system is reduced.</p>
<p id="p-0039" num="0038">For example, it is assumed that the constituent fragments of two files, &#x201c;a&#x201d; and &#x201c;b&#x201d;, are discontiguously stored on a hard disk as conceptually illustrated in <figref idref="DRAWINGS">FIG. 1A</figref>. The file &#x201c;a&#x201d; comprises fragments a<b>1</b>&#x2dc;a<b>7</b>, and file &#x201c;b&#x201d; comprises fragments b<b>1</b>&#x2dc;b<b>5</b>. As illustrated by the sequence shown in <figref idref="DRAWINGS">FIGS. 1A through 1D</figref>, multiple data copy operations are executed in relation to the hard disk to contiguously rearrange the physical location of the stored file fragments. Ultimately, the fragments making up files &#x201c;a&#x201d; and &#x201c;b&#x201d; are stored in a more search-efficient manner (i.e., a fully sequential arrangement) that maximizes the residual size of the available memory space (or &#x201c;free space&#x201d;) on the hard disk, as illustrated in <figref idref="DRAWINGS">FIG. 1D</figref>, and minimizes the search time across all fragments making up each data file.</p>
<p id="p-0040" num="0039">The foregoing example assumes a memory system incorporating a hard disk. Those skilled in the art will recognize the benefits of performing a defragmentation operation in relation to the unique electro-mechanical functionality associated with searching for fragments stored on a hard disk. Namely, as the surface area of the hard disk that must be traversed by a read/write head to find a fragment is reduced, the operating speed of the memory system will increase.</p>
<p id="p-0041" num="0040">Unlike a hard disk based memory system, however, the operating speed of a memory system incorporating flash memory (hereinafter, generically referred to as a &#x201c;flash storage device&#x201d;) is not materially affected by the stored order (or relative physical location) of fragments. That is, the discontiguous storing of fragments across a range of memory blocks defined within the flash memory does not in and of itself adversely slow read/write performance, since data search time in a flash memory does not vary as it does in a hard disk.</p>
<p id="p-0042" num="0041">As a result, many of the conventional considerations motivating the use of defragmentation operations in a hard disk based memory system do not apply to flash memory based memory systems. Indeed, assuming that a flash storage device is substituted for the hard disk defragmented by the approach illustrated in <figref idref="DRAWINGS">FIG. 1</figref>, the numerous (and unnecessary) data transfers associated with the multiple copy operations would only shorten the useful life of the flash memory and degrade memory system performance. In sum, given the distinct performance and operating characteristics of flash memory over other types of bulk data storage devices (e.g., hard disks), a different approach motivated by a completely different rationale must be taken in relation to the defragmentation of a flash storage device.</p>
<p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram of a flash memory system according to an embodiment of the inventive concept. Referring to <figref idref="DRAWINGS">FIG. 2</figref>, a flash memory system <b>1000</b> includes a host <b>1100</b> and a flash storage device <b>1200</b>. The flash memory system <b>1000</b> supports flash memory management unit-based defragmentation (hereinafter referred to as &#x201c;flash defragmentation&#x201d;). Examples of a &#x201c;flash memory management unit&#x201d; include; (1) a memory block (or a super block) used as an erase operation unit, or (2) a page (or super page) used as a read/write operation unit.</p>
<p id="p-0044" num="0043">The following description will focus on memory block-based flash defragmentation. That is, embodiments of the inventive concept perform flash defragmentation on a flash memory management unit basis, thereby making it possible to reduce the number of data transfer operations required during defragmentation and yet making efficient use of the free space remaining in flash memory. Referring to <figref idref="DRAWINGS">FIG. 2</figref>, the host <b>1100</b> generally includes a processing unit <b>1110</b> and a driving unit <b>1120</b>. The processing unit (e.g., a CPU) <b>1110</b> controls the overall operation of the host <b>1100</b>. The driving unit <b>1120</b> drives the flash storage device <b>1200</b> under the control of the processing unit <b>1110</b>. The driving unit <b>1120</b> may include a host memory <b>1124</b> storing programming code (e.g., application and operating systems) and data (e.g., user defined data) that enables program execution and general functionality within the host <b>1100</b>.</p>
<p id="p-0045" num="0044">Referring to <figref idref="DRAWINGS">FIG. 2</figref>, the driving unit <b>1120</b> is illustrated as including an application <b>1121</b>, a file system <b>1122</b>, a device driver <b>1123</b>, and a host memory <b>1124</b>. The application <b>1121</b> is software executed on an operating system (OS) running on the host <b>1100</b>. It is further assumed that at least one of the application <b>1121</b> or OS is programmed to support a flash defragmentation operation directed to flash storage device <b>1200</b>.</p>
<p id="p-0046" num="0045">In the illustrated embodiment, the file system <b>1122</b> is assumed to be software executing a file management protocol. In a more specific embodiment, the file system <b>1122</b> may be a file and data management system compatible with a legacy file system used to define and manage data and data files stored on a hard disk. In this particular context, the host <b>1100</b> and its constituent file system <b>1122</b> &#x201c;see&#x201d; the flash storage device <b>1200</b> as if it were a conventional hard disk storing data according to defined sector addresses.</p>
<p id="p-0047" num="0046">Accordingly, the file system <b>1122</b> may manage data and data files on a sector basis for a hard disk and/or a block basis for a flash memory. Hereinafter, the file management unit of the file system <b>1122</b> will be referred to as a file system block. That is, the file system <b>1122</b> systemizes and manages the files on a file system block basis, whether the system block is compatible with hard disk sectors or flash memory blocks.</p>
<p id="p-0048" num="0047">According to the illustrated embodiment of the inventive concept, for flash defragmentation, the file system <b>1122</b> &#x201c;groups&#x201d; file system blocks according to a flash memory management unit. This will be described later in some additional detail with reference to <figref idref="DRAWINGS">FIG. 8</figref>. The file system <b>1122</b> may set a flash defragmentation region on the basis of validity information of a file system block. The file system <b>1122</b> transfers file system block information to the flash storage device <b>1200</b> to request flash defragmentation. The file system block information may be converted on a sector basis (e.g., 512B) prior to transfer to the flash storage device <b>1200</b>.</p>
<p id="p-0049" num="0048">The file system <b>1122</b> may include flash memory file systems such as LFS, JFFS, YAFFS and LogFS, as well as FAT (File Application Table), NTFS (New Technology File System), HPFS (High Performance File System), UFS (Unix File System), Ext2 (Second Extended File System) and Ext3 (Third Extended File System) that are used mainly in floppy disks or hard disks.</p>
<p id="p-0050" num="0049">The device driver <b>1123</b> is a program that enables the flash storage device <b>1200</b> to communicate with the host <b>1100</b>. In order to use the flash storage device <b>1200</b>, the device driver <b>1123</b> suitable for use with the flash storage device <b>1200</b> must be installed in the host <b>1100</b>. The host memory <b>1124</b> may temporarily store &#x201c;write data&#x201d; to be written to, or &#x201c;read data&#x201d; having been read from the flash storage device <b>1200</b>. Also, the host memory <b>1124</b> may be used as a working memory during execution of the application <b>1121</b>, operation of the file system <b>1122</b>, and/or the device driver <b>1123</b>.</p>
<p id="p-0051" num="0050">The flash storage device <b>1200</b> may perform flash defragmentation at in response to a corresponding command received from the host <b>1100</b>. Alternately or additionally, the flash storage device <b>1200</b> may receive a sector address identifying flash defragmentation from the host <b>1100</b>. Referring to <figref idref="DRAWINGS">FIG. 2</figref>, the flash storage device <b>1200</b> generally includes a flash memory <b>1210</b>, a buffer memory <b>1220</b>, and a control unit <b>1230</b>.</p>
<p id="p-0052" num="0051">The flash memory <b>1210</b> may perform an erase/write/read operations under the control of the control unit <b>1230</b>. The flash memory <b>1210</b> shown in <figref idref="DRAWINGS">FIG. 2</figref> includes a plurality of memory blocks. Each of the memory blocks includes a plurality of pages. Four memory blocks <b>1121</b>&#x2dc;<b>1124</b> each including four pages are specifically illustrated in <figref idref="DRAWINGS">FIG. 2</figref> as a simple example. The flash memory <b>1210</b> performs erase operations on a memory block basis, but performs write/read operations on a page basis. It is further assumed in the working example that fragments are stored in the flash memory <b>1210</b> on a page-by-page basis. That is, one page is used as a data or data file allocation size by the host <b>1100</b>.</p>
<p id="p-0053" num="0052">The flash memory <b>1210</b> may be formed by a memory cell array of flash memory cells capable of storing 1-bit data per memory cell (i.e., single level memory cells) and/or at least 2-bit data per memory cell (i.e., multi-level memory cells).</p>
<p id="p-0054" num="0053">The buffer memory <b>1220</b> may be used to temporarily store read data retrieved from and/or write data to be written to the flash memory <b>1210</b> by the host <b>1100</b>. The buffer memory <b>1220</b> may also be used in conjunction with the operation of software or firmware, such as a flash translation layer (FTL). The buffer memory <b>1220</b> may be implemented using volatile memory devices such as DRAM and SRAM, or nonvolatile memory devices, such as EEPROM, MRAM and PRAM.</p>
<p id="p-0055" num="0054">Referring to <figref idref="DRAWINGS">FIG. 2</figref>, the control unit <b>1230</b> illustrated in the example includes a central processing unit (CPU) <b>1231</b>, a flash translation layer (FTL) <b>1232</b>, a flash controller <b>1233</b>, and a buffer controller <b>1234</b>. The CPU <b>1231</b> analyzes/processes signals received from the host <b>1100</b>, and controls the overall operation of the flash storage device <b>1200</b>. The FTL <b>1232</b> translates logical addresses (e.g., a sector address) received from the host <b>1100</b> into a physical address compatible with the one or more memory devices in the flash memory <b>1210</b>. The flash controller <b>1233</b> controls read/write/erase operations executed in relation to the flash memory <b>1210</b>, and the buffer controller <b>1234</b> controls read/write operations executed in relation to the buffer memory <b>1220</b>.</p>
<p id="p-0056" num="0055"><figref idref="DRAWINGS">FIG. 3</figref> is a block diagram illustrating a hierarchical relationship between software/firmware components (or &#x201c;software layer structure&#x201d;) of the flash memory system <b>1000</b> shown in <figref idref="DRAWINGS">FIG. 2</figref>. Referring to <figref idref="DRAWINGS">FIG. 3</figref>, the illustrated software layer structure for the flash memory system <b>1000</b> includes the application <b>1121</b>, file system <b>1122</b>, FTL <b>1232</b>, and flash memory <b>1210</b>. When receiving a flash defragmentation command (Flash Defrag) generated (e.g.) by the application <b>1121</b>, the file system <b>1122</b> provides a flash defragmentation target sector address (Sector ADDR) to the FTL <b>1232</b>. The FTL <b>1232</b> then translates the sector address into a physical address designating a block and/or page within the flash memory <b>1210</b>.</p>
<p id="p-0057" num="0056">As illustrated in <figref idref="DRAWINGS">FIG. 4</figref>, the FTL <b>1232</b> translates a sector address&#x2014;just one convenient example of a logical address&#x2014;into a physical address&#x2014;here, a block and page number associated with the memory cells of the flash memory <b>1210</b>.</p>
<p id="p-0058" num="0057">As further illustrated in <figref idref="DRAWINGS">FIG. 5</figref>, the FTL <b>1232</b> essentially performs an emulation operation mimicking read/write operations conventionally directed to a hard disk, but instead performing read/program/erase operation(s) in the flash memory <b>1210</b>. Thus, from the viewpoint of higher level software/firmware components (e.g., the file system <b>1122</b> and the application <b>1121</b>), the read/program/erase operations resulting from operation of the FLT <b>1232</b> are &#x201c;seen as&#x201d; conventional read/write operations directed to a hard disk.</p>
<p id="p-0059" num="0058">The address translation functionality provided by the FTL <b>1232</b> may be performed using, for example, a virtual mapping table. Conventionally understood examples of mapping schemes that may be used include a page mapping scheme and/or a block mapping scheme. The page mapping scheme performs address translation on a page basis (e.g., 2 KB), and the block mapping scheme performs address translation on a block basis (e.g., 1 MB). Certain hybrid mapping schemes using both block and page mapping might also be used.</p>
<p id="p-0060" num="0059"><figref idref="DRAWINGS">FIG. 6</figref> illustrates an exemplary address translation process based on an assumed block mapping scheme. Referring to <figref idref="DRAWINGS">FIG. 6</figref>, functionality provided by the FTL <b>1231</b> of <figref idref="DRAWINGS">FIG. 2</figref> identifies a logical block number (LBN) and a logical offset in response to a sector address including, for example, a sector number and the number of sectors received from the file system <b>1122</b>. The logical block number (LBN) and the logical offset are mapped respectively to a physical block number (PBN) and a physical offset that identify (e.g.,) block <b>1212</b> and page <b>0</b> within the flash memory <b>1210</b>.</p>
<p id="p-0061" num="0060">Those skilled in the art will recognize that the sector address generated by the file system <b>1122</b> is the outcome of a file system block definition. Using corresponding meta data, the file system <b>1122</b> may define one or more file system blocks in relation to a data cluster (e.g., 4K) conventionally defined in relation to a hard disk (e.g., 8 data sectors per cluster). Those skilled in the art will recognize that such cluster and file system block definitions are a matter of design choice and may be altered by assumptions regarding disk formatting. Regardless of such definitions, however, the resulting logical addresses will be converted to flash memory compatible logical addresses by the FTL <b>1232</b>.</p>
<p id="p-0062" num="0061"><figref idref="DRAWINGS">FIG. 7</figref> further illustrates the block mapping approach assumed for the example of <figref idref="DRAWINGS">FIG. 6</figref>. Block mapping is performed between an actual physical space and a logical (or virtual) memory space within the flash memory <b>1210</b>. Like the physical space, the logical space of the flash memory <b>1210</b> includes four blocks <b>0000</b>&#x2dc;<b>0003</b>. Each of the blocks includes four pages, and each page is assumed to includes eight sectors. In <figref idref="DRAWINGS">FIG. 7</figref>, the reference &#x201c;SN&#x201d; denotes a sector number associated with the logical address space.</p>
<p id="p-0063" num="0062">It is assumed that three files &#x201c;A&#x201d;, a jpeg file including fragments a<b>1</b> and a<b>2</b>, &#x201c;B&#x201d;, another jpeg file including fragments b<b>1</b> through b<b>4</b>, and &#x201c;C&#x201d;, a Word file including fragments c<b>1</b> and c<b>2</b> are stored in the flash memory <b>1210</b>. More specifically, fragments a<b>1</b>, a<b>2</b> and b<b>4</b> are stored in physical block <b>1212</b>, fragments c<b>1</b> and b<b>1</b> are stored in physical block <b>1213</b>, and fragments b<b>2</b>, c<b>2</b> and b<b>3</b> are stored in physical block <b>1214</b>. In this initial discontiguous arrangement of fragments, physical block <b>1211</b> is a free block, empty of fragments. It is further assumed that logical block <b>0000</b> is mapped to physical block <b>1212</b>, logical block <b>0001</b> is mapped to physical block <b>1213</b>, and logical block <b>0002</b> is mapped to physical block <b>1214</b>.</p>
<p id="p-0064" num="0063">The FTL <b>1232</b> may use virtual logical space to cause the operation of the flash storage device <b>1200</b> to emulate hard disk compatible operations by performing random read/write operations. That is as seen from the host <b>1100</b>, the flash memory <b>1210</b> appears to operates just like a hard disk in a defined virtual logical space, but actually operates according to performance characteristics unique to flash memory (e.g., the block-based erase, and the erase before write operation requirement) in physical space.</p>
<p id="p-0065" num="0064">Since the FTL <b>1232</b> effectively allows the flash storage device <b>1200</b> to operate in emulation of a hard disk, the flash memory system <b>1000</b> may be seamlessly used in conjunction with legacy hard disk-based file systems, such as FAT, NTFS, Ext2 and Ext3&#x2014;at least when viewed from higher level software/firmware components and the host <b>1100</b> in general.</p>
<p id="p-0066" num="0065"><figref idref="DRAWINGS">FIG. 8</figref> further illustrates the foregoing form the standpoint of a file system block structure acted upon by the file system <b>1122</b> of <figref idref="DRAWINGS">FIGS. 2 and 3</figref>. Referring to <figref idref="DRAWINGS">FIG. 8</figref>, fragments a<b>1</b> and a<b>2</b> of file A are stored in regions indicated by sector numbers <b>0</b>&#x2dc;<b>15</b>. Fragment b<b>4</b> of file B and fragment c<b>1</b> of file C are stored in regions indicated by sector numbers <b>24</b>&#x2dc;<b>39</b>. Fragments b<b>1</b>&#x2dc;b<b>3</b> of file B and fragment c<b>2</b> of file C are stored in regions indicated by sector numbers <b>56</b>&#x2dc;<b>97</b>.</p>
<p id="p-0067" num="0066">The file system <b>1122</b> may set (or define) a flash defragmentation region (e.g., sectors <b>0</b>&#x2dc;<b>127</b>) according to a file system block. The file system <b>1122</b> thus provides a defragmentation size (e.g., sectors <b>0</b>&#x2dc;<b>127</b>), a defragmentation start sector number, and the number of sectors to the flash storage device <b>1200</b> as illustrated in <figref idref="DRAWINGS">FIG. 9</figref>.</p>
<p id="p-0068" num="0067">For flash defragmentation within the illustrated embodiment of the inventive concept, the file system <b>1122</b> rearranges (or &#x201c;groups&#x201d;) file system blocks on a flash memory management unit basis (e.g., on a memory block basis). Referring to <figref idref="DRAWINGS">FIG. 8</figref>, the sectors <b>0</b>&#x2dc;<b>127</b> are divided into four groups Group<b>1</b>&#x2dc;Group<b>4</b>, wherein each group corresponds to a block within the flash memory <b>1210</b>. However, other embodiments of the inventive concept may use a grouping approach that uses a page unit.</p>
<p id="p-0069" num="0068">In order for each one of the defined groups of blocks to correspond to a block unit in the flash memory <b>1210</b>, a start address for the file system block must be equal to a start address for the flash memory block, and a size of each group must be equal to an integer multiple of a size of the flash memory block. One technique for equalizing the start address of a file system block, and setting a group size is disclosed, for example, in published U.S. Patent Application No. 2008/0195833, the subject matter of which is hereby incorporated by reference.</p>
<p id="p-0070" num="0069">As described above, the flash memory system <b>1000</b> consistent with an embodiment of the inventive concept performs flash defragmentation by grouping fragments stored in the flash memory <b>1210</b> according to a flash memory management unit. In this context, a &#x201c;fragmented block&#x201d; among the plurality of blocks forming the flash memory <b>1210</b> is a block storing at least one fragment, but also storing insufficient fragments to be substantially full. That is, a fragmented block is not a free block or a full block.</p>
<p id="p-0071" num="0070">As will be explained hereafter in some additional detail, the flash memory system <b>1000</b> performs flash defragmentation regardless of the arrangement order of the fragments stored in memory. That is, at least one fragmented block is converted into a free block by rearranging (&#x201c;groupings&#x201d;) fragments stored in fragmented blocks on a flash memory management unit basis, wherein the grouping process proceeds from fragment to fragment in a selected fragmented block, and then from a selected fragmented block to a next selected fragmented block regardless of either (1) a pre-existing file system defined arrangement order (e.g., a<b>1</b> through a<b>4</b> in <figref idref="DRAWINGS">FIG. 1</figref>), or (2) a stored physical arrangement order (e.g., a<b>1</b> and a<b>2</b> in <figref idref="DRAWINGS">FIG. 7</figref>) for the fragments stored in a fragmented block or across a plurality of fragmented blocks. This ability by embodiments of the inventive concept to perform flash defragmentation operations regardless of an arrangement order for the fragments being re-grouped is a clear departure from conventional defragmentation operations.</p>
<p id="p-0072" num="0071">A flash defragmentation method for the flash memory system <b>1000</b> according to an embodiment of the inventive concept may include flash defragmentation by the host <b>1100</b> (section II below) and/or flash defragmentation by the flash storage device <b>1200</b> (section III below). Flash defragmentation by the host is most commonly performed in relation to data transfers between the host <b>1100</b> and the flash storage device <b>1200</b>. Flash defragmentation by the flash storage device <b>1200</b> is most commonly performed without relation to a specific data transfer between the host <b>1100</b> and the flash storage device <b>1200</b>.</p>
<p id="p-0073" num="0072"><figref idref="DRAWINGS">FIG. 10</figref> is a diagram conceptually illustrating a flash defragmentation operation executed by the host <b>1100</b>. In the illustrated example, the host <b>1100</b> performs flash defragmentation on a defined flash memory management basis by sequentially reading and grouping fragments on a memory block by memory block basis, regardless of the arrangement order of the fragments being grouped. Once this reading and grouping sequence yields a full memory block, the full memory block may be written to an existing free block in the flash memory <b>1210</b>, and at least one new block may be formed. As noted above, flash defragmentation consistent with an embodiment of the inventive concept will be performed according to a flash memory management unit, such as a page, a super page, a block, a super block, a group of pages, a group of blocks, etc.</p>
<p id="p-0074" num="0073">Referring to <figref idref="DRAWINGS">FIG. 10</figref>, it is assumed that the fragments associated with files A, B, and C described in the context of <figref idref="DRAWINGS">FIG. 7</figref> are initially stored, as illustrated, in the logical space of the flash memory <b>1210</b>. That is, fragments a<b>1</b>, a<b>2</b> and b<b>4</b> are stored in logical block <b>0000</b>, fragments c<b>1</b> and b<b>1</b> are stored in logical block <b>0001</b>, and fragments b<b>2</b>, c<b>2</b> and b<b>3</b> are stored in logical block <b>0002</b>. Thus logical blocks <b>0000</b>, <b>0001</b> and <b>0002</b> are each considered a &#x201c;fragmented block&#x201d; because it has been invalidated as a block, or stores at least one fragment while remaining not full. In the illustrated example of <figref idref="DRAWINGS">FIG. 10</figref> it is assumed that fragments are stored by the host <b>1100</b> on a page basis. Thus, in the illustrated example each not-invalidated fragmented block will include at least one valid written page, but less than four valid written pages. Since no fragment (not one valid page) is stored in logical block <b>0003</b>, it is a free block.</p>
<p id="p-0075" num="0074">When the flash defragmentation operation begins, the host <b>1100</b> reads four pages worth of fragments a<b>1</b>, a<b>2</b>, b<b>4</b> and c<b>1</b> beginning with a lowest numbered page of logical block <b>0000</b> until a fourth page of data is read. More generically, the defragmentation read operation begins by sequentially reading valid data at a defined start address, on a page by page basis, until N pages of data have been read, wherein each block of flash memory (or each flash memory management unit) is defined as comprising N pages. Thus, as one of ordinary skill in the art may understand from the illustrated example of <figref idref="DRAWINGS">FIG. 10</figref> that the foregoing &#x201c;read and group&#x201d; process may continue until any reasonable number of fragments are collected into one or more non-fragmented blocks.</p>
<p id="p-0076" num="0075">The foregoing fragments a<b>1</b>, a<b>2</b>, b<b>4</b>, and c<b>1</b> are read and stored to host memory <b>1124</b> in the embodiment of <figref idref="DRAWINGS">FIG. 10</figref>. It should be noted, however, that host memory <b>1124</b> is only one example of a grouping memory that may be used to group the read fragments. The term &#x201c;grouping memory&#x201d; as used herein means any memory used to store (and thereby group) fragments during a flash defragmentation operation. In essence, one flash memory management unit's worth of fragments are read and then stored in the grouping memory.</p>
<p id="p-0077" num="0076">Since one block of data is assumed as the flash memory management unit in the working example, once a full block of data (e.g., fragments a<b>1</b>, a<b>2</b>, b<b>4</b> and c<b>1</b>) is stored in the host memory <b>1124</b>, a write command is issued by the host <b>1100</b> and the collection of fragments a<b>1</b>, a<b>2</b>, b<b>4</b> and c<b>1</b> is written from the host memory <b>1124</b> to the free block <b>0003</b> of the flash memory <b>1210</b>.</p>
<p id="p-0078" num="0077">Following these data consolidating read and write operations and recognizing that the flash memory <b>1210</b> has no free block, the corresponding logical block <b>0000</b> may be erased to create a new free block. In this context, a &#x201c;free block&#x201d; is an empty block existing before the defragmentation operation begins, while a &#x201c;new free block&#x201d; is an empty block existing as the result of the defragmentation operation. For example, the host <b>1100</b> may use a data invalidity, a trim, or similar command to erase the logical block <b>0000</b> once the grouped fragments stored in the host memory <b>1124</b> have been successfully written to logical block <b>0003</b>. A corresponding erase operation is performed on the physical space (not illustrated) of the flash memory <b>1210</b>, and the logical block <b>0000</b> is effectively converted into a free block in an updated block mapping table, for example. Exemplary data invalidity and trim commands are described, for example, in pending U.S. patent application Ser. No. 12/775,767 filed May 7, 2010.</p>
<p id="p-0079" num="0078">Thereafter, it is assumed that the flash defragmentation operation continues in similar manner by reading and grouping fragments b<b>1</b>, b<b>2</b>, c<b>2</b> and b<b>3</b>. That is, the host <b>1100</b> sequentially reads fragments b<b>1</b>, b<b>2</b>, c<b>2</b> and b<b>3</b> from logical blocks <b>0001</b> and <b>0002</b> and stores the resulting data in the host memory <b>1124</b>. Here again, fragments b<b>1</b>, b<b>2</b>, c<b>2</b> and b<b>3</b> fit into one block unit. Using a subsequent write command, the host <b>1100</b> writes the consolidated data associated with the fragments b<b>1</b>, b<b>2</b>, c<b>2</b> and b<b>3</b> and stored in the host memory <b>1124</b> to the new free block <b>0000</b>. Using an additional trim command, the host device <b>1100</b> effectively erases both logical blocks <b>0001</b> and <b>0002</b>. That is, corresponding erase operations directed to the physical memory space associated with logical blocks <b>0001</b> and <b>0002</b> may subsequently be executed (e.g.) during memory system idle time.</p>
<p id="p-0080" num="0079"><figref idref="DRAWINGS">FIGS. 11 and 12</figref> collectively illustrate the results of the flash defragmentation operation described above in relation to <figref idref="DRAWINGS">FIG. 10</figref>. <figref idref="DRAWINGS">FIGS. 11 and 12</figref> respectively illustrate the flash defragmentation results from the viewpoint of the flash memory <b>1210</b> and the file system <b>1122</b>. Referring to <figref idref="DRAWINGS">FIG. 11</figref>, fragments b<b>1</b>, b<b>2</b>, c<b>2</b> and b<b>3</b> are stored in relation to the logical block <b>0000</b> in logical space while being mapped to physical block <b>1212</b> in physical space. Fragments a<b>1</b>, a<b>2</b>, b<b>4</b> and c<b>1</b> are stored in relation to logical block <b>0003</b> in logical space while being mapped to physical block <b>1211</b> in physical space. Referring to <figref idref="DRAWINGS">FIG. 12</figref>, fragments b<b>1</b>, b<b>2</b>, c<b>2</b> and b<b>3</b> are stored in a first file system block group (Group<b>1</b>) including sector numbers <b>0</b>&#x2dc;<b>31</b>, and fragments a<b>1</b>, a<b>2</b>, b<b>4</b> and c<b>1</b> are stored within a fourth file system block group (Group<b>4</b>) including sector numbers <b>96</b>&#x2dc;<b>127</b>.</p>
<p id="p-0081" num="0080"><figref idref="DRAWINGS">FIG. 13</figref> is a flow chart summarizing a host-based flash defragmentation method consistent with the example described in relation to <figref idref="DRAWINGS">FIG. 10</figref>. When flash defragmentation starts, the host <b>1100</b> must detect information defining a flash memory management unit (e.g., a memory block).</p>
<p id="p-0082" num="0081">The host <b>1100</b> analyzes file system blocks and groups within the file system blocks according to the identified memory block basis (S<b>110</b>), and identifies corresponding fragmented blocks (S<b>120</b>).</p>
<p id="p-0083" num="0082">If the number of fragmented logical blocks is less than a defined minimum, or a defined &#x201c;fragmented block threshold&#x201d;, assumed to be two in the illustrated example (S<b>130</b>=No), then the flash defragmentation operation ends. However, if the number of fragmented logical blocks is greater than or equal to the fragmented block threshold (S<b>130</b>=Yes), one block unit of data (e.g., fragments a<b>1</b>, a<b>2</b>, b<b>4</b> and c<b>1</b>) is read from one or more fragmented blocks (e.g., logical block <b>0000</b> and <b>0001</b>) and stored in the host memory <b>1124</b> (S<b>140</b>). The host <b>1100</b> then writes the data stored in the host memory <b>1124</b> to a free block in the flash memory <b>1210</b> (S<b>150</b>). Thereafter, the FTL <b>1232</b> updates a corresponding mapping table (S<b>160</b>) to reflect the changes.</p>
<p id="p-0084" num="0083">If the number of fragmented logical blocks is now less than the fragmented block threshold (S<b>170</b>=Yes), the file system blocks are updated to reflect the flash defragmentation results (S<b>180</b>) and the flash defragmentation operation ends. If, however, the number of fragmented logical blocks remains greater than or equal to the fragmented block threshold (S<b>170</b>=No), the defragmentation operation contuse by returning to step S<b>140</b>. In the working example, flash defragmentation operation continues by reading and grouping fragments b<b>1</b>, b<b>2</b>, c<b>2</b> and b<b>3</b> stored in the fragmented blocks <b>0001</b> and <b>0002</b>.</p>
<p id="p-0085" num="0084">According to the host-based (or external) flash defragmentation method of <figref idref="DRAWINGS">FIG. 13</figref>, flash defragmentation may be performed on fragments on a memory block basis using a series of read/write commands generated by the host <b>1100</b>. The use of a flash defragmentation method according to certain embodiments of the inventive concept makes it possible to reduce the number of data transfer operations required to implement the defragmentation operation while efficiently providing more available free space in the flash memory.</p>
<p id="p-0086" num="0085"><figref idref="DRAWINGS">FIG. 14</figref> is a diagram illustrating an internal flash defragmentation operation performed within the flash storage device <b>1200</b>. The host <b>1100</b> may provide a flash defragmentation command (hereafter, a &#x201c;defrag command&#x201d;) to the flash storage device <b>1200</b> to begin the internal flash defragmentation operation. As part of the defrag command, or conjunction therewith. the host <b>1100</b> may provide (e.g.,) a defrag block size, a defrag start sector, a number of sectors (# of sectors), and/or a bitmap for a sector of the corresponding region storing valid data. The example of <figref idref="DRAWINGS">FIG. 14</figref> shows only a selected few of these defrag command related data components, and it should be noted that many different types of defrag commands are contemplated for use within various embodiments of the inventive concept.</p>
<p id="p-0087" num="0086">Upon receiving a defrag command, the flash storage device <b>1200</b> may perform the internal flash defragmentation operation to completion without further exchange of data (e.g., the series of host generated read/write operation noted above) with the host <b>1100</b>. After completion of the internal defragmentation operation, the flash storage device may provide results to the host <b>1100</b> in the form of updated mapping tables, etc. For example, the defrag results may correlate original sector number(s) with new sector number(s), a final number of valid sectors, etc. The host <b>1100</b> may then update the file system blocks on the basis of the defrag results.</p>
<p id="p-0088" num="0087">Referring to <figref idref="DRAWINGS">FIG. 14</figref>, the flash storage device <b>1200</b> identifies a logical block within the flash memory <b>1210</b> according to a given defrag start sector, as well as a number of sectors to be defragmented, and collects state information related to the corresponding physical space in the flash memory <b>1210</b> using, for example a mapping table. The flash storage device <b>1200</b> may then use the physical space state information to identify fragmented blocks, free blocks, and/or full blocks. In this context, the definition of a fragmented block may be variously defined by memory system designers, or in the context of certain applications running in the host <b>1100</b>. As used above, the term &#x201c;fragmented block&#x201d; meant any block between a free block and a full block, but this need not be the case. Certain minimum and maximum limits may be used to identify fragmented blocks within a particular defragmentation operation. Once identified, the flash storage device <b>1200</b> may construct a list of fragmented blocks, and may also construct validity information for each page within each fragmented block using, for example, bitmap(s) or look-up table(s).</p>
<p id="p-0089" num="0088">Similar to the working examples described in relation to <figref idref="DRAWINGS">FIGS. 7 and 10</figref>, the following example assumes that three files; A (including a<b>1</b>, a<b>2</b>), B (including b<b>1</b>, b<b>2</b>, b<b>3</b>, b<b>4</b>), and C (including c<b>1</b>, c<b>2</b>), are stored in the logical space of the flash memory <b>1210</b>. Fragments a<b>1</b>, a<b>2</b> and b<b>4</b> are stored in logical block <b>0000</b>, fragments c<b>1</b> and b<b>1</b> are stored in logical block <b>0001</b>, and fragments b<b>2</b>, c<b>2</b> and b<b>3</b> are stored in logical block <b>0002</b>. Logical block <b>0003</b> is a free block. As illustrated in an original block mapping table of <figref idref="DRAWINGS">FIG. 15</figref>, the logical block <b>0000</b> is mapped to physical block <b>1212</b>, the logical block <b>0001</b> is mapped to physical block <b>1213</b>, and logical block <b>0002</b> is mapped to physical block <b>1214</b>.</p>
<p id="p-0090" num="0089">Referring back to <figref idref="DRAWINGS">FIG. 14</figref>, the flash defragmentation operation is performed on a memory block basis in the physical space of the flash memory <b>1210</b>. For example, fragments a<b>1</b>, a<b>2</b> and b<b>4</b> stored in the physical block <b>1212</b> and fragment c<b>1</b> stored in the physical block <b>1213</b> are copied to the free block <b>1211</b>. Then, the physical block <b>1212</b> is erased to become a new free block. Thereafter, fragment b<b>1</b> stored in the physical block <b>1213</b> and fragments b<b>2</b>, c<b>2</b> and b<b>3</b> stored in the physical block <b>1214</b> are copied to new free block <b>1212</b>. Then, physical blocks <b>1213</b> and <b>1214</b> may be erased to become additional new free blocks. Herein, each copy operation may be performed using a conventionally understood, copyback programming operation executed within the flash memory <b>1210</b>.</p>
<p id="p-0091" num="0090">The corresponding page numbers for fragments a<b>1</b>, a<b>2</b> and b<b>4</b> may be maintained while one block unit data (e.g., the block unit including fragments a<b>1</b>, a<b>2</b>, b<b>4</b> and c<b>1</b>) is being copied to the free block <b>1211</b>. In this case, data may be copied to the free block <b>1211</b> in a sequential order for fragments a<b>1</b>, a<b>2</b>, c<b>1</b> and b<b>4</b>. Likewise, data may be copied to the new free block <b>1212</b> in the sequential order of fragments b<b>2</b>, c<b>3</b>, b<b>1</b> and b<b>3</b>.</p>
<p id="p-0092" num="0091">As illustrated in a new block mapping table of <figref idref="DRAWINGS">FIG. 15</figref>, logical block <b>0000</b> remains mapped to physical block <b>1212</b> while logical block <b>0003</b> is now mapped to physical block <b>1211</b>. Logical blocks <b>0001</b> and <b>0002</b> are mapped as free blocks. Referring to <figref idref="DRAWINGS">FIG. 14</figref>, the flash storage device <b>1200</b> performs flash defragmentation and provides the flash defragmentation results to the host <b>1100</b>. The flash defragmentation results include an original sector number, a new sector number, and the number of sectors (# of sectors).</p>
<p id="p-0093" num="0092">The flash defragmentation results may further include updated mapping information such as changed page numbers. However, in certain embodiment where only block mapping is used, a constituent FTL may not be able to provide updated page mapping. Therefore, in such circumstances when the page order changes from a<b>1</b>, a<b>2</b>, c<b>1</b> and b<b>4</b> or b<b>2</b>, c<b>3</b>, b<b>1</b> and b<b>3</b>, the flash storage device <b>1200</b> must provide updated mapping information related to changed pages to the host <b>1100</b> through means outside the FTL. Those skilled in the art will recognize that any number of conventionally understood techniques may be used to communicate this information between the flash storage device <b>1200</b> and the host <b>110</b>. Upon receipt of such information, the host <b>1100</b> may update the file system blocks accordingly using the file system <b>1122</b>.</p>
<p id="p-0094" num="0093"><figref idref="DRAWINGS">FIG. 16</figref> illustrates a file system block structure reflecting the flash defragmentation results above. Referring to <figref idref="DRAWINGS">FIG. 16</figref>, fragments b<b>1</b>, b<b>2</b>, c<b>2</b> and b<b>3</b> are stored in a first file system block group (Group<b>1</b>) including (or indicated by) the sector numbers <b>0</b>&#x2dc;<b>31</b>. Fragments a<b>1</b>, a<b>2</b>, b<b>4</b> and c<b>1</b> are stored in a fourth file system block group (Group<b>4</b>) indicated by the sector numbers <b>96</b>&#x2dc;<b>127</b>.</p>
<p id="p-0095" num="0094"><figref idref="DRAWINGS">FIG. 17</figref> is a flow chart summarizing the internal flash defragmentation method of <figref idref="DRAWINGS">FIG. 14</figref>. When receiving a defrag command from a user, the host <b>1100</b> determines information defining the flash memory management unit (e.g., one memory block). The host <b>1100</b> analyzes file system blocks and groups the file system blocks on a memory block basis (S<b>210</b>). The host <b>1100</b> then provides a defrag command to the flash storage device <b>1200</b>. The host <b>1100</b> may provide information about a start sector and the number of sectors, together with the defrag command. The flash storage device <b>1200</b> uses a mapping table to find fragmented blocks (S<b>220</b>).</p>
<p id="p-0096" num="0095">If the number of fragmented blocks is less than a fragmented block threshold (e.g., two) (S<b>230</b>=No), the flash defragmentation operation ends. However, if the number of fragmented blocks is greater than or equal to the fragmented block threshold (S<b>230</b>=Yes), one block unit of data (e.g., including fragments a<b>1</b>, a<b>2</b>, b<b>4</b> and c<b>1</b>) is read from the flash memory <b>1210</b> and copied to a free block (e.g., <b>1211</b> in the example of <figref idref="DRAWINGS">FIG. 14</figref>) of the flash memory <b>1210</b> (S<b>240</b>). The flash storage device <b>1200</b> then erases the physical block <b>1212</b>, whose page data are all invalidated, to create a new free block. Thereafter, the FTL <b>1232</b> updates a corresponding mapping table (S<b>250</b>).</p>
<p id="p-0097" num="0096">If the number of fragmented blocks now falls below the fragmented block threshold (S<b>260</b>=Yes), the flash defragmentation operation results are provided to the host <b>1100</b> and the flash defragmentation operation ends. However, if the number of fragmented blocks remains greater than or equal to the fragmented block threshold (S<b>260</b>=No), the flash defragmentation operation continues by returning to step S<b>240</b>. In the above example, the flash defragmentation concludes by read-grouping another block unit of data including fragments b<b>1</b>, b<b>2</b>, c<b>2</b> and b<b>3</b> from the fragmented blocks.</p>
<p id="p-0098" num="0097">According to the internal flash defragmentation method of <figref idref="DRAWINGS">FIG. 17</figref>, the flash defragmentation operation is again performed for fragments on a memory block basis in response to a defrag command received from the host <b>1100</b>. However, the host <b>1100</b> need not be actively involved (e.g., issue enabling read/write commands) during the re-grouping by copying of fragments into various blocks. That is, the use of a flash defragmentation operation according to the embodiment of the inventive concept makes it possible to perform the flash defragmentation without multiple read/write data transfers between the host <b>1100</b> and the flash storage device <b>1200</b>. This reduction of data transfers during the flash defragmentation operation speeds up the operation while making efficient use the available free space in the flash memory.</p>
<p id="p-0099" num="0098">Heretofore, the flash storage device <b>1200</b> has been assumed to be a replacement within a constituent host system for a conventional memory system including a hard disk (e.g., a hard disk drive, HDD). Thus, legacy file systems and applications running on the host <b>1100</b> may continue to run on hardware platforms that replace conventional HDDs with solid state drives (SDDs) or similar memory systems operating in accordance with embodiments of the inventive concept. However, this either/or approach to the provision of a bulk data storage medium need not always be the case.</p>
<p id="p-0100" num="0099">For example, the embodiment of the inventive concept illustrated in <figref idref="DRAWINGS">FIG. 18</figref> comprises a host <b>1101</b> and a data storage device <b>1201</b>. As before, the host <b>1101</b> comprises an application <b>1121</b> running on a computational platform (not shown) in conjunction with an operating system (OS) <b>1127</b>. This combination of software functionality cooperates to control one or more device drivers <b>1123</b> (wherein the device drivers may be integrally incorporated within the OS <b>1127</b>). However, instead of generating either a HDD compatible defragmentation operation or a SDD compatible defragmentation operation, the host <b>1101</b> is configured to generate both a first type defragmentation operation used by the HDD <b>1203</b> and a second type defragmentation operation used by the SSD, or some other flash storage device consistent with embodiments of the inventive concept.</p>
<p id="p-0101" num="0100">Thus, certain hybrid host systems including both a flash storage device and a HDD may be effective defragmented. The first type defragmentation operation may be conventional in nature, and the second type defragmentation operation may be as described above.</p>
<p id="p-0102" num="0101">It will be apparent that the flash memory system <b>1000</b> according to certain embodiments of the inventive concept may be incorporated into a variety of product configurations. Ready examples of host systems incorporating embodiments of the inventive concept include computers, digital cameras, portable phones, MP3 players, PMPs, game devices, etc. The flash storage device <b>1200</b> may take the form of a flash memory-based solid state drives (SSDs), flash memory cards, flash memory modules, etc. The host <b>1100</b> and the flash storage device <b>1200</b> may be connected through one or more standardized interfaces such as ATA, SATA, PATA, USB, SCSI, ESDI, PCI Express, or IDE interfaces, and may be operated using one or more conventionally understood data communication protocols.</p>
<p id="p-0103" num="0102"><figref idref="DRAWINGS">FIG. 19</figref> illustrates one possible application (a memory card) incorporating a flash defragmentation system and/or method according to an embodiment of the inventive concept. Referring to <figref idref="DRAWINGS">FIG. 19</figref>, a memory card system <b>2000</b> includes a host <b>2100</b> and a memory card <b>2200</b>. The host <b>2100</b> includes a host controller <b>2110</b> and a host connection unit <b>2120</b>. The memory card <b>2200</b> includes a card connection unit <b>2210</b>, a card controller <b>2220</b>, and a flash memory <b>2230</b>.</p>
<p id="p-0104" num="0103">The host connection unit <b>2120</b> and the card connection unit <b>2210</b> include a plurality of pins. The pins include command pin(s) (CMD), a data pin(s) (DAT), clock pin(s) (CLK), and/or related power pins (not shown). The number of pins varies according to the type of the memory card <b>2200</b>. For example, certain contemporary examples of an SD card includes nine (9) pins.</p>
<p id="p-0105" num="0104">The host <b>2100</b> writes/reads data in/from the memory card <b>2200</b>. The host controller <b>2110</b> transmits a command (e.g., a write command), a clock signal CLK generated by an internal clock generator (not illustrated) of the host <b>2100</b>, and data (DATA) trough the host connection unit <b>2120</b> to the memory card <b>2200</b>.</p>
<p id="p-0106" num="0105">The card controller <b>2220</b> stores data in the flash memory <b>2230</b>, in synchronization with a clock signal generated by an internal clock generator (not illustrated) of the card controller <b>2200</b>, in response to a write command received through the card connection unit <b>2210</b>. The flash memory <b>2230</b> stores data received from the host <b>2100</b>. For example, if the host <b>2100</b> is a digital camera, the flash memory <b>2230</b> stores video data.</p>
<p id="p-0107" num="0106">In <figref idref="DRAWINGS">FIG. 19</figref>, the host controller <b>2110</b> may include a file system and an application supporting flash defragmentation. The card controller <b>2220</b> may use the FTL to perform flash defragmentation in the memory card <b>2200</b>. The memory card system of <figref idref="DRAWINGS">FIG. 19</figref> may support both of the host-based flash defragmentation and the memory card-based flash defragmentation.</p>
<p id="p-0108" num="0107"><figref idref="DRAWINGS">FIG. 20</figref> illustrates another possible application (a solid state drive or SSD) incorporating a flash defragmentation system and/or method according to an embodiment of the inventive concept. Referring to <figref idref="DRAWINGS">FIG. 20</figref>, an SSD system <b>3000</b> includes a host <b>3100</b> and an SSD <b>3200</b>. The SSD <b>3200</b> communicates signals (SGL) with the host <b>3100</b> through a signal connector <b>3231</b>, and receives power through a power connector <b>3221</b>. The SSD <b>3200</b> includes a plurality of nonvolatile memory devices <b>3201</b>&#x2dc;<b>320</b><i>n </i>(or NVM_<b>1</b> through NVM_n), an SSD controller <b>3210</b>, and an auxiliary power supply unit <b>3220</b>.</p>
<p id="p-0109" num="0108">The nonvolatile memory devices NVM_<b>1</b> through NVM_n are used as data storage media within the SSD <b>3200</b>. The nonvolatile memory devices NVM_<b>1</b> through NVM_n may be implemented using flash memory devices with high storage capacity. That is, in certain contemporary example, the SSD <b>3200</b> may be primarily implemented using flash memory devices.</p>
<p id="p-0110" num="0109">The nonvolatile memory devices NVM_<b>1</b> through NVM_n may be connected to the SSD controller <b>3210</b> via a plurality of channels CH<b>1</b>&#x2dc;CHn. One or more memory devices may be connected to one channel. The memory devices connected to one channel may be connected to the same data bus. In this case, flash defragmentation may be performed on the basis of a super block connecting a plurality of memory blocks, or on the basis of a super page connecting a plurality of pages.</p>
<p id="p-0111" num="0110">The SSD controller <b>3210</b> may communicate signals SGL with the host <b>3100</b> through the signal connector <b>3231</b>. Herein, the signals SGL include a command, an address, and data. The SSD controller <b>3210</b> writes/reads data in/from the corresponding memory device according to a command of the host <b>3100</b>. The internal structure of the SSD controller <b>3210</b> will be described later in detail with reference to <figref idref="DRAWINGS">FIG. 21</figref>.</p>
<p id="p-0112" num="0111">The auxiliary power supply unit <b>3220</b> is connected through the power connector <b>3221</b> to the host <b>3100</b>. The auxiliary power supply unit <b>3220</b> may receive power PWR from the host <b>3100</b> to perform a charge operation. The auxiliary power supply unit <b>3220</b> may be located in or outside the SSD <b>3200</b>. For example, the auxiliary power supply unit <b>3220</b> may be located at the main board to supply auxiliary power to the SSD <b>3200</b>.</p>
<p id="p-0113" num="0112"><figref idref="DRAWINGS">FIG. 21</figref> is a block diagram further illustrating one possible example of the SSD controller <b>3210</b> of <figref idref="DRAWINGS">FIG. 19</figref>. Referring collectively to <figref idref="DRAWINGS">FIGS. 20 and 21</figref>, the SSD controller <b>3210</b> includes a nonvolatile memory (NVM) interface (I/F) <b>3211</b>, a host interface <b>3212</b>, an error correction code (ECC) <b>3213</b>, a central processing unit (CPU) <b>3214</b>, and a buffer memory <b>3215</b>.</p>
<p id="p-0114" num="0113">The NVN interface <b>3211</b> scatters the data, received from the buffer memory <b>3215</b>, to the respective channel CH<b>1</b>&#x2dc;CHn. The NVM interface <b>3211</b> transfers the data read from the nonvolatile memory devices NVM_<b>1</b> through NVM_n to the buffer memory <b>3215</b>. Herein, the NVM interface <b>3211</b> may use an interface protocol compatible with NAND flash memory. That is, the SSD controller <b>3210</b> may perform program/read/erase operations according to an interface protocol controlling data transfer to/from a NAND flash memory.</p>
<p id="p-0115" num="0114">With continued reference to <figref idref="DRAWINGS">FIGS. 20 and 21</figref>, the host interface <b>3212</b> provides an interface with the SSD <b>3200</b> according to one or more protocol(s) compatible with the associated host <b>3100</b>. The host interface <b>3212</b> may communicate with the host <b>3100</b> via a Universal Serial Bus (USB), a Small Computer System Interface (SCSI), PCI Express, ATA, PATA (Parallel ATA), SATA (Serial ATA), or SAS (Serial Attached SCSI). Also, the host interface <b>3212</b> may perform a disk emulation function to emulate the operation of a legacy, hard disk (HDD) functionality supported by the host. In other words, operation of the host interface <b>3212</b> allows the host <b>3100</b> to functionally &#x201c;see&#x201d; a legacy HDD peripheral when the SSD <b>3200</b> is operatively connected.</p>
<p id="p-0116" num="0115">The CPU <b>3214</b> analyzes/processes signal(s) SGL received from the host <b>3100</b>. The CPU <b>3214</b> controls the host <b>3100</b> or the nonvolatile memory devices NVM_<b>1</b> through NVM_n through the host interface <b>3212</b>, or the NVM interface <b>3211</b>. The CPU <b>3214</b> may further control the operations of the nonvolatile memory devices NVM_<b>1</b> through NVM_n according to firmware driving the SSD <b>3200</b>.</p>
<p id="p-0117" num="0116">The buffer memory <b>3215</b> temporarily stores data write data received from the host <b>3100</b>, or data read from the nonvolatile memory device. Also, the buffer memory <b>3215</b> may store cache data or metadata to be stored in the nonvolatile memory devices NVM_<b>1</b> through NVM_n. In a sudden power-off operation, cache data or metadata stored in the buffer memory <b>3215</b> are stored in the nonvolatile memory devices NVM_<b>1</b> through NVM_n. The buffer memory <b>3215</b> may be implemented using DRAM and/or SRAM devices.</p>
<p id="p-0118" num="0117">The SSD system <b>3000</b> of <figref idref="DRAWINGS">FIGS. 20 and 21</figref> may support both the flash defragmentation by the host <b>3100</b> and the flash defragmentation by the SSD <b>3200</b>, as described above.</p>
<p id="p-0119" num="0118"><figref idref="DRAWINGS">FIG. 22</figref> is a block diagram illustrating yet another possible application, i.e., a digital device, capable on incorporating a flash defragmentation system and method according to an embodiment of the inventive concept. That is, the digital device comprises a flash memory module <b>4000</b>, and may take the form of a personal computer (PC), a notebook computer, a portable phone, a PDA (Personal Digital Assistant), a digital camera, etc.</p>
<p id="p-0120" num="0119">Referring to <figref idref="DRAWINGS">FIG. 22</figref> the flash memory module <b>4000</b> generally comprises a memory system <b>4100</b>, a power supply unit <b>4200</b>, an auxiliary power supply unit <b>4250</b>, a central processing unit (CPU) <b>4300</b>, a random access memory (RAM) <b>4400</b>, and a user interface <b>4500</b>. The memory system <b>4100</b> of <figref idref="DRAWINGS">FIG. 22</figref> may be implemented using a memory controller <b>4120</b> (such as the control unit <b>1230</b> of <figref idref="DRAWINGS">FIG. 2</figref>), and a flash memory <b>4110</b> (such as flash memory <b>1210</b> of <figref idref="DRAWINGS">FIG. 2</figref>). In this manner, the memory system <b>4100</b> may perform flash defragmentation by an associated host and/or flash defragmentation by the flash memory module <b>4000</b>.</p>
<p id="p-0121" num="0120">As described above, certain embodiments of the inventive concept are configured to perform flash defragmentation on a flash memory management unit basis, thereby making it possible to reduce the number of data transfers associated with the defragmentation process, and yet efficiently making use of free space within a flash memory. Contemporary flash memory has been assumed in the foregoing examples for purposes of clarity. However, the inventive concept is not limited to only flash type memories, but may be readily adapted by those skilled in the art to other forms of nonvolatile memory.</p>
<p id="p-0122" num="0121">The above-disclosed subject matter is to be considered illustrative and not restrictive, and the appended claims are intended to cover all such modifications, enhancements, and other embodiments, which fall within the scope of the inventive concept. Thus, to the maximum extent allowed by law, the scope of the inventive concept is to be determined by the broadest permissible interpretation of the following claims and their equivalents, and shall not be restricted or limited by the foregoing detailed description.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method of defragmenting a flash memory operated under the control of a host, the flash memory being arranged in a plurality of blocks including a free block and a plurality of fragmented blocks respectively storing at least one fragment, the method comprising:
<claim-text>identifying a plurality of fragments stored in the plurality of fragmented blocks according to corresponding logical addresses;</claim-text>
<claim-text>converting the logical addresses to corresponding physical addresses using a flash translation layer (FTL);</claim-text>
<claim-text>using the physical addresses, reading a subset of fragments in the plurality of fragments from at least one of the plurality of fragmented blocks;</claim-text>
<claim-text>grouping the subset of fragments in a defragmentation region having a size defined by a flash management unit in response to a defragmentation command by the host;</claim-text>
<claim-text>writing the grouped subset of fragments to the free block,</claim-text>
<claim-text>wherein the reading and the grouping of the subset of fragments are performed regardless of an arrangement order of the plurality of fragments as stored in the flash memory; and</claim-text>
<claim-text>setting the defragmentation region according to a defragmentation size, a defragmentation start sector and a number of sectors provided by the host.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the flash management unit is equal in size to a single block in the plurality of blocks.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the logical addresses are defined by sector addresses compatible with a data storage method used with a hard disk drive (HDD).</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>creating at least one new free block from at least one of the fragmented blocks following writing of the grouped subset of fragments to the free block.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the converting of the logical addresses into the corresponding physical addresses using the FTL is performed with reference to a mapping table managed by the FTL, the method further comprising:
<claim-text>updating the mapping table following writing of the grouped subset of fragments to the free block; and</claim-text>
<claim-text>updating the mapping table following creation of the new free block.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the host comprises an application and a file system, and the method further comprises:
<claim-text>by operation of the application and the file system, defining systems files in relation to the logical addresses, and</claim-text>
<claim-text>updating the file system following each updating of the mapping table.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref>, further comprising:
<claim-text>by operation of the file system, identifying a number of fragmented blocks;</claim-text>
<claim-text>comparing the number of fragmented blocks to a fragmented block threshold; and</claim-text>
<claim-text>only if the number of fragmented blocks exceeds the fragmented block threshold, executing the method of defragmenting the flash memory.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, further comprising after the updating the system files:
<claim-text>identifying an updated number of fragmented blocks;</claim-text>
<claim-text>comparing the updated number of fragmented blocks to the fragmented block threshold; and</claim-text>
<claim-text>if the updated number of fragmented blocks still exceeds the fragmented block threshold, continue execution of the method of defragmenting the flash memory, or if the updated number of fragmented blocks does not exceed the fragmented block threshold, ending the method of defragmenting the flash memory.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the host further comprises a host memory used as the grouping memory.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. A method of defragmenting a flash memory, the flash memory being arranged in a plurality of blocks including a free block and a plurality of fragmented blocks storing a plurality of fragments, and the method comprising:
<claim-text>managing a mapping table correlating externally applied logical addresses with physical addresses for the flash memory using a flash translation layer (FTL);</claim-text>
<claim-text>identifying the plurality of fragmented blocks and a plurality of fragments stored in the plurality of fragmented blocks;</claim-text>
<claim-text>reading a subset of fragments in a defragmentation region among the plurality of fragments without regard to an arrangement order of the plurality of fragments as stored in the fragmented blocks in response to a defragmentation command by a host, and writing the subset of fragments in the free block; and</claim-text>
<claim-text>setting the defragmentation region according to a defragmentation size, a defragmentation start sector and a number of sectors provided by the host.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, further comprising:
<claim-text>updating the mapping table following the writing of the subset of fragments in the free block.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, further comprising:
<claim-text>performing a data invalidity operation on one of the fragmented blocks from which at least one fragment was read during the flash defragmentation operation to thereby convert the one fragmented memory block to a new free block.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method of <claim-ref idref="CLM-00012">claim 12</claim-ref>, further comprising:
<claim-text>updating the mapping table following the data invalidity operation.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the logical addresses are defined by sector addresses compatible with a data storage method used with a hard disk drive (HDD).</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the identifying of the plurality of fragmented blocks and the plurality of fragments stored in the plurality of fragmented blocks is performed with reference to the mapping table. </claim-text>
</claim>
</claims>
</us-patent-grant>
