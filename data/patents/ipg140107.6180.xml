<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627304-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627304</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12510272</doc-number>
<date>20090728</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>1035</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>45</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>717160</main-classification>
<further-classification>717151</further-classification>
</classification-national>
<invention-title id="d2e53">Vectorization of program code</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6192515</doc-number>
<kind>B1</kind>
<name>Doshi et al.</name>
<date>20010200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6363470</doc-number>
<kind>B1</kind>
<name>Laurenti et al.</name>
<date>20020300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>7237229</doc-number>
<kind>B2</kind>
<name>Ogawa et al.</name>
<date>20070600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>7386842</doc-number>
<kind>B2</kind>
<name>Eichenberger et al.</name>
<date>20080600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717150</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>7415601</doc-number>
<kind>B2</kind>
<name>May et al.</name>
<date>20080800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2004/0003381</doc-number>
<kind>A1</kind>
<name>Suzuki et al.</name>
<date>20040100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717150</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2008/0052693</doc-number>
<kind>A1</kind>
<name>Archambault et al.</name>
<date>20080200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717151</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2008/0307402</doc-number>
<kind>A1</kind>
<name>Eichenberger et al.</name>
<date>20081200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>EP</country>
<doc-number>1115059</doc-number>
<kind>A2</kind>
<date>20010700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00010">
<othercit>Fusion Utilities http://www-rocq.inria.fr/&#x2dc;pop/doc/lno/fusion.txt.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00011">
<othercit>Fellahi et al., &#x201c;Software Pipelining in Nested Loops With Prolog-Epilog Merging&#x201d;, 2009 http://www.springerlink.com/content/y26423776t2r88v1/.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00012">
<othercit>Rade Kutil, A Single-Loop Approach to SIMD Parallelization of 2D Wavelet Lifting, IEE, 2006 http://ieeexplore.ieee.org/Xplore/login.jsp?url=/ielx5/10741/33865/01613303.pdf?arnumber=1613303.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00013">
<othercit>A. Eichenberger et al., &#x201c;Vectorization for SIMD Architectures With Alignment Constraints&#x201d;, http://portal.acm.org/citation.cfm?id=996853&#x26;dl=GUIDE&#x26;coll=GUIDE&#x26;CFID=23248689&#x26;CFTOKEN=66409807.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00014">
<othercit>Hoseok Chang, Wonyong Sung, &#x201c;Efficient vectorization of SIMD programs with non-aligned and irregular data access hardware&#x201d;, CASES 2008.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00015">
<othercit>M. Alvarez et al., &#x201c;Performance Impact of Unaligned Memory Operations in SIMD Extensions for Video Codec Applications&#x201d;, ISPASS 2007.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>12</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>717160</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>12</number-of-drawing-sheets>
<number-of-figures>12</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20110029962</doc-number>
<kind>A1</kind>
<date>20110203</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Nuzman</last-name>
<first-name>Dorit</first-name>
<address>
<city>Haifa</city>
<country>IL</country>
</address>
</addressbook>
<residence>
<country>IL</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Rosen</last-name>
<first-name>Ira</first-name>
<address>
<city>Haifa</city>
<country>IL</country>
</address>
</addressbook>
<residence>
<country>IL</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Zaks</last-name>
<first-name>Ayal</first-name>
<address>
<city>Haifa</city>
<country>IL</country>
</address>
</addressbook>
<residence>
<country>IL</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Nuzman</last-name>
<first-name>Dorit</first-name>
<address>
<city>Haifa</city>
<country>IL</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Rosen</last-name>
<first-name>Ira</first-name>
<address>
<city>Haifa</city>
<country>IL</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Zaks</last-name>
<first-name>Ayal</first-name>
<address>
<city>Haifa</city>
<country>IL</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<last-name>Far-hadion</last-name>
<first-name>F. Jason</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<orgname>Century IP Group</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Tsai</last-name>
<first-name>Henry</first-name>
<department>2184</department>
</primary-examiner>
<assistant-examiner>
<last-name>Roche</last-name>
<first-name>John</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A method for vectorization of a block of code is provided. The method comprises receiving a first block of code as input; and converting the first block of code into at least a second block of code and a third block of code. The first block of code accesses a first set of memory addresses that are potentially misaligned. The second block of code performs conditional leaping address incrementation to selectively access a first subset of the first set of memory addresses. The third block of code accesses a second subset of the first set of memory addresses starting from an aligned memory address, simultaneously accessing multiple memory addresses at a time. No memory address belongs to both the first subset and the second subset of memory addresses.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="50.80mm" wi="157.65mm" file="US08627304-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="157.56mm" wi="62.31mm" orientation="landscape" file="US08627304-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="185.08mm" wi="151.30mm" file="US08627304-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="163.07mm" wi="114.22mm" orientation="landscape" file="US08627304-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="161.80mm" wi="95.17mm" orientation="landscape" file="US08627304-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="163.41mm" wi="78.49mm" orientation="landscape" file="US08627304-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="164.34mm" wi="103.04mm" orientation="landscape" file="US08627304-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="167.30mm" wi="101.68mm" orientation="landscape" file="US08627304-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="168.66mm" wi="128.61mm" orientation="landscape" file="US08627304-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="165.78mm" wi="128.95mm" orientation="landscape" file="US08627304-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="133.86mm" wi="110.66mm" file="US08627304-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="100.41mm" wi="151.21mm" file="US08627304-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="92.20mm" wi="119.13mm" file="US08627304-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">COPYRIGHT &#x26; TRADEMARK NOTICES</heading>
<p id="p-0002" num="0001">A portion of the disclosure of this patent document contains material, which is subject to copyright protection. The owner has no objection to the facsimile reproduction by any one of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyrights whatsoever.</p>
<p id="p-0003" num="0002">Certain marks referenced herein may be common law or registered trademarks of third parties affiliated or unaffiliated with the applicant or the assignee. Use of these marks is for providing an enabling disclosure by way of example and shall not be construed to limit the scope of the claimed subject matter to material associated with such marks.</p>
<heading id="h-0002" level="1">TECHNICAL FIELD</heading>
<p id="p-0004" num="0003">The claimed subject matter relates generally to optimizing code in a computer program, and, more particularly, to vectorization of program code.</p>
<p id="p-0005" num="0004">Vectorization refers to converting a program loop into vector format to maximize parallel execution of the same instruction on multiple data elements according to a vectorization factor (VF). VF refers to the number of data elements that a computing system is able to access simultaneously.</p>
<p id="p-0006" num="0005">Referring to exemplary code <b>1</b> provided below, an exemplary program loop L<b>0</b> comprises code for performing an addition operation on N data elements in &#x3b1;, one data element per iteration. Vectorization converts the program loop L<b>0</b> into exemplary vector loop L<b>1</b> and exemplary epilogue loop L<b>2</b>. Vector loop L<b>1</b> iterates through the data elements of &#x3b1;, VF elements per iteration, until fewer than VF data elements remain. Epilogue loop L<b>2</b> iterates through the remaining data elements of &#x3b1;, one data element per iteration.</p>
<p id="p-0007" num="0006">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>EXEMPLARY CODE 1:</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>L0: &#x2003;for (i=0; i&#x3c;N; i++) {</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;a[i] = a[i] + b[i];</entry>
</row>
<row>
<entry/>
<entry>&#x2002;&#x2003;&#x2003;&#x2009;}</entry>
</row>
<row>
<entry/>
<entry>L1: &#x2003;for (i=0; i&#x3c;(N&#x2212;VF+1); i+=VF) {</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;a[i:i+VF] = a[i:i+VF] + b[i:i+VF];</entry>
</row>
<row>
<entry/>
<entry>&#x2002;&#x2003;&#x2003;&#x2009;}</entry>
</row>
<row>
<entry/>
<entry>L2: &#x2003;for ( ; i&#x3c;N; i++) {</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;a[i] = a[i] + b[i];</entry>
</row>
<row>
<entry/>
<entry>&#x2002;&#x2003;&#x2009;&#x2003;}</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<heading id="h-0003" level="1">SUMMARY</heading>
<p id="p-0008" num="0007">The present disclosure is directed to systems and corresponding methods that facilitate efficient vectorization of program code.</p>
<p id="p-0009" num="0008">For purposes of summarizing, certain aspects, advantages, and novel features have been described herein. It is to be understood that not all such advantages may be achieved in accordance with any one particular embodiment. Thus, the claimed subject matter may be embodied or carried out in a manner that achieves or optimizes one advantage or group of advantages without achieving all advantages as may be taught or suggested herein.</p>
<p id="p-0010" num="0009">In accordance with one embodiment, a method for vectorization of a block of code is provided. The method comprises receiving a first block of code as input; and converting the first block of code into at least a second block of code and a third block of code. The first block of code accesses a first set of memory addresses that are potentially misaligned. The second block of code performs conditional leaping address incrementation to selectively access a first subset of the first set of memory addresses. The third block of code accesses a second subset of the first set of memory addresses starting from an aligned memory address, simultaneously accessing multiple memory addresses at a time. No memory address belongs to both the first subset and the second subset of memory addresses.</p>
<p id="p-0011" num="0010">A processor in operational relationship with a general purpose computing machine for executing logic code, wherein the execution of the logic code causes the general purpose computing machine to receive a first block of code as input; and convert the first block of code into at least a second block of code and a third block of code, wherein the first block of code accesses a first set of memory addresses that are potentially misaligned, wherein the second block of code performs conditional leaping address incrementation to selectively access a first subset of the first set of memory addresses, wherein the third block of code accesses a second subset of the first set of memory addresses starting from an aligned memory address, simultaneously accessing multiple memory addresses at a time, wherein no memory address belongs to both the first subset and the second subset of memory addresses.</p>
<p id="p-0012" num="0011">In accordance with another embodiment, a system comprising one or more logic units is provided. The one or more logic units are configured to perform the functions and operations associated with the above-disclosed methods. In accordance with yet another embodiment, a computer program product comprising a computer useable medium having a computer readable program is provided. The computer readable program when executed on a computer causes the computer to perform the functions and operations associated with the above-disclosed methods.</p>
<p id="p-0013" num="0012">One or more of the above-disclosed embodiments in addition to certain alternatives are provided in further detail below with reference to the attached figures. The claimed subject matter is not, however, limited to any particular embodiment disclosed.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0014" num="0013">Embodiments of the claimed subject matter are understood by referring to the figures in the attached drawings, as provided below.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 1</figref> illustrates an exemplary computing environment, in accordance with one or more embodiments.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 2</figref> is a flow diagram of a method for vectorization of a program loop, in accordance with one embodiment.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIGS. 3A through 3D</figref> illustrate vectorization of an exemplary program loop that accesses memory addresses with a single potential independent misalignment, in accordance with one embodiment.</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIGS. 4A and 4B</figref> illustrate vectorization of an exemplary program loop that accesses memory addresses with multiple potential independent misalignments, in accordance with one embodiment.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 5</figref> illustrates vectorization of a non-loop sequence of statements, in accordance with one embodiment.</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 6</figref> is a flow diagram of a method for performing conditional leaping address incrementation, in accordance with one embodiment.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIGS. 7 and 8</figref> are block diagrams of hardware and software environments in which a system of the present invention may operate, in accordance with one or more embodiments.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<p id="p-0022" num="0021">Features, elements, and aspects that are referenced by the same numerals in different figures represent the same, equivalent, or similar features, elements, or aspects, in accordance with one or more embodiments.</p>
<heading id="h-0005" level="1">DETAILED DESCRIPTION OF EXEMPLARY EMBODIMENTS</heading>
<p id="p-0023" num="0022">In the following, numerous specific details are set forth to provide a thorough description of various embodiments of the claimed subject matter. Certain embodiments may be practiced without these specific details or with some variations in detail. In some instances, certain features are described in less detail so as not to obscure other aspects of the disclosed embodiments. The level of detail associated with each of the elements or features should not be construed to qualify the novelty or importance of one feature over the others.</p>
<p id="p-0024" num="0023">Referring to <figref idref="DRAWINGS">FIG. 1</figref>, in accordance with one or more embodiments, an exemplary computing environment <b>100</b> may comprise a compiler <b>110</b> and one or more processors <b>120</b>. The compiler <b>110</b> may convert, or compile, the source code of a computer program into code that is executable by the processors <b>120</b>. The compiler <b>110</b> may also optimize the code to increase system performance.</p>
<p id="p-0025" num="0024">Optimizations may include vectorization of a program loop in the code. Vectorization refers to converting a program loop into vector format to maximize parallel execution of the same instruction on multiple data elements according to a vectorization factor (VF). VF refers to the number of data elements that the processors <b>120</b> are able to access simultaneously. In certain scenarios, vectorization may be utilized to reduce code size.</p>
<p id="p-0026" num="0025">In one embodiment, the processors <b>120</b> may comprise one or more single instruction multiple data (SIMD) units (not shown). The SIMD units may support fixed-size vector registers, which in turn may impose alignment constraints on memory addresses according to vector size (VS). VS is equal to the product of VF and the size of a data element (i.e., size of a vector register). Thus, a memory address is aligned, if the memory address is a multiple of VS.</p>
<p id="p-0027" num="0026">Referring to <figref idref="DRAWINGS">FIGS. 1 and 2</figref>, in accordance with one embodiment, the compiler <b>110</b> converts a program loop with a known number of iterations (i.e., loop count) into a vector loop (P<b>200</b>). A vector loop refers to a loop that simultaneously accesses multiple memory addresses per iteration. For example, during each iteration, a vector loop may store data into or load data from a set of vector registers supported by SIMD units.</p>
<p id="p-0028" num="0027">If there is a potential misalignment of the memory addresses accessed by the vector loop (P<b>210</b>), the compiler <b>110</b> generates prologue and epilogue loops and inserts the loops before and after the vector loop, respectively. (P<b>220</b>). A prologue loop refers to a loop that accesses memory addresses prior to the vector loop in order to align the memory addresses accessed by the vector loop. An epilogue loop refers to a loop that accesses memory addresses remaining after a vector loop is completed.</p>
<p id="p-0029" num="0028">Referring to <figref idref="DRAWINGS">FIG. 3A</figref>, for example, a program loop L<b>0</b> with a loop count of N is converted into a prologue loop L<b>1</b>, a vector loop L<b>2</b>, and an epilogue loop L<b>3</b> with loops counts N<b>1</b>, N<b>2</b>, and N<b>3</b>, respectively. Assume for now that N is known and divisible by VF, but that the alignment of p is unknown at compile time. The loop index so far is indicated by i. The prologue loop L<b>1</b> performs N<b>1</b> iterations starting from i=0, accessing memory addresses (i.e., *p++=0) until an aligned memory address is reached (i.e., p&#x26;(VS&#x2212;1)==0). N<b>1</b> is less than VF, but the exact value is unknown because the amount of the misalignment is unknown at compile time.</p>
<p id="p-0030" num="0029">In this example, upon reaching the aligned memory address, the vector loop L<b>2</b> performs N<b>2</b> iterations, accessing VF memory addresses at a time (i.e., *p[0:VF&#x2212;1]={0, . . . , 0}) until i is greater than or equal to N&#x2212;VF+1. If N<b>1</b> is equal to zero, N<b>2</b> is equal to N/VF, for example. If N<b>1</b> is more than zero, N<b>2</b> is equal to N/VF&#x2212;1, for example. The value of N<b>2</b> may therefore depend on N<b>1</b>, which is unknown. Once the vector loop L<b>2</b> is finished, the epilogue loop L<b>3</b> performs N<b>3</b> iterations, accessing memory addresses until i is equal to N. If N<b>1</b> is equal to zero, N<b>3</b> is also equal to zero, for example, when N is divisible by VF. If N<b>1</b> is more than zero, N<b>3</b> is equal to VF&#x2212;N<b>1</b>, for example. Since N<b>2</b> and N<b>3</b> depend on N<b>1</b>, N<b>2</b> and N<b>3</b> are also unknown.</p>
<p id="p-0031" num="0030">Referring back to <figref idref="DRAWINGS">FIGS. 1 and 2</figref>, since the compiler <b>110</b> may not be able to perform further optimizations on loops with unknown loop counts, it is desirable to maximize the number of loops with known loop counts. Accordingly, upon inserting the prologue loop, the compiler <b>110</b> re-orders the prologue, vector, or epilogue loops to facilitate merging of the prologue and epilogue loops (P<b>230</b>). In <figref idref="DRAWINGS">FIG. 3B</figref>, for example, epilogue loop L<b>3</b> is desirably placed immediately after prologue loop L<b>1</b>. It is possible to re-order the loops because the program loop is vectorizable. A loop with a loop count of N is vectorizable if there are no cross-iteration dependences whose distance is more than N or if such dependences may be broken.</p>
<p id="p-0032" num="0031">Once the loops are re-ordered, the compiler <b>110</b> merges the prologue and epilogue loops into a selective loop that accesses the same memory addresses as the prologue and epilogue loops without accessing the same memory addresses as the vector loop, using conditional leaping address incrementation (P<b>240</b>). The selective loop has a known loop count that is equal to VF, for example. Since the loop count of the vector loop is dependent on the loop count of the selective loop, the loop count of the vector loop is also known.</p>
<p id="p-0033" num="0032">Referring to <figref idref="DRAWINGS">FIG. 3C</figref>, for example, prologue loop L<b>1</b> is merged with epilogue loop L<b>3</b> to generate selective loop L<b>13</b>. Loop L<b>13</b> performs N<b>1</b> iterations starting from i=0. Upon performing N<b>1</b> iterations (i.e., reaching an aligned memory address), loop L<b>13</b> leaps over the memory addresses accessed by vector loop L<b>2</b> (i.e., p=(p&#x26;(VS&#x2212;1)==0?p+S:p)) and performs N<b>3</b> iterations. The total loop count for loop L<b>13</b> is equal to N<b>1</b>+N<b>3</b>, which is equal to VF. Since there are a total of N iterations, N<b>2</b> is equal to N&#x2212;VF. Thus, both the loop count of loop L<b>13</b> and vector loop L<b>2</b> are known.</p>
<p id="p-0034" num="0033">Referring back to <figref idref="DRAWINGS">FIGS. 1 and 2</figref>, if the program loop has a loop count that is not evenly divisible by VF (P<b>250</b>), the compiler <b>110</b> generates and inserts a loop for leftover iterations (P<b>260</b>). Depending on implementation, the leftover loop may be inserted in different locations (e.g., before or after the vector loop). Alternatively, the leftover loop may be merged with the selective loop, if the conditional leaping address incrementation is performed once. Referring to <figref idref="DRAWINGS">FIG. 3D</figref>, for example, leftover loop LL is similar to the merged loop but does not include the conditional leaping address incrementation sequence. Leftover loop LL performs M (i.e., N mod VF) iterations and thus has a known loop count N.</p>
<p id="p-0035" num="0034">It should be understood that the processes provided above are not limited to vectorization of a program loop with a known loop count, but may also be applicable to vectorization of a program loop with an unknown loop count. In <figref idref="DRAWINGS">FIG. 3D</figref>, for example, if N is unknown but M is known, merged loop L<b>13</b> and leftover loop LL have known loop counts but vector loop L<b>2</b> has an unknown loop count. If both N and M are unknown, selective loop L<b>13</b> still has a known loop count, but leftover loop LL and vector loop L<b>2</b> have unknown loop counts. The above processes may also be applicable to vectorization of a scalar program loop or a program loop comprising nested loops.</p>
<p id="p-0036" num="0035">Additionally, one or more of above processes may be applicable to a program loop that accesses memory addresses with multiple potential misalignments, such that each potential misalignment is mutually independent or has a dependence distance of at least 2*VF. In such a scenario, the compiler <b>110</b> directly converts the program loop into the selective loop and the vector loop. In an exemplary embodiment, it may not be possible to generate the prologue loop, if there is more than a single potential independent misalignment.</p>
<p id="p-0037" num="0036">In <figref idref="DRAWINGS">FIG. 4A</figref>, for example, program loop L<b>0</b>, which has a loop count N that is evenly divisible by VF, is converted into selective loop L<b>13</b> and vector loop L<b>2</b>. Selective loop L<b>13</b> comprises a conditional leaping increment sequence for each potential independent misalignment. Referring to <figref idref="DRAWINGS">FIG. 4B</figref>, for example, program loop L<b>0</b>, which has a loop count N that is not evenly divisible by VF, is converted into selective loop L<b>13</b>, leftover loop LL, and vector loop L<b>2</b>. Leftover loop LL is similar to selective loop L<b>13</b>, but does not include the conditional leaping increment sequences.</p>
<p id="p-0038" num="0037">It is also noteworthy that one or more of the processes provided above may be applicable to a non-loop sequence of statements (e.g., straight-line code, Basic block, or SLP). In such a scenario, the number of statements in the non-loop sequence may be equivalent to the loop count, for example. As illustrated in <figref idref="DRAWINGS">FIG. 5</figref>, program sequence S<b>0</b> may be converted to selective sequence S<b>13</b> and vector sequence S<b>2</b> in an exemplary implementation.</p>
<p id="p-0039" num="0038">Referring to <figref idref="DRAWINGS">FIG. 6</figref>, in accordance with one embodiment, conditional leaping address incrementation is performed by incrementing a memory address by a single element (e.g., 4 bytes) (P<b>600</b>) and determining whether the memory address is aligned (P<b>610</b>). If the memory address is aligned, the memory address is incremented by the total number of bytes accessed by the vector loop (i.e., VS*loop count of the vector loop) (P<b>620</b>).</p>
<p id="p-0040" num="0039">In one implementation, for example, conditional leaping address incrementation may be performed by the sequence p++; p=(p is aligned?p+S:p), where p is the memory address and S is the total number of bytes accessed by the vector loop. Unfortunately, such a sequence may incur runtime overhead. This problem may be avoided by providing support for performing conditional leaping address incrementation in one instruction.</p>
<p id="p-0041" num="0040">For example, in one implementation, conditional leaping address incrementation may be performed by implementing a triplet structure having first, second and third values (e.g., {Index, Start, End}), where each subsequent increment Index++ determines if Index has reached End, and, if so, resets Index to Start. In such a scenario, End refers to the address accessed by the first iteration of the vector loop, and Start (usually greater than End) refers to the address accessed by the first iteration of the epilogue loop. In another implementation, the amount of misalignment and the total number of bytes accessed by the vector loop may be provided. In yet another implementation, conditional leaping address incrementation may be implemented within a store or load instruction. It is noteworthy that many architectures already provide partial support for conditional leaping address incrementation (e.g., with a select instruction).</p>
<p id="p-0042" num="0041">In different embodiments, the claimed subject matter may be implemented either entirely in the form of hardware or entirely in the form of software, or a combination of both hardware and software elements. Referring to <figref idref="DRAWINGS">FIG. 1</figref>, for example, computing environment <b>100</b> may comprise a controlled computing system environment that may be presented largely in terms of hardware components and software code executed to perform processes that achieve the results contemplated by the system of the claimed subject matter.</p>
<p id="p-0043" num="0042">Referring to <figref idref="DRAWINGS">FIGS. 1</figref>, <b>7</b>, and <b>8</b>, a computing system environment in accordance with an exemplary embodiment is composed of a hardware environment <b>1110</b> and a software environment <b>1120</b>. The hardware environment <b>1110</b> comprises the machinery and equipment that provide an execution environment for the software; and the software environment <b>1120</b> provides the execution instructions for the hardware as provided below.</p>
<p id="p-0044" num="0043">As provided here, software elements that are executed on the illustrated hardware elements are described in terms of specific logical/functional relationships. It should be noted, however, that the respective methods implemented in software may be also implemented in hardware by way of configured and programmed processors, ASICs (application specific integrated circuits), FPGAs (Field Programmable Gate Arrays) and DSPs (digital signal processors), for example.</p>
<p id="p-0045" num="0044">Software environment <b>1120</b> is divided into two major classes comprising system software <b>1121</b> and application software <b>1122</b>. In one embodiment, compiler <b>110</b> may be implemented as system software <b>1121</b> or application software <b>1122</b> executed on one or more hardware environments to perform vectorization of a program loop.</p>
<p id="p-0046" num="0045">System software <b>1121</b> may comprise control programs, such as the operating system (OS) and information management systems that instruct the hardware how to function and process information. Application software <b>1122</b> may comprise but is not limited to program code, data structures, firmware, resident software, microcode or any other form of information or routine that may be read, analyzed or executed by a processor.</p>
<p id="p-0047" num="0046">In an alternative embodiment, the claimed subject matter may be implemented as computer program product accessible from a computer-usable or computer-readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description, a computer-usable or computer-readable medium may be any apparatus that can contain, store, communicate, propagate or transport the program for use by or in connection with the instruction execution system, apparatus or device.</p>
<p id="p-0048" num="0047">The computer-readable medium may be an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system (or apparatus or device) or a propagation medium. Examples of a computer-readable medium include a semiconductor or solid-state memory, magnetic tape, a removable computer diskette, a random access memory (RAM), a read-only memory (ROM), a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory (CD-ROM), compact disk read/write (CD-R/W) and digital video disk (DVD).</p>
<p id="p-0049" num="0048">Referring to <figref idref="DRAWINGS">FIG. 7</figref>, an embodiment of the application software <b>1122</b> may be implemented as computer software in the form of computer readable code executed on a data processing system such as hardware environment <b>1110</b> that comprises a processor <b>1101</b> coupled to one or more memory elements by way of a system bus <b>1100</b>. The memory elements, for example, may comprise local memory <b>1102</b>, storage media <b>1106</b>, and cache memory <b>1104</b>. Processor <b>1101</b> loads executable code from storage media <b>1106</b> to local memory <b>1102</b>. Cache memory <b>1104</b> provides temporary storage to reduce the number of times code is loaded from storage media <b>1106</b> for execution.</p>
<p id="p-0050" num="0049">A user interface device <b>1105</b> (e.g., keyboard, pointing device, etc.) and a display screen <b>1107</b> can be coupled to the computing system either directly or through an intervening I/O controller <b>1103</b>, for example. A communication interface unit <b>1108</b>, such as a network adapter, may be also coupled to the computing system to enable the data processing system to communicate with other data processing systems or remote printers or storage devices through intervening private or public networks. Wired or wireless modems and Ethernet cards are a few of the exemplary types of network adapters.</p>
<p id="p-0051" num="0050">In one or more embodiments, hardware environment <b>1110</b> may not include all the above components, or may comprise other components for additional functionality or utility. For example, hardware environment <b>1110</b> can be a laptop computer or other portable computing device embodied in an embedded system such as a set-top box, a personal data assistant (PDA), a mobile communication unit (e.g., a wireless phone), or other similar hardware platforms that have information processing and/or data storage and communication capabilities.</p>
<p id="p-0052" num="0051">In some embodiments of the system, communication interface <b>1108</b> communicates with other systems by sending and receiving electrical, electromagnetic or optical signals that carry digital data streams representing various types of information including program code. The communication may be established by way of a remote network (e.g., the Internet), or alternatively by way of transmission over a carrier wave.</p>
<p id="p-0053" num="0052">Referring to <figref idref="DRAWINGS">FIG. 8</figref>, application software <b>1122</b> may comprise one or more computer programs that are executed on top of system software <b>1121</b> after being loaded from storage media <b>1106</b> into local memory <b>1102</b>. In a client-server architecture, application software <b>1122</b> may comprise client software and server software. For example, in one embodiment, client software is executed on a personal computing system (not shown) and server software is executed on a server system (not shown).</p>
<p id="p-0054" num="0053">Software environment <b>1120</b> may also comprise browser software <b>1126</b> for accessing data available over local or remote computing networks. Further, software environment <b>1120</b> may comprise a user interface <b>1124</b> (e.g., a Graphical User Interface (GUI)) for receiving user commands and data. Please note that the hardware and software architectures and environments described above are for purposes of example, and one or more embodiments of the invention may be implemented over any type of system architecture or processing environment.</p>
<p id="p-0055" num="0054">It should also be understood that the logic code, programs, modules, processes, methods and the order in which the respective processes of each method are performed are purely exemplary. Depending on implementation, the processes can be performed in any order or in parallel, unless indicated otherwise in the present disclosure. Further, the logic code is not related, or limited to any particular programming language, and may comprise of one or more modules that execute on one or more processors in a distributed, non-distributed or multiprocessing environment.</p>
<p id="p-0056" num="0055">The claimed subject matter has been described above with reference to one or more features or embodiments. Those skilled in the art will recognize, however, that changes and modifications may be made to these embodiments without departing from the scope of the claimed subject matter. These and various other adaptations and combinations of the embodiments disclosed are within the scope of the claimed subject matter as defined by the claims and their full scope of equivalents.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A processor in operational relationship with a general purpose computing machine for executing logic code, wherein the execution of the logic code causes the general purpose computing machine to:
<claim-text>receive a first block of code as input, the first block of code including a program loop, wherein the program loop accesses one or more sets of memory addresses and at least one set of memory addresses is associated with a potential independent misalignment;</claim-text>
<claim-text>convert the program loop into prologue, vector and epilogue loops,</claim-text>
<claim-text>re-order the prologue, vector, or epilogue loops to facilitate merging of the prologue and epilogue loops; and</claim-text>
<claim-text>merge the prologue and epilogue loops into a selective loop that performs conditional leaping address incrementation so that the vector loop accesses memory addresses that are aligned,</claim-text>
<claim-text>wherein the conditional leaping address incrementation comprises:
<claim-text>implementing a triplet structure having first, second and third values, wherein the first value is an index value, the second value refers to an address accessed by the first iteration of the epilogue loop, and the third value refers to a memory address accessed by the first iteration of the vector loop;</claim-text>
<claim-text>incrementing a memory address in a first subset of memory addresses by incrementing the first value;</claim-text>
<claim-text>determining whether the memory address is aligned by comparing the first value to the third value; and</claim-text>
<claim-text>incrementing the memory address by a number of memory addresses in a second subset of memory addresses by resetting the first value to the second value, in response to determining that the memory address is aligned,</claim-text>
<claim-text>wherein for the selective loop, the number of iterations during execution of the selective loop is known at compile-time, such that number of loops whose number of iterations will remain a compile-time-known-constant is maximized, and</claim-text>
<claim-text>wherein the number of iterations during execution of the prologue loop and the epilogue loop is unknown.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the prologue loop accesses the memory addresses until reaching an aligned memory address.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the conditional leaping address incrementation is implemented in a single instruction to reduce runtime overhead.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein if it is determined that the index value has reached a threshold defined based on the third value, the index value is reset to the second value.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. A method for vectorization of a block of code, the method comprising:
<claim-text>receiving a first block of code as input, the first block of code including a program loop, wherein the program loop accesses one or more sets of memory addresses and at least one set of memory addresses is associated with a potential independent misalignment;</claim-text>
<claim-text>converting the program loop into prologue, vector and epilogue loops;</claim-text>
<claim-text>re-ordering the prologue, vector, or epilogue loops to facilitate merging of the prologue and epilogue loops;</claim-text>
<claim-text>merging the prologue and epilogue loops into a selective loop that performs conditional leaping address incrementation so that the vector loop accesses memory addresses that are aligned;</claim-text>
<claim-text>implementing a triplet structure having first, second and third values, wherein the first value is an index value, the second value refers to an address accessed by the first iteration of the epilogue loop, and the third value refers to a memory address accessed by the first iteration of the vector loop;</claim-text>
<claim-text>incrementing a memory address in a first subset of memory addresses by incrementing the first value;</claim-text>
<claim-text>determining whether the memory address is aligned by comparing the first value to the third value; and</claim-text>
<claim-text>incrementing the memory address by a number of memory addresses in a second subset of memory addresses by resetting the first value to the second value, in response to determining that the memory address is aligned,</claim-text>
<claim-text>wherein for the selective loop, the number of iterations during execution of the selective loop is known at compile-time, such that number of loops whose number of iterations will remain a compile-time-known-constant is maximized, and</claim-text>
<claim-text>wherein the number of iterations during execution of the prologue loop and the epilogue loop is unknown.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the prologue loop accesses the memory addresses until reaching an aligned memory address.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the conditional leaping address incrementation is implemented in a single instruction to reduce runtime overhead.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein if it is determined that the index value has reached a threshold defined based on the third value, the index value is reset to the second value.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. A system for vectorization of a block of code, the system comprising:
<claim-text>a logic unit for receiving a first block of code as input, the first block of code including a program loop, wherein the program loop accesses one or more sets of memory addresses and at least one set of memory addresses is associated with a potential independent misalignment;</claim-text>
<claim-text>a logic unit for converting the program loop into prologue, vector and epilogue loops; a logic unit for re-ordering the prologue, vector, or epilogue loops to facilitate merging of the prologue and epilogue loops; and</claim-text>
<claim-text>a logic unit for merging the prologue and epilogue loops into a selective loop that performs conditional leaping address incrementation so that the vector loop accesses memory addresses that are aligned;</claim-text>
<claim-text>a logic unit for implementing a triplet structure having first, second and third values, wherein the first value is an index value, the second value refers to an address accessed by the first iteration of the epilogue loop, and the third value refers to a memory address accessed by the first iteration of the vector loop;</claim-text>
<claim-text>a logic unit for incrementing a memory address in a first subset of memory addresses by incrementing the first value;</claim-text>
<claim-text>a logic unit for determining whether the memory address is aligned by comparing the first value to the third value; and</claim-text>
<claim-text>a logic unit for incrementing the memory address by a number of memory addresses in a second subset of memory addresses by resetting the first value to the second value, in response to determining that the memory address is aligned,</claim-text>
<claim-text>wherein for the selective loop, the number of iterations during execution of the selective loop is known at compile-time, such that number of loops whose number of iterations will remain a compile-time-known-constant is maximized, and</claim-text>
<claim-text>wherein the number of iterations during execution of the prologue loop and the epilogue loop is unknown,</claim-text>
<claim-text>wherein the logic units are executed by one or more processors in the system.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The system of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the prologue loop accesses the memory addresses until reaching an aligned memory address.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The system of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the conditional leaping address incrementation is implemented in a single instruction to reduce runtime overhead.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The system of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein if it is determined that the index value has reached a threshold defined based on the third value, the index value is reset to the second value. </claim-text>
</claim>
</claims>
</us-patent-grant>
