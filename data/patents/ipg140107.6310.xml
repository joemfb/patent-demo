<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627465-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627465</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13088711</doc-number>
<date>20110418</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<us-term-of-grant>
<us-term-extension>252</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20130101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>21</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>726 22</main-classification>
<further-classification>726 23</further-classification>
<further-classification>726 24</further-classification>
<further-classification>726 25</further-classification>
</classification-national>
<invention-title id="d2e53">Automatic inference of whitelist-based validation as part of static analysis for security</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>7509684</doc-number>
<kind>B2</kind>
<name>McDonald et al.</name>
<date>20090300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>7530107</doc-number>
<kind>B1</kind>
<name>Ono et al.</name>
<date>20090500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>7788235</doc-number>
<kind>B1</kind>
<name>Yeo</name>
<date>20100800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2008/0184208</doc-number>
<kind>A1</kind>
<name>Sreedhar et al.</name>
<date>20080700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>2009/0125976</doc-number>
<kind>A1</kind>
<name>Wassermann et al.</name>
<date>20090500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2009/0158430</doc-number>
<kind>A1</kind>
<name>Borders</name>
<date>20090600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2009/0183261</doc-number>
<kind>A1</kind>
<name>Peinado et al.</name>
<date>20090700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>726 24</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2009/0249489</doc-number>
<kind>A1</kind>
<name>Livshits et al.</name>
<date>20091000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2009/0328009</doc-number>
<kind>A1</kind>
<name>Scholz et al.</name>
<date>20091200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2010/0058475</doc-number>
<kind>A1</kind>
<name>Thummalapenta et al.</name>
<date>20100300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2010/0131721</doc-number>
<kind>A1</kind>
<name>Title et al.</name>
<date>20100500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711154</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2010/0251214</doc-number>
<kind>A1</kind>
<name>Bohling et al.</name>
<date>20100900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717124</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2010/0287613</doc-number>
<kind>A1</kind>
<name>Singh et al.</name>
<date>20101100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00014">
<othercit>Randive, Komal; &#x201c;Apparatus for String Overflow Exploitability Verification Using Static Analyis&#x201d;, IPCOM000201330D, Nov. 11, 2010.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00015">
<othercit>Ganesh et al.; &#x201c;Taint-Based Directed Whitebox Fuzzing&#x201d;, ICSE, May 16-24, 2009, pp. 474-484.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00016">
<othercit>Halfond et al.: &#x201c;WASP: Protecting Web Applications Using Positive Tainting and Syntax-Aware Evaluation&#x201d;, IEEE, vol. 34, Iss.1, Jan.-Feb. 2008, pp. 65-81.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00017">
<othercit>Huang et al.; &#x201c;Vulnerabilities Static Detection for Web Applications with False Positive Suppression&#x201d;, ICITIS, Dec. 17-19, 2010, pp. 574-577.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00018">
<othercit>Tang et al.; &#x201c;Dynamic Taint Analysis for Vulberability Exploits Detection&#x201d;, ICCET , vol. 2, Apr. 16-18, 2010, pp. 215-218.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00019">
<othercit>Ouyang, Weiwei; &#x201c;Privacy-Aware: Tracking and Protecting-Sensitive Information Using Automatic Type Inference&#x201d;, ICITIS, Dec. 17-19, 2010, pp. 665-668.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00020">
<othercit>Tripp et al., &#x201c;TAJ Effective Taint Analysis of Web Applications&#x201d;, PLDI'09, Jun. 15-20, 2009, 7 pgs.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>18</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>726 22- 25</main-classification>
<additional-info>unstructured</additional-info>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>6</number-of-drawing-sheets>
<number-of-figures>6</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20120266247</doc-number>
<kind>A1</kind>
<date>20121018</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Guy</last-name>
<first-name>Lotem</first-name>
<address>
<city>Hod Hasharon</city>
<country>IL</country>
</address>
</addressbook>
<residence>
<country>IL</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Pistoia</last-name>
<first-name>Marco</first-name>
<address>
<city>Amawalk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Tateishi</last-name>
<first-name>Takaaki</first-name>
<address>
<city>Yamato</city>
<country>JP</country>
</address>
</addressbook>
<residence>
<country>JP</country>
</residence>
</us-applicant>
<us-applicant sequence="004" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Tripp</last-name>
<first-name>Omer</first-name>
<address>
<city>Har-Adar</city>
<country>IL</country>
</address>
</addressbook>
<residence>
<country>IL</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Guy</last-name>
<first-name>Lotem</first-name>
<address>
<city>Hod Hasharon</city>
<country>IL</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Pistoia</last-name>
<first-name>Marco</first-name>
<address>
<city>Amawalk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Tateishi</last-name>
<first-name>Takaaki</first-name>
<address>
<city>Yamato</city>
<country>JP</country>
</address>
</addressbook>
</inventor>
<inventor sequence="004" designation="us-only">
<addressbook>
<last-name>Tripp</last-name>
<first-name>Omer</first-name>
<address>
<city>Har-Adar</city>
<country>IL</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Harrington &#x26; Smith</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Percello</last-name>
<first-name>Louis J.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Abrishamkar</last-name>
<first-name>Kaveh</first-name>
<department>2494</department>
</primary-examiner>
<assistant-examiner>
<last-name>Alata</last-name>
<first-name>Ayoub</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A method includes performing taint analysis of a computer program and determining an original set of paths from sources to sinks. Each path corresponds to a vulnerability. The method includes determining for each variable whose type is a collection and is accessed in one of the paths in the original set of paths whether the variable points to a concrete value whose internal state is not tainted according to the taint analysis. The method further includes, for each of the variables whose type is a collection found not to be tainted according to the taint analysis, determining all points in the computer program where a membership check against the collection is performed. The method also includes, for each of the points, determining corresponding paths and removing those paths from the original set of paths to create a reduced set of paths. Apparatus and computer readable program products are also disclosed.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="166.88mm" wi="231.14mm" file="US08627465-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="241.89mm" wi="180.00mm" orientation="landscape" file="US08627465-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="200.58mm" wi="184.32mm" orientation="landscape" file="US08627465-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="238.00mm" wi="185.50mm" orientation="landscape" file="US08627465-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="220.81mm" wi="186.10mm" orientation="landscape" file="US08627465-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="216.24mm" wi="182.88mm" orientation="landscape" file="US08627465-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="240.03mm" wi="182.46mm" orientation="landscape" file="US08627465-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND</heading>
<p id="p-0002" num="0001">This invention relates generally to analysis of software programs, and, more specifically, relates to static analysis of software programs.</p>
<p id="p-0003" num="0002">Static analysis for security is an area enjoying broad adoption. The prospect of scanning the code of a Web application (for instance) to detect security vulnerabilities is very appealing. This is true first because the analysis is conservative (which means that there are no false-negative findings, at least in theory), and second because the scanning process is very efficient (compared to a dynamic analysis). That is, the scanning process can operate on partial, uncompiling, or undeployable code. The greatest disadvantage of static analysis for security is the cost the analysis has to pay for being conservative: There is typically a large number of false reports.</p>
<p id="p-0004" num="0003">There are multiple techniques to improve the precision of static-analysis techniques, but these techniques normally come at the cost of making the technique more expensive, and thus less scalable. In particular, when it comes to static analysis for security, the ability to automatically infer which parts of the code act as information-flow downgraders, thereby sanitizing or validating user input, is crucial for the report to be precise. Otherwise, even if the application takes actions to secure its code against attacks, the analysis&#x2014;failing to acknowledge these measures&#x2014;flags spurious vulnerabilities.</p>
<heading id="h-0002" level="1">SUMMARY</heading>
<p id="p-0005" num="0004">In an exemplary embodiment, a method includes performing taint analysis of a computer program and determining an original set of paths from sources to sinks. Each path corresponds to a vulnerability because taint flows from a source in the path to a sink in the path. The method includes determining for each variable whose type is a collection and is accessed in one of the paths in the original set of paths whether the variable points to a concrete value whose internal state is not tainted according to the taint analysis. The method further includes, for each of the variables whose type is a collection found not to be tainted according to the taint analysis, determining all points in the computer program where a membership check against the collection is performed. The method also includes, for each of the points, determining corresponding paths and removing those paths from the original set of paths to create a reduced set of paths. Apparatus and computer readable program products are also disclosed.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS</heading>
<p id="p-0006" num="0005"><figref idref="DRAWINGS">FIG. 1</figref> is a flowchart of an exemplary method for automatic inference of whitelist-based validation as part of static analysis for security</p>
<p id="p-0007" num="0006"><figref idref="DRAWINGS">FIGS. 2-4</figref> are flowcharts of exemplary methods for operations performed in <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. 5</figref> illustrates a call graph representation of a computer program and paths through the call graph representation.</p>
<p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. 6</figref> illustrates an exemplary apparatus for performing embodiments of the instant invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0010" num="0009">As described in part above, a problem can occur in static analysis of computer programs in that flows through information-flow downgraders may still be flagged as vulnerabilities even though the flows have been properly operated on by the information-flow downgraders. Information-flow downgraders include sanitizers and validators. Sanitizers modify their input and make the input safe to be used. Meanwhile, validators simply check whether their input is or is not safe to be used, thereby allowing the programs using validators to either accept or reject, respectively, the input. A whitelist is a set of legal values. That is, white-list based validators perform membership checks to ensure that input values are members of the set of legal values.</p>
<p id="p-0011" num="0010">With regard to the problem that flows through information-flow downgraders may still be flagged as vulnerabilities even though the flows have been properly operated on by the information-flow downgraders, it is helpful to consider a concrete code example (in JAVA, which is a programming language and computing platform):</p>
<p id="p-0012" num="0011">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="196pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>1: String msgFormat = request.getParameter(&#x201c;msgFormat&#x201d;);</entry>
</row>
<row>
<entry/>
<entry>2: ...</entry>
</row>
<row>
<entry/>
<entry>3: if (validMessageFormats.contains(msgFormat)) {</entry>
</row>
<row>
<entry/>
<entry>4: &#x2003;&#x2002;response.getWriter( ).println(msgFormat);</entry>
</row>
<row>
<entry/>
<entry>5: }</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0013" num="0012">The na&#xef;ve technique for the problem of identifying the whitelist-based validation performed at line 3 (three) is based on the string-analysis family of algorithms (performed, e.g. by a string analysis engine), which produce a sound approximation of the runtime values string variables may assume. The technique using a string analysis includes the following steps:</p>
<p id="p-0014" num="0013">1. At line 1, use variable msgFormat as a seed, and submit a query to the string analysis engine on the set of runtime values the variable may assume.</p>
<p id="p-0015" num="0014">2. At line 3, to understand which values may reach line 4 (i.e., the body of the &#x201c;if&#x201d; condition), submit a query to the string analysis engine asking for all the concrete values that may be stored in the container pointed to by validMessageFormats.</p>
<p id="p-0016" num="0015">3. Assert that msgFormat can only point to one of these values at line 4.</p>
<p id="p-0017" num="0016">If one of the values to which msgFormat may evaluate is unsafe with respect to the set of security attacks of interest, then a violation is flagged. Therefore, a conservative yet coarse analysis that simply ignores whitelist-based validation would flag a vulnerability of, e.g., type cross-site scripting (XSS) on the flow (1, 4), even though the white-list based validation at line 3 should ensure that there is no XSS. As is known, XSS allows malicious Web users to inject code into Web pages viewed by other users. This vulnerability is currently the most important vulnerability in the space of Web applications, comprising roughly 80 percent of all documented security breaches. Thus, a false positive may occur if string analysis is used.</p>
<p id="p-0018" num="0017">It may also be possible for the string-analysis-based technique to avoid this false positive, but at a prohibitively expensive cost: computing all the string values that may flow into validMessageFormats requires an expensive and precise whole-program analysis, which can be problematic especially in the case of Web applications, which are multithreaded by design. That is, multithreading leads to state-space explosion, as all feasible interleavings of statements from different threads need to be taken into account.</p>
<p id="p-0019" num="0018">Herein, a much cheaper and simpler approach is proposed, which relies on, in an exemplary embodiment, running a taint analysis twice. In the first execution, it is established whether untrusted user inputs (henceforth, tainted values) reach validMessageFormats. If not, then one can safely assume validMessageFormats to maintain a set of values controlled by the Web application. Then, in a second run, membership checks are soundly treated against validMessageFormats as a form of whitelist-based validation, and a conclusion is made that there is no issue to be reported.</p>
<p id="p-0020" num="0019">As explained above, exemplary solutions described herein address a problem that is, on the one hand, of great importance, and on the other hand, cannot be solved in a straightforward manner due to the prohibitive cost of the na&#xef;ve solution. This is the reason why so far, none of the industrial/academic taint-analysis algorithms of which the inventors are aware has given treatment to this problem. The result, unfortunately, is a very high rate of false positives. The analysis assumes that the developer has done nothing to validate/sanitize untrusted inputs, where in fact, the whitelist-based endorsement pattern is quite common, and is considered the best form of sanitization/validation. This recommendation comes from the Open Web Application Security Consortium (OWASP), as well as from security experts at IBM (International Business Machines) Watchfire (a division of IBM under the Rational division).</p>
<p id="p-0021" num="0020">Herein is presented a highly efficient, exemplary solution to the problem of automatically identifying instances of whitelist-based validation. An exemplary solution includes the following operations (see <figref idref="DRAWINGS">FIG. 1</figref>):</p>
<p id="p-0022" num="0021">1. Run a taint analysis algorithm &#x201c;in the dark&#x201d;, i.e., without the algorithm being aware of instances where whitelist-based validation is performed. (block <b>110</b>). The taint analysis algorithm is performed on computer program <b>111</b> and is performed statically (i.e., the computer program <b>111</b> is not executed). It should be noted that all of the blocks in <figref idref="DRAWINGS">FIG. 1</figref> may be performed statically. The computer program <b>111</b> may include object code, byte code, source code, executable code, and library code and may not be a complete program. That is, the computer program may be simply be a portion of code and may not be operational. The methods of <figref idref="DRAWINGS">FIG. 1</figref> may be performed, e.g., by computer readable program code executed by one or more processors. There are several commercial taint-analysis tools, including &#x201c;IBM Rational AppScan Source Edition&#x201d; and HP's (Hewlett-Packard's) &#x201c;Fortify 360&#x201d;. There are also academic papers on taint analysis, such as Tripp, et al., &#x201c;TAJ: Effective Taint Analysis of Web Applications&#x201d;, Programming Language Design and Implementation (PLDI) (2009). These tools and papers may be used for performing the taint analysis used herein. Nonetheless, for completeness, a simple example of an exemplary method for performing block <b>110</b> is shown in <figref idref="DRAWINGS">FIG. 2</figref>. Assuming the taint analysis to be sound, this would produce a conservative approximation of the actual set of vulnerabilities in the Web application. The set of vulnerabilities is indicated as a conservative (or original) set <b>160</b>-<b>1</b> of paths through the computer program <b>111</b>. For the concrete code example given above, block <b>110</b> should determine paths where taint flows into the collection validMessageFormats or into the sink response.getWriter( ).println(&#x2022;). Block <b>110</b> also produces other exemplary output <b>155</b>-<b>1</b>, exemplary details of which are described below.</p>
<p id="p-0023" num="0022">2. Examine the output <b>155</b>-<b>1</b> computed by the taint-analysis algorithm, and determine (block <b>115</b>) for each variable whose type is a collection (e.g., set, array, map, etc.), whether according to the taint-analysis output <b>155</b>-<b>1</b>, the variable may point to a concrete value whose internal state may be tainted. That is, at least one of the elements in the container pointed to by the collection may be tainted. A concrete value is a run-time object (as opposed to its abstract representation by the taint analysis). A &#x201c;collection&#x201d; is defined according to its static type (e.g., a concrete class implementing java.util.Collection). A user specification defining more collection types, on top of those governed by the types in a standard library, can be included, as is described below. In the example given above, validMessageFormats is a collection. All other collections are assumed not to be tainted (block <b>115</b>). It is noted that in block <b>115</b>, the block can be considered as determining for each variable whose type is a collection whether the variable points to a concrete value whose internal state is not tainted according to the taint analysis. An exemplary method for performing block <b>115</b> is presented in <figref idref="DRAWINGS">FIG. 3</figref>.</p>
<p id="p-0024" num="0023">3. For each of the collections c found not to be reachable by taint, mark all the points in the program where membership checks against c are performed. See block <b>125</b> (an exemplary embodiment of which is shown in <figref idref="DRAWINGS">FIG. 4</figref>). Each such point is a whitelist-based validation instance, since the set of elements maintained by c at that point is known not to be controlled by the attacker. That the collection is not reachable by taint is important because otherwise a membership test against collection c might succeed due to the tainted string. That is, if the collection c is tainted (or validMessageFormats in the example given above), a corresponding measurement test (e.g., validMessageFormats.contains(&#x2022;) in the example above) might succeed due to the taint.</p>
<p id="p-0025" num="0024">In block <b>130</b>, for each of the determined points, a path corresponding to the determined point is removed from the conservative set <b>160</b>-<b>1</b> of paths. This results in output <b>155</b>-<b>2</b>, which includes in an exemplary embodiment, a reduced set <b>160</b>-<b>2</b> of paths. In other words, one way to describe the operations of blocks <b>115</b>, <b>125</b>, and <b>130</b> is these operations act like a filter, to filter out paths that are determined to have whitelist-based downgrading performed on the paths. In block <b>140</b>, a security report is displayed with the reduced set <b>162</b>-<b>2</b> of paths.</p>
<p id="p-0026" num="0025">Note that this algorithm obtains an under-approximation of the set of instances of whitelist-based validation in the computer program <b>111</b>, since the taint analysis is assumed to be sound.</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIGS. 2-4</figref> are flowcharts of exemplary methods for operations performed in <figref idref="DRAWINGS">FIG. 1</figref>. These methods may be performed, e.g., by computer readable program code executed by one or more processors. <figref idref="DRAWINGS">FIG. 2</figref> is an example of block <b>110</b> from <figref idref="DRAWINGS">FIG. 1</figref>. That is, <figref idref="DRAWINGS">FIG. 2</figref> shows exemplary operations for running a taint analysis algorithm without the algorithm being aware of instances where whitelist-based downgrading is performed. In block <b>210</b>, a call graph representation <b>500</b> (see <figref idref="DRAWINGS">FIG. 5</figref>) of the program is built. In block <b>220</b>, a taint analysis is performed on the call graph representation <b>500</b>. That is, taint such as untrusted user input in the form of strings for instance is flowed from sources to sinks. In the concrete code example given above, the source request.getParameter(&#x2022;) has an input corresponding to an HTML (hypertext markup language) form field for the attribute &#x201c;msgFormat&#x201d;, this input is put into the string msgFormat, and flows into the sink response.getWriter( ).println(&#x2022;). Any path where taint flows from a source to a sink is considered a potential vulnerability (where &#x201c;potential&#x201d; indicates that during program execution, there may be no actual vulnerability) and is placed into the conservative set <b>160</b>-<b>1</b> of paths. In block <b>230</b>, a resultant taint analysis solution <b>155</b>-<b>1</b> is stored for further inspection. The resultant taint analysis solution <b>155</b>-<b>1</b> includes in this example a map <b>256</b> from program points to taint facts holding at these points and the conservative set <b>160</b>-<b>1</b> of paths.</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 3</figref> is an example of a method for performing block <b>115</b> of <figref idref="DRAWINGS">FIG. 1</figref>. That is, the operations in <figref idref="DRAWINGS">FIG. 3</figref> determine for each variable whose type is a collection whether the variable points to a concrete value whose internal state may be tainted and assume all other collections are not tainted. The method starts in block <b>310</b>, when the map is analyzed. In block <b>320</b>, it is determined, at a program point and by static types, whether a variable is a collection. One technique for this is to perform pointer analysis to determine which variables at which program locations point to (abstract) objects of type collection. Block <b>320</b> will typically use known types <b>346</b> for collections. Assuming a strongly typed language, this language enables automatic identification of collections by their static type. Furthermore, these known types <b>346</b> also include which collections (and methods thereof) perform membership checks. Beyond the standard types, a user can specify additional types to be considered as collections, as indicated by the specification <b>345</b> of types for collections. The specification <b>345</b> also includes which collections (and methods thereof) perform membership checks. An exemplary output of block <b>320</b> is a list <b>350</b>-<b>1</b> of collections.</p>
<p id="p-0029" num="0028">In block <b>330</b>, it is determined if taint facts at the program point indicate variable points to a concrete value whose internal state may be tainted. If so, in block <b>340</b>, the collection is removed from the list <b>350</b>-<b>1</b> to create a smaller list <b>350</b>-<b>2</b>. In block <b>343</b>, blocks <b>320</b>, <b>330</b>, and <b>340</b> are performed until the entire map is analyzed. A result of the method shown in <figref idref="DRAWINGS">FIG. 3</figref> is a list <b>350</b>-<b>3</b> that contains only collections that are not tainted.</p>
<p id="p-0030" num="0029">Referring to <figref idref="DRAWINGS">FIG. 4</figref>, this figure is an example of blocks <b>125</b> and <b>130</b> from <figref idref="DRAWINGS">FIG. 1</figref>. The method begins in block <b>410</b>, when, using the call graph representation <b>500</b> and list <b>350</b>-<b>3</b> of collections that are not tainted, a point is determined in the program where a membership check is performed against a collection that is not tainted. The specification <b>345</b> and known types <b>346</b> may be used for block <b>410</b>. In block <b>420</b>, for the point, it is determined the path(s) of which the point is a part. A collection membership test can be part of many paths. As an example, imagine multiple sources and sinks, and flows between all the sources and all the sinks that first go through a collection membership test. In block <b>430</b>, the path(s) are removed from the conservative set <b>160</b>-<b>1</b> of paths. In block <b>440</b>, blocks <b>410</b>, <b>420</b>, and <b>430</b> are performed until the entire call graph representation <b>500</b> is analyzed. At this point, the reduced set <b>160</b>-<b>2</b> of paths should be available.</p>
<p id="p-0031" num="0030">Turning now to <figref idref="DRAWINGS">FIG. 5</figref>, this figure illustrates a call graph representation <b>500</b> of a computer program and paths through the call graph representation. Nodes n<sub>1 </sub><b>510</b>-<b>1</b> to n<sub>7 </sub><b>510</b>-<b>7</b> correspond to methods and each edge indicates that one method is calling another method. Node n<sub>1 </sub><b>510</b>-<b>1</b> is a source and nodes n<sub>5 </sub><b>510</b>-<b>5</b>, n<sub>6 </sub><b>510</b>-<b>6</b>, and n<sub>7 </sub><b>510</b>-<b>7</b> are sinks. There are three exemplary paths indicated by the conservative set <b>160</b>-<b>1</b> of paths. Each path corresponds to a vulnerability. In the example of the code example presented above, the node n<sub>1 </sub><b>510</b>-<b>1</b> could correspond to the request.getParameter(&#x201c;msgFormat&#x201d;) statement, node n<sub>4 </sub><b>510</b>-<b>4</b> could correspond to the validMessageFormats.contains(msgFormat) statement, and the node n<sub>7 </sub><b>510</b>-<b>7</b> could correspond to the sink statement, response.getWriter( ).println(msgFormat). It is noted that the path {1, 2, 4, 7} is found during the taint analysis because the string msgFormat is potentially tainted and makes it to the sink, response.getWriter( ).println(&#x2022;). Because the collection validMessageFormats is (in an example) not reachable by taint and performs a membership check against a collection, the path {1, 2, 4, 7} can be removed, resulting in the reduced set <b>160</b>-<b>2</b> of paths shown.</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 6</figref> illustrates an exemplary apparatus for performing embodiments of the instant invention. The apparatus in this example is computer system <b>600</b>. The computer system <b>600</b> includes one or more memories <b>620</b> including computer readable program code <b>630</b>, one or more processors <b>640</b>, one or more network interfaces <b>655</b>, and one or more display interfaces <b>670</b>, all interconnected by one or more buses <b>695</b>. The one or more network interfaces <b>655</b> communicate using wired or wireless links <b>660</b>. The display <b>680</b> may be part of or separate from the computer system <b>600</b>. In this example, the display <b>680</b> presents a security report <b>631</b> to the user. The security report <b>631</b> could be the reduced set <b>160</b>-<b>2</b> of paths, e.g., as shown in <figref idref="DRAWINGS">FIG. 5</figref>, or some indication of the paths or their corresponding vulnerabilities.</p>
<p id="p-0033" num="0032">As will be appreciated by one skilled in the art, aspects of the present invention may be embodied as a system, method or computer program product. Accordingly, aspects of the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a &#x201c;circuit,&#x201d; &#x201c;module&#x201d; or &#x201c;system.&#x201d; Furthermore, aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium(s) having computer readable program code embodied thereon.</p>
<p id="p-0034" num="0033">Any combination of one or more computer readable medium(s) may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be, for example, but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, or device, or any suitable combination of the foregoing. More specific examples (a non-exhaustive list) of the computer readable storage medium would include the following: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), an optical fiber, a portable compact disc read-only memory (CD-ROM), an optical storage device, a magnetic storage device, or any suitable combination of the foregoing. In the context of this document, a computer readable storage medium may be any tangible medium that can contain, or store a program for use by or in connection with an instruction execution system, apparatus, or device.</p>
<p id="p-0035" num="0034">A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein, for example, in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms, including, but not limited to, electro-magnetic, optical, or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate, propagate, or transport a program for use by or in connection with an instruction execution system, apparatus, or device.</p>
<p id="p-0036" num="0035">Program code embodied on a computer readable medium may be transmitted using any appropriate medium, including but not limited to wireless, wireline, optical fiber cable, RF, etc., or any suitable combination of the foregoing.</p>
<p id="p-0037" num="0036">Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages, including an object oriented programming language such as Java, Smalltalk, C++ or the like and conventional procedural programming languages, such as the &#x201c;C&#x201d; programming language or similar programming languages. The program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).</p>
<p id="p-0038" num="0037">Aspects of the present invention are described below with reference to flowchart illustrations and/or block diagrams of methods, apparatus (systems) and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and/or block diagrams, and combinations of blocks in the flowchart illustrations and/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions/acts specified in the flowchart and/or block diagram block or blocks.</p>
<p id="p-0039" num="0038">These computer program instructions may also be stored in a computer readable medium that can direct a computer, other programmable data processing apparatus, or other devices to function in a particular manner, such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function/act specified in the flowchart and/or block diagram block or blocks.</p>
<p id="p-0040" num="0039">The computer program instructions may also be loaded onto a computer, other programmable data processing apparatus, or other devices to cause a series of operational steps to be performed on the computer, other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions/acts specified in the flowchart and/or block diagram block or blocks.</p>
<p id="p-0041" num="0040">The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein, the singular forms &#x201c;a&#x201d;, &#x201c;an&#x201d; and &#x201c;the&#x201d; are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms &#x201c;comprises&#x201d; and/or &#x201c;comprising,&#x201d; when used in this specification, specify the presence of stated features, integers, steps, operations, elements, and/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, elements, components, and/or groups thereof.</p>
<p id="p-0042" num="0041">The corresponding structures, materials, acts, and equivalents of all means or step plus function elements in the claims below are intended to include any structure, material, or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description, but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method, comprising:
<claim-text>performing by a computer system taint analysis of a computer program and determining an original set of paths from sources to sinks, wherein each path corresponds to a vulnerability because taint flows from a source in the path to a sink in the path, wherein an output of the performed taint analysis includes a map from program points to taint facts holding at these points:</claim-text>
<claim-text>determining by the computer system for each variable whose type is a collection and is accessed in one of the paths in the original set of paths whether the variable points to a concrete value whose internal state is not tainted according to the taint analysis comprises:</claim-text>
<claim-text>determining by the computer system at a program point by static types whether a variable is a collection and, if so, adding the collection to a list;</claim-text>
<claim-text>determining, by the computer system using the map, if taint facts at the program point indicate the variable points to a concrete value whose internal state may be tainted and, if so, removing the collection from the list; and</claim-text>
<claim-text>performing by the computer system for all points in the computer program the determining at a program point and determining if taint facts at the program point, wherein the list indicates each variable whose type is a collection points to a concrete value whose internal state is not tainted according to the taint analysis;</claim-text>
<claim-text>for each of the collections found not to be tainted according to the taint analysis, determining by the computer system all points in the computer program where a membership check against the collection is performed; and</claim-text>
<claim-text>for each of the points, determining by the computer system corresponding paths and removing those paths from the original set of paths to create a reduced set of paths.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising displaying by the computer system the reduced set of paths to a user.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein determining at a program point by static types whether a variable is a collection is performed at least in part by using known types for collections indicating which variables are collections.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein determining at a program point by static types whether a variable is a collection is performed at least in part by using a user supplied specification of types for collections indicating which variables are collections.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein determining all the points in the computer</claim-text>
<claim-text>program where a membership check against the collection is performed further comprises determining a membership check is performed at least in part by using known types for collections indicating which collections perform membership checks.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein a membership check against a collection</claim-text>
<claim-text>comprises a whitelist-based validator.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. An apparatus, comprising:
<claim-text>one or more memories comprising computer readable program code;</claim-text>
<claim-text>one or more processors configured, in response to execution of the computer readable program code, to cause the apparatus to perform at least the following:</claim-text>
<claim-text>performing taint analysis of a computer program and determining an original set of paths from sources to sinks, wherein each path corresponds to a vulnerability because taint flows from a source in the path to a sink in the path, wherein an output of the performed taint analysis includes a map from program points to taint facts holding at these points:</claim-text>
<claim-text>determining for each variable whose type is a collection and is accessed in one of the paths in the original set of paths whether the variable points to a concrete</claim-text>
</claim-text>
<claim-text>value whose internal state is not tainted according to the taint analysis comprises:
<claim-text>determining at a program point by static types whether a variable is a collection and, if so, adding the collection to a list;</claim-text>
<claim-text>determining, using the map, if taint facts at the program point indicate the variable points to a concrete value whose internal state may be tainted and, if so, removing the collection from the list; and</claim-text>
<claim-text>performing for all points in the computer program the determining at a program point and determining if taint facts at the program point;</claim-text>
<claim-text>wherein the list indicates each variable whose type is a collection points to a concrete value whose internal state is not tainted according to the taint analysis;</claim-text>
<claim-text>for each of the collections found not to be tainted according to the taint analysis, determining all points in the computer program where a membership check against the collection is performed; and</claim-text>
<claim-text>for each of the points, determining corresponding paths and removing those paths from the original set of paths to create a reduced set of paths.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The apparatus of <claim-ref idref="CLM-00007">claim 7</claim-ref>, further comprising displaying the reduced set of paths to a user.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The apparatus of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein determining at a program point by static types whether a variable is a collection is performed at least in part by using known types for collections indicating which variables are collections.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The apparatus of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein determining at a program point by static types whether a variable is a collection is performed at least in part by using a</claim-text>
<claim-text>user-supplied specification of types for collections indicating which variables are collections.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The apparatus of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein determining all the points in the computer program where a membership check against the collection is performed further comprises determining a membership check is performed at least in part by using known types for collections indicating which collections perform membership checks.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The apparatus of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein a membership check against a collection comprises a whitelist-based validator.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. A computer program product, comprising:
<claim-text>a non-transitory computer readable storage medium having computer readable program code embodied thereon, the computer readable program code comprising:</claim-text>
<claim-text>code for performing taint analysis of a computer program and determining an</claim-text>
</claim-text>
<claim-text>original set of paths from sources to sinks, wherein each path corresponds to a vulnerability because taint flows from a source in the path to a sink in the path, wherein an output of the performed taint analysis includes a map from program points to taint facts holding at these points;
<claim-text>code for determining for each variable whose type is a collection and is accessed</claim-text>
</claim-text>
<claim-text>in one of the paths in the original set of paths whether the variable points to a concrete value whose internal state is not tainted according to the taint analysis comprises:
<claim-text>code for determining by the computer system at a program point by static types whether a variable is a collection and, if so, adding the collection</claim-text>
</claim-text>
<claim-text>to a list;
<claim-text>code for determining, by the computer system using the map, if taint facts at the program point indicate the variable points to a concrete value whose internal state may be tainted and, if so, removing the collection from the list; and</claim-text>
<claim-text>code for performing by the computer system for all points in the computer program the determining at a program point and determining if taint facts at the program point, wherein the list indicates each variable whose type is a collection points to a concrete value whose internal state is not tainted according to the taint analysis;</claim-text>
<claim-text>code for, for each of the collections found not to be tainted according to the taint analysis, determining all points in the computer program where a membership check against the collection is performed; and</claim-text>
<claim-text>code for, for each of the points, determining corresponding paths and removing those paths from the original set of paths to create a reduced set of paths.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The computer program product of <claim-ref idref="CLM-00013">claim 13</claim-ref>, further comprising displaying the reduced set of paths to a user.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The computer program product of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein determining at a program point by static types whether a variable is a collection is performed at least in part by using known types for collections indicating which variables are collections.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The computer program product <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein determining at a program point by static types whether a variable is a collection is performed at least in part by using a user-supplied specification of types for collections indicating which variables are collections.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The computer program product of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein determining all the points in the computer program where a membership check against the collection is performed further comprises determining a membership check is performed at least in part by using known types for collections indicating which collections perform membership checks.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The computer program product of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein a membership check against a collection comprises a whitelist-based validator. </claim-text>
</claim>
</claims>
</us-patent-grant>
