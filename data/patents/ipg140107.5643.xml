<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08626744-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08626744</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13358779</doc-number>
<date>20120126</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<us-term-of-grant>
<us-term-extension>11</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>7</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>30</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>707714</main-classification>
</classification-national>
<invention-title id="d2e53">Executing CASE expressions containing subqueries</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5987455</doc-number>
<kind>A</kind>
<name>Cochrane et al.</name>
<date>19991100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6341281</doc-number>
<kind>B1</kind>
<name>Macnicol et al.</name>
<date>20020100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6411951</doc-number>
<kind>B1</kind>
<name>Galindo-Legaria et al.</name>
<date>20020600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>  1  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6882993</doc-number>
<kind>B1</kind>
<name>Lawande et al.</name>
<date>20050400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707714</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>6996557</doc-number>
<kind>B1</kind>
<name>Leung et al.</name>
<date>20060200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2004/0153448</doc-number>
<kind>A1</kind>
<name>Cheng et al.</name>
<date>20040800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  4</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2004/0220896</doc-number>
<kind>A1</kind>
<name>Finlay et al.</name>
<date>20041100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2006/0101001</doc-number>
<kind>A1</kind>
<name>Lindsay et al.</name>
<date>20060500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  3</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2006/0218123</doc-number>
<kind>A1</kind>
<name>Chowdhuri et al.</name>
<date>20060900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00010">
<othercit>Burns, Doug. &#x201c;Improving SQL Efficiency Using CASE.&#x201d; &#x3c;http://oracledoug.com/case.pdf&#x3e;. Downloaded Aug. 17, 2010.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00011">
<othercit>Gryz, Jarek, et al.: &#x201c;SQL Queries with CASE Expressions.&#x201d; Proceedings 17th International Symposium, ISMIS, 2008. Toronto, Canada, May 2008. pp. 351-360.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>9</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>707714</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707999002</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>3</number-of-drawing-sheets>
<number-of-figures>4</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20130198164</doc-number>
<kind>A1</kind>
<date>20130801</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Cheng</last-name>
<first-name>Qi</first-name>
<address>
<city>North York</city>
<country>CA</country>
</address>
</addressbook>
<residence>
<country>CA</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Hornibrook</last-name>
<first-name>John F.</first-name>
<address>
<city>Markham</city>
<country>CA</country>
</address>
</addressbook>
<residence>
<country>CA</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Saborit</last-name>
<first-name>Jose A.</first-name>
<address>
<city>Markham</city>
<country>CA</country>
</address>
</addressbook>
<residence>
<country>CA</country>
</residence>
</us-applicant>
<us-applicant sequence="004" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Sharpe</last-name>
<first-name>David C.</first-name>
<address>
<city>St. Catharines</city>
<country>CA</country>
</address>
</addressbook>
<residence>
<country>CA</country>
</residence>
</us-applicant>
<us-applicant sequence="005" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Zuzarte</last-name>
<first-name>Calisto P.</first-name>
<address>
<city>Pickering</city>
<country>CA</country>
</address>
</addressbook>
<residence>
<country>CA</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Cheng</last-name>
<first-name>Qi</first-name>
<address>
<city>North York</city>
<country>CA</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Hornibrook</last-name>
<first-name>John F.</first-name>
<address>
<city>Markham</city>
<country>CA</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Saborit</last-name>
<first-name>Jose A.</first-name>
<address>
<city>Markham</city>
<country>CA</country>
</address>
</addressbook>
</inventor>
<inventor sequence="004" designation="us-only">
<addressbook>
<last-name>Sharpe</last-name>
<first-name>David C.</first-name>
<address>
<city>St. Catharines</city>
<country>CA</country>
</address>
</addressbook>
</inventor>
<inventor sequence="005" designation="us-only">
<addressbook>
<last-name>Zuzarte</last-name>
<first-name>Calisto P.</first-name>
<address>
<city>Pickering</city>
<country>CA</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Mollborn Patents, Inc.</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Mollborn</last-name>
<first-name>Fredrik</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Kerzhner</last-name>
<first-name>Aleksandr</first-name>
<department>2162</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Methods and apparatus, including computer program products, implementing and using techniques for executing a query in a computer to retrieve data from a relational database stored on a data storage device. A query is received that contains a CASE expression having one or more subqueries. A query execution plan is generated. The query execution plan uses a parameterized union all operator to keep the semantics of the CASE expression, and a nested loop join operator to drive data across the section of the query execution plan that executes the CASE expression without performing any join operations. The generated query execution plan is executed in the computer to retrieve data from the relational database.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="99.82mm" wi="181.10mm" file="US08626744-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="203.37mm" wi="126.32mm" file="US08626744-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="229.02mm" wi="184.49mm" file="US08626744-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="197.87mm" wi="172.21mm" orientation="landscape" file="US08626744-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND</heading>
<p id="p-0002" num="0001">The present invention relates to database management systems, and more specifically, to executing expressions within database query languages. Databases come in many flavors. One popular form is a relational database management system (RDBMS), such as DB2&#x2122; system, which is manufactured by International Business Machines Corporation of Armonk, N.Y.</p>
<p id="p-0003" num="0002">The RDBMS is responsible for handling all requests for access to the database where the data itself is actually stored, thereby shielding the users from the details of any specific hardware implementation. Using relational techniques, the RDBMS stores, manipulates and retrieves data in the form of table-like relations typically defined by a set of columns or attributes of data types and a set of rows (i.e. records or tuples) of data. The columns may further comprise restrictions on their data content (i.e. valid domains) and may be designated as a primary key or unique identifier for the relation or a foreign key for one or more other relations.</p>
<p id="p-0004" num="0003">One very common language for dealing with RDBMSs is the Structured Query Language (SQL). SQL includes both data definition operations and data manipulation operations. To maintain data independence a query (i.e. a set of SQL commands) instructs the RDBMS what to do but not how to do it. Thus, the RDBMS includes a query processor for generating various query plans of execution and choosing the least expensive plan with respect to execution costs. Due to the high-level nature of relational expressions and a variety of implementation techniques, automatic query optimization is possible and often necessary to ensure more efficient query processing.</p>
<p id="p-0005" num="0004">Often, a database application may require the creation of a &#x201c;view&#x201d; for the data in given relations or tables. A view provides an alternative way of looking at the data in one or more base tables. It may, for example, contain only selected columns from the table. The creation of the view or selections of data from the view may involve the processing of multiple &#x201c;CASE&#x201d; expressions.</p>
<p id="p-0006" num="0005">In SQL, CASE expressions (CEXP), similar to any other programming language, are an intelligible way to express complex conditional clauses, which allows a selection to be made of one sequence of statements out of many possible sequences. A CEXP can be seen as a list of n logical expressions, 1<sub>&#x2014;</sub>0, . . . , 1_(n&#x2212;1) and another list of n+1 actions, a<sub>&#x2014;</sub>0, . . . , a_n. An action represents a sequence of statements to be executed, and a logical expression represents a condition that can evaluate to be either true or false. Following this terminology, the semantics of a CEXP can be described as follows: the logical expressions 1_i must be evaluated in increasing order from i=0 to i=n&#x2212;1 until one logical expression satisfies, or all of the logical expressions fail, such that: if i:0i&#x3c;n:j:0j&#x3c;i: (false(1_j) true(1_i)) then a_i is executed; if i:0i&#x3c;n: false(1_i) then a_n is executed. It should be noted that only one action can be executed and that all the other actions being omitted.</p>
<p id="p-0007" num="0006">The syntax of a CEXP in a SQL statement can be expressed as follows:</p>
<p id="p-0008" num="0007">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="168pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>SELECT</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;CASE</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;&#x2003;&#x2003;WHEN I_0 THEN a_0</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;&#x2003;&#x2003;WHEN I_1 THEN a_1</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;&#x2003;&#x2003;....</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;&#x2003;&#x2003;WHEN I_(n&#x2212;1) THEN a_(n&#x2212;1)</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;&#x2003;&#x2003;ELSE a_n</entry>
</row>
<row>
<entry/>
<entry>&#x2003;&#x2003;END</entry>
</row>
<row>
<entry/>
<entry>FROM ...</entry>
</row>
<row>
<entry/>
<entry>WHERE ....;</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
The CEXPs can appear either in the SELECT clause, in the WHERE clauses, or in any place where a scalar expression can appear.
</p>
<p id="p-0009" num="0008">When CEXPs contain subqueries, commercial DBMSs such as DB2 tackle CEXPs by breaking the subquery semantic block so that the subquery semantic blocks are independently executed before evaluating the CEXPs. This type of approach allows the query compiler to speed up the query processing by considering a larger search space for join ordering. However, the payoff is that the query execution plan generated by the compiler breaks the CEXP semantics, the execution of subquery semantic blocks is out of the control of logical expression, i.e., subquery semantic blocks are executed no matter of the result of the logical expression, and, as a consequence, incorrect results may be produced. Also, in some scenarios, the fact that all subquery sematic blocks are being executed might lead to performance degradations, independently of the optimizations introduced by the query compiler.</p>
<p id="p-0010" num="0009">For example, say that we have the following statement:</p>
<p id="p-0011" num="0010">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>SELECT</entry>
</row>
<row>
<entry>&#x2003;&#x2003;CASE</entry>
</row>
<row>
<entry>&#x2003;&#x2003;&#x2003;&#x2003;WHEN C1 &#x3e; 0 THEN ( SELECT SUM(C2/C1) FROM T1)</entry>
</row>
<row>
<entry>&#x2003;&#x2003;&#x2003;&#x2003;ELSE ( SELECT SUM(C2+C1) FROM T1)</entry>
</row>
<row>
<entry>&#x2003;&#x2003;END</entry>
</row>
<row>
<entry>FROM T;</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
This CEXP has one logical expression 1<sub>&#x2014;</sub>0=C1&#x3e;0, and two actions: a<sub>&#x2014;</sub>0=(SELECT SUM(C2/C1) FROM T1), and a<sub>&#x2014;</sub>1=(SELECT SUM(C2+C1) FROM T1).
</p>
<p id="p-0012" num="0011">At present, a query compiler, such as the DB2 query compiler, may break the CEXP into several join operations, as illustrated in <figref idref="DRAWINGS">FIG. 1</figref>. For every tuple projected by the table scan on T, a<sub>&#x2014;</sub>0 and a<sub>&#x2014;</sub>1 are executed through the nested loop joins (NLJN). After that, the condition expressed by 1<sub>&#x2014;</sub>0 is checked and the result from a<sub>&#x2014;</sub>0 is selected if it evaluates to true. If this is not the case, the result from a<sub>&#x2014;</sub>1 is used.</p>
<p id="p-0013" num="0012">This CEXP execution can cause an error when a<sub>&#x2014;</sub>0 does not have to be executed because of its dependency on C1, that is, if C1 is 0, when a<sub>&#x2014;</sub>0 is executed, C2 will be divided by zero. Moreover, the execution of the query may be sub-optimal since all the actions are executed irrespective of the result from evaluating 1<sub>&#x2014;</sub>0. Thus, there is a need for mechanisms that execute CEXPs containing subqueries, such that the semantics of the CEXP are correct.</p>
<heading id="h-0002" level="1">SUMMARY</heading>
<p id="p-0014" num="0013">According to one embodiment of the present invention, methods and apparatus, including computer program products are provided for executing a query in a computer to retrieve data from a relational database stored on a data storage device. A query is received that contains a CASE expression having one or more subqueries. A query execution plan is generated. The query execution plan uses a parameterized union all operator to keep the semantics of the CASE expression, and a nested loop join operator to drive data across the section of the query execution plan that executes the CASE expression without performing any join operations. The generated query execution plan is executed in the computer to retrieve data from the relational database.</p>
<p id="p-0015" num="0014">The details of one or more embodiments of the invention are set forth in the accompanying drawings and the description below. Other features and advantages of the invention will be apparent from the description and drawings, and from the claims.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">DESCRIPTION OF DRAWINGS</heading>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 1</figref> shows a schematic tree diagram of join operations of a CEXP, in accordance with one embodiment.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 2</figref> shows a schematic view of a query plan using a PUA operator, in accordance with one embodiment.</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 3</figref> shows a strategy for handling a CEXP when all logical expressions are simple, in accordance with one embodiment.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 4</figref> shows a strategy for handling a CEXP when containing simple and complex logical expressions, in accordance with one embodiment.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<p id="p-0020" num="0019">Like reference symbols in the various drawings indicate like elements.</p>
<heading id="h-0004" level="1">DETAILED DESCRIPTION</heading>
<p id="h-0005" num="0000">Overview</p>
<p id="p-0021" num="0020">The various embodiments of this invention address the problem of executing CEXPs within SQL statements. As was described above, CEXP in SQL statements can be optimized to speed up query execution. However, these optimizations usually break the semantic correctness of CEXPs, which may cause errors or other types of undesirable behavior. Various embodiments of the invention attempt to solve these issues by proposing new methods for executing CEXPs containing subqueries such that its semantics are intact. Besides keeping the semantic correctness of a CEXP, the methods in accordance with the various embodiments described herein can also lead to performance improvements, as compared with current CEXP execution explained above, that is, scenarios in which there is correlation towards the actions to be executed by a CEXP.</p>
<p id="p-0022" num="0021">As will be appreciated by one skilled in the art, aspects of the present invention may be embodied as a system, method or computer program product. Accordingly, aspects of the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a &#x201c;circuit,&#x201d; &#x201c;module&#x201d; or &#x201c;system.&#x201d; Furthermore, aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium(s) having computer readable program code embodied thereon.</p>
<p id="p-0023" num="0022">Any combination of one or more computer readable medium(s) may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be, for example, but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, or device, or any suitable combination of the foregoing. More specific examples (a non-exhaustive list) of the computer readable storage medium would include the following: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), an optical fiber, a portable compact disc read-only memory (CD-ROM), an optical storage device, a magnetic storage device, or any suitable combination of the foregoing. In the context of this document, a computer readable storage medium may be any tangible medium that can contain, or store a program for use by or in connection with an instruction execution system, apparatus, or device.</p>
<p id="p-0024" num="0023">A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein, for example, in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms, including, but not limited to, electro-magnetic, optical, or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate, propagate, or transport a program for use by or in connection with an instruction execution system, apparatus, or device.</p>
<p id="p-0025" num="0024">Program code embodied on a computer readable medium may be transmitted using any appropriate medium, including but not limited to wireless, wireline, optical fiber cable, RF, etc., or any suitable combination of the foregoing.</p>
<p id="p-0026" num="0025">Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages, including an object oriented programming language such as Java, Smalltalk, C++ or the like and conventional procedural programming languages, such as the &#x201c;C&#x201d; programming language or similar programming languages. The program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).</p>
<p id="p-0027" num="0026">Aspects of the present invention are described below with reference to flowchart illustrations and/or block diagrams of methods, apparatus (systems) and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and/or block diagrams, and combinations of blocks in the flowchart illustrations and/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions/acts specified in the flowchart and/or block diagram block or blocks.</p>
<p id="p-0028" num="0027">These computer program instructions may also be stored in a computer readable medium that can direct a computer, other programmable data processing apparatus, or other devices to function in a particular manner, such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function/act specified in the flowchart and/or block diagram block or blocks.</p>
<p id="p-0029" num="0028">The computer program instructions may also be loaded onto a computer, other programmable data processing apparatus, or other devices to cause a series of operational steps to be performed on the computer, other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions/acts specified in the flowchart and/or block diagram block or blocks.</p>
<p id="h-0006" num="0000">The Parameterized Union All (PUA) Operator</p>
<p id="p-0030" num="0029">In order to solve the above-mentioned problems, a Parameterized Union All (PUA) operator is used. The PUA operator has two or more inputs, referred to as &#x201c;branches&#x201d;, in contrast to the conventional SQL &#x201c;Union All&#x201d; operator, which only executes one of its branches. The PUA operator executes an internal operator, referred to herein as a &#x201c;pick operator&#x201d;, which selects the branch to be executed based on a conditional expression. A common use of the PUA operator is on partitioned tables, in which rows are grouped in a specified range of a single dimension in the same data partition, and in which only access to a specific group of rows is needed. As an example, consider a table &#x201c;lineitems&#x201d; partitioned by the year the lineitem was committed. Consider the following statement: &#x201c;SELECT 1_lineitem FROM lineitems WHERE year(1_commited)=?&#x201d;. For this statement, the query optimizer could generate a query plan as illustrated in <figref idref="DRAWINGS">FIG. 2</figref>. In this example, the pick operator chooses the branch to execute based on the value of the parameter marker &#x201c;?&#x201d;. If the value is out of the partitioning range, then the pick operator will return an &#x201c;end of file&#x201d;.</p>
<p id="h-0007" num="0000">Executing CEXPs</p>
<p id="p-0031" num="0030">In one embodiment, a method for executing CEXPs that contain subqueries uses the PUA and the NLJN operators. The PUA operator is used to keep the semantics of the CEXP, and the NLJN is used to drive the data across the section of the query execution plan that executes the CEXP. It should be noted that no join operation is carried out by the NLJN, but that the operator is merely used to drive each tuple generated by the outer relation (i.e., the left child), to the inner relation (i.e., the right child, the PUA).</p>
<p id="p-0032" num="0031">In the following discussion, the following additional definitions will be used:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0032">Simple logical expression: a logical expression is said to be simple if its evaluation does not require the execution of a scalar subquery (i.e., a subquery that returns a single row).</li>
        <li id="ul0002-0002" num="0033">Complex logical expression: a logical expression is said to be complex if its evaluation does require the execution of one or more scalar subqueries (see, for example, 1_j in <figref idref="DRAWINGS">FIG. 4</figref>).</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0033" num="0034">In one embodiment, the pick operator in the PUA can only handle simple logical expressions. Thus, different techniques are used depending on whether the logical expressions in the CEXP are simple, or whether there is a mix of simple and complex logical expressions. Each of these situations will now be discussed in further detail.</p>
<p id="h-0008" num="0000">Simple Logical Expressions</p>
<p id="p-0034" num="0035">When all logical expressions 1_i in a CEXP are simple, a method in accordance with one embodiment for executing the CEXP includes using a single PUA with n+1 branches (one per each action in the CEXP) and a NLJN that drives the data towards the PUA.</p>
<p id="p-0035" num="0036"><figref idref="DRAWINGS">FIG. 3</figref> shows the strategy for handling a CEXP when all logical expressions are simple, in accordance with one embodiment. As can be seen in <figref idref="DRAWINGS">FIG. 3</figref>, the NLJN is used to feed the PUA, which is responsible for executing the CEXP. The pick operator evaluates the logical expressions 1_i in increasing order from i=0 to i=n&#x2212;1. When a logical expression evaluates to true, then the corresponding action is executed. If all 1_i evaluate to false, then a_n is executed.</p>
<p id="h-0009" num="0000">Both Simple and Complex Logical Expressions</p>
<p id="p-0036" num="0037">When complex logical expressions are present, the scalar subqueries, needed for their evaluation, cannot be executed by the pick operator. For example, assume that a CEXP includes a complex logical expression 1_j. The execution of the CEXP will proceed as explained above until 1_j is found by the pick operator of the PUA. When this happens, the pick operator automatically selects branch j to be executed, not to execute action a_j, but to execute the scalar subqueries through a NLJN, that will drive the results to another PUA. This PUA, with the subqueries being resolved, can evaluate 1_j. If 1_j evaluates to true, action a_j is selected, the execution of the CEXP is continued. Every complex logical expression will add one level of depth. <figref idref="DRAWINGS">FIG. 4</figref> illustrates this strategy in accordance with one embodiment for executing CEXPs in these situations. For the sake of simplicity, this example only includes one complex logical expression, 1_j.</p>
<p id="p-0037" num="0038">In summary, the techniques described herein in accordance with various embodiments combine the use of the PUA and NLJN relational operators to ensure the semantic correctness of CEXPs and, in terms of performance, can improve existing techniques used by existing conventional commercial database management systems, such as DB2.</p>
<p id="p-0038" num="0039">The diagrams in the figures illustrate the architecture, functionality, and operation of possible implementations of systems, methods and computer program products according to various embodiments of the present invention. In this regard, each block in the block diagrams may represent a module, segment, or portion of code, which comprises one or more executable instructions for implementing the specified logical function(s). It should also be noted that, in some alternative implementations, the functions noted in the block may occur out of the order noted in the figures. For example, two blocks shown in succession may, in fact, be executed substantially concurrently, or the blocks may sometimes be executed in the reverse order, depending upon the functionality involved. It will also be noted that each block of the block diagrams and/or flowchart illustration, and combinations of blocks in the block diagrams and/or flowchart illustration, can be implemented by special purpose hardware-based systems that perform the specified functions or acts, or combinations of special purpose hardware and computer instructions.</p>
<p id="p-0039" num="0040">The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein, the singular forms &#x201c;a&#x201d;, &#x201c;an&#x201d; and &#x201c;the&#x201d; are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms &#x201c;comprises&#x201d; and/or &#x201c;comprising,&#x201d; when used in this specification, specify the presence of stated features, integers, steps, operations, elements, and/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, elements, components, and/or groups thereof.</p>
<p id="p-0040" num="0041">The corresponding structures, materials, acts, and equivalents of all means or step plus function elements in the claims below are intended to include any structure, material, or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description, but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>The invention claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A computer-implemented method for executing a query in a computer to retrieve data from a relational database stored on a data storage device, the method comprising:
<claim-text>receiving a query containing a CASE expression having one or more subqueries;</claim-text>
<claim-text>generating a query execution plan, the query execution plan using a parameterized union all operator to keep the semantics of the CASE expression, and a nested loop join operator to drive data across the section of the query execution plan that executes the CASE expression,</claim-text>
<claim-text>wherein, when all logical expressions in the CASE expression are simple expressions, a single parameterized union all operator with one branch per action in the CASE expression is used and the nested loop join operator provides data to the parameterized union all operator which executes the CASE expression; and</claim-text>
<claim-text>executing the generated query execution plan in the computer to retrieve data from the relational database.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the parameterized union all operator executes an internal pick operator which selects a logical branch of the CASE expression to be executed based on a conditional expression.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein when the CASE expression contains a combination of simple and complex logical expressions,
<claim-text>multiple parameterized union all operators are used, at least some parameterized union all operators having one branch per action in the CASE expression and an additional branch for executing scalar subqueries through a nested loop join operator, and</claim-text>
<claim-text>the nested loop join operator receives a subquery from a parameterized union all operator and provides the received data to another parameterized union all operator which executes the subquery of the CASE expression.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. A computer program product for executing a query in a computer to retrieve data from a relational database stored on a data storage device, the computer program product comprising:
<claim-text>a computer readable storage medium having computer readable program code embodied therewith, the computer readable program code comprising:</claim-text>
<claim-text>computer readable program code configured to receive a query containing a CASE expression having one or more subqueries;</claim-text>
<claim-text>computer readable program code configured to generate a query execution plan, the query execution plan using a parameterized union all operator to keep the semantics of the CASE expression, and a nested loop join operator to drive data across the section of the query execution plan that executes the CASE expression,</claim-text>
<claim-text>wherein, when all logical expressions in the CASE expression are simple expressions, a single parameterized union all operator with one branch per action in the CASE expression is used and the nested loop join operator provides data to the parameterized union all operator which executes the CASE expression; and</claim-text>
<claim-text>computer readable program code configured to execute the generated query execution plan in the computer to retrieve data from the relational database.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The computer program product of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the parameterized union all operator executes an internal pick operator which selects a logical branch of the CASE expression to be executed based on a conditional expression.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The computer program product of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein when the CASE expression contains a combination of simple and complex logical expressions,
<claim-text>multiple parameterized union all operators are used, at least some parameterized union all operators having one branch per action in the CASE expression and an additional branch for executing scalar subqueries through a nested loop join operator, and</claim-text>
<claim-text>the nested loop join operator receives a subquery from a parameterized union all operator and provides the received data to another parameterized union all operator which executes the subquery of the CASE expression.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. An apparatus for executing a query to retrieve data from a relational database stored on a data storage device, comprising:
<claim-text>a computer having a memory and a data storage device coupled thereto, wherein the data storage device stores a relational database; and</claim-text>
<claim-text>one or more computer programs, performed by the computer, for:</claim-text>
<claim-text>receiving a query containing a CASE expression having one or more subqueries;</claim-text>
<claim-text>generating a query execution plan, the query execution plan using a parameterized union all operator to keep the semantics of the CASE expression, and a nested loop join operator to drive data across the section of the query execution plan that executes the CASE expression,</claim-text>
<claim-text>wherein, when all logical expressions in the CASE expression are simple expressions, a single parameterized union all operator with one branch per action in the CASE expression is used and the nested loop join operator provides data to the parameterized union all operator which executes the CASE expression; and</claim-text>
<claim-text>executing the generated query execution plan in the computer to retrieve data from the relational database.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The apparatus of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the parameterized union all operator executes an internal pick operator which selects a logical branch of the CASE expression to be executed based on a conditional expression.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The apparatus of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein when the CASE expression contains a combination of simple and complex logical expressions,
<claim-text>multiple parameterized union all operators are used, at least some parameterized union all operators having one branch per action in the CASE expression and an additional branch for executing scalar subqueries through a nested loop join operator, and</claim-text>
<claim-text>the nested loop join operator receives a subquery from a parameterized union all operator and provides the received data to another parameterized union all operator which executes the subquery of the CASE expression. </claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
