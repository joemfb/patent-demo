<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627281-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627281</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12954643</doc-number>
<date>20101125</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<priority-claims>
<priority-claim sequence="01" kind="national">
<country>JP</country>
<doc-number>2009-270506</doc-number>
<date>20091127</date>
</priority-claim>
</priority-claims>
<us-term-of-grant>
<us-term-extension>605</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>44</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>45</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>717114</main-classification>
<further-classification>717110</further-classification>
<further-classification>717137</further-classification>
</classification-national>
<invention-title id="d2e71">Method, computer program and computer system for converting source code written in dynamically typed language into target code written in statically typed language and executing target code</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>7389498</doc-number>
<kind>B2</kind>
<name>Meijer et al.</name>
<date>20080600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717114</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>7895584</doc-number>
<kind>B1</kind>
<name>Ma et al.</name>
<date>20110200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717137</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>8060859</doc-number>
<kind>B2</kind>
<name>Meijer et al.</name>
<date>20111100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717114</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>8112740</doc-number>
<kind>B2</kind>
<name>Meijer et al.</name>
<date>20120200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717114</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>8473901</doc-number>
<kind>B1</kind>
<name>Johnson</name>
<date>20130600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717110</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>8479156</doc-number>
<kind>B2</kind>
<name>Hudson et al.</name>
<date>20130700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717110</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2004/0216132</doc-number>
<kind>A1</kind>
<name>Messec</name>
<date>20041000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2007/0288892</doc-number>
<kind>A1</kind>
<name>Foti</name>
<date>20071200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717114</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2008/0313609</doc-number>
<kind>A1</kind>
<name>Meijer et al.</name>
<date>20081200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717114</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2008/0320444</doc-number>
<kind>A1</kind>
<name>Meijer et al.</name>
<date>20081200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717110</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2009/0024986</doc-number>
<kind>A1</kind>
<name>Meijer et al.</name>
<date>20090100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717137</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2012/0180025</doc-number>
<kind>A1</kind>
<name>Webb</name>
<date>20120700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717114</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>JP</country>
<doc-number>63-271532</doc-number>
<kind>A</kind>
<date>19881100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>JP</country>
<doc-number>04-317133</doc-number>
<kind>A</kind>
<date>19921100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>JP</country>
<doc-number>2004-326807</doc-number>
<kind>A</kind>
<date>20041100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>WO</country>
<doc-number>WO2009/002683</doc-number>
<date>20081200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00017">
<othercit>Ortin et al., &#x201c;including both static and dynamic typing in the same programming language&#x201d;, 2010 The Institution of Engineering and Technology, IET Softw., 2010, vol. 4, Iss. 4, pp. 268-282; &#x3c;http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&#x26;arnumber=5523694&#x3e;.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00018">
<othercit>Saunders et al., &#x201c;Dynamic, Recursive, Heterogeneous Types in Statically-Typed Languages&#x201d;, 2013 ACM, C++Now Conference 2013, May 13-17, 2013, pp. 1-10; &#x3c;cppnow.org/files/2013/03/saunders-jeffery.pdf&#x3e;.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00019">
<othercit>Ishizaki et al., &#x201c;Adding Dynamically-Typed Language Support to a Statically-Typed Language Compiler: Performance Evaluation, Analysis, and Tradeoffs&#x201d;, 2012 ACM, VEEE'12, Mar. 3-4, 2012, London, England, UK, pp. 169-180; &#x3c;http://dl.acm.org/citation.cfm?doid=2365864.2151047&#x3e;.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00020">
<othercit>Baars et., &#x201c;Typing Dynamic Typing&#x201d;, 2002 ACM, ICFP'02, 2002, Pittsburgh, Pennsylvania, USA, pp. 1-10; &#x3c;http://dl.acm.org/citation.cfm?doid=583852.581494&#x3e;.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00021">
<othercit>Ancona et al., &#x201c;RPython&#x2014;a Step Towards Reconciling Dynamically and Statically Typed OO Languages&#x201d;, 2007 ACM, DLS'07, Oct. 22, 2007, Montr&#xe9;al, Queb&#xe9;c, Canada, pp. 1-12; &#x3c;http://dl.acm.org/citation.cfm?doid=1297081.1297091&#x3e;.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00022">
<othercit>Laurence Tratt, &#x201c;Dynamically Typed Languages&#x201d;, Mar. 13, 2009, Bournemouth University, Poole, Dorset, United Kingdom, pp. 1-33; &#x3c;eprints.bournemouth.ac.uk/.../1/tratt<sub>&#x2014;</sub>dynamically<sub>&#x2014;</sub>typed<sub>&#x2014;</sub>languages.pdf&#x3e;.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00023">
<othercit>Shigeru Chiba et. al., &#x201c;Implementation Techniques for Faster Reflective Computing&#x201d;, Computer Software, Vo1. 21, No. 6, pp. 5-15, Nov. 25, 2004.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00024">
<othercit>Kei Nakahara, &#x201c;JSR Standard, Script Language Groovy Introduction&#x201d;, WEB+DB PRESS, Gijutsu-Hyohron Co., Ltd., vol. 24, p. 53, Jan. 15, 2005 (English language in JP text).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00025">
<othercit>&#x201c;The Reflection API&#x201d;, downloaded from http://download.oracle.com/javase/tutorial/reflect/ on Nov. 20, 2010.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00026">
<othercit>&#x201c;SugerCRM-Commmercial Open Source CRM&#x201d; downloaded from http://www.sugarcrm.com/crm/ on Nov. 19, 2010.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>11</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>34</number-of-drawing-sheets>
<number-of-figures>41</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20110131556</doc-number>
<kind>A1</kind>
<date>20110602</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Tatsubori</last-name>
<first-name>Michiaki</first-name>
<address>
<city>Kanagawa</city>
<country>JP</country>
</address>
</addressbook>
<residence>
<country>JP</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Tatsubori</last-name>
<first-name>Michiaki</first-name>
<address>
<city>Kanagawa</city>
<country>JP</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<last-name>Zarick</last-name>
<first-name>Gail H.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<orgname>Otterstedt, Ellenbogen &#x26; Kammer, LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Dao</last-name>
<first-name>Thuy</first-name>
<department>2192</department>
</primary-examiner>
<assistant-examiner>
<last-name>Wang</last-name>
<first-name>Ben C</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">The present invention provides a method for converting source code written in a dynamically typed language into target code written in a statically typed language. The method includes the step of generating in a storage device the target code from the source code, the step of generating the target code including storing in a buffer a signature of a function/method used by a caller in the source code. In this step, generation of an interface class is delayed to a time point immediately before execution of a part of the target code corresponding to the function/method call by the caller, the interface class being needed to generate the caller and serving as an interface in the statically typed language. The method also includes the step of generating in the storage device a consolidated interface class for all signatures stored in the buffer, and loading the generated consolidated interface class from the storage device. In this step, all the signatures in the buffer are deleted upon generation of the consolidated interface class.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="150.54mm" wi="251.63mm" file="US08627281-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="263.65mm" wi="201.00mm" file="US08627281-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="252.05mm" wi="187.37mm" file="US08627281-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="241.81mm" wi="175.77mm" orientation="landscape" file="US08627281-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="248.67mm" wi="164.17mm" orientation="landscape" file="US08627281-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="211.16mm" wi="153.92mm" file="US08627281-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="203.88mm" wi="112.86mm" orientation="landscape" file="US08627281-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="233.00mm" wi="185.25mm" orientation="landscape" file="US08627281-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="260.94mm" wi="175.09mm" file="US08627281-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="258.83mm" wi="180.51mm" orientation="landscape" file="US08627281-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="267.04mm" wi="194.14mm" orientation="landscape" file="US08627281-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="248.67mm" wi="196.85mm" orientation="landscape" file="US08627281-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="261.70mm" wi="185.42mm" orientation="landscape" file="US08627281-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="236.39mm" wi="181.86mm" orientation="landscape" file="US08627281-20140107-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="206.42mm" wi="203.03mm" file="US08627281-20140107-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="169.59mm" wi="153.92mm" file="US08627281-20140107-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00016" num="00016">
<img id="EMI-D00016" he="232.33mm" wi="192.11mm" file="US08627281-20140107-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00017" num="00017">
<img id="EMI-D00017" he="258.15mm" wi="193.46mm" orientation="landscape" file="US08627281-20140107-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00018" num="00018">
<img id="EMI-D00018" he="105.58mm" wi="193.46mm" file="US08627281-20140107-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00019" num="00019">
<img id="EMI-D00019" he="261.62mm" wi="183.90mm" orientation="landscape" file="US08627281-20140107-D00019.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00020" num="00020">
<img id="EMI-D00020" he="233.00mm" wi="175.09mm" orientation="landscape" file="US08627281-20140107-D00020.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00021" num="00021">
<img id="EMI-D00021" he="227.50mm" wi="165.52mm" orientation="landscape" file="US08627281-20140107-D00021.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00022" num="00022">
<img id="EMI-D00022" he="272.46mm" wi="198.20mm" orientation="landscape" file="US08627281-20140107-D00022.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00023" num="00023">
<img id="EMI-D00023" he="260.27mm" wi="192.11mm" orientation="landscape" file="US08627281-20140107-D00023.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00024" num="00024">
<img id="EMI-D00024" he="258.15mm" wi="191.43mm" orientation="landscape" file="US08627281-20140107-D00024.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00025" num="00025">
<img id="EMI-D00025" he="260.94mm" wi="197.53mm" orientation="landscape" file="US08627281-20140107-D00025.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00026" num="00026">
<img id="EMI-D00026" he="226.14mm" wi="175.77mm" orientation="landscape" file="US08627281-20140107-D00026.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00027" num="00027">
<img id="EMI-D00027" he="133.60mm" wi="103.63mm" file="US08627281-20140107-D00027.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00028" num="00028">
<img id="EMI-D00028" he="162.81mm" wi="195.50mm" file="US08627281-20140107-D00028.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00029" num="00029">
<img id="EMI-D00029" he="194.82mm" wi="205.06mm" file="US08627281-20140107-D00029.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00030" num="00030">
<img id="EMI-D00030" he="187.37mm" wi="158.07mm" orientation="landscape" file="US08627281-20140107-D00030.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00031" num="00031">
<img id="EMI-D00031" he="183.22mm" wi="167.56mm" orientation="landscape" file="US08627281-20140107-D00031.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00032" num="00032">
<img id="EMI-D00032" he="166.20mm" wi="164.17mm" orientation="landscape" file="US08627281-20140107-D00032.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00033" num="00033">
<img id="EMI-D00033" he="192.11mm" wi="148.51mm" orientation="landscape" file="US08627281-20140107-D00033.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00034" num="00034">
<img id="EMI-D00034" he="201.00mm" wi="161.46mm" orientation="landscape" file="US08627281-20140107-D00034.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATION(S)</heading>
<p id="p-0002" num="0001">This application claims foreign priority to Japanese Patent application 2009-270506 filed 27 Nov. 2009, the complete disclosure of which is expressly incorporated herein by reference in its entirety for all purposes.</p>
<heading id="h-0002" level="1">FIELD OF THE INVENTION</heading>
<p id="p-0003" num="0002">The present invention relates to the electrical and electronic arts, and, more particularly, to the computer arts and the like.</p>
<heading id="h-0003" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0004" num="0003">Dynamically typed languages such as PHP and Ruby have been widely used these days in web servers and the like. A script written in such a language is often executed by using the interpreter technology. However, some applications require the script to be executed after the conversion into bytecode which runs directly on JAVA Virtual Machine (JAVA VM), for example, in order to achieve a fast execution. In this case, it is difficult to efficiently execute a caller for each method/function while converting source code written in a dynamically typed language into target code written in a statically typed language such as JAVA. In practice, the above script file needs to be compiled during the execution of the source code, and thus a specific concern is in how to efficiently compile the script file. This concern arises mainly for the following two reasons. Firstly, there is no independently defined function in a statically typed language such as JAVA. For this reason, a JAVA class needs to be prepared for each function/method of a dynamically typed language. Secondly, when a caller function/method in a program in a dynamically typed language is converted, the type of its callee cannot be specified in general. The conversion can be made easily by using a reflection mechanism such as JAVA Reflection API. However, the reflection mechanism causes large overhead due to its reflective behavior during runtime.</p>
<p id="p-0005" num="0004">There is a method for the conversion without using the reflection mechanism, in which a class for implementation is prepared for every entity of functions/methods of a dynamically typed language, and the classes thus prepared can be called as a subclass of a specific class serving as a fixed interface. However, with the method, a lot of classes for respective functions/methods must be prepared for implementations of callee functions/methods. Accordingly, an extra memory is calculated for storing metadata required to describe the above classes themselves. This results in an inconvenience that a large portion of a memory area in an execution system such as JAVA VM is consumed.</p>
<p id="p-0006" num="0005">Against this background, there is a requirement of a method capable of reducing memory consumption when converting source code written in a dynamically typed language into target code written in a statically typed language to execute the target code.</p>
<heading id="h-0004" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0007" num="0006">In one aspect, one or more embodiments of the invention provide a method for converting source code written in a dynamically typed language into target code written in a statically typed language. The method includes the step, executed by a computer, of generating in a storage device the target code from the source code, the step of generating the target code including storing in a buffer a signature of a function/method used by a caller in the source code, wherein generation of an interface class is delayed to a time point immediately before execution of a part of the target code corresponding to the function/method call by the caller. The interface class is needed to generate the caller and serves as an interface in the statically typed language. An additional step includes generating in the storage device a consolidated interface class for all signatures stored in the buffer, and loading the generated interface class from the storage device, wherein all the signatures in the buffer are deleted upon generation of the consolidated interface class.</p>
<p id="p-0008" num="0007">In some cases, the method further includes the step, executed by the computer, of generating an implementation class in the storage device and loading the generated implementation class from the storage device when a command to call a function/method in the target code generated from the source code is executed, the implementation class corresponding to the signature of the corresponding function/method used by the caller and being defined for implementation corresponding to the function/method of a callee in the dynamically typed language.</p>
<p id="p-0009" num="0008">In another aspect, one or more embodiments of the invention provide a computer converting source code written in a dynamically typed language into target code written in a statically typed language. The computer includes a generator which generates in a storage device the target code from the source code, and stores in a buffer a signature of a function/method used by a caller in the source code, wherein generation of an interface class is delayed to a time point immediately before execution of a part of the target code corresponding to the function/method call by the caller. The interface class is needed to generate the caller and serves as an interface in the statically typed language. Also included is a first processor which generates in the storage device a consolidated interface class for all signatures stored in the buffer, and loads the generated consolidated interface class from the storage device, wherein all the signatures in the buffer are deleted upon generation of the consolidated interface class.</p>
<p id="p-0010" num="0009">In some cases, the computer further includes a second processor which generates an implementation class when a command to call a function/method in the target code generated from the source code is executed, and loads the generated implementation class, the implementation class corresponding to the signature of the corresponding function/method used by the caller and being defined for implementation corresponding to the function/method of a callee in the dynamically typed language.</p>
<p id="p-0011" num="0010">In some instances, the step of storing a signature in the buffer further includes the step of storing in the buffer not only a signature of a function/method of a caller which appears in a certain conversion unit in the source code, but also a signature of a function/method which appears in a different conversion unit in the source code.</p>
<p id="p-0012" num="0011">In some instances, the step of generating the target code from the source code includes a process of generating a function/method call corresponding to the caller in the source code.</p>
<p id="p-0013" num="0012">In some cases, the process of generating a function/method call includes the steps of checking whether an interface class corresponding to the called function/method has already been generated; if the interface class has not been generated yet, adding the signature of the called function/method to a call function list; and generating in the storage device code corresponding to the function/method call for a target object typed with a not-yet-generated interface class, the code having a name associated with the buffer.</p>
<p id="p-0014" num="0013">In some cases, the process of generating a function/method call further includes the steps of checking whether an interface class corresponding to the called function/method has already been generated; and if the interface class has already been generated, generating in the storage device code of the function/method call for a target object typed with the generated interface class.</p>
<p id="p-0015" num="0014">In some instances, the step of generating the target code from the source code includes generating a function/method declaration corresponding to the caller in the source code.</p>
<p id="p-0016" num="0015">In some instances, the generating of the function/method declaration includes the steps of checking whether a signature of a declared function/method is in the buffer, and whether an interface class corresponding to the declared function/method has already been generated; and adding the signature of the declared function/method to a declaration function list in a case where the signature of the declared function/method is not in the buffer and where the interface class corresponding to the declared function/method has not been generated yet.</p>
<p id="p-0017" num="0016">In some cases, the generating of the function/method declaration includes the steps of checking whether a signature of a declared function/method is in the buffer, and whether an interface class corresponding to the declared function/method has already been generated; and adding a corresponding interface class name to a declaration interface list in either of cases where the signature of the declared function/method is not in the buffer and where the interface class corresponding to the declared function/method has not been generated yet.</p>
<p id="p-0018" num="0017">In some cases, the generating of the function/method declaration further includes generating in the storage device bytecode of a script for a process of the declared function/method; and generating in the storage device code for associating the generated bytecode with the declared function/method.</p>
<p id="p-0019" num="0018">In some instances, the step of generating and loading an interface class further includes checking whether the declaration function list is empty; if the declaration function list is not empty, checking whether an interface class name associated with the buffer exists in the declaration interface list; and if the interface class name associated with the buffer exists, adding to the buffer the signature in the declaration function list and a signature in a call function list.</p>
<p id="p-0020" num="0019">In some instances, the step of generating and loading an interface class further includes the steps of generating in the storage device one interface class from the added signature, and loading the generated interface class from the storage device; and adding a name of the loaded interface class to the declaration interface list.</p>
<p id="p-0021" num="0020">In some instances, the step of generating and loading an interface class further includes the steps of checking whether the declaration function list is empty; if the declaration function list is not empty, checking whether an interface class name associated with the buffer exists in the declaration interface list; and if no interface class name associated with the buffer exists, generating, from the signature in the declaration function list, the consolidated interface class independent of the buffer, and loading the generated consolidated interface class; and adding a name of the loaded interface class to the declaration interface list.</p>
<p id="p-0022" num="0021">In some cases, the step of generating and loading an interface class further includes the steps of checking whether the declaration function list is empty; and if the declaration function list is empty, adding to the buffer a signature in a call function list.</p>
<p id="p-0023" num="0022">In some cases, the step of generating and loading an implementation class further includes the step of preparing in the implementation class a dummy implementation of a function having a signature and not being implemented in a conversion unit in the source code.</p>
<p id="p-0024" num="0023">In some instances, the computer further includes a processor which executes the target code obtained by the conversion.</p>
<p id="p-0025" num="0024">In some instances, the execution step further includes the steps of making a request to load the consolidated interface class for all the signatures stored in the buffer if the consolidated interface class is used; and, in response to the request, generating the consolidated interface class from all the signatures in the buffer, and loading the generated consolidated interface class.</p>
<p id="p-0026" num="0025">The present invention further provides a computer program causing a computer to execute the steps described in any one of the aspects of the method described above.</p>
<p id="p-0027" num="0026">One or more embodiments of the present invention allows reducing memory consumption when converting source code written in a dynamically typed language into target code written in a statically typed language and executing the target code, and thus allows an efficient system establishment.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 1A</figref> shows an example of PHP source code files (start.php, funcs.php) which are written in a PHP language and can be source code to be converted.</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 1B</figref> shows an outline of a JAVA class (Bytecode_start_php) generated from the PHP source code file (start.php) in <figref idref="DRAWINGS">FIG. 1A</figref> through a one script file-to-one class method.</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 1C</figref> shows an outline of a JAVA class (Bytecode_funcs_php) generated from the PHP source code file (funcs.php) in <figref idref="DRAWINGS">FIG. 1A</figref> through the one script File-to-one class method.</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 2A</figref> shows an outline of a JAVA implementation class (Bytecode_start_php) generated from the PHP source code file (start.php) in <figref idref="DRAWINGS">FIG. 1A</figref> through a one function-to-one class method.</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 2B</figref> shows an outline of a group of JAVA implementation classes (Bytecode_funcs_php, Bytecode_funcs_php_foo, Bytecode_funcs_php_bar) generated from the PHP source code file (funcs.php) in <figref idref="DRAWINGS">FIG. 1A</figref> through the one function-to-one class method.</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 2C</figref> shows the implementation classes generated from the PHP source code file (start.php) in <figref idref="DRAWINGS">FIG. 1A</figref> through the one function-to-one class method, and steps of converting source code into target code and executing the target code.</p>
<p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. 3A</figref> shows implementation classes and interface classes generated from the PHP source code in <figref idref="DRAWINGS">FIG. 1A</figref> through a one function-to-one interface method, and steps of converting the source code into target code and executing the target code.</p>
<p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. 3B</figref> shows an outline of an interface class for a function foo( ) and an interface class for a function bar( ) which are generated from the PHP source code in <figref idref="DRAWINGS">FIG. 1A</figref> through the one function-to-one interface method.</p>
<p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. 3C</figref> shows an outline of an implementation class Bytecode_start_php generated from the PHP source code in <figref idref="DRAWINGS">FIG. 1A</figref> through the one function-to-one interface method.</p>
<p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. 3D</figref> shows an outline of an implementation class Bytecode_funcs_php generated from the PHP source code in <figref idref="DRAWINGS">FIG. 1A</figref> through the one function-to-one interface method.</p>
<p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. 4A</figref> shows implementation classes and an interface class generated from the PHP source code in <figref idref="DRAWINGS">FIG. 1A</figref> through a multiple functions-to-one interface method, and steps of converting the source code into target code and executing the target code.</p>
<p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. 4B</figref> shows an outline of the consolidated interface class for functions foo( ) and bar( ) generated from the PHP source code in <figref idref="DRAWINGS">FIG. 1A</figref> through the multiple functions-to-one interface method.</p>
<p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. 4C</figref> shows an outline of the implementation class Bytecode_start_php generated from the PHP source code in <figref idref="DRAWINGS">FIG. 1A</figref> through the multiple functions-to-one interface method.</p>
<p id="p-0041" num="0040"><figref idref="DRAWINGS">FIG. 4D</figref> shows an outline of the implementation class Bytecode_funcs_php generated from the PHP source code in <figref idref="DRAWINGS">FIG. 1A</figref> through the multiple functions-to-one interface method.</p>
<p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. 5</figref> shows differences of interface classes generated through the one function-to-one class method (<figref idref="DRAWINGS">FIGS. 2A to 2C</figref>), the one function-to-one interface method (<figref idref="DRAWINGS">FIGS. 3A to 3D</figref>), and the multiple functions-to-one interface method (<figref idref="DRAWINGS">FIGS. 4A to 4D</figref>).</p>
<p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. 6A</figref> shows flowcharts of a bytecode generation process according to the one function-to-one interface method.</p>
<p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. 6B</figref> shows detailed flowcharts of a process of generating a function/method call (step <b>614</b>) and a process of generating a function/method declaration (step <b>616</b>) which are shown in <figref idref="DRAWINGS">FIG. 6A</figref>.</p>
<p id="p-0045" num="0044"><figref idref="DRAWINGS">FIG. 6C</figref> shows flowcharts of a bytecode generation process according to the multiple functions-to-one interface method.</p>
<p id="p-0046" num="0045"><figref idref="DRAWINGS">FIG. 6D</figref> shows detailed flowcharts of a process of generating a function/method call (step <b>654</b>) and a process of generating a function/method declaration (step <b>656</b>) which are shown in <figref idref="DRAWINGS">FIG. 6C</figref>.</p>
<p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. 6E</figref> shows a detailed flowchart of a buffer process in step <b>643</b> of <figref idref="DRAWINGS">FIG. 6C</figref>.</p>
<p id="p-0048" num="0047"><figref idref="DRAWINGS">FIG. 6F</figref> shows a detailed process flow for the generation and loading of a not-yet-loaded consolidated interface class, which is described in step <b>645</b>-<b>2</b> of <figref idref="DRAWINGS">FIG. 6C</figref>.</p>
<p id="p-0049" num="0048"><figref idref="DRAWINGS">FIG. 7</figref> shows a data structure in which signatures and interface classes are registered, according to an embodiment of the invention.</p>
<p id="p-0050" num="0049"><figref idref="DRAWINGS">FIG. 8A</figref> shows an example where there are three PHP source code files (start.php, caller.php, and funcs.php) which are written in a PHP language and can be a target for conversion, and where a function/method declaration is performed before a function/method call is performed.</p>
<p id="p-0051" num="0050"><figref idref="DRAWINGS">FIG. 8B</figref> shows implementation classes and an interface class generated from the source code shown in <figref idref="DRAWINGS">FIG. 8A</figref> through the multiple functions-to-one interface method, and steps of converting the source code into target code and executing the target code.</p>
<p id="p-0052" num="0051"><figref idref="DRAWINGS">FIG. 9A</figref> shows an example where there are three PHP source code files (start.php, foo.php, and bar.php) which are written in a PHP language and can be source code to be converted, and where a not-yet-defined function appears.</p>
<p id="p-0053" num="0052"><figref idref="DRAWINGS">FIG. 9B</figref> shows implementation classes and an interface class generated from the source code in <figref idref="DRAWINGS">FIG. 9A</figref> through the multiple functions-to-one interface method, and steps of converting the source code into target code and executing the target code.</p>
<p id="p-0054" num="0053"><figref idref="DRAWINGS">FIG. 10A</figref> shows an example of effects seen from reduction in the number of interface classes in a CRM (Customer Relationship Management) application.</p>
<p id="p-0055" num="0054"><figref idref="DRAWINGS">FIG. 10B</figref> shows a relation between a caller and callee of each function/method and a relation between each file inclusion command and the file specified by the command, in the PHP source code files shown in <figref idref="DRAWINGS">FIG. 10A</figref>.</p>
<p id="p-0056" num="0055"><figref idref="DRAWINGS">FIG. 10C</figref> shows steps of converting the PHP source code shown in <figref idref="DRAWINGS">FIG. 10A</figref> into JAVA bytecode and executing the bytecode. <figref idref="DRAWINGS">FIG. 10C</figref> also shows the generation, declaration, call/execution of each function/method in chronological order.</p>
<p id="p-0057" num="0056"><figref idref="DRAWINGS">FIG. 10D</figref> shows implementation classes generated when the PHP source code shown in <figref idref="DRAWINGS">FIG. 10A</figref> is converted through the one function-to-one class method, with the chronological diagram shown in <figref idref="DRAWINGS">FIG. 10C</figref>.</p>
<p id="p-0058" num="0057"><figref idref="DRAWINGS">FIG. 10E</figref> shows implementation classes generated when the PHP source code shown in <figref idref="DRAWINGS">FIG. 10A</figref> is converted through the one function-to-one interface method, with the chronological diagram shown in <figref idref="DRAWINGS">FIG. 10C</figref>.</p>
<p id="p-0059" num="0058"><figref idref="DRAWINGS">FIG. 10F</figref> shows implementation classes generated when the PHP source code shown in <figref idref="DRAWINGS">FIG. 10A</figref> is converted through the multiple functions-to-one interface method, with the chronological diagram shown in <figref idref="DRAWINGS">FIG. 10C</figref>.</p>
<p id="p-0060" num="0059"><figref idref="DRAWINGS">FIG. 11A</figref> is a diagram showing a system for converting source code written in a dynamically typed language into target code written in a statically typed language, according to an embodiment of the invention.</p>
<p id="p-0061" num="0060"><figref idref="DRAWINGS">FIG. 11B</figref> is a diagram showing a relation between an executable object created as a result of conversion and an execution helper, according to an embodiment of the invention.</p>
<p id="p-0062" num="0061"><figref idref="DRAWINGS">FIG. 11C</figref> is a diagram showing the bytecode generator and the signature-interface registration unit, according to an embodiment of the invention.</p>
<p id="p-0063" num="0062"><figref idref="DRAWINGS">FIG. 12</figref> is a block diagram showing computer hardware included in the system of <figref idref="DRAWINGS">FIG. 11A</figref> according to an embodiment of the invention.</p>
<p id="p-0064" num="0063"><figref idref="DRAWINGS">FIG. 13A</figref> shows inclusion relations among the processes in the steps of conversion and execution in <figref idref="DRAWINGS">FIG. 2C</figref>.</p>
<p id="p-0065" num="0064"><figref idref="DRAWINGS">FIG. 13B</figref> shows inclusion relations among the processes in the steps of conversion and execution in <figref idref="DRAWINGS">FIG. 3A</figref>.</p>
<p id="p-0066" num="0065"><figref idref="DRAWINGS">FIG. 13C</figref> shows inclusion relations among the processes in the steps of conversion and execution in <figref idref="DRAWINGS">FIG. 4A</figref>.</p>
<p id="p-0067" num="0066"><figref idref="DRAWINGS">FIG. 13D</figref> shows inclusion relations among the processes in the steps of conversion and execution in <figref idref="DRAWINGS">FIG. 8B</figref>.</p>
<p id="p-0068" num="0067"><figref idref="DRAWINGS">FIG. 13E</figref> shows inclusion relations among the processes in the steps of conversion and execution in <figref idref="DRAWINGS">FIG. 9B</figref>.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0006" level="1">DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS</heading>
<p id="p-0069" num="0068">One or more embodiments relate to a method, a computer program and a computer system for converting source code written in a dynamically typed language into target code written in a statically typed language and executing the target code.</p>
<p id="p-0070" num="0069">Hereinafter, terms used in the claims and the specification are described.</p>
<p id="p-0071" num="0070">In an embodiment of the invention, the term &#x201c;dynamically typed language&#x201d; denotes a language in which the type of a variable is determined not at programming-time or compile-time but at runtime. A dynamically typed language is written by a script, for example. A dynamically typed language includes PHP, Ruby, JAVASCRIPT, Python, and VISUAL BASIC, for example, but is not limited thereto.</p>
<p id="p-0072" num="0071">In an embodiment of the invention, the term &#x201c;source code&#x201d; denotes program code written in a dynamically typed language, and code which is to be converted. Source code may be written by a script.</p>
<p id="p-0073" num="0072">In an embodiment of the invention, the term &#x201c;statically typed language&#x201d; denotes a language in which the type of a variable is determined at programming-time or compile-time. A statically typed language includes .NET, JAVA, and C++, for example, but is not limited thereto.</p>
<p id="p-0074" num="0073">In an embodiment of the invention, the term &#x201c;target code&#x201d; denotes objective code obtained by converting source code. Target code includes intermediate code and machine language. In the case of JAVA, for example, intermediate code indicates bytecode.</p>
<p id="p-0075" num="0074">In an embodiment of the invention, for the term &#x201c;function/method,&#x201d; the definition of a function/method in a dynamically typed language which is a conversion source or in a statically typed language which is a conversion target is applied as it is, although the definition thereof somewhat differs from one language to another. For example, according to the object orientation, a function is defined as implementation of a method, and a method is defined as means to process a message sent to an object.</p>
<p id="p-0076" num="0075">In an embodiment of the invention, the term &#x201c;caller&#x201d; denotes a component which calls a function/method.</p>
<p id="p-0077" num="0076">In an embodiment of the invention, the term &#x201c;callee&#x201d; denotes a component whose function/method is called.</p>
<p id="p-0078" num="0077">In an embodiment of the invention, the term &#x201c;signature&#x201d; denotes a signature for specifying a function/method in a caller which is to be converted, and indicates the name of and the number of arguments (parameters) of a function/method. Since this is a signature in a dynamically typed language, the type of a variable is not required. A signature may include the type of a variable in a language having a feature of a statically typed language as an option.</p>
<p id="p-0079" num="0078">In an embodiment of the invention, the term &#x201c;class serving as an interface&#x201d; (interface class) denotes a class which is needed to generate a caller in source code and serves as an interface in a statically typed language. In an interface class, a function/method is only defined and code for realizing its specific operation is not implemented. For example, an interface in JAVA corresponds to an interface class. In an embodiment of the invention, the generation of an interlace class is not performed until a command to call a function/method by a caller in source code is executed, i.e., the generation is delayed to a time point immediately before the execution of a part of target code corresponding to the call for the function/method by the caller in the source code. In other words, an interlace class is generated at the time point immediately before the execution of the part of the target code corresponding to the call for the function/method, or at a time point prior to the time point. The time point prior to the execution of the part of the target code corresponding to the call depends on how a virtual machine is implemented in the case of JAVA, for example. The part of the target code corresponding to the call indicates code including a caller, and is the main body of a method in the case of JAVA, for example.</p>
<p id="p-0080" num="0079">In an embodiment of the invention, the term &#x201c;class for implementation&#x201d; (implementation class) denotes a class which corresponds to the signature of a function/method included in source code and used by a caller, and which is defined for implementation corresponding to a callee function/method in a dynamically typed language. In addition, code for realizing the operations of a function/method and its variable is implemented in an implementation class. In the case of JAVA, for example, an implementation class corresponds to a class which implements all functions/methods defined not in the corresponding abstract class but in the corresponding interface. An instance necessary for execution of a program is generated by an implementation class, and thus the program is executed. In an embodiment of the invention, an implementation class is generated upon execution of a command to call a function/method in target code corresponding to source code.</p>
<p id="p-0081" num="0080">In an embodiment of the invention, the term &#x201c;conversion and execution&#x201d; denotes converting source code written in a dynamically typed language into target code written in a statically typed language, and executing the converted target code. In an embodiment of the invention, this &#x201c;conversion&#x201d; is also called compilation. In the execution, an interface class and an implementation class are used.</p>
<p id="p-0082" num="0081">Hereinafter, an embodiment of the invention is described in accordance with the drawings. It should be understood that this embodiment is provided to illustrate a preferred embodiment of the invention, and not intended to limit the scope of the invention to a scope described herein. Further, the same reference numeral denotes the same object throughout the drawings, unless otherwise noted.</p>
<p id="p-0083" num="0082">PHP is taken as an example of a dynamically typed language and JAVA is taken as an example of a statically typed language below. However, the invention is not limited thereto.</p>
<p id="p-0084" num="0083"><figref idref="DRAWINGS">FIG. 1A</figref> shows an example of PHP source code files (start.php, funcs.php) which are written in a PHP language which can be source code to be converted.</p>
<p id="p-0085" num="0084">The PHP source code tiles include two source code files, i.e., start.php (<b>101</b>) and funcs.php (<b>102</b>). The arrow <b>103</b> indicates a correlation between an inclusion command include in the source code of the file start.php (<b>101</b>) and the file funcs.php (<b>102</b>) specified by the inclusion command. The arrow <b>104</b> indicates a correlation between a caller function foo( ) and the corresponding callee function declared and defined. Likewise, the arrow <b>105</b> indicates a correlation between a caller function bar( ) and the corresponding callee function declared and defined. Note that, these files are sometimes called script files meaning that they are written in a dynamically typed language.</p>
<p id="p-0086" num="0085">Next, a description is given of problems of conventional techniques observed when PHP source code is converted into bytecode, by using the PHP source code files (start.php, funcs.php) in <figref idref="DRAWINGS">FIG. 1A</figref>.</p>
<p id="p-0087" num="0086">The difference in behavior of a symbol table between a dynamically typed language and a statically typed language poses a problem when source code written in a dynamically typed language such as PHP is converted into bytecode of a statically typed language such as JAVA, and the bytecode is executed. Here, a symbol denotes a character string for specifying the name of a variable, a class, a method, or a function. A symbol table is a table which stores therein a correlation between a symbol and an entity of a variable, a class, or the like indicated by the symbol. Consider in particular a case where implementations of multiple functions/methods written in PHP are brought together into a single JAVA class, which is a compilation unit, in order to reduce the number of classes in JAVA which is a language of a conversion target. In this case, a method of efficiently implementing the functions/methods into the class is unclear.</p>
<p id="p-0088" num="0087">For example, consider an example where the two PHP source code files (<b>101</b>, <b>102</b>) in <figref idref="DRAWINGS">FIG. 1A</figref> are compiled to correspond respectively to JAVA classes.</p>
<p id="p-0089" num="0088">First consider a method where one function/method in PHP source code is assigned one JAVA class. This method is hereinafter called a one function-to-one class method. The one function-to-one class method will be described in detail by using <figref idref="DRAWINGS">FIGS. 2A to 2C</figref>. The one function-to-one class method involves the generation of numerous classes and the loading of the classes. For this reason, this method causes a problem of an increase in memory footprint or of overhead in the management of classes.</p>
<p id="p-0090" num="0089">Meanwhile, consider a method where one script file in PHP source code is assigned one JAVA class. This method is hereinafter called a one script file-to-one class method. In the one script file-to-one class method, two JAVA implementation classes, i.e., Bytecode_start_php (<b>111</b>, <figref idref="DRAWINGS">FIG. 1B</figref>) and Bytecode_funcs_php (<b>112</b>, <figref idref="DRAWINGS">FIG. 1C</figref>) arc generated to correspond respectively to the PHP source code files (start.php (<b>101</b>) and funcs.php (<b>102</b>)), as shown in <figref idref="DRAWINGS">FIGS. 1B and 1C</figref>. Here, the above names of the JAVA classes are given at random.</p>
<p id="p-0091" num="0090"><figref idref="DRAWINGS">FIG. 1B</figref> shows an outline of the JAVA class (Bytecode_start_php) (<b>111</b>) generated from the PHP source code file (start.php) in <figref idref="DRAWINGS">FIG. 1A</figref> through the one script file-to-one class method.</p>
<p id="p-0092" num="0091"><figref idref="DRAWINGS">FIG. 1C</figref> shows an outline of the JAVA class (Bytecode_funcs_php) (<b>112</b>) generated from the PHP source code file (funcs.php) in <figref idref="DRAWINGS">FIG. 1A</figref> through the one script file-to-one class method.</p>
<p id="p-0093" num="0092">In <figref idref="DRAWINGS">FIGS. 1B and 1C</figref>, the JAVA classes (Bytecode_start_php, Bytecode_funcs_php) (<b>111</b>, <b>112</b>) are shown by using JAVA source code for the sake of readability. However, the JAVA classes (Bytecode_start_php, Bytecode_funcs_php) (<b>111</b>, <b>112</b>) are actually written in JAVA bytecode equivalent to JAVA source code.</p>
<p id="p-0094" num="0093">Execution starts from a call for a method executeScript( ) of the JAVA class Bytecode_start_php (<b>111</b>) in <figref idref="DRAWINGS">FIG. 1B</figref> (A<b>02</b>). An include command in line <b>3</b> of <figref idref="DRAWINGS">FIG. 1B</figref> (A<b>03</b>) is a command to specify and include the file funcs.php (<b>102</b>). The JAVA class Bytecode_funcs_php (<b>112</b>) in <figref idref="DRAWINGS">FIG. 1C</figref> corresponds to the file funcs.php (<b>102</b>) shown in <figref idref="DRAWINGS">FIG. 1A</figref>. The include command (A<b>03</b>) calls a method executeScript( ) in line <b>2</b> of the JAVA class Bytecode_funcs_php (<b>112</b>) in <figref idref="DRAWINGS">FIG. 1C</figref> (B<b>02</b>). Here, the term &#x201c;PHPValue&#x201d; in line <b>8</b> of <figref idref="DRAWINGS">FIG. 1C</figref> (B<b>08</b>) denotes a class for holding values used in a PHP program.</p>
<p id="p-0095" num="0094">What presents a problem in <figref idref="DRAWINGS">FIG. 1B</figref> is how functions foo( ) and bar( ) called in line <b>4</b> (A<b>04</b>) and line <b>5</b> (A<b>05</b>) are implemented. In a PHP program, it is not until a script including the declaration of a function/method is executed (in lines <b>3</b> and <b>4</b> of <figref idref="DRAWINGS">FIG. 1C</figref>) that how the function/method called by the declared name is implemented is fixed. Accordingly, it is generally not possible to implement each function as a static method, and to call the functions foo( ) and bar( ) in <figref idref="DRAWINGS">FIG. 1B</figref> simply through a static method call (invokestatic command, for example). This is because what kind of function/method is actually to be called varies depending on the past execution status. If code for a call is generated assuming a specific callee, it is impossible to cope with a case where a different function is declared in a process of a request to call a callee other than the assumed callee, for example. Further, in the case of the above example and the like, a callee often remains unknown until the implementation class (<b>111</b>) corresponding to the caller script file start.php (<b>101</b>) is actually run, in other words, until the included file funcs.php is read and run. The above problems can be resolved by using the JAVA reflection mechanism, or by performing class loading for every declaration. These workarounds, however, incur enormous overhead during runtime.</p>
<p id="p-0096" num="0095">These problems occur essentially due to a difference in ways of resolving symbols between a script language such as PHP or Ruby and JAVA language. In JAVA, the location of the definition for an entity of a class or method corresponding to a certain symbol is implicitly fixed to a specific class file through classpath. Moreover, in JAVA, a program of a typical server-side application such as Servlet is written on the assumption that a correlation between a symbol and an entity of a class or method is the same throughout multiple request processes. Since a language such as PHP or Ruby, on the other hand, is designed in a way to include a step of causing an entity to correspond to a certain symbol for every request process, a program of an application using the language is also written in the same way. Here, the step of causing an entity to correspond to a certain symbol is equivalent to the process of declare function in the above example.</p>
<p id="p-0097" num="0096"><figref idref="DRAWINGS">FIGS. 2A to 2C</figref> show an application example of the one function-to-one class method.</p>
<p id="p-0098" num="0097">A typical way of solving the above problems without using the JAVA reflection mechanism is to use a JAVA method call mechanism. In the way of using the method call mechanism: a fixed interface (or an abstract class) such as PHPFunction is set as a class serving as an interface; one implementation class which implements the interface is generated for each PHP function; and a function/method is always called through the corresponding interface, as shown in <figref idref="DRAWINGS">FIG. 2A</figref>. However, in bytecode generated by the one function-to-one class method, a lot of implementation classes are consequently generated from the single script file funcs.php, as shown in <figref idref="DRAWINGS">FIG. 2B</figref>.</p>
<p id="p-0099" num="0098"><figref idref="DRAWINGS">FIGS. 2A to 2C</figref> show an example where the one function-to-one class method is applied to the PHP source code files (start.php, funcs.php) shown in <figref idref="DRAWINGS">FIG. 1A</figref>.</p>
<p id="p-0100" num="0099"><figref idref="DRAWINGS">FIG. 2A</figref> shows an outline of a JAVA implementation class (Bytecode_start_php) generated from the PHP source code file (start.php) in <figref idref="DRAWINGS">FIG. 1A</figref> through the one function-to-one class method. The name of the class is given at random. In addition, the implementation class is shown by using JAVA source code for the sake of readability. However, the JAVA implementation class (Bytecode_start_php) (<b>201</b>) is actually written in JAVA bytecode equivalent to JAVA source code.</p>
<p id="p-0101" num="0100">The implementation class (Bytecode_start_php) (<b>201</b>) is generated in bytecode to correspond to the PHP file start.php (<b>101</b>).</p>
<p id="p-0102" num="0101">The term constant_Hello in line <b>5</b> (C<b>05</b>) of <figref idref="DRAWINGS">FIG. 2A</figref> is a constant representing a character string literal corresponding to &#x201c;Hello&#x201d; in the original PHP program before conversion (see <b>101</b> in <figref idref="DRAWINGS">FIG. 1A</figref>), and is implemented as a class variable. Values of various types can be taken as an argument of the function bar( ) which is implementation of a function call, in accordance with the original PHP program (<b>101</b>). Moreover, the return value for this function can be used in various ways. However, these have no direct relation with the invention, and thus will not be described herein.</p>
<p id="p-0103" num="0102"><figref idref="DRAWINGS">FIG. 2B</figref> shows an outline of a group of JAVA implementation classes (Bytecode_funcs_php, Bytecode_funcs_php_foo, Bytecode_funcs_php_bar) generated from the PHP source code file (funcs.php) in <figref idref="DRAWINGS">FIG. 1A</figref> through the one function-to-one class method. These implementation classes are written in separate class files. The above names of the classes are given at random. Moreover, the implementation classes are shown by using JAVA source code for the sake of readability. However, the JAVA implementation classes (<b>202</b>, <b>203</b>, <b>204</b>) are actually written in JAVA bytecode equivalent to JAVA source code.</p>
<p id="p-0104" num="0103">With the conversion through the one function-to-one class method, the three JAVA implementation classes, i.e., Bytecode_funcs_php (<b>202</b>), Bytecode_funcs_php_foo (<b>203</b>), and Bytecode_funcs_php_bar (<b>204</b>) arc generated from the single PHP file funcs.php (<b>102</b>), as shown in <figref idref="DRAWINGS">FIG. 213</figref>. In other words, multiple implementation classes are generated from a single script file. A large amount of memory is required to generate and load multiple implementation classes. For this reason, the generation and loading of multiple implementation classes cause a problem of an increase in memory footprint or of overhead in the management of classes.</p>
<p id="p-0105" num="0104"><figref idref="DRAWINGS">FIG. 2C</figref> shows the implementation classes generated from the PHP source code file (start.php) in <figref idref="DRAWINGS">FIG. 1A</figref> through the one function-to-one class method, and steps of converting source code into target code and executing the target code.</p>
<p id="p-0106" num="0105">In <figref idref="DRAWINGS">FIG. 2C</figref>, the left-hand side shows the steps of conversion and execution (E<b>01</b> to E<b>12</b>). The right-hand side shows implementation classes (<b>211</b>, <b>212</b>, <b>213</b>, and <b>214</b>) generated through the one function-to-one class method. As shown in <figref idref="DRAWINGS">FIG. 2C</figref>, in the one function-to-one class method, one class is prepared per function in source code. The right-hand side also shows how a function executeScript( ) of the implementation class (<b>211</b>) calls, as its implementation contents, invoke( ) through a fixed interface (<b>215</b>). The implementation classes are shown with boxes (<b>211</b>, <b>212</b>, <b>213</b>, <b>214</b>, and <b>215</b>). The numbers (E<b>02</b> and E<b>05</b>) in arrows given on the left-hand side of the implementation classes correspond respectively to the step numbers of the above steps.</p>
<p id="p-0107" num="0106">The implementation classes in <figref idref="DRAWINGS">FIG. 2C</figref> each extend (extends) or implement (implements) a class serving as a common interface. The common interface denotes an interface previously prepared in a language system and can be used in common (PHPFunction in line <b>11</b> (D<b>11</b>) and line <b>21</b> (D<b>21</b>) of <figref idref="DRAWINGS">FIG. 2B</figref>, and the common interface in line <b>2</b> (E<b>02</b>) of <figref idref="DRAWINGS">FIG. 2C</figref>).</p>
<p id="p-0108" num="0107">Hereinafter, the steps of conversion and execution are described.</p>
<p id="p-0109" num="0108">In line <b>1</b> (E<b>01</b>), a command include to include the PHP file start.php (<b>101</b>) is directed. The steps in lines <b>2</b> to <b>12</b> (E<b>02</b> to E<b>12</b>) are executed as sub-steps of E<b>01</b>.</p>
<p id="p-0110" num="0109">In line <b>2</b> (F<b>02</b>), the generation and loading of the implementation class corresponding to a caller of the functions foo( ) and bar( ) in the PHP file start.php (<b>101</b> in <figref idref="DRAWINGS">FIG. 1A</figref>) are directed. According to the directions, the implementation class Bytecode_start_php (<b>211</b>) corresponding to the file start.php is generated with a method call for a target object typed with the common interface, as shown by the arrow (E<b>02</b>). Code for the class Bytecode_start_php is shown in <figref idref="DRAWINGS">FIG. 2A</figref>. In lines <b>4</b> (C<b>04</b>) and <b>5</b> (C<b>05</b>), the common interface PHPFunction is specified in bytecode as an interface provided with a method invoke( ) although not shown in source code.</p>
<p id="p-0111" num="0110">In line <b>3</b> (E<b>03</b>), the execution of the loaded class Bytecode_start_php (<b>211</b>) is directed. Specifically, the steps C<b>02</b> to C<b>06</b> of the implementation class Bytecode_start_php (<b>201</b>) shown in <figref idref="DRAWINGS">FIG. 2A</figref> are executed. First, a command executeScript( ) of step C<b>02</b> is executed.</p>
<p id="p-0112" num="0111">In line <b>4</b> (E<b>04</b>), an inclusion command include of step C<b>03</b> in <figref idref="DRAWINGS">FIG. 2A</figref> is executed, and thus the specified file funcs.php (<b>102</b> in <figref idref="DRAWINGS">FIG. 1A</figref>) is included.</p>
<p id="p-0113" num="0112">In line <b>5</b> (E<b>05</b>), the generation and loading of an implementation class corresponding to the specified file funcs.php are directed. According to the directions, the implementation class Bytecode_funcs_php (<b>212</b>) corresponding to the file funcs.php is generated and loaded, as shown by the arrow (E<b>05</b>).</p>
<p id="p-0114" num="0113">In line <b>6</b> (E<b>06</b>), the execution of the implementation class Bytecode_funcs_php (<b>212</b>) is directed. Specifically, a command executeScript( ) in line <b>2</b> (D<b>02</b>) of the class Bytecode_funcs_php (<b>202</b>) shown in <figref idref="DRAWINGS">FIG. 2B</figref> is executed.</p>
<p id="p-0115" num="0114">In line <b>7</b> (E<b>07</b>), functions foo( ) and bar( ) in lines <b>3</b> (D<b>03</b>) and <b>4</b> (D<b>04</b>) in <figref idref="DRAWINGS">FIG. 2B</figref> are subsequently declared. With this declaration, function names foo and bar of these functions are associated with function objects (entities) respectively created from the implementation classes Bytecode_funcs_php_foo (<b>203</b>) and Bytecode_funcs_php_bar (<b>204</b>) corresponding to the functions.</p>
<p id="p-0116" num="0115">In line <b>8</b> (E<b>08</b>), the registration of the function objects to a function table is directed. In the function table, a correlation between the signature of a function and an object of an entity for the function (object of an implementation class, for example) is recorded. Thereby, a function call is associated with a function object (entity) actually performing a process, and the execution of the class Bytecode_funcs_php (<b>202</b>) ends. Then, the process returns to step C<b>04</b> of the implementation class Bytecode_start_php (<b>201</b>).</p>
<p id="p-0117" num="0116">In line <b>9</b> (E<b>09</b>), the execution of step C<b>04</b> of the class Bytecode_start<sub>&#x2014; </sub>php (<b>201</b>), i.e., a call for the function foo( ) by the function name foo is directed.</p>
<p id="p-0118" num="0117">In line <b>10</b> (E<b>10</b>), the function foo( ) registered in the function table in E<b>08</b> is executed in response to the call for the function foo( ).</p>
<p id="p-0119" num="0118">In lines <b>11</b> (E<b>11</b>) and <b>12</b> (F<b>12</b>), the same processes as in lines <b>9</b> (E<b>09</b>) and <b>10</b> (E<b>10</b>) are executed for the function bar( ).</p>
<p id="p-0120" num="0119"><figref idref="DRAWINGS">FIGS. 3A to 3C</figref> show how the number of interface classes generated through a method of preparing one interface for each function (hereinafter called a one function-to-one interface method) is increased.</p>
<p id="p-0121" num="0120">In the one function-to-one interface method, an interface class is prepared per caller of one function/method. This allows consolidating implementations of multiple functions/methods into one JAVA class in target code. In the one function-to-one interface method, the implementation class of PHP functions/methods implements all interface classes corresponding to required functions/methods (see <b>301</b> and <b>302</b> of <figref idref="DRAWINGS">FIG. 3A</figref>). In addition, a call part of a PHP function/method makes a call through the corresponding interface class (see <b>304</b> of <figref idref="DRAWINGS">FIG. 3A</figref>). A call through an interface class is made through invoke interface, for example. Invoke interface is an example to be used in a case where <b>304</b> in <figref idref="DRAWINGS">FIG. 3A</figref> is represented in actual bytecode.</p>
<p id="p-0122" num="0121"><figref idref="DRAWINGS">FIG. 3A</figref> shows implementation classes and interface classes generated from the PHP source code in <figref idref="DRAWINGS">FIG. 1A</figref> through the one function-to-one interface method, and steps of converting the source code into target code and executing the target code.</p>
<p id="p-0123" num="0122">In <figref idref="DRAWINGS">FIG. 3A</figref>, the left-hand side shows the steps of conversion and execution (F<b>01</b> to F<b>13</b>). The right-hand side shows implementation classes (<b>303</b> and <b>304</b>) and interface classes (<b>301</b> and <b>302</b>) generated through the one function-to-one interface method. The right-hand side also shows how the implementation class (<b>303</b>) calls, as its implementation contents functions foo( ) and bar( ) through the interface classes (<b>307</b>). As shown in <figref idref="DRAWINGS">FIG. 3A</figref>, in the one function-to-one interface method, the interface classes (<b>301</b>, <b>302</b>) are prepared for respective caller functions/methods, and the implementation classes (<b>303</b>, <b>304</b>) are generated to correspond to the interface classes (<b>301</b>, <b>302</b>). The numbers (F<b>02</b>, F<b>03</b>, and F<b>06</b>) in arrows given on the left-hand side of the implementation classes and interface classes correspond respectively to the step numbers of the above steps.</p>
<p id="p-0124" num="0123">Arrows (<b>305</b> and <b>306</b>) indicate that the implementation class (<b>304</b>) implements the two interface classes (<b>301</b> and <b>302</b>).</p>
<p id="p-0125" num="0124"><figref idref="DRAWINGS">FIG. 3B</figref> shows an outline of the interface class for the function foo( ) and the interface class for the function bar( ) which are generated from the PHP source code in <figref idref="DRAWINGS">FIG. 1A</figref> through the one function-to-one interface method.</p>
<p id="p-0126" num="0125">The outline of the interface class (<b>301</b>) in <figref idref="DRAWINGS">FIG. 3A</figref> is shown as the interface class (<b>311</b>). Likewise, the outline of the interface class (<b>302</b>) in <figref idref="DRAWINGS">FIG. 3A</figref> is shown as the interface class (<b>312</b>).</p>
<p id="p-0127" num="0126">The interface class (<b>311</b>) is an interface class for the function foo( ), whereas the interface class (<b>312</b>) is an interface class for the function bar( ). The interface classes (<b>311</b> and <b>312</b>) are shown by using JAVA source code for the sake of readability.</p>
<p id="p-0128" num="0127"><figref idref="DRAWINGS">FIG. 3C</figref> shows an outline of an implementation class generated from the PEW source code in <figref idref="DRAWINGS">FIG. 1A</figref> through the one function-to-one interface method.</p>
<p id="p-0129" num="0128">The outline of the implementation class (<b>303</b>) in <figref idref="DRAWINGS">FIG. 3A</figref> is shown as the implementation class (<b>321</b>). The implementation class (<b>321</b>) corresponds to the PHP source code file (start.php) (<b>101</b>). The implementation class (<b>321</b>) is shown by using JAVA source code for the sake of readability.</p>
<p id="p-0130" num="0129"><figref idref="DRAWINGS">FIG. 3D</figref> shows an outline of an implementation class generated from the PHP source code in <figref idref="DRAWINGS">FIG. 1A</figref> through the one function-to-one interface method.</p>
<p id="p-0131" num="0130">The outline of the implementation class (<b>304</b>) in <figref idref="DRAWINGS">FIG. 3A</figref> is shown as the implementation class (<b>322</b>). The implementation class (<b>322</b>) corresponds to the PHP source code file (funcs.php) (<b>102</b>). The implementation class (<b>322</b>) is shown by using JAVA source code for the sake of readability.</p>
<p id="p-0132" num="0131">Hereinafter, the steps of conversion and execution shown in <figref idref="DRAWINGS">FIG. 3A</figref> are described.</p>
<p id="p-0133" num="0132">In line <b>1</b> (F<b>01</b>), a command include to include the script file start.php (<b>101</b>) which is a PHP source code file is directed. The steps in lines <b>2</b> to <b>13</b> (F<b>02</b> to F<b>13</b>) are executed as sub-steps of F<b>01</b>.</p>
<p id="p-0134" num="0133">In line <b>2</b> (F<b>02</b>), the generation and loading of an implementation class corresponding to a caller of the functions boo( ) and bar( ) in the PHP file start.php (<b>101</b>) are directed. According to the directions, the implementation class Bytecode_start_php (<b>303</b>) corresponding to the file start.php (<b>101</b>) is generated, as shown by the arrow (F<b>02</b>). Code for the class Bytecode_start_php (<b>303</b>) is shown in <b>321</b> of <figref idref="DRAWINGS">FIG. 3C</figref>.</p>
<p id="p-0135" num="0134">In line <b>3</b> (F<b>03</b>), the generation and loading of the interface classes for use in the calls for the respective functions foo( ) and bar( ) are directed. According to the directions, the two interface classes (<b>301</b> and <b>302</b>) are generated and loaded, as shown by the arrow (F<b>03</b>). Here, code for the interface classes (<b>301</b> and <b>302</b>) is shown in <b>311</b> and <b>312</b> of <figref idref="DRAWINGS">FIG. 3B</figref>.</p>
<p id="p-0136" num="0135">In line <b>4</b> (F<b>04</b>), the execution of the caller implementation class (<b>303</b>) thus loaded is directed. Thereby, a script execution command executeScript( ) of step H<b>02</b> of the implementation class is executed, as shown in the code (<b>321</b>) of the implementation class in <figref idref="DRAWINGS">FIG. 3C</figref>.</p>
<p id="p-0137" num="0136">In line <b>5</b> (F<b>05</b>), the inclusion command include in step H<b>03</b> is executed with the execution of the script execution command executeScript( ) of step H<b>02</b>, and thus the specified file funcs.php is included. At this point, the implementation class Bytecode_start_php (<b>303</b>) corresponding to the file start.php (<b>101</b>), which is being executed, is suspended, and the process moves to the generation and loading of an implementation class (<b>304</b>) corresponding to the newly included PHP file funcs.php (<b>102</b>).</p>
<p id="p-0138" num="0137">In line <b>6</b> (F<b>06</b>), the generation and loading of bytecode for the implementation class Bytecode_funcs_php (<b>304</b>) corresponding to the included file funcs.php are directed. According to the directions, the implementation class (<b>304</b>) corresponding to the file funcs.php is generated and loaded, as shown by the arrow (F<b>06</b>). Here, code for the implementation class (<b>304</b>) is shown in <b>322</b> of <figref idref="DRAWINGS">FIG. 31</figref>). The implementation class (<b>304</b>) is generated while implementing the interface classes Function_foo and Function_bar.</p>
<p id="p-0139" num="0138">In line <b>7</b> (F<b>07</b>), the execution of the implementation class (<b>304</b>, <b>322</b> of <figref idref="DRAWINGS">FIG. 3D</figref>) corresponding to the file funcs.php is directed, and a script execution command executeScript of step (<b>102</b>) shown in <figref idref="DRAWINGS">FIG. 3D</figref> is executed. Hereinbelow, the execution of the implementation class (<b>304</b>) continues till line <b>9</b> (F<b>09</b>).</p>
<p id="p-0140" num="0139">In line <b>8</b> (F<b>08</b>), function declaration commands declareFunction in steps (<b>103</b> and <b>104</b>) are executed followed by the execution of the script execution command executeScript. By the execution of the function declaration commands declareFunction, instances for executing calls for the functions foo( ) and bar( ) are created by the implementation class (<b>304</b>, <b>322</b> of <figref idref="DRAWINGS">FIG. 3D</figref>) itself.</p>
<p id="p-0141" num="0140">In line <b>9</b> (F<b>09</b>), the functions foo( ) and bar( ) are registered in execution contexts (declareFunction( )). Specifically, the created instances and function names foo and bar of the called functions foo( ) and bar( ) are registered in association with each other in a function table. This registration is made in order to search, upon function call, the function table for the corresponding instance, and to process the function call by use of methods foo( ) and bar( ) included in the instance thus searched out. With the above processes, the execution of the implementation class Bytecode_funcs_php (<b>304</b>) is completed. The process thereafter returns to the execution of the suspended implementation class Bytecode_start_php (<b>303</b>).</p>
<p id="p-0142" num="0141">In line <b>10</b> (F<b>10</b>), the function foo( ) is called by using JAVA bytecode obtained by conversion. Specifically, as shown in step H<b>04</b> of the implementation class Bytecode_start_php (<b>303</b>) (<b>321</b> of <figref idref="DRAWINGS">FIG. 3C</figref>) having been suspended, the function table is searched by the called function name foo, and the associated instance is thus found.</p>
<p id="p-0143" num="0142">In line <b>11</b> (F<b>11</b>), the function foo( ) is executed. Specifically, the function foo( ) is executed by calling and executing a method foo( ) (corresponding to the function foo( ) included in the found instance. In this event, the instance is cast so as to have its type adaptable to the type defined in the interface class Function_foo (<b>301</b>, <b>311</b> of <figref idref="DRAWINGS">FIG. 3B</figref>).</p>
<p id="p-0144" num="0143">In line <b>12</b> (F<b>12</b>), the function bar( ) is called by using JAVA bytecode obtained by conversion. Specifically, as shown in step H<b>05</b> of the implementation class Bytecode_start_php (<b>303</b>) (<b>321</b> of <figref idref="DRAWINGS">FIG. 3C</figref>) having been suspended, the function table is searched by the called function name bar, and the associated instance is thus found.</p>
<p id="p-0145" num="0144">In line <b>13</b> (F<b>13</b>), the function bar( ) is executed. Specifically, the function bar( ) is executed by calling and executing a method bar( ) (corresponding to the function bar( )) included in the found instance. In this event, the instance is cast so as to have its type adaptable to the type defined in the interface class Function_bar (<b>302</b>, <b>312</b> of <figref idref="DRAWINGS">FIG. 3B</figref>).</p>
<p id="p-0146" num="0145">Note that, in addition to the above, some consideration actually needs to be made to deal with various numbers of parameters. However, this has no direct relation with the invention, and thus will not be described herein.</p>
<p id="p-0147" num="0146">As described above, in the one function-to-one interface method, an interface class needs to be generated and loaded for every function/method to be called. Thus, the one function-to-one interface method eliminates the need for preparing an implementation class for every function/method unlike the one function-to-one class method. In the meantime, the one function-to-one interface method causes the need for preparing an interface class for every function/method. As a consequence, a lot of interface classes need to be generated as a whole. An interface class basically has the same feature as a class, and is of large volume. With all of these taken into account, it can be said that the one function-to-one interface method has no noticeable difference from the one function-to-one class method.</p>
<p id="p-0148" num="0147">With <figref idref="DRAWINGS">FIGS. 4A to 4D</figref>, a description is given of a method of consolidating multiple functions/methods to be called into one interface class (hereinafter called a multiple functions-to-one interface method) according to an embodiment of the invention. In the multiple functions-to-one interface method, generated and loaded interface classes are consolidated into one interface class on a per-compilation basis (on a file basis, for example). This allows reducing the number of interface classes, and thus contributes to a reduction in the amount of memory consumption. The above interface class thus consolidated is hereinafter called a consolidated interface class.</p>
<p id="p-0149" num="0148">In the multiple functions-to-one interface method, while implementations of multiple functions/methods in source code are consolidated into one implementation class, interface classes are speculatively collected irrespective of the implementation class. Here, the expression &#x201c;speculatively&#x201d; denotes &#x201c;at every time of encounter with a function call in source code,&#x201d; and depends on the source code in this respect. The speculative collection of interface classes allows reducing the number of interface classes required for target code generation.</p>
<p id="p-0150" num="0149">One or more embodiments of the invention cause a caller function/method in a dynamically typed language to correspond to an interface class (abstract class) in a statically typed language, instead of causing the function/method to correspond directly to a class in the statically typed language as in the one function-to-one class method. This allows generating bytecode corresponding to a caller efficiently even in a case where a callee implementation class is not fixed or changes during runtime.</p>
<p id="p-0151" num="0150"><figref idref="DRAWINGS">FIG. 4A</figref> shows implementation classes and a consolidated interface class generated from the PHP source code in <figref idref="DRAWINGS">FIG. 1A</figref> through the multiple functions-to-one interface method, and steps of converting the source code into target code and executing the target code.</p>
<p id="p-0152" num="0151">In <figref idref="DRAWINGS">FIG. 4A</figref>, the left-hand side shows the steps of conversion and execution (J<b>01</b> to J<b>18</b>). The right-hand side shows implementation classes (<b>403</b> and <b>404</b>) and a consolidated interface class (<b>402</b>) generated through the multiple functions-to-one interface method. As shown in <figref idref="DRAWINGS">FIG. 4A</figref>, in the multiple functions-to-one interface method, the one consolidated interface class (<b>402</b>) is generated for the caller of multiple functions/methods, and the implementation class (<b>404</b>) implementing the consolidated interface class (<b>402</b>) is generated. The right-hand side also shows how the implementation class (<b>403</b>) calls, as its implementation contents, functions foo( ) and bar( ) through the consolidated interface (<b>406</b>). The numbers (J<b>02</b>, J<b>03</b>, J<b>05</b>, and J<b>09</b>) in arrows given on the left-hand side of the implementation classes (<b>403</b> and <b>404</b>) and consolidated interface class (<b>402</b>) correspond respectively to the step numbers of the above steps.</p>
<p id="p-0153" num="0152">A buffer (<b>401</b>) is a storage used for storing temporality the signature of each caller function/method. One consolidated interface class is generated by using at least one signature stored in the buffer. In other words, a consolidated interface class is generated not for each caller but on a per-compilation basis (on a script file basis, for example). The buffer (<b>401</b>) may be included in a bytecode generator (<b>1106</b>) which will be described with <figref idref="DRAWINGS">FIG. 11A</figref>, or in a memory of another JAVA VM. In an embodiment of the invention, the buffer (<b>401</b>) is employed for using a consolidated interface class.</p>
<p id="p-0154" num="0153">In the multiple functions-to-one interface method, a consolidated interface class is not immediately generated from multiple caller functions/methods. Instead, signatures of the respective multiple functions/methods are first just stored in the buffer (<b>401</b>). The name of a consolidated interface class is determined to correspond to the buffer, and signatures of functions/methods are stored in the buffer on a compilation basis. For example, it is possible to store, in the buffer, not only the signature of a function/method which appears in a certain compilation unit (in a source code file, or the like) and is used by a caller, but also the signature of a function/method which appears in a different compilation unit obtained by parsing such as a process of including a script. For example, the signature of a function/method other than the function/methods foo( ) and bar( ) may be stored in the buffer. It is not until the caller implementation class (<b>403</b>) is executed that one consolidated interface class (<b>402</b>) for all the signatures stored in the buffer (<b>401</b>) is generated in a storage device. Then, the implementation class (<b>404</b>) implementing the one consolidated interface class (<b>402</b>) is generated when a call for any of the corresponding function/methods is executed.</p>
<p id="p-0155" num="0154"><figref idref="DRAWINGS">FIG. 4B</figref> shows an outline of the consolidated interface class for the functions foo( ) and bar( ) generated from the PHP source code in <figref idref="DRAWINGS">FIG. 1A</figref> through the multiple functions-to-one interface method.</p>
<p id="p-0156" num="0155">The outline of the consolidated interface class (<b>402</b>) in <figref idref="DRAWINGS">FIG. 4A</figref> is shown as a consolidated interface class (<b>411</b>). The consolidated interface class (<b>411</b>) is an interface class for both of the functions foo( ) and bar( ). The consolidated interface class (<b>411</b>) is shown by using JAVA source code for the sake of readability.</p>
<p id="p-0157" num="0156"><figref idref="DRAWINGS">FIG. 4C</figref> shows an outline of the implementation class Bytecode_start_php generated from the PHP source code in <figref idref="DRAWINGS">FIG. 1A</figref> through the multiple functions-to-one interface method.</p>
<p id="p-0158" num="0157">The outline of the implementation class (<b>403</b>) in <figref idref="DRAWINGS">FIG. 4A</figref> is shown as the implementation class (<b>421</b>). The implementation class (<b>421</b>) corresponds to the PHP source code (start.php) (<b>101</b>). The implementation class (<b>421</b>) is shown by using JAVA source code for the sake of readability.</p>
<p id="p-0159" num="0158"><figref idref="DRAWINGS">FIG. 4D</figref> shows an outline of the implementation class Bytecode_funcs_php generated from the PHP source code in <figref idref="DRAWINGS">FIG. 1A</figref> through the multiple functions-to-one interface method.</p>
<p id="p-0160" num="0159">The outline of the implementation class (<b>404</b>) in <figref idref="DRAWINGS">FIG. 4A</figref> is shown as the implementation class (<b>422</b>). The implementation class (<b>422</b>) corresponds to the PHP source code (funcs.php) (<b>102</b>). The implementation class (<b>422</b>) is shown by using JAVA source code for the sake of readability.</p>
<p id="p-0161" num="0160">Hereinafter, the steps of conversion and execution shown in <figref idref="DRAWINGS">FIG. 4A</figref> are described.</p>
<p id="p-0162" num="0161">In line <b>1</b> (J<b>01</b>), a command include to include the script file start.php (<b>101</b> in <figref idref="DRAWINGS">FIG. 1A</figref>) which is a PHP source code file is directed. The steps in lines <b>2</b> to <b>18</b> (J<b>02</b> to J<b>18</b>) are executed as sub-steps of J<b>01</b>.</p>
<p id="p-0163" num="0162">In line <b>2</b> (J<b>02</b>), the generation of an implementation class corresponding to a caller of the functions foo( ) and bar( ) in the PHP file start.php (<b>101</b> in <figref idref="DRAWINGS">FIG. 1A</figref>) is directed. According to the directions, the implementation class Bytecode_start_php (<b>403</b>) corresponding to the file start.php (<b>101</b> in <figref idref="DRAWINGS">FIG. 1A</figref>) is generated, as shown by the arrow (J<b>02</b>). Bytecode for the class Bytecode_start_php (<b>403</b>) is shown in <b>421</b> of <figref idref="DRAWINGS">FIG. 4C</figref>.</p>
<p id="p-0164" num="0163">In line <b>3</b> (J<b>03</b>), the storing of signatures of the respective called functions foo( ) and bar( ) in the buffer (<b>401</b>) is directed. According to the directions, the signatures thereof are stored in the buffer (<b>401</b>), as shown by the arrow (J<b>03</b>). The storing of the signatures is made in order to delay the generation and loading of an interface class to a phase where implementation code corresponding to a caller is actually executed.</p>
<p id="p-0165" num="0164">In line <b>4</b> (J<b>04</b>), the implementation class Bytecode_start_php (<b>403</b>) is loaded into a JAVA VM.</p>
<p id="p-0166" num="0165">In line <b>5</b> (J<b>05</b>), the taking out of the buffer (<b>401</b>) of signatures of the respective called functions foo( ) and bar( ), and the generation and loading of the consolidated interface class (<b>402</b>) are directed. According to the directions, the consolidated interface class (<b>402</b>) is generated as shown by the arrow (J<b>05</b>). Here, code for the consolidated interface class (<b>402</b>) is shown in <b>411</b> of <figref idref="DRAWINGS">FIG. 4B</figref>.</p>
<p id="p-0167" num="0166">In this way, the loading of the class (interface) is requested, through a class loader (<b>1107</b> of <figref idref="DRAWINGS">FIG. 11A</figref>), not at a timing when implementation code corresponding to a caller is generated (in line <b>2</b> (J<b>02</b>)) but at a timing when the implementation code is loaded (in line <b>4</b> (J<b>04</b>)) or, more preferably, executed. Thus, it is not until the timing when the implementation code is loaded or executed that the interface class including all methods corresponding to the signatures pooled in the buffer is generated and loaded. If the interface class already exists, the loading thereof is simply performed.</p>
<p id="p-0168" num="0167">In line <b>6</b> (J<b>06</b>), the execution of the caller implementation class (<b>403</b>) thus loaded is directed. Thereby, a script execution command executeScript( ) of step L<b>02</b> of the implementation class is executed, as shown in the code (<b>421</b>) of the implementation class in <figref idref="DRAWINGS">FIG. 4C</figref>.</p>
<p id="p-0169" num="0168">In line <b>7</b> (J<b>07</b>), the execution of an inclusion command include of step L<b>03</b> is directed followed by step L<b>02</b>, and thus the specified file funcs.php (<b>102</b>) is included. At this point, the implementation class Bytecode_start_php (<b>403</b>) corresponding to the file start.php (<b>101</b>), which is being executed, is suspended, and the process moves to the generation, loading, and execution of the implementation class (<b>404</b>) corresponding to the newly included PHP file funcs.php (<b>102</b>).</p>
<p id="p-0170" num="0169">In line <b>8</b> (J<b>08</b>), it is checked whether there is an interface class or consolidated interface class (<b>402</b>) corresponding to calls for the functions foo( ) and bar( ) which are defined in the file funcs.php (<b>102</b>). A consolidated interface including the calls for the functions foo( ) and bar( ) is newly generated and loaded if no corresponding interface class exists; however, this is not the case.</p>
<p id="p-0171" num="0170">In line <b>9</b> (J<b>09</b>), the generation and loading of bytecode for the implementation class (<b>404</b>, <b>422</b> of <figref idref="DRAWINGS">FIG. 4D</figref>) corresponding to the included file funcs.php (<b>102</b> of <figref idref="DRAWINGS">FIG. 1A</figref>) are directed. According to the directions, the implementation class (<b>404</b>) corresponding to the file funcs.php (<b>102</b> of <figref idref="DRAWINGS">FIG. 1A</figref>) is generated and loaded, as shown by the arrow (J<b>09</b>). Here, code for the implementation class (<b>404</b>) is shown in <b>422</b> of <figref idref="DRAWINGS">FIG. 4D</figref>. The implementation class (<b>404</b>) is generated with declaration that it implements the consolidated interface class Callsite_start_php (<b>411</b>).</p>
<p id="p-0172" num="0171">In this respect, the loading of an implementation class for functions in a source language is delayed until the execution of the functions is required. It should be noted here that, in a case where all the code in a script needs to be generated, loaded, and executed to interpret and execute the script, such delay does not mean anything since the code such as executeScript( ) needs to be executed immediately in this case; however, in a case where the interpretation and execution of a script involves the execution of the compiled code in the script using the interpreter technology, it is also possible to first register functions defined in the file funcs.php only without generating the code such as executeScript( ), for example. The reason why the loading of the implementation class is delayed is that the loading of the implementation class requires the loading of an interface class implemented by this implementation class, and that the more the loading of the interface class is delayed, the larger number of signatures the interface class can collect and thus the more beneficial the interface class can be. When the implementation class is loaded, the signature of a function/method which has not been defined in any other interface yet is added to the buffer for signatures (such a request is found if there is a class referenced by the implementation class when the class loader loads the implementation class, and if the class loader tries to solve this problem). Here, if the implementation involves neither the implementation nor use of functions corresponding to signatures in the buffer, a signature list may be separately prepared. If a function not yet used (i.e., implementation of the function) is defined in the implementation class, a consolidated interface class including the signature of the function is prepared, and then generated and loaded.</p>
<p id="p-0173" num="0172">In line <b>10</b> (J<b>10</b>), the execution of the implementation class (<b>404</b>) corresponding to the file funcs.php is directed, and a script execution command executeScript of step (M<b>02</b>) shown in <figref idref="DRAWINGS">FIG. 4D</figref> is executed.</p>
<p id="p-0174" num="0173">In line <b>11</b> (J<b>11</b>), a function declaration command declareFunction is executed in steps (M<b>03</b> and M<b>04</b>) followed by step (M<b>02</b>). By the execution of the function declaration command declareFunction, instances for executing calls for the functions foo( ) and bar( ) are created by the implementation class (<b>404</b>, <b>422</b> of <figref idref="DRAWINGS">FIG. 4D</figref>) itself.</p>
<p id="p-0175" num="0174">In line <b>12</b> (J<b>12</b>), the created instances and function names foo and bar for the called functions foo( ) and bar( ) are registered in association with each other in a function table. This registration is made in order to search, upon function call, the function table for the corresponding instance, and to process the function call by use of methods foo( ) and bar( ) included in the instance thus searched out. With the above processes, the execution of the implementation class (<b>404</b>) ends. The process thereafter moves to steps (L<b>04</b> and L<b>05</b>) next to branched step (L<b>03</b>) of the implementation class (<b>402</b>, <b>421</b> of <figref idref="DRAWINGS">FIG. 4C</figref>).</p>
<p id="p-0176" num="0175">In line <b>13</b> (J<b>13</b>), a call for the function foo( ) (invoke foo( )) is executed by step described above (L<b>04</b>).</p>
<p id="p-0177" num="0176">In line <b>14</b> (J<b>14</b>), as a preparation phase of step (L<b>04</b>), the function table is searched by the called function name foo, and the associated instance is thus found.</p>
<p id="p-0178" num="0177">In line <b>15</b> (J<b>15</b>), the function foo( ) is executed by calling and executing a method foo( ) (corresponding to the function foo( )) included in the found instance. In this event, the instance is cast so as to have its type adaptable to the type defined in the consolidated interface class Callsite_start_php (<b>402</b>, <b>411</b> of <figref idref="DRAWINGS">FIG. 4B</figref>).</p>
<p id="p-0179" num="0178">In line <b>16</b> (J<b>16</b>), a call for the function bar( ) (invoke bar( )) is executed by step described above (L<b>05</b>).</p>
<p id="p-0180" num="0179">In line <b>17</b> (J<b>17</b>), as a preparation phase of step (L<b>05</b>), the function table is searched by the called function name bar, and the associated instance is thus found.</p>
<p id="p-0181" num="0180">In line <b>18</b> (J<b>18</b>), the function bar( ) is executed by calling and executing a method bar( ) (corresponding to the function bar( )) included in the found instance. In this event, the instance is cast so as to have its type adaptable to the type defined in the consolidated interface class Callsite_start_php (<b>402</b>, <b>411</b> of <figref idref="DRAWINGS">FIG. 4B</figref>).</p>
<p id="p-0182" num="0181">With the above processes, the steps of converting a PHP script into JAVA bytecode and executing the bytecode end.</p>
<p id="p-0183" num="0182"><figref idref="DRAWINGS">FIG. 5</figref> shows differences of interface classes generated through the one function-to-one class method (<figref idref="DRAWINGS">FIGS. 2A to 2C</figref>), the one function-to-one interface method (<figref idref="DRAWINGS">FIGS. 3A to 3D</figref>), and the multiple functions-to-one interface method (<figref idref="DRAWINGS">FIGS. 4A to 4D</figref>).</p>
<p id="p-0184" num="0183">Reference numeral <b>501</b> indicates the implementation classes (<b>211</b>, <b>212</b>, <b>213</b>, and <b>214</b>) generated through the one function-to-one class method (<figref idref="DRAWINGS">FIGS. 2A to 2C</figref>).</p>
<p id="p-0185" num="0184">Reference numeral <b>502</b> indicates the interface classes (<b>301</b>, <b>302</b>) and the class (<b>304</b>) for the implementations (<b>305</b>, <b>306</b>) of the interface classes (<b>301</b>, <b>302</b>), which are generated through the one function-to-one interface method (<figref idref="DRAWINGS">FIGS. 3A to 3D</figref>).</p>
<p id="p-0186" num="0185">Reference numeral <b>503</b> indicates the consolidated interface class (<b>402</b>) and the class (<b>404</b>) for the implementation (<b>405</b>) of the consolidated interface class (<b>402</b>), which are generated through the multiple functions-to-one interface method (<figref idref="DRAWINGS">FIGS. 4A to 4D</figref>).</p>
<p id="p-0187" num="0186">The number of interface classes generated through the one function-to-one interface method is two. On the other hand, the number of consolidated interface classes generated through the multiple functions-to-one interface method is one.</p>
<p id="p-0188" num="0187">Note that, in the above example, a description is given of an example where the consolidated interface class includes two functions/methods. However, the multiple functions-to-one interface method can also be employed for a case of more than two functions/methods actually. Accordingly, only one interface class is needed by application of the multiple functions-to-one interface method, thereby allowing a reduction in the number of JAVA interface classes to be generated and loaded.</p>
<p id="p-0189" num="0188"><figref idref="DRAWINGS">FIGS. 6A and 6B</figref> show flowcharts of a bytecode generation process according to the one function-to-one interface method, and <figref idref="DRAWINGS">FIGS. 6C</figref>, <b>6</b>D, and <b>6</b>E show flowcharts of a bytecode generation process according to the multiple functions-to-one interface method.</p>
<p id="p-0190" num="0189"><figref idref="DRAWINGS">FIGS. 6A and 6B</figref> show the flowcharts of the bytecode generation process according to the one function-to-one interface method (<figref idref="DRAWINGS">FIGS. 3A to 3D</figref>).</p>
<p id="p-0191" num="0190">The process flow on the left-hand side of <figref idref="DRAWINGS">FIG. 6A</figref> (steps <b>601</b> to <b>605</b>) is a main flow showing the following process. Specifically, the process is to generate bytecode written in JAVA of a statically typed language out of source code written in a dynamically typed language according to the one function-to-one interface method in a state where none of data is cached yet, and to cache the generated bytecode. The bytecode is generated by the bytecode generator (<b>1106</b>) shown in <figref idref="DRAWINGS">FIG. 11A</figref>.</p>
<p id="p-0192" num="0191">In step <b>601</b>, the bytecode generator starts a process of converting source code written in a dynamically typed language to target code written in a statically typed language. Hereinafter, the description is given by taking a PHP language as an example of a dynamically typed language and a JAVA language as an example of a statically typed language. However, the invention is not limited to these languages. The source code is a script written in a PHP language in the case of a PHP language, and the target code is bytecode in the case of a JAVA language.</p>
<p id="p-0193" num="0192">In step <b>602</b>, the bytecode generator generates bytecode corresponding to the above script, and stores the generated bytecode into the storage device. The detailed processes of step <b>602</b> will be described later in steps <b>611</b> to <b>619</b>, steps <b>621</b> to <b>626</b>, and steps <b>631</b> to <b>638</b>.</p>
<p id="p-0194" num="0193">In step <b>603</b>, the bytecode generator executes the loading, into a JAVA VM, of a part of the generated bytecode as an implementation class having an interface listed in a declaration interface list (<b>1135</b> of <figref idref="DRAWINGS">FIG. 11C</figref>). Here, the declaration interface list (<b>1135</b>) is a list of interface class names, and is a list to which an interface class name is added in step <b>634</b> of <figref idref="DRAWINGS">FIG. 6B</figref>. Note that, as will be described later, the declaration interface list (<b>1135</b>) is used also in the multiple functions-to-one interface method which is an embodiment of the invention; however, a declaration function list (<b>1136</b> of <figref idref="DRAWINGS">FIG. 11C</figref>) and a call function list (<b>1137</b> of <figref idref="DRAWINGS">FIG. 11C</figref>) used in the multiple functions-to-one interface method are not used in the one function-to-one interface method.</p>
<p id="p-0195" num="0194">Note that, an implementation class is generated and loaded in steps <b>602</b> and <b>603</b>. In these steps, the implementation class is generated when a script file is loaded into a memory and converted into bytecode.</p>
<p id="p-0196" num="0195">In step <b>604</b>, a JAVA program execution unit (hereinafter called program execution unit) (<b>1118</b> of <figref idref="DRAWINGS">FIG. 11A</figref>) executes the generated bytecode. The detailed processes of step <b>604</b> will be described later in steps <b>604</b>-<b>1</b> to <b>604</b>-<b>7</b>.</p>
<p id="p-0197" num="0196">In step <b>605</b>, the program execution unit (or a PHP runtime helper (<b>1105</b> of <figref idref="DRAWINGS">FIG. 11A</figref>)) terminates the process of the script.</p>
<p id="p-0198" num="0197">The detailed processes of step <b>602</b> in <figref idref="DRAWINGS">FIG. 6A</figref> are described in accordance with a process flow shown in the middle of <figref idref="DRAWINGS">FIG. 6A</figref> (steps <b>611</b> to <b>619</b>).</p>
<p id="p-0199" num="0198">In step <b>611</b>, the bytecode generator starts the process of generating bytecode corresponding to the script (<b>602</b>).</p>
<p id="p-0200" num="0199">In step <b>612</b>, the bytecode generator recognizes each command in the PHP script, and iterates a determination process in step <b>613</b>, or in each of steps <b>613</b> and <b>615</b> which will be described below.</p>
<p id="p-0201" num="0200">In step <b>613</b>, the bytecode generator determines whether or not the recognized command is a function/method call. If the command is a function/method call (YES), the process moves to step <b>614</b>. On the other hand, if the command is not a function/method call (NO), the process moves to step <b>615</b>.</p>
<p id="p-0202" num="0201">In step <b>614</b>, the bytecode generator executes a process of generating a function/method call. Upon completion of this generation process, the process moves to step <b>618</b>. The detailed processes of step <b>614</b> will be described later in steps <b>621</b> to <b>626</b>.</p>
<p id="p-0203" num="0202">If determining that the recognized command is not a function/method call, the bytecode generator determines whether or not the command is a function/method declaration in step <b>615</b>. If the command is a function/method declaration (YES), the process moves to step <b>616</b>. On the other hand, if the command is not a function/method declaration (NO), the process moves to step <b>617</b>.</p>
<p id="p-0204" num="0203">In step <b>616</b>, the bytecode generator executes a process of generating a function/method declaration. Upon completion of this generation process, the process moves to step <b>618</b>. The detailed processes of step <b>616</b> will be described later in steps <b>631</b> to <b>638</b>.</p>
<p id="p-0205" num="0204">If determining that the recognized command is neither function/method call nor function/method declaration, the bytecode generator executes a process of generating bytecode corresponding to the command in step <b>617</b>. The detailed bytecode generation process has no direct relation with an embodiment of the invention, and thus will not be described in detail herein.</p>
<p id="p-0206" num="0205">In step <b>618</b>, the bytecode generator determines whether or not there is any command to be processed. If there is any command to be processed, the process returns to step <b>612</b> and iterates the above determinations. If there is no more command to be processed, the process moves to step <b>619</b>.</p>
<p id="p-0207" num="0206">In step <b>619</b>, the bytecode generator completes the process of generating bytecode corresponding to the script (<b>611</b>), and the process returns to step <b>602</b> from which the flow branches.</p>
<p id="p-0208" num="0207">The detailed processes of step <b>604</b> in <figref idref="DRAWINGS">FIG. 6A</figref> are shown in a process flow on the right-hand side of <figref idref="DRAWINGS">FIG. 6A</figref> (steps <b>604</b>-<b>1</b> to <b>604</b>-<b>7</b>). For the sake of convenience of description, steps <b>604</b>-<b>1</b> to <b>604</b>-<b>7</b> will be described after a description of <figref idref="DRAWINGS">FIG. 6B</figref>.</p>
<p id="p-0209" num="0208"><figref idref="DRAWINGS">FIG. 6B</figref> shows detailed flowcharts of the process of generating a function/method call (step <b>614</b>) and the process of generating a function/method declaration (step <b>616</b>) which are shown in <figref idref="DRAWINGS">FIG. 6A</figref>.</p>
<p id="p-0210" num="0209">The detailed processes of step <b>614</b> are described in accordance with a process flow shown on the left-hand side of <figref idref="DRAWINGS">FIG. 6B</figref> (steps <b>621</b> to <b>626</b>).</p>
<p id="p-0211" num="0210">In step <b>621</b>, the bytecode generator starts the process of generating a function/method call by a caller in source code.</p>
<p id="p-0212" num="0211">In step <b>622</b>, the bytecode generator checks whether or not an interface class corresponding to the called function/method has already been generated. Whether or not the interface class has already been generated is determined by using a data structure in which signatures and interface classes are registered. Note that, the data structure is basically the same as that shown in <figref idref="DRAWINGS">FIG. 7</figref> except that registered interface class names are different from one row to another.</p>
<p id="p-0213" num="0212">In step <b>623</b>, if the bytecode generator determines that the interface class corresponding to the called function/method has not been generated yet (NO), the process moves to step <b>625</b>. On the other hand, the process moves to step <b>624</b> if the bytecode generator determines that the interface class corresponding to the called function/method has already been generated (YES).</p>
<p id="p-0214" num="0213">In step <b>625</b>, since the interface class corresponding to the called function/method has not been generated yet, the bytecode generator generates the interface class by an appropriate name which is unique so that the interface class can be loaded into the JAVA VM as needed. Here, the interface class is named to be unique by numbering, for example. In this event, a set of the signature of the called function/method and the interface name is registered in the data structure of <figref idref="DRAWINGS">FIG. 7</figref>. Once the loading is completed, the process moves to step <b>624</b>.</p>
<p id="p-0215" num="0214">In step <b>624</b>, the bytecode generator generates code corresponding to a function/method call through the interface class corresponding to the called function/method. The code thus generated is bytecode to be executed in steps <b>604</b>-<b>1</b> to <b>604</b>-<b>7</b>. Once the code corresponding to the function/method call is generated, the process moves to step <b>626</b>. Note that, step <b>624</b> corresponds to the lines H<b>04</b> and H<b>05</b> in <figref idref="DRAWINGS">FIG. 3C</figref>, and is executed immediately after the line F<b>03</b> as a part of the line F<b>02</b> of <figref idref="DRAWINGS">FIG. 3A</figref>.</p>
<p id="p-0216" num="0215">In step <b>626</b>, the bytecode generator completes the process of generating the function/method call (<b>621</b>), and the process returns to step <b>614</b> from which the flow branches.</p>
<p id="p-0217" num="0216">Next, the detailed processes of step <b>616</b> are described in accordance with a process flow shown on the right-hand side of <figref idref="DRAWINGS">FIG. 6B</figref>.</p>
<p id="p-0218" num="0217">In step <b>631</b>, the bytecode generator starts the process of generating a declaration of a function/method in source code (<b>616</b>).</p>
<p id="p-0219" num="0218">In step <b>632</b>, the bytecode generator checks whether or not an interface class corresponding to the declared function/method has already been generated. This check is made on the basis of whether or not there is the signature of the corresponding function in the data structure in <figref idref="DRAWINGS">FIG. 7</figref> in which signatures and interface classes are registered. Here, a signature is defined for each function in the data structure.</p>
<p id="p-0220" num="0219">In step <b>633</b>, if the bytecode generator determines that the interface class corresponding to the declared function/method has not been generated yet (NO), the process moves to step <b>635</b>. On the other hand, the process moves to step <b>634</b> if the bytecode generator determines that the interface class has already been generated (YES).</p>
<p id="p-0221" num="0220">In step <b>635</b>, the bytecode generator generates the interface class corresponding to the declared function/method by an appropriate name which is named to be unique (by numbering, for example), and loads the generated interface class. In this event, a set of the signature of the declared function/method and the interface name is registered in the data structure of <figref idref="DRAWINGS">FIG. 7</figref>. Once the loading is completed, the process moves to step <b>634</b>.</p>
<p id="p-0222" num="0221">In step <b>634</b>, the bytecode generator adds the interface name of the generated interface class to the declaration interface list. Here, the declaration interface list indicates a data structure in which the name of a caller interface (interface class name) corresponding to the declared function/method is held in a list format.</p>
<p id="p-0223" num="0222">In step <b>636</b>, the bytecode generator generates, in a memory (<b>1101</b> of <figref idref="DRAWINGS">FIG. 11A</figref>), bytecode corresponding to a script for a process of the declared function/method (i.e., the contents of the function/method). The bytecode thus generated is bytecode to be executed in steps <b>604</b>-<b>1</b> to <b>604</b>-<b>7</b>. The detailed bytecode generation process is equivalent to the recursion of step <b>611</b> of <figref idref="DRAWINGS">FIG. 6A</figref> described above.</p>
<p id="p-0224" num="0223">In step <b>637</b>, the bytecode generator generates, in the memory (<b>1101</b>), code for associating the generated bytecode with the declared function/method. The code thus generated is bytecode to be executed in steps <b>604</b>-<b>1</b> to <b>604</b>-<b>7</b>. The code generated in step <b>637</b> is code to be registered in a symbol table (<b>1109</b> of <figref idref="DRAWINGS">FIG. 11A</figref>). This code is referenced by, for example, the function lookupFunction( ) shown in the lines H<b>04</b> and <b>1105</b> of <figref idref="DRAWINGS">FIG. 3C</figref>. In other words, the code generated in step <b>637</b> is code for associating the implementation of each function in the bytecode generated in step <b>636</b> with the name of the function.</p>
<p id="p-0225" num="0224">In step <b>638</b>, the bytecode generator completes the process of generating the function/method declaration (<b>631</b>), and the process returns to step <b>616</b> from which the flow branches.</p>
<p id="p-0226" num="0225">The detailed processes of step <b>604</b> in <figref idref="DRAWINGS">FIG. 6A</figref> are described in accordance with the process flow on the right-hand side of <figref idref="DRAWINGS">FIG. 6A</figref> (steps <b>604</b>-<b>1</b> to <b>604</b>-<b>7</b>).</p>
<p id="p-0227" num="0226">In step <b>604</b>-<b>1</b>, the JAVA program execution unit (hereinafter called program execution unit) starts the execution of the bytecode generated in each of steps <b>624</b>, <b>636</b>, and <b>637</b> as a part of step <b>602</b>, and loaded into the JAVA VM in step <b>603</b>.</p>
<p id="p-0228" num="0227">In step <b>604</b>-<b>2</b>, the program execution unit reads each instruction in the generated bytecode.</p>
<p id="p-0229" num="0228">In step <b>604</b>-<b>3</b>, the program execution unit determines whether or not the read instruction represents &#x201c;include&#x201d; or a process corresponding to &#x201c;include.&#x201d;</p>
<p id="p-0230" num="0229">If the read instruction represents &#x201c;include&#x201d; or a process corresponding to &#x201c;include,&#x201d; the program execution unit executes a process for the script in step <b>604</b>-<b>4</b>.</p>
<p id="p-0231" num="0230">If the read instruction represents neither &#x201c;include&#x201d; nor a process corresponding to &#x201c;include,&#x201d; the program execution unit executes a process according to other instructions in step <b>604</b>-<b>5</b>. The process according to other instructions is not the essence of the invention, and thus will not be described herein.</p>
<p id="p-0232" num="0231">In step <b>604</b>-<b>6</b>, the process returns to step <b>604</b>-<b>2</b> until the reading of all the instructions in the bytecode is completed.</p>
<p id="p-0233" num="0232">In step <b>604</b>-<b>7</b>, the execution of the bytecode is completed, and the process returns to step <b>604</b> from which the flow branches.</p>
<p id="p-0234" num="0233"><figref idref="DRAWINGS">FIGS. 6C</figref>, <b>6</b>D, and <b>6</b>E show flowcharts of a bytecode generation process according to the multiple functions-to-one interface method (<figref idref="DRAWINGS">FIGS. 4A to 4D</figref>).</p>
<p id="p-0235" num="0234">The process flow on the left-hand side of <figref idref="DRAWINGS">FIG. 6C</figref> (steps <b>641</b> to <b>646</b>) is a main flow showing the following process. Specifically, the process is to generate bytecode written in JAVA of a statically typed language out of source code written in a dynamically typed language according to the multiple functions-to-one interface method in a state where none of data is cached yet, and to cache the generated bytecode. The bytecode is generated by the bytecode generator (<b>1106</b>) shown in <figref idref="DRAWINGS">FIG. 11A</figref>.</p>
<p id="p-0236" num="0235">Note that, among steps in <figref idref="DRAWINGS">FIG. 6C</figref>, the steps which are each either different from or added to those in the one function-to-one interface method of <figref idref="DRAWINGS">FIG. 6A</figref> are shown in a hatched manner (steps <b>643</b> and <b>645</b>-<b>2</b>).</p>
<p id="p-0237" num="0236">In step <b>641</b>, the bytecode generator starts a process of converting source code written in a dynamically typed language to target code written in a statically typed language. Hereinafter, the description is given by taking a PHP language as an example of a dynamically typed language and a JAVA language as an example of a statically typed language. However, the invention is not limited to these languages. The source code is a script written in a PHP language in the case of a PIP language, and the target code is bytecode in the case of a JAVA language.</p>
<p id="p-0238" num="0237">In step <b>642</b>, the bytecode generator generates bytecode from the above script, and stores the generated bytecode into the storage device. The detailed processes of step <b>642</b> will be described later in steps <b>651</b> to <b>659</b>, steps <b>661</b> to <b>667</b>, and steps <b>671</b> to <b>678</b>.</p>
<p id="p-0239" num="0238">In step <b>643</b>, the bytecode generator executes a process for the buffer. This buffer process is a process of clearing the buffer, only in a case where the generated implementation class includes a declaration of a function corresponding to any one of signatures in the buffer. The declaration function list (<b>1136</b> of <figref idref="DRAWINGS">FIG. 11C</figref>) and the call function list (<b>1137</b> of <figref idref="DRAWINGS">FIG. 11C</figref>) are provided for use in this process. In the buffer process, according to conditions, any one of the following three processes is executed with reference to the declaration function list and the call function list. The three processes include: the process where a consolidated interface class is generated from signatures in the buffer (<b>1133</b> of <figref idref="DRAWINGS">FIG. 11C</figref>), and is loaded (<b>688</b> of <figref idref="DRAWINGS">FIG. 6E</figref>); the process where an interface class is generated from signatures in the declaration function list (<b>1136</b>), and is loaded (<b>686</b> of <figref idref="DRAWINGS">FIG. 6E</figref>); and the process where no interface class is generated (path from <b>682</b> to <b>683</b> of <figref idref="DRAWINGS">FIG. 6E</figref>). The detailed processes of the buffer process will be shown later in steps <b>681</b> to <b>689</b> below. Step <b>643</b> is peculiar to the multiple functions-to-one interface method, and is not provided in the one function-to-one interface method shown in <figref idref="DRAWINGS">FIG. 6A</figref>.</p>
<p id="p-0240" num="0239">In step <b>644</b>, the bytecode generator loads, into the JAVA VM, and executes the generated bytecode as a class having an interface listed in the declaration interface list. Here, the declaration interface list includes a list of signatures as similar to the buffer. The declaration interface list is a signature list separately prepared according to the above sentence &#x201c;if the implementation involves neither the implementation nor use of functions corresponding to signatures in the buffer, a signature list may be separately prepared.&#x201d;</p>
<p id="p-0241" num="0240">Note that, an implementation class is generated and loaded in steps <b>642</b> to <b>644</b>, and is generated when a script file is loaded into a memory and converted into bytecode. An implementation class is generated for every source code script file.</p>
<p id="p-0242" num="0241">In step <b>645</b>, the program execution unit (<b>1118</b> of <figref idref="DRAWINGS">FIG. 11A</figref>) executes the generated bytecode. The detailed processes of step <b>645</b> will be shown later in steps <b>645</b>-<b>1</b> to <b>645</b>-<b>8</b> below.</p>
<p id="p-0243" num="0242">In step <b>646</b>, the program execution unit (or PHP runtime helper (<b>1105</b> of <figref idref="DRAWINGS">FIG. 11A</figref>)) terminates the process for the script.</p>
<p id="p-0244" num="0243">The detailed processes of step <b>642</b> are described in accordance with a process flow in the middle of <figref idref="DRAWINGS">FIG. 6C</figref> (steps <b>651</b> to <b>659</b>). The process flow (steps <b>651</b> to <b>659</b>) is basically the same as the process flow described in <figref idref="DRAWINGS">FIG. 6A</figref> (steps <b>611</b> to <b>619</b>) except for the detailed processes of the process of generating a function/method call (step <b>654</b>) and the detailed processes of the process of generating a function/method declaration (step <b>656</b>).</p>
<p id="p-0245" num="0244">In step <b>651</b>, the bytecode generator starts the process of generating bytecode corresponding to the script (<b>642</b>).</p>
<p id="p-0246" num="0245">In step <b>652</b>, the bytecode generator recognizes each command in the PHP script, and iterates a determination process in step <b>653</b>, or in each of steps <b>653</b> and <b>655</b> which will be described below.</p>
<p id="p-0247" num="0246">In step <b>653</b>, the bytecode generator determines whether or not the recognized command is a function/method call. If the command is a function/method call (YES), the process moves to step <b>654</b>. On the other hand, if the command is not a function/method call (NO), the process moves to step <b>655</b>.</p>
<p id="p-0248" num="0247">In step <b>654</b>, the bytecode generator executes a process of generating a function/method call. Upon completion of this generation process, the process moves to step <b>658</b>. The detailed processes of step <b>654</b> will be described later in steps <b>661</b> to <b>667</b>.</p>
<p id="p-0249" num="0248">If determining that the recognized command is not a function/method call, the bytecode generator determines whether or not the command is a function/method declaration in step <b>655</b>. If the command is a function/method declaration (YES), the process moves to step <b>656</b>. On the other hand, if the command is not a function/method declaration (NO), the process moves to step <b>657</b>.</p>
<p id="p-0250" num="0249">In step <b>656</b>, the bytecode generator executes a process of generating a function/method declaration. Upon completion of this generation process, the process moves to step <b>658</b>. The detailed processes of step <b>656</b> will be described later in steps <b>671</b> to <b>678</b>.</p>
<p id="p-0251" num="0250">If determining that the recognized command is neither function/method call nor function/method declaration, the bytecode generator executes a process of generating bytecode corresponding to the command in step <b>657</b>. The detailed bytecode generation process has no direct relation with an embodiment of the invention, and thus will not be described in detail herein.</p>
<p id="p-0252" num="0251">In step <b>658</b>, the bytecode generator determines whether or not there is any command to be processed. If there is any command to be processed, the process returns to step <b>652</b> and iterates the above determinations. If there is no more process to be processed, the process moves to step <b>659</b>.</p>
<p id="p-0253" num="0252">In step <b>659</b>, the bytecode generator completes the process of generating bytecode corresponding to the script (<b>651</b>), and the process returns to step <b>642</b> from which the flow branches.</p>
<p id="p-0254" num="0253">The detailed processes of step <b>645</b> in <figref idref="DRAWINGS">FIG. 6C</figref> are shown in a process flow on the right-hand side of <figref idref="DRAWINGS">FIG. 6C</figref> (steps <b>645</b>-<b>1</b> to <b>645</b>-<b>8</b>). For the sake of convenience of description, steps <b>645</b>-<b>1</b> to <b>645</b>-<b>8</b> will be described after a description of <figref idref="DRAWINGS">FIG. 6E</figref>.</p>
<p id="p-0255" num="0254"><figref idref="DRAWINGS">FIG. 6D</figref> shows detailed flowcharts of the process of generating a function/method call (step <b>654</b>) and the process of generating a function/method declaration (step <b>656</b>) which are shown in <figref idref="DRAWINGS">FIG. 6C</figref>.</p>
<p id="p-0256" num="0255">Note that, among steps in <figref idref="DRAWINGS">FIG. 6D</figref>, the steps which are each either different from or added to those in the one function-to-one interface method of <figref idref="DRAWINGS">FIG. 6B</figref> are shown in a hatched manner (steps <b>665</b>, <b>666</b>, <b>672</b>, <b>673</b>, and <b>675</b>).</p>
<p id="p-0257" num="0256">The detailed processes of step <b>654</b> are described in accordance with a process flow shown on the left-hand side of <figref idref="DRAWINGS">FIG. 6D</figref> (steps <b>661</b> to <b>667</b>).</p>
<p id="p-0258" num="0257">In step <b>661</b>, the bytecode generator starts the process of generating a function/method call by a caller in source code.</p>
<p id="p-0259" num="0258">In step <b>662</b>, the bytecode generator checks whether or not an interface class corresponding to the called function/method has already been generated. Whether or not the interface class has already been generated is determined by using the data structure in <figref idref="DRAWINGS">FIG. 7</figref> in which signatures and interface classes are registered.</p>
<p id="p-0260" num="0259">In step <b>663</b>, if the bytecode generator determines that the interface class corresponding to the called function/method has not been generated yet (NO), the process moves to step <b>665</b>. On the other hand, the process moves to step <b>664</b> if the bytecode generator determines that the interface class corresponding to the called function/method has already been generated (YES).</p>
<p id="p-0261" num="0260">In step <b>665</b>, the bytecode generator adds the signature of the called function/method to the call function list (<b>1137</b> of <figref idref="DRAWINGS">FIG. 11C</figref>). Here, the call function list indicates a data structure in which the signature of a function which appears in a caller (which is to be called) is held in a list format. The call function list (<b>1137</b>) is implemented as a part of the bytecode generator.</p>
<p id="p-0262" num="0261">In step <b>666</b>, the bytecode generator generates code corresponding to a function/method call for a target object typed with a not-yet-generated interface class, with a name associated with the buffer. The generation of the code corresponding to the function/method call uses the name of the interface class only, and thus the interface class does not need to actually exist at this point. An actual consolidated interface class is generated from all signatures stored in the buffer at a timing when the class loader (<b>1107</b> of <figref idref="DRAWINGS">FIG. 11A</figref>) solves symbol names of an interface and the like during the execution of the code. Once the code corresponding to the function/method call is generated, the process moves to step <b>667</b>.</p>
<p id="p-0263" num="0262">In step <b>664</b>, the bytecode generator generates code corresponding to a function/method call made through the interface class corresponding to the called function/method. The code thus generated is bytecode to be executed in steps <b>645</b>-<b>1</b> to <b>645</b>-<b>8</b>. Once the code corresponding to the function/method call is generated, the process moves to step <b>667</b>. Note that, the code generated in step <b>664</b> corresponds to the lines L<b>04</b> and L<b>05</b> in <figref idref="DRAWINGS">FIG. 4C</figref>, and is executed in parallel with or before/after the line J<b>03</b> as a part of the line J<b>02</b> of <figref idref="DRAWINGS">FIG. 4A</figref>.</p>
<p id="p-0264" num="0263">In step <b>667</b>, the bytecode generator completes the process of generating the function/method call (<b>661</b>), and the process returns to step <b>654</b> from which the flow branches.</p>
<p id="p-0265" num="0264">The detailed processes of step <b>656</b> in <figref idref="DRAWINGS">FIG. 6C</figref> are described in accordance with a process flow shown on the right-hand side of <figref idref="DRAWINGS">FIG. 6D</figref>.</p>
<p id="p-0266" num="0265">In step <b>671</b>, the bytecode generator starts the process of generating a declaration of a function/method in source code (<b>656</b>).</p>
<p id="p-0267" num="0266">In step <b>672</b>, the bytecode generator checks whether the signature of the declared function/method is in the buffer, and whether an interface class corresponding to the declared function/method has already been generated. The check on whether or not the interface class has already been generated is made on the basis of whether or not there is the signature of the corresponding function in the data structure in <figref idref="DRAWINGS">FIG. 7</figref> in which signatures and interface classes are registered. Here, a signature is defined for every function in the data structure.</p>
<p id="p-0268" num="0267">In step <b>673</b>, if the bytecode generator determines that the signature has not appeared yet, that is, determines that the signature of the declared function/method is not in the buffer and that the interface class corresponding to the declared function/method has not been generated yet (NO), the process moves to step <b>675</b>. On the other hand, the process moves to step <b>674</b> if the bytecode generator determines that the signature has appeared already, that is, determines that the signature is in the buffer or that the interface class has been generated already (YES).</p>
<p id="p-0269" num="0268">In step <b>675</b>, the bytecode generator adds the signature of the declared function/method to the declaration function list. Upon completion of this addition, the process moves to step <b>676</b>.</p>
<p id="p-0270" num="0269">In step <b>674</b>, the bytecode generator adds the corresponding interface class name to the declaration interface list (<b>1135</b> of <figref idref="DRAWINGS">FIG. 11C</figref>). The corresponding interface class name is obtained from the name associated with the buffer (when the signature is in the buffer), or from the interface class name obtained by referring to the correspondence table in <figref idref="DRAWINGS">FIG. 7</figref> (when the interface class has already been generated). Here, the declaration interface list (<b>1135</b>) indicates a data structure in which the name of a caller interface class corresponding to the declared function/method is held in a list format.</p>
<p id="p-0271" num="0270">In step <b>676</b>, the bytecode generator generates, in the memory (<b>1101</b> of <figref idref="DRAWINGS">FIG. 11A</figref>), bytecode corresponding to a script for a process of the declared function/method (i.e., the contents of the function/method). The bytecode thus generated is bytecode to be executed in steps <b>645</b>-<b>1</b> to <b>645</b>-<b>8</b>. The detailed bytecode generation process is equivalent to the recursion of step <b>651</b> of <figref idref="DRAWINGS">FIG. 6C</figref> described above (the generation of bytecode corresponding to the script).</p>
<p id="p-0272" num="0271">In step <b>677</b>, the bytecode generator generates, in the memory (<b>1101</b>), code for associating the generated bytecode with the declared function/method. The code thus generated is bytecode to be executed in steps <b>645</b>-<b>1</b> to <b>645</b>-<b>8</b>. The code generated in step <b>677</b> is code to be registered in the symbol table (<b>1109</b> of <figref idref="DRAWINGS">FIG. 11A</figref>). This code is referenced by, for example, the function lookupFunction( ) shown in the lines L<b>04</b> and L<b>05</b> of <figref idref="DRAWINGS">FIG. 4C</figref>. In other words, the code generated in step <b>677</b> is code for associating the implementation of each function in the bytecode generated in step <b>676</b> with the name of the function.</p>
<p id="p-0273" num="0272">In step <b>678</b>, the bytecode generator completes the process of generating the function/method declaration (<b>671</b>), and the process returns to step <b>656</b> from which the flow branches.</p>
<p id="p-0274" num="0273"><figref idref="DRAWINGS">FIG. 6E</figref> shows a detailed flowchart of the buffer process in step <b>643</b> of <figref idref="DRAWINGS">FIG. 6C</figref>.</p>
<p id="p-0275" num="0274">In step <b>681</b>, the bytecode generator starts the buffer process.</p>
<p id="p-0276" num="0275">In step <b>682</b>, the bytecode generator determines whether or not the declaration function list is empty.</p>
<p id="p-0277" num="0276">The process moves to step <b>683</b> if the declaration function list is empty. On the other hand, the process moves to step <b>684</b> if the declaration function list is not empty.</p>
<p id="p-0278" num="0277">In step <b>683</b>, the bytecode generator adds, to the buffer, a signature included in the call function list, and preferably, the signature of a function/method which appears in another compilation unit obtained by static parsing such as an include process. Once the addition of the signature is over, the process moves to step <b>689</b> without clearing the buffer (while keeping the buffer as is).</p>
<p id="p-0279" num="0278">If the declaration function list is not empty, the process moves to step <b>684</b>.</p>
<p id="p-0280" num="0279">In step <b>684</b>, the bytecode generator checks whether or not an interface class name associated with the buffer exists in the declaration interface list.</p>
<p id="p-0281" num="0280">The process moves to step <b>686</b> if no interface class name associated with the buffer exists in step <b>685</b>. On the other hand, the process moves to step <b>687</b> if an interface class name associated with the buffer exists in step <b>685</b>.</p>
<p id="p-0282" num="0281">If determining that no interface class name associated with the buffer exists, the bytecode generator generates, from signatures in the declaration function list, an interface class which is different from an interface class generated from signatures in the buffer and independent of the buffer, and loads the generated interface class in step <b>686</b>. The process of generating and loading an interface class independent of the buffer is an optional step; however, it is often preferable to include this step since a less number of dummies needs to be implemented with a consolidated interface class having signatures of a set of functions/methods which is the same as the declared set of functions/methods. For this reason, a consolidated interface class consisting only of signatures of declared functions/methods is generated separately from the consolidated interface class generated from signatures in the buffer, only in a case where the signatures in the buffer can be kept as is. When a consolidated interface class independent of the buffer is generated, a set of each of the signatures and the name of the consolidated interface class generated independent of the buffer is registered in the data structure in <figref idref="DRAWINGS">FIG. 7</figref>. Moreover, the name of the loaded consolidated interface class independent of the buffer is added to the declaration interface list. Once the addition is over, the process moves to step <b>683</b>.</p>
<p id="p-0283" num="0282">If determining that an interface class name associated with the buffer exists, the bytecode generator adds signatures in the declaration function list and the call function list to the buffer in step <b>687</b>.</p>
<p id="p-0284" num="0283">In step <b>688</b>, the bytecode generator generates one consolidated interface class from signatures in the buffer, and loads the generated interface class. Here, the buffer stores therein signatures of respective caller functions/methods which appear in one script tile unit. When the consolidated interface class is generated, a set of each of the signatures and the name of the consolidated interface class is registered in the data structure in <figref idref="DRAWINGS">FIG. 7</figref>. Moreover, the name of the loaded consolidated interface class is added to the declaration interface list. The bytecode generator clears the buffer after generating the consolidated interface class. In other words, the bytecode generator deletes the signatures in the buffer. Once the clearing operation is over, the process moves to step <b>689</b>. Note that, in the buffer operation, the process sometimes passes through step <b>688</b>, which is a step of generating a consolidated interface class from signatures in the buffer, without passing through step <b>686</b>.</p>
<p id="p-0285" num="0284">In step <b>689</b>, the bytecode generator completes the buffer process (<b>681</b>), and the process returns to step <b>643</b> (<figref idref="DRAWINGS">FIG. 6C</figref>) from which the flow branches.</p>
<p id="p-0286" num="0285">The detailed processes of step <b>645</b> in <figref idref="DRAWINGS">FIG. 6C</figref> are described in accordance with the process flow on the right-hand side of <figref idref="DRAWINGS">FIG. 6C</figref> (steps <b>645</b>-<b>1</b> to <b>645</b>-<b>8</b>).</p>
<p id="p-0287" num="0286">In step <b>645</b>-<b>1</b>, the JAVA program execution unit (hereinafter called program execution unit) (<b>1118</b> of <figref idref="DRAWINGS">FIG. 11A</figref>) starts the execution of the bytecode generated in each of steps <b>664</b>, <b>676</b>, and <b>677</b>.</p>
<p id="p-0288" num="0287">In step <b>645</b>-<b>2</b>, the program execution unit generates a not-yet-loaded consolidated interface class, and loads the consolidated interface class thus generated. The detailed processes of step <b>645</b>-<b>2</b> will be shown later in steps <b>691</b> to <b>694</b> below.</p>
<p id="p-0289" num="0288">In step <b>645</b>-<b>3</b>, the program execution unit reads each instruction in the generated bytecode.</p>
<p id="p-0290" num="0289">In step <b>645</b>-<b>4</b>, the program execution unit determines whether or not the read instruction represents &#x201c;include&#x201d; or a process corresponding to &#x201c;include.&#x201d;</p>
<p id="p-0291" num="0290">If the read instruction represents &#x201c;include&#x201d; or a process corresponding to &#x201c;include,&#x201d; the program execution unit executes a process for the script in step <b>645</b>-<b>5</b>. The execution of the process for the script means returning to the process for the script which is described in step <b>641</b>.</p>
<p id="p-0292" num="0291">If the read instruction represents neither &#x201c;include&#x201d; nor a process corresponding to &#x201c;include,&#x201d; the program execution unit executes a process according to other instructions in step <b>645</b>-<b>6</b>. The process according to other instructions is not the essence of the invention, and thus will not be described herein.</p>
<p id="p-0293" num="0292">In step <b>645</b>-<b>7</b>, the process returns to step <b>645</b>-<b>3</b> until the reading of all the instructions in the bytecode is completed.</p>
<p id="p-0294" num="0293">In step <b>645</b>-<b>8</b>, the execution of the bytecode is completed, and the process returns to step <b>645</b> from which the flow branches.</p>
<p id="p-0295" num="0294"><figref idref="DRAWINGS">FIG. 6F</figref> shows a detailed process flow for the generation and loading of a not-yet-loaded consolidated interface class, which is described in step <b>645</b>-<b>2</b> of <figref idref="DRAWINGS">FIG. 6C</figref>.</p>
<p id="p-0296" num="0295">In step <b>691</b>, the generation and loading of a not-yet-loaded consolidated interface class are started.</p>
<p id="p-0297" num="0296">In step <b>692</b>, an interface class generator (<b>1132</b> of <figref idref="DRAWINGS">FIG. 11C</figref>) is requested to load a consolidated interface class for all the signatures in the buffer if the consolidated interface class is used by the class loader.</p>
<p id="p-0298" num="0297">In step <b>693</b>, the process moves to step <b>694</b> if the interface class generator is requested to perform the loading operation. On the other hand, the process moves to step <b>695</b> if the interface class generator is not requested to perform the loading operation.</p>
<p id="p-0299" num="0298">In step <b>694</b>, upon loading request, the interface class generator generates one consolidated interface class from all the signatures in the buffer, and loads the generated interface class. The interface class generator clears the buffer after generating the interface class. In other words, the interface class generator deletes the signatures in the buffer. Once the clearing operation is over, the process moves to step <b>695</b>.</p>
<p id="p-0300" num="0299">In step <b>695</b>, the interface class generator completes the generation and loading of a not-yet-loaded consolidated interface class, and the process returns to step <b>645</b>-<b>2</b> from which the flow branches.</p>
<p id="p-0301" num="0300">A description is given below of an example where the process flows according to an embodiment of the invention (steps <b>641</b> to <b>695</b>) are applied to the source code written in a PHP language shown in <figref idref="DRAWINGS">FIG. 1A</figref>.</p>
<p id="p-0302" num="0301">Assume that the process starts from the script file start.php (<b>101</b>).</p>
<p id="p-0303" num="0302">First, the &#x201c;process for the script&#x201d; (<b>641</b>) is performed for the script file start.php (<b>101</b>). Then, during the process (<b>645</b>) of executing the script file start.php (<b>101</b>), the &#x201c;process for the script&#x201d; (<b>645</b>-<b>5</b>) is performed for the file func.php.</p>
<p id="p-0304" num="0303">A. The Process for the Script File start.php (<b>101</b>)</p>
<p id="p-0305" num="0304">An implementation class required for executing the script file start.php (<b>101</b>) is generated in bytecode (step <b>642</b>). The bytecode thus generated is as shown in <figref idref="DRAWINGS">FIG. 4C</figref>, for example.</p>
<p id="p-0306" num="0305">No function is declared in the script file start.php (<b>101</b>). Hence, in the implementation class Bytecode_start_php (<b>421</b>) corresponding to the file start.php (<b>101</b>), there is no declaration for the implementation of any interface class except for the interface PHPScript which is used for the execution of the script itself. In the implementation class Bytecode_start_php (<b>421</b>) which is a caller, code corresponding to a call for a consolidated interface class is written by using an interface class name Callsite_start_php. The consolidated interface class name Callsite_start_php is named at random, and is also the name of the consolidated interface class to include methods corresponding to signatures currently stored in the buffer. At this phase, the above consolidated interface class itself is neither generated nor loaded. Instead, &#x201c;foo(0)&#x201d; and &#x201c;bar(1),&#x201d; which are signatures of functions/methods, are stored in the buffer for signatures. Here, in the description of an embodiment, the name of and the number of arguments of a function/method are only used for a signature for the sake of simplicity.</p>
<p id="p-0307" num="0306">B. The Execution of the File start.php</p>
<p id="p-0308" num="0307">The script file start.php is executed by calling the method executeScript( ) in the generated and loaded implementation class Bytecode_start_php (<b>421</b> of <figref idref="DRAWINGS">FIG. 4C</figref>) corresponding to the file start.php (step <b>645</b>). This execution of the script file start.php leads to the execution of the script file funcs.php (<b>102</b> of <figref idref="DRAWINGS">FIG. 1A</figref>) because the auxiliary function includeScript( ) (L<b>03</b> of <figref idref="DRAWINGS">FIG. 4C</figref>) corresponding to the function &#x201c;include&#x201d; in the original file is called by this execution of the script file start.php, and the argument passed by this function is &#x201c;funcs.php.&#x201d; Since an implementation class corresponding to the file funcs.php (<b>102</b>) has neither been generated nor loaded, the process for the script file funcs.php (<b>102</b>) is required.</p>
<p id="p-0309" num="0308">C. The Process for the Script File funcs.php</p>
<p id="p-0310" num="0309">The process of generating bytecode corresponding to the script file funcs.php (<b>102</b>) is executed in order to generate and load an implementation class required for executing this script file (step <b>642</b>). The bytecode obtained by this process is as shown in <figref idref="DRAWINGS">FIG. 4D</figref> (<b>422</b>). Since there is no declaration, in the file funcs.php (<b>102</b>), of a function whose signature has not appeared yet, no more signatures is newly added to the buffer. Functions are declared in the file funcs.php (<b>102</b>), and signatures corresponding to the functions are still in the buffer. Thus, the declaration is executed so that the implementation class may implement the interface class Callsite_start_php corresponding to these functions.</p>
<p id="p-0311" num="0310"><figref idref="DRAWINGS">FIG. 7</figref> shows a data structure in which signatures and interface classes are registered, according to an embodiment of the invention.</p>
<p id="p-0312" num="0311">A table (<b>701</b>) is a data structure for registering PHP functions/methods as loaded functions/methods. The data structure is stored in a signature-interface registration unit (<b>1131</b> of <figref idref="DRAWINGS">FIG. 11C</figref>). The table (<b>701</b>) includes signatures of PHP functions/methods and respective sets of a JAVA method and signature. Each set includes the name of an interface class that the corresponding method belongs and the signature of the corresponding method. Note that, in an embodiment of the invention, source code is written in a dynamically typed language in which variables and the like are not previously typed. Hence, only the name of and the number of arguments of a function are required for the signature of the function.</p>
<p id="p-0313" num="0312">Data which needs to be stored in the buffer in step <b>683</b> of <figref idref="DRAWINGS">FIG. 6E</figref> is any one of the signature of a PHP function/method, and the JAVA method and signature corresponding to the function/method. This is because the use of the data structure allows searching for a JAVA method and signature by using the signature of a PHP function/method corresponding thereto, and searching for the signature of a PHP function/method by using the JAVA method and signature corresponding thereto.</p>
<p id="p-0314" num="0313"><figref idref="DRAWINGS">FIGS. 8A and 8B</figref> show an example where a function/method declaration is made prior to a function/method call.</p>
<p id="p-0315" num="0314"><figref idref="DRAWINGS">FIG. 8A</figref> shows an example where there are three PHP source code files (start.php, caller.php, and funcs.php) which are written in a PHP language and can be source code to be converted, and where a process of a function/method declaration (funcs.php) is performed before a process of a function/method call (caller.php) is performed.</p>
<p id="p-0316" num="0315">The PHP source code files include three source code files, i.e., start.php (<b>801</b>). funcs.php (<b>803</b>), and caller.php (<b>802</b>).</p>
<p id="p-0317" num="0316">The relation among the three files is as follows. Specifically, an inclusion command include (&#x201c;funcs.php&#x201d;) in the file start.php (<b>801</b>) specifies the file funcs.php (<b>803</b>) as a file to be included by the file start.php (<b>801</b>) (arrow <b>804</b>). Further, an inclusion command include (&#x201c;caller.php&#x201d;) in the file start.php (<b>801</b>) specifies the file caller.php (<b>802</b>) as a file to be included by the file start.php (<b>801</b>) (arrow <b>805</b>). Furthermore, a function/method foo( ) in the file caller.php (<b>802</b>) corresponds to a declaration and definition function foo( ){ } in the file funcs.php (<b>803</b>) (arrow <b>806</b>).</p>
<p id="p-0318" num="0317">In another mode of an embodiment of the invention, unlike that described in <figref idref="DRAWINGS">FIGS. 4A to 4D</figref>, a process for a function/method declaration in the file funcs.php (<b>803</b>) is executed earlier than a process of the PHP function call file caller.php (<b>802</b>), i.e., than the generation of an interface class for a call for a function foo( ). In a case where the process of the declaration file funcs.php (<b>803</b>) is executed earlier than the process of the function call file caller.php (<b>802</b>), a consolidated interface class is generated and loaded at a time point where the file funcs.php (<b>803</b>) is executed, the consolidated interface class having functions which correspond to PHP functions and whose signatures are pooled in the buffer as of this time point and functions corresponding to the declared PHP functions. Then, a JAVA class for implementation of the declaration file (funcs.php) is generated and loaded in such a way as to implement (implements) this consolidated interface class. In this way, as shown in <figref idref="DRAWINGS">FIG. 8B</figref>, methods corresponding to multiple functions are consolidated into one consolidated interface class even in a case where code including a PHP function declaration is executed earlier.</p>
<p id="p-0319" num="0318"><figref idref="DRAWINGS">FIG. 8B</figref> shows implementation classes and an interface class generated from the source code in <figref idref="DRAWINGS">FIG. 8A</figref> through the multiple functions-to-one interface method, and steps of converting the source code into target code and executing the target code.</p>
<p id="p-0320" num="0319">In <figref idref="DRAWINGS">FIG. 8B</figref>, the left-hand side shows the steps of conversion and execution (N<b>01</b> to N<b>19</b>). The right-hand side shows implementation classes (<b>812</b>, <b>813</b>, and <b>814</b>) and a consolidated interface class (<b>811</b>) generated through the multiple functions-to-one interface method. As shown in <figref idref="DRAWINGS">FIG. 8B</figref>, in the multiple functions-to-one interface method, the one consolidated interface class (<b>811</b>) is prepared for the caller of multiple functions/methods, and the implementation class (<b>813</b>) is generated to correspond to the consolidated interface class (<b>811</b>). The right-hand side also shows how the implementation class (<b>814</b>) calls, as its implementation contents, a function foo( ) through the consolidated interface class (<b>811</b>) (<b>815</b>). The numbers (N<b>02</b>, N<b>06</b>, N<b>08</b>, and N<b>14</b>) in arrows given on the left-hand side of the implementation classes (<b>812</b>, <b>813</b>, and <b>814</b>) and consolidated interface class (<b>811</b>) correspond respectively to the step numbers of the above steps.</p>
<p id="p-0321" num="0320">Hereinafter, the steps of conversion and execution shown in <figref idref="DRAWINGS">FIG. 8B</figref> are described.</p>
<p id="p-0322" num="0321">In line <b>1</b> (N<b>01</b>), a command include to include the script file start.php (<b>801</b> in <figref idref="DRAWINGS">FIG. 8A</figref>) which is a PHP source code file is directed. The steps in lines <b>2</b> to <b>19</b> (N<b>02</b> to N<b>19</b>) are executed as sub-steps of N<b>01</b>.</p>
<p id="p-0323" num="0322">In line <b>2</b> (N<b>02</b>), the implementation class (<b>812</b>) corresponding to the PHP script file start.php (<b>801</b> of <figref idref="DRAWINGS">FIG. 8A</figref>) is generated and loaded. The arrow (N<b>02</b>) indicates the generation of the implementation class (<b>812</b>).</p>
<p id="p-0324" num="0323">In line <b>3</b> (N<b>03</b>), bytecode for the loaded implementation class (<b>812</b>) is executed.</p>
<p id="p-0325" num="0324">In line <b>4</b> (N<b>04</b>), the file funcs.php is included by the execution of the implementation class (<b>812</b>), the inclusion of the file funcs.php being directed by a part of the bytecode corresponding to a first command include in the script file start.php (<b>801</b> of <figref idref="DRAWINGS">FIG. 8A</figref>). At this point, the implementation class Bytecode_start_php (<b>812</b>) corresponding to the file start.php (<b>801</b>), which is being executed, is suspended, and the process moves to the generation and loading of the implementation class Bytecode_funcs_php (<b>813</b>) corresponding to the newly included PHP file funcs.php (<b>803</b>).</p>
<p id="p-0326" num="0325">In lines <b>5</b> (N<b>05</b>) to <b>9</b> (N<b>09</b>), the implementation class Bytecode_funcs_php (<b>813</b>) corresponding to the file funcs.php (<b>803</b>) is generated and loaded.</p>
<p id="p-0327" num="0326">In line <b>6</b> (N<b>06</b>), the implementation class Bytecode_funcs_php (<b>813</b>) corresponding to the file funcs.php (<b>803</b>) is generated. The arrow (N<b>06</b>) indicates the generation of the implementation class Bytecode_funcs_php (<b>813</b>). At this phase, a consolidated interface class has not been generated yet, and thus the implementation class Bytecode_funcs_php (<b>813</b>) is not loaded.</p>
<p id="p-0328" num="0327">In line <b>7</b> (N<b>07</b>), it is checked whether there is an interface class or signature corresponding to calls for the functions foo( ) and bar( ) which have neither be loaded nor buffered.</p>
<p id="p-0329" num="0328">In line <b>8</b> (N<b>08</b>), one consolidated interface class (<b>811</b>) is generated by using signatures of the respective declared functions foo( ) and bar( ). The arrow (N<b>08</b>) indicates the generation of the consolidated interface class (<b>811</b>). In this mode of the embodiment, the process of the declaration file funcs.php (<b>803</b> of <figref idref="DRAWINGS">FIG. 8A</figref>) is executed earlier than the process of the function call file caller.php (<b>802</b> of <figref idref="DRAWINGS">FIG. 8A</figref>). Thus, one consolidated interface class (<b>811</b>) is generated and loaded from the signature of a caller function pooled in the buffer as of this time point (0 signature in this mode of the embodiment) and signatures of the respective declared functions.</p>
<p id="p-0330" num="0329">In line <b>9</b> (N<b>09</b>), the implementation class (<b>813</b>) which is generated in step (N<b>06</b>) and corresponds to the file funcs.php is loaded. Here, the functions defined in the interface class (<b>811</b>) have already been implemented (<b>816</b>) in the implementation class (<b>813</b>), as can be understood from the method of generating the interface class (<b>811</b>) described in step (N<b>08</b>). In this way, in a case where code including a PHP function declaration is executed earlier, one consolidated interface class corresponding to multiple function/method calls is generated by use of the declared PHP function and of a PHP function corresponding to a signature pooled in the buffer as of a time point of generation and loading of an implementation class corresponding to a script file in which a PHP function is declared. At this time, the PHP functions are preferably brought together selectively on the basis of presence or absence of duplication.</p>
<p id="p-0331" num="0330">In line <b>10</b> (N<b>10</b>), the implementation class (<b>813</b>) corresponding to the file funcs.php is executed.</p>
<p id="p-0332" num="0331">In line <b>11</b> (N<b>11</b>), functions foo( ) and bar( ) are declared with the execution of the implementation class (<b>813</b>). This step is basically the same as step J<b>11</b> of <figref idref="DRAWINGS">FIG. 4A</figref>, for example.</p>
<p id="p-0333" num="0332">In line <b>12</b> (N<b>12</b>), entities of the functions foo( ) and bar( ) are registered in a function table, which is basically the same as step J<b>12</b> of <figref idref="DRAWINGS">FIG. 4A</figref>.</p>
<p id="p-0334" num="0333">In line <b>13</b> (N<b>13</b>), the control returns to the implementation class (<b>812</b>) corresponding to the script file start.php (<b>801</b> of <figref idref="DRAWINGS">FIG. 8A</figref>), and the file caller.php (<b>802</b> of <figref idref="DRAWINGS">FIG. 8A</figref>) directed by a second inclusion command include is included.</p>
<p id="p-0335" num="0334">In line <b>14</b> (N<b>14</b>), a function of the implementation class (<b>814</b>) corresponding to the file caller.php (<b>802</b> of <figref idref="DRAWINGS">FIG. 8A</figref>) is generated and loaded. The arrow (N<b>14</b>) indicates the generation of the function of the implementation class (<b>814</b>).</p>
<p id="p-0336" num="0335">In line <b>15</b> (N<b>15</b>), it is checked whether an interface class for the caller function foo( ) has already been loaded, and whether the signature of the caller function foo( ) is stored in the buffer.</p>
<p id="p-0337" num="0336">In line <b>16</b> (N<b>16</b>), the implementation class (<b>814</b>) corresponding to the file caller.php is executed.</p>
<p id="p-0338" num="0337">In line <b>17</b> (N<b>17</b>), a call (invoke) of the function foo( ) is executed in bytecode with the execution of step (N<b>16</b>).</p>
<p id="p-0339" num="0338">In line <b>18</b> (N<b>18</b>), the function table is searched by the called function name foo, and the corresponding instance is thus found.</p>
<p id="p-0340" num="0339">In line <b>19</b> (N<b>19</b>), the function foo( ) is executed by calling and executing a method foo( ) (corresponding to the function foo( ) included in the found instance. In this event, the instance is cast so as to have its type adaptable to the type defined in the consolidated interface class (<b>811</b>).</p>
<p id="p-0341" num="0340">In the example shown in <figref idref="DRAWINGS">FIG. 8B</figref>, the functions in only one script file (funcs.php) are consolidated into one consolidated interface class. However, in a case where another function is also called in the file funcs.php for example, such a called function as well as the above functions are altogether consolidated into the single consolidated interlace class. Note here that if there is neither function declaration nor call for a new function/method in a script which is being compiled, no interface class is generated at this time since not needed. An interface class is to be generated when a function declaration or a call for a new function/method is found in a script to be compiled.</p>
<p id="p-0342" num="0341"><figref idref="DRAWINGS">FIGS. 9A and 9B</figref> show an example where functions in a certain interface class are not covered by a PHP function declared in a certain script.</p>
<p id="p-0343" num="0342"><figref idref="DRAWINGS">FIG. 9A</figref> shows an example where there are three PHP source code files (start.php, foo.php, and bar.php) which are written in a PHP language which can be source code to be converted, and where a not-yet-defined function appears.</p>
<p id="p-0344" num="0343">The PHP source code files include three source code files, i.e., script files of start.php (<b>901</b>), foo.php (<b>902</b>), and bar.php (<b>903</b>).</p>
<p id="p-0345" num="0344">The relation among the three files is as follows. Specifically, an inclusion command include (&#x201c;foo.php&#x201d;) in the file start.php (<b>901</b>) specifies the file foo.php (<b>902</b>) as a file to be included by the file start.php (<b>901</b>) (arrow <b>904</b>). In addition, an inclusion command include (&#x201c;bar.php&#x201d;) in the file start.php (<b>901</b>) specifies the file bar.php (<b>903</b>) as a file to be included by the file start.php (<b>901</b>) (arrow <b>906</b>). Further, a caller function/method foo( ) in the file start.php (<b>901</b>) corresponds to a declaration and definition function foo( ){ } in the file foo.php (<b>902</b>) (arrow <b>905</b>). Furthermore, a function/method bar( ) in the file start.php (<b>901</b>) corresponds to a declaration and definition function bar( ){ } in the file bar.php (<b>903</b>) (arrow <b>907</b>).</p>
<p id="p-0346" num="0345">In an embodiment of the invention, interfaces are speculatively brought together to generate an interface class. For this reason, both of the functions foo( ) and bar( ) are defined in an interface class which is generated to correspond to calls for the functions foo( ) and bar( ) in the file start.php (<b>901</b>) as shown in <figref idref="DRAWINGS">FIG. 9A</figref>, for example. On the other hand, a case is observed in which: a declaration for the function boo( ) exists but no declaration for the function bar( ) exists in the included file foo.php (<b>902</b>), for example; and a declaration for the function bar( ) exists but no declaration for the function foo( ) exists in the included file bar.php (<b>903</b>), for example. To cope with such a case, this embodiment causes an implementation class for each script file to have a dummy implementation, with almost no contents, of a non-declared function. In this way, in this embodiment, an interface class, which includes the signature of a function/method included in an implementation class of a certain compilation unit, declares functions/methods including the above function/method on the assumption that the implementation class implements all the functions/methods, and a dummy implementation of the function/method having a signature and not being implemented in the original compilation unit, is prepared in the implementation class.</p>
<p id="p-0347" num="0346"><figref idref="DRAWINGS">FIG. 9B</figref> shows implementation classes and an interface class generated from the source code in <figref idref="DRAWINGS">FIG. 9A</figref> through the multiple functions-to-one interface method, and steps of converting the source code into target code and executing the target code.</p>
<p id="p-0348" num="0347">In <figref idref="DRAWINGS">FIG. 9B</figref>, the left-hand side shows the steps of conversion and execution (O<b>01</b> to O<b>22</b>). The right-hand side shows implementation classes (<b>913</b>, <b>915</b>, and <b>917</b>) and a consolidated interface class (<b>912</b>) generated through the multiple functions-to-one interface method. As shown in <figref idref="DRAWINGS">FIG. 9B</figref>, in the multiple functions-to-one interface method, the one consolidated interface class (<b>912</b>) is prepared for the caller of multiple functions/methods, and the implementation classes (<b>915</b> and <b>917</b>) are generated to correspond to the consolidated interface class (<b>912</b>). The right-hand side also shows how the implementation class (<b>913</b>) calls, as its implementation contents, functions foo( ) and bar( ) through the interface class (<b>914</b>). Likewise, the right-hand side also shows how the implementation class (<b>915</b>) calls, as its implementation contents, a function dummy( ) through the interface class (<b>916</b>). The right-hand side also shows how the implementation class (<b>917</b>) calls, as its implementation contents, a function dummy( ) through the interface class (<b>918</b>). The numbers (O<b>03</b>, O<b>04</b>, O<b>05</b>, O<b>08</b>, and O<b>16</b>) in arrows given on the left-hand side of the implementation classes (<b>913</b>, <b>915</b>, and <b>917</b>), the consolidated interface class (<b>912</b>), and the buffer correspond respectively to the step numbers of the above steps.</p>
<p id="p-0349" num="0348">Hereinafter, the steps of conversion and execution shown in <figref idref="DRAWINGS">FIG. 9B</figref> are described.</p>
<p id="p-0350" num="0349">In line <b>1</b> (O<b>01</b>), a command include to include the script file start.php (<b>901</b>) which is a PHP source code file is directed. The steps in lines <b>2</b> to <b>22</b> (O<b>02</b> to O<b>22</b>) are executed as sub-steps of O<b>01</b>.</p>
<p id="p-0351" num="0350">In line <b>2</b> (O<b>02</b>), the generation of an implementation class corresponding to a caller of the functions foo( ) and bar( ) in the PHP file start.php (<b>901</b> in <figref idref="DRAWINGS">FIG. 9A</figref>) is directed. According to the directions, the implementation class Bytecode_start_php (<b>913</b>) corresponding to the file start.php (<b>901</b> in <figref idref="DRAWINGS">FIG. 9A</figref>) is generated, as shown by the arrow (O<b>04</b>).</p>
<p id="p-0352" num="0351">In line <b>3</b> (O<b>03</b>), the storing in the buffer (<b>911</b>) of signatures of the respective called functions foo( ) and bar( ) is directed. According to the directions, the signatures thereof are stored in the buffer (<b>911</b>), as shown by the arrow (O<b>03</b>).</p>
<p id="p-0353" num="0352">In line <b>4</b> (O<b>04</b>), the implementation class Bytecode_start_php (<b>913</b>) is loaded into a JAVA VM.</p>
<p id="p-0354" num="0353">In line <b>5</b> (O<b>05</b>), the taking out of the buffer (<b>911</b>) of the signatures of the respective called functions foo( ) and bar( ) and the generation and loading of the consolidated interface class (<b>912</b>) are directed. According to the directions, the consolidated interface class (<b>912</b>) is generated as shown by the arrow (O<b>05</b>).</p>
<p id="p-0355" num="0354">In this way, the loading of the class (interface) is requested, through the class loader (<b>1107</b> of <figref idref="DRAWINGS">FIG. 11A</figref>), not at a timing when implementation code for a caller is generated (in line <b>2</b> (O<b>02</b>)) but at a timing when the implementation code is loaded (in line <b>4</b> (O<b>04</b>)) or, more preferably, executed. Thus, it is not till the timing when the implementation code is loaded or executed that the interface class is generated and loaded, the interface class including all methods corresponding to the signatures pooled in the buffer as of this time point. If the interface class already exists, the loading thereof is simply performed.</p>
<p id="p-0356" num="0355">In line <b>6</b> (O<b>06</b>), the execution of the caller implementation class (<b>913</b>) thus loaded is directed.</p>
<p id="p-0357" num="0356">In line <b>7</b> (O<b>07</b>), the execution of an inclusion command include is directed with the execution of the implementation class (<b>913</b>), and thus the specified file foo.php (<b>902</b> of <figref idref="DRAWINGS">FIG. 9A</figref>) is included.</p>
<p id="p-0358" num="0357">In line <b>8</b> (O<b>08</b>), the generation and loading of bytecode for the implementation class (<b>915</b>) corresponding to the included file foo.php (<b>902</b> of <figref idref="DRAWINGS">FIG. 9A</figref>) are directed. According to the directions, the implementation class (<b>915</b>) corresponding to the file foo.php (<b>902</b>) is generated and loaded, as shown by the arrow (O<b>08</b>). The implementation class (<b>915</b>) needs to be generated while implementing the consolidated interface class (<b>912</b>) (implementation <b>919</b>). The reason is that, according to the JAVA rule, the functions foo( ) and bar( ) defined in the consolidated interface class (<b>912</b>) must be implemented in the implementation class (<b>915</b>). However, only the function foo( ) is declared and the function bar( ) is not declared in the file foo.php (<b>902</b>) corresponding to the implementation class (<b>915</b>). To deal with this problem, this embodiment causes the implementation class (<b>915</b>) to have a function dummy( ) (<b>916</b>) which is a dummy implementation, with almost no contents, of a function bar( ).</p>
<p id="p-0359" num="0358">In line <b>9</b> (O<b>09</b>), the execution of the implementation class (<b>915</b>) corresponding to the file foo.php is directed.</p>
<p id="p-0360" num="0359">In line <b>10</b> (<b>010</b>), a function declaration command declareFunction is executed with the execution of the implementation class (<b>915</b>). By the execution of the function declaration command declareFunction, an instance for executing a call for the function foo( ) is created by the implementation class itself.</p>
<p id="p-0361" num="0360">In line <b>11</b> (<b>011</b>), the created instance and a function name foo of the called function foo( ) are registered in association with each other in a function table. This registration is made in order to search, upon function call, the function table for the corresponding instance, and to process the function call by use of methods foo( ) and bar( ) included in the instance thus searched out. With the above processes, the execution of the implementation class (<b>915</b>) ends, and the control returns to the implementation class (<b>913</b>).</p>
<p id="p-0362" num="0361">In line <b>12</b> (O<b>12</b>), a call for the function foo( ) (invoke foo( ) is executed with the execution of the implementation class (<b>913</b>).</p>
<p id="p-0363" num="0362">In line <b>13</b> (O<b>13</b>), with the execution of the above call, the function table is searched by the called function name foo, and the corresponding instance is thus found.</p>
<p id="p-0364" num="0363">In line <b>14</b> (O<b>14</b>), a method foo( ) (corresponding to the function foo( ) included in the found instance is called and executed.</p>
<p id="p-0365" num="0364">In line <b>15</b> (O<b>15</b>), a command include to include the script file bar.php (<b>903</b> of <figref idref="DRAWINGS">FIG. 9A</figref>) is executed upon completion of the above execution.</p>
<p id="p-0366" num="0365">In line <b>16</b> (O<b>16</b>), the generation and loading of bytecode for the implementation class (<b>917</b>) corresponding to the included file bar.php (<b>903</b> of <figref idref="DRAWINGS">FIG. 9A</figref>) are directed. According to the directions, the implementation class (<b>917</b>) corresponding to the file bar.php (<b>903</b>) is generated and loaded, as shown by the arrow (O<b>16</b>). The implementation class (<b>917</b>) needs to be generated while implementing the consolidated interface class (<b>912</b>) (implementation <b>920</b>). The reason is that, according to the JAVA rule, the functions foo( ) and bar( ) defined in the consolidated interface class (<b>912</b>) must be implemented in the implementation class (<b>917</b>). However, only the function bar( ) is declared and the function foo( ) is not declared in the file bar.php (<b>903</b>) corresponding to the implementation class (<b>917</b>). To deal with this problem, this embodiment causes the implementation class (<b>917</b>) to have a function dummy( ) (<b>918</b>) which is a dummy implementation, with almost no contents, of a function foo( ).</p>
<p id="p-0367" num="0366">In line <b>17</b> (O<b>17</b>), the execution of the implementation class (<b>917</b>) corresponding to the file bar.php is directed.</p>
<p id="p-0368" num="0367">In line <b>18</b> (O<b>18</b>), a function declaration command declareFunction is executed with the execution of the implementation class (<b>917</b>). By the execution of the function declaration command declareFunction, an instance for executing a call for the function bar( ) is created by the implementation class itself.</p>
<p id="p-0369" num="0368">In line <b>19</b> (O<b>19</b>), the created instance and a function name bar for the called function bar( ) are registered in association with each other in the function table. This registration is made in order to search, upon function call, the function table for the corresponding instance, and to process the function call by use of methods foo( ) and bar( ) included in the instance thus searched out. With the above processes, the execution of the implementation class (<b>917</b>) ends, and the control returns to the implementation class (<b>913</b>).</p>
<p id="p-0370" num="0369">In line <b>20</b> (O<b>20</b>), a call for the function bar( ) (invoke bar( )) is executed with the execution of the implementation class (<b>913</b>).</p>
<p id="p-0371" num="0370">In line <b>21</b> (O<b>21</b>), with the execution of the above call, the function table is searched by the called function name bar, and the corresponding instance is thus found.</p>
<p id="p-0372" num="0371">In line <b>22</b> (O<b>22</b>), a method bar( ) (corresponding to the function bar( )) included in the found instance is called and executed.</p>
<p id="p-0373" num="0372">With the above processes, the steps of converting a PHP script into JAVA bytecode and executing the bytecode end.</p>
<p id="p-0374" num="0373"><figref idref="DRAWINGS">FIGS. 10A to 10E</figref> show an example of effects seen from reduction in the number of interface classes in a CRM (Customer Relationship Management) application.</p>
<p id="p-0375" num="0374">This example shows how JAVA bytecode is generated from code excerpted from the actual PHP application, by employing both the existing technique and the technique according to an embodiment of the invention.</p>
<p id="p-0376" num="0375"><figref idref="DRAWINGS">FIG. 10A</figref> shows an example of multiple PHP source code files excerpted from the CRM (Customer Relationship Management) application.</p>
<p id="p-0377" num="0376">The PHP source code files include the following files: index.php (<b>1001</b>); entryPoint.php (<b>1002</b>); utils.php (<b>1003</b>); Application.php (<b>1004</b>); Controller.php (<b>1005</b>); ControllerFactory.php (<b>1006</b>); and Employees/Controller.php (<b>1007</b>).</p>
<p id="p-0378" num="0377"><figref idref="DRAWINGS">FIG. 10B</figref> shows a relation between a caller and callee of each function/method and a relation between each file inclusion command and the file specified by the command, in the PHP source code tiles shown in <figref idref="DRAWINGS">FIG. 10A</figref>.</p>
<p id="p-0379" num="0378">The arrow <b>1007</b> indicates that a file entryPoint.php specified by an inclusion command require_once shown in line <b>1</b> of the PHP script file index.php (<b>1001</b>) indicates the file entryPoint.php (<b>1002</b>).</p>
<p id="p-0380" num="0379">The arrow <b>1008</b> indicates that a function Application( ) in a command new Application( ) to generate an object shown in the PHP script file index.php (<b>1001</b>) corresponds to a function declaration functionApplication( ){ } in the file Application.php (<b>1004</b>).</p>
<p id="p-0381" num="0380">The same goes for the other arrows (<b>1009</b> to <b>1021</b>), and thus a description thereof is omitted herein.</p>
<p id="p-0382" num="0381"><figref idref="DRAWINGS">FIG. 10C</figref> shows steps of converting the PHP source code shown in <figref idref="DRAWINGS">FIG. 10A</figref> into JAVA bytecode and executing the bytecode. <figref idref="DRAWINGS">FIG. 10C</figref> also shows the generation, declaration, call/execution of each function/method in chronological order.</p>
<p id="p-0383" num="0382">In <figref idref="DRAWINGS">FIG. 10C</figref>, the left-hand side shows the steps of conversion and execution (P<b>01</b> to P<b>30</b>). The right-hand side (note reference numerals <b>1011</b>-<b>1039</b>) shows, in chronological order, timings of the call, declaration, and execution of each function of the PHP source code shown in <figref idref="DRAWINGS">FIG. 10A</figref> in a way that these timings are associated with the steps (P<b>01</b> to P<b>30</b>). For example, a function Application( ) is called in line <b>2</b> (P<b>02</b>), declared in line <b>14</b> (P<b>14</b>), and executed in line <b>15</b> (P<b>15</b>). The same goes for other functions startSession( ), execute( ), Insert_charset_header( ), Controller( ), setup( ), getController( ), EmployeesController( ), pre_editview( ), and execute( ), and thus a description thereof is omitted herein. The line labeled &#x201c;Application( )&#x201d; with marks C<b>1011</b>-D<b>1012</b>-E<b>1013</b> in <figref idref="DRAWINGS">FIG. 10C</figref> indicates:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0383">the first caller-side code generation (C<b>1011</b>),</li>
        <li id="ul0002-0002" num="0384">code generation/loading for the function body and its registration in a symbol table with the function name (&#x201c;Application&#x201d;) in its execution context (D<b>1012</b>), and</li>
        <li id="ul0002-0003" num="0385">the first execution of the code (E<b>1013</b>).</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0384" num="0386"><figref idref="DRAWINGS">FIG. 10D</figref> shows implementation classes generated when the PHP source code shown in <figref idref="DRAWINGS">FIG. 10A</figref> is converted through the one function-to-one class method, with the chronological diagram shown in <figref idref="DRAWINGS">FIG. 10C</figref>.</p>
<p id="p-0385" num="0387">Implementation classes (<b>1041</b> to <b>1057</b>) are generated in bytecode to correspond to the PHP files (<b>1001</b> to <b>1007</b>) shown in <figref idref="DRAWINGS">FIG. 10A</figref>. The numbers (P<b>01</b>, P<b>03</b>, P<b>04</b>, P<b>06</b>, P<b>07</b>, P<b>08</b>, and P<b>22</b>) in arrows given on the left-hand side of the implementation classes correspond respectively to the step numbers of the conversion and execution steps shown in <figref idref="DRAWINGS">FIG. 10C</figref>.</p>
<p id="p-0386" num="0388"><figref idref="DRAWINGS">FIG. 10E</figref> shows implementation classes generated when the PHP source code shown in <figref idref="DRAWINGS">FIG. 10A</figref> is converted through the one function-to-one interface method, with the chronological diagram shown in <figref idref="DRAWINGS">FIG. 10C</figref>.</p>
<p id="p-0387" num="0389">Implementation classes (<b>1070</b> to <b>1076</b>) and interface classes (<b>1061</b> to <b>1069</b>) are generated in bytecode by converting the PHP source code shown in <figref idref="DRAWINGS">FIG. 10A</figref> through the one function-to-one interface method. The numbers (P<b>01</b>, P<b>02</b>, P<b>03</b>, P<b>04</b>, P<b>06</b>, P<b>07</b>, P<b>08</b>, and P<b>22</b>) in arrows given on the left-hand side of the implementation classes and interface classes correspond respectively to the step numbers of the conversion and execution steps shown in <figref idref="DRAWINGS">FIG. 10C</figref>.</p>
<p id="p-0388" num="0390"><figref idref="DRAWINGS">FIG. 10F</figref> shows implementation classes generated when the PHP source code shown in <figref idref="DRAWINGS">FIG. 10A</figref> is converted through the multiple functions-to-one interface method, with the chronological diagram shown in <figref idref="DRAWINGS">FIG. 10C</figref>.</p>
<p id="p-0389" num="0391">Implementation classes (<b>1081</b> to <b>1085</b>) and interface classes (<b>1086</b> to <b>1092</b>) are generated in bytecode by converting the PHP source code shown in <figref idref="DRAWINGS">FIG. 10A</figref> through the multiple functions-to-one interface method. The numbers (P<b>01</b>, P<b>02</b>, P<b>03</b>, P<b>04</b>, P<b>06</b>, P<b>07</b>, P<b>08</b>, and P<b>22</b>) in arrows given on the left-hand side of the implementation classes, interface classes, and buffer processes correspond respectively to the step numbers of the conversion and execution steps shown in <figref idref="DRAWINGS">FIG. 10C</figref>.</p>
<p id="p-0390" num="0392">A description is now given of a difference between the one function-to-one interface method shown in <figref idref="DRAWINGS">FIG. 10E</figref> and the multiple functions-to-one interface method shown in <figref idref="DRAWINGS">FIG. 10F</figref>. In <figref idref="DRAWINGS">FIG. 10E</figref>, three interface classes (<b>1061</b>, <b>1062</b>, and <b>1063</b>) are generated in the process of the arrow (P<b>02</b>), for example. On the other hand, in <figref idref="DRAWINGS">FIG. 10F</figref>, one consolidated interface class (<b>1082</b>) is generated in the process of the arrow (P<b>06</b>). The consolidated interface class (<b>1082</b>) corresponds to the three interface classes (<b>1061</b>, <b>1062</b>, and <b>1063</b>) in the one function-to-one interface method. Thus, this shows that the three interface classes (<b>1061</b>, <b>1062</b>, and <b>1063</b>) are consolidated into the one consolidated interface class (<b>1082</b>).</p>
<p id="p-0391" num="0393">Likewise, in <figref idref="DRAWINGS">FIG. 10E</figref>, two interface classes (<b>1066</b> and <b>1067</b>) are generated in the process of the arrow (P<b>07</b>), and two interface classes (<b>1068</b> and <b>1069</b>) are generated in the process of the arrow (P<b>22</b>). On the other hand, in <figref idref="DRAWINGS">FIG. 10F</figref>, one consolidated interface class (<b>1084</b>) obtained by consolidating the two interface classes (<b>1066</b> and <b>1067</b>) in <figref idref="DRAWINGS">FIG. 10F</figref> is generated in the process of the arrow (P<b>08</b>) corresponding to the arrow (P<b>07</b>) of <figref idref="DRAWINGS">FIG. 10E</figref>. In the same manner, one consolidated interface class (<b>1085</b>) obtained by consolidating the two interface classes (<b>1068</b> and <b>1069</b>) in <figref idref="DRAWINGS">FIG. 10E</figref> is generated in the process of the arrow (P<b>22</b>) corresponding to the arrow (P<b>22</b>) of <figref idref="DRAWINGS">FIG. 10E</figref>.</p>
<p id="p-0392" num="0394">As can be seen from above, the number of interface classes generated through the multiple functions-to-one interface method in <figref idref="DRAWINGS">FIG. 10F</figref> is reduced to five from nine generated through the one function-to-one interface method in <figref idref="DRAWINGS">FIG. 10E</figref>.</p>
<p id="p-0393" num="0395"><figref idref="DRAWINGS">FIG. 11A</figref> is a diagram showing a system <b>1100</b> for converting source code written in a dynamically typed language into target code written in a statically typed language, according to an embodiment of the invention.</p>
<p id="p-0394" num="0396">As shown in <figref idref="DRAWINGS">FIG. 11A</figref>, the system includes the memory (<b>1101</b>) and the storage device (<b>1102</b>). The storage device (<b>1102</b>) can be a hard disk drive or silicon disk drive. The JAVA virtual machine (<b>1103</b>) can be implemented in the memory (<b>1101</b>). The storage device (<b>1102</b>) stores therein PHP script files (<b>1104</b>). In the JAVA virtual machine (<b>1103</b>), the PHP runtime helper (<b>1105</b>), the bytecode generator (<b>1106</b>), the class loader (<b>1107</b>), a table of executable objects (<b>1108</b>), and the symbol table (<b>1109</b>) are implemented.</p>
<p id="p-0395" num="0397">The system converts source code, which is stored in the storage device (<b>1102</b>) and written in a dynamically typed language such as a PHP language (PHP script files, for example) (<b>1104</b>), into target code, which is written in a statically typed language such as JAVA (JAVA class files (<b>1112</b> of <figref idref="DRAWINGS">FIG. 11A</figref>), for example), loads the target code, and executes the target code in the JAVA virtual machine.</p>
<p id="p-0396" num="0398">The operation of the system is now described in accordance with <figref idref="DRAWINGS">FIG. 11A</figref>.</p>
<p id="p-0397" num="0399">The bytecode generator (<b>1106</b>) reads, from the storage device (<b>1102</b>), a PHP script file (<b>1104</b>) as source code, and parses the read file (<b>1110</b>).</p>
<p id="p-0398" num="0400">The bytecode generator (<b>1106</b>) converts the source code into bytecode in accordance with the process flows shown in <figref idref="DRAWINGS">FIGS. 6C and 61</figref>) (<b>1111</b>) to generate a JAVA class file (<b>1112</b>).</p>
<p id="p-0399" num="0401">Subsequently, the class loader (<b>1107</b>) loads (<b>1113</b>) the generated JAVA class file (<b>1112</b>), and obtains classes (<b>1115</b>) (<b>1114</b>). Each class (<b>1115</b>) thus obtained is either an interface class or an implementation class. While executing a specified script written in PHP or any other language, the language execution system of this system further executes another script.</p>
<p id="p-0400" num="0402">For example, the language execution system operates in accordance with a web server, and executes a script corresponding to an accessed URL. To enable fast execution, the script is compiled into bytecode which runs directly on the JAVA virtual machine, and the bytecode is loaded and executed. Typically, the compiled result is represented as a JAVA class, and the script is executed as a method call for an object (executable object) created from this class. Since such compilation or loading requires large cost, an executable object or class which has been loaded once is usually cached, and reused when accessed again.</p>
<p id="p-0401" num="0403">The operation of the PHP runtime helper (<b>1105</b>) is now described in accordance with steps <b>1</b> to <b>4</b> of <figref idref="DRAWINGS">FIG. 11A</figref>.</p>
<p id="p-0402" num="0404">In step <b>1</b>, the PHP runtime helper (<b>1105</b>) checks whether or not the cached executable object or class corresponding to the PHP script file (<b>1104</b>) in the storage device (<b>1102</b>) is valid. Whether the cached data is valid or not is determined by checking, for example, if the last updated time of a PHP script file to be processed is the same as that registered in the cache. When the cached data is valid, bytecode for the file is not generated since the program execution unit (<b>1118</b>) uses the cached data to execute the script in this case. The process moves to step <b>2</b> only when the cached data is not valid. The process moves to step <b>3</b> without passing through step <b>2</b> when the cached data is valid.</p>
<p id="p-0403" num="0405">In step <b>2</b>, the PHP runtime helper (<b>1105</b>) requests the bytecode generator (<b>1106</b>) to process the script (i.e., processes shown in steps <b>641</b> to <b>646</b> of <figref idref="DRAWINGS">FIG. 6C</figref>). According to the request, the bytecode generator (<b>1106</b>) gives the PHP runtime helper (<b>1105</b>) a class obtained by generating and loading bytecode corresponding to the requested script file. The PHP runtime helper (<b>1105</b>) instantiates the obtained class to create an executable object, and puts the executable object in the cache.</p>
<p id="p-0404" num="0406">In step <b>3</b>, the PHP runtime helper (<b>1105</b>) registers the executable object in the symbol table (<b>1109</b>) valid within the current execution scope (e.g., during a process of one request by a web server).</p>
<p id="p-0405" num="0407">In step <b>4</b>, the PHP runtime helper (<b>1105</b>) finds the executable object from the symbol table (<b>1109</b>) and executes the object thus found. Specifically, the PHP runtime helper (<b>1105</b>) calls a method, such as executeScript( ), of the executable object, and requests the JAVA virtual machine (<b>1103</b>) to execute the called method.</p>
<p id="p-0406" num="0408"><figref idref="DRAWINGS">FIG. 11B</figref> is a diagram showing a relation between an execution helper and an executable object created as a result of conversion, according to an embodiment of the invention.</p>
<p id="p-0407" num="0409">The execution helper (<b>1121</b>) is a PHP runtime helper, for example. There are many common processes among processes related to script execution. The execution helper (<b>1121</b>) is a module for helping the execution of such common processes. The common processes include, for example, a basic calculation process such as addition of values, and the process of include( ) which has been noted above.</p>
<p id="p-0408" num="0410">The execution helper (<b>1121</b>) calls (<b>1123</b>) the executable object (<b>1122</b>), and receives an instruction from the executable object (<b>1122</b>) to activate a PHP command (<b>1124</b>), and helps the activation. The program execution unit (<b>1118</b>) executes bytecode, which is converted from a PHP script by the bytecode generator (<b>1106</b>), while letting the PHP runtime helper perform a part of the execution process. The program execution unit (<b>1118</b>) is an ordinary JAVA program execution unit, and includes an interpreter (<b>1119</b>) and a JIT compiler (<b>1120</b>). Code generated by the interpreter (<b>1119</b>) or the JIT compiler (<b>1120</b>) is executed by a CPU (<b>1202</b> of <figref idref="DRAWINGS">FIG. 12</figref>). Note also call <b>1125</b>.</p>
<p id="p-0409" num="0411"><figref idref="DRAWINGS">FIG. 11C</figref> is a diagram showing the bytecode generator and the signature-interface registration unit, according to an embodiment of the invention.</p>
<p id="p-0410" num="0412">The JAVA virtual machine (<b>1103</b>) includes the signature-interface registration unit (<b>1131</b>) and the bytecode generator (<b>1106</b>).</p>
<p id="p-0411" num="0413">The signature-interface registration unit (<b>1131</b>) is a storage device for storing therein the data structure of <figref idref="DRAWINGS">FIG. 7</figref> in which signatures and interface classes are registered.</p>
<p id="p-0412" num="0414">The bytecode generator (<b>1106</b>) includes the interface class generator (<b>1132</b>), the buffer (<b>1133</b>), and an implementation class generator (<b>1134</b>).</p>
<p id="p-0413" num="0415">The interface class generator (<b>1132</b>) generates a consolidated interface class (step <b>688</b> of <figref idref="DRAWINGS">FIG. 6E</figref>, and step <b>694</b> of <figref idref="DRAWINGS">FIG. 6F</figref>).</p>
<p id="p-0414" num="0416">The buffer (<b>1134</b>) is a place to store signatures.</p>
<p id="p-0415" num="0417">The implementation class generator (<b>1134</b>) includes the declaration interface list (<b>1135</b>), the declaration function list (<b>1136</b>), and the call function list (<b>1137</b>). The declaration interface list (<b>1135</b>) indicates a data structure in which the name of a caller interface class corresponding to the declared function/method is held in a list format, and is a list to which an interface class name is added in step <b>634</b> of <figref idref="DRAWINGS">FIG. 6B</figref> or in step <b>674</b> of <figref idref="DRAWINGS">FIG. 6D</figref>, for example. The declaration function list (<b>1136</b>) is used for the process of clearing the buffer (<b>1133</b>) performed only in a case where the generated implementation class includes a declaration of a function corresponding to any one of signatures in the buffer (<b>1133</b>). The call function list (<b>1137</b>) indicates a data structure in which the signature of a function (to be called) which appears in a caller is held in a list format.</p>
<p id="p-0416" num="0418"><figref idref="DRAWINGS">FIG. 12</figref> is a block diagram showing computer hardware included in the system of <figref idref="DRAWINGS">FIG. 11A</figref> according to an embodiment of the invention.</p>
<p id="p-0417" num="0419">A computer system (<b>1201</b>) includes the CPU (<b>1202</b>) and a main memory (<b>1203</b>) which are connected to a bus (<b>1204</b>). The CPU (<b>1202</b>) is preferably based on 32-bit or 64-bit architecture. Examples usable as the CPU (<b>1202</b>) include the XEON series, CORE series, ATOM series, PENTIUM series, and CELERON series of Intel Corporation, and the PHENOM series, ATHLON series, TURION series, and SEMPRON series of Advanced Micro Devices, Inc. A display (<b>1206</b>) such as a TFT monitor is connected to the bus (<b>1204</b>) through a display controller (<b>1205</b>). The display (<b>1206</b>) is used to display, on a proper graphic interface, information on the computer system connected to a network via a communication line (<b>1215</b>) and information on software running on the computer system, for the purpose of managing the computer system. Also, a hard disk or a silicon disk (<b>1208</b>), and a CD-ROM drive, a DVD drive, or a BD drive (<b>1209</b>) are connected to the bus (<b>1204</b>) through an IDE or S-ATA controller (<b>1207</b>).</p>
<p id="p-0418" num="0420">An operating system, an application program, and data are stored in the hard disk (<b>1208</b>) to be loadable in the main memory (<b>1203</b>).</p>
<p id="p-0419" num="0421">The CD-ROM drive, the DVD drive, or the BD drive (<b>1209</b>) is used to additionally load a program as needed from a CD-ROM, a DVD-ROM or a BD into the hard disk (<b>1208</b>). A keyboard (<b>1211</b>) and a mouse (<b>1212</b>) are also connected to the bus (<b>1204</b>) through a keyboard/mouse controller (<b>1210</b>).</p>
<p id="p-0420" num="0422">A communication interface (<b>1214</b>) is compliant with an Ethernet protocol, for example. The communication interface (<b>1214</b>) is connected to the bus (<b>1204</b>) through a communication controller (<b>1213</b>) and functions to physically connect the computer system and the communication line (<b>1215</b>). The communication interface (<b>1214</b>) also provides a network interface layer to a TCP/IP communication protocol which is a communication function of the operating system of the computer system. Here, the communication line (<b>1215</b>) may be a wired LAN environment, or a wireless LAN environment based on a wireless LAN connection standard such as IEEE 802.11a/b/g/n.</p>
<p id="p-0421" num="0423">Having reviewed the disclosure herein, including <figref idref="DRAWINGS">FIG. 12</figref>, the skilled artisan will appreciate that aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium(s) having computer readable program code embodied thereon. Any combination of one or more computer readable medium(s) may be utilized. The computer readable medium may be a computer readable signal medium (e.g., signals on line <b>1215</b>) or a computer readable storage medium (e.g., HDD <b>1208</b>, DVD in drive <b>1209</b>). A computer readable storage medium may be, for example, but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, or device, or any suitable combination of the foregoing. More specific examples (a non-exhaustive list) of the computer readable storage medium would include the following: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), an optical fiber, a portable compact disc read-only memory (CD-ROM), an optical storage device, a magnetic storage device, or any suitable combination of the foregoing. In the context of this document, a computer readable storage medium may be any tangible medium that can contain, or store a program for use by or in connection with an instruction execution system, apparatus, or device.</p>
<p id="p-0422" num="0424">A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein, for example, in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms, including, but not limited to, electro-magnetic, optical, or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate, propagate, or transport a program for use by or in connection with an instruction execution system, apparatus, or device.</p>
<p id="p-0423" num="0425">Program code embodied on a computer readable medium may be transmitted using any appropriate medium, including but not limited to wireless, wireline, optical fiber cable, RF, etc., or any suitable combination of the foregoing.</p>
<p id="p-0424" num="0426">Distinct software modules for carrying aspects of embodiments of the invention can be, in at least some cases, embodied on a computer readable storage medium</p>
<p id="p-0425" num="0427"><figref idref="DRAWINGS">FIGS. 13A to 13E</figref> show inclusion relations among the processes in the steps of conversion and execution shown in <figref idref="DRAWINGS">FIGS. 2C</figref>, <b>3</b>A, <b>4</b>A, <b>8</b>B, and <b>9</b>B.</p>
<p id="p-0426" num="0428">In each of these drawings, each inclusion relation is shown by an indent, and also by a frame for easier understanding.</p>
<p id="p-0427" num="0429"><figref idref="DRAWINGS">FIG. 13A</figref> shows inclusion relations among the processes in the steps of conversion and execution in <figref idref="DRAWINGS">FIG. 2C</figref>.</p>
<p id="p-0428" num="0430">It can be seen from this drawing that an inclusion command include is directed in line <b>1</b> (E<b>01</b>), and that the steps in lines <b>2</b> to <b>12</b> (E<b>02</b> to E<b>12</b>) are executed as sub-steps of E<b>01</b>. Each inclusion relation among the processes of lines <b>2</b> to <b>12</b> (E<b>02</b> to E<b>12</b>) is shown in the same manner as above.</p>
<p id="p-0429" num="0431"><figref idref="DRAWINGS">FIG. 13B</figref> shows inclusion relations among the processes in the steps of conversion and execution in <figref idref="DRAWINGS">FIG. 3A</figref>.</p>
<p id="p-0430" num="0432">It can be seen from this drawing that an inclusion command include is directed in line <b>1</b> (F<b>01</b>), and that the steps in lines <b>2</b> to <b>13</b> (F<b>02</b> to F<b>13</b>) are executed as sub-steps of F<b>01</b>. Each inclusion relation among the processes of lines <b>2</b> to <b>13</b> (F<b>02</b> to F<b>13</b>) is shown in the same manner as above.</p>
<p id="p-0431" num="0433"><figref idref="DRAWINGS">FIG. 13C</figref> shows inclusion relations among the processes in the steps of conversion and execution in <figref idref="DRAWINGS">FIG. 4A</figref>.</p>
<p id="p-0432" num="0434">It can be seen from this drawing that an inclusion command include is directed in line <b>1</b> (J<b>01</b>), and that the steps in lines <b>2</b> to <b>18</b> (J<b>02</b> to J<b>18</b>) are executed as sub-steps of J<b>01</b>. Each inclusion relation among the processes of lines <b>2</b> to <b>18</b> (J<b>02</b> to J<b>18</b>) is shown in the same manner as above.</p>
<p id="p-0433" num="0435"><figref idref="DRAWINGS">FIG. 13D</figref> shows inclusion relations among the processes in the steps of conversion and execution in <figref idref="DRAWINGS">FIG. 8B</figref>.</p>
<p id="p-0434" num="0436">It can be seen from this drawing that an inclusion command include is directed in line <b>1</b> (N<b>01</b>), and that the steps in lines <b>2</b> to <b>19</b> (N<b>02</b> to N<b>19</b>) are executed as sub-steps of N<b>01</b>. Each inclusion relation among the processes of lines <b>2</b> to <b>19</b> (N<b>02</b> to N<b>19</b>) is shown in the same manner as above.</p>
<p id="p-0435" num="0437"><figref idref="DRAWINGS">FIG. 13E</figref> shows inclusion relations among the processes in the steps of conversion and execution in <figref idref="DRAWINGS">FIG. 9B</figref>.</p>
<p id="p-0436" num="0438">It can be seen from this drawing that an inclusion command include is directed in line <b>1</b> (O<b>01</b>), and that the steps in lines <b>2</b> to <b>22</b> (O<b>02</b> to <b>022</b>) are executed as sub-steps of O<b>01</b>. Each inclusion relation among the processes of lines <b>2</b> to <b>22</b> (O<b>02</b> to <b>022</b>) is shown in the same manner as above.</p>
<heading id="h-0007" level="1">Example 1</heading>
<p id="p-0437" num="0439">In the case of SugarCRM 5.0.0c which is an open source CRM application, 2686 interface classes were generated through the one function-to-one class method while 941 interface classes were generated through the multiple functions-to-one interface method being an embodiment of the invention. Thus, the number of interface classes generated through the multiple functions-to-one interface method was less by 1923 than that generated through the one function-to-one class method.</p>
<p id="p-0438" num="0440">As can be seen from the above result, the multiple functions-to-one interface method which is an embodiment of the invention is capable of reducing the number of interface classes to be generated as compared to that in the conventional compilation method, without using the slow reflection mechanism. In particular, the larger the number of functions/methods declared on a per-compilation basis (on a file basis, for example) in a source program, the larger number of interface classes the multiple functions-to-one interface method which is an embodiment of the invention is capable of reducing, i.e., the more remarkably the effects of the invention are exhibited.</p>
<p id="p-0439" num="0441">The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein, the singular forms &#x201c;a&#x201d;, &#x201c;an&#x201d; and &#x201c;the&#x201d; are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms &#x201c;comprises&#x201d; and/or &#x201c;comprising,&#x201d; when used in this specification, specify the presence of stated features, integers, steps, operations, elements, and/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, elements, components, and/or groups thereof.</p>
<p id="p-0440" num="0442">The corresponding structures, materials, acts, and equivalents of all means or step plus function elements in the claims below are intended to include any structure, material, or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description, but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for converting source code written in a dynamically typed language into target code written in a statically typed language, the method comprising the steps, executed by a computer, of:
<claim-text>generating in a storage device the target code from the source code, the step of generating the target code in turn comprising storing in a buffer a signature of a function/method used by a caller in the source code, wherein generation of an interface class is delayed to a time point immediately before execution of a part of the target code corresponding to the function/method call by the caller, the interface class being needed to generate the caller and serving as an interface in the statically typed language; and</claim-text>
<claim-text>generating in the storage device a consolidated interface class for all signatures stored in the buffer, and loading the generated consolidated interface class from the storage device, wherein all the signatures in the buffer are deleted upon generation of the consolidated interface class;</claim-text>
<claim-text>wherein the step of generating the target code from the source code includes generating a function/method declaration corresponding to the caller in the source code.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the generating of the function/method declaration includes the steps of:
<claim-text>checking whether a signature of a declared function/method is in the buffer, and whether an interface class corresponding to the declared function/method has already been generated; and</claim-text>
<claim-text>adding the signature of the declared function/method to a declaration function list in a case where the signature of the declared function/method is not in the buffer and where the interface class corresponding to the declared function/method has not been generated yet.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the generating of the function/method declaration includes the steps of:
<claim-text>checking whether a signature of a declared function/method is in the buffer, and whether an interface class corresponding to the declared function/method has already been generated; and</claim-text>
<claim-text>adding a corresponding interface class name to a declaration interface list in either of cases where the signature of the declared function/method is not in the buffer and where the interface class corresponding to the declared function/method has not been generated yet.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method according to <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the generating of the function/method declaration further includes:
<claim-text>generating in the storage device bytecode of a script for a process of the declared function/method; and</claim-text>
<claim-text>generating in the storage device code for associating the generated bytecode with the declared function/method.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method according to <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the step of generating and loading an interface class further includes:
<claim-text>checking whether the declaration function list is empty;</claim-text>
<claim-text>if the declaration function list is not empty, checking whether an interface class name associated with the buffer exists in the declaration interface list; and</claim-text>
<claim-text>if the interface class name associated with the buffer exists, adding to the buffer the signature in the declaration function list and a signature in a call function list.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method according to <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the step of generating and loading an interface class further includes the steps of:
<claim-text>generating in the storage device one interface class from the added signature, and loading the generated interface class from the storage device; and</claim-text>
<claim-text>adding a name of the loaded interface class to the declaration interface list.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method according to <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the step of generating and loading an interface class further includes the steps of:
<claim-text>checking whether the declaration function list is empty;</claim-text>
<claim-text>if the declaration function list is not empty, checking whether an interface class name associated with the buffer exists in the declaration interface list; and</claim-text>
<claim-text>if no interface class name associated with the buffer exists, generating, from the signature in the declaration function list, the consolidated interface class independent of the buffer, and loading the generated consolidated interface class; and</claim-text>
<claim-text>adding a name of the loaded interface class to the declaration interface list.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method according to <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the step of generating and loading an interface class further includes the steps of:
<claim-text>checking whether the declaration function list is empty; and</claim-text>
<claim-text>if the declaration function list is empty, adding to the buffer a signature in a call function list.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising the step, executed by the computer, of executing the target code obtained by the conversion.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. A computer for converting source code written in a dynamically typed language into target code written in a statically typed language, the computer comprising:
<claim-text>a generator which generates in a storage device the target code from the source code, and stores in a buffer a signature of a function/method used by a caller in the source code, wherein generation of an interface class is delayed to a time point immediately before execution of a part of the target code corresponding to the function/method call by the caller, the interface class being needed to generate the caller and serving as an interface in the statically typed language; and</claim-text>
<claim-text>a first processor which generates in the storage device a consolidated interface class for all signatures stored in the buffer, and loads the generated consolidated interface class from the storage device, wherein all the signatures in the buffer are deleted upon generation of the consolidated interface class;</claim-text>
<claim-text>wherein the generator generates the target code from the source code by generating a function/method declaration corresponding to the caller in the source code.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. A computer program product for converting source code written in a dynamically typed language into target code written in a statically typed language, the computer program product comprising:
<claim-text>a non-transitory computer readable storage medium having computer readable program code embodied therewith, the computer readable program code comprising:
<claim-text>computer readable program code configured to generate in a storage device the target code from the source code, by storing in a buffer a signature of a function/method used by a caller in the source code, wherein generation of an interface class is delayed to a time point immediately before execution of a part of the target code corresponding to the function/method call by the caller, the interface class being needed to generate the caller and serving as an interface in the statically typed language; and</claim-text>
<claim-text>computer readable program code configured to generate in the storage device a consolidated interface class for all signatures stored in the buffer, and load the generated consolidated interface class from the storage device, wherein all the signatures in the buffer are deleted upon generation of the interface class;</claim-text>
</claim-text>
<claim-text>wherein the computer readable program code configured to generate the target code from the source code generates the target code from the source code by generating a function/method declaration corresponding to the caller in the source code. </claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
