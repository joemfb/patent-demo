<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627111-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627111</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12243903</doc-number>
<date>20081001</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>1159</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>11</main-group>
<subgroup>30</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>713193</main-classification>
</classification-national>
<invention-title id="d2e53">Managing associations between keys and values</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>7725437</doc-number>
<kind>B2</kind>
<name>Kirshenbaum et al.</name>
<date>20100500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707640</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>7895666</doc-number>
<kind>B1</kind>
<name>Eshghi et al.</name>
<date>20110200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>726 30</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>2004/0107186</doc-number>
<kind>A1</kind>
<name>Najork et al.</name>
<date>20040600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  3</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2006/0106857</doc-number>
<kind>A1</kind>
<name>Lillibridge et al.</name>
<date>20060500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707102</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>2007/0061311</doc-number>
<kind>A1</kind>
<name>Kurose</name>
<date>20070300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  3</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2007/0276843</doc-number>
<kind>A1</kind>
<name>Lillibridge et al.</name>
<date>20071100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707100</main-classification></classification-national>
</us-citation>
<us-citation>
<nplcit num="00007">
<othercit>S. Lyall, Cancel-Locks in Usenet Articles, May 1999,Usefor Working Group, pp. 1-5.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
</us-references-cited>
<number-of-claims>19</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>713193</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>10</number-of-drawing-sheets>
<number-of-figures>13</number-of-figures>
</figures>
<us-related-documents>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61047331</doc-number>
<date>20080423</date>
</document-id>
</us-provisional-application>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20100083004</doc-number>
<kind>A1</kind>
<date>20100401</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Kirshenbaum</last-name>
<first-name>Evan R</first-name>
<address>
<city>Mountain View</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Kirshenbaum</last-name>
<first-name>Evan R</first-name>
<address>
<city>Mountain View</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Hewlett-Packard Development Company, L.P.</orgname>
<role>02</role>
<address>
<city>Houston</city>
<state>TX</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Zele</last-name>
<first-name>Krista</first-name>
<department>2453</department>
</primary-examiner>
<assistant-examiner>
<last-name>Benoit</last-name>
<first-name>Esther</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Provided are, among other things, systems, methods and techniques for managing associations between keys and values within a computer processing system. In one exemplary implementation, requests to store associations between keys and data values corresponding to the keys are input, and the associations are stored in entry nodes within a data structure represented as a hash-based directed acyclic graph (HDAG). Upon receipt of a data value request and accompanying request key, together with satisfaction of any additional access criterion, a return data value corresponding to the request key automatically is provided, the return data value having been generated based on at least one of the associations that involve the request key.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="142.58mm" wi="119.04mm" file="US08627111-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="209.89mm" wi="147.32mm" file="US08627111-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="155.87mm" wi="137.41mm" file="US08627111-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="218.02mm" wi="150.88mm" file="US08627111-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="110.66mm" wi="146.73mm" file="US08627111-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="89.15mm" wi="130.56mm" file="US08627111-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="213.53mm" wi="145.46mm" file="US08627111-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="179.24mm" wi="146.81mm" file="US08627111-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="193.21mm" wi="100.41mm" file="US08627111-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="155.36mm" wi="119.38mm" file="US08627111-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="80.18mm" wi="99.99mm" file="US08627111-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CROSS REFERENCE TO RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">This Application claims the benefit of U.S. Provisional Application Ser. No. 61/047,331 filed Apr. 23, 2008, titled &#x201c;Managing Associations Between Keys And Values&#x201d; which is hereby incorporated by reference herein as if reproduced in full below.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">FIELD OF THE INVENTION</heading>
<p id="p-0003" num="0002">The present invention generally pertains to systems, methods and techniques for managing associations between keys and values and can be used, e.g., for storing metadata about files and other data objects and/or for controlling access to decryption keys or other sensitive information.</p>
<heading id="h-0003" level="1">BACKGROUND</heading>
<p id="p-0004" num="0003">There often arises a need to make information available, either to a general population of users or only to certain individuals. Moreover, it sometimes is desirable to make such information available on a secure basis. For example, one context in which this problem arises is the communication of decryption keys to the particular individuals who are authorized to view corresponding encrypted files, while at the same time taking appropriate measures in an attempt to preclude unauthorized individuals from obtaining such information. In fact, in such situations it often will be advantageous to preclude anyone from obtaining information that he or she does not absolutely require, including secondary information, such as who has been granted access rights to which files. Complicating this problem is the fact that both the information and the people who are supposed to have access to it sometimes change over time.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0005" num="0004">In the following disclosure, the invention is described with reference to the attached drawings. However, it should be understood that the drawings merely depict certain representative and/or exemplary embodiments and features of the present invention and are not intended to limit the scope of the invention in any manner. The following is a brief description of each of the attached drawings.</p>
<p id="p-0006" num="0005"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram illustrating a computer system within which certain embodiments of the present invention are implemented;</p>
<p id="p-0007" num="0006"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram illustrating storage of a key-value association;</p>
<p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. 3</figref> is a flow diagram illustrating a process for managing storage of associations between keys and values, as well as retrieval of the stored values;</p>
<p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. 4</figref> illustrates a portion of a HDAG data structure;</p>
<p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. 5</figref> illustrates an example of certain contents of an entry node within a HDAG data structure;</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 6</figref> illustrates an example of a value list node, as well as certain of its relationships to other nodes;</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 7</figref> is a block diagram showing the relationship between key-value associations and value list nodes according to a representative embodiment of the invention;</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 8</figref> is a conceptual block diagram providing an overview of the system according to representative embodiments and of the present invention;</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 9</figref> is a block diagram illustrating examples of data-value requests and the returned data values;</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 10</figref> illustrates the structure of an exemplary self-describing digest abstraction scheme descriptor;</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 11</figref> illustrates the meanings of different values for the length field of a scheme descriptor according to a representative embodiment of the invention;</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 12</figref> illustrates general meanings of different values for the algorithm type field of a scheme descriptor according to a representative embodiment of the invention; and</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 13</figref> illustrates a sample set of initial scheme descriptor value assignments.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DESCRIPTION OF THE PREFERRED EMBODIMENT(S)</heading>
<p id="p-0019" num="0018">This disclosure is in some respects an extension of the disclosures set forth in U.S. patent application Ser. No. 11/149,509, filed Jun. 10, 2005, titled &#x201c;Identifying Characteristics in Sets of Organized Items&#x201d; and published as U.S. Patent Application Publication No. 20060282475 on Dec. 14, 2006, Ser. No. 11/514,634, filed Sep. 1, 2006, and titled, &#x201c;Data Structure Representation Using Hash-Based Directed Acyclic Graphs and Related Method&#x201d; (the '634 application), and Ser. No. 11/888,092, filed Jul. 31, 2007, and titled, &#x201c;Storing Nodes Representing Respective Chunks of Files in a Data Store&#x201d; (the '092 application), which applications are incorporated by reference herein as though set forth herein in full. The present disclosure also is related to the concurrently filed, commonly assigned patent applications by the present inventor titled &#x201c;Decryption Key Management&#x201d; (the &#x201c;Key Management&#x201d; application) and titled &#x201c;Access Grants&#x201d; (the &#x201c;Access Grants&#x201d; application), which applications also are incorporated by reference herein as though set forth herein in full.</p>
<p id="p-0020" num="0019">The present invention addresses, among other things, the problem of how to distribute, or otherwise make available, various kinds of information. In certain embodiments, such information can be characterized as metadata that describe or otherwise pertain to particular data objects (e.g., arranged in a hierarchical data structure) containing substantive content. In other embodiments, the information comprises content that has independent value.</p>
<p id="p-0021" num="0020">An example of one context in which certain aspects of the present invention may be utilized is system <b>10</b>, illustrated in <figref idref="DRAWINGS">FIG. 1</figref>. As shown in system <b>10</b>, a user <b>12</b> operating through a computer <b>14</b> accesses data in a server <b>16</b> (sometimes referred to herein as the data store) via network <b>18</b>. At the same time, a number of other users <b>22</b> (e.g., tens, hundreds or thousands of other users) also are able to access server <b>16</b> via network <b>18</b>. Although server <b>16</b> is shown as a single component, in certain embodiments it is comprised of multiple server boxes (e.g., collectively functioning as a single logical unit).</p>
<p id="p-0022" num="0021">Within server <b>16</b> is a database <b>19</b>, which includes stored associations between keys and values according to the present invention. Application <b>21</b> controls access to the data within database <b>19</b>. Generally speaking, the data within server <b>16</b> can include any kind of values which one would like to make available, often to a large number of people.</p>
<p id="p-0023" num="0022">In certain representative embodiments, server <b>16</b> corresponds, e.g., to the file server or to the backup server discussed in the &#x201c;Key Management&#x201d; application. In either such case, the data stored and retrieved according to the techniques described below can include decryption keys for encrypted files and/or any of a variety of different kinds of metadata pertaining to stored files or portions thereof. As noted in the &#x201c;Key Management&#x201d; application, data files and portions thereof can be stored in a data structure formatted as a hash-based directed acyclic graph (HDAG). In addition (or instead), as discussed below, associations between keys and values can be stored within an overall HDAG structure.</p>
<p id="p-0024" num="0023">The most obvious approach to storing associations between keys and data values is to simply maintain a table mapping keys (e.g., keys known to certain authorized individuals) to corresponding data values. However, there are several problems with this approach:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0024">First, anyone with permission to set a value would have permission, by doing so, to delete a value already in the map. This has serious implications in many situations (e.g., in the context of a decryption key store), as the key, which preferably is a hash or other function of a value that includes the grantee's identity and an identifier for the data object, can be computed by anyone knowing this information, and so anybody who knows both can assert a bogus key, rendering the data inaccessible to someone who was supposed to have been able to read it.</li>
        <li id="ul0002-0002" num="0025">Second, anyone with permission to read a value can, by doing so, determine that a value has been set. In the context of a decryption key store, this means that even if someone cannot use the encryption key to decrypt the data, he or she can still gain information that a particular entity has been granted access to it.</li>
        <li id="ul0002-0003" num="0026">Third, associations remain in the map until they are explicitly deleted. They would not be easily amenable to a desired &#x201c;retention policy&#x201d;-based automatic reclamation of the rest of the data store. This often would result in the metadata outliving the data it describes, even when not useful or desirable.</li>
        <li id="ul0002-0004" num="0027">Fourth, such an approach would make it difficult to verify that a large number of associations that are supposed to be stored are, in fact, there. An easy way to verify existence of associations often is highly desirable.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0025" num="0028">In order to address the foregoing problems, the present invention provides systems that include request-management processes and techniques, as well as storage data structures. With regard to storage, as shown in <figref idref="DRAWINGS">FIG. 2</figref>, the preferred embodiments of the present invention employ a structure utilizing two kinds of storage nodes: entry nodes <b>42</b> that store associations that are requested (by authorized entities) to be made between keys and data values and value list nodes <b>43</b> that store the data values pertaining to a common key. Preferably, the entry nodes <b>42</b> reflect associations in the manner they are asserted and, therefore, correspond to the entities that are asserting the associations, while the value list nodes store information for responding to a retrieval request and, therefore, correspond to individual keys.</p>
<p id="p-0026" num="0029">Upon receiving a request <b>45</b> to associate a key with a data value, storage manager <b>50</b> (e.g., a subcomponent of management application <b>21</b>) preferably creates entry node <b>42</b> to store the association and simultaneously creates (or supplements) value list node <b>43</b> to reflect any impact the association has on future retrieval requests pertaining to the key. Additional detail regarding these aspects of the invention is discussed below.</p>
<p id="p-0027" num="0030">An exemplary process <b>70</b> that is implemented by management application <b>21</b> in certain embodiments of the invention is shown in <figref idref="DRAWINGS">FIG. 3</figref>. Preferably, process <b>70</b> is fully automated so that it can be performed using one or more computer processors to run computer-executable process steps stored on one or more computer-readable media, or in any of the other ways described herein. As indicated above, process <b>70</b> can be used, e.g., for the storage and retrieval of various kinds of sensitive and/or non-sensitive information.</p>
<p id="p-0028" num="0031">Initially, in step <b>71</b> a request (e.g., request <b>45</b>) to store an association between a key and a data value is received by storage manager subcomponent <b>50</b>. It is noted that such a request can take different forms in different embodiments of the invention. For example, in one set of embodiments, the request includes an explicit call, e.g., of the form, &#x201c;Please associate this value with this key,&#x201d; or &#x201c;Please associate these values with these respective keys.&#x201d; In another set of embodiments, the request is generally of the form &#x201c;Please store this entry node,&#x201d; which the data store <b>16</b> then recognizes by its form (e.g., by a &#x201c;node type&#x201d; indicator contained in it as containing associations that should be added to the system.</p>
<p id="p-0029" num="0032">In one exemplary embodiment, the key corresponds to a particular user who is being granted access (i.e., the grantee) and also corresponds to a particular file, folder or other data object for which access is being granted (but instead could correspond to either one alone), and the data value corresponds to a decryption key that is used to decrypt the data object (or any other metadata pertaining to the data object). One such embodiment is described in more detail in the &#x201c;Key Management&#x201d; application.</p>
<p id="p-0030" num="0033">More generally, however, the key can be (or include) any desired value, including hashes of chunks, arbitrary strings or hashes of arbitrary values. Often, the key will correspond in some manner to the type of data value with which it is associated. In one example, the key includes or is a function of information designating &#x201c;weather&#x2014;Los Angeles&#x201d;, and the data value includes component values for temperature, barometric pressure, wind speed, wind direction, etc.</p>
<p id="p-0031" num="0034">In this regard, the term &#x201c;data value&#x201d; as used herein can comprise a single value (e.g., a decryption key as described in the &#x201c;Key Management&#x201d; application) or an array or set of component values of the same or different types (e.g., an entire set of values for entry into the fields of a pre-defined form). Generally speaking, the request <b>45</b> can involve any kind of data value.</p>
<p id="p-0032" num="0035">In addition to the key and data value, the request <b>45</b> frequently will include other kinds of information as well, such as override information and/or access control information. In any event, the request <b>45</b> preferably can be initiated by a user <b>12</b>, either directly or, e.g., indirectly by the user <b>12</b> assigning association-assertion rights to another entity through a user interface running on her computer <b>14</b>.</p>
<p id="p-0033" num="0036">In step <b>72</b>, the association in request <b>45</b> is stored. One aspect of the preferred embodiments of the present invention is the decoupling of defined associations from the data value(s) that are returned in response to a query. In order to achieve such decoupling, as previously noted, in the embodiment shown in <figref idref="DRAWINGS">FIG. 2</figref> the storage manager <b>50</b> uses two different kinds of storage nodes: an entry node <b>42</b>, e.g., which includes keys and other information pertaining one or more defined associations which are desired to be managed together, and a value list node <b>43</b>, e.g. which includes the data values and other information pertaining to a particular key.</p>
<p id="p-0034" num="0037">Ordinarily, the entry node <b>42</b> is newly generated for each new key-value association request <b>45</b> (storing all key-value associations asserted in one request), while the value list node <b>43</b> preferably is identical across all associations involving the same key. Therefore, the value list node <b>43</b> either is newly generated (if no previous association with the same key has been stored) or is simply accessed and the new information added to it (if such a previous association has been stored). In some embodiments, there is more than one value list node <b>43</b> corresponding to a single key for purposes of federation, performance, or fault tolerance. In an exemplary embodiment of a system in which assertions of associations are more frequent than lookups, a second, temporary value list node reflecting recent changes to associations having to do with a key is kept in memory and merged with the longer-lived value list node <b>43</b> kept in permanent storage when the system is quiescent. When there is a lookup in such a system, both value list nodes typically are checked and their contents merged.</p>
<p id="p-0035" num="0038">In certain embodiments, the entry node <b>42</b> can be accessed subsequently by submission of a value known to the entity asserting the association, while the value list node is an internal, derivative node that is used by management application <b>21</b> but is not directly accessible by any other entity. One potential benefit of this structure is to give users significant flexibility in defining associations while simultaneously maintaining greater control over the data values that are associated with corresponding keys. Another potential benefit, particularly in embodiments where security is an important concern, is to make it more difficult for individual entities to determine who (other than themselves) has been granted access to particular data values.</p>
<p id="p-0036" num="0039">Referring back to <figref idref="DRAWINGS">FIG. 2</figref>, in order to coordinate the information between the various entry nodes <b>42</b> and the value list nodes <b>43</b>, each entry node <b>42</b> preferably includes a reference <b>52</b> to each value list node <b>42</b> to which it corresponds (e.g., one for each key designated in the entry node <b>42</b>), and each value list node <b>43</b> preferably includes a reference <b>53</b> to each entry node <b>42</b> storing an association that pertains to it (e.g., an association including the key that corresponds to such value list node <b>43</b>).</p>
<p id="p-0037" num="0040">References to the value list nodes <b>43</b> that are stored in the entry nodes <b>42</b> preferably are generated by using a unique hashing technique, one that is different from any other hashing technique used in the system. In one representative embodiment in which the MD-5 hash is used for other node references, the special hash used for referencing value list nodes <b>43</b> is computed by first-calculating a MD-5 hash of the key and then computing a bitwise complement or by performing a bitwise exclusive-or (XOR) operation using a defined bit string. In the preferred embodiment, the hashes generated by this unique hashing technique are recognizably different from other hashes, as is described below.</p>
<p id="p-0038" num="0041">The association stored in the entry node <b>42</b> preferably includes the key, together with certain additional information. In the present embodiment, such additional information includes: (1) a data value (which, as noted previously, can include multiple different components or values) designated by the requester with which the key is to be associated, digests (e.g., hashes) of such data values and/or references to one or more other nodes that include the data value (such references potentially being hashes of the data values); (2) one or more optional override locks; (3) one or more optional override keys; (4) an optional set of access values and/or criteria (the word &#x201c;optional&#x201d; here meaning at the option of the requester, i.e., the entity asserting the association); and (5) in some cases, references to other entry nodes.</p>
<p id="p-0039" num="0042">In this latter regard, in certain embodiments the entry nodes are stored in data structures. For example, in one preferred embodiment the entry nodes are stored in HDAGs (e.g., a single HDAG for all of the associations asserted by a particular entity or all of the associations asserted by a particular entity in a given session). In addition, such HDAGs or other data structures preferably are contained within retention groups (i.e., groups of associations that have common rules regarding when they are to expire).</p>
<p id="p-0040" num="0043">Generally speaking, in a HDAG data structure a hierarchical arrangement of data is represented by a set of nodes in an acyclic graph. An example of a portion of a HDAG data structure <b>95</b> is shown in <figref idref="DRAWINGS">FIG. 4</figref>. In this example, all of the data are represented by a root node <b>100</b>. Root node <b>100</b>, in turn, has a number of child nodes, such as child nodes <b>103</b>-<b>105</b>. Included within root node <b>100</b> is certain data (often, just metadata at this level) and a separate hash of at least some of the contents of each of its child nodes (e.g., hashes <b>111</b>-<b>113</b> of nodes <b>103</b>-<b>105</b>, respectively), with each hash functioning as a reference to the corresponding child node.</p>
<p id="p-0041" num="0044">Each such child node <b>103</b>-<b>105</b>, in turn, includes a number of its own children, again with each such child represented within the subject node (e.g., one of nodes <b>103</b>-<b>105</b>) by a hash of at least some of the child node's contents (e.g., hashes <b>114</b>-<b>120</b>), with such hash also functioning as a reference to the child node. In practice, the hierarchical data structure can be large and include many levels. Typically, only the data fields in the leaf nodes contain content other than metadata.</p>
<p id="p-0042" num="0045">In any event, in accordance with the general HDAG structure, higher-level nodes include one or more hashes, generated from content within their child nodes. Typically, each such hash is calculated across all of the content of the corresponding child node. However, in certain embodiments, the hash is only calculated across content within the corresponding child node that is deemed as relevant (e.g., content that one wishes to monitor). As a result of this structure, and assuming that each parent includes a hash for each child (or at least each relevant child) the system is able to determine whether an entire sub-structure of the hierarchy corresponding to the hash of its topmost node already has been stored (or, more generally, is otherwise present). On the other hand, if the entire sub-structure is not present, the system preferably drills down deeper into the hierarchy to check for matches at lower levels.</p>
<p id="p-0043" num="0046"><figref idref="DRAWINGS">FIG. 5</figref> illustrates an example of an entry node <b>130</b> within a HDAG data structure that includes other nodes, such as nodes <b>131</b> and <b>132</b> (which could be other entry nodes and/or other kinds of nodes). Included within entry node <b>130</b> are two keys, K<b>1</b> and K<b>2</b>. Key K<b>1</b> has a data value <b>135</b> associated with it, and key K<b>2</b> has a data value <b>136</b> associated with it. As shown, data value <b>135</b> has four component values and data value <b>136</b> has three, each such component value including a reference into an internal table <b>140</b> of values. Some of the values in table <b>140</b> (e.g., values <b>141</b> and <b>142</b>) are references (e.g., cryptographic hash references) to other nodes (e.g., nodes <b>144</b> and <b>145</b>, respectively) that include the actual component values. Other instances of the values in table <b>140</b> are the actual component values themselves, which might typically be the case, e.g., for shorter component values and/or for those component values that are not expected to be referenced by other nodes in the system. For example, H<b>4</b> in table <b>142</b> is the constant string &#x201c;Fred&#x201d;. In some embodiments, the indirection through table <b>140</b> is not done and the references themselves are inserted directly.</p>
<p id="p-0044" num="0047">In addition, each key-and-data-value association also includes: (1) any additional information that must be asserted in order to retrieve the data values (here represented as required identities <b>147</b> and <b>148</b>, although in alternate embodiments such additional information can be of any conceivable kind, defined in any conceivable way) and (2) any specified override information. More particularly, the first key-value association in entry node <b>130</b> requires, in addition to submission of K<b>1</b>, that the requester prove possession of either identity credential Id<b>1</b> or identity credential Id<b>2</b> in order to obtain data value <b>135</b>. Similarly, the second key-value association requires, in addition to submission of K<b>2</b>, that the requester prove possession of identity credential Id<b>3</b> in order to obtain data value <b>136</b>.</p>
<p id="p-0045" num="0048">With respect to override information, the first association includes an override lock OL<b>1</b>, which means that the association can be overridden by another association that produces the matching override key, and also includes an override key OK<b>1</b> which is used to override another stored association (e.g., an association having a lock value to which OK<b>1</b> hashes). The second association just has an override lock OL<b>2</b> which means it can be overridden by another association having the matching key but it does not attempt to override any other association. The preferred override technique is described in more detail below.</p>
<p id="p-0046" num="0049">As indicated in the foregoing example, an entry node according to the present invention preferably can include multiple associations, potentially involving different keys and corresponding different data values of any conceivable type (e.g., metadata indicating similarity to another data object, a relationship to another data object, file annotation data, or the like). However, in the preferred embodiments each entry node is generated by a single entity, i.e., with different entities directly or indirectly generating their own sets of entry nodes.</p>
<p id="p-0047" num="0050">In certain embodiments, the entry node preferably also contains an indication of which of the associations are considered to be &#x201c;strong references&#x201d; and which are considered to be &#x201c;weak references&#x201d;. These concepts are useful in performing cleanup operations in which nodes that are no longer needed are deleted. In the preferred embodiments, a &#x201c;strong reference&#x201d; implies that as long as the entry node itself is in the data store, the node referenced by the association will not be deleted or designated for deletion; other associations preferably are &#x201c;weak references&#x201d; which do not imply that guarantee. Because different associations in an entry node preferably can make use of the same data values, in the present example the table <b>140</b> within entry node <b>130</b> includes two lists of data value references, i.e., one list of strong references (including value <b>141</b>) and one list of weak references (including value <b>142</b>), with the associations referring into such lists. In other embodiments, other indications of which references are strong and which are weak are employed.</p>
<p id="p-0048" num="0051">As indicated above, any given association can include an override lock and/or an override key (or, for that matter, multiple override locks and/or keys). The override lock preferably gives the requirement for another association to override this association. The override key asserts that this association overrides another one (i.e., one with the matching lock). The override lock-and-key mechanism preferably is based on the Usenet Cancel-Lock mechanism, e.g., as described in the USEFOR Working Group INTERNET-DRAFT authored by Simon Lyall, dated November 1998, entitled &#x201c;Cancel-Locks in Usenet,&#x201d; and identified by the identified articles.draft-ietf-usefor-cancel-lock-01.txt. Essentially, the principle behind the use of such a mechanism is that in order to guard against malicious removal, when an association is requested, a secret override key is generated. This override key preferably is hashed using a well-known function (e.g., SHA-1 or any other adequately secure hash function) to generate an override lock, which then is included with the association. Because it is presumed to be prohibitively difficult to reverse a cryptographic hash function, anyone who can actually produce the override key that fits (i.e., hashes to) the override lock can be presumed to be authorized to override the value. However, it should be noted that any other lock-and-key mechanism instead can be used.</p>
<p id="p-0049" num="0052">In certain embodiments, the actual value of the override key is a hash of the association key, some private (or shared secret) information and, in certain cases, a serial number based on the sequence of overriding. However, using a serial number generally implies that the association needs to keep this information in the value and requires a lookup to find out what is being overridden. On the other hand, simply hashing the association key and a secret will always result in the same value, and the key will fit the association's own lock, which might not be desirable, e.g., in that it will be difficult to establish the appropriate sequence in which the overrides are to be applied. In certain embodiments one or more well-known override locks and keys exist for the purpose of allowing overriding of values by anyone. Such well-known values may be created in the same manner as normal override locks and keys or may simply be identifiable by their contents.</p>
<p id="p-0050" num="0053">As noted above, when an entry node (e.g., entry node <b>130</b>) is added to the data store <b>16</b> (i.e., it was not already there), the corresponding value list node(s) are found or created, and the information for the new association is added, flagged as not overridden. If the new association has an override key on it, that override key preferably is hashed to find the corresponding override lock, and any association with that override lock is flagged as being overridden (based on a model that if B overrides A and then C overrides B, A stays overridden, although an alternate embodiments the override is removed from A once B is overridden). If any such associations exist, the association being added is flagged as overriding. If the new association has an override lock, the data store <b>16</b> preferably checks whether that lock corresponds to the override keys for any of the other entries, and, if so, the new association is marked as (already) overridden.</p>
<p id="p-0051" num="0054">In the example given above, in addition to the key value, an appropriate identity credential must be asserted to retrieve the corresponding data value. It should be noted that this is just one example of an access criterion. In alternate embodiments, a different access criterion (which can be just a simple condition or a multi-part criterion) and/or different values are used. Generally speaking, the access values and/or criterion allow the entity asserting the association to specify who should be allowed to see the association and/or retrieve the data value referenced by the association. The access criterion could take any of several forms, e.g.:
<ul id="ul0003" list-style="none">
    <li id="ul0003-0001" num="0000">
    <ul id="ul0004" list-style="none">
        <li id="ul0004-0001" num="0055">A public key (or other credential) for an identity that the requestor would have to assert and prove to the server <b>16</b>, e.g., when a session is initiated. A benefit of this approach is that the identity proof could be delayed until the server <b>16</b> gave the client <b>12</b> a challenge in the form of a random number that had to be encrypted using a public key process by the client <b>12</b>, although this variation would require both a public key encryption (by the client) and a public key decryption (by the server). The client <b>12</b> might or might not be required to disclose the resulting encryption value or might only be required to disclose the hash of the resulting encryption value.</li>
        <li id="ul0004-0002" num="0056">A hash of a public key (or some other credential) possessed by the requester <b>12</b> that the requester <b>12</b> would have to assert and prove to the server <b>16</b> before making the request. This value is smaller, and the server <b>16</b> will not know the actual credential until somebody asserts it, but with this approach the proof generally cannot be delayed.</li>
        <li id="ul0004-0003" num="0057">A challenge/response pair, e.g., of the form &#x3c;r, H(Id;r)&#x3e;, where r is a random number. Here, the server <b>16</b> sends back r, and the client <b>12</b> responds with hashes using all of its identities. This approach leaks the least information to the server <b>16</b>, because the server <b>16</b> cannot correlate different associations exposed to the same identity and it is inexpensive for both sides to compute, but it generally requires a round trip each time, and it generally leaks information to the client <b>12</b> that there is a value there.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0052" num="0058">It is noted that the same association can be made visible to multiple identities. Alternatively, the access criterion can be eliminated entirely (i.e., the association is made public).</p>
<p id="p-0053" num="0059">In certain embodiments, the data store <b>16</b> also includes &#x201c;identity delegates&#x201d;, in which a client <b>12</b> who can prove an identity is allowed to specify other identities that are also allowed to see values that it is allowed to see. This approach can be used, e.g., as discussed in the &#x201c;Key Management&#x201d; application to allow an identity <b>12</b> to delegate its access rights to a trusted scanner or other automated entity. In such embodiments, proving the delegated identity preferably is treated as proving the original identity for access purposes, although not necessarily for the purpose of granting further delegation.</p>
<p id="p-0054" num="0060">In the current embodiment of the invention, at the same time that an entry node <b>42</b> is created (in step <b>72</b> of <figref idref="DRAWINGS">FIG. 3</figref>), a corresponding value list node <b>43</b> is either created or supplemented. More preferably, the key for the association is stored in a new value list node <b>43</b> (if not previously stored in connection with a different entry node using the same key), together with the following information for the new association: (1) the data value; (2) the optional override lock; (2) the override lock corresponding to the optional override key (e.g., obtained by hashing the override key); (3) flags stating whether the data value is overridden, whether it overrides, and whether it has been deleted; and (4) the hash of (or other reference to) the entry node that led to the association. In other embodiments the override key is stored rather than the override lock corresponding to the override key.</p>
<p id="p-0055" num="0061">In certain embodiments, the entry node <b>42</b> also contains strong references to the value list nodes <b>43</b> corresponding to the keys for each of the associations it contains. These references are computed by computing the hash of the keys using the special hashing algorithm described above. In other embodiments, as when the special hashing algorithm is not made public (and so these values cannot be computed outside of the data store <b>16</b>) and the associations are created by storing entry nodes <b>42</b>, the data store <b>16</b> augments the stored entry nodes <b>42</b> with these references. In such embodiments, the reference to an entry node <b>42</b> is computed on only the portion presented to the data store <b>16</b> (i.e., not including the augmentation) and when a request to retrieve the entry node <b>42</b> is received by the data store <b>16</b>, the augmentations are preferably not included in the returned value.</p>
<p id="p-0056" num="0062">A more detailed depiction of a value list node <b>180</b> according to this embodiment of the invention, as well as the relationship between value list node <b>180</b> and entry node <b>130</b> (as well as various other related entry nodes), is illustrated in <figref idref="DRAWINGS">FIG. 6</figref>. As indicated in <figref idref="DRAWINGS">FIG. 6</figref>, value list node <b>180</b> pertains to the key for the first association in entry node <b>130</b> (which is shown in <figref idref="DRAWINGS">FIG. 6</figref> as including a reference to value list node <b>180</b>). That association is reflected in value list node <b>180</b> as entry <b>182</b>. At the same time, additional associations <b>191</b>-<b>196</b> involving the same key (K<b>1</b>) also are stored in value list node <b>180</b>.</p>
<p id="p-0057" num="0063">As indicated, much of the information in the association <b>182</b> stored in value list node <b>180</b> mirrors the information in the corresponding entry node <b>130</b>. One difference is that the hash of the override key (OK<b>1</b>) has been stored in value list node <b>180</b>, rather than the override key value itself. As result, the appropriate overrides can be determined more quickly. In addition, association <b>182</b> includes a reference <b>185</b> back to the entry node <b>130</b> that caused association <b>182</b> to be stored in value list node <b>180</b>; similarly, associations <b>191</b>-<b>196</b> include references back to the entry nodes (e.g., entry nodes <b>201</b>-<b>203</b>) that caused them to be stored within value list node <b>180</b>, and a different value list node <b>210</b> that corresponds to the second association in entry node <b>130</b> also refers back to entry node <b>130</b>. These back references are weak references, which means that the entry nodes (<b>130</b> and <b>201</b>-<b>203</b>) and their children can be deleted even though the value list node <b>180</b> still exists.</p>
<p id="p-0058" num="0064">In the present embodiment, the value list nodes (such as node <b>180</b>) are purely internal storage nodes whose contents are not directly accessible from outside the data store <b>16</b>. They contain the data values currently associated with a particular key. That is, each value list node preferably represents (e.g., either stores or has access to) all current associations with a given key, even those that are overridden. Thus, as shown in <figref idref="DRAWINGS">FIG. 7</figref>, associations <b>221</b>-<b>223</b> reference the same value list node <b>251</b> because they have the same key value <b>231</b>, although they have different data values <b>241</b>-<b>243</b>, respectively; similarly, associations <b>224</b> and <b>225</b> reference the same value list node <b>252</b> because they have the same key value <b>232</b>, although they have different data values <b>244</b> and <b>245</b>, respectively.</p>
<p id="p-0059" num="0065">An overview of a system <b>300</b> according to a representative embodiment of the present invention is illustrated in <figref idref="DRAWINGS">FIG. 8</figref>. As shown, a variety of different entities <b>304</b>-<b>306</b> (which, e.g., can be people and/or automated agents) specify or assert associations between keys and values. For example, entity <b>304</b> asserts a set of associations and causes them to be stored within an entry node HDAG data structure <b>314</b>. Entity <b>305</b> creates a set <b>315</b> of associations without specifying any particular relationships between them. Entity <b>306</b> creates a single association <b>316</b>. In each case, corresponding entry nodes automatically are generated to store the associations, and value list nodes are generated and/or modified to store the data values corresponding to individual keys. For example, each of entry nodes <b>324</b>-<b>326</b> references the same value list node <b>340</b> because each includes an association having the same key, even though each may have entirely different properties otherwise, as specified by their respective asserting entities <b>304</b>-<b>306</b>.</p>
<p id="p-0060" num="0066">The foregoing discussion primarily concerns the assertion of associations, as well as the preferred processing and storage techniques for reflecting such associations within data store <b>16</b>. Another aspect of the present invention is the ability for users or other entities to request the data value associated with a specified key.</p>
<p id="p-0061" num="0067">Thus, returning to <figref idref="DRAWINGS">FIG. 3</figref>, in step <b>77</b> a determination is made as to whether any data value request <b>360</b> (as shown in <figref idref="DRAWINGS">FIG. 8</figref>) has been made. Such a request <b>360</b> can be initiated directly by a user <b>12</b>, but sometimes instead will be initiated indirectly by the user <b>12</b>. For example, with respect to the example in which the data values comprise decryption keys for data objects within an encrypted file system, a user <b>12</b> operating her computer <b>14</b> to browse through files on server <b>16</b> (i.e., in this example, encrypted files within backup data store <b>16</b>) will come across an encrypted file and attempt to open it or otherwise access it. In response, an application running on computer <b>14</b> automatically will create and transmit request <b>360</b>, packaging into request <b>360</b> the appropriate information pertaining to the identity of user <b>12</b> and the identity of the subject file. As with requests to store associations, requests to retrieve associated values can be made in different ways in different embodiments. In some embodiments, the protocol for interacting with the data store <b>16</b> may include a special request of the form &#x201c;Please retrieve values associated with key K&#x201d;. In other embodiments, a request to retrieve a value may take the form of a request to retrieve a chunk associated with a reference computed by applying the special value list node hashing algorithm to the key. In such embodiments, the data store <b>16</b> uses the format of the digest proffered in the request to determine that it is a request to retrieve an association value. Such a determination is based on the digest format described below. Generally speaking, the data value request preferably includes some function of the key corresponding to the data value, e.g., a hash of the key or simply the key itself (i.e., where the function is the identity function).</p>
<p id="p-0062" num="0068">If a request <b>360</b> has been received in step <b>77</b>, processing proceeds to step <b>78</b>. If no request <b>360</b> has been received, processing proceeds to step <b>79</b>.</p>
<p id="p-0063" num="0069">In step <b>78</b>, any data value (or portion thereof) that is relevant to the received request <b>360</b> is retrieved and/or generated on-the-fly and then provided to the requester <b>350</b>. As indicated above, the request <b>360</b> preferably includes a key <b>362</b> that is derived from the data object to which the desired data values apply or, more generally, from an identification for the desired data value.</p>
<p id="p-0064" num="0070">The value of the key <b>362</b> is then used to access the corresponding value list node <b>340</b>. In the present embodiment, the requester is only allowed to access node <b>340</b> through a software component <b>365</b> (e.g., a component of data store <b>16</b>) that manages incoming requests <b>360</b>. As indicated above, in one specific embodiment, component <b>365</b> performs a special hash on the key <b>362</b> in order to obtain a reference to the corresponding value list node <b>340</b>.</p>
<p id="p-0065" num="0071">As further indicated in the above discussion regarding access values and/or criteria, in certain embodiments of the invention, the requester <b>350</b> must have provided certain access information, e.g., proving his or her identity, in order to obtain one or more of the data values within value list node <b>340</b>. In one embodiment, the applicable criterion need only be satisfied for once for each session (which can include multiple requests <b>360</b>).</p>
<p id="p-0066" num="0072">The techniques by which data store <b>16</b> obtains the requested data value(s) differ according to the various embodiments of the present invention. In certain embodiments, the requested data value(s): (1) are generated on the fly based on the associations in the value list node <b>340</b>, (2) are simply provided (in the event that such data value(s) previously have been generated based on the relevant associations in the value list node <b>340</b> and then stored within value list node <b>340</b>), or (3) any combination of the two. In any case, the processing to determine the requested data value preferably takes account of all relevant currently active associations for the request key <b>362</b>, as well as all effective overrides and all applicable access criteria.</p>
<p id="p-0067" num="0073">In addition, the foregoing embodiments generally pertain to the simple case in which each data value is or comprises one or more component values which are constant values or constant references to (possibly changing) values. However, in alternate embodiments, at least some of the stored data values are defined by the requesters <b>304</b>-<b>306</b> to be functionally dependent on other values, which might be, e.g., constants, values associated with keys, or other values accessible to data store <b>16</b> and which might change over time. For example, a requester <b>304</b>-<b>306</b> might request an association to a value which is defined to be the maximum of all (or all visible) values associated with a specified other key or set of keys. As a second example, the association might be to the sum (or any other function) of values associated with a specified key or set of keys. As a third example, the association might be to the difference between the current time and the time a particular referenced chunk was stored in data store <b>16</b>. In such embodiments, the request to create the association will contain sufficient information to allow the server <b>16</b> to identify both the arguments to the combination and the method of combining them.</p>
<p id="p-0068" num="0074">The specification of such a combination could be as simple as a selection from a fixed list of available functions or as complicated as a program specified in a general-purpose programming language. In such alternate embodiments, the retrieval processing also determines the current component values of the parameters which will serve as arguments to the combining function and then computes the combination. In some of these embodiments, the values which are allowed to serve as arguments are restricted to values whose access criteria would allow the requesting user to retrieve them. In some embodiments, such restrictions are dependent upon the combining function that has been specified (e.g., certain functions asserted by certain individuals that return personally identifying data are prohibited while other functions asserted by the same individuals that only return aggregate data are permitted). In some embodiments, some combining functions can result in more than one component value being returned. For example, a combining function that specifies an association with the sum of the values with two keys, the first of which is (visibly) associated with two values and the second of which is (visibly) associated with three values, may result in up to six such sums, when the values are taken pairwise. In some such embodiments, a further indication can be specified in order to allow the combining function to &#x201c;match up&#x201d; desired pairs, as, for example, by including as part of the subsidiary values an indication of an entity that asserted the association.</p>
<p id="p-0069" num="0075">Accordingly, in at least some of such alternate embodiments the retrieval processing also accesses information in one or more other related value list nodes <b>367</b> (e.g., having their own separately defined entry nodes <b>371</b>-<b>374</b>). For example, in one embodiment, such processing looks up the data object corresponding to key <b>362</b>, determines that it belongs to a larger group and therefore inherits certain data values from the group, and then accesses value list node <b>367</b> to obtain and include such group data values within the returned data value(s) <b>370</b>. Similar group value list nodes can be used for groups to which the individual requester <b>350</b> belongs. In any event, the data value(s) <b>370</b> resulting from all such processing are then output to the requester.</p>
<p id="p-0070" num="0076">Preferably, the returned data value(s) <b>370</b> are formatted as a specially typed chunk, including the key <b>362</b>, followed in random (or otherwise different for different identical requests) order by a sequence of all non-overridden data value(s) (potentially with a descriptor field for each) for which the requester <b>350</b> has asserted an identity that allows it to see the value. For each one, preferably only the value is included, not the override key, override lock, or access digests. If two values are identical, preferably only one is returned.</p>
<p id="p-0071" num="0077"><figref idref="DRAWINGS">FIG. 9</figref> is a block diagram illustrating examples of data-value requests and the returned data values, in keeping with the same example described above. Each of the requests <b>391</b>-<b>395</b> involves key K<b>1</b>, corresponding to value list node <b>180</b> (shown in abbreviated form in <figref idref="DRAWINGS">FIG. 9</figref> and in greater detail in <figref idref="DRAWINGS">FIG. 6</figref>). Request <b>391</b> asserts the identity Id<b>1</b>, so the returned data values <b>401</b> include only those data values which Id<b>1</b> has permission to see. Similarly, request <b>392</b> asserts the identity Id<b>2</b>, so the returned data values <b>402</b> include only those data values which Id<b>2</b> has permission to see; and request <b>393</b> asserts the identity Id<b>3</b>, so the returned data value <b>403</b> includes only the single data value which is visible for anyone to see. Request <b>394</b> is made by an entity which has been delegated rights to see everything that Id<b>1</b> and Id<b>2</b> are permitted to see, so the returned data values <b>404</b> include all the data values within value list node <b>180</b>. Request <b>395</b> is a repeat of request <b>392</b>, so in this case the returned data values <b>405</b> are the same as returned data values <b>402</b>, but arranged in a different order. Note that some of the associations in value list node <b>180</b> (e.g., association <b>195</b>) are overridden (in the case of association <b>195</b> by association <b>194</b>) and therefore their values are not returned in response to any request.</p>
<p id="p-0072" num="0078">More specifically, referring to <figref idref="DRAWINGS">FIG. 6</figref>, associations <b>191</b>, <b>192</b>, and <b>195</b> are overridden and associations <b>192</b> and <b>194</b> override (association <b>192</b> both overrides the association <b>191</b> and is overridden by association <b>193</b>). In the present example, the associations in <figref idref="DRAWINGS">FIG. 6</figref> are listed in the order in which they were asserted, i.e., with the associations at the top of the table having been asserted first. It is noted that association <b>194</b> overrides association <b>195</b>, even though association <b>194</b> was asserted first, so association <b>195</b> was overridden at the moment it was asserted. However, if association <b>194</b> subsequently is deleted (or expires), association <b>195</b> will become active (i.e., will be restored). It is noted that for simplicity, the applicable override flags are not shown in the figures.</p>
<p id="p-0073" num="0079">One aspect of the preferred embodiments of the present invention is the use of value list nodes, separate from association entry nodes, for storing all relevant information pertaining to a given potential request key. However, the actual structures used for accomplishing this purpose can differ from embodiment to embodiment. For example, in the embodiment discussed above, associations present in the entry nodes are essentially duplicated in the corresponding value list nodes. In alternate embodiments, the value list nodes just contain references to the entry nodes that include associations pertaining to the subject key, so that the appropriate data value(s) to be returned in response to a request <b>360</b> are generated (e.g., on-the-fly) by referencing the relevant entry nodes.</p>
<p id="p-0074" num="0080">As will be readily apparent, the processing/storage configuration <b>300</b> can provide for a number of advantages pertaining to flexibility in defining, modifying and overriding associations between keys and data values, as well as advantages pertaining to maintaining the security of sensitive data values. Whether the value list nodes <b>340</b> maintain current data value(s) or generate them in real-time in response to a request <b>370</b> preferably depends on: the expected number of requests <b>360</b>, the availability of system resources to constantly maintain current data values and the importance of providing fast responses to requests <b>360</b>.</p>
<p id="p-0075" num="0081">One important advantage of the preferred embodiments is the ability to have associations expire or otherwise be deleted, with the data values <b>370</b> returned in response to a request <b>360</b> being updated (e.g., on-the-fly) to reflect these changes. For example, as noted above, the individual requesters <b>304</b>-<b>306</b> preferably have the ability to search associations stored within retention groups. In this regard, anode preferably becomes part of a retention group simply by the fact of there being a strong reference to it from something in the retention group or by being designated a root node in a retention group. In any event, during periodic maintenance operations the associations represented in the various value list nodes are updated to reflect any changes that have occurred. For example, the expiration of a particular association might: (1) have no effect (if the association is overridden anyway), (2) result in the corresponding data value not being returned in response to a request <b>360</b> (if the association previously was active) and/or (3) cause some other data value to be returned in response to a request <b>360</b> (one whose association previously was overridden by the now expired association). In any event, in the preferred embodiments: (1) value list nodes are not deleted (or designated for deletion) while there are active entry nodes that refer to them, and (2) strong references from entry nodes prevent parts of the association value from being designated for deletion.</p>
<p id="p-0076" num="0082">Preferably, data store <b>16</b> repeatedly over time (e.g., periodically) determines whether entry nodes have been deleted, and then deletes corresponding associations in the value list nodes corresponding to that deleted entry nodes and restores associations previously overridden by the associations in the deleted entry nodes. Such determinations can be made, e.g., for a particular entry noted in response to an explicit request to delete such entry node (e.g., an externally input request or an automated request based on a pre-specified expiration policy or a reclamation of the entry node (or the page containing the entry node) as &#x201c;garbage&#x201d;) and/or can be made as part of a scanning process that is independent of any particular entry node.</p>
<p id="p-0077" num="0083">In the preferred embodiments, the data store <b>16</b> also periodically (or in any other repeated manner over time) performs a scan of value list nodes, checking to see whether an entry node might have disappeared without the store <b>16</b> having a chance to process it (e.g., because it became corrupted or was deleted rather than being scavenged by the garbage collector). If the entry node no longer exists, the association preferably is removed. To facilitate such scanning, the value list nodes preferably are kept on special pages, i.e., designated portions of the store <b>16</b>, as described in the '092 application.</p>
<p id="p-0078" num="0084">When a page of entry nodes is scavenged, each one preferably is processed by finding the corresponding value list nodes and removing from them data value information corresponding to the entry node reference. Several specific cases are as follows.</p>
<p id="p-0079" num="0085">When the association is both overridden and overriding, everything but the override lock and override key's lock preferably is removed (although in alternate embodiments it is not worthwhile to do so, in light of the fact that the value references preferably are weak references, so it will not matter to garbage collection), and the resulting abbreviated entry preferably is flagged as being deleted. This approach ensures that chains of overriding associations remain intact even if intermediate associations vanish.</p>
<p id="p-0080" num="0086">Otherwise, the association preferably is removed, possibly with some cleanup. For example, if the association overrides and there are no other associations with the same override key, then there is a chain of zero or more deleted associations terminating in an overridden association. The deleted associations (if any) preferably are removed and the previously overridden association are flagged as no longer being overridden (i.e., are restored). If, on the other hand, the association being removed is overridden and there are no other associations with the same override lock, the associations with keys matching its lock preferably are flagged as no longer overriding. If these associations are flagged as deleted, they also preferably are removed, and so on, recursively.</p>
<p id="p-0081" num="0087">In most cases, it is expected that there will be a single association for a key, so this cleanup operation will be trivial. In any event, however, the cleanup operation preferably is entirely internal to the store <b>16</b>, so the mechanism can change without disrupting anything externally visible.</p>
<p id="p-0082" num="0088">It is noted that when a new entry node is created, value list nodes typically are retrieved, modified and stored again. This process could be quite expensive, so in certain embodiments those associations that have not yet made it out to pages are kept in memory (preferably journaled to disk so that they can be brought back should the process die), and these new associations are merged in real time should the value be requested. In such embodiments, the actual modifications preferably take place in the background when the store <b>16</b> is relatively quiescent. Additional details regarding some of the foregoing concepts are described in the '092 application.</p>
<p id="h-0006" num="0000">Self-Describing Digest Abstraction</p>
<p id="p-0083" num="0089">There are several cryptographic hash algorithms in use and more are being developed. In addition, as discussed above, it sometimes is desirable to use modifications of existing hash algorithms.</p>
<p id="p-0084" num="0090">With respect to the embodiments described above, for the most part, the data store <b>16</b> does not actually interpret the digests produced (except, e.g., where the values are constants or map keys, or when optional consistency checking is performed), but it does read them and store them as opaque strings of bytes. Unfortunately, different hash algorithms produce digests of different lengths, which can make it difficult to deal with digests produced by hash algorithms with which the recipient is unfamiliar.</p>
<p id="p-0085" num="0091">This section discusses various self-describing digest abstractions that can accommodate flexibly defined hashes (or digests). Generally speaking, such abstractions include separate fields for type and length of the hash and the use &#x201c;indirection&#x201d; codes to allow for expandability. More preferably, as shown in <figref idref="DRAWINGS">FIG. 10</figref>, the abstraction is provided as a single-byte descriptor <b>410</b> that is divided into two parts: an algorithm type field <b>420</b> (preferably 5 bits long) indicating the type of hash performed and a length field <b>425</b> (preferably 3 bits long) indicating the length of the resulting hash value.</p>
<p id="p-0086" num="0092">As a result of this structure, it is possible to encode eight different lengths (including null). In many situations, that number will be insufficient, so some codes for the length field <b>425</b> preferably indicate that the actual length will be specified by the one or two bytes that follow the scheme byte <b>410</b>. An example is shown in <figref idref="DRAWINGS">FIG. 11</figref> which shows the meanings for different codes in the length field <b>425</b> in a particular embodiment, including the corresponding length of the hash value <b>440</b>, as well as whether the length code <b>425</b> indicates the presence of an indirection field <b>442</b> or <b>443</b>. Codes within the length field <b>425</b> of 0-5 correspond to the indicated fixed lengths for the hash value. Specifically, a length code of 0 corresponds to a length of 0 (null), a length code of 1 corresponds to a length of 16 bytes (e.g., for MD5), and a length code of 2 corresponds to a length of 20 bytes (e.g., for SHA-1). A standard length of 4 bytes (when the length code is 3) is provided in order to allow constant numbers to be used in some places in which digests are required.</p>
<p id="p-0087" num="0093">The other two standard sizes (when the length code is 4 or 5) preferably are selected based on the considerations applicable to the particular embodiment, e.g., using hash sizes from other common algorithms. For example, any two of the values 32, 64 and 128 bytes might be selected.</p>
<p id="p-0088" num="0094">When the length field <b>425</b> has a code of 6, the actual length is taken as an unsigned value from the following byte <b>442</b>. When its code is 7, the length is taken as an unsigned value from the following two bytes <b>443</b>.</p>
<p id="p-0089" num="0095">It is noted that the foregoing allocations are merely exemplary. In addition, in alternate embodiments the scheme descriptor <b>410</b> can have a different size or, even if implemented as a single byte, the individual bits might be allocated differently, such as by having both the type field <b>420</b> and the length field <b>425</b> be 4 bits long, or by having the length field <b>425</b> be longer (e.g., 5 bits) than the type field <b>420</b> (e.g., 3 bits). In still further alternate embodiments, the division of the descriptor <b>410</b> into separate fields may be performed algorithmically. For instance, the length field <b>425</b> may be computed as the result of computing the modulus of the descriptor <b>410</b> with respect to a well-known predefined constant while the algorithm field <b>420</b> may be the integer portion of the result of dividing the descriptor <b>410</b> by that value. It should be noted that such an algorithm is purely exemplary. In any event, it is generally preferred that, given a digest containing a descriptor (and optional following indirection bytes), it is possible based on that information: (1) to determine the length of the following data bytes even when the descriptor indicates an algorithm unknown to the one doing the interpretation and (2) to distinguish two digests computed using different algorithms when the following data bytes are identical.</p>
<p id="p-0090" num="0096">An exemplary assignment of codes for the algorithm type field <b>420</b> is shown in <figref idref="DRAWINGS">FIG. 12</figref>, which includes in addition to the code in the type field <b>420</b>, ranges of codes in the indirection field <b>442</b> (if applicable), the total number of different algorithms available within the indicated range <b>445</b>, and the general categorization <b>447</b> of the corresponding hash types. As shown in <figref idref="DRAWINGS">FIG. 12</figref>, in the algorithm field <b>420</b>, regardless of length, a code of 29 (0x1D) preferably indicates a constant string (or number) rather than the result of some hash function. This allocation allows digests to be used uniformly in places in which some values are references to nodes and others are simply constants or strings. The rest of the codes preferably are divided between those actually registered, those that the data store <b>16</b> can use internally, and those that are left unspecified but can be used as private schemes (recognizing that private schemes might collide and so should not be used in some situations).</p>
<p id="p-0091" num="0097">Similar to the length field <b>425</b>, the algorithm type field <b>420</b> preferably includes one or more indirection codes. In the present embodiment, as shown in <figref idref="DRAWINGS">FIG. 12</figref>, a code of 30 (0x1E) indicates that the actual scheme comes from the following byte, and a code of 31 (0x1F) indicates that the actual scheme comes from the following two bytes. If both the length field <b>425</b> and the algorithm field <b>420</b> include indirection codes, the length field <b>425</b> preferably comes first.</p>
<p id="p-0092" num="0098">In certain embodiments, some of the top of the internal space is explicitly reserved for both one- and two-byte indirections in case it becomes desirable to extend farther. Also, in certain embodiments, for the two-byte algorithms, at least, the actual codes to be used are based on some hash function or random draw rather than being sequential based on some assigning body. Such an approach should help to minimize collisions in different domains.</p>
<p id="p-0093" num="0099">It is noted that the algorithm field <b>420</b> can have different interpretations based on different length values. At least some codes, however, especially among the one- and two-byte ones, preferably are length-independent, so it should be possible to register them over all lengths as well.</p>
<p id="p-0094" num="0100">A sample set of initial assignments is shown in <figref idref="DRAWINGS">FIG. 13</figref>, with scheme code <b>420</b> (indicating the value of all 8 bits), algorithm code <b>422</b> (indicating the value of the first 5 bits) length code <b>425</b> (indicating the value of the last 3 bits), length value (in bytes) <b>440</b> and algorithm descriptor <b>460</b> indicated. For the map key hash <b>462</b> mentioned above, even though the different scheme byte will mean that such a digest will not be considered equal to an MD5 hash over the same data, it is preferred to have it be less likely to collide in the index, so it currently is preferred to have the map key hash <b>462</b> be defined as the bitwise inverse of a MD5 hash. That is, as noted above, it can be computed by first computing the MD5 hash and then XORing each of the bytes with 0xFF.</p>
<p id="h-0007" num="0000">System Environment.</p>
<p id="p-0095" num="0101">Generally speaking, except where clearly indicated otherwise, all of the systems, methods and techniques described herein can be practiced with the use of one or more programmable general-purpose computing devices. Such devices typically will include, for example, at least some of the following components interconnected with each other, e.g., via a common bus: one or more central processing units (CPUs); read-only memory (ROM); random access memory (RAM); input/output software and circuitry for interfacing with other devices (e.g., using a hardwired connection, such as a serial port, a parallel port, a USB connection or a firewire connection, or using a wireless protocol, such as Bluetooth or a 802.11 protocol); software and circuitry for connecting to one or more networks, e.g., using a hardwired connection such as an Ethernet card or a wireless protocol, such as code division multiple access (CDMA), global system for mobile communications (GSM), Bluetooth, a 802.11 protocol, or any other cellular-based or non-cellular-based system), which networks, in turn, in many embodiments of the invention, connect to the Internet or to any other networks; a display (such as a cathode ray tube display, a liquid crystal display, an organic light-emitting display, a polymeric light-emitting display or any other thin-film display); other output devices (such as one or more speakers, a headphone set and a printer); one or more input devices (such as a mouse, touchpad, tablet, touch-sensitive display or other pointing device, a keyboard, a keypad, a microphone and a scanner); a mass storage unit (such as a hard disk drive); a real-time clock; a removable storage read/write device (such as for reading from and writing to RAM, a magnetic disk, a magnetic tape, an opto-magnetic disk, an optical disk, or the like); and a modem (e.g., for sending faxes or for connecting to the Internet or to any other computer network via a dial-up connection). In operation, the process steps to implement the above methods and functionality, to the extent performed by such a general-purpose computer, typically initially are stored in mass storage (e.g., the hard disk), are downloaded into RAM and then are executed by the CPU out of RAM. However, in some cases the process steps initially are stored in RAM or ROM.</p>
<p id="p-0096" num="0102">Suitable devices for use in implementing the present invention may be obtained from various vendors. In the various embodiments, different types of devices are used depending upon the size and complexity of the tasks. Suitable devices include mainframe computers, multiprocessor computers, workstations, personal computers, and even smaller computers such as PDAs, wireless telephones or any other appliance or device, whether stand-alone, hard-wired into a network or wirelessly connected to a network.</p>
<p id="p-0097" num="0103">In addition, although general-purpose programmable devices have been described above, in alternate embodiments one or more special-purpose processors or computers instead (or in addition) are used. In general, it should be noted that, except as expressly noted otherwise, any of the functionality described above can be implemented in software, hardware, firmware or any combination of these, with the particular implementation being selected based on known engineering tradeoffs. More specifically, where the functionality described above is implemented in a fixed, predetermined or logical manner, it can be accomplished through programming (e.g., software or firmware), an appropriate arrangement of logic components (hardware) or any combination of the two, as will be readily appreciated by those skilled in the art.</p>
<p id="p-0098" num="0104">It should be understood that the present invention also relates to machine-readable media on which are stored program instructions for performing the methods and functionality of this invention. Such media include, by way of example, magnetic disks, magnetic tape, optically readable media such as CD ROMs and DVD ROMs, or semiconductor memory such as PCMCIA cards, various types of memory cards, USB memory devices, etc. In each case, the medium may take the form of a portable item such as a miniature disk drive or a small disk, diskette, cassette, cartridge, card, stick etc., or it may take the form of a relatively larger or immobile item such as a hard disk drive, ROM or RAM provided in a computer or other device.</p>
<p id="p-0099" num="0105">The foregoing description primarily emphasizes electronic computers and devices. However, it should be understood that any other computing or other type of device instead may be used, such as a device utilizing any combination of electronic, optical, biological and chemical processing.</p>
<p id="h-0008" num="0000">Additional Considerations.</p>
<p id="p-0100" num="0106">Several different embodiments of the present invention are described above, with each such embodiment described as including certain features. However, it is intended that the features described in connection with the discussion of any single embodiment are not limited to that embodiment but may be included and/or arranged in various combinations in any of the other embodiments as well, as will be understood by those skilled in the art.</p>
<p id="p-0101" num="0107">Similarly, in the discussion above, functionality sometimes is ascribed to a particular module or component. However, functionality generally may be redistributed as desired among any different modules or components, in some cases completely obviating the need for a particular component or module and/or requiring the addition of new components or modules. The precise distribution of functionality preferably is made according to known engineering tradeoffs, with reference to the specific embodiment of the invention, as will be understood by those skilled in the art.</p>
<p id="p-0102" num="0108">Thus, although the present invention has been described in detail with regard to the exemplary embodiments thereof and accompanying drawings, it should be apparent to those skilled in the art that various adaptations and modifications of the present invention may be accomplished without departing from the spirit and the scope of the invention. Accordingly, the invention is not limited to the precise embodiments shown in the drawings and described above. Rather, it is intended that all such variations not departing from the spirit of the invention be considered as within the scope thereof as limited solely by the claims appended hereto.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method of managing associations between keys and values within a computer processing system, comprising:
<claim-text>inputting requests to store associations between keys and data values corresponding to the keys;</claim-text>
<claim-text>storing the associations in entry nodes within a data structure represented as a hash-based directed acyclic graph (HDAG); and</claim-text>
<claim-text>upon receipt of a data value request that includes a specified function of a request key, together with satisfaction of any additional access criterion, automatically providing a return data value corresponding to the request key,</claim-text>
<claim-text>wherein the return data value has been generated based on at least one of the associations that involve the request key,</claim-text>
<claim-text>wherein the data values are managed in value list nodes and references to the value list nodes are generated using a hashing algorithm that is different than one or more hashing algorithms used to generate the HDAG.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. A method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the value list nodes correspond to individual ones of the keys, and the data values corresponding to a given key are managed in a single value list node.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. A method according to <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising a step of:
<claim-text>storing references between (1) the entry nodes storing associations involving a particular key and (2) the value list node corresponding to said particular key.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. A method according to <claim-ref idref="CLM-00003">claim 3</claim-ref>, further comprising a step of:
<claim-text>determining whether an entry node storing an association involving the particular key has been deleted and, if so, at least one of (1) deleting a corresponding association in the value list node corresponding to said particular key and (2) restoring an association previously overridden by the association involving the particular key in the deleted entry node.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. A method according to <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the references between the entry nodes and the value list nodes are stored within the entry nodes, and wherein said method further comprises a step, executed upon receipt of a request to retrieve a chunk corresponding to a reference to a specified entry node, of excluding the references between the specified entry node and the value list nodes in a returned result.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. A method according to <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the data value request comprises a request to retrieve a reference to the value list node corresponding to the request key.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. A method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein at least one hashing algorithm used is identified by a digest abstraction having a first field indicating a type of hash and a separate second field indicating a length of bytes comprising resulting hash code.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. A method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein a plurality of the associations include override information, and the return data value provided in response to the data value request excludes overridden data values.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. A method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein a specified request to store a set of at least one association comprises a request to store a chunk containing contents of a corresponding entry node.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. A method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein at least one of the associations comprises a reference to a HDAG node, and wherein the HDAG node is protected from deletion at least until the entry node storing said at least one of the associations is deleted.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. A method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein at least one of the entry nodes is associated with a retention group which is associated with an expiration criterion, and wherein said at least one of the entry nodes is protected from deletion at least until the expiration criterion is satisfied.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. A method of managing associations between keys and values within a computer processing system, comprising:
<claim-text>inputting requests to store associations between keys and data values corresponding to the keys;</claim-text>
<claim-text>storing the associations in entry nodes of a hash-based directed acyclic graphic (HDAG); and</claim-text>
<claim-text>upon receipt of a data value request that includes a specified function of a request key, together with satisfaction of any additional access criterion, automatically providing a return data value corresponding to the request key,</claim-text>
<claim-text>wherein the return data value is generated based on a plurality of the associations involving the request key that were previously stored,</claim-text>
<claim-text>wherein the data values are managed in value list nodes and references to the value list nodes are generated using a hashing algorithm that is different than one or more hashing algorithms used to generate the HDAG.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. A method according to <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the requests to store associations are made by different entities and the associations used to generate the return data value resulted from requests made by a plurality of said different entities.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. A method according to <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein a plurality of the associations include override information, and the return data value provided in response to the data value request excludes overridden data values.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. A method according to <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the override information for a first association includes an override lock for which a matching key must be provided in order to override said first association, and the override information for a second association includes an override key that provides the matching key, whereby the second association overrides the first association, resulting in an overridden data value.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. A method according to <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the request key is associated, through a plurality of previously stored associations, with a plurality of data values having different access criteria, and wherein any data values for which the corresponding access criteria have not been satisfied are excluded from the return data value.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. A method according to <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein at least one of the access criteria comprises a required demonstration of at least one of an identity, a role and a capability of an entity submitting the data value request.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. A method according to <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the return data value includes a plurality of component values, and wherein an order in which the component values are returned is different in response to different submissions of the data value request.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. A non-transitory computer readable medium storing computer-executable process steps for managing associations between keys and values within a computer processing system, said process steps comprising:
<claim-text>inputting requests to store associations between keys and data values corresponding to the keys;</claim-text>
<claim-text>storing the associations in entry nodes within a data structure represented as a hash-based directed acyclic graph (HDAG); and</claim-text>
<claim-text>upon receipt of a data value request that includes a specified function of a request key, together with satisfaction of any additional access criterion, automatically providing a return data value corresponding to the request key,</claim-text>
<claim-text>wherein the return data value has been generated based on at least one of the associations that involve the request key,</claim-text>
<claim-text>wherein the data values are managed in value list nodes and references to the value list nodes are generated using a hashing algorithm that is different than one or more hashing algorithms used to generate the HDAG. </claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
