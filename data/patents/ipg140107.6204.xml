<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627328-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627328</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12618474</doc-number>
<date>20091113</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>899</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>46</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>718104</main-classification>
<further-classification>718  1</further-classification>
<further-classification>718100</further-classification>
<further-classification>706 47</further-classification>
<further-classification>706 50</further-classification>
<further-classification>709202</further-classification>
<further-classification>709220</further-classification>
<further-classification>709223</further-classification>
<further-classification>709224</further-classification>
<further-classification>709226</further-classification>
<further-classification>717177</further-classification>
</classification-national>
<invention-title id="d2e53">Operation control for deploying and managing software service in a virtual environment</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>8046765</doc-number>
<kind>B2</kind>
<name>Cherkasova et al.</name>
<date>20111000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718104</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>8046767</doc-number>
<kind>B2</kind>
<name>Rolia et al.</name>
<date>20111000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718104</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>8078728</doc-number>
<kind>B1</kind>
<name>Pollan et al.</name>
<date>20111200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709226</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>8176486</doc-number>
<kind>B2</kind>
<name>Amir Husain</name>
<date>20120500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>8301746</doc-number>
<kind>B2</kind>
<name>Head et al.</name>
<date>20121000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709223</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>8307362</doc-number>
<kind>B1</kind>
<name>Gong et al.</name>
<date>20121100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>8370833</doc-number>
<kind>B2</kind>
<name>Bolles et al.</name>
<date>20130200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>8429650</doc-number>
<kind>B2</kind>
<name>Ferwerda et al.</name>
<date>20130400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2005/0278441</doc-number>
<kind>A1</kind>
<name>Bond et al.</name>
<date>20051200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709223</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2006/0075079</doc-number>
<kind>A1</kind>
<name>Powers et al.</name>
<date>20060400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709220</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2006/0075407</doc-number>
<kind>A1</kind>
<name>Powers et al.</name>
<date>20060400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718100</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2006/0075408</doc-number>
<kind>A1</kind>
<name>Powers et al.</name>
<date>20060400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718100</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2006/0129687</doc-number>
<kind>A1</kind>
<name>Goldszmidt et al.</name>
<date>20060600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709229</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2007/0078988</doc-number>
<kind>A1</kind>
<name>Miloushev et al.</name>
<date>20070400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709227</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>2007/0083648</doc-number>
<kind>A1</kind>
<name>Addleman et al.</name>
<date>20070400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709224</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>2007/0233698</doc-number>
<kind>A1</kind>
<name>Sundar et al.</name>
<date>20071000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707 10</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>2008/0028409</doc-number>
<kind>A1</kind>
<name>Cherkasova et al.</name>
<date>20080100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718104</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00018">
<document-id>
<country>US</country>
<doc-number>2008/0104247</doc-number>
<kind>A1</kind>
<name>Venkatakrishnan et al.</name>
<date>20080500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709226</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00019">
<document-id>
<country>US</country>
<doc-number>2008/0201711</doc-number>
<kind>A1</kind>
<name>Amir Husain</name>
<date>20080800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00020">
<document-id>
<country>US</country>
<doc-number>2008/0215742</doc-number>
<kind>A1</kind>
<name>Goldszmidt et al.</name>
<date>20080900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709229</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00021">
<document-id>
<country>US</country>
<doc-number>2008/0271039</doc-number>
<kind>A1</kind>
<name>Rolia et al.</name>
<date>20081000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718105</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00022">
<document-id>
<country>US</country>
<doc-number>2008/0301175</doc-number>
<kind>A1</kind>
<name>Applebaum et al.</name>
<date>20081200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707102</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00023">
<document-id>
<country>US</country>
<doc-number>2009/0049443</doc-number>
<kind>A1</kind>
<name>Powers et al.</name>
<date>20090200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718100</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00024">
<document-id>
<country>US</country>
<doc-number>2009/0055522</doc-number>
<kind>A1</kind>
<name>Shen et al.</name>
<date>20090200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709224</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00025">
<document-id>
<country>US</country>
<doc-number>2010/0011104</doc-number>
<kind>A1</kind>
<name>Crosbie</name>
<date>20100100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709226</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00026">
<document-id>
<country>US</country>
<doc-number>2010/0125665</doc-number>
<kind>A1</kind>
<name>Simpson et al.</name>
<date>20100500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709224</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00027">
<document-id>
<country>US</country>
<doc-number>2010/0125844</doc-number>
<kind>A1</kind>
<name>Mousseau et al.</name>
<date>20100500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00028">
<document-id>
<country>US</country>
<doc-number>2011/0185063</doc-number>
<kind>A1</kind>
<name>Head et al.</name>
<date>20110700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709226</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00029">
<document-id>
<country>US</country>
<doc-number>2011/0258317</doc-number>
<kind>A1</kind>
<name>Sinha et al.</name>
<date>20111000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709226</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00030">
<document-id>
<country>US</country>
<doc-number>2012/0303805</doc-number>
<kind>A1</kind>
<name>Simpson et al.</name>
<date>20121100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709224</main-classification></classification-national>
</us-citation>
<us-citation>
<nplcit num="00031">
<othercit>Definition of &#x201c;scope&#x201d; from Dictionary.com, Nov. 3, 2008.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00032">
<othercit>&#x2018;Implement Business Logic With the Drools Rules Engine&#x2019; by Ricardo Olivieri, IBM, Mar. 18, 2008.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00033">
<othercit>&#x2018;Performance Isolation in Virtualized Machines&#x2019; Dissertation by Rahul Gundecha, Department of Computer Science and Engineering, Indian Institute of Technology, Bombay, Jul. 4, 2008.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00034">
<othercit>&#x2018;Dynamic Placement of Virtual Machines for Managing SLA Violations&#x2019; by Norman Bobroff et al., copyright 2007, IEEE.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
</us-references-cited>
<number-of-claims>20</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>16</number-of-drawing-sheets>
<number-of-figures>16</number-of-figures>
</figures>
<us-related-documents>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61114742</doc-number>
<date>20081114</date>
</document-id>
</us-provisional-application>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20100125477</doc-number>
<kind>A1</kind>
<date>20100520</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Mousseau</last-name>
<first-name>Richard</first-name>
<address>
<city>Stratham</city>
<state>NH</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Herendeen</last-name>
<first-name>John</first-name>
<address>
<city>Upton</city>
<state>MA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Spotswood</last-name>
<first-name>Mark</first-name>
<address>
<city>Newton</city>
<state>MA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="004" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Akella</last-name>
<first-name>Ravi Sankar</first-name>
<address>
<city>Fremont</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="005" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Codanda</last-name>
<first-name>Chinnappa</first-name>
<address>
<city>Marblehead</city>
<state>MA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="006" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Jasnowski</last-name>
<first-name>Michael</first-name>
<address>
<city>Amherst</city>
<state>NH</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Mousseau</last-name>
<first-name>Richard</first-name>
<address>
<city>Stratham</city>
<state>NH</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Herendeen</last-name>
<first-name>John</first-name>
<address>
<city>Upton</city>
<state>MA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Spotswood</last-name>
<first-name>Mark</first-name>
<address>
<city>Newton</city>
<state>MA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="004" designation="us-only">
<addressbook>
<last-name>Akella</last-name>
<first-name>Ravi Sankar</first-name>
<address>
<city>Fremont</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="005" designation="us-only">
<addressbook>
<last-name>Codanda</last-name>
<first-name>Chinnappa</first-name>
<address>
<city>Marblehead</city>
<state>MA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="006" designation="us-only">
<addressbook>
<last-name>Jasnowski</last-name>
<first-name>Michael</first-name>
<address>
<city>Amherst</city>
<state>NH</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Fliesler Meyer LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Oracle International Corporation</orgname>
<role>02</role>
<address>
<city>Redwood Shores</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Snyder</last-name>
<first-name>Steven</first-name>
<department>2184</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A system and method can deploy and manage software services in virtualized and non-virtualized environments. The system provides an enterprise application virtualization solution that allows for centralized governance and control over software and Java applications. Operations teams can define policies, based on application-level service level agreements (SLA) that govern the allocation of hardware and software resources to ensure that quality of service (QoS) goals are met across virtual and non-virtualized platforms. The system use a rules engine that can compare administrator defined constraints with runtime metrics; generate events when a constraint is violated by a metric of the runtime metrics and generate events when a constraint is violated by a metric of the runtime metrics.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="171.37mm" wi="215.90mm" file="US08627328-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="153.92mm" wi="127.17mm" orientation="landscape" file="US08627328-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="226.65mm" wi="144.02mm" orientation="landscape" file="US08627328-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="225.38mm" wi="140.04mm" orientation="landscape" file="US08627328-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="264.84mm" wi="201.51mm" orientation="landscape" file="US08627328-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="237.24mm" wi="115.57mm" orientation="landscape" file="US08627328-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="263.99mm" wi="199.90mm" orientation="landscape" file="US08627328-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="257.47mm" wi="198.71mm" orientation="landscape" file="US08627328-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="245.70mm" wi="194.31mm" file="US08627328-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="229.02mm" wi="108.71mm" orientation="landscape" file="US08627328-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="236.90mm" wi="195.07mm" orientation="landscape" file="US08627328-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="236.22mm" wi="212.85mm" file="US08627328-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="247.14mm" wi="215.82mm" file="US08627328-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="211.84mm" wi="174.92mm" file="US08627328-20140107-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="235.88mm" wi="202.27mm" orientation="landscape" file="US08627328-20140107-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="233.60mm" wi="163.41mm" orientation="landscape" file="US08627328-20140107-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00016" num="00016">
<img id="EMI-D00016" he="249.43mm" wi="190.08mm" orientation="landscape" file="US08627328-20140107-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CLAIM OF PRIORITY</heading>
<p id="p-0002" num="0001">This application claims the benefit or priority to U.S. Provisional Patent Application No. 61/114,742, filed Nov. 14, 2008, titled &#x201c;OPERATION CONTROL FOR DEPLOYING AND MANAGING SOFTWARE SERVICE IN A VIRTUAL ENVIRONMENT&#x201d;, and is incorporated herein by reference.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">COPYRIGHT NOTICE</heading>
<p id="p-0003" num="0002">A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.</p>
<heading id="h-0003" level="1">FIELD OF INVENTION</heading>
<p id="p-0004" num="0003">This invention relates generally to the management of application services in an enterprise environment, and, particularly, to a system and method for deploying and managing software services in virtualized and non-virtualized environments.</p>
<heading id="h-0004" level="1">BACKGROUND</heading>
<p id="p-0005" num="0004">Organizations that utilize enterprise and application server software as part of their enterprise infrastructure are increasingly adopting virtualization technologies as part of their drive to increase utilization and reduce infrastructure costs, while at the same time improving their ability to respond rapidly to a new line of business initiatives.</p>
<p id="p-0006" num="0005">Hypervisor-based virtualization platforms allow the organization to consolidate their information technology deployments onto a much reduced number of servers running powerful multi-core processors, which, in turn, host multiple virtual machines running applications in their own protected, virtualized environments. As a result, organizations have been able to optimize their physical infrastructure by pooling hardware and storage resources, reduce physical space, ease power and cooling costs, and improve application availability.</p>
<p id="p-0007" num="0006">Recently, the focus has shifted to application virtualization&#x2014;technologies that help information technology operations to package, deploy, monitor and control enterprise applications in these new virtual data centers to achieve flexible, dynamic operations that are more responsive, highly available and efficient. This is the area that embodiments of the present invention are designed to address.</p>
<heading id="h-0005" level="1">SUMMARY</heading>
<p id="p-0008" num="0007">A system and method can deploy and manage software services in virtualized and non-virtualized environments. The enterprise application virtualization solution allows for centralized governance and control over software and Java applications. Operation teams can define policies, based on application-level service level agreements (SLA) that govern the allocation of hardware and software resources to ensure that quality of service (QoS) goals are met across virtual and non-virtualized platforms. In accordance with a embodiment, the system includes monitor service component to convert constraints specified by the users into a watch list, a rules engine to compare administrator defined constraints with runtime metrics, and an execution engine to obtain and execute a pipeline of actions of deploying and managing software services that are associated with a defined scope and encapsulates a behavior of a plurality of compute resources.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0006" level="1">BRIEF DESCRIPTION OF THE FIGURES</heading>
<p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. 1</figref> is an illustration that shows the architecture of a system for deploying and managing software services, in accordance with an embodiment.</p>
<p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. 2</figref> is an illustration that shows the architecture of a Controller for use with the system, in accordance with an embodiment.</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 3</figref> is an illustration that shows the architecture of an Agent for use with the system, in accordance with an embodiment.</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 4</figref> is an illustration that shows a screenshot of an Administrative Console or interface, in accordance with an embodiment.</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 5</figref> is an illustration that shows the architecture of a system for deploying and managing software services as process groups and clusters, in accordance with an embodiment.</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 6</figref> is an illustration that shows another screenshot of an Administrative Console interface that displays metrics, in accordance with an embodiment.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 7</figref> is an illustration that shows another screenshot of an Administrative Console interface that allows for setting of filters, in accordance with an embodiment.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 8</figref> is an illustration that shows the monitor service component of the Controller, in accordance with an embodiment.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 9</figref> is an illustration that shows the component pieces of the Controller, in accordance with an embodiment.</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 10</figref> is an illustration that shows how the Execution Engine Service is dependent with the other services provided by the other components in the Controller and how the other services provided by the other components are dependent on the Execution Engine Service.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 11</figref> is an exemplary illustration of Metric class diagram in accordance with an embodiment of the invention.</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 12</figref> is an exemplary illustration of Constraint class diagram in accordance with an embodiment.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 13</figref> is an exemplary illustration of Event State diagram in accordance with an embodiment.</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 14</figref> is an illustration that shows basic flow diagram for the Pipeline or the Action execution, in accordance with an embodiment.</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 15</figref> is an illustration that shows the basic feedback loop that occurs between the Rules Engine, the Monitor and the Execute Engine, in accordance with an embodiment.</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 16</figref> is an illustration that shows how the trigger service interacts with the rules engine, in accordance with an embodiment.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0007" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0025" num="0024">The invention is illustrated, by way of example and not by way of limitation, in the figures of the accompanying drawings in which like references indicate similar elements. It should be noted that references to &#x201c;an&#x201d; or &#x201c;one&#x201d; or &#x201c;some&#x201d; embodiment(s) in this disclosure are not necessarily to the same embodiment, and such references mean at least one.</p>
<p id="p-0026" num="0025">The description of the invention as following uses WebLogic&#xae; application server functions or libraries as an example for application server functions or libraries. It will be apparent to those skilled in the art that other types of application server functions or libraries can be used without limitation.</p>
<p id="p-0027" num="0026">The description of the invention as following also uses Java&#xae; Virtual Machine functions or libraries as an example for virtual machine functions or libraries. It will be apparent to those skilled in the art that other types of virtual machine functions or libraries can be used without limitation.</p>
<p id="p-0028" num="0027">In accordance with an embodiment, the system provides an enterprise application virtualization solution that allows for centralized governance and control over software and Java applications. Operation teams can define policies, based on application-level service level agreements (SLA) that govern the allocation of hardware and software resources to ensure that quality of service (QoS) goals are met across virtual and non-virtualized platforms. When pre-defined conditions occur, a controller dynamically apportions resources to applications or services by invoking the deployment capabilities of the underlying infrastructure. This allows organizations to take advantage of the computing power available from modern processing systems and hypervisor-based virtualization technology. Applications can be deployed on a pool of virtual resources and dynamically extended or re-configured to meet runtime requirements, without constant monitoring by system operators.</p>
<p id="p-0029" num="0028">In accordance with an embodiment, application administrators can set policies that govern such features as how many servers must be available in a given domain, the maximum load that those servers should support, the response time required for individual services, and other important Service Level Agreement (SLA) metrics. If any of these parameters are breached, the system can respond immediately by provisioning further server instances, migrating existing instances to more suitable resources, or taking other actions to reconfigure the application's runtime environment.</p>
<p id="p-0030" num="0029">In accordance with an embodiment, the system automatically maps application activity to the most appropriate resources of the underlying platform, so that in a virtualized environment the system can invoke hypervisor-based services to clone, deploy or to migrate servers; while in a non-virtualized operating system (OS)-based environment, the system can start additional resources wherever they have been defined. The system can also provide application-level monitoring and automation for all Java applications, whether those applications are running virtualized or on a dedicated server. In a typical organization, the information operations can contain a mixture of virtual and dedicated servers (since not all applications can be effectively virtualized and in some cases a mixed architecture may be appropriate). Using the system herein, an organization is able to control and optimize Java applications both at the Java Virtual Machine (JVM) and application server layers, regardless of how and where those applications are running.</p>
<p id="p-0031" num="0030">In accordance with an embodiment, the system comprises two principal components: a Controller, and one or more Agents. The Controller maintains a secure repository of service deployments and SLA policies that are monitored by the system, with a high-performance customizable rules engine that allows the system administrator to specify what actions should be taken when those service levels are at risk. The Controller monitors JVM, application and other metrics, and is able to perform configuration changes and provide process control, so that operations teams can automate key tasks aimed at maintaining application quality of service (QoS), such as provisioning new server instances or migrating existing deployments to alternative hardware resources, based on the runtime behavior of applications and the SOA services that underpin them. The Controller can determine optimal resource placement for service deployments and JVM creations by matching service deployment requirements with specific resource pool capabilities. Action pipelines can be defined to allow complex, sequenced activities to be initiated in response to an event or condition and calendar-based rules allow scheduling of actions to be performed on a one-off or periodic basis.</p>
<p id="p-0032" num="0031">Agents manage the virtualized or non-virtualized resources that make up the application domain to be managed. These can be virtual appliances (for example, WLS-VE) running on hypervisor-based virtualization platforms, dedicated app server, or JVM-based deployments. Agents determine the resource capabilities of the managed resource environment, and provide appropriate process control operations and platform-specific runtime information. Agents collect and aggregate a rich variety of information about the resources and services they monitor, which they return to the Controller.</p>
<p id="p-0033" num="0032">The Controller and Agents can run within virtual machines, or on dedicated servers. For example, in some embodiments the Controller can run on its own, dedicated server, as can the Virtualized Agent which manages the server instances running in virtual machines on the hypervisor. Virtualized server resources, process control and virtual machine monitoring can be performed via API calls. Both virtualized and non-virtualized resources can be controlled in a single domain. In accordance with a particular embodiment, the system and features thereof are referred to as a Liquid Operations Control (LOC) system. These and other features and benefits are described in further detail below.</p>
<heading id="h-0008" level="1">GLOSSARY</heading>
<p id="p-0034" num="0033">The following terms are used throughout this document:</p>
<p id="p-0035" num="0034">Controller&#x2014;A centralized component or process that gathers data about the operating environment from Agents. The Controller uses the data gathered to enforce policies and to deploy new services in a way that best honors the SLA of all deployed services. The Controller hosts the Administration Console.</p>
<p id="p-0036" num="0035">Agent&#x2014;A component or process that provides information about the environment to the Controller, starts and stops processes, and invokes other actions at the request of the Controller. In accordance with an embodiment, the system can use two types of Agents: a Plain Agent, for managing any type of Java process, that renders the resources from the machine on which it resides as a resource pool; and a Virtualized Agent for managing instances of Application Server running in a virtualized environment, that renders the virtualized resource pools as system-accessible resource pools, and can reside on any machine in the operations center that has access to the virtualized environment.</p>
<p id="p-0037" num="0036">Administration Console&#x2014;A graphical user interface that an administrator can use to configure, manage, and monitor services in the operations center.</p>
<p id="p-0038" num="0037">Managed Java Process&#x2014;A process instance initiated by the system and then monitored.</p>
<p id="p-0039" num="0038">Action&#x2014;A software class that can display alert messages in the Administration Console, send notifications, or change the runtime state of a service. Actions can be adjudicated, requiring user input before the system invokes the action pipeline. Actions can be invoked by the Controller as part of enforcing a policy, or manually from the Administration Console.</p>
<p id="p-0040" num="0039">CPU cycles/Computer Power&#x2014;A measurement of the CPU resources that a resource pool can supply and that a service needs. The measurement can be normalized across CPU architectures so that a megahertz of processing on an i386 processor is comparable to a megahertz on other types of processors.</p>
<p id="p-0041" num="0040">Hypervisor&#x2014;Virtualization software that allows multiple operating systems to run on a single physical computer at the same time.</p>
<p id="p-0042" num="0041">JMS&#x2014;Java Message Service.</p>
<p id="p-0043" num="0042">JMX&#x2014;Java Management Extensions.</p>
<p id="p-0044" num="0043">JVM&#x2014;Java Virtual Machine.</p>
<p id="p-0045" num="0044">Managed Environment/LOC environment&#x2014;The collection of all resource pools, services, processes, Agents and Controller in a single installation at an organization.</p>
<p id="p-0046" num="0045">Machine/Server&#x2014;Either a physical machine or a virtual machine.</p>
<p id="p-0047" num="0046">Metric&#x2014;A numeric runtime value that describes the performance of a process or process group and the resource environment. Some metrics are aggregations or calculations of raw (observed) data. Policies set constraints on metrics.</p>
<p id="p-0048" num="0047">Physical Host&#x2014;The physical machine that is hosting a Controller, an Agent or any of the processes that the system is managing, including, virtual machines that the system has started.</p>
<p id="p-0049" num="0048">Policies&#x2014;Runtime requirements for a service and actions to take when the service operates outside the requirements. In accordance with an embodiment, each policy comprises two parts: a single constraint and an action or pipeline of actions. Multiple policies can be created for each service. Policies can apply to the resource environment, all processes in a service, to a group of processes (process type), or to a single process.</p>
<p id="p-0050" num="0049">Process/Application&#x2014;A program that the system manages. For example, a single application server managed server can be considered a process. From the perspective of the system, a Java process consists of an entire JVM stack and includes any application server and applications being managed.</p>
<p id="p-0051" num="0050">Process Group/Process Type&#x2014;A collection of processes in a service for which policies can be written. For example, a process group can contain three application server instances, and a policy can be written that starts all three server instances when the service is deployed.</p>
<p id="p-0052" num="0051">Resource Pool/Computer Resource&#x2014;A virtual environment, or a physical environment, in which services can be deployed. Each resource pool provides access to physical computing resources (such as CPU cycles, memory, and disk space) and pre-installed software that a service needs to run. A resource pool also contains a description of the failover capabilities of the machines that host the computing and software resources.</p>
<p id="p-0053" num="0052">Service/Application&#x2014;A collection of one or more processes that the system manages as a unit. Each process in a service is a software stack starting from the Java Virtual Machine (JVM) and includes the classes that are running in the JVM. For example, in some embodiments a service can be created for managing a single application server instance on which is deployed a single Java EE application. Alternatively, a service can be created for managing all server instances in a cluster. In accordance with an embodiment, a service specifies requirements for the physical computing resources that are needed to run all of its processes, expressed as a range of CPU cycles, memory, and disk space, an optional set of policies that define an SLA, and actions to take when the service is operating outside of the SLA. Metadata can also be provided that defines the Java classes or other executables that comprise the service processes.</p>
<p id="h-0009" num="0000">System Environment</p>
<p id="p-0054" num="0053">In accordance with an embodiment, a system is provided which includes a management framework for virtualized and non-virtualized enterprise Java applications. A layer of abstraction is provided over complex operation environments that enable operation staff to think in terms of supply and demand. The framework also offers a policy-based framework for creating and automatically enforcing service level agreements for Java applications, and allows the system to monitor resources across the operations center and distribute the deployment of Java applications in a manner that ensures the overall efficient use of resources.</p>
<p id="p-0055" num="0054">On the demand side, the system can be used to organize Java applications (processes) into services. Typically, a group of related processes are organized into a single service and the group is then managed as a unit. Alternatively, one service can be created for each process. On the supply side, the system can be used to organize the computer resources in an operations center into collections of resources, or resource pools. A resource pool can represent a single physical machine or a collection of virtualized resources that are made available through Hypervisor software. In accordance with an embodiment, the system provides an environment for encapsulating an SLA as a collection of requirements and policies. The operation team can define policies based on application-level SLA that govern the allocation of hardware and software resources, ensuring that quality of service (QoS) goals are met across virtual and non-virtualized platforms.</p>
<p id="p-0056" num="0055"><figref idref="DRAWINGS">FIG. 1</figref> is an illustration that shows the architecture of a system for deploying and managing software services, in accordance with an embodiment. As shown in <figref idref="DRAWINGS">FIG. 1</figref>, a typical deployment contains a single Controller <b>101</b>, and multiple Agents <b>102</b> and <b>103</b> that manage and monitor resources and communicate that information back to the Controller <b>101</b>. The Controller <b>101</b> gathers data about the operating environment from the Agents <b>102</b> and <b>103</b>. The Controller <b>101</b> then uses the data gathered to intelligently deploy new services and to evaluate and enforce policies to honor the SLA for all services in the environment. The Controller <b>101</b> also hosts the Administration Console <b>100</b> that enables an administrator to visually configure, manage, and monitor the environment.</p>
<p id="p-0057" num="0056">When predefined conditions occur, the system dynamically allocates resources to services. The system then monitors the use of resources across the operations center and distributes the deployment of Java applications in a manner that ensures the most efficient use of resources overall. When a service is deployed, or when a system action requests that an additional process be started, the system examines all resource pools to determine where to host the service or process. To choose a resource pool, the system first eliminates any resource pool that cannot satisfy particular dependencies (such as IP addresses or access to software. For example, if a service requires access to Application Server software, then the system eliminates any resource pools that cannot provide access to Application Server software). After considering declared dependencies, the system then considers the capacity of each remaining resource pool, the SLA of any services that are currently deployed, and the relative priorities declared for each service. It then uses an appropriate algorithm to determine which resource pool to use.</p>
<p id="p-0058" num="0057">One example is based on most resources available. In this approach the system chooses the resource pool that currently has the most excess capacity. For example, if resource pool A has 600 MHz of CPU and 600 MB of RAM that are currently unused, and resource pool B has 400 MHz of CPU and 400 MB of RAM that are unused, then the system chooses resource pool A.</p>
<p id="p-0059" num="0058">Another example is based on most efficient use of resources. In this approach, the system chooses the resource pool that has just enough unused resources to satisfy the minimum resource requirements of a deployment request. This algorithm ensures the system is best positioned to handle services whose resource requirements are larger than the current request. For example, if resource pool A has 600 MHz of CPU and 600 MB of RAM that are currently unused, and resource pool B has 400 MHz of CPU and 400 MB of RAM that are unused, and if a service is deployed with a minimal requirement of 200 MHz of CPU and 200 MB of RAM, then the system chooses resource pool B.</p>
<p id="h-0010" num="0000">System Controller</p>
<p id="p-0060" num="0059"><figref idref="DRAWINGS">FIG. 2</figref> is an illustration that shows the architecture of a Controller <b>201</b> for use with the system, in accordance with an embodiment. Each instance of the system environment includes a single Controller <b>201</b>. The Controller <b>201</b> is responsible for hosting the Administration Console that enables the administrator to visually configure, manage, and monitor the environment; managing resource pools; managing the creation of services; managing the creation of SLA agreements; and, providing logging and audit trails.</p>
<p id="p-0061" num="0060">To manage resource pools, the Controller communicates with Agents to determine the computing resources that each Agent is capable of allocating and selects appropriate resource pools for deploying services. To adapt the system environment to best meet the SLA of all deployed services, the Controller communicates with Agents to gather metrics. It also compares policy constraints against the metrics and invokes actions when services operate outside the constraints. The Controller configuration, service metadata, and SLA information are stored as XML files and stored locally on the machine that is hosting the Controller.</p>
<p id="h-0011" num="0000">System Agents</p>
<p id="p-0062" num="0061"><figref idref="DRAWINGS">FIG. 3</figref> is an illustration that shows the architecture of an Agent <b>301</b> for use with the system. In accordance with an embodiment, an Agent <b>301</b> is a standalone Java process that renders the CPU cycles and memory of a machine or a collection of virtual resources as resource pools for use by services. As described above, in accordance with an embodiment, the system supports two types of Agents: a Plain Agent for managing any type of Java process, and that renders the resources from the machine on which it resides as a resource pool; and, a Virtualized Agent for managing instances of Application Server running in a virtualized environment, and that renders virtualized resource pools as system resource pools. Agents can use XML documents to save information about the resources that the Agent exposes for use by the system. Agents can also use unique identifiers for each of the managed processes being managed by that Agent.</p>
<p id="p-0063" num="0062">In accordance with an embodiment, a Virtualized Agent can communicate with the Virtual Center or similar process, to gather data about the resource pools that are available for use by the system and to manage instances of Application Server. After an Application Server instance starts, the Agent communicates with the Application Server instance to gather monitoring data and invoke management actions.</p>
<p id="p-0064" num="0063">In accordance with an embodiment, each instance of the system environment includes one or more Agents <b>301</b>. The one or more Agents <b>301</b> are responsible for managing and storing its configuration information; providing ongoing visibility into the amount of resources that the system is using for a given resource pool; controlling the life cycle of JVMs in a resource pool upon request from the Controller; gathering metrics and monitoring data of its instantiated JVMs and making this data available to the Controller; and, providing logging and audit trails.</p>
<p id="h-0012" num="0000">Administration Console</p>
<p id="p-0065" num="0064"><figref idref="DRAWINGS">FIG. 4</figref> is an illustration that shows a screenshot of an Administrative Console or interface. In accordance with an embodiment the Administration Console is a browser-based, graphical user interface that the administrator can use to configure, manage, and monitor services in the operations center. The interface can be hosted by the Controller, which communicates with Agents to gather monitoring data and to invoke management actions.</p>
<p id="p-0066" num="0065">In one embodiment, the Administration Console can configure network communications for Controllers and Agents; organize computing resources into resource pools; organize Java applications into services; create policies to enforce SLA for services automatically; configure logging and auditing features; create users and assign them to groups and roles; deploy and activate services; invoke actions to manually affect services; monitor the performance of services; monitor the use of computing resources on machines that host resource pools; and, view Controller log files and security auditing files.</p>
<p id="h-0013" num="0000">Administration Console and Configuration of Services</p>
<p id="p-0067" num="0066"><figref idref="DRAWINGS">FIG. 5</figref> is an illustration that shows the architecture of a system for deploying and managing software services as process groups and clusters, in accordance with an embodiment. A service is a collection of one or more processes that the system manages as a unit. Each process in a service is a software stack starting from the Java Virtual Machine (JVM), including the classes that are running in the JVM. Typically, processes that perform the same function are organized into process groups. (For example, all of the servers in a cluster can be organized within a process group). The administrator can specify attributes for each process group such as:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0067">The number of instances of the process groups to create initially and the minimum and maximum number of process instances allowed for the service;</li>
        <li id="ul0002-0002" num="0068">The minimum amount of resources that the process requires and an upper limit of resources that the process can use. The system reserves the minimal resources for exclusive use by the process and grants additional resources if they are available;</li>
        <li id="ul0002-0003" num="0069">A priority for the service, which the system uses to resolve conflicts when more than one service fails to meet its SLA at the same time;</li>
        <li id="ul0002-0004" num="0070">Any information required by the system in order to deploy processes, including the main class, JVM startup arguments, and software dependencies;</li>
        <li id="ul0002-0005" num="0071">A ready metric, which the system uses to determine when a process has been successfully started and can be monitored; and</li>
        <li id="ul0002-0006" num="0072">Any software dependencies including the name and location of the software that the processes require to run.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0068" num="0073">The administrator can also define one or more policies that specify the deployment or runtime requirements (constraints) for the service and the actions to take if the SLA constraint is not met. For example, a policy can be used to expand or shrink a service's footprint in response to the runtime environment. Constraints can be placed on a process, a group of processes, or all processes in a service. In accordance with an embodiment, constraints can be based on a calendar value, or, if the managed processes expose management data through Java Management Extensions (JMX), then by constraining the value of an MBean attribute in the processes.</p>
<p id="p-0069" num="0074">For example, in <figref idref="DRAWINGS">FIG. 5</figref>, an administrator can create a service <b>501</b> that specifies a process group <b>502</b> for a collection of externally-facing web services, all of which run on a single application server cluster <b>503</b>, and can configure the process group <b>502</b> as follows:
<ul id="ul0003" list-style="none">
    <li id="ul0003-0001" num="0000">
    <ul id="ul0004" list-style="none">
        <li id="ul0004-0001" num="0075">Resource Minimum=Reserve 400 CPU cycles, 600 MB RAM.</li>
        <li id="ul0004-0002" num="0076">Resource Maximum=Allow services to use up to 800 CPU cycles, 800 MB RAM.</li>
        <li id="ul0004-0003" num="0077">Resource Priority=Specify highest priority over all other services.</li>
        <li id="ul0004-0004" num="0078">Initial Deployment State=Start Administration Server and two Managed Servers.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0070" num="0079">For example, a policy can be created that starts an additional cluster member during business hours. A second policy can be created that starts two additional members if servlet response time drops below 2 seconds, and that stops the additional members if response time is faster than 0.1 second. When the service is deployed, the system reserves the prescribed 400 CPU cycles and 600 MB of RAM for exclusive use by the service. As the system adds processes to the service, it requests additional resources for use by the service up to the maximum. If the additional resources are currently being used by other processes, the system can remove resources from lower-priority processes, as long as each process retains its minimal reserve.</p>
<p id="h-0014" num="0000">Administration Console and Monitoring of Services and System Resources</p>
<p id="p-0071" num="0080"><figref idref="DRAWINGS">FIG. 6</figref> is an illustration that shows another screenshot of an Administrative Console interface that displays metrics, in accordance with an embodiment. The performance of system resources can be charted using charts and graphs that describe the amount of resources the service is using from a resource pool relative to the amount of resources available, and the runtime statistics from each JVM within the service.</p>
<p id="p-0072" num="0081">In accordance with an embodiment, services and system resources can be monitored based on:
<ul id="ul0005" list-style="none">
    <li id="ul0005-0001" num="0000">
    <ul id="ul0006" list-style="none">
        <li id="ul0006-0001" num="0082">Information about events and action that have occurred in the environment and the time that they occurred;</li>
        <li id="ul0006-0002" num="0083">Actions that are currently pending and that require approval;</li>
        <li id="ul0006-0003" num="0084">Notifications that are triggered when a service operates outside of a policy constraint. The administrator can configure the system to generate notifications using Java Message Service (JMS), Java Management Extensions (JMX), Simple Mail Transfer Protocol (SMTP), and Simple Network Management Protocol (SNMP);</li>
        <li id="ul0006-0004" num="0085">Log messages about events such as the deployment of services or the failure of one or more actions; and</li>
        <li id="ul0006-0005" num="0086">Audit messages that capture changes to the Controller, Agents, or service configuration.
<br/>
Administration Console and Security
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0073" num="0087"><figref idref="DRAWINGS">FIG. 7</figref> is an illustration that shows another screenshot of an Administrative Console interface that allows for setting of filters. In accordance with an embodiment, the system uses role-based access control to enable an administrator to assign different levels of privileges to different users or groups. The system also includes a set of security roles with pre-configured access privileges, and groups that can be configured to be in one or more of the defined security roles. An administrator can then create users and assign them to groups, or directly to security roles.</p>
<p id="h-0015" num="0000">Monitor Service</p>
<p id="p-0074" num="0088"><figref idref="DRAWINGS">FIG. 8</figref> is an illustration that shows the monitor service component of the controller. The monitoring service provides the infrastructure to obtain system performance information. The monitoring service converts the constraints specified by the users into a watch list. The watch list is a list of all the attributes that need to be monitored for an asset. This watch list is passed on to the observer that observes the asset. The monitoring service also converts all the raw data that is returned from the observers into metrics that are consumed by services within the System Controller. The monitoring service can also aggregate, count or perform special calculations on the raw data that has been observed. In accordance with an embodiment, the system can provide a set of pre-defined functions that the user is able to use to perform these calculations. The monitoring service also handles all the event/action metrics that are generated within the System Controller. The event metrics capture events such as the start of an action, failure of an action, etc. The monitoring service also supports the console for any monitoring information it may need to display.</p>
<p id="p-0075" num="0089"><figref idref="DRAWINGS">FIG. 8</figref> also describes the monitor service and its interaction with the other components of the System Controller. In the example as shown in <figref idref="DRAWINGS">FIG. 8</figref>, the Java function calls are indicated by solid lines and the web service function calls are indicated by the dashed lines. The interfaces that the monitor service exposes are shown in the rectangles with rounded corners. The execute engine <b>802</b> and the rules engine <b>801</b> are components within the Controller. There can also be a console to access the monitoring information.</p>
<p id="p-0076" num="0090">The MonitorService <b>803</b> interface is the core interface of the monitor service that provides all the functions that other components within the System Controller needs to interact with it. The MonitorHandler <b>805</b> interface is used to broadcast all the updates of the metrics that are maintained by the monitor service. The rules engine <b>801</b> implements the MonitorHandler <b>805</b> interface and registers itself with the monitor service <b>803</b> using the addHandler call. The MonitorService <b>803</b> interface is implemented by the Monitor <b>804</b> class in the monitor service. In one embodiment, the monitor service maintains internally a hierarchical structure based upon the service names and process types. This can be indicated by the ServiceMonitor <b>806</b> and ProcessTypeMonitor <b>807</b> in <figref idref="DRAWINGS">FIG. 8</figref>.</p>
<p id="p-0077" num="0091">In one embodiment, a collector <b>808</b> oversees every ProcessTypeMonitor <b>807</b>. The collector <b>808</b> is responsible for interacting with the observers <b>810</b>. The Collector <b>808</b> also implements the Observer interface. The Collector <b>808</b> is responsible for performing calculations on the data that is received from the observers <b>810</b>. Calculations such as averages, counts, etc., can be performed by the collector <b>808</b>. <figref idref="DRAWINGS">FIG. 8</figref> shows the collector <b>808</b> in which users can plug in their own functions to perform calculations. In addition, in <figref idref="DRAWINGS">FIG. 8</figref>, the lines drawn between the ProcessTypeMonitor <b>807</b>, Collector <b>808</b> and the Observer <b>810</b> represent the Observer contract.</p>
<p id="p-0078" num="0092">The rules engine <b>801</b> notifies the monitor service of the updated constraints by calling the updateConstraints on the MonitorService <b>803</b> interface. State metrics are asserted by the execute engine <b>802</b> and retracted by the rules engine <b>801</b>.</p>
<p id="p-0079" num="0093">When an Observer <b>810</b> has been started up, it notifies the monitor service via a web services call to add an observer. When a new observer is added, a new web service end point is created to handle the new observer. The watch list constructed using the constraints is passed to the observer. The observer then calls into the ObserverHandler <b>809</b> whenever updated metrics have been observed.</p>
<p id="p-0080" num="0094">Monitor Handler allows services to listen to updates on all metrics in the monitor service. The updates include all metrics that have been added, removed or changed. There can be a MonitorHandler <b>805</b> Interface that is used to broadcast updates of the monitoring metrics to all registered handlers. Components that wish to get the updates of the metrics implement this interface and register them with the MonitorService. The handlers receive updates on metrics as they occur within the System Controller. A filter class is specified when the handler is added to the monitor service. This allows the handlers to receive updates on only the metrics they are interested in.</p>
<p id="p-0081" num="0095">All registered handlers can receive updates on a separate thread. This ensures that the handlers do not hold up the operation of the System Controller. The handler can be used to gather all updates to metrics. The system can first spawn a new thread (thread-1) and then loop through all the handlers within the new thread. For each of the handlers within the thread, the system can further spawn a new thread (thread-1-a, thread-1-b, etc.) and notify handlers on the thread.</p>
<p id="p-0082" num="0096">In one embodiment, a MetricsFilter Class can be provided to allow the handlers to specify the metrics that they are interested in. The filter is used to weed out any metrics that the handler is not interested in so that it is not inundated with metrics that are useless to it. The filter allows the handler to specify the service names, process types, process Ids, metric types, instance types and attribute names it is interested in. All except the metric type can be specified in terms of a regular expression. This filter can be updated during runtime.</p>
<p id="p-0083" num="0097">In one example, the monitor service component can be delivered as two bundles, for instance two OSGI bundles. One bundle provides all the core functionality of the monitoring service. It includes the MonitorHandler and the Metrics filter that were described above. The bundle is registered as an Service Discovery Service (SDS) and can be accessed by linking to it in the arc-config.xml file. This service exposes the MonitorService interface. It exposes all functionality that other services within the virtual environment may want to use. Internally, the monitor service can maintain a hierarchical structure of the services and process types.</p>
<p id="p-0084" num="0098">In addition, the monitor service can also be made available via a web service. It allows observers to add themselves to the monitor service. This bundle provides the implementation for the deployment of a web service. It also provides a utility class (MonitorWSUtils) that has a simple static function that the observers can call to add themselves to the monitor.</p>
<p id="p-0085" num="0099">In one embodiment, the MonitorService <b>803</b> Interface is the main interface of the monitor service component. It provides methods to add/remove Monitor Handlers, add/remove/change constraints, assert/retract state metrics, access metrics maintained by the monitor service, and add/remove observers.</p>
<p id="p-0086" num="0100">In addition, for ease of use to call the monitor web service, a utility function can be provided. This utility has a simple static method that can be called. The method encapsulates all the calls to the web service.</p>
<p id="p-0087" num="0101">In one embodiment, one can add different metric types to a watch list. The monitor service can keep track of the number of times an item was added to the watch list because when they are removed they have to be removed from the watch list only when all additions are paired with removals.</p>
<p id="p-0088" num="0102">The collector <b>808</b> is the component that talks to the observers <b>810</b> via the ObserverHandler <b>809</b>. There can be one collector for every process type in a service. The collector can manage all the observers for the processes that belong to that process type.</p>
<p id="p-0089" num="0103">In one embodiment, the collector <b>808</b> is delivered as an OSGI bundle. It can also be declared as a Service Discovery Service (SDS) and the monitor service can use the service to create collectors for the different process types. The collector service exposes the CollectorService interface. In one embodiment, the collector implements the Observer pattern to keep it consistent with the observers that it is managing.</p>
<p id="p-0090" num="0104">In one embodiment, the collector can manage multiple observers. A collector is responsible for managing the observers for the processes that belong to the process type that it is associated with. The management responsibilities include adding and removing observers.</p>
<p id="p-0091" num="0105">In one embodiment, adding an observer involves adding the observer to the list of observers that the collector is managing, providing the observer with the current watch list and providing a web service endpoint that can receive all the metrics. Removing an observer involves taking it out of the list of managed observers, and notifying the process type monitor via the observer contract to clean up the associated metrics.</p>
<p id="p-0092" num="0106">The collector can also update the observers with the current watch list. During the running of the system, the watch list may be modified. These updates are communicated to the collector via the observer contract. The collector <b>808</b> is then responsible for pushing these updates on to the observers that it is managing.</p>
<p id="p-0093" num="0107">The collector <b>808</b> can also perform and is responsible for calculations over metrics received from observers. The collector is notified that it needs to perform these calculations via the watch list. The attribute is tagged with a marker to indicate what kind of calculation needs to be performed.</p>
<p id="h-0016" num="0000">Rules Engine</p>
<p id="p-0094" num="0108">In accordance with an embodiment, the Controller manages the processes that constitute services. <figref idref="DRAWINGS">FIG. 9</figref> is an illustration that shows the component pieces of the Controller <b>901</b>. As shown in <figref idref="DRAWINGS">FIG. 9</figref>, the monitor service component <b>902</b> is responsible for handling all the monitoring information that flows through the Controller <b>901</b>. In order to optimize all the services it manages, the Controller <b>901</b> needs to know how the services are currently performing. This information needs to be monitored and passed back into the controller for it to be able to make decisions on how to tweak the services for optimal performance.</p>
<p id="p-0095" num="0109">In one embodiment, the Service and Process Type are intrinsic to the constraints, metrics and actions described in this document. The Rules Engine <b>903</b> considers these grouping constructs when evaluating the system state and when invoking the Execute Engine <b>904</b> to effect change on the system. Furthermore, other subsystems within the Controller <b>901</b> also consider Services and Process Types. For example, the process meta-data used by the Execute Engine <b>904</b> can be organized by service name and process type name.</p>
<p id="p-0096" num="0110">A Rules Engine <b>903</b> exists to enforce policies specified to the Controller <b>901</b> by an administrator. The Rules Engine <b>903</b> uses constraints that the administrator defines. The Rules Engine <b>903</b>, as a subsystem of the Controller <b>901</b>, can also determine when an action is necessary to satisfy an administrator defined constraint. In addition, the Rules Engine <b>903</b> can determine when a deployment or an un-deployment action is necessary. Also, The Rules Engine <b>903</b> can prepare context necessary for carrying out actions.</p>
<p id="p-0097" num="0111">In one embodiment, the Rules Engine <b>903</b> is comprised of the set of Rules established by the Administrator to govern the behavior and execution environment of the resources and services running within the virtual environment. These rules are a set of conditional expressions and the corresponding action or actions to be executed in the case where the given conditional expressions evaluate to true.</p>
<p id="p-0098" num="0112">In one embodiment, the Drools Rules Engine provides the underlying rules support for the Rules Engine <b>903</b>. Drools Rules Engine is a Rules Engine implementation based on Rete algorithm tailored for an Object-Oriented programming language, such as the Java&#xae; language. Adapting Rete algorithm to an object-oriented interface allows for more natural expression of business rules with regards to business objects. Drools Rules Engine is designed to allow pluggable language implementations. In addition, Drools Rules Engine provides for Declarative programming and is flexible enough to match the semantics of one problem domain with Domain Specific Languages (DSL) via XML using a Schema defined for your problem domain. DSLs consist of XML elements and attributes that represent the problem domain. Using Drools concepts, a defined rule is a given set of condition statements combined with a consequence. In the case of the Controller <b>901</b>, the Drools consequence can correspond to an action that can be handled by the Execution Engine <b>904</b>.</p>
<p id="p-0099" num="0113">In addition, the Drools Rules Engine provides extensibility opportunities. The Controller <b>901</b> can encapsulate this functionality and provide a new mechanism for extensibility. The following provides more details related to the rules definition and execution in accordance with one embodiment.</p>
<p id="p-0100" num="0114">In one embodiment, the Rules Engine leverages the full set of Drools capabilities for defining new domain specific languages. The Rules Engine allows for differing rule types that can be based upon the Drools Semantic Module Framework, as needed, for establishing Domain Specific rule languages. The operation and control system of the virtual environment can support the following rule types: Deployment layout rules; Metric Rules (based on monitored metrics, JMX or other sources); Predefined WLS and resource specific Named rules; Workload and capacity on demand rules; Alert and Failure rules (real-time observed data/HA); Calendar Rules; and Log or Event Rule. When any of the provided rule types are used by the Administrator to define a rule instance and bind that rule instance with one or more associated actions, the rule instance can also have a scope associated with it. In one example, this scope can be defaulted based upon the context in which the rule is specified.</p>
<p id="p-0101" num="0115">In one embodiment, the scope is necessary to allow for the rule instance to be constrained or applied to the appropriate resource in the management domain. This specified scope can allow the Controller to correctly filter which Agent(s) it interacts with for monitoring data and for initiated actions for the given rule instance at execution time. The following scopes can be considered: Global; Service Name(s); Agent(s); Resource Pools; Process Name(s); Process Type; Cluster(s); and Application Server Domain. This ability provides for an ease of specification, such that rules that an administrator wants applied to all services deployed in the virtual environment do not have to be repeated for each configured service. An example of this is surfacing a Notification Action for each deployed service that violates an HA rule. If any running process in any deployed service were to fail, an Administrator would receive an e-mail.</p>
<p id="p-0102" num="0116">The Rules Engine architecture can support the processing of multiple Rule Sets executing in the same runtime environment. Each Rule Set can be loaded and processed using its own Working Memory, isolating the rules and metric information used for that set of rules from other executing Rules Sets. An example is to define each Service, or a defined group of Services, to be its own Rule Set. On the other hand, it is also possible to maintain all Rule Sets in the same working memory for evaluation. Each Rule Set establishes the set of related rules that is exercised at the same time, with the same context. Drools uses the concept of Working Memory to define the set of runtime classes and data that the rules in the rule set will evaluate against. As part of runtime processing, the Resource Monitor interacts with the Rules Engine to provide the metrics and alert events it is receiving. The Rules Engine populates Working Memory with this information.</p>
<p id="p-0103" num="0117">At the appropriate time, either immediate, or on a timed basis, or as initiated by some internal state change detected in the managed domain, a request is made to trigger Rule evaluation. The Rules Engine exercises all of the rules in the rule set against the established data in Working Memory. For each and every rule that evaluates to true, the Rules Engine informs the Execution Engine and the configured actions are initiated.</p>
<p id="p-0104" num="0118">In one embodiment, Rule evaluation is triggered whenever a new metric is provided to the Rules Engine and placed in Working Memory. The concept of rule prioritization is provided to affect the order of rule processing at the Administrators discretion. This helps to handle the varying nature of the different rule types. A rule-priority can be introduced in Rule configuration.</p>
<p id="p-0105" num="0119">Consideration is given for controlling or throttling Rule Sets evaluation. Many of the actions supported in an operational environment require significant time to complete. The Controller wants to throttle or delay the evaluation of additional Rules that directly relate to the ongoing action or actions. Therefore a mechanism can be provided to allow for an individual rule or set of rules to be disabled. This mechanism can be useful when introducing new rules into the currently executing environment.</p>
<p id="p-0106" num="0120">In one embodiment, the Rules Engine <b>903</b> provides the RulesEngineService API, a public interface that can be used by other subsystems in the Controller <b>901</b> such as the Configuration subsystem and the Trigger Service. External access to the Rules Engine <b>903</b> can be made via either the console or configuration subsystem. Monitoring of Rules Engine state can be done via the Monitoring subsystem. For example, public access to configure the Rules Engine can be done via the Configuration Service. In addition, public access to monitor the Rules Engine <b>903</b> can be done via the Monitor Service <b>902</b>. The Rules Engine service can assert its monitoring information to the Monitor Service <b>902</b>. In one example, the RulesEngineService is an OSGi service within the Controller <b>901</b> which provides APIs for defining user services and associating constraints on process types with those services.</p>
<p id="p-0107" num="0121">The RulesEngineService API provides interfaces to add, remove and change process type constraints for the services. The RulesEngineService API uses the information provided by the Monitor Service <b>902</b> to determine when action is necessary. The RulesEngineService API also tells the Execute Engine <b>904</b> when action is necessary and provides context information which may be used in performing the action.</p>
<p id="p-0108" num="0122">Internally, the Rules Engine <b>903</b> can keep System Performance Metrics, Constraints, EventMetrics, and Action Metrics. Here, System Performance Metrics are passed in from the Monitor <b>902</b>. EventMetrics are related to Events and are asserted internally by the Rules Engine <b>903</b>. ActionMetrics are related to Actions and are asserted externally by the Execute Engine <b>904</b>. In addition, the Rules Engine <b>903</b> keeps a data structure that tracks the existing Services, Process Types, and Process instances. The key elements of this data structure are SystemState, ServiceState, and ProcessTypeState.</p>
<p id="p-0109" num="0123">In one embodiment, the Monitor <b>902</b> provides system performance Metrics to the Rules Engine <b>903</b>. When Constraints are added to the Rules Engine Service, the Rules Engine Service passes the Constraint data on to the Monitor which uses the Constraint information to generate a watch list for observers. The Monitor <b>902</b> can convert observation values returned from the Observer based on the watch list into Metric values.</p>
<p id="p-0110" num="0124">In one embodiment, all of the metric data, including the action and event metrics, can be visible from the monitor service <b>902</b>. The constraint information used by the Rules Engine <b>903</b> is available from the configuration service. Some of the information from the state data structure is available from the RulesEngineService interface.</p>
<p id="h-0017" num="0000">Execution Engine</p>
<p id="p-0111" num="0125">In accordance with an embodiment, the Execution engine provides a programming environment where both built-in actions and third party supplied actions can run to perform the automated IT behavior. Examples of built-in actions include starting and stopping processes, raising alerts to administrators, and initiating configuration changes.</p>
<p id="p-0112" num="0126">The Execution Engine provides the ability for actions to be initiated directly via the Console, or externally supported Web Services. One embodiment can dynamically manage an adaptive environment. The adaptive management is based upon the defined set of rules for monitoring the environment and the corresponding set of actions that are initiated to adapt. This can be as a result of rules based upon defined constraint violations or rules based upon a schedule or calendar. In one embodiment, the combined rules and actions provide a framework for delivering the quality of service demanded by the deployed services, or meeting the service level agreements provided by the resource providers.</p>
<p id="p-0113" num="0127">The Execution Engine executes Actions to fulfill constraints. The administrator can configure a Pipeline to define a set of Actions and execute them. The Execution Engine executes the Action(s) in serial or parallel based on how the Pipeline is configured. The Execution Engine can alert the Administrator when Actions are executed. The Administrator can also configure the Action(s) or the Pipeline(s) for adjudication. The Execution Engine can wait for the Administrator to accept or reject the Action(s) or the Pipeline(s) based upon the adjudication configuration on that Action(s) or Pipeline(s). In one embodiment, the Execution Engine uses a Resource Broker to perform resource control Actions. The Administrators of the operation and control system for the virtual environment can also select the Action(s) or the Pipeline(s) and force execution on them from the Administration Console. The Execution Engine Service can be an OSGi service that can be used by the other services or bundles in the Controller for initiating Action execution.</p>
<p id="p-0114" num="0128"><figref idref="DRAWINGS">FIG. 10</figref> shows how the Execution Engine Service is dependent with the other services provided by the other components in the Controller and how the other services provided by the other components are dependent on the Execution Engine Service. As shown in <figref idref="DRAWINGS">FIG. 10</figref>, the Execution Engine Module <b>1001</b> includes Event Handle Service <b>1008</b>, Execution Engine Service <b>1009</b>, Pipeline Manager Service <b>1010</b>, and Adjudication Manager Service <b>1011</b>. The Event Handle Service <b>1008</b> handles an event generated from the Rules Engine Service <b>1012</b> and passes the event to the Execution Engine Service <b>1009</b>. The execution Engine Service <b>1009</b> uses the Metadata Service <b>1016</b> to obtain the associated actions with the event. Then, the Pipeline Manager Service <b>1010</b> can use the Resource Broker Service <b>1017</b> to execute the resource related operation.</p>
<p id="p-0115" num="0129">In one embodiment, the Execution Engine Service <b>1009</b> prepares action(s) for execution and performs execution when an Event is fired either by the Rules Engine or by the Administrator Console. The Execution Engine Service <b>1009</b>, when it receives Event(s), can find the relevant Action(s) or Pipeline(s) from the Application Metadata, and registers the Event with the Pipeline Manager. The Execution Engine Service <b>1009</b> also provides APIs to get to the other services such as the Adjudication Manager Service <b>1011</b>, or the Pipeline Manager Service <b>1010</b> provided by the Execution Engine.</p>
<p id="p-0116" num="0130">In one embodiment, the Execution Engine Service <b>1009</b> provides APIs for initiating the Action or Pipeline execution. In addition, the Execution Engine Service <b>1009</b> provides access methods to get to the Pipeline Manager. Also, the Execution Engine Service <b>1009</b> provides APIs to register Event(s) and corresponding Action(s) with the Pipeline Manager. Registration implicitly creates a Pipeline. Also, the Execution Engine Service <b>1009</b> provides access methods to get to the Adjudication Manager. Also, the Execution Engine Service <b>1009</b> provides access methods to get to the Resource Broker Service so that other Execution Engine internal classes can use this service for making process control operations.</p>
<p id="p-0117" num="0131">In one embodiment, the Execution Engine Service <b>1009</b> is initialized when the Controller is being booted. The initialization is based on services, such as Resource Broker Service <b>1017</b>, Application Metadata Service <b>1016</b>, Monitor Service <b>1015</b>, and the Work Manager Service. The Resource Broker Service <b>1017</b> is used to make process control operations. The Application Metadata Service <b>1016</b> can get to the application configuration metadata for starting up processes in the application. The Monitor Service <b>1015</b> can assert metrics, and the Work Manager Service can schedule notifications or other such operations onto different threads.</p>
<p id="h-0018" num="0000">Metrics</p>
<p id="p-0118" num="0132"><figref idref="DRAWINGS">FIG. 11</figref> is an exemplary illustration of a Metric class diagram in accordance with one embodiment. In this example, the type hierarchy of the metrics package mirrors that of the constraints package.</p>
<p id="p-0119" num="0133">ServiceState <b>1111</b> is a Metric type that provides metadata about a service, such as its priority. ServiceState <b>1111</b> can be used by the Rules Engine to decide whether and when to send certain events to the Execute Engine. In addition to the general Metric types <b>1100</b>, there are other types for holding state about the system in the metrics package. These types can be used by the Rules Engine to keep derived information about the system.</p>
<p id="p-0120" num="0134">For example, when the Rules Engine sends an event to the Execute Engine, it can simultaneously generate for itself an EventMetric <b>1103</b> with a value of EVENT_STARTED. When the Execute Engine has finished processing this event, it changes the value to either EVENT_SUCCEEDED or EVENT_FAILED. Such information is used to prevent redundant ArcEvents from being passed to the Execute Engine while it is in the midst of processing. The EventMetric <b>1103</b> can be dynamically updated. In one example, the Rules Engine is automatically notified via Java Beans PropertyChangeSupport when it is modified.</p>
<p id="p-0121" num="0135">For a given event, the Execute Engine can perform one or more actions. For each action, the Execute Engine generates an ActionMetric <b>1106</b> and asserts it to the Monitor so that the Rules Engine may track progress of individual actions. Similar to the EventMetric <b>1103</b>, ActionMetric <b>1106</b> can also be dynamically updated. Another type of AssertedMetric <b>1107</b> is the ProcessMetric <b>1105</b>. The ProcessMetric <b>1105</b> is asserted to the Rules Engine whenever a process is started. The Rules Engine uses this information to determine whether a service is within its process boundaries. ProcessMetrics <b>1105</b> can be created when the system restarts. EventMetric <b>1103</b>, ActionMetric <b>1106</b>, and ProcessMetric <b>1105</b> can all implement the tagging interface AssertedMetric <b>1107</b>. The Rules Engine can assert the AssertedMetrics <b>1107</b> to the Monitor Service so that the Console or other tools can view them.</p>
<p id="h-0019" num="0000">Constraints</p>
<p id="p-0122" num="0136">In accordance with an embodiment, a Constraint is a user defined service level agreement (SLA) for some discrete entity which is captured by a Metric or states which are derived from metadata or other Metrics. Each Constraint instance has a unique name within the operation and control system of the managed environment in order to identify itself. The constraint types loosely follow the scoping organization of things being managed by the operation and control system of the virtual environment: System, Service, and Process. Constraints are evaluated whenever new or changed Constraints and/or Metrics are passed into the RulesEngineService. After each evaluation, depending on the result, events may be sent to the Execute Engine.</p>
<p id="p-0123" num="0137">The Rules Engine Service describes an interface that is used to add constraints to the Rules Engine. In one example, a set of interfaces for defining constraints that are passed to the Rules Engine Service.</p>
<p id="p-0124" num="0138"><figref idref="DRAWINGS">FIG. 12</figref> is an exemplary illustration of a Constraint class diagram in accordance with one embodiment. It shows the hierarchy of Constraint and all its sub-types. ServiceConstraint <b>1202</b> is a specialization of Constraint <b>1201</b> which is tied to a specific Service. The ServiceConstraint <b>1202</b> has a State attribute which defines to which deployment state the constraint can be applied. The deployment states are defined in the ServiceState class. The State attribute of the ServiceConstraint is compared with the State attribute of the ServiceState for the service to determine if the constraint should be applied. A ProcessTypeConstraint <b>1203</b> is a specialization of ServiceConstraint <b>1102</b> which is tied to a process type within a service. ObserverConstraint <b>1204</b> is a specialization of ProcessTypeConstraint <b>1103</b> which is tied to a specific Metric that is provided by the monitor. There are specializations of ObserverConstraint <b>1204</b> for various primitive types&#x2014;IntConstraint, LongConstraint, DateConstraint, etc&#x2014;which are used by the Rules Engine for matching with corresponding Metric types. ObserverConstraints <b>1204</b> have a helper method called checkMetricValue which is used by the Rules Engine to compare a metric value&#x2014;which it provides to the method&#x2014;with the expected value of the constraint. This allows the Rules Engine to treat all constraint types generically and should make adding new constraint types easier.</p>
<p id="p-0125" num="0139">In addition to ObserverConstraints, there are two special kinds of constraints for dealing with the results of event handling (EventConstraint <b>1205</b>) and individual actions (ActionConstraints <b>1206</b>) performed by the Execute Engine. When the Rules Engine finds a Metric that does not satisfy a certain Constraint, the Rules Engine sends an event to the Execute Engine. The Execute Engine can then perform one or more actions related to the event. The Execute Engine can post ActionMetrics to the Monitor Service which, in turn, posts them to the Rules Engine for each action. The Execute Engine can also update EventMetrics corresponding to the event handling as a whole.</p>
<p id="h-0020" num="0000">Events</p>
<p id="p-0126" num="0140">In accordance with an embodiment, when the Rules Engine determines that a Metric does not comply with a Constraint that has been defined it can send an Event to the Execute Engine to perform some action. In one embodiment, each event generated by the rules engine carries with it information necessary to handle the event including the scope of a constraint failure that caused the event.</p>
<p id="p-0127" num="0141"><figref idref="DRAWINGS">FIG. 13</figref> is an exemplary illustration of Event State diagram in accordance with one embodiment. As shown in <figref idref="DRAWINGS">FIG. 13</figref>, the events can carry references to state data objects created and managed by the Rules Engine. The state data objects includes a hierarchy of SystemState <b>1301</b>, ServiceState <b>1302</b> and ProcessTypeState <b>1303</b> objects. For example, the ProcessTypeState <b>1303</b> has attributes that indicate whether a process is allowed to start or stop, as defined in ProcessTypeEvent <b>1313</b>. Also, a ServiceEvent <b>1312</b> refers to a ServiceState <b>1302</b>. In addition, a SystemEvent <b>1311</b> refers to a SystemState <b>1301</b>. In one embodiment, all these attributes are calculated during rules processing.</p>
<p id="p-0128" num="0142"><figref idref="DRAWINGS">FIG. 13</figref> also shows the basic event types and the state types to which they can refer. Note that the hierarchy data structure allows one to traverse to higher level objects if needed. For example, if the ProcessTypeState <b>1303</b> object is given in the event, the ServiceState <b>1302</b> object is available as well. Also, the elements of this data structure can be asserted into the working memory of the rules engine. The Rules Engine can detect changes to attributes that affect rules.</p>
<p id="p-0129" num="0143">In one embodiment, a set of interfaces defines the events which the Rules Engine can provide to the Execute Engine when a constraint has failed. There are different event types corresponding to different combinations of Metrics and Constraints. These event types carry different information depending on the nature of the constraint failure. The ArcEvent <b>1310</b> carries with it information that may be used for handling the event. This information may be used to look up metadata related to the problem as well as to determine which actions should be taken. In addition, the information from the Constraint may be used when modifying the EventMetrics or creating the ActionMetrics described below. A ServiceState <b>1301</b> object is passed along with the event. This is used when the action requires service wide action, such as deployment. The ServiceState <b>1302</b> object has information about the runtime state of the service including references to all of the ProcessTypeState <b>1303</b> objects for the service.</p>
<p id="p-0130" num="0144">There can also be a system wide event. For example, load balancing support can be modeled with events that include system wide information associated with a SystemState <b>1301</b> object. There are different kinds of events which carry different kinds of information, the Execute Engine can ensure that the actions applied are appropriate for the event type that is passed to it.</p>
<p id="p-0131" num="0145">Events can be fired in a prioritized manner. Priorities are assigned to each service as well as to each constraint within a service. When multiple constraints are failing, those associated with higher priority services are fired first. Within the same service priority, constraints of the highest priority can be fired first. In one example, when there is an event in progress for a particular constraint associated with a service and process type, the Rules Engine does not produce another event for the same constraint.</p>
<p id="p-0132" num="0146">The Rules Engine can assert an EventMetric just before sending an event to the Execute Engine. The Execute Engine can modify this metric when the event handling is complete. The Rules Engine can clean up any EventMetrics in a completed state prior to the next rule evaluation cycle. In one embodiment, EventMetrics can age-out rather than be cleaned up each time the Rules Engine evaluates the rules.</p>
<p id="h-0021" num="0000">Actions</p>
<p id="p-0133" num="0147">In accordance with an embodiment, the Action is a contract or a public interface defined by the Execution Engine. The Execution Engine expects an object of type Action while initiating the execution, and, hence, every Action being initiated can implement this contract. The Administrators may define custom Action(s) and those custom Action(s) can implement this contract as well. The Action class provides the typical data structure that is needed for the execution when a constraint fails. In one embodiment, the Action provides API to execute the action. In addition, the Action provides an API to associate with the Application Metadata. Also, the Action provides API to get the Application Metadata. Also, the Action provides API to get the state of the Action.</p>
<p id="p-0134" num="0148">In some embodiments, built-in and third party provided actions are written as Java Beans or Plain Old Java Object (POJO). The operation and control system for the virtual environment can supply JavaBeans that start and stop JVM instances, raise alerts, initiate configuration changes etc. In one example, a third party can write third party provided beans which call out to third party software or implement custom logic for their environment.</p>
<p id="p-0135" num="0149">In one embodiment, the operation and control system for the virtual environment provides action classes for common use cases and coding is not required in these scenarios. The operation and control system can invoke these actions from both the Controller Console when associated with defined Rules. In another embodiment, these can be externally exposed via a set of Web Services so as not to limit Administrative control to the provided Controller user interface.</p>
<p id="p-0136" num="0150">There can be different types of actions, such as Deployment Actions, Notification Actions, Configuration Actions, and Third Party Actions.</p>
<p id="p-0137" num="0151">Deployment Actions are those that initiate deployment or undeployment of the service. Deployment Actions include Process Control Actions, which manage the resources, such as Starting, Stopping, Suspending or Resuming the application. In addition, Deployment Actions are capable of expanding or shrinking resources such as CPU, memory. This refers to the changing of the resource agreement for an application or for a process instance of an application. Also, Deployment Actions can be instance migration actions such as taking a snapshot of a process instance and starting it on another resource. These actions are all pre-defined actions. The Execution Engine can trigger these actions when a set of rules met in the rules engine matches to either one of these canned actions. Notification Actions are those that initiate alerts by sending notifications. Notification Actions can send notifications through a SNMP trap; SMTP; JMX; or JMS message. Configuration Actions are those that can be executed as a result of the Administrator changing the configuration for an application or for a process instance of an application. For example, Configuration Actions are capable of changing the Execute Queue size of an Application Server process instance of a service; shrinking or expanding the JDBC connection queue size of an Application Server process instance of a service; changing the configuration of web server plugin of a service; and deploying or undeploying a J2EE application in an Application Server process instance of a service. The Administrator can define Third Party Actions in the Action contract and they may be totally unknown to the container.</p>
<p id="p-0138" num="0152">In one embodiment, the metadata necessary to perform an action for a given rule is part of the binding. It can be beneficial to define default metadata for a given action. An example is the ability to configure a default SMTP-Notification action, such that whenever any action was initiated as a result of a successful rule evaluation, an e-mail notification would be delivered to the configured addresses for this with the defined subject and message body.</p>
<p id="p-0139" num="0153">In one embodiment, actions are configurable at different scopes with appropriate instance data specified for a given scope. The Administrators can configure actions anywhere as in a Global scope. An example for the globally scoped actions is to allow the Administrator the ability to alert the Administrator via email when there is a successful stop action execution of any process or any application. Also, the Administrators can define the Service Scoped actions. An example for the Service Scoped actions allows the Administrator the ability to manage resources for an interested service. Also, the Administrators can define the Process Type Scoped actions. An example for the Process Type Scoped actions is to allow the Administrator the ability to manage the resource for an Application Server Cluster. Also, the Administrators can define the Instance Scoped actions. An example for the Instance Scoped actions is to allow the Administrator the ability to manage resources for a specific application Server instance of a service.</p>
<p id="p-0140" num="0154">In one embodiment, the actions provide extensibility. In one example, the execution engine, as well as Resource Controller in the Agent, can be built upon a Spring Framework to allow for ease of extensibility. The Spring Framework offers features required to create complex business applications effectively outside of the programming models on the Java platform. The Spring Framework leverages an existing popular and lightweight container, allowing for time spent on value-add rather than reinventing the technology. The Spring Framework does not require the developers to learn a new programming model. The operation and control system for the virtual environment can provide actions as POJO beans, which are separated from the Controller runtime, making it possible to ship updated or additional actions without modifying the Execution Engine component. User can have a simple POJO model for writing custom actions or plugging in third party products when this is exposed as an extensibility point. In addition, Spring Framework's POJO beans can be unit tested outside of the Controller. Also, Spring Framework separates the metadata and configuration from the implementation logic and provides an easy way for a third party to plug-in debugging or audit point cuts. As an example, action classes can leverage Spring Framework's dependency injection support to manage their external references. For instance, an action class which logs a message to a database can be injected with the JDBC DataSource reference.</p>
<p id="p-0141" num="0155">In one embodiment, the Controller can track the status of single actions or actions that are part of an action pipeline. For example, the Controller can leverage some Audit events as part of the tracking and reporting. There can be both long-running single actions and certainly for long-running pipelines, the Controller can represent the status of each of these actions back to the Administrator so that the Administrator is kept aware of the activity in progress within the adaptive environment. The execution engine can provide this tracking ability for any and all actions that it initiates. As an example, the execution engine can provide the tracking ability that is roughly equivalent to the capabilities of the TaskRuntimeMBean functionality in an application server which is used to track and report status on long running activities. For the operation and control system in the virtual environment, an initiated Action can surface information that includes: Start time; Action type; Current or completed duration; End time; Action Status (progress state, succeeded, failed); and, Exception (on Failed Action Status).</p>
<p id="p-0142" num="0156">In some embodiments, for an action pipeline, this can either be represented as a single TaskRuntimeMBean with an array of task entry info listed above along with an encompassing action entry for the entire pipeline, or it can be implemented as a set of unique TaskRuntimeMBeans for each action, with a Pipeline correlation identifier in each of the actions. In one embodiment, all activity corresponding to the Action tracking are represented in the UI for monitoring purposes as well as tracked in the Controller log file.</p>
<p id="p-0143" num="0157">In some embodiments, for both long running actions and action pipelines, state persistence is required to provide the ability to deal with failure conditions of the Controller. A persisted context of pipeline execution needs to be maintained. A restarted Controller can report on the state of all pipelines and actions that were executing at the time of failure.</p>
<p id="h-0022" num="0000">Pipeline</p>
<p id="p-0144" num="0158">In accordance with an embodiment, the Pipeline is a form of complex Action where it consists of a list of Actions to be initiated. Configuration Component in a virtual environment provides the ability of configuring the Pipeline. The Pipeline Manager can construct the Pipeline instance for the PipelineBean that comes from the Configuration Component.</p>
<p id="p-0145" num="0159">The Administrator can configure a Pipeline and associate it with multiple Actions. The Execution Engine defines an interface for the Pipeline and it expects any Pipeline being performed to implement this contract. A Pipeline can be configured for either parallel execution or for serial execution. In addition, the Pipeline maintains a Pipeline Context so that the Action(s) executed inside the Pipeline can make use of this Context object for getting to the state of execution or update the state of the execution.</p>
<p id="p-0146" num="0160">While many virtual environment initiated tasks are simple actions (such as raising an alert), and can be implemented with a single JavaBean, other tasks require composing together multiple simple actions. For instance, an automated IT scenario requires starting a new application server instance, updating their web server plug-ins and logging a message; or a user chooses to log a message, raises an SNMP trap, and calls out to the application server to turn on additional debugging as one action. In one embodiment, a Pipeline processor can handle multi-step actions. The Pipeline processor is injected with the actions in its pipeline. The Pipeline runs through the simple actions calling out to each.</p>
<p id="p-0147" num="0161">The Pipeline instance is configured to identify the ordered list of action beans to be executed. In one example, by default, the pipeline calls out to each bean sequentially. It is possible to allow for the metadata to configure a set of beans which may be run in parallel. In one embodiment, the parallel actions are run in separate threads and no guarantee is given about their execution ordering. In one embodiment, pipelines can mix sequential and parallel blocks, with all beans in a parallel block complete before moving on to the next sequential action.</p>
<p id="p-0148" num="0162">In one embodiment, pipeline actions require context or the ability to pass state through the Pipeline. A java.util.Map can be passed to each action bean and is read or modified by the action. Parallel actions receive a thread-safe Map implementation. There is no need of passing any pipeline metadata to the action classes. In one example, the operation and control system for the virtual environment does not provide a means for them to know all the other beans in the pipeline or change the bean list.</p>
<p id="p-0149" num="0163">For extensibility purposes, the operation and control system for the virtual environment can support third party action beans in the pipeline that do not implement any built-in interface. In this scenario, the configuration simply provides the method-name along with the class-name for action invocation.</p>
<p id="p-0150" num="0164">In one embodiment, a pipeline action can signal an error by throwing an exception. When this occurs, the Pipeline bean guarantees no further sequential actions in the pipeline are called. Any parallel tasks running are allowed to complete. The pipeline optionally specifies an error handler in the metadata. This handler implements an Error Handler interface and is called first when error processing begins. The Error Handler is meant to handle any error processing that is global to the pipeline. For instance, it can email an administrator with the error. Actions in the pipeline may also request a callback. After calling the Error Handler (if one exists), the actions receive error callbacks in the reverse order as their execution callbacks. All error callbacks are sequential (single-threaded). The order of callbacks in a parallel block is undefined. Note that only beans which have already completed execution without error receive the callback. The bean's error callback is meant to undo anything it performed in its execution callback, if possible. Not all beans will implement this callback or be able to rollback.</p>
<p id="p-0151" num="0165">A Pipeline can be executed in parallel or sequential. If the Pipeline is configured for parallel execution, it can initiate the execution on each Action associated with it in parallel. If it is configured for the sequential execution, then the Actions associated in it can be executed sequentially in the order in which they are configured. In one embodiment, the Pipeline maintains the status. Its status can be changed based on each transition.</p>
<p id="p-0152" num="0166">In one embodiment, the Pipeline provides the accessor methods for adding, removing or getting the Actions, including getting the status of the Actions. In addition, the Pipeline provides API for initiating the adjudication, execution of the Actions, and preparing the associated Actions. Also, the Pipeline provides the accessor method for getting the PipelineContext so that it can be used by the Actions associated with the Pipeline. Last but not least, the Pipeline provides the types for lifecycle states of the Actions.</p>
<p id="p-0153" num="0167"><figref idref="DRAWINGS">FIG. 14</figref> shows a basic flow diagram for the Pipeline or the Action execution. As shown in <figref idref="DRAWINGS">FIG. 14</figref>, in one embodiment, the Execution Engine Service <b>1404</b> implements the contract Event Handler. When an Event fires as a result of a constraint failure in the Rules Engine <b>1401</b>, or as a result of the Administrator selecting the Action(s) or Pipeline(s) for firing from User Interface Service <b>1403</b>, the Execution Engine Service <b>1409</b> receives an Event fired message, eventOccurred( ), and the corresponding EventMetric object. It can make use of the Application Metadata Service <b>1408</b> and finds the relevant Pipeline(s) <b>1409</b> or Action(s) <b>1410</b>. After it finds the relevant Action(s) <b>1410</b> or Pipeline <b>1409</b> for the incoming Event, the Execution Engine Service <b>1404</b> registers the Event and the Action(s) or Pipeline with the Pipeline Manager Service <b>1405</b>. After the successful registration of the Event and the Action(s) or the Pipeline with the Pipeline Manager Service <b>1405</b>, it can initiate execute( ) for that Event. Then, the eventOccurred( ) method can update the EventMetric's state when the Pipeline execution succeeds or fails.</p>
<p id="p-0154" num="0168">In one embodiment, the Pipeline Manager <b>1405</b> is an internal OSGi service. It manages the registered Pipelines. It also provides the API for monitoring the registered Pipelines <b>1409</b>. The Pipeline Manager <b>1405</b> also provides APIs for registering/deregistering the Pipelines <b>1409</b>. If an Event results in one Action, the Pipeline Manager <b>1405</b> registers an internal Pipeline with one Action in it.</p>
<p id="p-0155" num="0169">In one embodiment, the Pipeline Manager <b>1405</b> keeps the Pipeline instances even after their execution is completed so that they can be shown to the Administrator by the Administration Console. Such Pipelines can be kept around until they are marked as retired. The Pipeline Manager <b>1405</b> provides API for marking the Pipeline retired. After the Pipeline is marked retired, it is removed by the Pipeline Manager automatically when it purges the retired Pipelines.</p>
<p id="p-0156" num="0170">In one embodiment, the Pipeline Manager <b>1405</b> provides APIs for registering/deregistering the Pipelines. In addition, the Pipeline Manager <b>1405</b> provides APIs for initiating the execution of a Pipeline identified with the interested Id. Also, the Pipeline Manager <b>1405</b> provides API for initiating the adjudication of a Pipeline identified with the interested Id. Also, the Pipeline Manager <b>1405</b> provides API for knowing lifecycle states such as is executing, is execution initiated, is prepared, is adjudication pending, is retired, is failed on a Pipeline identified with the interested Id. Also, the Pipeline Manager <b>1405</b> provides API for preparing a Pipeline identified with the given Id. Also, the Pipeline Manager <b>1405</b> provides the accessor method to get the active Pipelines so that the LOC Administration Console can use this and show the active Pipelines. Also, the Pipeline Manager <b>1405</b> provides the accessor method to get the retired Pipelines so that the LOC Administration Console can use this and show them to the Administrator. Also, the Pipeline Manager <b>1405</b> provides API for removing the retired Pipelines so that the LOC Administration Console can provide an option to the Administrator to explicitly remove them. Also, the Pipeline Manager <b>1405</b> provides API for retiring the finished Pipelines so that the LOC Administration Console can provide an option to the Administrator to explicitly mark them retired.</p>
<p id="p-0157" num="0171">In one embodiment, every Pipeline has a Pipeline Context associated with it. This context provides the information of the state of the Pipeline and actions associated with the Pipeline. It also provides the context information such as for the Event the pipeline is initiated for execution and the affecting Service. All the Actions associated with the Pipeline have access to this Context object while they are being executed. The Context object is an intermediate object and can exist as long as the Pipeline exists.</p>
<p id="p-0158" num="0172">In one embodiment, the Administrator is given an option to force the Pipeline removal and force marking a Pipeline retired. If the Pipeline is not marked for retire but it is completed the execution and is idle for the configured idle timeout, Pipeline Manager can automatically mark that Pipeline retired.</p>
<p id="p-0159" num="0173">In one embodiment, the Pipeline Context provides API to get to the Pipeline instance for which this context belongs to. In addition, the Pipeline Context provides APIs to get the state of the Actions associated with the Pipeline to which this context belongs; the scoping information of the Pipeline being executed for which this context belongs to; the Event by which this Pipeline is initiated for execution; and, the time it took for state transitions.</p>
<p id="p-0160" num="0174">In one embodiment, the Pipeline bean encapsulates a simple and lightweight java state machine. The expectation is that pipelines are relatively short-lived sets of tasks that do not require human intervention to complete. The pipeline does not persist its state or support long-running business processes. The pipeline does not include a decision or routing language between its steps.</p>
<p id="p-0161" num="0175">For scenarios that do require this type of functionality the extensibility model could be leveraged to integrate with an external workflow engine. The third party action bean could make a web service or other remote call to the workflow engine and begin a business process or workflow.</p>
<p id="h-0023" num="0000">Adjudication</p>
<p id="p-0162" num="0176">In accordance with an embodiment, the Execution Engine provides the ability for a given single Action, or a defined Action Pipeline to be adjudicated. This allows for the approval or rejection of a given action that the Controller has initiated.</p>
<p id="p-0163" num="0177">Adjudication is allowed on a given single action, or on the entire pipeline. In one embodiment, adjudication is not allowed for individual actions within the defined action pipeline. If the individual action, the pipeline, or an action within a pipeline is defined to require adjudication, then a single request for adjudication is made. Adjudication can also be configurable globally, on a per-action or on a per-service basis. In one embodiment, the architecture allows the registration of multiple adjudicators. When multiple adjudicators are configured, there is configuration available to define the approach for conflicting responses.</p>
<p id="p-0164" num="0178">In one embodiment, a single adjudicator, for example the Console Adjudicator, results in the prompting of the Console administrator to approve or deny the execution. There can be a configurable timeout allowed for addressing the scenario where there is no response from the Administrator. In such a scenario the configuration also allows for defining whether or not a timeout should result in an approval or denial of the execution. In one example, a denial of a configured action execution leads to the Controller continuing to raise the same constraint violation. In this example, the Administrator can disable the Rule which caused the action request.</p>
<p id="p-0165" num="0179">In one embodiment, the Adjudication Manager <b>1406</b> is an OSGi service defined by the Execution Engine that can register the Pipeline(s) or Action(s) for adjudication, configure the adjudication and provide monitoring points for the Pipeline(s) pending for adjudication. It also allows the Administrators to register adjudication handlers for plugging in their own adjudication methods. In one example, it registers one Adjudication Handler and this Handler waits for the Action(s) or the Pipeline(s) to move further for execution until the adjudication is done through the console where the Administrator of the system approves or denies the Action(s) or the Pipeline(s).</p>
<p id="p-0166" num="0180">The Pipeline Manager <b>1405</b>, as part of the prepare phase of the Pipeline, passes the Pipeline through the Adjudication Manager <b>1406</b> and registers the Pipeline for the adjudication with the Adjudication Manager <b>1406</b> if the Pipeline or the Action(s) associated with the Pipeline are configured for adjudication.</p>
<p id="p-0167" num="0181">The Adjudication Manager <b>1406</b> provides API to perform adjudication for a given pipeline; to configure adjudication for a given application or service; to register/deregister AdjudicationHandler; and, to retrieve pending action-set for adjudication for auditing purposes.</p>
<p id="p-0168" num="0182">The Adjudication Manager <b>1406</b> goes through the registered Adjudication Handlers <b>1407</b> and calls adjudication on them. The Adjudication Manager <b>1406</b> provides a way to register/deregister the Adjudication Handlers <b>1407</b>. The Adjudication Manager <b>1406</b>, while running through the Adjudication Handlers <b>1407</b>, schedules the adjudication on a different thread so that it does not block the execution initiated thread.</p>
<p id="p-0169" num="0183">The default Adjudication Handler <b>1407</b> is the type of adjudication that can be done through the Administration Console. While adjudicating through this Adjudication Handler <b>1407</b>, it marks the Pipeline(s) or the Action(s) for adjudication and they are put on hold until the Administrator logs into the Administration Console, and, approves or denies the execution on these Pipeline(s) or Action(s).</p>
<p id="p-0170" num="0184">The Pipeline Manager <b>1405</b> sends the Pipeline to the adjudication only when the Pipeline is explicitly configured for the adjudication but not for the individual Action(s). The Pipeline does not inherit the adjudication from the associated Actions. If the Pipeline is not configured for the adjudication but the associated Action(s) are configured for the adjudication a warning is issued and the Pipeline Manager can proceed as if it is non-adjudicated.</p>
<p id="p-0171" num="0185">The Adjudication Handler <b>1407</b> blocks the thread when it executes the adjudication operation on the Pipeline or the Action. So, the Adjudication Manager <b>1406</b> uses one Work Manager for each Pipeline when it performs adjudication on the Pipelines. The Adjudication Manager <b>1406</b> schedules the adjudicate work with the Work Manager that corresponds to the Pipeline. In one embodiment, the Adjudication Manager <b>1406</b> can be used by the Pipeline Manager to initiate the adjudication.</p>
<p id="p-0172" num="0186">In one embodiment, the Administrator can configure the action-sets or pipelines for the purpose of adjudication. Configuration can be based on Global level adjudication. Thus, all the Actions, if they are individually configured, and all the Pipelines are adjudicated by the Adjudication Manager. The Administrator can optionally provide an exclude list of the Pipelines or the Actions.</p>
<p id="p-0173" num="0187">Configuration can also be based on Service level adjudication. The Administrator can define the Service level adjudications. In this case, all the Actions of the specified Service if they are individually configured and all the Pipelines of the specified Service is adjudicated by the Adjudication Manager. The Administrator can optionally provide an exclude list of the Pipelines or the Actions for the adjudication.</p>
<p id="p-0174" num="0188">Configuration can also be based on ProcessType level adjudication. The Administrator can define the ProcessType level adjudications. In this case, all the Actions of the specified ProcessType, if they are individually configured, and all the Pipelines of the specified ProcessType are adjudicated by the Adjudication Manager. The Administrator can optionally provide an exclude list of the Pipelines or the Actions for the adjudication.</p>
<p id="p-0175" num="0189">Configuration can also be based on Instance level adjudication. The Administrator can define the instance level adjudications. In this case, all the Actions of the specified instance, if they are individually configured, and all the Pipelines of the specified instance are adjudicated by the Adjudication Manager.</p>
<p id="p-0176" num="0190">Configuration can also be based on Pipeline level adjudication. The Administrator can define a particular Pipeline for adjudication. The configuration can be explicitly called out for this. The Pipeline does not inherit the adjudication configuration from the associated Actions.</p>
<p id="p-0177" num="0191">Configuration can also be based on Action level adjudication. The Administrator can define a particular Action for adjudication. The adjudication configuration on the Action has no effect if the Action is associated in a Pipeline. A warning is issued if it is part of a Pipeline and the Pipeline can be executed with or without adjudication depending on the Pipeline configuration.</p>
<p id="p-0178" num="0192">Some of the above mentioned scopes (Global, Service and ProcessType) have the option of providing an exclude list. When an exclude list is specified, the Adjudication Manager honors the exclude list and filters the Pipelines or the Actions in the exclude list. If the Action in the exclude list is part of a Pipeline, then a warning can be issued and it may not be excluded individually.</p>
<p id="p-0179" num="0193">In one embodiment, the adjudication decisions can be made pluggable and extensible. The Adjudication Manager <b>1406</b> can provide an Adjudication Handler contract so that the Administrator can programmatically register/deregister the Adjudication Handler(s). The Adjudication Handler allows the Administrator to plug-in third-party methods of adjudications. The Adjudication Handler <b>1407</b> can provide an API for adjudicating the given Pipeline and another API for adjudicating the given Action.</p>
<p id="h-0024" num="0000">Interaction Between the Rules Engine and Execution Engine</p>
<p id="p-0180" num="0194">In accordance with an embodiment, service and constraint information can be provided to the RulesEngineService when the Controller is booted. It is also possible to dynamically update this information via the same interface. Once initialized, the RulesEngineService takes input primarily from the Monitor and provides input to the ExecuteEngineService.</p>
<p id="p-0181" num="0195">In one embodiment, the constraints are applied to a piece of observed data that is of a particular type (int, string, date, etc.). In addition to Constraint definitions, the RulesEngineService has APIs to create and deploy services. The deployment state affects whether Constraints are applied for a particular service. One can have separate constraints for the deployed state and the un-deployed state. An example of a constraint for the un-deployed state is one that defines the number of processes allowed to be zero.</p>
<p id="p-0182" num="0196"><figref idref="DRAWINGS">FIG. 15</figref> shows the basic feedback loop that occurs between the Rules Engine, the Monitor and the Execute Engine.</p>
<p id="p-0183" num="0197">In one embodiment, the Execute Engine <b>1503</b> implements the interface ArcEventHandler, the API that the Rules Engine <b>1502</b> calls to pass an ArcEvent to the Execute Engine <b>1503</b>.</p>
<p id="p-0184" num="0198">When the Rules Engine <b>1502</b> sends an event to the Execute Engine <b>1503</b>, the event carries with it information necessary for handling the event. This information varies depending on the scope of the constraint failure that caused the event. For example, a process level event carries the service name and process type; whereas a service level issue carries wider information about the service state.</p>
<p id="p-0185" num="0199">The function of the RulesEngineService is closely dependent on the Monitor <b>1501</b> and Execute Engine <b>1503</b>. The monitor <b>1501</b> pushes ObserverMetrics to the Rules Engine <b>1502</b>. These metrics are matched with ObserverConstraints. If the metric does not satisfy the constraint, an ArcEvent is passed to the Execute Engine <b>1503</b>. The Rules Engine <b>1502</b> can also assert an EventMetric to its working memory indicating that the event was passed to the Execute Engine <b>1503</b> for handling. This EventMetric is provided to the Execute Engine <b>1503</b> along with the ArcEvent.</p>
<p id="p-0186" num="0200">The Execute Engine <b>1503</b> can perform one or more actions when it receives the event. When the Execute Engine <b>1503</b> starts an action, it asserts an ActionMetric to the Rules Engine <b>1502</b>. The state of the ActionMetric can be modified by the Execute Engine <b>1503</b> as the action progresses and can finally be marked as successful or failed. This information may be used in later rules processing.</p>
<p id="p-0187" num="0201">After the Execute Engine <b>1503</b> is finished performing the actions associated with an event, it updates the EventMetric previously asserted by the Rules Engine <b>1502</b> to indicate the success or failure of the event as a whole which again may be used in later rules processing.</p>
<p id="p-0188" num="0202">Depending on the constraints, this cycle can continue on allowing users to set up multi-step responses to the initial constraint failure as well as alternate actions when the initial action fails.</p>
<p id="p-0189" num="0203">In one embodiment, any subsequent events that occur from matching of ActionMetrics and EventMetrics are not sent until the Execute Engine <b>1503</b> returns from the eventOccurred call as the Rules Engine <b>1502</b> serializes calls to eventOccurred.</p>
<p id="p-0190" num="0204">There are different kinds of ArcEvents which may be passed to the Execute Engine <b>1503</b> depending on the nature of the rule that generates the event. These different event types carry different information in them depending on the scope of the event. In one embodiment, the Rules Engine <b>1502</b> does not know what actions are carried out as a result of an event. It only finds out about actions that the Execute Engine <b>1403</b> performs via ActionMetrics.</p>
<p id="h-0025" num="0000">Trigger Service</p>
<p id="p-0191" num="0205">In accordance with an embodiment, the Trigger Service is a service that provides for time based events. The Trigger Service is intended to satisfy the requirement for Time Based Constraints. In one example, this service is built on top of the Open Source job scheduling system known as Quartz. Quartz has a flexible interface that lets you declare trigger points in a number of ways. In one case, the Trigger Service can only expose a small subset of the Quartz declarative capabilities.</p>
<p id="p-0192" num="0206">When a trigger is fired, an action (or job) can be performed. In one embodiment, an action or job includes deploying a service, which is to call RulesEngineService.deployService that lead to a DeploymentEvent being passed to the Execute Engine. In addition, an action or job includes undeploying a service, which is to call RulesEngineService.undeployService that also leads to a DeploymentEvent being passed to the Execute Engine. Also, an action or job includes sending an Event to the Execute Engine allowing one to execute an ArcAction or a Pipeline.</p>
<p id="p-0193" num="0207">In one embodiment, the TriggerService is configured with Trigger Beans. The Trigger Bean defines a name for the trigger and a Job class to run when the trigger is pulled. Sub-classes of Trigger Beans define the time information that controls when the trigger goes off. In one example, trigger points can be defined using CronTriggerBean with a cron string. Other ways can also be used for defining trigger points.</p>
<p id="p-0194" num="0208"><figref idref="DRAWINGS">FIG. 16</figref> shows how the trigger service interacts with the rules engine. For any calendar constraints, the trigger service registers a trigger. As shown in <figref idref="DRAWINGS">FIG. 16</figref>, one embodiment includes a trigger service <b>1601</b> that listens for constraints that are passed to the rules engine <b>1602</b>. The trigger service <b>1601</b> is associated with a job scheduling system such as a Quartz system, while the rules engine <b>1602</b> is associated with a Drools Rules Engine <b>1605</b>.
<ul id="ul0007" list-style="none">
    <li id="ul0007-0001" num="0000">
    <ul id="ul0008" list-style="none">
        <li id="ul0008-0001" num="0209">At step (1) <b>1611</b>, constraints are passed in to the Rules Engine <b>1602</b> from configuration.</li>
        <li id="ul0008-0002" num="0210">At Step (2) <b>1612</b>, the Rules Engine <b>1602</b> can forward calendar constraints to the trigger service <b>1612</b>.</li>
        <li id="ul0008-0003" num="0211">At Step (3) <b>1613</b>, the Rules Engine <b>1602</b> can assert all constraints into working memory of Drools Rules Engine <b>1605</b>.</li>
        <li id="ul0008-0004" num="0212">At Step (4a) <b>1614</b>, the Quartz job scheduling system <b>1604</b> can deploy/undeploy a service, leading to normal Drools activity.</li>
        <li id="ul0008-0005" num="0213">At Step (4b) <b>1624</b>, the Quartz job scheduling system <b>1604</b> can lead to a event which the Rules Engine <b>1602</b> relays to the Execution Engine <b>1603</b>.</li>
        <li id="ul0008-0006" num="0214">At Step (5a) <b>1615</b>, the Rules Engine <b>1602</b> can modify the service state.</li>
        <li id="ul0008-0007" num="0215">At Step (5b) <b>1625</b>, the Rules Engine <b>1602</b> can assert an EventMetric to working memory of Drools Rules Engine <b>1605</b>, when a trigger event occurs.</li>
        <li id="ul0008-0008" num="0216">At Step (6a) <b>1616</b>, as a result of step (3) <b>1613</b>, a QoSEvent can be sent to the Execution Engine <b>1603</b>.</li>
        <li id="ul0008-0009" num="0217">At Step (6b) <b>1626</b>, as a result of step (4a) <b>1614</b>, a DeploymentEvent can be sent to the Execution Engine <b>1503</b>.</li>
        <li id="ul0008-0010" num="0218">At Step (6c) <b>1636</b>, as a result of step (4b) <b>1624</b>, a triggerEvent can be sent to the Execution Engine <b>1603</b>.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0195" num="0219">The present invention may be conveniently implemented using a conventional general purpose or a specialized digital computer or microprocessor programmed according to the teachings of the present disclosure. Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure, as will be apparent to those skilled in the software art.</p>
<p id="p-0196" num="0220">In some embodiments, the present invention includes a computer program product which is a storage medium (media) having instructions stored thereon/in which can be used to program a computer to perform any of the processes of the present invention. The storage medium can include, but is not limited to, any type of disk including floppy disks, optical discs, DVD, CD-ROMs, microdrive, and magneto-optical disks, ROMs, RAMs, EPROMs, EEPROMs, DRAMs, VRAMs, flash memory devices, magnetic or optical cards, nanosystems (including molecular memory ICs), or any type of media or device suitable for storing instructions and/or data.</p>
<p id="p-0197" num="0221">The foregoing description of the present invention has been provided for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations will be apparent to the practitioner skilled in the art. Particularly, it will be evident that while the examples described herein illustrate how the features may be used in a JRockit environment, other application servers, virtual machines, JVMs, computing environments, and software development systems may use and benefit from the invention. The code examples given are presented for purposes of illustration. It will be evident that the techniques described herein may be applied using other code languages, and with different code.</p>
<p id="p-0198" num="0222">The embodiments were chosen and described in order to best explain the principles of the invention and its practical application, thereby enabling others skilled in the art to understand the invention for various embodiments and with various modifications that are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalence.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A system for deploying and managing software services, comprising:
<claim-text>a computing environment that includes a plurality of virtualized and non-virtualized machines, which are organized into resource pools, wherein each of the resource pools includes a collection of virtualized resources;</claim-text>
<claim-text>a plurality of software services, wherein each of the plurality of software services includes one or more software applications which are manageable as a unit and deployable to one of the resource pools;</claim-text>
<claim-text>a plurality of agents, wherein each of the plurality of agents resides on one of the plurality of virtualized and non-virtualized machines, manages software applications and resources on the one of the plurality of virtualized and non-virtualized machines, and exposes the resources to the resource pools for use by the computing environment;</claim-text>
<claim-text>a system controller that communicates with the plurality of agents to determine resources available on the plurality of virtualized and non-virtualized machines and to select a resource pool for deploying a software service, based on one or more of remaining capacity of the resource pool, dependencies of the software service, a service level agreement (SLA) of software services already deployed on the resource pool, and a priority for the software service; and</claim-text>
<claim-text>a rules engine that
<claim-text>compares administrator defined constraints with runtime metrics, wherein an administrator defined constraint is a user defined SLA that is captured a metric or state derived from meta data or other metrics and the runtime metrics are provided to the rules engine by a monitor service, and</claim-text>
<claim-text>generates events when a constraint is violated by a metric of the runtime metrics, each event generated by the rules engine carries with it information necessary to handle the event including the scope of a constraint failure that caused the event.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein:
<claim-text>the rules engine resides in the system controller and provides an Open Services Gateway Initiative (OSGi) service.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein:
<claim-text>the rules engine utilizes a Drools Rules Engine model.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein:
<claim-text>the rules engine is capable performing one of:
<claim-text>determining when action is necessary to satisfy an administrator defined constraint;</claim-text>
<claim-text>determining when deployment or un-deployment action is necessary; and</claim-text>
<claim-text>preparing context necessary for carrying out actions.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein:
<claim-text>the runtime metrics are provided to the rules engine by an execute engine.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>a configuration service that is capable of configuring the rules engine.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>a monitor service that is capable of monitoring the rules engine.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein:
<claim-text>the rules engine is associated with a trigger service that provides time based events.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the constraint is one of:
<claim-text>a service constraint,</claim-text>
<claim-text>a process constraint,</claim-text>
<claim-text>an observer constraint,</claim-text>
<claim-text>an event constraint, and</claim-text>
<claim-text>an action constraint.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein:
<claim-text>the event generated by the rules engine has the same scope as the constraint that is associated with the event.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein:
<claim-text>the rules engine manages a data structure that is a hierarchy of event states.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein:
<claim-text>one of the plurality of agents is a Virtualized Agent.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. A method for deploying and managing software services, comprising the steps of:
<claim-text>providing a computing environment that includes a plurality of virtualized and non-virtualized machines, which are organized into resource pools, wherein each of the resource pools includes a collection of virtualized resources;</claim-text>
<claim-text>providing a plurality of software services, wherein each of the plurality of software services includes one or more software applications which are manageable as a unit and deployable to one of the resource pools;</claim-text>
<claim-text>providing an agent on each of the plurality of virtualized and non-virtualized machines, wherein the agent manages software applications and resources on the each machine, and exposes the resources of the each machine to the resource pools for use by the computing environment;</claim-text>
<claim-text>providing a system controller that communicates with the plurality of agents to determine the resources available on the virtualized and non-virtualized machines and to select a resource pool for deploying a software service, based on one or more of remaining capacity of the resource pool, dependencies of the software service, a service level agreement (SLA) of software services already deployed on the resource pool, and a priority for the software service; and</claim-text>
<claim-text>providing rules engine that
<claim-text>compares administrator defined constraints with runtime metrics, wherein an administrator defined constraint is a user defined SLA that is captured by a metric or state derived from meta data or other metrics and the runtime metrics are provided to the rules engine by a monitor service, and</claim-text>
<claim-text>generates events when a constraint is violated by a metric of the runtime metrics, wherein each event generated by the rules engine carries with it information necessary to handle the event including the scope of a constraint failure that caused the event.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The method according to <claim-ref idref="CLM-00013">claim 13</claim-ref>, further comprising at least one of:
<claim-text>determining when action is necessary to satisfy an administrator defined constraint;</claim-text>
<claim-text>determining when deployment or un-deployment action is necessary; and</claim-text>
<claim-text>preparing context necessary for carrying out actions.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method according to <claim-ref idref="CLM-00013">claim 13</claim-ref>, further comprising:
<claim-text>configuring the rules engine by a configuration service.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The method according to <claim-ref idref="CLM-00013">claim 13</claim-ref>, further comprising:
<claim-text>monitoring the rules engine through a monitor service.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The method according to <claim-ref idref="CLM-00013">claim 13</claim-ref>, further comprising:
<claim-text>associating with a trigger service that provides time based events.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The method according to <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the constraint is one of:
<claim-text>a service constraint,</claim-text>
<claim-text>a process constraint,</claim-text>
<claim-text>an observer constraint,</claim-text>
<claim-text>an event constraint, and</claim-text>
<claim-text>an action constraint.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The method according to <claim-ref idref="CLM-00013">claim 13</claim-ref>, further comprising:
<claim-text>managing a data structure that is a hierarchy of event states.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. A non-transitory machine readable medium having instructions stored thereon that when executed cause a system to perform the steps comprising:
<claim-text>providing a computing environment that includes a plurality of virtualized and non-virtualized machines, which are organized into resource pools, wherein each of the resource pools includes a collection of virtualized resources;</claim-text>
<claim-text>providing a plurality of software services, wherein each of the plurality of software services includes one or more software applications which are manageable as a unit and deployable to one of the resource pools;</claim-text>
<claim-text>providing an agent on each of the plurality of virtualized and non-virtualized machines, wherein the agent manages software applications and resources on the each machine, and exposes the resources of the each machine to the resource pools for use by the computing environment;</claim-text>
<claim-text>providing a system controller that communicates with the plurality of agents to determine the resources available on the virtualized and non-virtualized machines and to select a resource pool for deploying a software service, based on one or more of remaining capacity of the resource pool, dependencies of the software service, a service level agreement (SLA) of software services already deployed on the resource pool, and a priority for the software service; and</claim-text>
<claim-text>providing a rules engine that
<claim-text>compares administrator defined constraints with runtime metrics, wherein an administrator defined constraint is a user defined SLA that is captured by a metric or state derived from meta data or other metrics and the runtime metrics are provided to the rules engine by a monitor service, and</claim-text>
<claim-text>generates events when a constraint is violated by a metric of the runtime metrics, wherein each event generated by the rules engine carries with it information necessary to handle the event including the scope of a constraint failure that caused the event.</claim-text>
</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
