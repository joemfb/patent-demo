<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08626725-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08626725</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12270872</doc-number>
<date>20081114</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>767</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>7</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>00</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>30</subgroup>
<symbol-position>L</symbol-position>
<classification-value>N</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>707693</main-classification>
<further-classification>707736</further-classification>
<further-classification>707758</further-classification>
<further-classification>707764</further-classification>
</classification-national>
<invention-title id="d2e53">Efficient large-scale processing of column based data encoded structures</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5794229</doc-number>
<kind>A</kind>
<name>French et al.</name>
<date>19980800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5870752</doc-number>
<kind>A</kind>
<name>Gibbons et al.</name>
<date>19990200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>  1  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>5918225</doc-number>
<kind>A</kind>
<name>White</name>
<date>19990600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6457009</doc-number>
<kind>B1</kind>
<name>Bollay</name>
<date>20020900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707770</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>6597812</doc-number>
<kind>B1</kind>
<name>Fallon et al.</name>
<date>20030700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>382232</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>6965897</doc-number>
<kind>B1</kind>
<name>Chen</name>
<date>20051100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>7024414</doc-number>
<kind>B2</kind>
<name>Sah</name>
<date>20060400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>7818728</doc-number>
<kind>B1</kind>
<name>Olson</name>
<date>20101000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717140</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2003/0028509</doc-number>
<kind>A1</kind>
<name>Sah et al.</name>
<date>20030200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2004/0135903</doc-number>
<kind>A1</kind>
<name>Brooks et al.</name>
<date>20040700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>34823199</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2007/0143248</doc-number>
<kind>A1</kind>
<name>Uppala</name>
<date>20070600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  2</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2008/0071724</doc-number>
<kind>A1</kind>
<name>Parkinson</name>
<date>20080300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2008/0071818</doc-number>
<kind>A1</kind>
<name>Apanowicz et al.</name>
<date>20080300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707101</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2008/0133562</doc-number>
<kind>A1</kind>
<name>Cheong et al.</name>
<date>20080600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>2009/0132602</doc-number>
<kind>A1</kind>
<name>Brown et al.</name>
<date>20090500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707200</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>2009/0132611</doc-number>
<kind>A1</kind>
<name>Brown et al.</name>
<date>20090500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707203</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>2009/0187586</doc-number>
<kind>A1</kind>
<name>Olson</name>
<date>20090700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707101</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00018">
<document-id>
<country>EP</country>
<doc-number>2040180</doc-number>
<date>20090300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00019">
<othercit>Miguel C. Ferreira, Compression and Query Execution within Column Oriented Databases http://db.lcs.mit.edu/madden/html/theses/ferreira.pdf. Last accessed on Jul. 25, 2008, 66 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00020">
<othercit>Mike Stonebraker, et al. C-Store: A Column-Oriented DBMS http://db.lcs.mit.edu/projects/cstore/vldb.pdf. Last accessed on Jul. 25, 2008, 12 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00021">
<othercit>Daniel J. Abadi, et al. Integrating Compression and Execution in Column Oriented Database Systems http://db.lcs.mit.edu/projects/cstore/abadisigmod06.pdf. Last accessed on Jul. 25, 2008, 12 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00022">
<othercit>Mike Stonebraker, Row Store Compression versus Column Store Compression http://www.dbms2.com/2007/03/24/mike-stonebraker-explains-column-store-data-compression/ Last accessed on Jul. 28, 2008, 9 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00023">
<othercit>Daniel J. Abadi: &#x201c;Query Execution in Column-Oriented Database Systems&#x201d;, Feb. 29, 2008 , XP5503471, http://cs-www.cs.yale.edu/homes/dna/papers/abadiphd/pdf, 30 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00024">
<othercit>Daniel J. Adabi et al: &#x201c;Materialization Strategies in a Column-Oriented DBMS&#x201d;, Data Engineering 2007. ICDE 2007. IEEE 23<sup>rd </sup>Internatioinal Conference on, IEEE, PI, Apr. 1, 2007, pp. 466-475.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00025">
<othercit>Daniel J. Abadi. &#x201c;Query Execution in Column-Oriented Database Systems&#x201d;. Massachusetts Institute of Technology. Feb. 29, 2008.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>21</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>707736</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707758</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707764</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707693</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>29</number-of-drawing-sheets>
<number-of-figures>29</number-of-figures>
</figures>
<us-related-documents>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61085022</doc-number>
<date>20080731</date>
</document-id>
</us-provisional-application>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20100030748</doc-number>
<kind>A1</kind>
<date>20100204</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Netz</last-name>
<first-name>Amir</first-name>
<address>
<city>Bellevue</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Petculescu</last-name>
<first-name>Cristian</first-name>
<address>
<city>Redmond</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Netz</last-name>
<first-name>Amir</first-name>
<address>
<city>Bellevue</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Petculescu</last-name>
<first-name>Cristian</first-name>
<address>
<city>Redmond</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Workman Nydegger</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Microsoft Corporation</orgname>
<role>02</role>
<address>
<city>Redmond</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Mofiz</last-name>
<first-name>Apu</first-name>
<department>2161</department>
</primary-examiner>
<assistant-examiner>
<last-name>Bibbee</last-name>
<first-name>Jared</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">The subject disclosure relates to efficient query processing over large scale data storage. An exemplary process includes retrieving a subset of columns implicated by a query as integer encoded and compressed sequences of values corresponding to different columns of data, defining query processing buckets that span over the subset of columns based on changes of compression type occurring in the integer encoded and compressed sequences of values of the subset of data and processing the query in memory on a bucket by bucket basis and processing the query based on type of current bucket when processing the integer encoded and compressed sequences of values. The column based organization of the data, and the application of a hybrid run length encoding and bit packing technique, enable a highly efficient and speedy query response in real-time.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="147.66mm" wi="230.38mm" file="US08626725-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="232.92mm" wi="158.75mm" orientation="landscape" file="US08626725-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="235.80mm" wi="166.79mm" file="US08626725-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="209.04mm" wi="149.52mm" file="US08626725-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="200.24mm" wi="189.99mm" file="US08626725-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="208.79mm" wi="174.84mm" orientation="landscape" file="US08626725-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="267.46mm" wi="186.86mm" file="US08626725-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="206.93mm" wi="168.23mm" orientation="landscape" file="US08626725-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="154.18mm" wi="156.38mm" orientation="landscape" file="US08626725-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="222.67mm" wi="158.75mm" file="US08626725-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="213.61mm" wi="172.72mm" orientation="landscape" file="US08626725-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="173.40mm" wi="158.75mm" orientation="landscape" file="US08626725-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="267.80mm" wi="162.90mm" file="US08626725-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="249.94mm" wi="169.50mm" orientation="landscape" file="US08626725-20140107-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="255.52mm" wi="167.22mm" orientation="landscape" file="US08626725-20140107-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="192.11mm" wi="157.65mm" orientation="landscape" file="US08626725-20140107-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00016" num="00016">
<img id="EMI-D00016" he="194.99mm" wi="158.75mm" orientation="landscape" file="US08626725-20140107-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00017" num="00017">
<img id="EMI-D00017" he="234.95mm" wi="134.28mm" orientation="landscape" file="US08626725-20140107-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00018" num="00018">
<img id="EMI-D00018" he="245.70mm" wi="172.38mm" orientation="landscape" file="US08626725-20140107-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00019" num="00019">
<img id="EMI-D00019" he="258.23mm" wi="186.01mm" orientation="landscape" file="US08626725-20140107-D00019.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00020" num="00020">
<img id="EMI-D00020" he="257.98mm" wi="176.70mm" orientation="landscape" file="US08626725-20140107-D00020.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00021" num="00021">
<img id="EMI-D00021" he="231.90mm" wi="175.60mm" orientation="landscape" file="US08626725-20140107-D00021.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00022" num="00022">
<img id="EMI-D00022" he="181.44mm" wi="156.97mm" orientation="landscape" file="US08626725-20140107-D00022.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00023" num="00023">
<img id="EMI-D00023" he="245.62mm" wi="160.10mm" orientation="landscape" file="US08626725-20140107-D00023.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00024" num="00024">
<img id="EMI-D00024" he="252.14mm" wi="176.95mm" orientation="landscape" file="US08626725-20140107-D00024.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00025" num="00025">
<img id="EMI-D00025" he="218.86mm" wi="166.79mm" file="US08626725-20140107-D00025.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00026" num="00026">
<img id="EMI-D00026" he="225.89mm" wi="157.31mm" file="US08626725-20140107-D00026.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00027" num="00027">
<img id="EMI-D00027" he="196.68mm" wi="147.07mm" file="US08626725-20140107-D00027.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00028" num="00028">
<img id="EMI-D00028" he="215.31mm" wi="162.81mm" file="US08626725-20140107-D00028.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00029" num="00029">
<img id="EMI-D00029" he="220.64mm" wi="159.09mm" orientation="landscape" file="US08626725-20140107-D00029.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">PRIORITY CLAIM</heading>
<p id="p-0002" num="0001">The present application claims priority to U.S. Provisional Application No. 61/085,022, filed Jul. 31, 2008, entitled &#x201c;EFFICIENT LARGE-SCALE PROCESSING OF COLUMN BASED DATA ENCODED STRUCTURES&#x201d;, the entirety of which is incorporated herein by reference.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">TECHNICAL FIELD</heading>
<p id="p-0003" num="0002">The subject disclosure generally relates to efficient column based encoding of data for reducing the size of large-scale amounts of data and increasing the speed of processing or querying the data.</p>
<heading id="h-0003" level="1">BACKGROUND</heading>
<p id="p-0004" num="0003">By way of background concerning conventional compression, when a large amount of data is stored in a database, such as when a server computer collects large numbers of records, or transactions, of data over long periods of time, other computers sometimes desire access to that data or a targeted subset of that data. In such case, the other computers can query for the desired data via one or more query operators. In this regard, historically, relational databases have evolved for this purpose, and have been used for such large scale data collection, and various query languages have developed which instruct database management software to retrieve data from a relational database, or a set of distributed databases, on behalf of a querying client.</p>
<p id="p-0005" num="0004">Traditionally, relational databases have been organized according to rows, which correspond to records, having fields. For instance, a first row might include a variety of information for its fields corresponding to columns (name1, age1, address1, sex1, etc.), which define the record of the first row and a second row might include a variety of different information for fields of the second row (name2, age2, address2, sex2, etc.). However, traditionally, querying over enormous amounts of data, or retrieving enormous amounts of data for local querying or local business intelligence by a client have been limited in that they have not been able to meet real-time or near real-time requirements. Particularly in the case in which the client wishes to have a local copy of up-to-date data from the server, the transfer of such large scale amounts of data from the server given limited network bandwidth and limited client cache storage has been impractical to date for many applications.</p>
<p id="p-0006" num="0005">For instance, currently, scanning and aggregating 600 million rows of data having approximately 160 bytes of data each (about 100 Gigabytes of data), using two &#x201c;group by&#x201d; operations and four aggregate operations as a sample query, the fastest known relational database management system (RDBMS), as measured by industry standard TPC-H metrics, can deliver and process the data in about 39.9 seconds. This represents delivery at an approximate bit rate of 2.5 Gb/sec, or about 15 million rows/sec. However, today's state of the art system runs almost $200,000 from a cost standpoint, a high barrier to entry for most users. Moreover, 39.9 seconds, while fast, does not begin to meet the tightest of real-time demands and requirements, and otherwise leaves much room for improvement.</p>
<p id="p-0007" num="0006">By way of further background, due to the convenience of conceptualizing differing rows as differing records with relational databases as part of the architecture, techniques for reducing data set size have thus far focused on the rows due to the nature of how relational databases are organized. In other words, the row information preserves each record by keeping all of the fields of the record together on one row, and traditional techniques for reducing the size of the aggregate data have kept the fields together as part of the encoding itself.</p>
<p id="p-0008" num="0007">Run-length encoding (RLE) is a conventional form of data compression in which runs of data, that is, sequences in which the same data value occurs in many consecutive data elements, are stored as a single data value and count, rather than as the original run. In effect, instead of listing &#x201c;EEEEEE&#x201d; as an entry, a run length of &#x201c;6 Es&#x201d; is defined for the slew of Es. RLE is useful on data that contains many such runs, for example, relatively simple graphic images such as icons, line drawings, and animations. However, where data tends to be unique from value to value, or pixel to pixel, etc., or otherwise nearly unique everywhere, RLE is known to be less efficient. Thus, sometimes RLE, by itself, does not lend itself to efficient data reduction, wasting valuable processing time for little to no gain.</p>
<p id="p-0009" num="0008">Another type of compression that has been applied to data includes dictionary encoding, which operates by tokenizing field data values to a reduced bit set, such as sequential integers, in a compacted representation via a dictionary used alongside of the resulting data to obtain the original field data values from the compacted representation.</p>
<p id="p-0010" num="0009">Another type of compression that has been applied to data includes value encoding, which converts real numbers into integers by performing some transformation over the data enabling a more compact representation, e.g., applying an invertible mathematical function over the data, which reduces the number of bits needed to represent the data. For instance, real numbers, such as float values, take up more space in memory than integer values, and thus invertibly converting float values to integer values reduces storage size and then a processor that uses the data can derive the float values when needed.</p>
<p id="p-0011" num="0010">Still another type of compression that has been applied to data includes bit packing, which counts the number of distinct values of data or determines the range over which the different values span, and then represents that set of numbers or values with the minimum number of bits as determined by an optimization function. For instance, perhaps the each field of a given column spans only a limited range, and thus instead of representing each value with, e.g., 10 bits as originally defined for the field, it may turn out that only 6 bits are needed to represent the values. Bit packing re-stores the values according to the more efficient 6 bit representation of the data.</p>
<p id="p-0012" num="0011">Each of these conventional compression techniques has been independently applied to the row-organized information of relational databases, e.g., via rowset operators, yet, each of these techniques suffers disadvantages in that none adequately address the problem of satisfying the delivery of huge amounts of data from a database quickly to a consuming client, which may have real-time requirements, for up-to-date data. Mainly, the conventional methodologies have focused on reducing the size of data stored to maximize the amount of data that can be stored for a given disk size or storage limit.</p>
<p id="p-0013" num="0012">However, these techniques on their own can actually end up increasing the amount of processing time over the data according to a scan or query of the data due to data intensive decoding or the monolithic size of the compressed storage structures that must be transmitted to complete the inquiry. For instance, with many conventional compression techniques, the longer it takes to compress the data, the greater the savings that are achieved with respect to size; however, on the other hand, the longer it takes to compress the data with such conventional compression schemes, the longer it takes to decompress and process as a result. Accordingly, conventional systems fail to provide a data encoding technique that not only compresses data, but compresses the data in a way that makes querying, searching and scanning of the data faster.</p>
<p id="p-0014" num="0013">In addition, limitations in network transmission bandwidth inherently limit how quickly compressed data can be received by the client, placing a bottleneck on the request for massive amounts of data. It would thus be desirable to provide a solution that achieves simultaneous gains in data size reduction and query processing speed. It would be further desirable to provide an improved data encoding technique that enables highly efficient compression and processing in a query based system for large amounts of data.</p>
<p id="p-0015" num="0014">The above-described deficiencies of today's relational databases and corresponding compression techniques are merely intended to provide an overview of some of the problems of conventional systems, and are not intended to be exhaustive. Other problems with conventional systems and corresponding benefits of the various non-limiting embodiments described herein may become further apparent upon review of the following description.</p>
<heading id="h-0004" level="1">SUMMARY</heading>
<p id="p-0016" num="0015">A simplified summary is provided herein to help enable a basic or general understanding of various aspects of exemplary, non-limiting embodiments that follow in the more detailed description and the accompanying drawings. This summary is not intended, however, as an extensive or exhaustive overview. Instead, the sole purpose of this summary is to present some concepts related to some exemplary non-limiting embodiments in a simplified form as a prelude to the more detailed description of the various embodiments that follow.</p>
<p id="p-0017" num="0016">Embodiments of processing of column based data encoded structures are described. Various non-limiting embodiments enable efficient query processing over large scale data storage. A subset of columns implicated by a query are received as integer encoded and compressed sequences of values corresponding to different columns of data. Query processing buckets are defined that span over the subset of columns based on transitions of compression type occurring in the integer encoded and compressed sequences of values of the subset of data. The query is then processed in memory on a bucket by bucket basis and based on type of current bucket, e.g., pure bucket, single impurity bucket, double impurity bucket, etc., as defined in greater detail below.</p>
<p id="p-0018" num="0017">The column based organization of the data, and the application of a hybrid run length encoding and bit packing technique, enable a highly efficient and speedy query response in real-time. Synergy of the hybrid data reduction techniques in concert with the column-based organization, coupled with gains in scanning and querying efficiency owing to the column based compact representation, results in substantially improved data compression at a fraction of the cost of conventional systems, e.g., a factor of 400 times faster at less than 1/10 the cost of the fastest known conventional system.</p>
<p id="p-0019" num="0018">These and other embodiments are described in more detail below.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0020" num="0019">Various non-limiting embodiments are further described with reference to the accompanying drawings in which:</p>
<p id="p-0021" num="0020">Various non-limiting embodiments are further described with reference to the accompanying drawings in which:</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 1</figref> is a general block diagram illustrating a column based encoding technique and in memory client side processing of queries over the encoded data;</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram illustrating an exemplary non-limiting implementation of encoding apparatus employing column based encoding techniques;</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 3</figref> is a flow diagram illustrating an exemplary non-limiting process for applying column based encoding to large scale data;</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 4</figref> is an illustration of column based representation of raw data in which records are broken into their respective fields and the fields of the same type are then serialized to form a vector;</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 5</figref> is a non-limiting block diagram exemplifying columnization of record data;</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 6</figref> illustrates that the work of in memory client-side processing of the column data received in connection with a query can be split among multiple cores so as to share the burden of processing large numbers of rows across the column organization;</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 7</figref> is a non-limiting block diagram illustrating the concept of dictionary encoding;</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 8</figref> is a non-limiting block diagram illustrating the concept of value encoding;</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 9</figref> is a non-limiting block diagram illustrating the concept of bit packing applied in one aspect of a hybrid compression technique;</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 10</figref> is a non-limiting block diagram illustrating the concept of run length encoding applied in another aspect of a hybrid compression technique;</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 11</figref> is a block diagram illustrating an exemplary non-limiting implementation of encoding apparatus employing column based encoding techniques;</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 12</figref> is a flow diagram illustrating an exemplary non-limiting process for applying column based encoding to large scale data in accordance with an implementation;</p>
<p id="p-0034" num="0033"><figref idref="DRAWINGS">FIGS. 13-14</figref> are exemplary illustrations of ways to perform a greedy run length encoding compression algorithm, including the optional application of a threshold savings algorithm for applying an alternative compression technique;</p>
<p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. 15</figref> is a block diagram further illustrating a greedy run length encoding compression algorithm;</p>
<p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. 16</figref> is a block diagram illustrating a hybrid run length encoding and bit packing compression algorithm;</p>
<p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. 17</figref> is a flow diagram illustrating the application of a hybrid compression technique that adaptively provides different types of compression based on a total bit savings analysis;</p>
<p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. 18</figref> block diagram illustrating the sample performance of the column based encoding to reduce an overall size of data in accordance with various embodiments of the subject disclosure;</p>
<p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. 19</figref> illustrates a bucketization process that can be applied to column based encoded data with respect to transitions between pure and impure areas, and vice versa;</p>
<p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. 20</figref> illustrates impurity levels with respect to bucketization of the columns in accordance with an embodiment;</p>
<p id="p-0041" num="0040"><figref idref="DRAWINGS">FIG. 21</figref> illustrates the efficient division of query/scan operators into sub-operators corresponding to the different types of buckets present in the columns relevant to the current query/scan;</p>
<p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. 22</figref> illustrates the power of column based encoding where resulting pure buckets represent more than 50% of the rows of the data;</p>
<p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. 23</figref> illustrates exemplary non-limiting query building blocks for query languages for specifying queries over data in a standardized manner;</p>
<p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. 24</figref> illustrates representative processing of a sample query requested by a consuming client device over large scale data available via a network;</p>
<p id="p-0045" num="0044"><figref idref="DRAWINGS">FIG. 25</figref> is a flow diagram illustrating a process for encoding data according to columns according to a variety of embodiments;</p>
<p id="p-0046" num="0045"><figref idref="DRAWINGS">FIG. 26</figref> is a flow diagram illustrating a process for bit packing integer sequences according to one or more embodiments;</p>
<p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. 27</figref> is a flow diagram illustrating a process for querying over the column based representations of data;</p>
<p id="p-0048" num="0047"><figref idref="DRAWINGS">FIG. 28</figref> is a block diagram representing exemplary non-limiting networked environments in which various embodiments described herein can be implemented; and</p>
<p id="p-0049" num="0048"><figref idref="DRAWINGS">FIG. 29</figref> is a block diagram representing an exemplary non-limiting computing system or operating environment in which one or more aspects of various embodiments described herein can be implemented.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0006" level="1">DETAILED DESCRIPTION</heading>
<heading id="h-0007" level="1">Overview</heading>
<p id="p-0050" num="0049">As discussed in the background, among other things, conventional systems do not adequately handle the problem of reading tremendous amounts of data from a server, or other data store in &#x201c;the cloud,&#x201d; in memory very fast due to limits on current compression techniques, limits on transmission bandwidth over networks and limits on local cache memory. For instance, reading the equivalent of 1.5 Terabytes of data per second would be a tremendous feat, and is cost prohibitive today, with the leading expensive conventional solution operating at a fraction of that speed (&#x2dc;2.5 Gb/sec).</p>
<p id="p-0051" num="0050">Accordingly, in various non-limiting embodiments, a column oriented encoding technique is applied to large amounts of data to compact the data and simultaneously organize the data to make later scan/search/query operations over the data substantially more efficient. As a roadmap for what follows, an overview of various embodiments is first described and then exemplary, non-limiting optional implementations are discussed in more detail for supplemental context and understanding. First, the column based encoding techniques for packing large amounts of data are described including an exemplary embodiment that adaptively trades off the performance benefits of run length encoding and bit packing via a hybrid compression technique.</p>
<p id="p-0052" num="0051">In an exemplary non-limiting embodiment, after columnizing raw data to a set of value sequences, one for each column (e.g., serializing the fields of the columns of data, e.g., all Last Names as one sequence, or all PO Order #s as another sequence, etc.), the data is &#x201c;integerized&#x201d; to form integer sequences for each column that are uniformly represented according to dictionary encoding, value encoding, or both dictionary and value encoding, in either order. This integerization stage results in uniformly represented column vectors, and can achieve significant savings by itself, particularly where long fields are recorded in the data, such as text strings. Next, examining all of the columns, a compression stage iteratively applies run length encoding to the run of any of the columns that will lead to the highest amount of overall size savings on the overall set of column vectors.</p>
<p id="p-0053" num="0052">As mentioned, the packing technique is column based, not only providing superior compression, but also the compression technique itself aids in processing the data quickly once the compacted integer column vectors are delivered to the client side.</p>
<p id="p-0054" num="0053">In various non-limiting embodiments, as shown in <figref idref="DRAWINGS">FIG. 1</figref>, a column based encoder/compressor <b>110</b> is provided for compacting large scale data storage <b>100</b> and for making resulting scan/search/query operations over the data substantially more efficient as well. In response to a query by a data consuming device <b>120</b> in data processing zone C, compressor <b>110</b> transmits the compressed columns that are pertinent to the query over transmission network(s) <b>115</b> of data transmission zone B. The data is delivered to in memory storage <b>130</b>, and thus decompression of the pertinent columns can be performed very fast by decoder and query processor <b>140</b> in data processing zone C. In this regard, a bucket walking is applied to the rows represented by the decompressed columns pertinent to the query for additional layers of efficient processing. Similarity of rows is exploited during bucket walking such that repetitive acts are performed together. As described in more detail below, when the technique is applied to real world sample data, such as large quantities of web traffic data or transaction data, with a standard, or commodity server having 196 Gb RAM, query/scan of server data is achieved at approximately 1.5 Terabytes of data per second, an astronomical leap over the capabilities of conventional systems, and at substantially reduced hardware costs.</p>
<p id="p-0055" num="0054">While the particular type of data that can be compressed is by no means limited to any particular type of data and the number of scenarios that depend upon large scale scan of enormous amounts of data are similarly limitless, the commercial significance of applying these techniques to business data or records in real-time business intelligence applications cannot be doubted. Real-time reporting and trend identification is taken to a whole new level by the exorbitant gains in query processing speed achieved by the compression techniques.</p>
<p id="h-0008" num="0000">Column Based Data Encoding</p>
<p id="p-0056" num="0055">As mentioned in the overview, column oriented encoding and compression can be applied to large amounts of data in various embodiments to compact and simultaneously organize the data to make later scan/search/query operations over the data substantially more efficient. In various embodiments, to begin the encoding and compression, the raw data is initially re-organized as columnized streams of data.</p>
<p id="p-0057" num="0056">One embodiment of an encoder is generally shown in <figref idref="DRAWINGS">FIG. 2</figref> in which raw data is received, or read from storage at <b>200</b> at which point encoding apparatus and/or encoding software <b>250</b> organizes the data as columns at <b>210</b>. At <b>220</b>, the column streams are transformed to a uniform vector representation. For instance, integer encoding can be applied to map individual entries like names or places to integers. Such integer encoding technique can be a dictionary encoding technique, which can reduce the data by a factor of 2&#xd7;-10&#xd7;. In addition, or alternatively, a value encoding can further provide a 1&#xd7;-2&#xd7; reduction in size. This leaves a vector of integers for each column at <b>220</b>. Such performance increases are sensitive to the data being compacted, and thus such size reduction ranges are given merely as non-limiting estimates to give a general idea of relative performance of the different steps.</p>
<p id="p-0058" num="0057">Then, at <b>230</b>, the encoded uniform column vectors can be compacted further. In one embodiment, a run length encoding technique is applied that determines the most frequent value or occurrence of a value across all the columns, in which case a run length is defined for that value, and the process is iterative up to a point where benefits of run length encoding are marginal, e.g., for recurring integer values having at least 64 occurrences in the column.</p>
<p id="p-0059" num="0058">In another embodiment, the bit savings from applying run length encoding are examined, and at each step of the iterative process, the column of the columns is selected that achieves the maximum bit savings through application of re-ordering and definition of a run length. In other words, since the goal is to represent the columns with as few bits as possible, at each step, the bit savings are maximized at the column providing the greatest savings. In this regard, run length encoding can provide significant compression improvement, e.g., 100&#xd7; more, by itself.</p>
<p id="p-0060" num="0059">In another embodiment, a hybrid compression technique is applied at <b>230</b> that employs a combination of bit packing and run length encoding. A compression analysis is applied that examines potential savings of the two techniques, and where, for instance, run length encoding is deemed to result in insufficient net bit savings, bit packing is applied to the remaining values of a column vector. Thus, once run length savings are determined to be minimal according to one or more criteria, the algorithm switches to bit packing for the remaining relatively unique values of the column. For instance, where the values represented in a column become relatively unique (where the non-unique or repetitive values are already run length encoded), instead of run length encoding, bit packing can be applied for those values. At <b>240</b>, the output is a set of compressed column sequences corresponding to the column values as encoded and compressed according to the above-described technique.</p>
<p id="p-0061" num="0060"><figref idref="DRAWINGS">FIG. 3</figref> generally describes the above methodology according to a flow diagram beginning with the input of raw data <b>300</b>. At <b>310</b>, as mentioned, the data is reorganized according to the columns of the raw data <b>300</b>, as opposed to keeping each field of a record together like conventional systems. For instance, as shown in <figref idref="DRAWINGS">FIG. 4</figref>, each column forms an independent sequence, such as sequences C<b>401</b>, C<b>402</b>, C<b>403</b>, C<b>404</b>, C<b>405</b>, C<b>406</b>. Where retail transaction data is the data, for example, column C<b>401</b> might be a string of product prices, column C<b>402</b> might represent a string of purchase dates, column C<b>403</b> might represent a store location, and so on. The column based organization maintains inherent similarity within a data type considering that most real world data collected by computer systems is not very diverse in terms of the values represented. At <b>320</b>, the column based data undergoes one or more conversions to form uniformly represented column based data sequences. In one embodiment, step <b>320</b> reduces each column to integer sequences of data via dictionary encoding and/or value encoding.</p>
<p id="p-0062" num="0061">At <b>330</b>, the column based sequences are compressed with a run length encoding process, and optionally bit packing. In one embodiment, the run-length encoding process re-orders the column data value sequences of the column of all of the columns which achieves the highest compression savings. Thus, the column where run length encoding achieves the highest savings, is re-ordered to group the common values being replaced by run length encoding, and then a run length is defined for the re-ordered group. In one embodiment, the run length encoding algorithm is applied iteratively across the columns, examining each of the columns at each step to determine the column that will achieve the highest compression savings.</p>
<p id="p-0063" num="0062">When the benefit of applying run length encoding becomes marginal or minimal according to one or more criterion, such as insufficient bit savings, or savings are less than a threshold, then the benefits of its application correspondingly go down. As a result, the algorithm can stop, or for the remaining values not encoded by run length encoding in each column, bit packing can be applied to further reduce the storage requirements for those values. In combination, the hybrid run length encoding and bit packing technique can be powerful to reduce a column sequence, particularly those with a finite or limited number of values represented in the sequence.</p>
<p id="p-0064" num="0063">For instance, the field &#x201c;sex&#x201d; has only two field values: male and female. With run length encoding, such field could be represented quite simply, as long as the data is encoded according to the column based representation of raw data as described above. This is because the row focused conventional techniques described in the background, in effect, by keeping the fields of each record together, break up the commonality of the column data. &#x201c;Male&#x201d; next to an age value such as &#x201c;21&#x201d; does not compress as well as a &#x201c;male&#x201d; value next to only &#x201c;male&#x201d; or &#x201c;female&#x201d; values. Thus, the column based organization of data enables efficient compression and the result of the process is a set of distinct, uniformly represented and compacted column based sequences of data <b>340</b>.</p>
<p id="p-0065" num="0064"><figref idref="DRAWINGS">FIG. 5</figref> gives an example of the columnization process based on actual data. The example of <figref idref="DRAWINGS">FIG. 5</figref> is for 4 data records <b>500</b>, <b>501</b>, <b>502</b> and <b>503</b>, however, this is for simplicity of illustration since the invention can apply to terabytes of data. Generally speaking, when transaction data is recorded by computer systems, it is recorded record-by-record and generally in time order of receiving the records. Thus, the data in effect has rows, which correspond to each record.</p>
<p id="p-0066" num="0065">In <figref idref="DRAWINGS">FIG. 5</figref>, record <b>500</b> has name field <b>510</b> with value &#x201c;Jon&#x201d; <b>511</b>, phone field <b>520</b> with value &#x201c;555-1212&#x201d; <b>521</b>, email field <b>530</b> with value &#x201c;jon@go&#x201d; <b>531</b>, address field <b>540</b> with value &#x201c;2 1<sup>st </sup>St&#x201d; <b>541</b> and state field <b>550</b> with value &#x201c;Wash&#x201d; <b>551</b>.</p>
<p id="p-0067" num="0066">Record <b>501</b> has name field <b>510</b> with value &#x201c;Amy&#x201d; <b>512</b>, phone field <b>520</b> with value &#x201c;123-4567&#x201d; <b>522</b>, email field <b>530</b> with value &#x201c;Amy@wo&#x201d; <b>532</b>, address field <b>540</b> with value &#x201c;1 2<sup>nd </sup>Pl&#x201d; <b>542</b> and state field <b>550</b> with value &#x201c;Mont&#x201d; <b>552</b>.</p>
<p id="p-0068" num="0067">Record <b>502</b> has name field <b>510</b> with value &#x201c;Jimmy&#x201d; <b>513</b>, phone field <b>520</b> with value &#x201c;765-4321&#x201d; <b>523</b>, email field <b>530</b> with value &#x201c;Jim@so&#x201d; <b>533</b>, address field <b>540</b> with value &#x201c;9 Fly Rd&#x201d; <b>543</b> and state field <b>550</b> with value &#x201c;Oreg&#x201d; <b>553</b>.</p>
<p id="p-0069" num="0068">Record <b>503</b> has name field <b>510</b> with value &#x201c;Kim&#x201d; <b>514</b>, phone field <b>520</b> with value &#x201c;987-6543&#x201d; <b>524</b>, email field <b>530</b> with value &#x201c;Kim@to&#x201d; <b>534</b>, address field <b>540</b> with value &#x201c;91 Y St&#x201d; <b>544</b> and state field <b>550</b> with value &#x201c;Miss&#x201d; <b>554</b>.</p>
<p id="p-0070" num="0069">When row representation <b>560</b> is columnized to reorganized column representation <b>570</b>, instead of having four records each having five fields, five columns are formed corresponding to the fields.</p>
<p id="p-0071" num="0070">Thus, column <b>1</b> corresponds to the name field <b>510</b> with value &#x201c;Jon&#x201d; <b>511</b>, followed by value &#x201c;Amy&#x201d; <b>512</b>, followed by value &#x201c;Jimmy&#x201d; <b>513</b>, followed by value &#x201c;Kim&#x201d; <b>514</b>. Similarly, column <b>2</b> corresponds to the phone field <b>520</b> with value &#x201c;555-1212&#x201d; <b>521</b>, followed by value &#x201c;123-4567&#x201d; <b>522</b>, followed by value &#x201c;765-4321&#x201d; <b>523</b>, followed by value &#x201c;987-6543&#x201d; <b>524</b>. Column <b>3</b> corresponds to the email field <b>530</b> with value &#x201c;jon@go&#x201d; <b>531</b>, followed by value &#x201c;Amy@wo&#x201d; <b>532</b>, followed by value &#x201c;Jim@so&#x201d; <b>533</b>, followed by value &#x201c;Kim@to&#x201d; <b>534</b>. In turn, column <b>4</b> corresponds to the address field <b>540</b> with value &#x201c;2 1<sup>st </sup>St&#x201d; <b>541</b>, followed by value &#x201c;1 2<sup>nd </sup>Pl&#x201d; <b>542</b>, followed by value &#x201c;9 Fly Rd&#x201d; <b>543</b>, followed by value &#x201c;91 Y St&#x201d; <b>544</b>. And column <b>5</b> corresponds to the state field <b>550</b> with value &#x201c;Wash&#x201d; <b>551</b>, followed by value &#x201c;Mont&#x201d; <b>552</b>, followed by value &#x201c;Oreg&#x201d; <b>553</b>, followed by value &#x201c;Miss&#x201d; <b>554</b>.</p>
<p id="p-0072" num="0071">In one embodiment, when compressed columns according to the above-described technique are loaded in memory on a consuming client system, the data is segmented across each of the columns C1, C2, C3, C4, C5, C6 to form segments <b>600</b>, <b>602</b>, <b>604</b>, <b>606</b>, etc. In this regard, since each segment can include 100s of millions of rows or more, parallelization improves the speed of processing or scanning the data, e.g., according to a query. The results of each segment are aggregated to form a complete set of results while each segment is processed separately.</p>
<p id="p-0073" num="0072"><figref idref="DRAWINGS">FIG. 7</figref> is a block diagram illustrative of a non-limiting example of dictionary encoding, as employed by embodiments described herein. A typical column <b>700</b> of cities may include values &#x201c;Seattle,&#x201d; &#x201c;Los Angeles,&#x201d; &#x201c;Redmond&#x201d; and so on, and such values may repeat themselves over and over. With dictionary encoding, an encoded column <b>710</b> includes a symbol for each distinct value, such as a unique integer per value. Thus, instead of representing the text &#x201c;Seattle&#x201d; many times, the integer &#x201c;1&#x201d; is stored, which is much more compact. The values that repeat themselves more often can be enumerated with mappings to the most compact representations (fewest bits, fewest changes in bits, etc.). The value &#x201c;Seattle&#x201d; is still included in the encoding as part of a dictionary <b>720</b>, but &#x201c;Seattle&#x201d; need only be represented once instead of many times. The extra storage implicated by the dictionary <b>720</b> is far outweighed by the storage savings of encoded column <b>710</b>.</p>
<p id="p-0074" num="0073"><figref idref="DRAWINGS">FIG. 8</figref> is a block diagram illustrative of a non-limiting example of value encoding, as employed by embodiments described herein. A column <b>800</b> represents sales amounts and includes a typical dollars and cents representation including a decimal, which implicates float storage. To make the storage more compact, a column <b>810</b> encoded with value encoding may have applied to it a factor of 10, e.g., 10<sup>2</sup>, in order to represent the values with integers instead of float values, with integers requiring fewer bits to store. The transformation can similarly be applied in reduce the number of integers representing a value. For instance, values consistently ending in the millions for a column, such as 2,000,000, 185,000,000, etc. can all be divided by 10<sup>6 </sup>to reduce the values to more compact representations <b>2</b>, <b>185</b>, etc.</p>
<p id="p-0075" num="0074"><figref idref="DRAWINGS">FIG. 9</figref> is a block diagram illustrative of a non-limiting example of bit packing, as employed by embodiments described herein. A column <b>900</b> represents order quantities as integerized by dictionary and/or value encoding, however, 32 bits per row are reserved to represent the values. Bit packing endeavors to use the minimum number of bits for the values in the segment. In this example, 10 bits/row can be used to represent the values 590, 110, 680 and 320, representing a substantial savings for the first layer of bit packing applied to form column <b>910</b>.</p>
<p id="p-0076" num="0075">Bit packing can also remove common powers of 10 (or other number) to form a second packed column <b>920</b>. Thus, if the values end in 0 as in the example, that means that the 3 bits/row used to represent the order quantities are not needed reducing the storage structure to 7 bits/row. Similar to the dictionary encoding, any increased storage due to the metadata needed to restore the data to column <b>900</b>, such as what power of 10 was used, is vastly outweighed by the bit savings.</p>
<p id="p-0077" num="0076">As another layer of bit packing to form third packed column <b>930</b>, it can be recognized that it takes 7 bits/row to represent a value like <b>68</b>, but since the lowest value is 11, the range can be shifted by 11 (subtract each value by 11), and then the highest number is 68&#x2212;11=57, which can be represented with just 6 bits/row since 2<sup>6</sup>=64 value possibilities. While <figref idref="DRAWINGS">FIG. 9</figref> represents a particular order of packing layers, the layers can be performed in different orders, or alternatively, the packing layers can be selectively removed or supplemented with other known bit packing techniques.</p>
<p id="p-0078" num="0077"><figref idref="DRAWINGS">FIG. 10</figref> is a block diagram illustrative of a non-limiting example of run length encoding, as employed by embodiments described herein. As illustrated, a column such as column <b>1000</b> representing order types can be encoded effectively with run length encoding due to the repetition of values. A column value runs table <b>1010</b> maps order type to a run length for the order type. While slight variations on the representation of the metadata of table <b>1010</b> are permitted, the basic idea is that run length encoding can give compression of &#xd7;50 for a run length of 100, which is superior to the gains bit packing can generally provide for the same data set.</p>
<p id="p-0079" num="0078"><figref idref="DRAWINGS">FIG. 11</figref> is a general block diagram of an embodiment provided herein in which the techniques of <figref idref="DRAWINGS">FIGS. 7-10</figref> are synthesized into various embodiments of a unified encoding and compression scheme. Raw data <b>1100</b> is organized as column streams according to column organization <b>1110</b>. Dictionary encoding <b>1120</b> and/or value encoding <b>1130</b> provide respective size reductions as described above. Then, in a hybrid RLE and bit packing stage, a compression analysis <b>1140</b> examines potential bit savings across the columns when determining whether to apply run length encoding <b>1150</b> or bit packing <b>1160</b>.</p>
<p id="p-0080" num="0079"><figref idref="DRAWINGS">FIG. 11</figref> is expanded upon in the flow diagram of <figref idref="DRAWINGS">FIG. 12</figref>. At <b>1200</b>, raw data is received according to an inherent row representation. At <b>1210</b>, the data is re-organized as columns. At <b>1220</b>, dictionary and/or value encoding are applied to reduce the data a first time. At <b>1230</b>, a hybrid RLE and bit packing technique, as described above, can be applied. At <b>1240</b>, the compressed and encoded column based sequence of data are stored. Then, when a client queries for all or a subset of the compressed encoded column based sequences of data, the affected columns are transmitted to the requesting client at <b>1250</b>.</p>
<p id="p-0081" num="0080"><figref idref="DRAWINGS">FIG. 13</figref> is a block diagram of an exemplary way to perform the compression analysis of the hybrid compression technique. For instance, a histogram <b>1310</b> is computed from column <b>1300</b>, which represents the frequency of occurrences of values, or the frequency of occurrences of individual run lengths. Optionally, a threshold <b>1312</b> can be set so that run length encoding does not apply for reoccurrences of a value that are small in number where run length gains may be minimal. Alternatively, or in addition, a bit savings histogram <b>1320</b> represents not only frequency of occurrences of values, but also the total bit savings that would be achieved by applying one or the other of the compression techniques of the hybrid compression model. In addition, a threshold <b>1322</b> can again be optionally applied to draw the line where run length encoding benefits are not significant enough to apply the technique. Instead, bit packing can be applied for those values of the column.</p>
<p id="p-0082" num="0081">In addition, optionally, prior to applying run length encoding of the column <b>1300</b>, the column <b>1300</b> can be re-ordered to group all of the most similar values as re-ordered column <b>1330</b>. In this example, this means grouping the As together for a run length encoding and leaving the Bs for bit packing since neither the frequency nor the total bit savings justify run length encoding for the 2 B values. In this regard, the re-ordering can be applied to the other columns to keep the record data in lock step, or it can be remembered via column specific metadata how to undo the re-ordering of the run length encoding.</p>
<p id="p-0083" num="0082"><figref idref="DRAWINGS">FIG. 14</figref> illustrates a similar example where the compression analysis is applied to a similar column <b>1400</b>, but where the bit savings per replacement of a run length have been altered so that now, it is justified according to the hybrid compression analysis to perform the run length encoding for the 2 B values, even before the 10 A values, since the 2 B values result in higher net bit savings. In this respect, much like a glutton choosing among 10 different plates with varying foods on them, application of run length encoding is &#x201c;greedy&#x201d; in that it iteratively seeks the highest gains in size reduction across all of the columns at each step. Similar to <figref idref="DRAWINGS">FIG. 13</figref>, a histogram of frequencies <b>1410</b> and/or a bit savings histogram <b>1420</b> data structure can be built to make determinations about whether to apply run length encoding, as described, or bit packing. Also, optional thresholds <b>1412</b> and <b>1422</b> can be used when deciding whether to pursue RLE or bit packing. Re-ordered column <b>1430</b> can help the run length encoding to define longer run lengths and thus achieve greater run length savings.</p>
<p id="p-0084" num="0083"><figref idref="DRAWINGS">FIG. 15</figref> illustrates the &#x201c;greedy&#x201d; aspect of the run length encoding that examines, across all of the columns, where the highest bit savings are achieved at each step, and can optionally include re-ordering the columns as columns <b>1530</b>, <b>1532</b>, etc. to maximize run length savings. At a certain point, it may be that run length savings are relatively insignificant because the values are relatively unique at which point run length encoding is stopped.</p>
<p id="p-0085" num="0084">In the hybrid embodiment, bit packing is applied to the range of remaining values, which is illustrated in <figref idref="DRAWINGS">FIG. 16</figref>. In this regard, applying the hybrid compression technique, re-ordered column <b>1600</b> includes an RLE portion <b>1610</b> and a bit packing portion <b>1620</b> generally corresponding to recurring values and relatively unique values, respectively. Similarly, re-ordered column <b>1602</b> includes RLE portion <b>1612</b> and BP portion <b>1622</b>.</p>
<p id="p-0086" num="0085">In one embodiment shown in <figref idref="DRAWINGS">FIG. 17</figref>, the hybrid algorithm computes the bit savings from bit packing and bit savings from run length encoding <b>1700</b>, and then the bit savings from bit packing and bit savings from run length are compared at <b>1710</b> or examined to determine which compression technique maximizes bit savings at <b>1720</b>.</p>
<p id="p-0087" num="0086">Exemplary performance of the above-described encoding and compression techniques illustrates the significant gains that can be achieved on real world data samples <b>1801</b>, <b>1802</b>, <b>1803</b>, <b>1804</b>, <b>1805</b>, <b>1806</b>, <b>1806</b>, <b>1807</b> and <b>1808</b>, ranging in performance improvement from about 9&#xd7; to 99.7&#xd7;, which depends on, among other things, the relative amounts of repetition of values in the particular large scale data sample.</p>
<p id="p-0088" num="0087"><figref idref="DRAWINGS">FIG. 19</figref> is a block diagram showing the final result of the columnization, encoding and compression processes described herein in various embodiments. In this regard, each column C1, C2, C3, . . . , CN includes areas having homogeneous repeated values to which run length encoding has been applied, and other areas labeled &#x201c;Others&#x201d; or &#x201c;Oth&#x201d; in the diagram, which represent groups of heterogeneous values in the column. The areas with identical repeated values defined by run length are the pure areas <b>1920</b> and the areas having the variegated values are the impure areas <b>1910</b>, as indicated in the legend. In this respect, as one's eye &#x201c;walks down&#x201d; the columns, a new view over the data emerges as an inherent benefit of the compression techniques discussed herein.</p>
<p id="p-0089" num="0088">Across all of the columns, at the first transition point between an impure area <b>1910</b> and a pure area <b>1920</b>, or the other way around, a bucket is defined as the rows from the first row to the row at the transition point. In this regard, buckets <b>1900</b> are defined down the columns at every transition point as shown by the dotted lines. Buckets <b>1900</b> are defined by the rows between the transitions.</p>
<p id="p-0090" num="0089"><figref idref="DRAWINGS">FIG. 20</figref> shows a nomenclature that is defined for the buckets based on the number of pure and impure areas across a particular row. A pure bucket <b>2000</b> is one with no impure areas. A single impurity bucket <b>2010</b> is one with 1 impure area across the rows of the bucket. A double impurity bucket <b>2010</b> is one with 2 impure area across the rows of the bucket. A triple impurity bucket has 3, and so on.</p>
<p id="p-0091" num="0090">Thus, during an exemplary data load process, data is encoded, compressed and stored in a representation suitable for efficient querying later and a compression technique can be that used that looks for data distribution within a segment, and attempts to use RLE compression more often than bit packing. In this regard, RLE provides the following advantages for both compression and querying: (A) RLE typically requires significantly less storage than bit packing and (B) RLE includes the ability to effectively &#x201c;fast forward&#x201d; through ranges of data while performing such query building block operations as Group By, Filtering and/or Aggregations; such operations can be mathematically reduced to efficient operations over the data organized as columns.</p>
<p id="p-0092" num="0091">In various non-limiting embodiments, instead of sorting one column segment at a time before sorting another column in the same segment, the compression algorithm clusters rows of data based on their distribution, and as such increases the use of RLE within a segment. Where used herein, the term &#x201c;bucket&#x201d; is used to describe clusters of rows, which, for the avoidance of doubt, should be considered distinct from the term &#x201c;partition,&#x201d; a well defined online analytical processing (OLAP) and RDBMS concept.</p>
<p id="p-0093" num="0092">The above discussed techniques are effective due to the recognition that data distribution is skewed, and that in large amounts of data, uniform distributions rarely exist. In compression parlance, Arithmetic Coding leverages this: by representing frequently used characters using fewer bits and infrequently used characters using more bits, with the goal of using fewer bits in total.</p>
<p id="p-0094" num="0093">With bit packing, a fixed-sized data representation is utilized for faster random access. However, the compression techniques described herein also have the ability to use RLE, which provides a way to use fewer bits for more frequent values. For example, if an original table (including one column Col1 for simplicity of illustration) appeared as follows:</p>
<p id="p-0095" num="0094">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Col1</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>100</entry>
</row>
<row>
<entry>100</entry>
</row>
<row>
<entry>100</entry>
</row>
<row>
<entry>100</entry>
</row>
<row>
<entry>200</entry>
</row>
<row>
<entry>300</entry>
</row>
<row>
<entry>400</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0096" num="0095">Then, after compression, Col1 appears as follows, divided into a first portion to which run length encoding is applied and a second portion to which bit packing applies:</p>
<p id="p-0097" num="0096"><chemistry id="CHEM-US-00001" num="00001">
<img id="EMI-C00001" he="13.04mm" wi="29.80mm" file="US08626725-20140107-C00001.TIF" alt="embedded image" img-content="chem" img-format="tif"/>
</chemistry>
</p>
<p id="p-0098" num="0097">As can be seen above, occurrences of the most common value, 100, is collapsed into RLE, while the infrequently appearing values are still stored in a fixed-width, bit packed storage.</p>
<p id="p-0099" num="0098">In this regard, the above-described embodiments of data packing includes two distinct phases: (1) Data analysis to determine bucketization, and (2) Reorganization of segment data to conform to the bucketized layout. Each of these are described in exemplary further detail below.</p>
<p id="p-0100" num="0099">With respect to data analysis to determine bucketization, a goal is to cover as much data within a segment with RLE as possible. As such, this process is skewed towards favoring &#x201c;thicker&#x201d; columns, i.e., columns that have large cardinality, rather than columns that will be used more frequently during querying. Usage based optimizations can also be applied.</p>
<p id="p-0101" num="0100">For another simple example, for the sake of illustration, the following small table is used. In reality, such small tables are not generally included within the scope of the above described compression because the benefit of compression of such tables tends not to be worthwhile. Also, such small tables are not generally included since compression occurs after encoding is performed, and works with data identifications (IDs) in one embodiment, not the values themselves. Thus, a Row # column is also added for illustration.</p>
<p id="p-0102" num="0101">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="70pt" align="center"/>
<colspec colname="2" colwidth="56pt" align="center"/>
<colspec colname="3" colwidth="91pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>Col1</entry>
<entry>Col2</entry>
</row>
<row>
<entry>Row #</entry>
<entry>(9 bits per value)</entry>
<entry>(11 bits per value)</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="70pt" align="center"/>
<colspec colname="2" colwidth="56pt" align="center"/>
<colspec colname="3" colwidth="91pt" align="char" char="."/>
<tbody valign="top">
<row>
<entry>1</entry>
<entry>100</entry>
<entry>1231</entry>
</row>
<row>
<entry>2</entry>
<entry>100</entry>
<entry>12</entry>
</row>
<row>
<entry>3</entry>
<entry>200</entry>
<entry>1231</entry>
</row>
<row>
<entry>4</entry>
<entry>100</entry>
<entry>32</entry>
</row>
<row>
<entry>5</entry>
<entry>400</entry>
<entry>1231</entry>
</row>
<row>
<entry>6</entry>
<entry>100</entry>
<entry>111</entry>
</row>
<row>
<entry>7</entry>
<entry>100</entry>
<entry>12</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0103" num="0102">Across the columns, the bucketization process begins by finding the single value the takes the most space in the segment data. As mentioned above in connection with <figref idref="DRAWINGS">FIGS. 13 and 14</figref>, this can be done using simple histogram statistics for each column, e.g., as follows.</p>
<p id="p-0104" num="0103">
<tables id="TABLE-US-00003" num="00003">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="35pt" align="left"/>
<colspec colname="2" colwidth="77pt" align="center"/>
<colspec colname="3" colwidth="56pt" align="center"/>
<colspec colname="4" colwidth="49pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="4" align="center" rowsep="1"/>
</row>
<row>
<entry>Column</entry>
<entry>Most Common Value</entry>
<entry># occurrences</entry>
<entry>Space Saved</entry>
</row>
<row>
<entry namest="1" nameend="4" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>Col1</entry>
<entry>&#x2002;100</entry>
<entry>5</entry>
<entry>45 bits</entry>
</row>
<row>
<entry>Col2</entry>
<entry>1231</entry>
<entry>3</entry>
<entry>33 bits</entry>
</row>
<row>
<entry namest="1" nameend="4" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0105" num="0104">Once this value is selected, rows in the segment are logically reordered such that all occurrences of this value occur in a sequence, to maximize the length of an RLE run:</p>
<p id="p-0106" num="0105">
<tables id="TABLE-US-00004" num="00004">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="98pt" align="center"/>
<colspec colname="2" colwidth="21pt" align="center"/>
<colspec colname="3" colwidth="98pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry>Original</entry>
<entry/>
<entry/>
</row>
<row>
<entry>Row #</entry>
<entry>Col1</entry>
<entry>Col2</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="98pt" align="center"/>
<colspec colname="2" colwidth="21pt" align="center"/>
<colspec colname="3" colwidth="98pt" align="char" char="."/>
<tbody valign="top">
<row>
<entry>1</entry>
<entry>100</entry>
<entry>1231</entry>
</row>
<row>
<entry>2</entry>
<entry/>
<entry>12</entry>
</row>
<row>
<entry>4</entry>
<entry/>
<entry>32</entry>
</row>
<row>
<entry>6</entry>
<entry/>
<entry>111</entry>
</row>
<row>
<entry>7</entry>
<entry/>
<entry>12</entry>
</row>
<row>
<entry>3</entry>
<entry>200</entry>
<entry>1231</entry>
</row>
<row>
<entry>5</entry>
<entry>400</entry>
<entry>1231</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0107" num="0106">In one embodiment, all values belonging to the same row exist at the same index in each of the column segment, e.g., col1[3] and col2[3] both belong to the third row. Ensuring this provides efficient random access to values in the same row, instead of incurring the cost of an indirection through a mapping table for each access. Therefore, in the presently described embodiment of the application of the greedy RLE algorithm, or the hybrid RLE and bit packing algorithm, when reordering a value in one column, this implies values in other column segments are reordered as well.</p>
<p id="p-0108" num="0107">In the example above, two buckets now exist: {1,2,4,6,7} and {3,5}. As mentioned, the RLE applied herein is a greedy algorithm, which means that the algorithm follows the problem solving metaheuristic of making the locally optimum choice at each stage with the hope of finding the global optimum. After the first phase of finding the largest bucket, the next phase is to select the next largest bucket and repeat the process within that bucket.</p>
<p id="p-0109" num="0108">
<tables id="TABLE-US-00005" num="00005">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="98pt" align="center"/>
<colspec colname="2" colwidth="21pt" align="center"/>
<colspec colname="3" colwidth="98pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry>Original</entry>
<entry/>
<entry/>
</row>
<row>
<entry>Row #</entry>
<entry>Col1</entry>
<entry>Col2</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="98pt" align="center"/>
<colspec colname="2" colwidth="21pt" align="center"/>
<colspec colname="3" colwidth="98pt" align="char" char="."/>
<tbody valign="top">
<row>
<entry>2</entry>
<entry>100</entry>
<entry>12</entry>
</row>
<row>
<entry>7</entry>
</row>
<row>
<entry>1</entry>
<entry/>
<entry>1231</entry>
</row>
<row>
<entry>4</entry>
<entry/>
<entry>32</entry>
</row>
<row>
<entry>6</entry>
<entry/>
<entry>111</entry>
</row>
<row>
<entry>3</entry>
<entry>200</entry>
<entry>1231</entry>
</row>
<row>
<entry>5</entry>
<entry>400</entry>
<entry>1231</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0110" num="0109">Now, there are three buckets: {2,7}, {1,4,6}, {3,5}, when the rows are re-organized accordingly. The largest bucket is the second one, but there are no repeating values there. The first bucket has all columns with RLE runs, and the rest of the values are unique, so it is known that there are no further RLE gains to be had in Col1. Taking the {3,5} bucket into account, there is another value, <b>1231</b>, that can be converted to RLE. Interestingly, <b>1231</b> also appears on the previous bucket, and that bucket can be reordered such that <b>1231</b> is at the bottom, ready to be merged with the top of the next bucket. The next step results in the following:</p>
<p id="p-0111" num="0110">
<tables id="TABLE-US-00006" num="00006">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="98pt" align="center"/>
<colspec colname="2" colwidth="21pt" align="center"/>
<colspec colname="3" colwidth="98pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry>Original</entry>
<entry/>
<entry/>
</row>
<row>
<entry>Row #</entry>
<entry>Col1</entry>
<entry>Col2</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="98pt" align="center"/>
<colspec colname="2" colwidth="21pt" align="center"/>
<colspec colname="3" colwidth="98pt" align="char" char="."/>
<tbody valign="top">
<row>
<entry>2</entry>
<entry>100</entry>
<entry>12</entry>
</row>
<row>
<entry>7</entry>
</row>
<row>
<entry>6</entry>
<entry/>
<entry>111</entry>
</row>
<row>
<entry>4</entry>
<entry/>
<entry>32</entry>
</row>
<row>
<entry>1</entry>
<entry/>
<entry>1231</entry>
</row>
<row>
<entry>3</entry>
<entry>200</entry>
</row>
<row>
<entry>5</entry>
<entry>400</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0112" num="0111">In the example above, four buckets now exist: {2,7}, {6,4}, {1}, {3,5}. Unable to reduce further the data further, the process moves to the next phase of reorganization of segment data.</p>
<p id="p-0113" num="0112">While the illustration at the top reordered the rows as well, for performance reasons, the determination of the buckets can be based purely on statistics, from the act of reordering data within each column segment. The act of reordering data within each column segment can be parallelized based on available cores using a job scheduler.</p>
<p id="p-0114" num="0113">As mentioned, the use of the above-described techniques is not practical for small datasets. For customer datasets, the above-described techniques frequently undergoes tens of thousands of steps, which can take time. Due to the greedy nature of the algorithm, the majority of space savings occur in the first few steps. In the first couple of thousand steps, most of the space that will be saved has already been saved. However, as will be observed on the scanning side of the compressed data, the existence of RLE in the packed columns gives significant performance boosts during querying, since even tiny compression gains reap rewards during querying.</p>
<p id="p-0115" num="0114">Since one segment is processed at a time, multiple cores can be used, overlapping the time taken to read data from the data source into a segment with the time taken to compress the previous segment. With conventional technologies, at the rate of &#x2dc;100K rows/sec reading from a relational database, a segment of 8M rows will take &#x2dc;80 seconds, which is a significant amount of time available for such work. Optionally, in one embodiment, packing of the previous segment may also be stopped once data for the next segment is available.</p>
<p id="h-0009" num="0000">Processing of the Column Based Data Encodings</p>
<p id="p-0116" num="0115">As mentioned, the way that the data is organized according to the various embodiments for column based encoding lends itself to an efficient scan at the consuming side of the data, where the processing can be performed very fast on a select number of the columns in memory. The above-described data packing and compression techniques update the compression phase during row encoding, while scanning includes a query optimizer and processor to leverage the intelligent encoding.</p>
<p id="p-0117" num="0116">The scan or query mechanism can be used to efficiently return results to business intelligence (BI) queries and is designed for the clustered layout produced by the above-described data packing and compression techniques, and optimizes for increased RLE usage, e.g., it is expected that during query processing, a significant number of columns used for querying would have been compressed using RLE. In addition, the fast scanning process introduces a column-oriented query engine, instead of a row-wise query processor over column stores. As such, even in buckets that contain bit pack data (as opposed to RLE data), the performance gains due to data locality can be significant.</p>
<p id="p-0118" num="0117">In addition to introducing the above-described data packing and compression techniques and the efficient scanning, the following can be supported in a highly efficient manner: &#x201c;OR&#x201d; slices in queries and &#x201c;Joins&#x201d; between multiple tables where relationships have been specified.</p>
<p id="p-0119" num="0118">As alluded to above, the scanning mechanism assumes segments contain buckets that span across a segment, and contains columns values in &#x201c;pure&#x201d; RLE runs or &#x201c;impure&#x201d; others bit pack storage, such as shown in <figref idref="DRAWINGS">FIG. 19</figref>.</p>
<p id="p-0120" num="0119">In one embodiment, the scanning is invoked on a segment, the key being to work one bucket at a time. Within a bucket, the scanning process performs column-oriented processing in phases, depending on the query specification. The first phase is to gather statistics about what column areas are Pure, and what areas are Impure. Next, filters can be processed followed by processing of Group By operations, followed by processing of proxy columns. Next, aggregations can be processed as another phase.</p>
<p id="p-0121" num="0120">As mentioned earlier, it is noted that the embodiments presented herein for the scanning implement column-oriented query processing, instead of row-oriented like conventional systems. Thus, for each of these phases, the actual code executed can be specific to: (1) whether the column being operated on is run length encoded or not, (2) the compression type used for bit packing, (3) whether results will be sparse or dense, etc. For Aggregations, additional considerations are taken into account: (1) encoding type (hash or value), (2) aggregation function (sum/min/max/count), etc.</p>
<p id="p-0122" num="0121">In general, the scanning process thus follows the form of <figref idref="DRAWINGS">FIG. 21</figref> in which a query result from various standard query/scan operators <b>2100</b> is a function of all of the bucket rows. The query/scan operators <b>2100</b> can be broken up mathematically in effect such that the filters, Group Bys, proxy columns, and aggregations are processed separate from one another in phases.</p>
<p id="p-0123" num="0122">In this regard, for each of the processing steps, the operators are processed according to different purities of the buckets at <b>2110</b> according to a bucket walking process. Consequently, instead of a generalized and expensive scan of all the bucket rows, with the specialization of different buckets introduced by the work of the encoding and compression algorithms described herein, the result is thus an aggregated result of the processing of pure buckets, single impurity buckets, double impurity buckets, etc.</p>
<p id="p-0124" num="0123"><figref idref="DRAWINGS">FIG. 24</figref> shows a sample distribution of buckets and the power of the compression architecture, since processing performed over pure buckets is the fastest due to the reduction of processing mathematics to simple operations, followed by the second fastest being the single impurity buckets, and so on for additional impurity buckets. Moreover, it has been found that a surprisingly large number of buckets are pure. For instance, as shown in <figref idref="DRAWINGS">FIG. 25</figref>, for six columns implicated by a query, if each column has about 90% purity (meaning about 90% of the values are represented with run length encoding due to similar data), then about 60% of the buckets will be pure, about &#x2153; will be single impurity, about 8% will be double purity, and the rest will be accounted for at a mere 1%. Since processing of pure buckets is the fastest, and processing of single impurity and double impurity buckets is still quite fast, the &#x201c;more complex&#x201d; processing of buckets with 3 or more impure areas is kept to a minimum.</p>
<p id="p-0125" num="0124"><figref idref="DRAWINGS">FIG. 23</figref> indicates a sample query <b>2300</b> with some sample standard query building blocks, such as sample &#x201c;filter by column&#x201d; query building block <b>2302</b>, sample &#x201c;Group by Column&#x201d; query building block <b>2304</b> and sample &#x201c;Aggregate by Column&#x201d; query building block <b>2306</b>.</p>
<p id="p-0126" num="0125"><figref idref="DRAWINGS">FIG. 24</figref> is a block diagram illustrating an additional aspect of bandwidth reduction through column selectivity. Reviewing sample query <b>2400</b>, one can see that no more than 6 columns <b>2410</b> of all columns <b>2420</b> are implicated, and thus only six columns need be loaded into local RAM for a highly efficient query.</p>
<p id="p-0127" num="0126">Various embodiments have thus been described herein. <figref idref="DRAWINGS">FIG. 25</figref> illustrates an embodiment for encoding data, including organizing the data according to a set of column based sequences of values corresponding to different data fields of the data at <b>2500</b>. Then, at <b>2510</b>, the set of column based sequences of values are transformed to a set of column based integer sequences of values according to at least one encoding algorithm, such as dictionary encoding and/or value encoding. Then, at <b>2520</b>, the set of column based integer sequences are compressed according to at least one compression algorithm, including a greedy run length encoding algorithm applied across the set of column based integer sequences or a bit backing algorithm, or a combination of run length encoding and bit packing.</p>
<p id="p-0128" num="0127">In one embodiment, the integer sequences are analyzed to determine whether to apply run length encoding (RLE) compression or bit packing compression including analyzing bit savings of RLE compression relative to bit packing compression to determine where the maximum bit savings is achieved. The process can include generating a histogram to assist in determining where the maximum bit savings are achieved.</p>
<p id="p-0129" num="0128">In another embodiment, as shown in <figref idref="DRAWINGS">FIG. 26</figref>, a bit packing technique includes receiving, at <b>2600</b>, the portions of an integer sequence of values representing a column of data, and three stages of potential reduction by bit packing. At <b>2610</b>, the data can be reduced based on the number of bits needed to represent the data fields. At <b>2620</b>, the data can be reduced by removing any shared numerical powers across the values of the portions of the integer sequence. At <b>2630</b>, the data can also be reduced by offsetting the values of the portions of the integer sequence spanning a range.</p>
<p id="p-0130" num="0129">In another embodiment, as shown in the flow diagram of <figref idref="DRAWINGS">FIG. 27</figref>, in response to a query, at <b>2700</b>, a subset of the data is retrieved as integer encoded and compressed sequences of values corresponding to different columns of the data. Then, at <b>2710</b>, processing buckets are defined that span over the subset of the data based on changes of compression type occurring in any of the integer encoded and compressed sequences of values of the subset of data. Next, at <b>2720</b>, query operations are performed based on type of current bucket being processed for efficient query processing. The operations can be performed in memory, and parallelized in a multi-core architecture.</p>
<p id="p-0131" num="0130">Different buckets include where (1) the different portions of values in the bucket across the sequences are all compressed according to run length encoding compression, defining a pure bucket, (2) all but one portion compressed according to run length encoding, defining a single impurity bucket, or (3) all but two portions compressed according to run length encoding, defining a double impurity bucket.</p>
<p id="p-0132" num="0131">The improved scanning enables performing a variety of standard query and scan operators much more efficiently, particularly for the purest buckets. For instance, logical OR query slice operations, query join operations between multiple tables where relationships have been specified, filter operations, Group By operations, proxy column operations or aggregation operations can all be performed more efficiently when the bucket walking technique is applied and processing is performed based on bucket type.</p>
<p id="h-0010" num="0000">Exemplary Networked and Distributed Environments</p>
<p id="p-0133" num="0132">One of ordinary skill in the art can appreciate that the various embodiments of column based encoding and query processing described herein can be implemented in connection with any computer or other client or server device, which can be deployed as part of a computer network or in a distributed computing environment, and can be connected to any kind of data store. In this regard, the various embodiments described herein can be implemented in any computer system or environment having any number of memory or storage units, and any number of applications and processes occurring across any number of storage units. This includes, but is not limited to, an environment with server computers and client computers deployed in a network environment or a distributed computing environment, having remote or local storage.</p>
<p id="p-0134" num="0133">Distributed computing provides sharing of computer resources and services by communicative exchange among computing devices and systems. These resources and services include the exchange of information, cache storage and disk storage for objects, such as files. These resources and services also include the sharing of processing power across multiple processing units for load balancing, expansion of resources, specialization of processing, and the like. Distributed computing takes advantage of network connectivity, allowing clients to leverage their collective power to benefit the entire enterprise. In this regard, a variety of devices may have applications, objects or resources that may cooperate to perform one or more aspects of any of the various embodiments of the subject disclosure.</p>
<p id="p-0135" num="0134"><figref idref="DRAWINGS">FIG. 28</figref> provides a schematic diagram of an exemplary networked or distributed computing environment. The distributed computing environment comprises computing objects <b>2810</b>, <b>2812</b>, etc. and computing objects or devices <b>2820</b>, <b>2822</b>, <b>2824</b>, <b>2826</b>, <b>2828</b>, etc., which may include programs, methods, data stores, programmable logic, etc., as represented by applications <b>2830</b>, <b>2832</b>, <b>2834</b>, <b>2836</b>, <b>2838</b>. It can be appreciated that objects <b>2810</b>, <b>2812</b>, etc. and computing objects or devices <b>2820</b>, <b>2822</b>, <b>2824</b>, <b>2826</b>, <b>2828</b>, etc. may comprise different devices, such as PDAs, audio/video devices, mobile phones, MP3 players, personal computers, laptops, etc.</p>
<p id="p-0136" num="0135">Each object <b>2810</b>, <b>2812</b>, etc. and computing objects or devices <b>2820</b>, <b>2822</b>, <b>2824</b>, <b>2826</b>, <b>2828</b>, etc. can communicate with one or more other objects <b>2810</b>, <b>2812</b>, etc. and computing objects or devices <b>2820</b>, <b>2822</b>, <b>2824</b>, <b>2826</b>, <b>2828</b>, etc. by way of the communications network <b>2840</b>, either directly or indirectly. Even though illustrated as a single element in <figref idref="DRAWINGS">FIG. 28</figref>, network <b>2840</b> may comprise other computing objects and computing devices that provide services to the system of <figref idref="DRAWINGS">FIG. 28</figref>, and/or may represent multiple interconnected networks, which are not shown. Each object <b>2810</b>, <b>2812</b>, etc. or <b>2820</b>, <b>2822</b>, <b>2824</b>, <b>2826</b>, <b>2828</b>, etc. can also contain an application, such as applications <b>2830</b>, <b>2832</b>, <b>2834</b>, <b>2836</b>, <b>2838</b>, that might make use of an API, or other object, software, firmware and/or hardware, suitable for communication with, processing for, or implementation of the column based encoding and query processing provided in accordance with various embodiments of the subject disclosure.</p>
<p id="p-0137" num="0136">There are a variety of systems, components, and network configurations that support distributed computing environments. For example, computing systems can be connected together by wired or wireless systems, by local networks or widely distributed networks. Currently, many networks are coupled to the Internet, which provides an infrastructure for widely distributed computing and encompasses many different networks, though any network infrastructure can be used for exemplary communications made incident to the column based encoding and query processing as described in various embodiments.</p>
<p id="p-0138" num="0137">Thus, a host of network topologies and network infrastructures, such as client/server, peer-to-peer, or hybrid architectures, can be utilized. The &#x201c;client&#x201d; is a member of a class or group that uses the services of another class or group to which it is not related. A client can be a process, i.e., roughly a set of instructions or tasks, that requests a service provided by another program or process. The client process utilizes the requested service without having to &#x201c;know&#x201d; any working details about the other program or the service itself.</p>
<p id="p-0139" num="0138">In a client/server architecture, particularly a networked system, a client is usually a computer that accesses shared network resources provided by another computer, e.g., a server. In the illustration of <figref idref="DRAWINGS">FIG. 28</figref>, as a non-limiting example, computers <b>2820</b>, <b>2822</b>, <b>2824</b>, <b>2826</b>, <b>2828</b>, etc. can be thought of as clients and computers <b>2810</b>, <b>2812</b>, etc. can be thought of as servers where servers <b>2810</b>, <b>2812</b>, etc. provide data services, such as receiving data from client computers <b>2820</b>, <b>2822</b>, <b>2824</b>, <b>2826</b>, <b>2828</b>, etc., storing of data, processing of data, transmitting data to client computers <b>2820</b>, <b>2822</b>, <b>2824</b>, <b>2826</b>, <b>2828</b>, etc., although any computer can be considered a client, a server, or both, depending on the circumstances. Any of these computing devices may be processing data, encoding data, querying data or requesting services or tasks that may implicate the column based encoding and query processing as described herein for one or more embodiments.</p>
<p id="p-0140" num="0139">A server is typically a remote computer system accessible over a remote or local network, such as the Internet or wireless network infrastructures. The client process may be active in a first computer system, and the server process may be active in a second computer system, communicating with one another over a communications medium, thus providing distributed functionality and allowing multiple clients to take advantage of the information-gathering capabilities of the server. Any software objects utilized pursuant to the column based encoding and query processing can be provided standalone, or distributed across multiple computing devices or objects.</p>
<p id="p-0141" num="0140">In a network environment in which the communications network/bus <b>2840</b> is the Internet, for example, the servers <b>2810</b>, <b>2812</b>, etc. can be Web servers with which the clients <b>2820</b>, <b>2822</b>, <b>2824</b>, <b>2826</b>, <b>2828</b>, etc. communicate via any of a number of known protocols, such as the hypertext transfer protocol (HTTP). Servers <b>2810</b>, <b>2812</b>, etc. may also serve as clients <b>2820</b>, <b>2822</b>, <b>2824</b>, <b>2826</b>, <b>2828</b>, etc., as may be characteristic of a distributed computing environment.</p>
<heading id="h-0011" level="1">Exemplary Computing Device</heading>
<p id="p-0142" num="0141">As mentioned, advantageously, the techniques described herein can be applied to any device where it is desirable to query large amounts of data quickly. It should be understood, therefore, that handheld, portable and other computing devices and computing objects of all kinds are contemplated for use in connection with the various embodiments, i.e., anywhere that a device may wish to scan or process huge amounts of data for fast and efficient results. Accordingly, the below general purpose remote computer described below in <figref idref="DRAWINGS">FIG. 29</figref> is but one example of a computing device.</p>
<p id="p-0143" num="0142">Although not required, embodiments can partly be implemented via an operating system, for use by a developer of services for a device or object, and/or included within application software that operates to perform one or more functional aspects of the various embodiments described herein. Software may be described in the general context of computer-executable instructions, such as program modules, being executed by one or more computers, such as client workstations, servers or other devices. Those skilled in the art will appreciate that computer systems have a variety of configurations and protocols that can be used to communicate data, and thus, no particular configuration or protocol should be considered limiting.</p>
<p id="p-0144" num="0143"><figref idref="DRAWINGS">FIG. 29</figref> thus illustrates an example of a suitable computing system environment <b>2900</b> in which one or aspects of the embodiments described herein can be implemented, although as made clear above, the computing system environment <b>2900</b> is only one example of a suitable computing environment and is not intended to suggest any limitation as to scope of use or functionality. Neither should the computing environment <b>2900</b> be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary operating environment <b>2900</b>.</p>
<p id="p-0145" num="0144">With reference to <figref idref="DRAWINGS">FIG. 29</figref>, an exemplary remote device for implementing one or more embodiments includes a general purpose computing device in the form of a computer <b>2910</b>. Components of computer <b>2910</b> may include, but are not limited to, a processing unit <b>2920</b>, a system memory <b>2930</b>, and a system bus <b>2922</b> that couples various system components including the system memory to the processing unit <b>2920</b>.</p>
<p id="p-0146" num="0145">Computer <b>2910</b> typically includes a variety of computer readable media and can be any available media that can be accessed by computer <b>2910</b>. The system memory <b>2930</b> may include computer storage media in the form of volatile and/or nonvolatile memory such as read only memory (ROM) and/or random access memory (RAM). By way of example, and not limitation, memory <b>2930</b> may also include an operating system, application programs, other program modules, and program data.</p>
<p id="p-0147" num="0146">A user can enter commands and information into the computer <b>2910</b> through input devices <b>2940</b>. A monitor or other type of display device is also connected to the system bus <b>2922</b> via an interface, such as output interface <b>2950</b>. In addition to a monitor, computers can also include other peripheral output devices such as speakers and a printer, which may be connected through output interface <b>2950</b>.</p>
<p id="p-0148" num="0147">The computer <b>2910</b> may operate in a networked or distributed environment using logical connections to one or more other remote computers, such as remote computer <b>2970</b>. The remote computer <b>2970</b> may be a personal computer, a server, a router, a network PC, a peer device or other common network node, or any other remote media consumption or transmission device, and may include any or all of the elements described above relative to the computer <b>2910</b>. The logical connections depicted in <figref idref="DRAWINGS">FIG. 29</figref> include a network <b>2972</b>, such local area network (LAN) or a wide area network (WAN), but may also include other networks/buses. Such networking environments are commonplace in homes, offices, enterprise-wide computer networks, intranets and the Internet.</p>
<p id="p-0149" num="0148">As mentioned above, while exemplary embodiments have been described in connection with various computing devices and network architectures, the underlying concepts may be applied to any network system and any computing device or system in which it is desirable to compress large scale data or process queries over large scale data.</p>
<p id="p-0150" num="0149">Also, there are multiple ways to implement the same or similar functionality, e.g., an appropriate API, tool kit, driver code, operating system, control, standalone or downloadable software object, etc. which enables applications and services to use the efficient encoding and querying techniques. Thus, embodiments herein are contemplated from the standpoint of an API (or other software object), as well as from a software or hardware object that provides column based encoding and/or query processing. Thus, various embodiments described herein can have aspects that are wholly in hardware, partly in hardware and partly in software, as well as in software.</p>
<p id="p-0151" num="0150">The word &#x201c;exemplary&#x201d; is used herein to mean serving as an example, instance, or illustration. For the avoidance of doubt, the subject matter disclosed herein is not limited by such examples. In addition, any aspect or design described herein as &#x201c;exemplary&#x201d; is not necessarily to be construed as preferred or advantageous over other aspects or designs, nor is it meant to preclude equivalent exemplary structures and techniques known to those of ordinary skill in the art. Furthermore, to the extent that the terms &#x201c;includes,&#x201d; &#x201c;has,&#x201d; &#x201c;contains,&#x201d; and other similar words are used in either the detailed description or the claims, for the avoidance of doubt, such terms are intended to be inclusive in a manner similar to the term &#x201c;comprising&#x201d; as an open transition word without precluding any additional or other elements.</p>
<p id="p-0152" num="0151">As mentioned, the various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. As used herein, the terms &#x201c;component,&#x201d; &#x201c;system&#x201d; and the like are likewise intended to refer to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a component may be, but is not limited to being, a process running on a processor, a processor, an object, an executable, a thread of execution, a program, and/or a computer. By way of illustration, both an application running on computer and the computer can be a component. One or more components may reside within a process and/or thread of execution and a component may be localized on one computer and/or distributed between two or more computers.</p>
<p id="p-0153" num="0152">The aforementioned systems have been described with respect to interaction between several components. It can be appreciated that such systems and components can include those components or specified sub-components, some of the specified components or sub-components, and/or additional components, and according to various permutations and combinations of the foregoing. Sub-components can also be implemented as components communicatively coupled to other components rather than included within parent components (hierarchical). Additionally, it should be noted that one or more components may be combined into a single component providing aggregate functionality or divided into several separate sub-components, and that any one or more middle layers, such as a management layer, may be provided to communicatively couple to such sub-components in order to provide integrated functionality. Any components described herein may also interact with one or more other components not specifically described herein but generally known by those of skill in the art.</p>
<p id="p-0154" num="0153">In view of the exemplary systems described supra, methodologies that may be implemented in accordance with the described subject matter will be better appreciated with reference to the flowcharts of the various figures. While for purposes of simplicity of explanation, the methodologies are shown and described as a series of blocks, it is to be understood and appreciated that the claimed subject matter is not limited by the order of the blocks, as some blocks may occur in different orders and/or concurrently with other blocks from what is depicted and described herein. Where non-sequential, or branched, flow is illustrated via flowchart, it can be appreciated that various other branches, flow paths, and orders of the blocks, may be implemented which achieve the same or a similar result. Moreover, not all illustrated blocks may be required to implement the methodologies described hereinafter.</p>
<p id="p-0155" num="0154">In addition to the various embodiments described herein, it is to be understood that other similar embodiments can be used or modifications and additions can be made to the described embodiment(s) for performing the same or equivalent function of the corresponding embodiment(s) without deviating therefrom. Still further, multiple processing chips or multiple devices can share the performance of one or more functions described herein, and similarly, storage can be effected across a plurality of devices. Accordingly, the invention should not be limited to any single embodiment, but rather should be construed in breadth, spirit and scope in accordance with the appended claims.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-chemistry idref="CHEM-US-00001" cdx-file="US08626725-20140107-C00001.CDX" mol-file="US08626725-20140107-C00001.MOL"/>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for processing data, comprising:
<claim-text>receiving raw data organized according to rows or records having fields corresponding to columns;</claim-text>
<claim-text>reorganizing the raw data organized as rows or records according to columns;</claim-text>
<claim-text>encoding data values in each column according to dictionary and/or value encoding as a first data reduction layer;</claim-text>
<claim-text>performing a hybrid run length encoding (RLE) and bit packing (BP) compression iteratively over all columns as a second data reduction layer;</claim-text>
<claim-text>in response to a query, receiving a subset of the data as integer encoded and compressed sequences of values corresponding to different columns of the data;</claim-text>
<claim-text>defining processing buckets that span over the subset of the data received as integer encoded and compressed sequences of values based on changes of compression type occurring in any of the integer encoded and compressed sequences of values of the subset of data, wherein the compression type is evaluated for each column in a compression analysis and, based on the compression analysis, is selected for each column according to which compression type results in the highest rate of compression for that column; and</claim-text>
<claim-text>performing operations defined by the query on a bucket-by-bucket basis, according to the current bucket type when processing the integer encoded and compressed sequences of values to return query results.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the receiving includes receiving the subset in memory for fast memory operations and processing of the subset of the data.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the receiving includes receiving the subset of data from a relational database and wherein the different columns of the data correspond to columns of the relational database.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the performing includes performing operations defined by the query based on whether different portions of values in the bucket across the sequences are compressed according to a first type of compression or second type of compression.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the performing includes performing operations defined by the query based on whether different portions of values in the bucket across the sequences are compressed according to run length encoding compression or bit packing compression.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the performing includes performing operations defined by the query based on how many different portions of values in the bucket across the sequences are compressed according to bit packing compression.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the performing includes performing operations defined by the query based on whether
<claim-text>(1) the different portions of values in the bucket across the sequences are all compressed according to run length encoding compression, defining a pure bucket,</claim-text>
<claim-text>(2) all but one portion compressed according to run length encoding, defining a single impurity bucket, or</claim-text>
<claim-text>(3) all but two portions compressed according to run length encoding, defining a double impurity bucket.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the performing includes performing operations defined by the query based on type of current bucket processed, and processing the buckets in order.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the performing includes parallelizing the operations defined by the query by utilizing multiple processors and a corresponding number of segments divided from the sequences, each segment handled by a different processor.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the performing includes performing logical OR query slice operations or query join operations between multiple tables where relationships have been specified defined by the query based on type of current bucket processed when processing the integer encoded and compressed sequences of values to return query results.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the performing includes performing at least one of filter operations, Group By operations, proxy column operations, or aggregation operations defined by the query based on type of current bucket processed when processing the integer encoded and compressed sequences of values to return query results.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the at least one of filter operations, Group By operations, proxy column operations, or aggregation operations are processed separate from one another in phases for the current bucket and processing occurs bucket by bucket.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. A device for processing data, comprising:
<claim-text>a processing unit for:
<claim-text>receiving raw data organized according to rows or records having fields corresponding to columns;</claim-text>
<claim-text>reorganizing the raw data organized as rows or records according to columns;</claim-text>
<claim-text>encoding data values in each column according to dictionary and/or value encoding as a first data reduction layer;</claim-text>
<claim-text>performing a hybrid run length encoding (RLE) and bit packing (BP) compression iteratively over all columns as a second data reduction layer;</claim-text>
</claim-text>
<claim-text>high speed in memory storage for storing a subset of data received as integer encoded and compressed sequences of values corresponding to different fields of the data;</claim-text>
<claim-text>at least one query processor that processes the query over the subset of the data according to a bucket walking process that defines buckets across the sequences of values based on compression algorithm transitions from run length encoding to bit packing, or vice versa, wherein a compression type is evaluated in a compression analysis for each column and, based on the compression analysis, is selected for each column according to which compression type results in the highest rate of compression for that column, and then processes the query over the subset of data bucket by bucket according to a type of bucket determined for a current bucket being processed based on the types of compression applied across the sequences for the current bucket.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The device of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the types of compression include run length encoding and bit packing.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The device of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the at least one query processor processes filter operations of the query over the subset of data based on the type of bucket.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The device of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the at least one query processor processes Group By operations of the query over the subset of data based on the type of bucket.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The device of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the at least one query processor processes proxy column operations of the query over the subset of data based on the type of bucket.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The device of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the at least one query processor processes aggregation operations of the query over the subset of data based on the type of bucket.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The device of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the at least one query processor determines the query results across all of the buckets based on the different types of buckets.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The device of <claim-ref idref="CLM-00013">claim 13</claim-ref>, further comprising a decoder for decoding the integer encoded and compressed sequences of values to the data fields represented.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. A computer program product comprising one or more physical storage devices having encoded thereon computer executable instructions which when executed upon one or more computer processors performs a method for processing data, the method comprising:
<claim-text>receiving raw data organized according to rows or records having fields corresponding to columns;</claim-text>
<claim-text>reorganizing the raw data organized as rows or records according to columns;</claim-text>
<claim-text>encoding data values in each column according to dictionary and/or value encoding as a first data reduction layer;</claim-text>
<claim-text>performing a hybrid run length encoding (RLE) and bit packing (BP) compression iteratively over all columns as a second data reduction layer;</claim-text>
<claim-text>in response to a query, receiving a subset of the data as integer encoded and compressed sequences of values corresponding to different columns of the data;</claim-text>
<claim-text>defining processing buckets that span over the subset of the data received as integer encoded and compressed sequences of values based on changes of compression type occurring in any of the integer encoded and compressed sequences of values of the subset of data, wherein the compression type is evaluated for each column in a compression analysis and, based on the compression analysis, is selected for each column according to which compression type results in the highest rate of compression for that column; and</claim-text>
<claim-text>performing operations defined by the query on a bucket-by-bucket basis, according to the current bucket type when processing the integer encoded and compressed sequences of values to return query results. </claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
