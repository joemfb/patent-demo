<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08626526-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08626526</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12416599</doc-number>
<date>20090401</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>889</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20120101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>Q</subclass>
<main-group>10</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>705  2</main-classification>
<further-classification>705  3</further-classification>
<further-classification>707100</further-classification>
</classification-national>
<invention-title id="d2e53">System and method for a healthcare communication framework</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>7275220</doc-number>
<kind>B2</kind>
<name>Brummel et al.</name>
<date>20070900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>715804</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>2005/0228808</doc-number>
<kind>A1</kind>
<name>Mamou et al.</name>
<date>20051000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707100</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>2010/0131962</doc-number>
<kind>A1</kind>
<name>Zakonov</name>
<date>20100500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>719315</main-classification></classification-national>
</us-citation>
</us-references-cited>
<number-of-claims>20</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>705  2</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>7</number-of-drawing-sheets>
<number-of-figures>7</number-of-figures>
</figures>
<us-related-documents>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61103145</doc-number>
<date>20081006</date>
</document-id>
</us-provisional-application>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20100088110</doc-number>
<kind>A1</kind>
<date>20100408</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Lemke</last-name>
<first-name>Kai</first-name>
<address>
<city>Schwetzingen</city>
<country>DE</country>
</address>
</addressbook>
<residence>
<country>DE</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Tafazzoli-Yazdi</last-name>
<first-name>Ali Gerhard</first-name>
<address>
<city>Heidelberg</city>
<country>DE</country>
</address>
</addressbook>
<residence>
<country>DE</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Oshifeso</last-name>
<first-name>Mark Anthony</first-name>
<address>
<city>Regensdorf</city>
<country>CH</country>
</address>
</addressbook>
<residence>
<country>CH</country>
</residence>
</us-applicant>
<us-applicant sequence="004" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Puechert</last-name>
<first-name>Wolfram</first-name>
<address>
<city>Speyer</city>
<country>DE</country>
</address>
</addressbook>
<residence>
<country>DE</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Lemke</last-name>
<first-name>Kai</first-name>
<address>
<city>Schwetzingen</city>
<country>DE</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Tafazzoli-Yazdi</last-name>
<first-name>Ali Gerhard</first-name>
<address>
<city>Heidelberg</city>
<country>DE</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Oshifeso</last-name>
<first-name>Mark Anthony</first-name>
<address>
<city>Regensdorf</city>
<country>CH</country>
</address>
</addressbook>
</inventor>
<inventor sequence="004" designation="us-only">
<addressbook>
<last-name>Puechert</last-name>
<first-name>Wolfram</first-name>
<address>
<city>Speyer</city>
<country>DE</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Kenyon &#x26; Kenyon LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>SAP AG</orgname>
<role>03</role>
<address>
<city>Walldorf</city>
<country>DE</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Nguyen</last-name>
<first-name>Hiep V</first-name>
<department>3686</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A computer-implemented method is described for asynchronous service-based communication. The method includes steps of generating events in an application layer of a computer software system, storing the generated events in a database table and scanning the database table by a process of a healthcare communication framework (HCF) at a time after the generated events are stored. The computer software system can run on a computer implementing the HCF and the generated events targeting service operations exported by another software system. During each scan the process is configured to group the events in the database table into packages based on a respective context of each event. For each package: consistency is checked for each event contained in the package, a consolidation logic is applied to consolidate events contained in the package, services operations associated with each event not being consolidated are found, and the service operations are invoked asynchronously.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="170.86mm" wi="141.48mm" file="US08626526-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="189.74mm" wi="135.89mm" file="US08626526-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="203.45mm" wi="145.71mm" file="US08626526-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="203.71mm" wi="115.15mm" file="US08626526-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="201.17mm" wi="142.32mm" file="US08626526-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="144.78mm" wi="131.23mm" file="US08626526-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="226.65mm" wi="153.84mm" orientation="landscape" file="US08626526-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="146.98mm" wi="132.76mm" file="US08626526-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">This application claims priority to U.S. Provisional Patent Application No. 61/103,145, filed Oct. 6, 2008, entitled &#x201c;Healthcare Communication Framework,&#x201d; which is herein incorporated by reference in its entirety.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">BACKGROUND</heading>
<p id="p-0003" num="0002">Health care institutions (e.g., hospitals, clinics, doctor's offices) may have multiple computer software systems to provide a variety of services. For example, a hospital may use an administrative system for admission of patients. The administrative system may facilitate taking and managing information such as patient name, insurance information, etc. The hospital may have a billing system to generate invoices and send bills to insurance companies, and a lab system to manage diagnostic tests. Sometimes, the services provided by another system may be needed. For example, the administrative system may need to invoke services provided in the billing system to generate bills and services provided in the lab system to schedule diagnostic tests. There is a need to integrate diverse systems, such as an administrative system, a billing system and a lab system, by a communication framework.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS OF THE EXAMPLE EMBODIMENTS</heading>
<p id="p-0004" num="0003"><figref idref="DRAWINGS">FIG. 1</figref> shows example systems for a health care institution according to one example of the present invention.</p>
<p id="p-0005" num="0004"><figref idref="DRAWINGS">FIG. 2</figref> shows one example of high level components included in an eventing framework according to one example of the present invention.</p>
<p id="p-0006" num="0005"><figref idref="DRAWINGS">FIG. 3</figref> shows one example of data fields of a runtime events table according to one example of the present invention.</p>
<p id="p-0007" num="0006"><figref idref="DRAWINGS">FIG. 4</figref> shows one example of an out bound process according to one example of the present invention.</p>
<p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. 5</figref> shows one example of a business object model in accordance with one exemplary embodiment of the present invention.</p>
<p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. 6</figref> shows one healthcare communication solution system in accordance with one example embodiment of the present invention.</p>
<p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. 7</figref> shows one message layout in accordance with one example embodiment of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION OF THE EXAMPLE EMBODIMENTS</heading>
<p id="p-0011" num="0010">Embodiments of the present application implement event-driven asynchronous communication between different software systems. Events may be pre-defined and generated at runtime by software systems in accordance with business needs (e.g., admission of a patient, input/modification of insurance information for a patient, etc.). In one embodiment, events may be persisted in a database such that subsequent processing steps may be performed at a later time by scanning entries in the database. For example, an outbound processor may be implemented to periodically check the database and process events accumulated since the last check. The subsequent processing steps may include, but are not limited to, finding a service operation targeted by a respective event, filling context information for the service operation, and calling a proxy of the service operation. These steps will be described in detail below. The outbound processor may be scheduled to execute in the background (e.g., without user interface and/or user interaction). In one or more embodiments, users may define and/or modify service operations without modification to the framework of the system. The communication framework in accordance with embodiments of the present invention may be termed a healthcare communication framework (HCF).</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 1</figref> shows example systems of a health care institution <b>100</b> according to one example of the present invention. The health care institution <b>100</b> have multiple computer software systems to provide a variety of services. One of such software systems may be an administrative system <b>110</b>, which provides information management relating to administrative tasks (e.g., admission/discharge of a patient). The health care institution <b>100</b> may further include a lab system <b>120</b>. The lab system <b>120</b> may facilitate diagnostics tests to be performed by a laboratory (e.g., blood testing). The health care institution <b>100</b> may also include a billing system <b>130</b> to generate invoices and send bills to insurance companies. The administrative system <b>110</b>, lab system <b>120</b> and billing system <b>130</b> may be connected via a network <b>140</b>, such that one system may interact with another system to perform a certain function. For example, the administrative system <b>110</b> may need to invoke services provided in the lab system <b>120</b> and/or billing system <b>130</b>. In one embodiment, one or more of the systems of the health care institution <b>100</b> may need to communicate with external systems (e.g., a system of an insurance company).</p>
<p id="p-0013" num="0012">One way of communication between diverse systems may be synchronous communication. Synchronous communication establishes connections between different participating systems in a synchronized manner. In this manner, systems participating in the communication must be present during the whole time period the communication is in progress. Once synchronous communication is established, the initiating system will resume its own execution only after the synchronous communication is completed. That is, the initiating system has to complete the communication with other systems before continue its own execution. Thereby, synchronous communication may block execution of the initiating system. If a subsequent change is made in the initiating system, the change may cause the initiating system to start another round of synchronous communication. Resources (e.g., bandwidth of the network) may be spent by recurring communications between different systems running on different computers. For example, an update to a patient's information in the administrative system <b>110</b> may cause the administrative system <b>110</b> to invoke services provided in the lab system <b>120</b> and/or billing system <b>130</b>, thus a new round of synchronous communication is needed.</p>
<p id="p-0014" num="0013">In one embodiment, communication between various systems <b>110</b>, <b>120</b> and <b>130</b> may be implemented as remote procedure calls. That is, each system may export certain procedures to represent service operations that can be called by another system. The remote procedure calls may be facilitated by proxies. Each proxy presents a corresponding remote procedure to be called by a calling system. The procedure calls may be performed synchronously and/or asynchronously. For example, a patient information may be transmitted from the administrative system <b>110</b> to the billing system <b>130</b> when a bill for the patient needs to be generated. That is, the administrative system <b>110</b> may initiate a remote procedure call synchronously to invoke the service operation in the billing system <b>130</b> to generate the bill. Alternatively, the administrative system <b>110</b> may generate a request (e.g., an event) and submit the request to a system or queue to be fulfilled later (e.g., asynchronously). For example, the bill may be generated at night when there is less network communication and less computing activity by computers running the billing system <b>120</b>.</p>
<p id="p-0015" num="0014">In one embodiment, asynchronous communications may be implemented for certain types of remote procedure calls and synchronous communications may be implemented for other types. A system designer may define what types of remote procedure calls should be implemented as synchronous or asynchronous. It should be noted that the administrative system <b>110</b>, lab system <b>120</b> and billing system <b>130</b> are exemplary systems of the health care institution <b>100</b>. The health care institution <b>100</b> may include other systems not shown in <figref idref="DRAWINGS">FIG. 1</figref> and may include systems less than shown in <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 2</figref> shows one example of high level components included in an eventing framework <b>200</b> according to one example of the present invention. Eventing may cover detection of events and supply of further processing steps of the events. The eventing framework <b>200</b> may be implemented by any of the computer software systems (e.g. administrative system <b>110</b>, lab system <b>120</b> or billing system <b>130</b>). The eventing framework <b>200</b> may include a user interface <b>208</b>, a communication module <b>204</b>, an events processing module <b>206</b> and events database <b>208</b>. A user <b>202</b> may interact with the user interface <b>208</b>. The interaction may cause events to be generated (e.g., generating a bill for a patient). The communication module <b>204</b> may implement functions that collect events and call related function modules. In one embodiment, the communication module <b>204</b> may be implemented as a &#x201c;virtual&#x201d; communication module. For example, the &#x201c;virtual&#x201d; communication module may perform various exchange data interface (EDI) procedures. They may provide a way to establish connections between an information system (e.g., administrative system <b>110</b>) and a data exchange infrastructure (e.g., exchange infrastructure <b>632</b> shown in <figref idref="DRAWINGS">FIG. 6</figref>).</p>
<p id="p-0017" num="0016">The events processing module <b>206</b> may be invoked by the communication module <b>204</b> for post processing of events that have been triggered for one business transaction (e.g., entry of a patient's information or a request to generate a bill by the user <b>202</b>). The events processing module <b>206</b> may aggregate events by keeping the order by which events are generated and writing the events into the events database <b>208</b>. In one embodiment, the database <b>208</b> implements a runtime events table to store the events written by the event processing module <b>206</b>. In one embodiment, events may be collected within the database <b>208</b> as persistent events.</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 3</figref> shows one example of data fields of a runtime events table <b>300</b> according to one example of the present invention. In one embodiment, the runtime events table <b>300</b> may include data field &#x201c;MANDT&#x201d; for clients (e.g., each representing an enterprise with a runtime system), &#x201c;EGUID&#x201d; for a globally unique identifier for the event, &#x201c;LUWID&#x201d; for an identifier of the originating business transaction Logical Unit of Work (LUW), &#x201c;TA&#x201d; for name of the originating transaction, &#x201c;TIMESTAMP&#x201d; for the time the event is generated, &#x201c;User&#x201d; to identify the user of the system generating the event, &#x201c;APPLK&#x201d; for the owner of the event, and &#x201c;EVENT&#x201d; for a code identifying the eventcode. The runtime events table <b>300</b> may further include data fields with text that describes an institution (e.g., EINRI), a patient identifier (e.g., PATID), and case identifier (e.g., CASEID). The runtime events table <b>300</b> may also include supplementary text fields to describe additional aspects of a respective event, such as, but not limited to, data field Key <b>1</b>.</p>
<p id="p-0019" num="0018">Events stored in the runtime events table <b>300</b> may be processed at a later time (e.g., periodically, or a designated later time) by an outbound processor. If an error occurs during the process, an error may be recorded in an event errors table. The event errors table may be similar to the runtime events table <b>300</b> and contains data fields and information stored in the runtime events table <b>300</b>. Additionally, the event errors table may store error information to facilitate diagnosis of the errors.</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 4</figref> shows one example of an out bound process <b>400</b> according to one example of the present invention. The out bound process <b>400</b> may be implemented by any of the software systems of the health care institution <b>100</b> that use asynchronous communication. In one embodiment, the out bound process <b>400</b> may be scheduled to run periodically as a backend computer service. When executed, the out bound process <b>400</b> may process events accumulated in the runtime events table <b>300</b> and event errors table between the last run and the current run. If an error occurs during execution of the out bound process <b>400</b>, the error may be written to the event errors table. In one embodiment, an administrator may be notified of the error by an alert, which will be described in detail later. Further, if the same error is found again during the next run of the out bound process <b>400</b> (e.g., because the administrator has not yet fixed the error), the alert may be suppressed.</p>
<p id="p-0021" num="0020">The out bound process <b>400</b> may start with step <b>402</b> and continue to step <b>404</b>. At step <b>404</b>, the out bound process <b>400</b> may try to retrieve an events package. Events in the runtime events table <b>300</b> and the event errors table are packaged in to events packages according to the context of each event. In one embodiment, an event manager may be implemented. The event manager may build events packages based on a pre-determined criteria. Each events package may be processed as a unit. That is, all events contained in one package may be processed together. For example, events may be grouped in one events package for one patient based on a patient context. The patient context may ensure that all events that might be relevant for later consolidation and may be written to the event errors table are contained in one package. The consolidation of events are described in detail below.</p>
<p id="p-0022" num="0021">In one embodiment, events stored in both the runtime events table <b>300</b> and the event errors table need to be processed in chronological order. In case of any error occurring during the process, any subsequent related events may also be put in the event errors table. In one embodiment, any subsequent events with the same PATID may be related to same patient and may be treated as related events. For events without patent context, such as a patient identifier, a pre-defined criteria may be used to group events. The same pre-defined criteria may also be used for consolidation of events when processing events packages.</p>
<p id="p-0023" num="0022">At step <b>406</b>, the out bound process <b>400</b> may determine whether the retrieval step <b>404</b> is successful. If no package can be retrieved and thus no more packages are to be processed, the out bound process <b>400</b> may end at step <b>407</b>. If a package is retrieved, the out bound process <b>400</b> continues to step <b>408</b>.</p>
<p id="p-0024" num="0023">At step <b>408</b>, the out bound process <b>400</b> may check consistency for each event contained in the events package being processed. For example, the step <b>408</b> may check whether relevant patient context is provided. If an error occurs during the step <b>408</b>, the step <b>408</b> may raise an error identified as basic consistency error and continue to step <b>416</b>, which may store the error in the event errors table. In one embodiment, the events package may include a field identifying the last error that has occurred. This field of last error may contain error information that is existent to an event in the event errors table. Thus, this information in an events package may suppress multiple alerts for the same error. If no error occurs, the out bound process <b>400</b> may continue to step <b>408</b>.</p>
<p id="p-0025" num="0024">At step <b>410</b>, the out bound process <b>400</b> may consolidate events contained in the current events package. In one embodiment, the out bound process <b>400</b> may implement a consolidation logic. The consolidation logic may be applied to each event in the events package to determine if the respective event may be consolidated with another event in the events package. Consolidation may be implemented as aggregation of events that were triggered between the last and current run of the out bound process <b>400</b>, and may reduce and/or eliminate redundant service operation calls during the out bound process <b>400</b>. The events package may contain supplementary information reflecting the status of the consolidation steps. For example, the events package may have a field identifying whether an event has been consolidated with another event and the other event's identifier. The events package may further include a field about a status identifying whether a respective event is no longer the object of event processing steps of the out bound process <b>400</b>. The status may be set to &#x201c;processed&#x201d;, when the event has been consolidated. The out bound process <b>400</b> may skip all events with a status of &#x201c;processed&#x201d; for further processing steps. However, the consolidated events are not deleted from the runtime events table yet because in case of error scenarios, they also have to be inserted in the event errors table.</p>
<p id="p-0026" num="0025">In one or more embodiments, consolidation is implemented to reduce/eliminate redundant service operation calls. The redundant service operation calls may be identified by certain patterns. Each pattern may use business objects and context to distinguish service operation calls. The term business object is described below. Context may be patient context, e.g., the same patient as identified by a patient identifier.</p>
<p id="p-0027" num="0026">In one pattern, for example, two events may have identical service operation calls thus the two events may be consolidated. In this case, the second event may be marked as &#x201c;processed&#x201d; and only one service operation call is performed. The pattern may be identified by the same business object, the same context and the same action.</p>
<p id="p-0028" num="0027">In another exemplary pattern, a change service operation call may follow a preceding creation service operation call. For example, after a patient's information has been entered into the administration system <b>110</b>, the patient's information has been subsequently modified. An event may be stored in the runtime events table <b>300</b> for initial entry of the patient's information, and a subsequent event may be stored for the subsequent modification. The two events may have the same patient context and thus may be consolidated (e.g., modify information of the initial event with change from the subsequent event). The subsequent event may be treated as already processed (e.g., marking it as &#x201c;processed&#x201d;). The out bound process <b>400</b> may skip the subsequent event in later steps (e.g., for locating and calling the service operation). This exemplary pattern may be identified by the same business object, the same context and a creation action plus a change action.</p>
<p id="p-0029" num="0028">In a further exemplary pattern, an event may cancel a service operation following a preceding event to create the service operation (e.g., canceling generation of a bill for a patient). The consolidation may cancel the creation service operation call and the out bound process <b>400</b> will invoke no service operation calls for these two events. This further exemplary pattern may be identified by the same business object, the same context and a creation action plus a cancel action.</p>
<p id="p-0030" num="0029">If an error occurs during the step <b>410</b>, the step <b>410</b> may raise an error identified as a consolidation error and continue to step <b>416</b>, which may store the error in the event errors table. The error information may be stored in the last error field of the events package before being processed in step <b>416</b>. If no error occurs, the out bound process <b>400</b> may continue to step <b>412</b>.</p>
<p id="p-0031" num="0030">At step <b>412</b>, the out bound process <b>400</b> may find service operations for the events contained in the events package being processed. In one embodiment, the out bound process <b>400</b> may find service operations for each event in the events package with a status not set to &#x201c;processed.&#x201d; The service operations for each event may be determined by pre-defined configurations. The configurations to associate operation services with events may be stored in configuration information database tables or configuration files. During the step <b>412</b>, if an event is marked as &#x201c;processed&#x201d; in the status field, the event may be skipped by the step <b>412</b> and no service operations will be searched for the event.</p>
<p id="p-0032" num="0031">In one embodiment, the events package may contain supplementary information reflecting the status of the finding service operation steps. For example, the events package may include a field for service operations. One or more service operations may be associated with one event. That is, each event may cause one or more service operations to be invoked. The service operations may be implemented as a nested structure for each event. The nested structure may contain the service operations that are found for the given event. This field for service operations may be filled when the previous step <b>410</b> (e.g., consolidation) and current step <b>412</b> (e.g., service operation finding) are successful. If an error occurs during the step <b>412</b>, the step <b>412</b> may raise an error identified as a service operations finding error and continue to step <b>416</b>, which stores the error in the event errors table. The error information may be stored in the last error field of the events package before being processed in step <b>416</b>. If no error occurs, the out bound process <b>400</b> may continue to step <b>414</b>.</p>
<p id="p-0033" num="0032">At step <b>414</b>, service operations identified for each event in step <b>412</b> are invoked. In one or more embodiments, the out bound process <b>400</b> may implement procedures to fill in context information of each service operation and call respective proxies of the service operations. In one embodiment, invocation of service operation may be performed asynchronously, e.g., using message queues.</p>
<p id="p-0034" num="0033">Embodiments of the present invention may use message queuing to provide an asynchronous communication. Message queuing is an asynchronous communications protocol. Using message queues, senders and receivers of messages do not need to interact with the message queues at the same time. Messages placed onto a queue are stored until the recipient retrieves them from the queue. Some message queues have set limits on the size of data that can be transmitted in a single message but some others do not. Some implementations of message queues allow the passing of messages between different computer systems, potentially connecting multiple applications and multiple operating systems. These message queuing systems typically provide enhanced resilience functionality to ensure that messages do not get &#x201c;lost&#x201d; in the event of a system failure. Examples of commercial implementations of this kind of message queuing software (also known as Message Oriented Middleware) include IBM's WebSphere MQ (formerly MQ Series), Oracle Advanced Queuing (AQ) within an Oracle database, and Microsoft's MSMQ. The Java standard called Java Message Service has, associated with it, a number of implementations, both proprietary and free software. Embodiments of the present invention may use any existing message queuing systems or may develop custom message queuing systems.</p>
<p id="p-0035" num="0034">If an error occurs during the step <b>414</b>, the step <b>414</b> may raise an error identified as a process service operations error and continue to step <b>416</b>, which stores the error in the event errors table. The error information may be stored in the last error field of the events package before being processed in step <b>416</b>. If no error occurs, the out bound process <b>400</b> may continue to step <b>416</b> without raising an error.</p>
<p id="p-0036" num="0035">At step <b>416</b>, the out bound process <b>400</b> may perform clean up tasks before ending the process. In one embodiment, the step <b>416</b> may raise an alert for errors raised during any of previous steps. Also, the step <b>416</b> may store the errors in the event errors table. If there are no errors, the step <b>416</b> may delete entries in the events table because the current run successfully processed scanned events from the events table. If events from event errors table are also processed without error, corresponding entries in the event errors table may also be cleaned. In one embodiment, the out bound process <b>400</b> may implement transactions to protect data integrity in the step <b>416</b>. For example, a transaction may be started as soon as the step <b>416</b> starts, if certain work has been performed before encountering the error, the work may be rolled back. The transaction may only be committed when the step <b>416</b> has executed successfully. Further, changes to either runtime events table and event errors table may also be wrapped around by the transaction and occur only after a successful execution of other functions in step <b>416</b>.</p>
<p id="p-0037" num="0036">In one or more embodiments, the out bound process <b>400</b> may skip integrity checks. Integrity checks normally make sure context information or data supplied to proxies conform to the remote procedure's requirement. A layered implementation of the software system may be implemented and the integrity checks may be implemented at an application layer not at the out bound process <b>400</b>. However, the out bound process <b>400</b> is prepared to handle errors for each processing step. Thus, an integrity check framework may be added to the health care communication framework if needed. Further, in one embodiment, error situations that occur during out bound process <b>400</b> may be forwarded using one generic alert implementation. More complex alert framework may be employed if more complex errors than mere technical errors are anticipated.</p>
<p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. 5</figref> shows one example of a business object model <b>500</b> in accordance with one exemplary embodiment of the present invention. The business object model may comprise an application layer <b>502</b>, a business objects layer <b>504</b> and a data access objects layer <b>506</b>. The application layer <b>502</b> may include user interface elements and modules that are responsive to user interactions. Events may be generated in the application layer <b>502</b> and stored in the runtime events table. The business objects layer <b>504</b> comprises a plurality of business objects. The business objects may represent the entities in the business domain for an HCF (e.g., a patient, a customer, etc). These business objects may be sometimes called domain objects; a domain model represents the set of domain objects and the relationships between them. A business object (e.g., a patient object) often encapsulates all of the data and business behavior associated with the entity that it represents. Business objects do not necessarily need to represent objects in an actual business, though they often do. They can represent any object related to the HCF for which a system developer may define any business logic. The business object model <b>500</b> may be implemented in one or more object oriented programming languages (e.g., Java, C++).</p>
<p id="p-0039" num="0038">The business objects may access data stored in any underlying database through the data access objects (DAO) layer <b>506</b>. The DAO layer <b>506</b> provides an abstract interface to an underlying database or persistence mechanism. It provides data specific operations without exposing details of the database. This isolation separates the concerns of what data accesses the HCF needs, in terms of business objects and data types, and how these needs can be satisfied with a specific DBMS, database schema, etc. In one or more embodiments, the DAO layer does not contain any control for transactions. That is, data access objects may not implement &#x201c;commit&#x201d; for transaction and leave the transaction control to the business objects in the layer <b>504</b>.</p>
<p id="p-0040" num="0039">Errors may occur when a data access object is accessing data. In this case, one or more exceptions may be generated (e.g., thrown) in the DAO and propagated to the caller (e.g., a business object invoking the DAO). The exceptions may be of technical or business nature. For example, technical exceptions may be caused by customizing inconsistencies, inactive Data Dictionary (DDIC) and invalid parameters. Business exceptions may be errors caused by invalid application programming interface (API) calls (e.g., trying to access information for a non-existent patient). A business exception may be propagated by raising an alert to an administrator.</p>
<p id="p-0041" num="0040">Errors and exceptions have been mentioned above. In one embodiment, problematic situations may be grouped into exceptions, errors, and conflicts. Exceptions may indicate that some unexpected condition has occurred which cannot be fixed by an end user. They might be fixed by the system administrator. Exemplary exceptions may be database inconsistencies, invalid customizing settings, code errors (e.g. invalid parameters passed to a method), authorization problems (if they cannot be corrected by the user), unexpected error situations in the proxy coding before and after the business logic calls. Errors may be problems that can be solved by a user, e.g., correcting the input data or by doing the action some time later, data inconsistencies with a (incoming) message (e.g. unknown service operation code). Conflicts may occur when there are process inconsistencies with a (incoming) message, e.g., choreographic errors.</p>
<p id="p-0042" num="0041">The business object model <b>500</b> may be implemented across systems with each system exporting services to be invoked by other systems. As described above, service operations implemented in another system may be invoked through messaging queues. This service oriented architecture (SOA) using asynchronous messages may result in loose coupling of systems. Further, the SOA may use no cross system transactions (as DB LUW) and may use no cross system locks. This may lead to an optimistic approach where each system is responsible for its own process steps. Results of the steps are published via messages (e.g., invocation or acknowledgement). This also means that there are limited checks for the invoked systems, whereas many checks are done in the invoking system. In one or more embodiments, forward recovery may be chosen for resolution strategies (e.g., exception, error or conflict situations), which might come up in a subsequent system since rollback of a LUW is no longer possible (due to loose coupling). That is, errors at the receiver-side are to be handled independently from the sender.</p>
<p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. 6</figref> shows one healthcare communication solution system <b>600</b> in accordance with one example embodiment of the present invention. The healthcare communication solution system <b>600</b> may comprise a healthcare system <b>630</b>, an exchange infrastructure <b>632</b> and an external system <b>614</b>. The healthcare system <b>630</b> (e.g., an administrative system) may comprise a healthcare information system <b>602</b> and a healthcare communication framework (HCF) runtime <b>608</b>. The exchange infrastructure <b>632</b> may comprise an infrastructure runtime <b>634</b>. The HCF runtime <b>608</b> and infrastructure runtime <b>634</b> may be components of a healthcare communication solution <b>606</b> that spread beyond one single computer system. The external system <b>614</b> may be a computer system of a business partner (e.g., a health insurance company) and may run a different computer hardware/software system. In one embodiment, more than one external system may be included in a healthcare communication solution system. The healthcare communication solution system <b>600</b> may further comprise a universal worklist (UWL) <b>616</b>, an alert box <b>618</b> and a personal object work list (POWL) <b>620</b>.</p>
<p id="p-0044" num="0043">The healthcare information system <b>602</b> may comprise the application layer <b>502</b> described above in <figref idref="DRAWINGS">FIG. 5</figref> and may raise events <b>604</b>. The events <b>604</b> may be transmitted to the HCF runtime <b>608</b> in the order that they are raised. The HCF runtime <b>608</b> may process the events in the order they are received. Events <b>604</b> may be related to service operations provided in another system (e.g., a billing system not shown) and those service operations may need to be invoked in the same order on a proxy <b>610</b>.</p>
<p id="p-0045" num="0044">In one embodiment, to ensure a proper sequence for invoking the service operations, a named queue may be used. Instead of all messages sharing one message queue, multiple queues with unique names may be created. Thus, each message may be put into a specific named queue based on the message's target system, target service operation (e.g., a specific remote procedure), or a message context (e.g., a patient ID). With named queues, the HCF outbound proxy calls (e.g., outbound messages) may be enhanced to allow a strict sequencing (e.g., exactly once in order (EOIO)). In one embodiment, the sequencing context may be based on a patient ID. If a patient ID is available, the patient ID may be used for a queue name to ensure all service operations related to the patient are put in one queue and EOIO may be strictly enforced. If a message has no patient ID, a named queue is not used for the message. The message may be delivered to queues managed by the proxy framework (e.g., proxy <b>610</b>) to ensure exactly once (EO) delivery. However, the sequence for those services is not to be guaranteed. In one or more embodiments, the proxy <b>610</b> may create queues if there is no patient ID and HCF runtime <b>608</b> does not create named queues.</p>
<p id="p-0046" num="0045">The exchange infrastructure <b>632</b> may also need to implement functions to ensure EOIO if EOIO is requested by the HCF runtime <b>608</b>. In one or more embodiments, the infrastructure runtime <b>634</b> may further communicate with the external system <b>614</b> through an adapter <b>612</b>. Thus, not only the infrastructure runtime <b>634</b> needs to perform the service operations in the sequence as set forth by the HCF runtime <b>608</b>, it may further ensure messages sent to the external system <b>614</b> to be in that sequence. The adapter <b>612</b> may be required to be EOIO capable to facilitate the mission.</p>
<p id="p-0047" num="0046">In one embodiment, the external system <b>614</b> may send messages to the HCF runtime <b>608</b>. The messages may be termed inbound messages with regard to the HCF runtime <b>608</b>. The inbound messages may be sent via the adapter <b>612</b> to the infrastructure runtime <b>634</b>. The infrastructure runtime <b>634</b> may invoke service operations exported by the HCF runtime <b>608</b> via the proxy <b>610</b>. Message queuing including named queues described above for the proxy <b>610</b> may also be used for the inbound messages as well. The external system <b>614</b> may also require EOIO behavior for inbound messages. To enforce the EOIO behavior, the adapter <b>612</b> may be required to be EOIO capable. Further, named queues may be required for invocation of service operations through the proxy <b>610</b>.</p>
<p id="p-0048" num="0047">If no error occurs and EOIO is used, then the inbound proxies at the proxy <b>610</b> will be called in the correct order. If an error occurs, then the sequence will only be guaranteed for subsequent errors, which may be caught by the business object model implemented by the healthcare communication solution system <b>600</b>. In one embodiment, the first erroneous message will be persisted in a monitor in the exchange infrastructure <b>632</b>. The follow-up messages may run into errors and also be persisted by the monitor. An administrator may be informed with an alert through the alert inbox <b>618</b> and he or she might restart the message at a later point in time. For example, if a service operation to create a patient object has an error and is not processed. A subsequent service operation to change the patient object may cause an exception to be raised in the HCF runtime <b>608</b>, because the patient doesn't exist yet. So the subsequent message is not processed and will instead be put into the monitor. In one embodiment, messages like several change messages for the same patient might be processed not in the order the messages are generated.</p>
<p id="p-0049" num="0048">HCF may be activated and/or deactivated at an institutional level. The HCF runtime <b>608</b> and the infrastructure runtime <b>634</b> only run when the HCF is activated. For example, configuration database may be used to store the HCF procedures pre-defined for the institution. The various HCF procedures run in the HCF runtime <b>608</b> and infrastructure runtime <b>634</b> when the HCF is activated. An administrator may activate the HCF procedures through a user interface menu (e.g., through the healthcare information system <b>602</b>). In one embodiment, all exported operation services from either the HCF runtime <b>608</b> or infrastructure runtime <b>634</b> may be stored in one or more database tables.</p>
<p id="p-0050" num="0049">In one embodiment, the HCF runtime <b>608</b> or infrastructure runtime <b>634</b> may implement exception handling by exception classes. These classes may have a hierarchical structure and have common attributes. Exceptions which are raised within HCF runtime <b>608</b> or infrastructure runtime <b>634</b> may be propagated to either the runtime caller or the inbound proxy <b>610</b> depending upon which is the caller. Succeeding actions may be taken at the caller. This may help restrain follow up actions taking place only at either of the two places. Follow up actions may include: raise an alert (e.g., send an alert to the alter inbox <b>618</b>); send an error notification/message; write an application log entry; adjust the events table accordingly and any other action.</p>
<p id="p-0051" num="0050">The healthcare communication solution system <b>600</b> may implement an alert management to provide a central notification system. The alert management may be accessed from all systems of the healthcare communication solution system <b>600</b> (except the external system). The healthcare communication solution system <b>600</b> may implement user functions/components for watching alerts. In one embodiment, the UWL <b>616</b> may be implemented, which may be a component coupled to a portal to display alerts to an administrator. In another embodiment, the alert inbox <b>618</b> may be implemented to receive alerts from the healthcare information system <b>602</b>, HCF runtime <b>608</b>, the proxy <b>610</b> and the infrastructure runtime <b>634</b>. In a further embodiment, the POWL <b>620</b> may be implemented for data other than alerts (e.g., message history) to be shown to an administrator.</p>
<p id="p-0052" num="0051">The alert management and the exception handling of the healthcare communication solution system <b>600</b> may provide different approaches for error handling. For example, one type of error may be resolved by the system administrator only. In one embodiment, an administrator may be informed about the exception by an alert (e.g., via the alert inbox <b>618</b>, UWL <b>616</b>, and/or POWL <b>620</b>) and the administrator can log in the system to resolve it. One exemplary alert may be caused by faulty environment settings. The alert may comprise some text with an error description (and/or a call stack of the current procedure call context), link to the transaction for correcting the environment, and link to an monitor (leads directly to the concerned message).</p>
<p id="p-0053" num="0052">Another type of error may be resolved by the end user only. An exemplary alert may be temporary errors, which couldn't be resolved by automatic retries or may be any unknown error. This kind of alert may also comprise some text with error description (and a call stack) and link to an monitor (leads directly to the concerned message). For the end users, only errors or conflicts may be relevant. These errors and conflicts may be defined by the business transactions implemented in the healthcare communication solution system <b>600</b>. Such errors/conflicts may occur in the HCF runtime <b>608</b> during inbound or out bound processing or in the infrastructure runtime <b>634</b>. From both locations, alerts may be thrown, which may contain descriptive texts and links to the related transactions.</p>
<p id="p-0054" num="0053">Another type of error may be resolved first by end user, then by system administrator. In one embodiment, the link to the monitor may be provided only if the proxy <b>610</b> is involved In some situations, resolution of an error or conflict may need involvement from both the end user and the administrator. In such cases, an alert will be send first to the end user, who might fix the issue with business transaction(s). After successfully changing data in the transaction that caused the error/conflict, the end user may forward the alert to the administrator, who may then follow the link in the alert to the monitor and try to resend the message.</p>
<p id="p-0055" num="0054">The alert management described above may also be applied if exception/error/conflict is caused by an inbound message initiated from the external system <b>614</b>.</p>
<p id="p-0056" num="0055">The healthcare communication solution system <b>600</b> may log its activities on request to support tracing and error finding for the initial setup of the system as well as during productive use. Logging may be switchable (active/inactive) at an institution level (e.g., via a database table entry and/or a user interface menu). Additionally, the log level can be set to different levels (e.g., just errors, errors and warnings or all messages). The HCF runtime logging may log activities from the HCF runtime <b>608</b>. The exchange infrastructure <b>632</b> may offer additional logging and monitoring functionalities, e.g. to follow-up how a specific message was handled within infrastructure runtime <b>634</b>. In one embodiment, the activities that may be logged in HCF runtime <b>608</b> are based on inbound or outbound processing (e.g., successful execution of a unit process, error occurring at a component). Logs may be stored in one or more database tables. User interface modules may be implemented to display logged data.</p>
<p id="p-0057" num="0056"><figref idref="DRAWINGS">FIG. 7</figref> shows one message layout <b>700</b> in accordance with one example embodiment of the present invention. A message according the message layout <b>700</b> may comprise a message type <b>702</b>. The message may further comprise one or more nodes, such as, nodes <b>704</b>, <b>706</b> and <b>708</b>. In one embodiment, the message type <b>702</b> may describe a complete structure of the message. The nodes <b>704</b>, <b>706</b> and <b>708</b> may contain global data types (e.g., data types across systems at an institutional level) or are complex global data types themselves. For example, the node <b>704</b> may comprise general patient data, the node <b>706</b> may comprise data related to a case and the node <b>708</b> may comprise data related to encounter data. An encounter is a part of a visit in a healthcare provider institution, for example, admission, discharge and transfer.</p>
<p id="p-0058" num="0057">In one embodiment, the data access objects in <figref idref="DRAWINGS">FIG. 5</figref> may be used to access data represented by each node. One data access object may be defined to access data only for one node and from one data source. For example, patient data of node <b>704</b> may come from the healthcare information system <b>602</b> and external system <b>614</b>. Two data access objects may be needed to access the patient data from two different data sources.</p>
<p id="p-0059" num="0058">In one or more embodiments, acknowledgements to messages may be implemented. Acknowledgements may be requested by a message sender and the receiver(s) are to send requested information back to the sender. Acknowledgements may be useful for asynchronous messaging because unlike synchronous messaging, in which status information will be directly sent back, status information for asynchronous messaging is not available unless explicitly requested by the sender. Acknowledgments may differ from confirmations because acknowledgements are more of a technical nature and they may indicate that the processing of the message on the transport or application level has been successful. In contrast, confirmations may be outside the bounds of a transaction (e.g., confirming receipt of an order). In one embodiment, the HCF may supports various types of acknowledgements. For example, the default may be no acknowledgement (e.g., none). Alternatively, there may be system acknowledgement (e.g., by business objects), application acknowledgement (by application layer) and/or a combination of system and application acknowledgement.</p>
<p id="p-0060" num="0059">The various computer systems described herein may each include a storage component for storing machine-readable instructions for performing the various processes as described and illustrated. The storage component may be any type of machine readable medium (i.e., one capable of being read by a machine) such as hard drive memory, flash memory, floppy disk memory, optically-encoded memory (e.g., a compact disk, DVD-ROM, DVD&#xb1;R, CD-ROM, CD&#xb1;R, holographic disk), a thermomechanical memory (e.g., scanning-probe-based data-storage), or any type of machine readable (computer readable) storing medium. Each computer system may also include addressable memory (e.g., random access memory, cache memory) to store data and/or sets of instructions that may be included within, or be generated by, the machine-readable instructions when they are executed by a processor on the respective platform. The methods and systems described herein may also be implemented as machine-readable instructions stored on or embodied in any of the above-described storage mechanisms.</p>
<p id="p-0061" num="0060">Although the present invention has been described with reference to particular examples and embodiments, it is understood that the present invention is not limited to those examples and embodiments. Further, those embodiments may be used in various combinations with and without each other. The present invention as claimed therefore includes variations from the specific examples and embodiments described herein, as will be apparent to one of skill in the art.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A computer-implemented method for event-based asynchronous communication:
<claim-text>generating events in an application layer of a computer software system, the application layer including user interface elements and modules that are responsive to user interactions, the computer software system running on a computer implementing a healthcare communication framework (HCF), the events being requests to asynchronously invoke service operations exported by another computer software system;</claim-text>
<claim-text>storing the generated events in a database table; and</claim-text>
<claim-text>scanning the database table by a process of the healthcare communication framework at a time after the generated events are stored, the process being run as part of the healthcare communication framework, wherein during each scan the process is configured to:
<claim-text>group the events in the database table into packages based on a predetermined criteria,</claim-text>
<claim-text>for each package:
<claim-text>check consistency for each event contained in the package, the consistency check determining whether relevant context information is provided in each event,</claim-text>
<claim-text>apply a consolidation logic to consolidate events contained in the package, wherein the consolidation logic determines whether multiple events invoke a respective service and combines later events of the multiple events into a first event of the multiple events to consolidate invocation of the respective service,</claim-text>
<claim-text>determine services operations associated with the consolidated events and each event not being consolidated, and</claim-text>
<claim-text>invoke the service operations asynchronously.</claim-text>
</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the scanning process is run at fixed time intervals periodically.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the predetermined criteria is patient identifiers.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the consolidation logic uses patterns based on business object and context to perform consolidation.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the patterns comprise same business object, same context and same action; same business object, same context and a creation action plus a change action; and same business object, same context and a creation action plus a cancel action.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the consolidation logic mark each later event of the multiple events being consolidated as processed.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein to determine services operations associated with each event comprises filling a field corresponding to a respective event in the package with a nest structure, the nested structure containing service operations to be invoked for the respective event.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein to invoke the service operations asynchronously comprises:
<claim-text>generating a respective message for each service operation;</claim-text>
<claim-text>filling nodes of the respective message with data to be used by the service operation;</claim-text>
<claim-text>placing the message in a message queue.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein to invoke the service operations asynchronously further comprises processing a message from the message queue by invoking the service operation on a proxy representing the service operation.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the message queue is a named queue.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the healthcare communication framework ensures invocation on service operations exactly once in order (EOIO).</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein healthcare communication framework comprises a personal object work list to display message histories on a display device.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the process implements exception handling that stores error raised by any steps of the process into an errors table.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the healthcare communication framework is activated at an institutional level.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the process scans the errors table as well as the events table at fixed intervals.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The method of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein each alert in the alert management comprises a text description and a call stack.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the healthcare communication framework stores the operation services exported by software systems in database tables.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the healthcare communication framework comprises an alert management that provides a central notification system.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. A system for event-based asynchronous communication, comprising:
<claim-text>a memory;</claim-text>
<claim-text>a processor configured to execute machine codes capable of:
<claim-text>generating events in an application layer of a computer software system, the application layer including user interface elements and modules that are responsive to user interactions, the computer software system running on a computer implementing a healthcare communication framework (HCF), the events being requests to asynchronously invoke service operations exported by another computer software system;</claim-text>
<claim-text>storing the generated events in a database table; and</claim-text>
<claim-text>scanning the database table by a process of the healthcare communication framework at a time after the generated events are stored, the process being part of the healthcare communication framework, wherein during each scan the process is configured to:
<claim-text>group the events in the database table into packages based on a predetermined criteria,</claim-text>
<claim-text>for each package:
<claim-text>check consistency for each event contained in the package, the consistency check determining whether relevant context information is provided in each event,</claim-text>
<claim-text>apply a consolidation logic to consolidate events contained in the package, wherein the consolidation logic determines whether multiple events invoke a respective service and combines later events of the multiple events into a first event of the multiple events to consolidate invocation of the respective service,</claim-text>
<claim-text>determine services operations associated with the consolidated events and each event not being consolidated, and</claim-text>
<claim-text>invoke the service operations asynchronously.</claim-text>
</claim-text>
</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. A non-transitory computer-readable medium including instructions adapted to be execute to implement a method for event-based asynchronous communication, the method comprising:
<claim-text>generating events in an application layer of a software system, the application layer including user interface elements and modules that are responsive to user interactions, the software system running on a computer implementing a healthcare communication framework (HCF), the events being requests to asynchronously invoke service operations exported by another software system;</claim-text>
<claim-text>storing the generated events in a database table; and</claim-text>
<claim-text>scanning the database table by a process of the healthcare communication framework at a time after the generated events are stored, the process being part of the healthcare communication framework, wherein during each scan the process is configured to:
<claim-text>group the events in the database table into packages based on a predetermined criteria,</claim-text>
<claim-text>for each package:
<claim-text>check consistency for each event contained in the package, the consistency check determining whether relevant context information is provided in each event,</claim-text>
<claim-text>apply a consolidation logic to consolidate events contained in the package, wherein the consolidation logic determines whether multiple events invoke a respective service and combines later events of the multiple events into a first event of the multiple events to consolidate invocation of the respective service,</claim-text>
<claim-text>determine services operations associated with the consolidated events and each event not being consolidated, and</claim-text>
<claim-text>invoke the service operations asynchronously. </claim-text>
</claim-text>
</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
