<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08626984-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08626984</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12257546</doc-number>
<date>20081024</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>484</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>12</main-group>
<subgroup>08</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>711103</main-classification>
<further-classification>711101</further-classification>
<further-classification>710 62</further-classification>
</classification-national>
<invention-title id="d2e53">Method and system for device independence in storage device wear algorithms</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>2008/0189485</doc-number>
<kind>A1</kind>
<name>Jung et al.</name>
<date>20080800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711115</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>2009/0300238</doc-number>
<kind>A1</kind>
<name>Panabaker et al.</name>
<date>20091200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710 62</main-classification></classification-national>
</us-citation>
</us-references-cited>
<number-of-claims>28</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>7</number-of-drawing-sheets>
<number-of-figures>7</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20100106888</doc-number>
<kind>A1</kind>
<date>20100429</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Pack</last-name>
<first-name>Gordon F.</first-name>
<address>
<city>Sunnyvale</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Pack</last-name>
<first-name>Gordon F.</first-name>
<address>
<city>Sunnyvale</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Campbell Stephenson LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Cisco Technology, Inc.</orgname>
<role>02</role>
<address>
<city>San Jose</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Otto</last-name>
<first-name>Alan</first-name>
<department>2182</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A device, methods and systems that provide device independence in storage device wear algorithms are disclosed. A storage device that provides such device independence includes a device-specific wear algorithm, and may also include an integrated wear algorithm. The device-specific wear algorithm is configured to be loaded into a wear algorithm space and is at least a portion of a wear algorithm. The device-specific wear algorithm is stored in the storage device. The integrated wear algorithm, if employed, is resident in the storage device. A method that provides such device independence is also disclosed. The method includes loading a device-specific wear algorithm from a storage device into a wear algorithm space. The device-specific wear algorithm is configured to be stored in the storage device and loaded into the wear algorithm space. The device-specific wear algorithm is at least a portion of a wear algorithm.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="189.40mm" wi="275.42mm" file="US08626984-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="274.83mm" wi="188.30mm" orientation="landscape" file="US08626984-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="276.27mm" wi="189.74mm" file="US08626984-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="260.52mm" wi="177.63mm" file="US08626984-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="239.10mm" wi="138.09mm" file="US08626984-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="254.00mm" wi="120.99mm" file="US08626984-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="227.92mm" wi="160.02mm" file="US08626984-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="261.87mm" wi="173.06mm" file="US08626984-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0002" num="0001">1. Field of the Invention</p>
<p id="p-0003" num="0002">This invention relates to the field of storage devices, and more particularly to device independence in wear algorithms for storage devices.</p>
<p id="p-0004" num="0003">2. Background</p>
<p id="p-0005" num="0004">As electronic devices have continued to shrink in size, such devices have become increasingly popular, and so, ubiquitous. The desire for smaller devices has necessitated smaller storage devices. Smaller storage devices have a tendency to use their storage media more intensively, from a physical perspective. Intensive use of only a portion of the storage device's storage media can cause premature failure in certain storage devices. One solution is to more evenly distribute accesses to the storage device through the use of wear-leveling algorithms.</p>
<p id="p-0006" num="0005">For example, such wear-leveling algorithms are important in the operation of semiconductor memories. One example of a memory type that benefits from the use of wear-leveling algorithms is a type of Electrically Erasable Programmable Read-Only Memory (EEPROM) known as flash memory. Flash memory can be used, for example, in memory cards and Universal Serial Bus (USB) storage devices, for the general storage and transfer of data between computers and other digital products.</p>
<p id="p-0007" num="0006">Endurance is one of the key aspects of flash memory technology, describing the number of program and erase cycles that can be performed on a given physical block of the flash memory before that physical block wears out. The goal of wear-leveling algorithms is to evenly spread the program and erase cycles among the available blocks in the flash memory's memory array. Such wear leveling avoids a worn-out block compromising the reliability of the entire storage device. By spreading out the locations at which the program and erase cycles occur, such failures can be minimized. This is of importance, for example, in applications that treat such storage devices as fixed-media devices (e.g., the use of flash memory as a hard-disk drive). Such applications will typically attempt to localize read and write operations with the intention of improving a hard-disk drive's performance and efficiency, while reducing the physical stress experienced by the hard-disk drive. In a flash memory device, however, this has the opposite effect on reliability, while offering no particular benefits with regard to efficiency.</p>
<p id="p-0008" num="0007">Wear-leveling algorithms thus seek to prevent the early deterioration of flash memory blocks hosting dynamic data due to the high cell stress induced by the frequent program and erase cycles that would otherwise be performed repeatedly on such blocks. This can be achieved, for example, by maintaining a block mapping table in the flash memory controller's memory. The block mapping table, implementing the wear-leveling algorithm employed, dynamically binds the block logical address to an alternative physical address. Of necessity, the wear-leveling algorithm (or more simply, the wear algorithm) is generic in nature, as a given flash memory device may be used in any one of a number of applications. Moreover, the wear algorithm used in a given device is designed to provide only a certain level of reliability (and thus, a given wear algorithm may not achieve the highest possible reliability for the given device, particularly when used in a specific application).</p>
<p id="p-0009" num="0008">As a result, the wear algorithm provided in a given flash memory is likely to be less than optimal than for one or more specific applications accessing the storage device. However, it will be appreciated that neither the manufacturer's creation nor their implementation of multiple wear algorithms for a given storage device is practical (or even possible) alternative, given the wide array of uses to which such a storage device might be put. There is no way for the manufacturer to determine the manner in which a given storage device will be used, nor is it possible for the manufacturer to determine the optimal wear algorithm for each such use.</p>
<p id="p-0010" num="0009">Equally difficult is the position of the original equipment manufacturer (OEM). Having multiple sources of storage devices for a given piece of equipment being manufactured, the OEM must provide some large number of device drivers, if the optimal lifetime is to be coaxed from the storage device actually installed in the equipment. This situation leads to bloating of the operating system's software. Moreover, the use of a new storage device and/or application will likely entail the addition of yet more device drivers, in order to maintain the storage device's lifetime. The need for device driver installation is particularly untenable in an end-user environment, and may well be either impractical or impossible in such circumstances. This situation leaves the OEM in a predicament&#x2014;make no changes to the storage device and its use, or change the operating system software as needed. A solution to the dilemma presented by the desire for optimal storage device lifetime with flexibility in the use and replacement of such storage devices is therefore desirable.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0002" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0011" num="0010">Embodiments of the present invention may be better understood, and numerous objects, features, and advantages made apparent to those skilled in the art by referencing the accompanying drawings.</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram illustrating an example of a storage architecture according to embodiments of the present invention.</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 2</figref> is a flow diagram illustrating an example of a process for using a wear algorithm according to embodiments of the present invention.</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 3</figref> is a flow diagram illustrating an example of a process for determining the availability of wear algorithm(s) according to embodiments of the present invention.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 4</figref> is a flow diagram illustrating an example of a process for loading a device-specific wear algorithm according to embodiments of the present invention.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 5</figref> is a flow diagram illustrating an example of a process for loading a generic wear algorithm according to embodiments of the present invention.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 6</figref> is a flow diagram illustrating an example of a process for using a loaded wear algorithm according to embodiments of the present invention.</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 7</figref> is a flow diagram illustrating an example of a process of accessing a storage device using a loaded wear algorithm according to embodiments of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<p id="p-0019" num="0018">The use of the same reference symbols in different drawings indicates similar or identical items.</p>
<heading id="h-0003" level="1">DESCRIPTION OF EXAMPLE EMBODIMENTS</heading>
<p id="p-0020" num="0019">The following is intended to provide a detailed description of an example of the invention and should not be taken to be limiting of the invention itself. Rather, any number of variations may fall within the scope of the invention which is defined in the claims following the description.</p>
<p id="h-0004" num="0000">Introduction</p>
<p id="p-0021" num="0020">Embodiments of the present invention provide a method and system that provide an operating system with access to a given storage device, while improving the storage device's wear characteristics beyond that typically provided by integrated wear algorithms. Embodiments of the present invention provide this and other advantages by employing a device-specific wear algorithm (or portion thereof, such as one or more sub-algorithms, parameter sets or the like) stored in the storage device. Such a device-specific wear algorithm can be stored, for example, in either a dedicated storage area, or in the storage device's main storage area. The device-specific wear algorithm is then loaded into the operating system, device driver or the like. The loaded device-specific wear algorithm can then be used to access the device. The storage of a device-specific wear algorithm (DSWA) in the given storage device allows an operating system (typically a device driver thereof) to maintain code that is generic to the storage device, while being able to access the storage device in a manner that provides an improved lifespan, as compared to simply performing such accesses using the integrated wear algorithm resident in the storage device.</p>
<p id="p-0022" num="0021">Embodiments of the present invention provide several advantages. One advantage is device-independence. Embodiments of the present invention provide wear algorithms optimized for a given storage device (and even application), while simplifying the operating system and obviating the need for operating system/device driver upgrades to support different storage devices. Wear performance is improved even in systems supporting a variety of applications, high-availability systems, and the like. Moreover, storage devices having a wide range of reliability can be used, by allowing the designer (or system) to employ a variety of wear algorithms, in order to tailor the wear algorithm employed to the application at hand. Further, if a generic portion of a wear algorithm is maintained in a device driver, for example, only device-specific portion (sub-algorithm(s), parameter(s) or the like) need be maintained in the storage device. In one scenario, a number of storage devices can be supported using the same generic wear algorithm, but different parameters. In this case, the requisite parameters are retrieved from the storage device in use, and the loaded wear algorithm employed to good effect in accessing the given storage device.</p>
<p id="p-0023" num="0022">It will also be appreciated, in light of the present disclosure, that not only the lifespan, but also the performance of a storage device can be improved by changing the manner in which the storage device is accessed. For example, an improved sector selection algorithm can improve wear algorithm performance. Using embodiments of the present invention, such alternate algorithms can be incorporated in device drivers or other software modules loaded from the storage device. Such algorithms enable the operating system and other software in the computer system to remain unchanged, and so, storage device independent. As will be appreciated from the discussions that follow, the present invention is not restricted to wear algorithms. Software components, whether or not stored in the storage device, can be employed to enhance and/or change other storage device characteristics, once loaded. These and other advantages will be apparent from the following examples.</p>
<p id="h-0005" num="0000">An Example Storage Architecture</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram illustrating an example of a storage architecture <b>100</b> according to embodiments of the present invention. As depicted in <figref idref="DRAWINGS">FIG. 1</figref>, storage architecture <b>100</b> includes a computing device <b>105</b>. Computing device <b>105</b>, in turn, includes a processing system <b>110</b> and a storage device <b>115</b>. Processing system <b>110</b> is configured to execute an operating system <b>120</b>. Operating system <b>120</b> accesses storage device <b>115</b> via a device driver <b>125</b>. Device driver <b>125</b> is configured to load a wear algorithm (WA) using a loader <b>130</b> that loads the wear algorithm into a wear algorithm space <b>135</b>. The wear algorithm thus loaded appears in <figref idref="DRAWINGS">FIG. 1</figref> as a loaded wear algorithm <b>140</b>. As will be appreciated in light of the present disclosure, the information loaded into wear algorithm space <b>135</b> as loaded wear algorithm <b>140</b> need not be a complete wear algorithm. Loaded wear algorithm <b>140</b> can be a portion of a wear algorithm or simply one or more of the parameters used in a wear algorithm, for example. Among other elements, operating system <b>120</b> is able to access loaded wear algorithm <b>140</b> via a wear algorithm application programming interface (API) <b>145</b>.</p>
<p id="p-0025" num="0024">Storage device <b>115</b> includes a storage area <b>150</b> that is made available to operating system <b>120</b> via device driver <b>125</b>, for purposes of storing and retrieving information for use by operating system <b>120</b>. Typically, a storage device such as storage device <b>115</b> will include a wear algorithm provided by the manufacturer of storage device <b>150</b>. Such a wear algorithm is depicted in <figref idref="DRAWINGS">FIG. 1</figref> as an integrated wear algorithm <b>155</b>. Integrated wear algorithm <b>155</b> is stored in storage device <b>115</b> in an integrated wear algorithm storage area <b>160</b>. As will appreciated, in light of the present disclosure, integrated wear algorithm storage area <b>160</b> can in fact be subsumed in storage area <b>150</b>. Integrated wear algorithm <b>155</b> is resident in storage device <b>115</b>, and so is configured to operate from within storage device <b>115</b>.</p>
<p id="p-0026" num="0025">Integrated wear algorithm <b>155</b> can, for example, reduce or partially offset the effects of multiple program and erase cycles on a given block (or sector) by counting the number of program and erase cycles, and dynamically remapping the block(s) (or sector(s)) in order to spread the write operations between the sectors. Another approach is to perform write verification and remapping to spare sectors in case of a write failure, a technique called bad block management (BBM). For portable consumer devices, these wear management techniques can extend the life of the flash memory beyond the life of the device itself. Moreover, a given amount of data loss may be more acceptable in certain applications, thereby making failures more tolerable. For data storage, however, such failures are typically catastrophic. Thus, simply using the storage device OEM's wear algorithm (e.g., integrated wear algorithm <b>155</b>) is not advisable, particularly if the storage device will be subject to a relatively large number of program and erase cycles.</p>
<p id="p-0027" num="0026">Storage device <b>115</b> also provides a storage area for a device-specific wear algorithm (depicted in <figref idref="DRAWINGS">FIG. 1</figref> as a device-specific wear algorithm storage area <b>165</b>). As will be appreciated, in light of the present disclosure, device-specific wear algorithm storage area <b>165</b> can subsumed in storage area <b>150</b>. A device-specific wear algorithm (DSWA) <b>170</b> is stored in DSWA storage area <b>165</b>. This can be, for example, a modified sector (or block) selection algorithm, or other algorithm. In fact, it will be appreciated that while integrated wear algorithm <b>155</b> is a complete wear algorithm (and so ready for use in accessing storage device <b>115</b>), DSWA <b>170</b> need not necessarily be a complete wear algorithm. Although DSWA <b>170</b> can be a complete wear algorithm, DSWA <b>170</b> can also be only a portion of a wear algorithm or simply one or more of the parameters used in a wear algorithm.</p>
<p id="p-0028" num="0027">As noted, the result of loading of a wear algorithm (e.g., DSWA <b>170</b> or generic WA <b>175</b>) into wear algorithm space <b>135</b> is depicted as loaded wear algorithm <b>140</b>. In a similar manner, a generic WA portion <b>180</b> can be loaded into wear algorithm space <b>135</b> using loader <b>130</b>. This results in a loaded generic WA portion <b>185</b>. The loading of generic WA portion <b>180</b> may be necessitated, for example, by DSWA <b>170</b> being something less than a complete wear algorithm (e.g., resulting from a generic WA portion being employed). This may be the case, for example, when a wear algorithm needs only parameters to provide support for the various devices to be employed. Thus, loaded wear algorithm <b>140</b> can be a portion of a wear algorithm, or one or more parameters, in which case generic WA portion <b>180</b> is needed. In the alternative, loaded wear algorithm <b>140</b> can be a complete wear algorithm, and, once loaded, obviate the need for any generic WA portion. It will also be appreciated that, in the alternative, generic WA portion <b>180</b> can be executed from its initial location.</p>
<p id="p-0029" num="0028">Operating system <b>120</b> is able to access loaded wear algorithm <b>140</b> in wear algorithm space <b>135</b> via wear algorithm application programming interface (API) <b>145</b>. Operating system <b>120</b> is also able to access and control loader <b>130</b> via WA API <b>145</b>, in order to control the loading of one or more wear algorithms (e.g., loading a wear algorithm into wear algorithm space <b>135</b>). Once the wear algorithm(s) have been loaded, operating system <b>120</b> is also able to control their operation via WA API <b>145</b>.</p>
<p id="p-0030" num="0029">In an example of the operation of storage architecture <b>100</b>, device driver <b>125</b> loads DSWA <b>170</b> into WA space <b>135</b> (and thus, the copy of DSWA <b>170</b> loaded into WA space <b>135</b> is thus loaded WA <b>140</b>). However, if storage device <b>115</b> does not contain a device-specific wear algorithm or device-specific wear algorithm <b>170</b> is corrupted, a generic wear algorithm <b>175</b> can be provided, for example, as part of device driver <b>125</b>. In the situation in which DSWA <b>170</b> does not exist or cannot be loaded for some reason, generic WA <b>175</b> is loaded into WA space <b>135</b>, a copy of which then exists in WA space <b>135</b> as loaded WA <b>140</b>. One of skill in the art will appreciate that, in light of the present disclosure, device driver <b>125</b> can be characterized as including a generic portion of the software needed to provide wear leveling capabilities to operating system <b>120</b>. This makes operating system <b>120</b> (and device driver <b>125</b>) device independent, by allowing generic portions of one or more wear algorithms to be included as part of the operating system/device driver employed. By contrast, the device-dependent (device-specific) portion of the wear algorithm can be stored on the storage device and retrieved when this portion is needed. The device-dependent (device-specific) portion of the software, needed to provide wear leveling capabilities to operating system <b>120</b>, is represented by DSWA <b>170</b>. It will be appreciated that, as noted elsewhere, this device-specific portion can in fact be the entire wear algorithm, a portion thereof or simply one or more parameters.</p>
<p id="p-0031" num="0030">In fact, as will be appreciated in light of the present disclosure, it is possible to download loaded wear algorithm <b>140</b> and/or loaded generic WA portion <b>180</b> to storage device <b>115</b> (and, more specifically, to DSWA storage area <b>165</b>). For example, certain embodiments allow loaded wear algorithm <b>140</b> and loaded generic WA portion <b>180</b> to be treated as a single, complete wear algorithm. Such might be the case, for example, if loaded wear algorithm <b>140</b> included only parameters for the wear algorithm employed. In that case, loaded generic WA portion <b>180</b> would be updated with the parameters from loaded wear algorithm <b>140</b>, and then downloaded to storage device <b>115</b>. In operation, the wear algorithm thus stored in storage device <b>115</b> would be an updated version of loaded generic WA portion <b>180</b>. Alternatively, if loaded wear algorithm <b>140</b> and loaded generic WA portion <b>180</b> we portions of a wear algorithm (e.g., the code representing one or more formulas, and the code for the remaining portion of the wear algorithm, for example), these separate portions can be merged with one another, and the resulting wear algorithm downloaded to storage device <b>115</b>. It will be appreciated, however, that if DSWA storage area <b>165</b> were subsumed in storage area <b>150</b>, DSWA storage area <b>165</b> could be exposed to the risk of failure comparable to that of the blocks/sectors of storage area <b>150</b>.</p>
<p id="p-0032" num="0031">In certain situations, applications uniformly update data in the given storage device (e.g., the storage of photographs in a digital camera, which are subsequently downloaded from the storage device and then deleted). In this case, the storage device is more evenly worn than might otherwise be the case, and the device-specific optimizations of the selected device-specific wear algorithm will take this into consideration. Non-volatile memory devices (e.g., flash memory devices) have also come into widespread use in laptop and desktop computers, for example, to the point of completely replacing hard-drives in some systems. In such systems, a variety of applications will potentially make use of such storage devices (e.g., the operating system, word-processing applications, spreadsheet applications, database applications and so on). Such applications can cause a variety of wear patterns, particularly when such storage devices are dealt with as hard-drives by operating systems. The selected device-specific wear algorithm will take this into account by more aggressively spreading out the program/erase cycles. Such effects can be even more pronounced in specific applications: dedicated systems (e.g., network devices), high-availability systems and other such applications. In such applications, the storage device's lifespan can be unexpectedly short in light of the workloads placed on the storage device. By loading a storage device with multiple device-specific wear algorithms, the storage device can provide a lifespan optimized for the given application(s).</p>
<p id="p-0033" num="0032">In fact, multiple device-specific wear algorithms can be stored in the storage device, and given one of the device-specific wear algorithms loaded, based on the age of the storage device (e.g., the number of program/erase cycles to which the storage device has been subjected). In this scenario, each of the device-specific wear algorithms is optimized for a given range of program/erase cycles. As will be appreciated, in light of the present disclosure, a wide variety of effects can be taken into consideration in creating the device-specific wear algorithms, and their combination (e.g., using multiple device-specific wear algorithms) is contemplated hereby.</p>
<p id="p-0034" num="0033">A device-specific wear algorithm can be fashioned in a number of ways. Wear algorithms in common use can be divided, for example, as follows. It will be apparent in light of the present disclosure that other alternatives can be devised, both for the wear algorithms discussed below, as well as other wear algorithms. In hot-cold swapping, one can load the predefined threshold that is used to determine when oldest and youngest blocks are swapped. In static-dynamic swapping, the predefined threshold used in the HC swapping can be loaded, for use in static mode, while the round-robin parameters used in the dynamic mode can also be made loadable. In a two-level replacement scheme, the predefined threshold used in the second level of replacement can be made loadable. With a replacement by formula scheme, the parameters for the given formula used, or even the entire formula can be made loadable. In a CAT approach, the parameters for the pre-tuned aging function (and/or the pre-tuned aging function itself) can be made loadable. For turn-based selection, values for the x and y parameters used in selecting a block/sector can be loaded, as can the decision to select blocks/sectors randomly or by selecting the next block/sector with all live data (or some other selection scheme). With old-block protection, the predefined threshold employed can be made loadable. These and other alternatives will be apparent, in light of the present disclosure.</p>
<p id="p-0035" num="0034">More generally, the selection of the next sector to be used by the operating system can be altered, in order to more evenly distribute program/erase cycles. This holds true not just for sector selection, but also by incrementing the sector number in a write block in the device. For writes to small blocks, then, the writes are packed in one after the other, and thus do not use a larger write block for small files. Another alternative is to read wear statistics (if available) from the device, and then write to less worn areas or move blocks which are read only to high-wear areas.</p>
<p id="p-0036" num="0035">Of course, it will be apparent in light of the present disclosure that a given wear algorithm can be loaded in whole or in part, along with the parameters discussed herein. Moreover, not only can the device-specific wear algorithm be loaded in toto, but may also have one of several sub-portions and/or parameter sets loaded. Further still, the wear algorithm employed can be selected from a number of such wear algorithms, and then a specific parameter set loaded for the given application. Many such permutations will be apparent in light of the present disclosure.</p>
<p id="p-0037" num="0036">It will also be appreciated, in light of the present disclosure, that the storage device's integrated wear algorithm and a device-specific wear algorithm for the storage (and application(s), if such is the case) need not employ the same wear algorithm. Conversely, the device-specific wear algorithm and the integrated wear algorithm can employ the same wear algorithm, albeit with different parameters. Also, the device-specific wear algorithm will typically be designed such that the use of the storage device's integrated wear algorithm and other effects are taken into account. As noted elsewhere herein, such effects include which of the integrated wear algorithm and the device-specific wear algorithm are invoked first.</p>
<p id="p-0038" num="0037">It will be noted that variable identifiers (e.g., &#x201c;N&#x201d;) are used in several instances in the figures described herein to more simply designate the final element of a series of related or similar elements. The repeated use of such variable identifiers is not meant to necessarily imply a correlation between the sizes of such series of elements, although such correlation may exist. The use of such variable identifiers does not require that each series of elements has the same number of elements as another series delimited by the same variable identifier. Rather, in each instance of use, the variable identified (e.g., by &#x201c;N&#x201d; or any other such identifier) may represent the same or a different value than other instances of the same variable identifier.</p>
<p id="p-0039" num="0038">Moreover, regarding the signals described herein, those skilled in the art will recognize that a signal may be directly transmitted from a first block to a second block, or a signal may be modified (e.g., amplified, attenuated, delayed, latched, buffered, inverted, filtered or otherwise modified) between the blocks. Although the signals of the above described embodiment are characterized as transmitted from one block to the next, other embodiments of the present invention may include modified signals in place of such directly transmitted signals as long as the informational and/or functional aspect of the signal is transmitted between blocks. To some extent, a signal input at a second block may be conceptualized as a second signal derived from a first signal output from a first block due to physical limitations of the circuitry involved (e.g., there will inevitably be some attenuation and delay). Therefore, as used herein, a second signal derived from a first signal may be the first signal, or a modification of the first signal, whether due to circuit limitations or due to passage through other circuit elements which do not change the informational and/or final functional aspect of the first signal.</p>
<p id="h-0006" num="0000">An Example of the Operation of a Device-Specific Wear Algorithm</p>
<p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. 2</figref> is a flow diagram illustrating an example of a process for using a wear algorithm according to embodiments of the present invention. The process begins with a determination as to the availability of a wear algorithm specific to the type of storage device in use (e.g., storage device <b>115</b>) and, in some embodiments, the application(s) that will be accessing the storage device (step <b>200</b>). This process is described in greater detail in connection with <figref idref="DRAWINGS">FIG. 3</figref>. If a device-specific wear algorithm is available for the given storage device and application (step <b>205</b>), a device-specific wear algorithm (e.g., DSWA <b>170</b>) is loaded by the device driver (e.g., device driver <b>125</b>) from the storage device (e.g., storage device <b>115</b>) into the device driver's wear algorithm space (e.g., wear algorithm space <b>135</b>, such that DSWA <b>170</b> appears as loaded wear algorithm <b>140</b>) (step <b>210</b>). The process of loading a device-specific wear algorithm from the storage device is described in greater detail in connection with <figref idref="DRAWINGS">FIG. 4</figref>.</p>
<p id="p-0041" num="0040">Another determination is made as to whether or not to load a generic WA portion (step <b>211</b>). If a generic WA portion is to be loaded (e.g., DSWA <b>170</b> is only a portion of the given wear algorithm), a generic WA portion is loaded into the device driver's wear algorithm space (step <b>212</b>). Such is the case if, for example, the generic WA portion is complete except for the parameters to be used. The DSWA loaded in such a scenario will provide the requisite parameters. Alternatively, it may be determined that a generic WA portion need not be loaded (step <b>211</b>). This may be the case if, for example, the DSWA loaded is a complete algorithm. The operations performed closely parallel those of <figref idref="DRAWINGS">FIG. 4</figref>, save for the fact that the generic WA portion is loaded from within the device driver.</p>
<p id="p-0042" num="0041">A number of permutations with thus be evident, in light of the present disclosure. Though not shown in <figref idref="DRAWINGS">FIG. 2</figref>, it will be appreciated that multiple DSWA's can be provided within and for a given storage device. This allows the appropriate DSWA to be selected and loaded as part of the process depicted in <figref idref="DRAWINGS">FIG. 2</figref>. In so doing, optimized storage device lifetime can be maintained in a multi-application environment, while supporting access to the storage device by these various applications.</p>
<p id="p-0043" num="0042">Another possibility is maintaining and/or determining information regarding the state of the storage device's memory blocks/sectors (either individually or by grouping the memory blocks/sectors), and then using that information to determine which of a number of DSWA's to use. Such a determination can be based on the age of the device or memory blocks (e.g., in terms of program/erase cycles for an individual memory block/sector, a group of memory blocks/sectors, or the storage device), the difference between most- and least-worn memory blocks/sectors, the amount of data held in each such memory block/sector (or group thereof), or through the use of other such metrics. A variety of adaptive techniques can thus be implemented in embodiments of the present invention. Moreover, these and other metrics can also be used as an input to a given wear algorithm, allowing for the implementation of self-adapting wear algorithms. In light of the present disclosure, these and other alternatives will be apparent to one of skill in the art.</p>
<p id="p-0044" num="0043">The wear algorithm thus loaded is then integrated into the device driver/operating system, and so made available for use by the operating system in accessing the storage device (step <b>230</b>). The process of integrating the wear algorithm into the device driver/operating system is discussed in greater detail in connection with <figref idref="DRAWINGS">FIG. 6</figref>. If the device-specific wear algorithm is not complete, it is at this point that the device-specific wear algorithm and generic wear algorithm portion can also be integrated with one another. For example, the device-specific wear algorithm can simply provide parameter values for the generic wear algorithm portion. Integration of the device-specific wear algorithm and generic wear algorithm portion can be accomplished by inserting the parameter values into the generic wear algorithm portion, resulting in a wear algorithm that is complete. The device driver is then able to provide the operating system with access to the storage device, in a manner that provides improved lifespan as compared to such access without the use of such a wear algorithm. In accessing the storage device, then, the operating system employs the wear algorithm loaded into the wear algorithm space of the device driver (step <b>220</b>).</p>
<p id="p-0045" num="0044">If a device-specific wear algorithm is unavailable for some reason (step <b>205</b>), a determination is made as to whether a generic wear algorithm is available (e.g., generic wear algorithm <b>175</b>) (step <b>225</b>). Though not shown, it will be appreciated that, in light of the present disclosure, a determination can also be made to always use a generic wear algorithm, regardless of the availability of a DSWA. If a generic wear algorithm is available (step <b>225</b>), the generic wear algorithm is loaded into the wear algorithm space of the device driver (step <b>230</b>). The process of loading a generic wear algorithm is described in further detail in connection with <figref idref="DRAWINGS">FIG. 5</figref>.</p>
<p id="p-0046" num="0045">If neither a device-specific wear algorithm (step <b>205</b>) nor a generic wear algorithm (step <b>225</b>) are available, a determination is made as to whether the user should be notified as to the lack of a wear algorithm that can be loaded into the wear algorithm space of the device driver (step <b>235</b>). If such notification is desired, the user is notified that neither a generic nor a device-specific wear algorithm is available (step <b>240</b>). Though not shown, it will be appreciated that such notification can be provided as to the unavailability of the generic wear algorithm or device-specific wear algorithm, taken alone. Otherwise, no such notification is provided. If operating the storage device without either a generic wear algorithm or a device-specific wear algorithm is acceptable (step <b>245</b>), access to the storage device is provided using only the integrated wear algorithm that is provided with the storage device (or without, if no such integrated wear algorithm is provided) (step <b>220</b>). Otherwise, access to the storage device is not permitted. In fact, though not shown, it will also be appreciated that, in light of the present disclosure, a determination can be made not to use either a generic wear algorithm or a device specific wear algorithm, and so always rely on whatever integrated wear algorithm is stored within the storage device.</p>
<p id="p-0047" num="0046">As noted, <figref idref="DRAWINGS">FIG. 2</figref> depicts a flow diagram illustrating a process according to an embodiment of the present invention, as do other of the figures depicting flow diagrams that are discussed herein. It will be appreciated that operations discussed herein may consist of directly entered commands by a computer system user or by steps executed by application specific hardware modules. The functionality of steps referred to herein may correspond to the functionality of modules or portions of modules.</p>
<p id="p-0048" num="0047">The operations referred to herein may be modules or portions of modules (e.g., software, firmware or hardware modules). For example, although the described embodiment includes software modules and/or includes manually entered user commands, the various example modules may be application specific hardware modules. The software modules discussed herein may include script, batch or other executable files, or combinations and/or portions of such files. The software modules may include a computer program or subroutines thereof encoded on computer-readable media.</p>
<p id="p-0049" num="0048">Additionally, those skilled in the art will recognize that the boundaries between modules are merely illustrative and alternative embodiments may merge modules or impose an alternative decomposition of functionality of modules. For example, the modules discussed herein may be decomposed into submodules to be executed as multiple computer processes, and, optionally, on multiple computers. Moreover, alternative embodiments may combine multiple instances of a particular module or submodule. Furthermore, those skilled in the art will recognize that the operations described in example embodiment are for illustration only. Operations may be combined or the functionality of the operations may be distributed in additional operations in accordance with the invention.</p>
<p id="p-0050" num="0049">Alternatively, such actions may be embodied in the structure of circuitry that implements such functionality, such as the micro-code of a complex instruction set computer (CISC), firmware programmed into programmable or erasable/programmable devices, the configuration of a field-programmable gate array (FPGA), the design of a gate array or full-custom application-specific integrated circuit (ASIC), or the like.</p>
<p id="p-0051" num="0050">Each of the blocks of the flow diagram may be executed by a module (e.g., a software module) or a portion of a module or a computer system user. Thus, the above described method, the operations thereof and modules therefor may be executed on a computer system configured to execute the operations of the method and/or may be executed from computer-readable media. The method may be embodied in a machine-readable and/or computer-readable medium for configuring a computer system to execute the method. Thus, the software modules may be stored within and/or transmitted to a computer system memory to configure the computer system to perform the functions of the module.</p>
<p id="p-0052" num="0051">The software modules described herein may be received by a computer system, for example, from computer readable media. The computer readable media may be permanently, removably or remotely coupled to the computer system. The computer readable media may non-exclusively include, for example, any number of the following: magnetic storage media including disk and tape storage media; optical storage media such as compact disk media (e.g., CD-ROM, CD-R, DVD, etc.) and digital video disk storage media. nonvolatile memory storage memory including semiconductor-based memory units such as FLASH memory, EEPROM, EPROM, ROM or application specific integrated circuits. volatile storage media including registers, buffers or caches, main memory, RAM, and the like. In a UNIX-based embodiment, the software modules may be embodied in a file which may be a device, a terminal, a local or remote file, a socket, a network connection, or other expedient of communication or state change. Other new and various types of computer-readable storage media may be used to store and/or convey the software modules discussed herein.</p>
<p id="p-0053" num="0052"><figref idref="DRAWINGS">FIG. 3</figref> is a flow diagram illustrating an example of a process for determining the availability of wear algorithm(s) according to embodiments of the present invention. The process begins with a determination as to the type of storage device being used (step <b>300</b>). In some embodiments, a determination is also made as to the application(s) that will be using the storage device (step <b>310</b>). In such embodiments, the selected device-specific wear algorithm will take into account the manner in which the given application is expected to use the storage device's blocks/sectors.</p>
<p id="p-0054" num="0053">Next, a determination is made as to whether the selected device-specific wear algorithm is present in the storage device (step <b>320</b>). If the device-specific wear algorithm is present in the storage device (step <b>320</b>), an indication is made as to the availability of the selected device-specific wear algorithm for loading into the wear algorithm space of the device driver (step <b>330</b>). However, if the selected device-specific wear algorithm is not present in the storage device (step <b>320</b>), an indication is made as to the unavailability of the selected device-specific wear algorithm (step <b>340</b>). If the selected device-specific wear algorithm is not available (step <b>320</b>), a determination is made as to the availability of a generic wear algorithm (step <b>350</b>). If a generic wear algorithm is available (step <b>350</b>), an indication is made with regard to the availability of the generic wear algorithm for loading into the wear algorithm space of the device driver (step <b>360</b>). However, if a generic wear algorithm is also unavailable (step <b>350</b>), an indication is made with regard to the unavailability of the generic wear algorithm (step <b>370</b>).</p>
<p id="p-0055" num="0054"><figref idref="DRAWINGS">FIG. 4</figref> is a flow diagram illustrating an example of a process for loading a device-specific wear algorithm according to embodiments of the present invention. The process begins, for example, with a determination of the location of the selected device-specific wear algorithm in the given storage device (step <b>400</b>). The device-specific wear algorithm can be located in a dedicated DSWA storage area, or may be stored in the main storage area of the storage device, among other possible alternatives. Next, a determination is made as the location into which the selected device-specific wear algorithm is to be loaded (step <b>410</b>). This can be achieved, for example, by loading the device-specific wear algorithm into a wear algorithm space of the device driver (depicted in <figref idref="DRAWINGS">FIG. 1</figref> as wear algorithm space <b>135</b>, subsequently having loaded wear algorithm <b>140</b> stored therein). The loading of the selected device-specific wear algorithm into the wear algorithm space of the device driver is then performed (step <b>420</b>). The loading of the device-specific wear algorithm into the wear algorithm space continues until the device-specific wear algorithm has been loaded (step <b>430</b>).</p>
<p id="p-0056" num="0055"><figref idref="DRAWINGS">FIG. 5</figref> is a flow diagram illustrating an example of a process for loading a generic wear algorithm according to embodiments of the present invention. The process begins, for example, with a determination of the location of the selected generic wear algorithm in the given storage device (step <b>500</b>). As in the process of <figref idref="DRAWINGS">FIG. 4</figref>, the generic wear algorithm can be located in a dedicated wear algorithm storage area, or may be stored in the main storage area of the storage device, among other possible alternatives. Next, a determination is made as the location into which the selected generic wear algorithm is to be loaded (step <b>510</b>). This can be achieved, for example, by loading the generic wear algorithm into a wear algorithm space of the device driver. The loading of the selected generic wear algorithm into the wear algorithm space of the device driver is then performed (step <b>520</b>). The loading of the generic specific wear algorithm into the wear algorithm space continues until the generic wear algorithm has been loaded (step <b>530</b>).</p>
<p id="p-0057" num="0056"><figref idref="DRAWINGS">FIG. 6</figref> is a flow diagram illustrating an example of a process for using a loaded wear algorithm according to embodiments of the present invention. The process for using a loaded wear algorithm begins with an indication of the wear algorithm's availability to the device driver and/or operating system via the wear algorithm application programming interface (WA API) (step <b>600</b>). Next, wear algorithm operating parameters are received from the device and/or operating system (step <b>610</b>). While the storage device is available for access (step <b>620</b>), the storage device is accessed using the loaded wear algorithm (step <b>630</b>).</p>
<p id="p-0058" num="0057"><figref idref="DRAWINGS">FIG. 7</figref> is a flow diagram illustrating the process of performing a read operation or write operation according to embodiments of the present invention. The process of performing read and write operations begins with a determination as to whether the operation to be performed is a read operation or a write operation (step <b>700</b>). If the operation to be performed is a write operation, a call is made to the device driver to perform a write operation to the storage device (step <b>705</b>). Next, the device driver invokes the loaded wear algorithm that is stored in the wear algorithm space, in order to perform the write operation (step <b>710</b>).</p>
<p id="p-0059" num="0058">The device driver invokes the loaded wear algorithm via the wear algorithm API, which allows the device driver to access the storage device in a manner consistent with the wear polices implemented in the loaded wear algorithm. As will be appreciated in light of the present disclosure, accessing the storage device can be performed in the normal course, in the case in which only one of a device-specific or generic wear algorithm is loaded into the device driver. It will be further appreciated that the use of a generic wear algorithm and a device-specific wear algorithm can also be combined. Either of the wear algorithms can be accessed before the other, as appropriate. For example, in the case in which several given applications access the storage device, a generic wear algorithm can be employed, with a device-specific wear algorithm (specific to the application and storage device) accessed prior to accessing the generic wear algorithm. In such a scenario, the generic wear algorithm provides a generally better wear pattern than the storage device's integrated wear algorithm, while the device-specific wear algorithm fine-tunes the wear pattern for the given application and storage device. Moreover, it will be noted that a device driver can change the write sector number and store this information locally, as shown in <figref idref="DRAWINGS">FIG. 7</figref>. It will be appreciated that, in light of the present disclosure, such an operation performs a read translation. Alternatively, the operating system/device driver can be instructed to convert the sector number to the selected sector number. Using the latter approach, a read mapping is unnecessary.</p>
<p id="p-0060" num="0059">Once invoked, the loaded wear algorithm calculates the address(es) at which to perform the write operation (step <b>715</b>). Using the address(es) thus calculated, the device driver performs the requested write operation to the storage device (step <b>720</b>). The storage device then receives the write command, calculated address(es), and data from the device driver (step <b>725</b>). Using its integrated wear algorithm, the storage device calculates the internal address(es) from the calculated address(es) (step <b>730</b>). The storage device then performs the requested write operation, by storing the data sent by the device driver at the internal address(es) calculated from the calculated address(es) received from the device driver (step <b>735</b>). The write operation is then complete.</p>
<p id="p-0061" num="0060">In the case in which the requested operation is a read operation (step <b>700</b>), the device driver is called to perform a read operation from the storage device (step <b>740</b>). As will be appreciated, in light of the present disclosure, the address translations that occur in performing a read operation are similar to those that occur in performing a write operation according to embodiments of the present invention. Once the device driver is called to perform a read operation, the device driver invokes the loaded wear algorithm to perform certain of the address translation operations necessary to performing the read operation (step <b>745</b>). As before, the device driver invokes the loaded wear algorithm (stored in the wear algorithm space of the device driver) via a wear algorithm API, which allows the device driver access to the functionality provided by the loaded wear algorithm. The loaded wear algorithm then calculates address(es) at which the read operation is to be performed in the storage device (step <b>750</b>). The device driver then performs the read operation using these calculated address(es) (step <b>755</b>). The storage device receives the read command and calculated address(es) from the device driver (step <b>760</b>). Using its integrated wear algorithm, the storage device calculates internal address(es) from the calculated address(es) received from the device driver (step <b>765</b>). The storage device then performs the requested read operation using the internal address(es) calculated from the calculated address(es) received from the device driver (step <b>770</b>). The storage device then returns the data retrieved by the read operation to the device driver (step <b>775</b>). The read operation is then complete.</p>
<p id="p-0062" num="0061">While particular embodiments of the present invention have been shown and described, it will be obvious to those skilled in the art that, based upon the teachings herein, changes and modifications may be made without departing from this invention and its broader aspects and, therefore, the appended claims are to encompass within their scope all such changes and modifications as are within the scope of this invention. Moreover, while the invention has been particularly shown and described with reference to these specific embodiments, it will be understood by those skilled in the art that the foregoing and other changes in the form and details may be made therein without departing from the scope of the invention.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method implemented on a computing host processing system, the method comprising:
<claim-text>uploading device-specific wear algorithm code to the host processing system from a storage device coupled to the host processing system; and</claim-text>
<claim-text>configuring the device-specific wear algorithm code for execution on the host processing system, wherein
<claim-text>said host processing system comprises an operating system that is executed on said host processing system,</claim-text>
<claim-text>said operating system is configured to access said storage device via a device driver for said storage device,</claim-text>
<claim-text>said storage device also comprises an integrated wear algorithm provided by a manufacturer of the storage device and configured for execution on the storage device,</claim-text>
<claim-text>said integrated wear algorithm is not uploaded to the host processing system,</claim-text>
<claim-text>said device-specific wear algorithm code is specific to a type of said storage device,</claim-text>
<claim-text>said device-specific wear algorithm code is configured to be used to access said storage device, and</claim-text>
<claim-text>said device-specific wear algorithm code is at least a portion of a wear algorithm.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>configuring generic wear algorithm code stored on the host processing system for execution on the host processing system.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the generic wear algorithm code comprises a complete wear algorithm.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>accessing said storage device using said device-specific wear algorithm code.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of claim a <b>2</b>, further comprising:
<claim-text>accessing said storage device using said device-specific wear algorithm code and said generic wear algorithm code.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising:
<claim-text>accessing said storage device using said device-specific wear algorithm code executed on the host processing system, said generic wear algorithm code executed on the host processing system, and said integrated wear algorithm executed on the storage device.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>accessing said storage device using said integrated wear algorithm executed on the storage device.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising:
<claim-text>downloading said device-specific wear algorithm code back to said storage device; and</claim-text>
<claim-text>downloading said generic wear algorithm code to said storage device.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. A host processing system comprising:
<claim-text>a processor;</claim-text>
<claim-text>a storage interface, configured to be coupled to a storage device and coupled to said processor, wherein
<claim-text>said storage device comprises an integrated wear algorithm provided by the manufacturer of the storage device and configured for execution on the storage device,</claim-text>
<claim-text>said storage device comprises additional device-specific wear algorithm code,</claim-text>
<claim-text>said device-specific wear algorithm code is specific to a type of said storage device,</claim-text>
<claim-text>said device-specific wear algorithm code is configured to be uploaded from said storage device, and</claim-text>
<claim-text>said device-specific wear algorithm is further configured to be used to access said storage device; and</claim-text>
</claim-text>
<claim-text>a memory, coupled to said processor, wherein
<claim-text>said memory stores an operating system,</claim-text>
<claim-text>said operating system is configured to be executed by said processor,</claim-text>
<claim-text>said operating system is configured to access said storage device via a device driver for said storage device,</claim-text>
<claim-text>said processor is configured to upload said device-specific wear algorithm code, but not said integrated wear algorithm, from said storage device to said memory, and</claim-text>
<claim-text>wherein said processor is configured to configure said device-specific wear algorithm code for execution on the host processing system.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The computer host processing system of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein
<claim-text>said memory comprises a wear algorithm space, and</claim-text>
<claim-text>said processor is configured to configure said device-specific wear algorithm code for execution by storing the device-specific wear algorithm code in the wear algorithm space as a loaded wear algorithm, and</claim-text>
<claim-text>further comprising:</claim-text>
<claim-text>a wear algorithm application programming interface, wherein
<claim-text>said wear algorithm application programming interface is configured to provide said operating system with access to said storage device via said loaded wear algorithm.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The computer host processing system of <claim-ref idref="CLM-00009">claim 9</claim-ref>, further comprising:
<claim-text>computer readable storage medium coupled to said processor; and</claim-text>
<claim-text>computer code, encoded in said computer readable storage medium, configured to cause said processor to:
<claim-text>upload said device-specific wear algorithm code, but not said integrated wear algorithm, from said storage device to said memory, and</claim-text>
<claim-text>configure said device-specific wear algorithm code for execution on the host processing system,</claim-text>
<claim-text>wherein
<claim-text>said device-specific wear algorithm code is at least a portion of a wear algorithm.</claim-text>
</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. An apparatus comprising:
<claim-text>means for uploading device-specific wear algorithm code, but not an integrated wear algorithm, from a storage device to a host processing system, wherein the storage device is configured to be coupled to the host processing system; and</claim-text>
<claim-text>means for configuring the device-specific wear algorithm code for execution on the host processing system, wherein
<claim-text>said host processing system comprises an operating system configured to be executed on said host processing system,</claim-text>
<claim-text>said operating system is configured to access said storage device via said device driver for said storage device,</claim-text>
<claim-text>said device-specific wear algorithm code is specific to a type of said storage device,</claim-text>
<claim-text>said device-specific wear algorithm code is configured to be used to access said storage device,</claim-text>
<claim-text>said device-specific wear algorithm code is at least a portion of a wear algorithm, and</claim-text>
<claim-text>said integrated wear algorithm is provided by the manufacturer of the storage device and configured for execution on the storage device.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The apparatus of <claim-ref idref="CLM-00012">claim 12</claim-ref>, further comprising:
<claim-text>means for configuring generic wear algorithm code stored on the host processing system for execution on the host processing system.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The apparatus of <claim-ref idref="CLM-00013">claim 13</claim-ref>,
<claim-text>wherein said generic wear algorithm code comprises a complete wear algorithm.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The apparatus of <claim-ref idref="CLM-00013">claim 13</claim-ref>, further comprising:
<claim-text>means for accessing said storage device using said device-specific wear algorithm code, said generic wear algorithm code, and said integrated wear algorithm.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The apparatus of <claim-ref idref="CLM-00012">claim 12</claim-ref>, further comprising:
<claim-text>means for accessing said storage device using said device-specific wear algorithm code and said integrated wear algorithm.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. An apparatus comprising:
<claim-text>a storage device, wherein
<claim-text>said storage device comprises
<claim-text>device-specific wear algorithm code, and</claim-text>
<claim-text>an integrated wear algorithm provided by the manufacturer of the storage device and configured for execution on the storage device,</claim-text>
</claim-text>
<claim-text>said storage device is configured to be coupled to a host processing system,</claim-text>
<claim-text>said host processing system comprises an operating system,</claim-text>
<claim-text>said device-specific wear algorithm code is specific to a type of said storage device, and</claim-text>
<claim-text>said device-specific wear algorithm code is configured to be uploaded to and executed on the host processing system to access said storage device,</claim-text>
<claim-text>an operating system is configured to be executed on said host processing system,</claim-text>
<claim-text>said operating system is configured to access said storage device via a device driver for said storage device, and</claim-text>
<claim-text>said device-specific wear algorithm is at least a portion of a wear algorithm.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said device-specific algorithm code is specific to an application using said storage device.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said configuring the device-specific wear algorithm code for execution on the host processing system comprises loading the device-specific wear algorithm code into a wear algorithm space of a device driver for said storage device.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein said configuring generic wear algorithm code for execution on the host processing system comprises loading the generic wear algorithm code into a wear algorithm space of a device driver for said storage device.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein said device-specific wear algorithm code comprises one or more parameters for use by the generic wear algorithm code.</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>determining whether the device-specific wear algorithm code is stored in the storage device, and</claim-text>
<claim-text>wherein said uploading the device-specific wear algorithm code is performed in response to a determination that said device-specific wear algorithm code is stored in said storage device.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00023" num="00023">
<claim-text>23. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising:
<claim-text>determining whether the generic wear algorithm code is available on the host processing device, and</claim-text>
<claim-text>wherein said configuring the generic wear algorithm code is performed in response to a determination that the generic wear algorithm code is available.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00024" num="00024">
<claim-text>24. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said device specific wear algorithm code comprises a complete wear algorithm.</claim-text>
</claim>
<claim id="CLM-00025" num="00025">
<claim-text>25. The host processing system of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein said processor is configured to configure said device-specific wear algorithm code for execution on the host processing system by loading said device-specific wear algorithm code into a wear algorithm space of said device driver.</claim-text>
</claim>
<claim id="CLM-00026" num="00026">
<claim-text>26. The host processing system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein said computer code is configured to cause said processor to configure said device-specific wear algorithm code for execution on the host processing system by loading said device-specific wear algorithm code into a wear algorithm space of said device driver.</claim-text>
</claim>
<claim id="CLM-00027" num="00027">
<claim-text>27. The apparatus of <claim-ref idref="CLM-00023">claim 23</claim-ref>, further comprising:
<claim-text>means for determining whether the device-specific wear algorithm code is stored in said storage device, and wherein said means for uploading device-specific wear algorithm code comprises means for uploading the device-specific wear algorithm code in response to a determination that said device-specific wear algorithm code is stored in said storage device.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00028" num="00028">
<claim-text>28. The apparatus of <claim-ref idref="CLM-00013">claim 13</claim-ref>, further comprising:
<claim-text>means for determining whether to configure the generic wear algorithm code for execution on the host processing system, and wherein said means for configuring generic wear algorithm code for execution comprises means for configuring the generic wear algorithm code for execution in response to a determination that said generic wear algorithm code should be configured for execution.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
