<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08626807-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08626807</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12350680</doc-number>
<date>20090108</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>1349</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>7</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>708205</main-classification>
</classification-national>
<invention-title id="d2e53">Reuse of rounder for fixed conversion of log instructions</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5696709</doc-number>
<kind>A</kind>
<name>Smith, Sr.</name>
<date>19971200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>708551</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6058410</doc-number>
<kind>A</kind>
<name>Sharangpani</name>
<date>20000500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>708551</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6523050</doc-number>
<kind>B1</kind>
<name>Dhablania et al.</name>
<date>20030200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>708204</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2007/0038693</doc-number>
<kind>A1</kind>
<name>Jacobi et al.</name>
<date>20070200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>708446</main-classification></classification-national>
</us-citation>
<us-citation>
<nplcit num="00005">
<othercit>Lang, T.; Bruguera, J.D.; , &#x201c;Floating-point multiply-add-fused with reduced latency,&#x201d; Computers, IEEE Transactions on , vol. 53, No. 8, pp. 988-1003, Aug. 2004.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00006">
<othercit>&#x201c;PowerPC Microprocessor Family: Vector/SIMD Multimedia Extension Technology Programming Environments Manual Version 2.06&#x201d; on pp. 174-175, IBM International Business Machines Corporation 1998, 2003, 2004, 2005.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00007">
<othercit>Martin S. Schmookler, et al., &#x201c;A Low-power, High-speed Implementation of a PowerPCTM Microprocessor Vector Extension&#x201d;.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00008">
<othercit>Oklobdzija, Vojin G. et al., &#x201c;High-performance Energy-efficient Microprocessor Design&#x201d;, Chapter 8&#x2014;Binary floating-point unit design: the fused multiply-add dataflow Eric Schwarz.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00009">
<othercit>L. Eisen, et al., &#x201c;IBM POWER6 accelerators: VMX and DFU&#x201d;, IBM J. Res. &#x26; Dev. Vol. 51 No. 6 Nov. 2007.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00010">
<othercit>E. Hokenek, et al., Leading-zero anticipator (LZA) in the IBM RISC System/6000 floating-point execution unit, IBM J. Res. Develop. vol. 34, No. 1, Jan. 1990.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>17</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>5</number-of-drawing-sheets>
<number-of-figures>5</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20100174764</doc-number>
<kind>A1</kind>
<date>20100708</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Boersma</last-name>
<first-name>Maarten</first-name>
<address>
<city>Holzgerlingen</city>
<country>DE</country>
</address>
</addressbook>
<residence>
<country>DE</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Kaltenbach</last-name>
<first-name>Markus</first-name>
<address>
<city>Leinfelden</city>
<country>DE</country>
</address>
</addressbook>
<residence>
<country>DE</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Klein</last-name>
<first-name>Michael</first-name>
<address>
<city>Schoenaich</city>
<country>DE</country>
</address>
</addressbook>
<residence>
<country>DE</country>
</residence>
</us-applicant>
<us-applicant sequence="004" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Mueller</last-name>
<first-name>Silvia Melitta</first-name>
<address>
<city>Altdorf</city>
<country>DE</country>
</address>
</addressbook>
<residence>
<country>DE</country>
</residence>
</us-applicant>
<us-applicant sequence="005" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Preiss</last-name>
<first-name>Jochen</first-name>
<address>
<city>Boeblingen</city>
<country>DE</country>
</address>
</addressbook>
<residence>
<country>DE</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Boersma</last-name>
<first-name>Maarten</first-name>
<address>
<city>Holzgerlingen</city>
<country>DE</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Kaltenbach</last-name>
<first-name>Markus</first-name>
<address>
<city>Leinfelden</city>
<country>DE</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Klein</last-name>
<first-name>Michael</first-name>
<address>
<city>Schoenaich</city>
<country>DE</country>
</address>
</addressbook>
</inventor>
<inventor sequence="004" designation="us-only">
<addressbook>
<last-name>Mueller</last-name>
<first-name>Silvia Melitta</first-name>
<address>
<city>Altdorf</city>
<country>DE</country>
</address>
</addressbook>
</inventor>
<inventor sequence="005" designation="us-only">
<addressbook>
<last-name>Preiss</last-name>
<first-name>Jochen</first-name>
<address>
<city>Boeblingen</city>
<country>DE</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Cantor Colburn LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Bluestone</last-name>
<first-name>Randall</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Alrobaye</last-name>
<first-name>Idriss N</first-name>
<department>2181</department>
</primary-examiner>
<assistant-examiner>
<last-name>Lewis-Taylor</last-name>
<first-name>Dayton</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A method for converting a signed fixed point number into a floating point number that includes reading an input number corresponding to a signed fixed point number to be converted, determining whether the input number is less than zero, setting a sign bit based upon whether the input number is less than zero or greater than or equal to zero, computing a first intermediate result by exclusive-ORing the input number with the sign bit, computing leading zeros of the first intermediate result, padding the first intermediate result based upon the sign bit, computing a second intermediate result by shifting the padded first intermediate result to the left by the leading zeros, computing an exponent portion and a fraction portion, conditionally incrementing the fraction portion based on the sign bit, correcting the exponent portion and the fraction portion if the incremented fraction portion overflows, and returning the floating point number.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="110.32mm" wi="199.98mm" file="US08626807-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="202.35mm" wi="141.39mm" orientation="landscape" file="US08626807-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="235.63mm" wi="187.37mm" orientation="landscape" file="US08626807-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="201.34mm" wi="124.97mm" orientation="landscape" file="US08626807-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="254.00mm" wi="189.06mm" orientation="landscape" file="US08626807-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="233.09mm" wi="182.37mm" orientation="landscape" file="US08626807-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?GOVINT description="Government Interest" end="lead"?>
<heading id="h-0001" level="1">STATEMENT OF GOVERNMENT INTEREST</heading>
<p id="p-0002" num="0001">This invention was made with Government support under Contract No. HR0011-07-9-0002 awarded by DARPA. The Government has certain rights in this invention.</p>
<?GOVINT description="Government Interest" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">BACKGROUND</heading>
<p id="p-0003" num="0002">The present invention relates to floating point units (FPUs), and more specifically, to the reuse of the normalizer and rounder of the FPU for conversion from a fixed point format to a floating point data format which enables the execution of the log estimate in a single loop through a fused-multiply-add (FMA) data path and thereby improves the latency of log estimate instructions executed on the FPU within the FMA data path.</p>
<p id="p-0004" num="0003"><figref idref="DRAWINGS">FIG. 1</figref> illustrates a dataflow of a conventional floating point unit <b>10</b>. The FPU <b>10</b> includes an aligner <b>15</b>, a multiplier <b>20</b>, an adder <b>25</b>, a normalizer <b>30</b> and a rounder <b>35</b>. As shown in <figref idref="DRAWINGS">FIG. 1</figref>, the data flow is designed to loop twice through the FPU data path in order to execute log estimate instructions. As shown, the first loop, as indicated by reference numeral <b>2</b>, computes the estimate and the second loop, as indicated by reference numeral <b>4</b>, converts the estimate into a floating point data format. Specifically, an input operand is normalized to a number x=2<sup>e&#x2032;</sup>*1.f&#x2032; at the estimate normalize block <b>12</b>. Then, an estimate is computed for f<sub>L</sub>=log(1.f&#x2032;) using a table lookup <b>14</b>, for example. The table lookup <b>14</b> returns the log estimate as a two's complement fixed point number e'.f<sub>L </sub>for conversion to a floating point number. A conventional algorithm for converting from the fixed format to the floating point format is shown in <figref idref="DRAWINGS">FIG. 2</figref>. As shown in <figref idref="DRAWINGS">FIG. 2</figref>, the two's complement input number n having m total bits and k bits before the binary point is read at operation <b>100</b>. From operation <b>100</b>, the process moves to operation <b>105</b>, where, in the aligner <b>15</b> (depicted in <figref idref="DRAWINGS">FIG. 1</figref>), it is determined whether the input number n is less than zero. If it is determined at operation <b>105</b> that the input number n is greater than or equal to zero (i.e., a non-negative number), then the sign bit is set to zero, and if it is determined that the input number n is less than zero (i.e., a negative number) then the input number is inverted at operation <b>115</b>. From operation <b>115</b>, the process moves to operation <b>120</b>, where the sign bit is set to one and the input number is incremented by adding &#x2018;1&#x2019; to the least significant bit (LSB) via the adder <b>25</b> (depicted in <figref idref="DRAWINGS">FIG. 1</figref>). From operations <b>110</b> and <b>120</b>, the process moves to operation <b>125</b> where leading zeros (&#x201c;lz&#x201d;) are counted via the adder <b>25</b> which includes a leading zero anticipator (LZA).</p>
<p id="p-0005" num="0004">At operation <b>130</b>, the output of the adder <b>25</b> is padded with zeros. Then at operation <b>135</b>, in the normalizer <b>30</b> (depicted in <figref idref="DRAWINGS">FIG. 1</figref>), the result is shifted to the left by the number of leading zeros counted. From operation <b>135</b>, the process moves to operation <b>140</b>, where in the rounder <b>35</b> (depicted in <figref idref="DRAWINGS">FIG. 1</figref>), the exponent and fraction are calculated and the floating point number including the sign bit, the exponent, and the fraction is returned at operation <b>145</b>. There are several disadvantages regarding the conventional data flow <b>10</b>. For example, the implementation of log estimate instructions in the conventional data flow <b>10</b> reuses the entire data flow for converting from a fixed format to a floating point format. Therefore, resulting in a 10-cycle latency as shown in <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<heading id="h-0003" level="1">SUMMARY</heading>
<p id="p-0006" num="0005">According to an embodiment of the present invention, methods for converting a signed fixed point number into a floating point number and computer program product for performing the method are provided. The methods utilize the normalizer and the rounder unit in the FPU.</p>
<p id="p-0007" num="0006">According to one embodiment, a method for converting a signed fixed point number into a floating point number is provided. The method includes reading an input number corresponding to a signed fixed point number to be converted into a floating point number, determining whether the input number is less than zero, setting a sign bit based upon whether the input number is less than zero or greater than or equal to zero, computing a first intermediate result by exclusive-ORing the input number with the sign bit, computing a number of leading zeros of the first intermediate result, padding the first intermediate result with ones or zeros based upon the sign bit, computing a second intermediate result by shifting the padded first intermediate result to the left by a number based on the number of leading zeros, computing an exponent portion using the number of leading zeros, computing a fraction portion using the second intermediate result, conditionally incrementing the fraction portion based on the sign bit, correcting the exponent portion and the fraction portion if the incremented fraction portion overflows, and returning, the floating point number including the sign bit, and the exponent portion and fraction portion.</p>
<p id="p-0008" num="0007">According to another embodiment of the present invention, a computer program product comprising a computer useable medium including a computer readable program, wherein the computer readable program when executed on a computer causes the computer to implement a method for converting a signed fixed point number into a floating point number is provided. The method includes reading an input number corresponding to a signed fixed point number to be converted into a floating point number, determining whether the input number is less than zero, setting a sign bit based upon whether the input number is less than zero or greater than or equal to zero, computing a first intermediate result by exclusive-ORing the input number with the sign bit, computing a number of leading zeros of the first intermediate result, padding the first intermediate result with ones or zeros based upon the sign bit, computing a second intermediate result by shifting the padded first intermediate result to the left by a number based on the number of leading zeros, computing an exponent portion using the number of leading zeros, computing a fraction portion using the second intermediate result, conditionally incrementing the fraction portion based on the sign bit, correcting the exponent portion and the fraction portion if the incremented fraction portion overflows, and returning, the floating point number including the sign bit, and the exponent portion and fraction portion.</p>
<p id="p-0009" num="0008">Additional features and advantages are realized through the techniques of the present invention. Other embodiments and aspects of the invention are described in detail herein and are considered a part of the claimed invention. For a better understanding of the invention with the advantages and the features, refer to the description and to the drawings.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS</heading>
<p id="p-0010" num="0009">The subject matter which is regarded as the invention is particularly pointed out and distinctly claimed in the claims at the conclusion of the specification. The forgoing and other features, and advantages of the invention are apparent from the following detailed description taken in conjunction with the accompanying drawings in which:</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 1</figref> is diagram illustrating a conventional FMA dataflow executing a log estimate instruction.</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 2</figref> is a flowchart illustrating a conversion operation for converting a fixed point number into a floating point number according to the conventional art.</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 3</figref> is a diagram illustrating an FMA dataflow executing a log estimate instruction that can be implemented within embodiments of the present invention.</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 4</figref> is a flowchart illustrating a conversion operation for converting a fixed point number into a floating point number that can be implemented within embodiments of the present invention.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 5</figref> is a flowchart illustrating the reuse of the rounder and normalizer to convert a fixed point number into a floating point number according to an embodiment of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0016" num="0015">With reference now to <figref idref="DRAWINGS">FIG. 3</figref>, there is a floating point unit (FPU) <b>300</b> of a processor according to an embodiment of the present invention. The dataflow of the FPU <b>300</b> may operate according to a fused multiply-add (FMA) data flow, for example, where (&#x201c;R=C+A*B&#x201d;), where &#x201c;A&#x201d; is the multiplicand, &#x201c;B&#x201d; is the multiplier, &#x201c;C&#x201d; is the addend, and &#x201c;R&#x201d; is the result. The dataflow includes an aligner <b>315</b>, a multiplier <b>320</b>, an adder <b>325</b>, a normalizer <b>330</b> and a rounder <b>335</b>. In the dataflow, the addend is aligned by the aligner <b>315</b> prior to being combined with the product of the multiplier <b>320</b> at the adder <b>325</b>. The result of the adder <b>325</b> is normalized via the normalizer <b>330</b> and the normalized result is then rounded into the instruction specific format via the rounder <b>335</b>.</p>
<p id="p-0017" num="0016">According to an embodiment of the present invention, a system for converting a signed fixed point number into a floating point number within the FPU <b>300</b> of a processor is provided. The system includes a preparation circuit, the normalizer <b>330</b> and the rounder <b>335</b>. The preparation circuit reads an input number corresponding to a signed fixed point number to be converted into a floating point number. An estimate normalize block <b>312</b> and a table lookup <b>314</b> are also provided. The preparation circuit may be included in the table lookup <b>314</b>. The standard data flow for log estimate instructions includes normalizing the input operand, if necessary at block <b>312</b>, and computing a log estimate using the table lookup <b>314</b>, along a single loop indicated by reference numeral <b>5</b>. The loop <b>5</b> then continues to the normalizer <b>330</b> and the rounder <b>335</b> for performance of the conversion from a fixed format to a floating point format as discussed below with reference to <figref idref="DRAWINGS">FIG. 4</figref>. Therefore, the result is a 6-cycle latency.</p>
<p id="p-0018" num="0017">According to embodiments of the present invention, a floating point number format includes a single sign bit &#x201c;s&#x201d;, an exponent &#x201c;e&#x201d; that includes multiple bits, and a significand that includes a single integer bit &#x201c;i&#x201d; and a fraction part &#x201c;f&#x201d; that includes multiple bits. All the bits within the floating point number are binary integer value bits (i.e., either a binary logic &#x201c;0&#x201d; or &#x201c;1&#x201d;). The value for the floating point number is (&#x2212;1)<sup>2</sup>*2<sup>e</sup>*i.f, normalizing converts this number to the unique number with sign bit s, exponent e&#x2032;, fraction f&#x2032;, and an integer bit with value &#x201c;1&#x201d;. The log function is defined as log (2<sup>e&#x2032;</sup>*1.f)=log(2<sup>e&#x2032;</sup>)+log(1.f&#x2032;)=e&#x2032;+log(1.f&#x2032;). The number e+log(1.f) is called the intermediate significand with integer part e&#x2032; and fraction part log(1.f).</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 4</figref> is a flowchart illustrating the conversion of a fixed point number into a floating point number that can be implemented within embodiments of the present invention. <figref idref="DRAWINGS">FIG. 4</figref> will now be described with reference to the data flow shown in <figref idref="DRAWINGS">FIG. 3</figref>. At operation <b>400</b>, the two's complement input number &#x201c;n&#x201d; having &#x201c;m&#x201d; total bits and &#x201c;k&#x201d; bits prior to the binary point is read. At operation <b>405</b>, it is determined whether the input number n is less than zero or greater than or equal to zero. If it is determined that the input number n is greater than or equal to zero (i.e., a non-negative number), then the input number n remains the same at operation <b>410</b>, and if it is determined in operation <b>405</b>, that the input number n is less than zero (i.e., a negative number), then the process moves to operation <b>415</b> where the input number n is inverted. From operations <b>410</b> and <b>415</b> respectively, the process moves to operation <b>420</b>, where leading zeros (&#x201c;lz&#x201d;) are counted. According to an embodiment of the present invention, operations <b>400</b> through <b>420</b> are performed via the table lookup <b>314</b> (depicted in <figref idref="DRAWINGS">FIG. 3</figref>). The leading zeros may be counted in a manner as disclosed in application Ser. No. 12/208,439 entitled &#x201c;NORMALIZER SHIFT PREDICTION FOR LOG ESTIMATE INSTRUCTIONS&#x201d; filed on Sep. 11, 2008 by Maarten J. Boersma et al., the disclosure of which is incorporated herein by reference in its entirety.</p>
<p id="p-0020" num="0019">From operation <b>420</b>, the process moves to operation <b>425</b> where it is determined whether the input number n is less than zero or greater than or equal to zero. If it is determined that the input number n is greater than or equal to zero, the process moves to operation <b>430</b> where the result of the table lookup <b>314</b> (&#x201c;n<sub>1</sub>&#x201d;) (i.e., a first intermediate result) is padded with zeros on a least significant bit side. From operation <b>430</b>, the process moves to operation <b>435</b> where a second intermediate result is computed by normalizing the first intermediate result by shifting the results (&#x201c;n<sub>2</sub>&#x201d;) (i.e., the padded first intermediate result) to the left by a number equal to the number of leading zeros counted. According to an embodiment of the present invention, operations <b>425</b> through <b>435</b> are performed via the normalizer <b>330</b> of the floating-point fused multiply-add computation (depicted in <figref idref="DRAWINGS">FIG. 3</figref>). Further shown in <figref idref="DRAWINGS">FIG. 4</figref>, &#x201c;p&#x201d; represents the number of fraction bits and &#x201c;bias&#x201d; denotes the exponent bias of the precision of the floating point number.</p>
<p id="p-0021" num="0020">From operation <b>435</b>, the process moves to operation <b>440</b> where the sign bit s is set to zero and the exponent e and the fraction part f are computed and from operation <b>440</b>, the process moves to operation <b>470</b> where the floating point number including the sign bit s, exponent e and the fraction f are returned. According to an embodiment of the present invention, operations <b>440</b> and <b>470</b> are performed in the rounder <b>335</b> of the floating-point fused multiply-add computation (depicted in <figref idref="DRAWINGS">FIG. 3</figref>).</p>
<p id="p-0022" num="0021">If it is determined at operation <b>425</b>, that n is less than zero, the process moves to operation <b>445</b> where the result of the table lookup (&#x201c;n<sub>1</sub>&#x201d;) (i.e., the first intermediate result) is padded with ones on a least significant bit side. From operation <b>445</b>, the process moves to operation <b>450</b>, where the result (&#x201c;n<sub>2</sub>&#x201d;) (i.e. the padded first intermediate result) is then shifted to the left by a number equal to the number of leading zeros counted. According to an embodiment of the present invention, operations <b>445</b> and <b>450</b> are performed at the normalizer <b>330</b>.</p>
<p id="p-0023" num="0022">From operation <b>450</b>, the process moves to operation <b>455</b> where it is determined whether the fraction f is equal to all ones. If it is determined that the fraction f is not equal to all ones, the process moves to operation <b>465</b> where the sign bit is set to one, the exponent e is computed and the fraction f is incremented by adding a &#x201c;1&#x201d; to the LSB. On the other hand, if it is determined in operation <b>455</b> that the fraction f is equal to all ones, then the process moves to operation <b>460</b> where the sign bit s is set to one and the exponent e and the fraction f are corrected by incrementing the exponent e and setting the fraction f to all zeros. As can be seen in <figref idref="DRAWINGS">FIG. 4</figref>, according to an embodiment of the present invention, the fraction f is conditionally incremented based on the sign bit. That is, the fraction f is incremented if the sign bit is set to one (operation <b>465</b>) and the fraction is not incremented if the sign bit is set to zero (operation <b>440</b>). From operation <b>460</b>, the process moves to operation <b>470</b> where the floating point number including the sign bit s, exponent e and the fraction f is returned. According to an embodiment of the present invention, operations <b>455</b> through <b>470</b> are performed in the rounder <b>335</b>.</p>
<p id="p-0024" num="0023">The following is an example of a conversion from a fixed format to a floating point format. In the following example, the input number is &#x2212;18.625=11101101.01100000 at operation <b>400</b>. Since &#x2212;18.625 is less than zero, the process moves to operation <b>415</b> where the input number is inverted to 00010010.10011111. From operation <b>415</b>, the process moves to operation <b>420</b>, where the leading zeros are counted. For this example, the leading zeros counted equals 3. From operation <b>420</b>, the process moves to operation <b>425</b>, where it is determined whether the input number is less than zero. Since the input number (00010010.10011111) is less than zero, at operation <b>445</b>, the inverted input number is padded with ones to 00010010.1001111111111111111. From operation <b>445</b>, the process moves to operation <b>450</b> where the result is shifted to the left by the number of zeros to 1.00101001111111111111111. From operation <b>450</b>, the process moves to operation <b>455</b> where it is determined whether the fraction equals all ones. In this example, the fraction does not equal all ones, therefore the process moves to operation <b>465</b> where the sign bit is set to 1 and the exponent is computed and the fraction is incremented by 1 resulting in 1.0010101000000. From operation <b>465</b>, the process moves to operation <b>470</b> where the floating point number is returned, for this example, the floating point number equals &#x2212;1*2<sup>4</sup>*1.0010101=&#x2212;16*1.1640625=&#x2212;18.625.</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 5</figref> is a flowchart illustrating the reuse of the rounder and normalizer to convert a signed fixed point number into a floating point number according to an embodiment of the present invention. In a preferred embodiment, the signed fixed point number is an estimate of a logarithm of an input floating point number. <figref idref="DRAWINGS">FIG. 5</figref> illustrates the functionality of the normalizer <b>330</b> and the rounder <b>335</b> shown in <figref idref="DRAWINGS">FIG. 3</figref>, for example.</p>
<p id="p-0026" num="0025">At operation <b>500</b>, the two's complement input number n is read. From operation <b>500</b>, the process moves to operation <b>505</b> where it is determined whether the input number n is less than zero or greater than or equal to zero. If it is determined in operation <b>505</b> that the input number n is greater than or equal to zero, the process moves to operation <b>510</b> where the signed bit is set to zero and the rounding mode is set to round-to-zero according to the IEEE 754 standard for floating point numbers. If it is determined in operation <b>505</b>, that the input number n is less than zero, the process moves to operation <b>515</b> where the signed bit is set to one and the rounding mode is set to round-nearest-even according to the IEEE 754 standard. The standard rounding mode is well known in the art. According to an embodiment of the present invention, operations <b>500</b> through <b>515</b> are performed via the table lookup <b>314</b> (depicted in <figref idref="DRAWINGS">FIG. 3</figref>).</p>
<p id="p-0027" num="0026">From operations <b>510</b> and <b>515</b>, the process moves to operation <b>520</b>, where the signed fixed point number (&#x201c;n&#x201d;) is logically exclusively-ORed with the sign bit giving a first intermediate result. From operation <b>520</b>, the process moves to operation <b>525</b> where the leading zeros (lz) of the first intermediate result is computed. Operations <b>520</b> and <b>525</b> are also performed via the table lookup <b>314</b>. Thus, as mentioned above, the setting of the sign bit, the exclusive-ORing of the input number, the computing of the leading zeros and the padding of ones or zeros are performed as a part of a table lookup for the logarithm estimate.</p>
<p id="p-0028" num="0027">From operation <b>525</b>, the process moves to operation <b>530</b>, where the first intermediate result is padded with ones or zeros on a least significant bit side based upon the sign bit. Then in operation <b>535</b>, a second intermediate result is computed by shifting the padded first intermediate result to the left by a number based on the number of leading zeros. According to one embodiment, the operations <b>530</b> and <b>535</b> are performed via the normalizer <b>330</b> within the floating-point fused multiply-add computation, for example. The normalizer <b>330</b> is configured to perform a desired function by setting the normalizer <b>330</b> to a default normalization function as used in a computation of a fused multiply-add instruction. Further shown in <figref idref="DRAWINGS">FIG. 5</figref>, &#x201c;p&#x201d; represents the number of fraction bits and &#x201c;bias&#x201d; denotes the exponent bias of the precision of the floating point number.</p>
<p id="p-0029" num="0028">From operation <b>535</b>, the process moves to operation <b>540</b>, where the sign bit s, the exponent e, and the fraction f are calculated by rounding the result of the normalizer <b>330</b>, via the rounder <b>335</b> in the floating-point fused multiply-add computation. The rounder <b>335</b> is configured to performed a desired function by setting the rounder <b>335</b> to a default rounding function as used in the computation of a fused multiply-add instruction and applying an appropriate rounding mode. Further, according to an embodiment of the present invention, the exponent e is computed using the number of leading zeros and the fraction f is computed using the second intermediate result. From operation <b>540</b>, the process moves to operation <b>545</b> where the floating point number is returned including the sign bit s, the exponent e, and the fraction f calculated.</p>
<p id="p-0030" num="0029">According to one embodiment of the present invention, the method of converting from a fixed point to a floating point format is used for the log2 estimate instruction in the FPU. However, the present invention is not limited hereto, and may vary as necessary.</p>
<p id="p-0031" num="0030">Embodiments of the present invention reuse the normalizer and the rounder. Therefore, it is possible to implement the log instruction in a fully pipelined way with the same latency as a FMA instruction. In addition, the present invention also eliminates the need for extra hardware in the pipeline, to manage the additional loop through the pipeline.</p>
<p id="p-0032" num="0031">For the sake of description, <figref idref="DRAWINGS">FIGS. 4 and 5</figref> assume that the number of leading zeros (lz) computed in steps <b>420</b> and <b>525</b> is exact. However, a state-of-the-art rounder supports a number of leading zeros that is off by one. Such a rounder determines whether the number of leading zeros is either correct or off by one based on the most significant bit of the second intermediate result. It corrects the second intermediate result and the number of leading zeros prior to the computing of the exponent e and the fraction f, i.e., directly after the steps <b>435</b>, <b>450</b>, and <b>535</b>. The correction of the second intermediate result includes adding or subtracting one to or from the number of leading zeros and shifting the second intermediate result by one.</p>
<p id="p-0033" num="0032">The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein, the singular forms &#x201c;a&#x201d;, &#x201c;an&#x201d; and &#x201c;the&#x201d; are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms &#x201c;comprises&#x201d; and/or &#x201c;comprising,&#x201d; when used in this specification, specify the presence of stated features, integers, steps, operations, elements, and/or components, but do not preclude the presence or addition of one ore more other features, integers, steps, operations, element components, and/or groups thereof.</p>
<p id="p-0034" num="0033">The corresponding structures, materials, acts, and equivalents of all means or step plus function elements in the claims below are intended to include any structure, material, or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description, but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated</p>
<p id="p-0035" num="0034">The flow diagrams depicted herein are just one example. There may be many variations to this diagram or the steps (or operations) described therein without departing from the spirit of the invention. For instance, the steps may be performed in a differing order or steps may be added, deleted or modified. All of these variations are considered a part of the claimed invention.</p>
<p id="p-0036" num="0035">While the preferred embodiment to the invention had been described, it will be understood that those skilled in the art, both now and in the future, may make various improvements and enhancements which fall within the scope of the claims which follow. These claims should be construed to maintain the proper protection for the invention first described.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for converting a signed fixed point number into a floating point number in a floating-point unit of a processor, the floating-point unit comprising a preparation circuit, a normalizer, and a rounder, the method comprising:
<claim-text>reading, by the preparation circuit, an input number that is a signed fixed point number to be converted into a floating point number, wherein the signed fixed point number is an estimate of a logarithm of an input floating point number;</claim-text>
<claim-text>determining, by the preparation circuit, whether the input number is less than zero;</claim-text>
<claim-text>setting, by the preparation circuit, a sign bit based upon whether the input number is less than zero or greater than or equal to zero;</claim-text>
<claim-text>computing, by the preparation circuit, a first intermediate result by exclusive-ORing the input number with the sign bit;</claim-text>
<claim-text>computing, by the preparation circuit, a number of leading zeros of the first intermediate result;</claim-text>
<claim-text>padding, by the normalizer, the first intermediate result on a least significant bit side with ones or zeros based upon the sign bit;</claim-text>
<claim-text>computing, by the normalizer, a second intermediate result by shifting the padded first intermediate result to the left by a number based on the number of leading zeros, wherein the computing of the second intermediate result based on the first intermediate result, the sign bit, and the number of leading zeros is performed within a normalization step of a floating-point fused multiply-add computation, wherein the normalization step is configured to perform a desired function by setting the normalization step to a default normalization function as used in a computation of a fused multiply-add instruction;</claim-text>
<claim-text>computing, by the rounder, an exponent portion using the number of leading zeros;</claim-text>
<claim-text>computing, by the rounder, a fraction portion using the second intermediate result;</claim-text>
<claim-text>conditionally incrementing, by the rounder, the fraction portion based on the sign bit;</claim-text>
<claim-text>correcting, by the rounder, the exponent portion and the fraction portion if the incremented fraction portion overflows; and</claim-text>
<claim-text>returning the floating point number including the sign bit, and the exponent portion and fraction portion, wherein a computation of the floating point number based on the sign bit, the second intermediate result and the number of leading zeros is performed within a rounding step of the floating-point fused multiply-add computation, wherein the rounding step is configured to perform a desired function by setting the rounder to a default rounding function as used in the computation of a fused multiply-add instruction and applying an appropriate rounding mode, wherein the rounding mode is set based on the input number, and further wherein the setting of the sign bit, the exclusive-ORing of the input number, and the computing of the number of leading zeros are performed as part of a table lookup for the estimate of a logarithm of an input floating point number.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein setting the sign bit comprises:
<claim-text>setting the sign bit to zero when it is determined that the input number is greater than or equal to zero; and</claim-text>
<claim-text>setting the sign bit to one when it is determined that the input number is less than zero.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein padding the first intermediate result comprises:
<claim-text>padding the first intermediate result with zeros when the sign bit is zero; and</claim-text>
<claim-text>padding the first intermediate result with ones when the sign bit is one.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the fraction portion is incremented if the sign bit is one and not incremented if the sign bit is zero; and
<claim-text>wherein the exponent portion and the fraction portion are corrected if the fraction portion prior to incrementing includes all ones and the sign bit is one; and</claim-text>
<claim-text>wherein the correcting of the exponent portion and the fraction portion comprises incrementing the exponent portion and setting the fraction portion to all zeros.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the number of leading zeros is either a correct number of leading zeros of the first intermediate result or off by one; and
<claim-text>wherein, if the number of leading zeros is off by one, the second intermediate result and the number of leading zeros are corrected prior to the computing of the exponent portion and the fraction portion based on a most significant bit of the second intermediate result; and</claim-text>
<claim-text>wherein the correction of the number of leading zeros and the second intermediate result comprises adding or subtracting one to or from the number of leading zeros and shifting the second intermediate result by one.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>setting the rounding mode to round-to-zero as the appropriate rounding mode based on determining that the input number is greater than or equal to zero; and</claim-text>
<claim-text>setting the rounding mode to round-nearest-even as the appropriate rounding mode based on determining that the input number is less than zero.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. A computer program product comprising a non-transitory useable medium including a computer readable program, wherein the computer readable program when executed on a computer causes the computer to implement a method for converting a signed fixed point number into a floating point number, the method comprising:
<claim-text>reading an input number that is a signed fixed point number to be converted into a floating point number, wherein the signed fixed point number is an estimate of a logarithm of an input floating point number;</claim-text>
<claim-text>determining whether the input number is less than zero;</claim-text>
<claim-text>setting a sign bit based upon whether the input number is less than zero or greater than or equal to zero;</claim-text>
<claim-text>computing a first intermediate result by exclusive-ORing the input number with the sign bit;</claim-text>
<claim-text>computing a number of leading zeros of the first intermediate result;</claim-text>
<claim-text>padding the first intermediate result on a least significant bit side with ones or zeros based upon the sign bit;</claim-text>
<claim-text>computing a second intermediate result by shifting the padded first intermediate result to the left by a number based on the number of leading zeros, wherein the computing of the second intermediate result based on the first intermediate result, the sign bit, and the number of leading zeros is performed within a normalization step of a floating-point fused multiply-add computation, wherein the normalization step is configured to perform a desired function by setting the normalization step to a default normalization function as used in a computation of a fused multiply-add instruction;</claim-text>
<claim-text>computing an exponent portion using the number of leading zeros;</claim-text>
<claim-text>computing a fraction portion using the second intermediate result;</claim-text>
<claim-text>conditionally incrementing the fraction portion based on the sign bit;</claim-text>
<claim-text>correcting the exponent portion and the fraction portion if the incremented fraction portion overflows; and</claim-text>
<claim-text>returning, the floating point number including the sign bit, and the exponent portion and fraction portion, wherein a computation of the floating point number based on the sign bit, the second intermediate result and the number of leading zeros is performed within a rounding step of the floating-point fused multiply-add computation, wherein the rounding step is configured to perform a desired function by setting the rounder to a default rounding function as used in the computation of a fused multiply-add instruction and applying an appropriate rounding mode, wherein the rounding mode is set based on the input number, and further wherein the setting of the sign bit, the exclusive-ORing of the input number, and the computing of the number of leading zeros are performed as part of a table lookup for the estimate of a logarithm of an input floating point number.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The computer program product of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein setting the sign bit comprises:
<claim-text>setting the sign bit to zero when it is determined that the input number is greater than or equal to zero; and</claim-text>
<claim-text>setting the sign bit to one when it is determined that the input number is less than zero.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The computer program product of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein padding the first intermediate result comprises:
<claim-text>padding the first intermediate result with zeros when the sign bit is zero; and</claim-text>
<claim-text>padding the first intermediate result with ones when the sign bit is one.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The computer program product of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the fraction portion is incremented if the sign bit is one and not incremented if the sign bit is zero; and
<claim-text>wherein the exponent portion and the fraction portion are corrected if the fraction portion prior to incrementing includes all ones and the sign bit is one; and</claim-text>
<claim-text>wherein the correcting of the exponent portion and the fraction portion comprises incrementing the exponent portion and setting the fraction portion to all zeros.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The computer program product of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the number of leading zeros is either a correct number of leading zeros of the first intermediate result or off by one; and
<claim-text>wherein, if the number of leading zeros is off by one, the second intermediate result and the number of leading zeros are corrected prior to the computing of the exponent portion and the fraction portion based on a most significant bit of the second intermediate result; and</claim-text>
<claim-text>wherein the correction of the number of leading zeros and the second intermediate result comprises adding or subtracting one to or from the number of leading zeros and shifting the second intermediate result by one.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The computer program product of <claim-ref idref="CLM-00007">claim 7</claim-ref>, further comprising:
<claim-text>setting the rounding mode to round-to-zero as the appropriate rounding mode based on determining that the input number is greater than or equal to zero; and</claim-text>
<claim-text>setting the rounding mode to round-nearest-even as the appropriate rounding mode based on determining that the input number is less than zero.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. A system for converting a signed fixed point number into a floating point number within a floating point unit of a processor, the system comprising:
<claim-text>a preparation circuit reading an input number that is a signed fixed point number to be converted into a floating point number, wherein the signed fixed point number is an estimate of a logarithm of an input floating point number, the preparation circuit comprising a circuit to determine whether the input number is less than zero and to set a sign bit based upon whether the input number is less than zero or greater than or equal to zero, to compute a first intermediate result from the input number by exclusive-ORing the input number with the sign bit, and to compute a number of leading zeros of the first intermediate result, wherein the setting of the sign bit the exclusive-ORing of the input number, and the computing of the number of leading zeros are performed as part of a table lookup for the estimate of a logarithm of an input floating point number;</claim-text>
<claim-text>a normalizer configured to pad the first intermediate result on a least significant bit side with ones or zeros based on the sign bit and to compute a second intermediate result by shifting the padded first intermediate result to the left by the number of leading zeros computed, wherein the normalizer is configured to perform a desired function by setting the normalizer to a default normalization function as used in a computation of a fused multiply-add instruction; and</claim-text>
<claim-text>a rounder configured to compute an exponent portion using the number of leading zeros, to compute a fraction portion using the second intermediate result, and to conditionally increment the fraction portion based on the sign bit and to return a floating point number including the sign bit, the exponent portion and the fraction portion, wherein the normalizer and rounder are part of a floating point unit able to execute fused-multiply-add operations, and wherein the rounder is configured to perform a desired function by setting the rounder to a default rounding function as used in the computation of a fused multiply-add instruction and applying an appropriate rounding mode, wherein the rounding mode is set based on the input number.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The system of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the sign bit is set to zero when it is determined that the input number is greater than or equal to zero and the sign bit is set to one when it is determined that the input number is less than zero; and
<claim-text>wherein the first intermediate result is padded with zeros when the sign bit is zero and padded with ones when the sign bit is one.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The system of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the fraction portion is incremented if the sign bit is one and not incremented if the sign bit is zero; and
<claim-text>wherein the exponent portion and the fraction portion are corrected if the fraction portion prior to incrementing includes all ones and the sign bit is one; and</claim-text>
<claim-text>wherein the correcting of the exponent portion and the fraction portion comprises incrementing the exponent portion and setting the fraction portion to all zeros.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The system of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the number of leading zeros is either a correct number of leading zeros of the first intermediate result or off by one; and
<claim-text>wherein, if the number of leading zeros is off by one, the rounder corrects the second intermediate result and the number of leading zeros prior to the computing of the exponent portion and the fraction portion based on a most significant bit of the second intermediate result; and</claim-text>
<claim-text>wherein the correction of the number of leading zeros and the second intermediate result comprises adding or subtracting one to or from the number of leading zeros and shifting the second intermediate result by one.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The system of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the rounding mode is set to round-to-zero as the appropriate rounding mode based on the determination that the input number is greater than or equal to zero, and the rounding mode is set to round-nearest-even as the appropriate rounding mode based on the determination that the input number is less than zero. </claim-text>
</claim>
</claims>
</us-patent-grant>
