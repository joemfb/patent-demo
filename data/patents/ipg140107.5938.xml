<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627047-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627047</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12031898</doc-number>
<date>20080215</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>937</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>7</main-group>
<subgroup>38</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>00</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>44</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>13</main-group>
<subgroup>00</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>13</main-group>
<subgroup>28</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>712225</main-classification>
<further-classification>711150</further-classification>
<further-classification>711154</further-classification>
</classification-national>
<invention-title id="d2e53">Store data forwarding with no memory model restrictions</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6021485</doc-number>
<kind>A</kind>
<name>Feiste et al.</name>
<date>20000200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712216</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6134646</doc-number>
<kind>A</kind>
<name>Feiste et al.</name>
<date>20001000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712 23</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6141747</doc-number>
<kind>A</kind>
<name>Witt</name>
<date>20001000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712225</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6338128</doc-number>
<kind>B1</kind>
<name>Chang et al.</name>
<date>20020100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711203</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>6393536</doc-number>
<kind>B1</kind>
<name>Hughes et al.</name>
<date>20020500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711159</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>6581151</doc-number>
<kind>B2</kind>
<name>Henry et al.</name>
<date>20030600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711203</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>6678807</doc-number>
<kind>B2</kind>
<name>Boatright et al.</name>
<date>20040100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711154</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>6901540</doc-number>
<kind>B1</kind>
<name>Griffith et al.</name>
<date>20050500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714 48</main-classification></classification-national>
</us-citation>
<us-citation>
<nplcit num="00009">
<othercit>z/Architecture. &#x201c;Principles of Operation&#x201d;. Sixth Edition (Apr. 2007). IBM. 1218 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>10</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>712225</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>4</number-of-drawing-sheets>
<number-of-figures>5</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20090210679</doc-number>
<kind>A1</kind>
<date>20090820</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Tsai</last-name>
<first-name>Aaron</first-name>
<address>
<city>Poughkeepsie</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Krumm</last-name>
<first-name>Barry W.</first-name>
<address>
<city>Poughkeepsie</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Mitchell</last-name>
<first-name>James R.</first-name>
<address>
<city>Poughkeepsie</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="004" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Nelson</last-name>
<first-name>Bradley</first-name>
<address>
<city>Austin</city>
<state>TX</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="005" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Barrick</last-name>
<first-name>Brian D.</first-name>
<address>
<city>Pflugerville</city>
<state>TX</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="006" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Shum</last-name>
<first-name>Chung-Lung Kevin</first-name>
<address>
<city>Wappingers Falls</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="007" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Wood</last-name>
<first-name>Michael H.</first-name>
<address>
<city>Poughkeepsie</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Tsai</last-name>
<first-name>Aaron</first-name>
<address>
<city>Poughkeepsie</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Krumm</last-name>
<first-name>Barry W.</first-name>
<address>
<city>Poughkeepsie</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Mitchell</last-name>
<first-name>James R.</first-name>
<address>
<city>Poughkeepsie</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="004" designation="us-only">
<addressbook>
<last-name>Nelson</last-name>
<first-name>Bradley</first-name>
<address>
<city>Austin</city>
<state>TX</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="005" designation="us-only">
<addressbook>
<last-name>Barrick</last-name>
<first-name>Brian D.</first-name>
<address>
<city>Pflugerville</city>
<state>TX</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="006" designation="us-only">
<addressbook>
<last-name>Shum</last-name>
<first-name>Chung-Lung Kevin</first-name>
<address>
<city>Wappingers Falls</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="007" designation="us-only">
<addressbook>
<last-name>Wood</last-name>
<first-name>Michael H.</first-name>
<address>
<city>Poughkeepsie</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Cantor Colburn LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Campbell</last-name>
<first-name>John</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Caldwell</last-name>
<first-name>Andrew</first-name>
<department>2183</department>
</primary-examiner>
<assistant-examiner>
<last-name>Partridge</last-name>
<first-name>William B</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A pipelined microprocessor includes circuitry for store forwarding by performing: for each store request, and while a write to one of a cache and a memory is pending; obtaining the most recent value for at least one complete block of data; merging store data from the store request with the complete block of data thus updating the block of data and forming a new most recent value and an updated complete block of data; and buffering the updated complete block of data into a store data queue; for each load request, where the load request may require at least one updated completed block of data: determining if store forwarding is appropriate for the load request on a block-by-block basis; if store forwarding is appropriate, selecting an appropriate block of data from the store data queue on a block-by-block basis; and forwarding the selected block of data to the load request.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="203.20mm" wi="163.75mm" file="US08627047-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="136.74mm" wi="138.09mm" file="US08627047-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="227.08mm" wi="170.26mm" file="US08627047-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="224.37mm" wi="162.73mm" file="US08627047-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="223.35mm" wi="165.69mm" file="US08627047-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0002" num="0001">The invention herein is related to design of microprocessors, and in particular, to techniques for addressing cache loads waiting prior to cache write backs.</p>
<p id="p-0003" num="0002">As microprocessor design continues to advance, new problems arise. Consider, for example, an existing (prior art) architecture, aspects of which are depicted in <figref idref="DRAWINGS">FIG. 1</figref>. First, note that <figref idref="DRAWINGS">FIG. 1</figref> is a simplified depiction for purposes of discussion and does not take into account that each microprocessor <b>1</b> may include pluralities of various components.</p>
<p id="p-0004" num="0003">The microprocessor <b>1</b> typically includes components such as one or more arithmetic logic units <b>2</b>, one or more caches <b>5</b>, and a plurality of registers <b>6</b>. Typically, the cache <b>5</b> provides an interface with random access memory <b>11</b>. Of course, different configurations of other components are typically included in the microarchitecture, but are not shown here for simplicity.</p>
<p id="p-0005" num="0004">Most processors run programs by loading an instruction from memory <b>11</b> and decoding the instruction; loading associated data from registers or memory <b>11</b> that is needed to process the instruction; processing the instruction; and storing any associated results in registers or memory <b>11</b>. Complicating this series of steps is the fact that access to the memory <b>11</b>, which includes the cache <b>5</b>, main memory (i.e., random access memory <b>11</b>) and other memory such as non-volatile storage like hard disks, (not shown) involves a lengthy delay (in terms of processing time).</p>
<p id="p-0006" num="0005">One technique to improve performance is the use of &#x201c;pipelining.&#x201d; Pipelines improve performance by allowing a number of instructions to work their way through the microprocessor at the same time. For example, if each of the previously mentioned <b>4</b> steps of running programs is implemented as a pipeline cycle, then microprocessor <b>1</b> would start to decode (step <b>1</b>) a new instruction while the last instruction waits for results to continue. This would allow up to four instructions to be &#x201c;in flight&#x201d; at one time, making the microprocessor <b>1</b> appear to be up to four times as fast. Although any one instruction takes just as long to complete (there are still four steps) the microprocessor <b>1</b> as a whole &#x201c;retires&#x201d; instructions much faster and can be run at a much higher clock speed than in prior designs.</p>
<p id="p-0007" num="0006">Unfortunately, in a pipelined microprocessor <b>1</b>, a special condition exists. This condition is commonly referred to as &#x201c;load-hit-store&#x201d; (and also known as &#x201c;operand store compare&#x201d;). In load-hit-store, a load (also referred to herein as a &#x201c;fetch&#x201d; or as a &#x201c;read&#x201d;) from memory <b>11</b> (step <b>2</b> above) designates an address in memory that is the same as an address designated by a store (also referred to herein as an &#x201c;update&#x201d; or a &#x201c;write&#x201d;) to memory <b>11</b>.</p>
<p id="p-0008" num="0007">In load-hit-store, the most recent value intended for storing in an address location is not available for use in the load. That is, the data required for the load may not yet be stored in the address of the memory <b>11</b> or in the cache <b>5</b> and may be in progress, elsewhere in the microprocessor <b>1</b>.</p>
<p id="p-0009" num="0008">Previous designs have attempted to minimize delays due to load-hit-store conflicts by using store forwarding mechanisms to allow loads to reference store data result values before they are written into the cache <b>5</b>. Thus, such designs attempt to solve this problem without requiring loads to wait for either the cache <b>5</b> or memory <b>11</b> to be written before they execute. Consider three examples provided below that relate to store forwarding or load-hit-store handling.</p>
<p id="p-0010" num="0009">A first example is provided in U.S. Pat. No. 6,678,807, entitled &#x201c;System and method for multiple store buffer forwarding in a system with a restrictive memory model&#x201d; and issued on Jan. 13, 2004. This patent discloses use of multiple buffers for store forwarding in a microprocessor system with a restrictive memory model. In an embodiment, the system and method allow load operations that are completely covered by two or more store operations to receive data via store buffer forwarding in such a manner as to retain the side effects of the restrictive memory model thereby increasing microprocessor performance without violating the restrictive memory model.</p>
<p id="p-0011" num="0010">A further example is that of U.S. Pat. No. 6,393,536, entitled &#x201c;Load/store unit employing last-in-buffer indication for rapid load-hit-store,&#x201d; and issued on May 21, 2002. This patent discloses a load/store unit that includes a buffer configured to retain store memory operations which have probed the data cache. Each entry in the buffer includes a last-in-buffer (LIB) indication which identifies whether or not the store in that entry is the youngest store in the buffer to update the memory locations specified by the corresponding store address. Load addresses are compared to the store addresses, and the comparison result is qualified with the corresponding LIB indication such that only the youngest store is identified as a hit. At most one load hit store is detected.</p>
<p id="p-0012" num="0011">The third example is provided in U.S. Pat. No. 6,581,151, entitled &#x201c;Apparatus and method for speculatively forwarding storehit data based on physical page index compare,&#x201d; and issued on Jun. 17, 2003. This patent describes a speculative store forwarding apparatus in a pipelined microprocessor that supports paged virtual memory. The apparatus includes comparators that compare only the physical page index of load data with the physical page indexes of store data pending in store buffers to detect a potential store-hit. If the indexes match, forwarding logic speculatively forwards the newest store-hit data based on the index compare. The index compare is performed in parallel with a TLB lookup of the virtual page number of the load data, which produces a load physical page address. The load physical page address is compared with the store data physical page addresses to verify that the speculatively forwarded store-hit data is in the same page as the load data. If the physical page addresses mismatch, the apparatus stalls the pipeline in order to correct the erroneous speculative forward. The microprocessor stalls until the correct data is fetched.</p>
<p id="p-0013" num="0012">Prior solutions to load-hit-store conflicts using store forwarding have had difficulties with certain types of overlap between the load memory areas and store memory areas. The exemplary patents above either describe restrictions on the memory area overlap between loads and stores for allowing store forwarding, do not mention these restrictions, or do not attempt to address solutions for avoiding these restrictions at all. The following example demonstrates a load-hit-store memory overlap condition that prior art store forwarding designs cannot or did not attempt to resolve with store forwarding.</p>
<p id="p-0014" num="0013">Suppose there is a store A instruction that stores to 4 bytes in address locations 0, 1, 2, and 3. This store A instruction is followed closely by a load B instruction that loads 4 bytes from address locations 2, 3, 4, and 5. (Note that address location 5 is not to be confused with the reference numeral used to designate the cache <b>5</b>). If the store A has not yet updated the cache <b>5</b> or memory <b>11</b> at the time that load B requires the data, then there is a load-hit-store condition. This particular load-hit-store condition only exists for address locations 2 and 3. Locations 0 and 1 stored to by store A are not needed by load B. Also, the 2 bytes loaded by load B in address locations 4 and 5 are not stored to by store A. Not only does store A not store to addresses <b>4</b> and <b>5</b>, in previous designs the structures holding the data for store A would have no record of the values of locations 4 and 5. So, for load B to get all of the bytes it needs, it must get locations 2 and 3 from store A using store forwarding, and locations 4 and 5 from somewhere else (usually this would be the cache <b>5</b>). In prior art, this type of &#x201c;partial overlap&#x201d; between store A and load B is a violation of the restrictive memory model used and store forwarding is not allowed because there is no mechanism to determine which pieces of data should be forwarded from the store and which pieces of data need to be forwarded from the cache <b>5</b>. A mechanism to effectively forward parts of load data from different sources does not currently exist. The existing or prior art restrictive memory model assumes that either all data is forwarded from a single store structure or no data is forwarded and all data is accessed normally from the cache. Any case of store and load overlap that cannot be resolved by either of these two methods will result in a load-hit-store penalty (load must wait for the previous stores, that the load depends upon, to write the data into the cache).</p>
<p id="p-0015" num="0014">An additional example of a violation of prior art restrictive memory models would be store A to locations 0, 1, 2, and 3 followed by a store B to locations 2 and 3, followed by a load C to locations 0, 1, 2, and 3. If stores A and B have not yet updated the cache <b>5</b> at the time load C needs to load its data from the cache, there is a load-hit-store condition. Though store A does cover the exact same locations as load C it would be incorrect to forward all the bytes from store A since store B is more recent than store A, so locations 2 and 3 should be forwarded from store B while locations 0 and 1 are forwarded from store A. Prior art solutions would be able to handle the condition where there is a store A and load C without store B, but having store B in the middle violates the standard restrictive memory model used for store forwarding. As a result, the load must take a load-hit-store penalty. In order to avoid strict memory area overlap based restrictions on store forwarding, a new solution is required.</p>
<p id="p-0016" num="0015">What are needed are solutions to overcome situations where the most recently updated value for an address location from a respective store is not available for the load to use including cases where store data only partially overlaps with load data and cases where multiple stores may partially overlap with the load data and partially overlap with each other.</p>
<heading id="h-0002" level="1">BRIEF SUMMARY OF THE INVENTION</heading>
<p id="p-0017" num="0016">The shortcomings of the prior art are overcome and additional advantages are provided through the provision of, in one embodiment, a pipelined microprocessor including circuitry adapted for store forwarding, the microprocessor including circuits for performing: for each store request, and while a write to one of a cache and a memory is pending; obtaining the most recent value for at least one complete block of data; merging store data from the store request with the complete block of data thus updating the block of data and forming a new most recent value and an updated complete block of data; and buffering the updated complete block of data into a store data queue; for each load or store request, where the load request may require at least one updated completed block of data and the store request may require the most recent value for at least one complete block of data for merging with store data and forming a new most recent value and an updated complete block of data: determining if store forwarding is appropriate for the load or store request on a block-by-block basis; if store forwarding is appropriate, selecting an appropriate block of data from the store data queue on a block-by-block basis; and forwarding the selected block of data to the load or store request.</p>
<p id="p-0018" num="0017">An embodiment of a method for loading data in a pipelined microprocessor includes: issuing a load request that includes a load address requiring at least one block of data; determining if the at least one load block address matches any block addresses in a store address queue; if there is a match, then for the most recent entry in the queue that matched the corresponding block address, reading a data block from a buffer register designated by the store address queue and sending the data block to satisfy the load request; and if there is no match, then reading data block from a cache based on the address and sending the data block to satisfy the load request.</p>
<p id="p-0019" num="0018">Another embodiment of a method for storing data in a pipelined microprocessor includes: issuing a store request that includes a store address; determining if the store address matches an address in a store address queue; if there is a match, then for the most recent entry in the store address queue that matched, reading data from a register designated by the store address queue and sending the data as at least one block of data for merging with data from the store request; if there is no match, then reading data from a cache based on the store address and sending the at least one block of data for merging with the data from the store request; and setting at least one state bit for the store address and writing the store address queue with the store address.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0020" num="0019">Referring now to the drawings wherein like elements are numbered alike in the several figures, wherein:</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram presenting aspects of a typical microarchitecture;</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram illustrating aspects of an exemplary implementation the teachings herein;</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 3</figref> is a flow chart depicting an exemplary process for a load request; and</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIGS. 4</figref><i>a </i>and <b>4</b><i>b </i>flowcharts depicting an exemplary process for fulfilling a store address request.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<p id="p-0025" num="0024">The detailed description explains the preferred embodiments of the invention, together with advantages and features, by way of example with reference to the drawings.</p>
<heading id="h-0004" level="1">DETAILED DESCRIPTION OF EXEMPLARY EMBODIMENTS</heading>
<p id="p-0026" num="0025">Disclosed herein are aspects of microarchitecture for a microprocessor <b>1</b>. In particular, the microarchitecture provides advanced implementation of memory accessing including loading and storing to memory. The advanced implementation is referenced as an &#x201c;enhanced microarchitecture <b>100</b>&#x201d; shown in <figref idref="DRAWINGS">FIG. 2</figref> and as otherwise discussed herein.</p>
<p id="p-0027" num="0026">Generally presented herein are certain aspects of the invention, though the present invention may be applied in other embodiments not described herein. For example, other embodiments may be realized by changing the implementation to match the requirements of the architecture or microarchitecture of a microprocessor <b>1</b>. Accordingly, it is considered such other embodiments known now or later devised are contemplated by and a part of this invention.</p>
<p id="p-0028" num="0027">Two architectural or microarchitectural requirements or variables that may affect embodiments of this invention are the smallest granularity of data that can be addressed and loaded from memory and the largest granularity of data that can be addressed and loaded from memory. It is assumed that these two variables are not necessarily the same. How these (and other) requirements and variables may affect embodiments of the invention as described below.</p>
<p id="p-0029" num="0028">For convenience, some additional definitions are provided. First, as used herein, the term &#x201c;load&#x201d; is used generally and makes reference to an instruction for loading data from memory <b>11</b> into a register <b>6</b> (also a &#x201c;load request&#x201d;), as well as the process of loading from memory <b>11</b>. In some instances, the term &#x201c;load&#x201d; makes reference to data recently retrieved from memory <b>11</b>. Similarly, the term &#x201c;store&#x201d; is used generally and makes reference to an instruction for storing data from a register <b>6</b> into memory <b>11</b> (also, a &#x201c;store request&#x201d;). In some instances, the term &#x201c;store&#x201d; makes reference to data recently written to memory <b>11</b>. The store may relate to certain targets, such as a store data queue. The term &#x201c;granularity&#x201d; generally refers to a size of data in relation to computation or access to computing resources.</p>
<p id="p-0030" num="0029">Further, it should be recognized that the teachings herein may include other circuitry and components as necessary for providing the functions and features described herein. As an example, a component such as a &#x201c;load/store unit&#x201d; may be used for implementation, at least in part. Aspects may include embodiments of machine executable instructions stored on machine readable media for executing various tasks (i.e., software). Various combinations of hardware, firmware and software may be used for implementing the features and functions described herein. Accordingly, while the description provided herein is generally in reference to enhanced microarchitecture, the exemplary embodiments provided herein are not limiting of the invention and are merely illustrative.</p>
<p id="p-0031" num="0030">Further, the discussion of loads and store to a typical microprocessor implementation where these memory accesses are going through the local cache (L1), or simply refer to as cache, which is usually managed by a &#x201c;load/store unit&#x201d;. Operations about multi-level cache and memory relations are not necessarily described herein.</p>
<p id="p-0032" num="0031">The enhanced microarchitecture <b>100</b> as described herein minimizes the penalty of having a load wait for completion of a cache update from all stores to the same address(es) ahead of the load in the pipeline. Each load only need to wait for all the store update values to be available in the microprocessor <b>1</b>. In addition, there are no restrictions of either the load or stores in the pipeline for removing dependency on writing the cache <b>5</b>, such as those restrictions that are based purely on the amount of overlapping memory locations.</p>
<p id="p-0033" num="0032">That is, the enhanced microarchitecture <b>100</b> provides for forwarding of store data prior to the writing of cache <b>5</b> or memory <b>11</b> for the store. Accordingly, store forwarding minimizes the penalty of waiting for store writes to the cache <b>5</b> or memory <b>11</b> prior to a subsequent load.</p>
<p id="p-0034" num="0033">As an overview, the enhanced microarchitecture <b>100</b> provides for saving off (buffering) snapshots of the most current values of memory <b>11</b> into a store data queue after each store. The most current values in the store data queue include both data that is updated by the store as well as data that is not updated (data not yet updated by the store is referred to herein as &#x201c;background data&#x201d;). Then, using control logic and the results of address compares, a determination is made as to whether store forwarding can be used to avoid the normal penalties of load-hit-store and which store data queue entry should be forwarded. The data forwarded from the store queue entry is used as a contiguous block of data that acts as a complete replacement for the data normally loaded from the cache <b>5</b>. Note that the block size (which is the store data queue entry size) can be smaller than the normal cache return size and can replace only part of the overall cache return (with the rest of the return data still referencing the cache data). In this way, there is no need for subset or superset memory area overlap restrictions on either the load or the store(s), since each part of the load data can either reference the cache data or store forward data from any queue entry. Accordingly, different queue entries (meaning different stores) can independently be used to forward to the different parts of any given load.</p>
<p id="p-0035" num="0034">Also for convenience, a discussion of aligned data, unaligned data and memory ranges is provided. In this regard, a &#x201c;sub-block&#x201d; describes the smallest granularity of memory <b>11</b> that can be addressed by a load or store, and all loads and stores access or update an integral number of sub-blocks. Then assume that an exemplary embodiment of enhanced microarchitecture <b>100</b> has a sub-block size of one (1) byte. The exemplary embodiment defines a word to be four (4) bytes and a double-word to be eight (8) bytes. By convention, an aligned range of data always begins at a memory address that is an integral multiple of its length. For example, an aligned double-word always starts on a byte address that is an integral multiple of eight (8) and includes all the bytes up until the next byte address that is a multiple of eight (8) (for a total length of eight (8) bytes). Assume the largest granularity of memory that is used for storage by a single instruction is eight (8) bytes (with a minimum length of one (1) byte and no restrictions on starting or ending address so the data can be unaligned). Then assume that each store pipe can perform one store instruction each cycle and that there are two store pipes that can independently send store data into a Load/Store Unit at the same time in the cycle. Also, assume that there are two (2) load pipes and each load pipe can access one (1) aligned even double-word and one (1) odd aligned double-word of data and the even and odd double-word of data do not necessarily belong to the same aligned quad-word of memory but are contiguous (an even double-word is a double-word that begins at an even integral byte address of 8, and an odd double-word begins at an odd integral byte address of eight (8)). Note that depending on the embodiment, there typically may be other restrictions for returning both even and odd DWs on a given pipe. For example, it may be required that both even and odd DWs belong to the same cache line entry for both to return the correct data from the cache. The structure of the cache <b>5</b> would be built to support these load return requirements. For example, if the address width is 64 bits with bit <b>0</b> as the most significant address bit and bit <b>63</b> as the least significant bit, then bit <b>63</b>=&#x2018;0&#x2019; would describe all the even bytes and bit <b>63</b>=&#x2018;1&#x2019; would describe all the odd bytes. Then this would mean that any access to bytes with address bit <b>60</b>=&#x2018;0&#x2019; would be to an even double-word and any access to bytes with address bit <b>60</b>=&#x2018;1&#x2019; would be to an odd double-word. For the even and the odd double-word to be allowed to be different quad-words would mean that address bits <b>0</b>:<b>59</b> could be different. Then, a cache structure to support this load bandwidth requirement would have one half of the cache supporting requests to all bytes that have address bit <b>60</b>=&#x2018;0&#x2019; (even double-words) and one half of the cache supporting requests to bytes that have address bit <b>60</b>=&#x2018;1&#x2019; (odd double-words). Each cache half would need to be able to take requests to different address bits <b>0</b>:<b>59</b>, and each cache half would then support up to two (2) independent requests at once since there are two (2) independent load pipes.</p>
<p id="p-0036" num="0035">Given the base design descriptions, one embodiment includes a block size the same as the largest contiguous data return from the cache, which is one (1) double-word. In this implementation, the block size is used as the store data queue entry size. In this embodiment, the largest aligned contiguous data return from the cache determines the largest granular data size that is loaded from memory. Since the cache return from each cache half is one (1) double-word that is aligned to storage boundaries (eight (8) bytes starting with address bits <b>61</b>:<b>63</b>=&#x2018;000&#x2019;b and ending with address bits <b>61</b>:<b>63</b>=&#x2018;111&#x2019;b), an easy implementation for store forwarding makes the data in the queue entry storage aligned. If the store data queue entries are storage aligned, then the data queue entries are split into two (2) halves, one (1) for even double-words and one (1) for odd double-words, similar to the cache. This provides an easy correlation between queue entries and the cache for store forwarding, and also provides a way to handle store data that can be eight (8) bytes in size (which is not necessarily aligned to memory boundaries). Because the stores are contiguous and the maximum store size is eight (8) bytes, the design can only update bytes in up to two (2) different memory aligned double-words (in this embodiment), and in particular it can only update at most one (1) even double-word and one (1) odd double-word (though the even double-word may be updated first and then the odd double-word or vice-versa).</p>
<p id="p-0037" num="0036">Note for this embodiment, there are advantages in dealing with block sizes that are based on the largest granularities of data manipulation and data transfer supported by the microprocessor (double-word) rather than with the smallest granularities of data manipulation required by the architecture (byte). When using a large block size matching the maximum data granularity (as detailed above), at most two (2) sets of independent compares and controls are needed to manipulate the two (2) blocks. If the smallest block size was used (byte), then there would need to be at least as many independent sets of compares and controls as the largest data size divided by the minimum block size which in this embodiment would be eight (8) sets of compares and controls (one (1) set for each byte in a double-word).</p>
<p id="p-0038" num="0037">In this embodiment, the overall structure used to handle all stores and is referred to as a &#x201c;store queue.&#x201d; A store queue includes of one or more entries, with each entry including a starting address register, an ending address register, a starting data register, an ending data register, and some control states (such as valid bits). The data registers hold memory aligned double-word blocks such that the starting data register would hold memory contents directly associated with the entry's starting address 0:60, and the ending data register would hold memory contents directly associated with the entry's ending address 0:60. The portion of the store queue all the address registers is referred to as the store address queue. The portion of the store queue including all the data registers is referred to as the store data queue.</p>
<p id="p-0039" num="0038">Refer now to <figref idref="DRAWINGS">FIG. 2</figref>, which presents a block diagram that shows aspects of implementation of the microarchitecture, and also to <figref idref="DRAWINGS">FIGS. 3 and 4</figref>. <figref idref="DRAWINGS">FIG. 2</figref> depicts an embodiment showing three (3) store address queue and store data queue entries, while <figref idref="DRAWINGS">FIGS. 3 and 4</figref> are exemplary flow charts that show general aspects of handling load and store address requests respectively by the enhanced microarchitecture <b>100</b>.</p>
<p id="p-0040" num="0039">Assume that the microprocessor <b>1</b> requests loads and stores with their addresses in program order, and that store data is always presented in order, and that the store address is always available before the store data is presented. The processing of a store would involve taking the address of the store request <b>300</b> and writing the address (and other request related information) into a store address queue <b>110</b>/<b>310</b>. At the same time, the store would be treated as a load and the data from the cache for that address location would be accessed <b>120</b>/<b>320</b>. This data is accessed from the cache in order to have all the bytes of the memory aligned double-word available that may not be updated for the store (the &#x201c;background data&#x201d;). The memory aligned double-word or two (2) double-words of background data for the store <b>130</b> are then written into the appropriate store data queue entry (or entries) reserved for the store at block <b>322</b>. When the store result data is available, the store data is shifted or rotated as necessary to align the store bytes to memory boundaries by a rotator <b>140</b> at block <b>324</b>. Then the store data is written into the associated store data queue entry, but only the appropriate bytes are updated such that the background data that is already saved off in the store data queue entry is replaced by the store data <b>326</b>. This process is referred to as &#x201c;byte merging&#x201d; the store data onto the background data. The resulting even and/or odd double-words in the store data queue that are the result of byte merging are now the correct and most recent values of the double-word for the state of the microprocessor (and overall system) at the time of the completion of the store. The queue entry or entries can now be tagged as valid for store forwarding for any following instructions that need to access those double-words at block <b>328</b>. The queue entry or entries are now also valid for writing the entire contents of the double-word into the cache hierarchy <b>160</b>.</p>
<p id="p-0041" num="0040">For a load, first the address of the load <b>210</b> is compared to all the stores that are ahead of it in the pipeline that have not yet written their stores into the cache <b>170</b>/<b>270</b>. This embodiment assumes the microprocessor <b>1</b> is making load and store requests with addresses in program order, so all stores that are ahead of this load have known addresses that are written into the store address queue. For all cases where the addresses for the bytes of the load overlap with any addresses for the bytes that are being stored and have not yet written the cache, there are one of two results.</p>
<p id="p-0042" num="0041">In a first result, there are one or more bytes of the load where the most recent store data has not yet been merged with double-word based background data and written into the store data queue (store forwarding valid bit is off). In this case, the load-hit-store condition is not resolved with store forwarding and the load request cannot be processed at this time <b>271</b>.</p>
<p id="p-0043" num="0042">As an alternative, all of the bytes of the load that overlap with store data correspond with most recent store data that have already been merged with background data such that the most recent value or values for the memory aligned double-word or double-words associated with those bytes are available in the store data queue (all required store forwarding valid bits are on) at block <b>274</b>. In this case, the load-hit-store condition can be resolved by using the appropriate double-words of data from the store data queue corresponding to the most recent double-word for those double-words of the load that contain bytes that overlap with stores that have not yet written the cache <b>180</b>/<b>280</b>. These double-words from the store data queue should be used as the load data instead of double-words of data from the cache <b>120</b>/<b>220</b> (normally implemented using a 2 to 1 multiplexer (mux) <b>190</b>/<b>290</b>).</p>
<p id="p-0044" num="0043">Given the even versus odd double-word structure of both the cache and the store data queue, one easy method of implementing the load versus store compares is to have separate even double-word address compares and odd double-word address compares. This provides for determining which store queue entries could be used for store forwarding purposes on a per even/odd double-word basis. Then, the potentially multiple store queue entries that compare with the load can be filtered down to a single entry by determining which entry contains the most recent value for the double-word, The most recent double-word from stores (if any) can then be determined and used to replace cache data on a per even/odd double-word basis.</p>
<p id="p-0045" num="0044">One method that may be used by the enhanced microarchitecture <b>100</b> for determining the most recent double-word of data is to also use double-word address compares <b>170</b>/<b>370</b> for store requests. The results of these address compares are used to determine which store queue entries should have their &#x201c;I am the most recent double-word&#x201d; state bits reset <b>372</b> at the same time that a current store request sets the &#x201c;I am most recent double-word&#x201d; state bit for its store queue entry (or entries) <b>373</b> if they are all for the same double-word. In this way, there should always only be at most one store queue entry with its &#x201c;I am most recent double-word&#x201d; state bit on for any given memory aligned double-word at block <b>375</b>. These state bits can then be ANDed individually with their corresponding store address queue entry compares to determine which of the compares corresponds to the entry that is the most recent for that double-word. In addition, the store forwarding valid bits can be ANDed individually with their corresponding compares and most recent double-word state bits to determine whether the most recent store data queue entry can be used for store forwarding and replace the cache data <b>170</b>/<b>274</b>.</p>
<p id="p-0046" num="0045">As the background data for stores may not always be able to access the most recent data value from the cache, a further technique is used by the enhanced microarchitecture <b>100</b>. Note that in this context, the background data access is like a load in that the most recent data may not yet be available because a store ahead of it in the pipeline has not yet written its store data into the cache. In particular, this becomes a problem when the stores that are ahead in the pipeline need to write to the double-word that the current store needs as background data, but the bytes of the stores that are ahead are not pure subsets of the bytes of the current store (for that double-word) such that they truly modify bytes that are background data that will not be overwritten by the current store.</p>
<p id="p-0047" num="0046">Using the same terminology as load-hit-store, this situation can be termed a &#x201c;store-hit-store&#x201d; or background data-hit-store. In this embodiment, the solution to this store-hit-store problem is to simply treat each store request with address like a fetch request with address and solve the store-hit-store problem for stores in the same way that the load-hit-store problem is solved for loads. The results of address comparisons with the store address queue <b>170</b>/<b>370</b> that were used for loads as part of the load-hit-store solution are now used as part of the store-hit-store solution. Like loads, store background data can only be forwarded from store queue entries that have the &#x201c;I am most recent double-word&#x201d; state and that already have their store data <b>374</b>. There may be situations where the store-hit-store problem cannot be resolved using store forwarding from the store queue (one example would be the store data is not yet available for forwarding) <b>371</b>, but this same problem would exist for regular load-hit-store situations that cannot be resolved with store forwarding <b>271</b>. This problem can be solved by taking the same action as a load-hit-store situation where a delay of the load (or store) is necessary, or some other special solutions must be used. If the store-hit-store problem can be resolved using store forwarding, then for the appropriate double-words, the data from the most recent store data queue entry <b>180</b>/<b>380</b> is used to write background data into the store data queue entry <b>100</b>/<b>300</b> for the current store instead of data from the cache <b>130</b>/<b>330</b>. As mentioned above, additionally this situation would result in the store queue entry that was considered most recent for this double-word (and that was the source for the current store request background data) to result in getting its &#x201c;I am most recent&#x201d; state bit reset (due to the address compare) <b>372</b> and for the current store request to get its &#x201c;I am most recent&#x201d; bit set <b>373</b>, thus correctly updating which store queue entry is most recent and avoiding having multiple entries to the same double-word tagged as most recent.</p>
<p id="p-0048" num="0047">Accessing and generating the most recent background data for each store has other potential benefits. One example is the ability to easily add functionality to the design to accurately detect stores that do not change any data in memory. These stores that write or &#x201c;update&#x201d; memory with the same value that already exists in memory is commonly known as &#x201c;silent stores&#x201d;. Because these silent stores cause no change to the values of memory, there is no need to process these stores once they are detected and valuable resources may be conserved by not writing these stores to memory.</p>
<p id="p-0049" num="0048">Before describing the next additional functionality to this embodiment, some background must be provided on typical cache structure and design. A typical cache can be broken into two conceptual parts: one part holds the data and is typically called &#x201c;the cache&#x201d; or &#x201c;the cache array&#x201d; and the other part holds the address corresponding to the data and is typically called the &#x201c;directory&#x201d;. The correct data is determined to be in the cache if the address of the requested data is found in a valid entry within the directory. This is also known as a &#x201c;cache hit&#x201d;. One popular form of cache and directory structure is known as &#x201c;set associativity&#x201d;. A cache with set associativity has a number of &#x201c;rows&#x201d; and a number of &#x201c;sets&#x201d;. Each row of the cache array and directory contains a number of entries with each of these entries denoted by a unique set identifier (abbreviated as &#x201c;set id&#x201d;). A row of the data is accessed from the cache array and a row of addresses is accessed from the directory using a subset of the overall address. This subset of the address used to access a row in the cache and directory is referred to as the index address. Then the rest of the address for the access is compared to the addresses of the row of entries accessed by the directory. If there is an address match, a &#x201c;hit&#x201d; is indicated and the set id of the entry hit in that row in the directory is sent to the cache array. This set id is then used to select the correct entry of data from the row in the cache array. If there is no address match, then a &#x201c;miss&#x201d; is indicated and there is no valid set id corresponding to this access and there is no valid data from the cache array. After a processor encounters a cache miss, it must retrieve the requested data from another cache or from memory into its cache and then update its directory with the request address for this data in order to get a hit and return the requested data from its cache in the future.</p>
<p id="p-0050" num="0049">The address compares used to select the correct store data queue entry for store forwarding (if any) do not have to be implemented as full double-word address compares (in this embodiment comparing address bits <b>0</b> to <b>60</b>). Due to timing and physical design constraints, it may not be possible or desirable to implement such wide compares. This is especially true if the microprocessor pipeline requires data from the cache to be accessed immediately after the address is generated, the cache has a very fast access time, and implementing a full compare would result in store forwarding data arriving later than cache data. One solution to this is to use a mechanism to predict which store queue entry will likely need to be used for store forwarding and to take corrective actions if this prediction is wrong. One example of a prediction mechanism involves using only a part of the address range for comparing when selecting a store data queue entry for store forwarding. If the cache uses set associativity, one implementation calls for comparing of the address bits used to index the cache (down to the double-word). Typically, the address bits used to index a set associative cache are known early, but the set identifiers used to select the data in the cache from the correct set are known much later since they are typically generated after accessing a row in the directory and performing a large address compare, and also the set id information is needed much later by the cache (after the correct row has been accessed from the cache). Using a subset of address bits for compares does allow for multiple store queue entries to compare to the load, but this can be handled by filtering the compares by only allowing entries with the &#x201c;I am most recent double-word&#x201d; state bit (described above) to be forwarded.</p>
<p id="p-0051" num="0050">In order to avoid multiple entries being selected for store forwarding after this filtering, all stores using the same cache index (down to the double-word) can be treated as being to the same double-word for the purposes of setting or resetting the &#x201c;I am the most recent double-word&#x201d; (in effect the state then becomes &#x201c;I am the most recent double-word for all double-words matching this cache index&#x201d;). Recall that for background data, stores like loads must hit in the directory and cache and retrieve the correct set id information for accessing the cache. For this reason (and often others), the store must hit in the directory with a valid set id before the operation can complete, and this set id information can be recorded in the store queue. The assumption is that any load that uses the same cache index as an outstanding store will likely also be accessing the same set id as the store. Later, after the set id of the load is known, the load set id must be compared to the set id associated with the store data that was forwarded to determine if the prediction based only on cache index was correct (some cache designs already save off the set id for all stores anyway for writing the cache for stores). If the prediction is correct, no special action is needed. If the prediction is incorrect, then the data for the load request must be thrown away, and the load request must be redone. To avoid repeating this mis-prediction, one could reset the state that allows forwarding from the store that was incorrectly forwarded. Note that this general prediction mechanism of using a subset of the address bits for the initial compare used to select the correct store data queue entry can also be applied to caches that do not employ set associativity. If the cache is a direct mapped design, an arbitrary subset of address bits can be used for prediction and a simple cache hit indication can be used in place of set id compares to determine if the store forwarding action was correct.</p>
<p id="p-0052" num="0051">The enhanced microarchitecture <b>100</b> can be modified to handle additional functions. One example of an additional function is fulfilling an architectural requirement to process store instructions that store more data than can be delivered on a single store pipe or on a single cycle (known as &#x201c;long storing instructions&#x201d;). The general solution would be to break up the long storing instruction into many smaller stores that each store on the maximum data size that can be delivered on a pipe within a single cycle. One implementation would be to treat each of these smaller stores just like any other &#x201c;short&#x201d; storing instruction.</p>
<p id="p-0053" num="0052">Another example of an additional function is addressing a physical design area, wiring, or cycle time requirement that precludes the ability of comparing and selecting every block of store data that has been delivered and buffered but has not yet written the cache. In this case, one solution is to pre-select a subset of all the store data that has been delivered and needs to be buffered (before writing the cache) for store forwarding and to put only the selected store data and store addresses in the structures used for store forwarding. There are various methods or algorithms that can be applied to predict which blocks of store data are most likely to be referenced by future fetches or stores to optimize performance. One example of an algorithm for selecting a subset of data for forwarding is selecting only the first memory aligned block (double-word if using the above embodiment) and last memory aligned block of store data for store forwarding. This algorithm is useful for situations where there are long storing instructions. In this case, all of the &#x201c;middle&#x201d; memory aligned blocks would be buffered for writing the cache, but would not be available for store forwarding <b>151</b>. Though this solution would technically introduce a type of memory area overlap restriction, in reality this is just a simple way of restricting the implementation cost of supporting store forwarding for long stores by only making a subset of the total store data available for forwarding. Thus, supporting various kinds of memory area overlap between loads and stores is not an inherent problem for the enhanced microarchitecture <b>100</b>.</p>
<p id="p-0054" num="0053">The technical effects and benefits include, among other things, solutions that are provided to overcome situations where the most recently updated value for an address location from a respective store is not available for a load to use including cases where store data only partially overlaps with load data and cases where multiple stores may partially overlap with the load data and partially overlap with each other.</p>
<p id="p-0055" num="0054">The flow diagrams depicted herein are just examples. There may be many variations to these diagrams or the steps (or operations) described therein without departing from the spirit of the invention. For instance, the steps may be performed in a differing order, or steps may be added, deleted or modified. All of these variations are considered a part of the claimed invention.</p>
<p id="p-0056" num="0055">While the invention has been described with reference to exemplary embodiments, it will be understood by those skilled in the art that various changes may be made and equivalents may be substituted for elements thereof without departing from the scope of the invention. In addition, many modifications may be made to adapt a particular situation or material to the teachings of the invention without departing from the essential scope thereof. Therefore, it is intended that the invention not be limited to the particular embodiment disclosed as the best mode contemplated for carrying out this invention, but that the invention will include all embodiments falling within the scope of the appended claims. Moreover, the use of the terms first, second, etc. do not denote any order or importance, but rather the terms first, second, etc. are used to distinguish one element from another.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for loading data in a pipelined microprocessor, the method comprising:
<claim-text>issuing a load request that comprises a load address requiring at least one block of data, the at least one block of data the same size as a largest contiguous granularity of data returned from a cache;</claim-text>
<claim-text>determining that the load address matches at least one block address in a store address queue, wherein determining that there is a match comprises using a cache index address for a comparison between the load address and an address in the store address queue;</claim-text>
<claim-text>based on determining that there is an address match, performing a) through c):
<claim-text>a) reading a data block from a buffer register designated by the matching address in the store address queue and sending the data block along with data from the cache to satisfy the load request for a most recent entry in the store address queue that matches the load address;</claim-text>
<claim-text>b) comparing a unique set id of the data block to the set id of the matching address in the store address queue after sending the data block;</claim-text>
<claim-text>c) based on determining that there is a set id match, continuing the load request, or, based on determining that there is not a set id match, setting a store-forwarding state of the matching address in the store address queue to no store-forwarding and rejecting the load request; and</claim-text>
</claim-text>
<claim-text>reading a data block from a cache based on the load address and sending the data block to satisfy the load request, based on determining that there is no address match.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method as in <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising, determining that the store-forwarding state of a matching address in the store address queue is set for no store-forwarding based on determining that there is a match, and performing no store-forwarding based on determining that the store-forwarding state of the matching address in the store address queue is set to no store-forwarding.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method as in <claim-ref idref="CLM-00001">claim 1</claim-ref>, where, for a match, a most recent entry in the store address queue is determined using a most recent data state.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method as in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein a size of a block of data is based on the largest granularity of data supported by the microprocessor.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method as in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the store address queue comprises a starting address register, an ending address register, a starting data register, an ending data register and at least one state bit.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. A pipelined microprocessor comprising circuitry configured to perform store-forwarding, the microprocessor comprising circuits for performing:
<claim-text>issuing a load request that comprises a load address requiring at least one block of data, the at least one block of data the same size as a largest contiguous granularity of data returned from a cache;</claim-text>
<claim-text>determining that the load address matches at least one block address in a store address queue, wherein determining that there is a match comprises using a cache index address for a comparison between the load address and an address in the store address queue;</claim-text>
<claim-text>based on determining that there is an address match, performing a) through c):
<claim-text>a) reading a data block from a buffer register designated by the matching address in the store address queue and sending the data block along with data from the cache to satisfy the load request for a most recent entry in the store address queue that matches the load address</claim-text>
<claim-text>b) comparing a unique set id of the data block to the set id of the matching address in the store address queue after sending the data block;</claim-text>
<claim-text>c) based on determining that there is a set id match, continuing the load request, or, based on determining that there is not a set id match, setting a store-forwarding state of the matching address in the store address queue to no store-forwarding and rejecting the load request; and</claim-text>
</claim-text>
<claim-text>reading a data block from a cache based on the load address and sending the data block to satisfy the load request, based on determining that there is no address match.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The microprocessor as in <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein a size of a block of data is based on the largest granularity of data supported by the microprocessor.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The microprocessor as in <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the store address queue comprises a starting address register, an ending address register, a starting data register, an ending data register and at least one state bit.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The microprocessor as in <claim-ref idref="CLM-00006">claim 6</claim-ref>, further comprising, determining that the store-forwarding state of a matching address in the store address queue is set for no store-forwarding based on determining that there is a match, and performing no store-forwarding based on determining that the store-forwarding state of the matching address in the store address queue is set to no store-forwarding.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The microprocessor as in <claim-ref idref="CLM-00006">claim 6</claim-ref>, where, for a match, a most recent entry in the store address queue is determined using most recent data state. </claim-text>
</claim>
</claims>
</us-patent-grant>
