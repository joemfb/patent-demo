<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627178-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627178</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13946136</doc-number>
<date>20130719</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>11</class>
<subclass>C</subclass>
<main-group>29</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>714763</main-classification>
<further-classification>714751</further-classification>
<further-classification>714752</further-classification>
<further-classification>714770</further-classification>
</classification-national>
<invention-title id="d2e43">Adjusting data dispersal in a dispersed storage network</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5774643</doc-number>
<kind>A</kind>
<name>Lubbers et al.</name>
<date>19980600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714 20</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>2002/0194427</doc-number>
<kind>A1</kind>
<name>Hashemi</name>
<date>20021200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711114</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>2003/0018927</doc-number>
<kind>A1</kind>
<name>Gadir et al.</name>
<date>20030100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714  4</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2007/0079081</doc-number>
<kind>A1</kind>
<name>Gladwin et al.</name>
<date>20070400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711154</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>2007/0079082</doc-number>
<kind>A1</kind>
<name>Gladwin et al.</name>
<date>20070400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711154</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2010/0241920</doc-number>
<kind>A1</kind>
<name>Nonogaki</name>
<date>20100900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714752</main-classification></classification-national>
</us-citation>
</us-references-cited>
<number-of-claims>18</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>714751</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714752</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714763</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714770</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>13</number-of-drawing-sheets>
<number-of-figures>14</number-of-figures>
</figures>
<us-related-documents>
<continuation>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>12983214</doc-number>
<date>20101231</date>
</document-id>
<parent-grant-document>
<document-id>
<country>US</country>
<doc-number>8495466</doc-number>
<date>20130723</date>
</document-id>
</parent-grant-document>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>13946136</doc-number>
</document-id>
</child-doc>
</relation>
</continuation>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61314166</doc-number>
<date>20100316</date>
</document-id>
</us-provisional-application>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20130311851</doc-number>
<kind>A1</kind>
<date>20131121</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only" applicant-authority-category="assignee">
<addressbook>
<orgname>Cleversafe, Inc.</orgname>
<address>
<city>Chicago</city>
<state>IL</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Clifone</last-name>
<first-name>Bart</first-name>
<address>
<city>Chicago</city>
<state>IL</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Resch</last-name>
<first-name>Jason K.</first-name>
<address>
<city>Chicago</city>
<state>IL</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Gladwin</last-name>
<first-name>S. Christopher</first-name>
<address>
<city>Chicago</city>
<state>IL</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Garlick &#x26; Markison</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Markison</last-name>
<first-name>Timothy W.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Cleversafe, Inc.</orgname>
<role>02</role>
<address>
<city>Chicago</city>
<state>IL</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Ehne</last-name>
<first-name>Charles</first-name>
<department>2113</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A method begins with a processing module determining that storage of data requires updating, wherein the data is stored as a plurality of sets of encoded data slices in DSN memory. For a first type of updating, the processing module increases the total number while maintaining the decode threshold number. The processing module then, for each set of encoded data slices, creates another encoded data slice in accordance with the dispersed storage error encoding function and the increased total number and sends the new encoded data slices to the DSN memory. For a second type of updating, the processing module increases the total number and the decode threshold number. The processing module then recovers the data and encodes it in accordance with the dispersed storage error encoding function using the increased total number and the increased decode threshold number to produce an updated plurality of sets of encoded data slices.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="112.78mm" wi="156.89mm" file="US08627178-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="192.70mm" wi="158.75mm" orientation="landscape" file="US08627178-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="237.91mm" wi="191.69mm" orientation="landscape" file="US08627178-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="258.32mm" wi="213.11mm" orientation="landscape" file="US08627178-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="201.34mm" wi="158.75mm" orientation="landscape" file="US08627178-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="146.47mm" wi="207.69mm" orientation="landscape" file="US08627178-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="228.18mm" wi="200.49mm" orientation="landscape" file="US08627178-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="252.65mm" wi="197.02mm" orientation="landscape" file="US08627178-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="261.11mm" wi="211.50mm" orientation="landscape" file="US08627178-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="221.57mm" wi="208.36mm" orientation="landscape" file="US08627178-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="219.71mm" wi="205.23mm" orientation="landscape" file="US08627178-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="219.03mm" wi="205.23mm" orientation="landscape" file="US08627178-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="221.91mm" wi="201.76mm" orientation="landscape" file="US08627178-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="219.03mm" wi="199.22mm" orientation="landscape" file="US08627178-20140107-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CROSS REFERENCE TO RELATED PATENTS</heading>
<p id="p-0002" num="0001">The present U.S. Utility Patent Application claims priority pursuant to 35 U.S.C. &#xa7;120, as a continuation, to the following U.S. Utility Patent Application, which is hereby incorporated herein by reference in its entirety and made part of the present U.S. Utility Patent Application for all purposes:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0002">1. U.S. Utility application Ser. No. 12/983,214, entitled &#x201c;ADJUSTING DATA DISPERSAL IN A DISPERSED STORAGE NETWORK,&#x201d;, filed Dec. 31, 2010, issuing as U.S. Pat. No. 8,495,466 on Jul. 23, 2013, which claims priority pursuant to 35 U.S.C. &#xa7;119(e) to the following U.S. Provisional Patent Application, which is hereby incorporated herein by reference in its entirety and made part of the present U.S. Utility Patent Application for all purposes:
        <ul id="ul0003" list-style="none">
            <li id="ul0003-0001" num="0003">a. U.S. Provisional Application Ser. No. 61/314,166, entitled &#x201c;STORAGE AND RETRIEVAL IN A DISTRIBUTED STORAGE SYSTEM,&#x201d;, filed Mar. 16, 2010.</li>
        </ul>
        </li>
    </ul>
    </li>
</ul>
</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">STATEMENT REGARDING FEDERALLY SPONSORED RESEARCH OR DEVELOPMENT</heading>
<p id="p-0003" num="0004">NOT APPLICABLE</p>
<heading id="h-0003" level="1">INCORPORATION-BY-REFERENCE OF MATERIAL SUBMITTED ON A COMPACT DISC</heading>
<p id="p-0004" num="0005">NOT APPLICABLE</p>
<heading id="h-0004" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0005" num="0006">1. Technical Field of the Invention</p>
<p id="p-0006" num="0007">This invention relates generally to computing systems and more particularly to data storage solutions within such computing systems.</p>
<p id="p-0007" num="0008">2. Description of Related Art</p>
<p id="p-0008" num="0009">Computers are known to communicate, process, and store data. Such computers range from wireless smart phones to data centers that support millions of web searches, stock trades, or on-line purchases every day. In general, a computing system generates data and/or manipulates data from one form into another. For instance, an image sensor of the computing system generates raw picture data and, using an image compression program (e.g., JPEG, MPEG, etc.), the computing system manipulates the raw picture data into a standardized compressed image.</p>
<p id="p-0009" num="0010">With continued advances in processing speed and communication speed, computers are capable of processing real time multimedia data for applications ranging from simple voice communications to streaming high definition video. As such, general-purpose information appliances are replacing purpose-built communications devices (e.g., a telephone). For example, smart phones can support telephony communications but they are also capable of text messaging and accessing the internet to perform functions including email, web browsing, remote applications access, and media communications (e.g., telephony voice, image transfer, music files, video files, real time video streaming. etc.).</p>
<p id="p-0010" num="0011">Each type of computer is constructed and operates in accordance with one or more communication, processing, and storage standards. As a result of standardization and with advances in technology, more and more information content is being converted into digital formats. For example, more digital cameras are now being sold than film cameras, thus producing more digital pictures. As another example, web-based programming is becoming an alternative to over the air television broadcasts and/or cable broadcasts. As further examples, papers, books, video entertainment, home video, etc. are now being stored digitally, which increases the demand on the storage function of computers.</p>
<p id="p-0011" num="0012">A typical computer storage system includes one or more memory devices aligned with the needs of the various operational aspects of the computer's processing and communication functions. Generally, the immediacy of access dictates what type of memory device is used. For example, random access memory (RAM) memory can be accessed in any random order with a constant response time, thus it is typically used for cache memory and main memory. By contrast, memory device technologies that require physical movement such as magnetic disks, tapes, and optical discs, have a variable response time as the physical movement can take longer than the data transfer, thus they are typically used for secondary memory (e.g., hard drive, backup memory, etc.).</p>
<p id="p-0012" num="0013">A computer's storage system will be compliant with one or more computer storage standards that include, but are not limited to, network file system (NFS), flash file system (FFS), disk file system (DFS), small computer system interface (SCSI), internet small computer system interface (iSCSI), file transfer protocol (FTP), and web-based distributed authoring and versioning (WebDAV). These standards specify the data storage format (e.g., files, data objects, data blocks, directories, etc.) and interfacing between the computer's processing function and its storage system, which is a primary function of the computer's memory controller.</p>
<p id="p-0013" num="0014">Despite the standardization of the computer and its storage system, memory devices fail; especially commercial grade memory devices that utilize technologies incorporating physical movement (e.g., a disc drive). For example, it is fairly common for a disc drive to routinely suffer from bit level corruption and to completely fail after three years of use. One solution is to a higher-grade disc drive, which adds significant cost to a computer.</p>
<p id="p-0014" num="0015">Another solution is to utilize multiple levels of redundant disc drives to replicate the data into two or more copies. One such redundant drive approach is called redundant array of independent discs (RAID). In a RAID device, a RAID controller adds parity data to the original data before storing it across the array. The parity data is calculated from the original data such that the failure of a disc will not result in the loss of the original data. For example, RAID 5 uses three discs to protect data from the failure of a single disc. The parity data, and associated redundancy overhead data, reduces the storage capacity of three independent discs by one third (e.g., n&#x2212;1=capacity). RAID 6 can recover from a loss of two discs and requires a minimum of four discs with a storage capacity of n&#x2212;2.</p>
<p id="p-0015" num="0016">While RAID addresses the memory device failure issue, it is not without its own failures issues that affect its effectiveness, efficiency and security. For instance, as more discs are added to the array, the probability of a disc failure increases, which increases the demand for maintenance. For example, when a disc fails, it needs to be manually replaced before another disc fails and the data stored in the RAID device is lost. To reduce the risk of data loss, data on a RAID device is typically copied on to one or more other RAID devices. While this addresses the loss of data issue, it raises a security issue since multiple copies of data are available, which increases the chances of unauthorized access. Further, as the amount of data being stored grows, the overhead of RAID devices becomes a non-trivial efficiency issue.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWING(S)</heading>
<p id="p-0016" num="0017"><figref idref="DRAWINGS">FIG. 1</figref> is a schematic block diagram of an embodiment of a computing system in accordance with the invention;</p>
<p id="p-0017" num="0018"><figref idref="DRAWINGS">FIG. 2</figref> is a schematic block diagram of an embodiment of a computing core in accordance with the invention;</p>
<p id="p-0018" num="0019"><figref idref="DRAWINGS">FIG. 3</figref> is a schematic block diagram of an embodiment of a distributed storage processing unit in accordance with the invention;</p>
<p id="p-0019" num="0020"><figref idref="DRAWINGS">FIG. 4</figref> is a schematic block diagram of an embodiment of a grid module in accordance with the invention;</p>
<p id="p-0020" num="0021"><figref idref="DRAWINGS">FIG. 5</figref> is a diagram of an example embodiment of error coded data slice creation in accordance with the invention;</p>
<p id="p-0021" num="0022"><figref idref="DRAWINGS">FIG. 6</figref> is a flowchart illustrating an example of storing data as encoded data slices in accordance with invention;</p>
<p id="p-0022" num="0023"><figref idref="DRAWINGS">FIG. 7</figref> is a flowchart illustrating an example of re-storing data as encoded data slices in accordance with invention;</p>
<p id="p-0023" num="0024"><figref idref="DRAWINGS">FIG. 8A</figref> is a diagram illustrating an example of data segmentation of data in accordance with the invention;</p>
<p id="p-0024" num="0025"><figref idref="DRAWINGS">FIG. 8B</figref> is a diagram illustrating an example of encoding data segments in accordance with the invention;</p>
<p id="p-0025" num="0026"><figref idref="DRAWINGS">FIG. 9</figref> is a flowchart illustrating an example of segmenting data in accordance with the invention;</p>
<p id="p-0026" num="0027"><figref idref="DRAWINGS">FIG. 10</figref> is a flowchart illustrating an example of re-creating data in accordance with the invention;</p>
<p id="p-0027" num="0028"><figref idref="DRAWINGS">FIG. 11</figref> is a flowchart illustrating an example of caching encoded data slices in accordance with the invention;</p>
<p id="p-0028" num="0029"><figref idref="DRAWINGS">FIG. 12</figref> is a flowchart illustrating an example of caching rebuilt encoded data slices in accordance with the invention; and</p>
<p id="p-0029" num="0030"><figref idref="DRAWINGS">FIG. 13</figref> is a flowchart illustrating another example of caching encoded data slices in accordance with the invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0006" level="1">DETAILED DESCRIPTION OF THE INVENTION</heading>
<p id="p-0030" num="0031"><figref idref="DRAWINGS">FIG. 1</figref> is a schematic block diagram of a computing system <b>10</b> that includes one or more of a first type of user devices <b>12</b>, one or more of a second type of user devices <b>14</b>, at least one distributed storage (DS) processing unit <b>16</b>, at least one DS managing unit <b>18</b>, at least one storage integrity processing unit <b>20</b>, and a distributed storage network (DSN) memory <b>22</b> coupled via a network <b>24</b>. The network <b>24</b> may include one or more wireless and/or wire lined communication systems; one or more private intranet systems and/or public internet systems; and/or one or more local area networks (LAN) and/or wide area networks (WAN).</p>
<p id="p-0031" num="0032">The DSN memory <b>22</b> includes a plurality of distributed storage (DS) units <b>36</b> for storing data of the system. Each of the DS units <b>36</b> includes a processing module and memory and may be located at a geographically different site than the other DS units (e.g., one in Chicago, one in Milwaukee, etc.). The processing module may be a single processing device or a plurality of processing devices. Such a processing device may be a microprocessor, micro-controller, digital signal processor, microcomputer, central processing unit, field programmable gate array, programmable logic device, state machine, logic circuitry, analog circuitry, digital circuitry, and/or any device that manipulates signals (analog and/or digital) based on hard coding of the circuitry and/or operational instructions. The processing module may have an associated memory and/or memory element, which may be a single memory device, a plurality of memory devices, and/or embedded circuitry of the processing module. Such a memory device may be a read-only memory, random access memory, volatile memory, non-volatile memory, static memory, dynamic memory, flash memory, cache memory, and/or any device that stores digital information. Note that if the processing module includes more than one processing device, the processing devices may be centrally located (e.g., directly coupled together via a wired and/or wireless bus structure) or may be distributedly located (e.g., cloud computing via indirect coupling via a local area network and/or a wide area network). Further note that when the processing module implements one or more of its functions via a state machine, analog circuitry, digital circuitry, and/or logic circuitry, the memory and/or memory element storing the corresponding operational instructions may be embedded within, or external to, the circuitry comprising the state machine, analog circuitry, digital circuitry, and/or logic circuitry. Still further note that, the memory element stores, and the processing module executes, hard coded and/or operational instructions corresponding to at least some of the steps and/or functions illustrated in <figref idref="DRAWINGS">FIGS. 1-13</figref>.</p>
<p id="p-0032" num="0033">Each of the user devices <b>12</b>-<b>14</b>, the DS processing unit <b>16</b>, the DS managing unit <b>18</b>, and the storage integrity processing unit <b>20</b> may be a portable computing device (e.g., a social networking device, a gaming device, a cell phone, a smart phone, a personal digital assistant, a digital music player, a digital video player, a laptop computer, a handheld computer, a video game controller, and/or any other portable device that includes a computing core) and/or a fixed computing device (e.g., a personal computer, a computer server, a cable set-top box, a satellite receiver, a television set, a printer, a fax machine, home entertainment equipment, a video game console, and/or any type of home or office computing equipment). Such a portable or fixed computing device includes a computing core <b>26</b> and one or more interfaces <b>30</b>, <b>32</b>, and/or <b>33</b>. An embodiment of the computing core <b>26</b> will be described with reference to <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0033" num="0034">With respect to the interfaces, each of the interfaces <b>30</b>, <b>32</b>, and <b>33</b> includes software and/or hardware to support one or more communication links via the network <b>24</b> and/or directly. For example, interfaces <b>30</b> support a communication link (wired, wireless, direct, via a LAN, via the network <b>24</b>, etc.) between the first type of user device <b>12</b> and the DS processing unit <b>16</b>. As another example, DSN interface <b>32</b> supports a plurality of communication links via the network <b>24</b> between the DSN memory <b>22</b> and the DS processing unit <b>16</b>, the first type of user device <b>12</b>, and/or the storage integrity processing unit <b>20</b>. As yet another example, interface <b>33</b> supports a communication link between the DS managing unit <b>18</b> and any one of the other devices and/or units <b>12</b>, <b>14</b>, <b>16</b>, <b>20</b>, and/or <b>22</b> via the network <b>24</b>.</p>
<p id="p-0034" num="0035">In general and with respect to data storage, the system <b>10</b> supports three primary functions: distributed network data storage management, distributed data storage and retrieval, and data storage integrity verification. In accordance with these three primary functions, data can be distributedly stored in a plurality of physically different locations and subsequently retrieved in a reliable and secure manner regardless of failures of individual storage devices, failures of network equipment, the duration of storage, the amount of data being stored, attempts at hacking the data, etc.</p>
<p id="p-0035" num="0036">The DS managing unit <b>18</b> performs distributed network data storage management functions, which include establishing distributed data storage parameters, performing network operations, performing network administration, and/or performing network maintenance. The DS managing unit <b>18</b> establishes the distributed data storage parameters (e.g., allocation of virtual DSN memory space, distributed storage parameters, security parameters, billing information, user profile information, etc.) for one or more of the user devices <b>12</b>-<b>14</b> (e.g., established for individual devices, established for a user group of devices, established for public access by the user devices, etc.). For example, the DS managing unit <b>18</b> coordinates the creation of a vault (e.g., a virtual memory block) within the DSN memory <b>22</b> for a user device (for a group of devices, or for public access). The DS managing unit <b>18</b> also determines the distributed data storage parameters for the vault. In particular, the DS managing unit <b>18</b> determines a number of slices (e.g., the number that a data segment of a data file and/or data block is partitioned into for distributed storage) and a read threshold value (e.g., the minimum number of slices required to reconstruct the data segment).</p>
<p id="p-0036" num="0037">As another example, the DS managing module <b>18</b> creates and stores, locally or within the DSN memory <b>22</b>, user profile information. The user profile information includes one or more of authentication information, permissions, and/or the security parameters. The security parameters may include one or more of encryption/decryption scheme, one or more encryption keys, key generation scheme, and data encoding/decoding scheme.</p>
<p id="p-0037" num="0038">As yet another example, the DS managing unit <b>18</b> creates billing information for a particular user, user group, vault access, public vault access, etc. For instance, the DS managing unit <b>18</b> tracks the number of times user accesses a private vault and/or public vaults, which can be used to generate a per-access bill. In another instance, the DS managing unit <b>18</b> tracks the amount of data stored and/or retrieved by a user device and/or a user group, which can be used to generate a per-data-amount bill.</p>
<p id="p-0038" num="0039">The DS managing unit <b>18</b> also performs network operations, network administration, and/or network maintenance. As at least part of performing the network operations and/or administration, the DS managing unit <b>18</b> monitors performance of the devices and/or units of the system <b>10</b> for potential failures, determines the devices and/or unit's activation status, determines the devices' and/or units' loading, and any other system level operation that affects the performance level of the system <b>10</b>. For example, the DS managing unit <b>18</b> receives and aggregates network management alarms, alerts, errors, status information, performance information, and messages from the devices <b>12</b>-<b>14</b> and/or the units <b>16</b>, <b>20</b>, <b>22</b>. For example, the DS managing unit <b>18</b> receives a simple network management protocol (SNMP) message regarding the status of the DS processing unit <b>16</b>.</p>
<p id="p-0039" num="0040">The DS managing unit <b>18</b> performs the network maintenance by identifying equipment within the system <b>10</b> that needs replacing, upgrading, repairing, and/or expanding. For example, the DS managing unit <b>18</b> determines that the DSN memory <b>22</b> needs more DS units <b>36</b> or that one or more of the DS units <b>36</b> needs updating.</p>
<p id="p-0040" num="0041">The second primary function (i.e., distributed data storage and retrieval) begins and ends with a user device <b>12</b>-<b>14</b>. For instance, if a second type of user device <b>14</b> has a data file <b>38</b> and/or data block <b>40</b> to store in the DSN memory <b>22</b>, it send the data file <b>38</b> and/or data block <b>40</b> to the DS processing unit <b>16</b> via its interface <b>30</b>. As will be described in greater detail with reference to <figref idref="DRAWINGS">FIG. 2</figref>, the interface <b>30</b> functions to mimic a conventional operating system (OS) file system interface (e.g., network file system (NFS), flash file system (FFS), disk file system (DFS), file transfer protocol (FTP), web-based distributed authoring and versioning (WebDAV), etc.) and/or a block memory interface (e.g., small computer system interface (SCSI), internet small computer system interface (iSCSI), etc.). In addition, the interface <b>30</b> may attach a user identification code (ID) to the data file <b>38</b> and/or data block <b>40</b>.</p>
<p id="p-0041" num="0042">The DS processing unit <b>16</b> receives the data file <b>38</b> and/or data block <b>40</b> via its interface <b>30</b> and performs a distributed storage (DS) process <b>34</b> thereon (e.g., an error coding dispersal storage function). The DS processing <b>34</b> begins by partitioning the data file <b>38</b> and/or data block <b>40</b> into one or more data segments, which is represented as Y data segments. For example, the DS processing <b>34</b> may partition the data file <b>38</b> and/or data block <b>40</b> into a fixed byte size segment (e.g., 2<sup>1 </sup>to 2<sup>n </sup>bytes, where n=&#x3e;2) or a variable byte size (e.g., change byte size from segment to segment, or from groups of segments to groups of segments, etc.).</p>
<p id="p-0042" num="0043">For each of the Y data segments, the DS processing <b>34</b> error encodes (e.g., forward error correction (FEC), information dispersal algorithm, or error correction coding) and slices (or slices then error encodes) the data segment into a plurality of error coded (EC) data slices <b>42</b>-<b>48</b>, which is represented as X slices per data segment. The number of slices (X) per segment, which corresponds to a number of pillars n, is set in accordance with the distributed data storage parameters and the error coding scheme. For example, if a Reed-Solomon (or other FEC scheme) is used in an n/k system, then a data segment is divided into n slices, where k number of slices is needed to reconstruct the original data (i.e., k is the threshold). As a few specific examples, the n/k factor may be 5/3; 6/4; 8/6; 8/5; 16/10.</p>
<p id="p-0043" num="0044">For each slice <b>42</b>-<b>48</b>, the DS processing unit <b>16</b> creates a unique slice name and appends it to the corresponding slice <b>42</b>-<b>48</b>. The slice name includes universal DSN memory addressing routing information (e.g., virtual memory addresses in the DSN memory <b>22</b>) and user-specific information (e.g., user ID, file name, data block identifier, etc.).</p>
<p id="p-0044" num="0045">The DS processing unit <b>16</b> transmits the plurality of EC slices <b>42</b>-<b>48</b> to a plurality of DS units <b>36</b> of the DSN memory <b>22</b> via the DSN interface <b>32</b> and the network <b>24</b>. The DSN interface <b>32</b> formats each of the slices for transmission via the network <b>24</b>. For example, the DSN interface <b>32</b> may utilize an internet protocol (e.g., TCP/IP, etc.) to packetize the slices <b>42</b>-<b>48</b> for transmission via the network <b>24</b>.</p>
<p id="p-0045" num="0046">The number of DS units <b>36</b> receiving the slices <b>42</b>-<b>48</b> is dependent on the distributed data storage parameters established by the DS managing unit <b>18</b>. For example, the DS managing unit <b>18</b> may indicate that each slice is to be stored in a different DS unit <b>36</b>. As another example, the DS managing unit <b>18</b> may indicate that like slice numbers of different data segments are to be stored in the same DS unit <b>36</b>. For example, the first slice of each of the data segments is to be stored in a first DS unit <b>36</b>, the second slice of each of the data segments is to be stored in a second DS unit <b>36</b>, etc. In this manner, the data is encoded and distributedly stored at physically diverse locations to improved data storage integrity and security. Further examples of encoding the data segments will be provided with reference to one or more of <figref idref="DRAWINGS">FIGS. 2-13</figref>.</p>
<p id="p-0046" num="0047">Each DS unit <b>36</b> that receives a slice <b>42</b>-<b>48</b> for storage translates the virtual DSN memory address of the slice into a local physical address for storage. Accordingly, each DS unit <b>36</b> maintains a virtual to physical memory mapping to assist in the storage and retrieval of data.</p>
<p id="p-0047" num="0048">The first type of user device <b>12</b> performs a similar function to store data in the DSN memory <b>22</b> with the exception that it includes the DS processing. As such, the device <b>12</b> encodes and slices the data file and/or data block it has to store. The device then transmits the slices <b>11</b> to the DSN memory via its DSN interface <b>32</b> and the network <b>24</b>.</p>
<p id="p-0048" num="0049">For a second type of user device <b>14</b> to retrieve a data file or data block from memory, it issues a read command via its interface <b>30</b> to the DS processing unit <b>16</b>. The DS processing unit <b>16</b> performs the DS processing <b>34</b> to identify the DS units <b>36</b> storing the slices of the data file and/or data block based on the read command. The DS processing unit <b>16</b> may also communicate with the DS managing unit <b>18</b> to verify that the user device <b>14</b> is authorized to access the requested data.</p>
<p id="p-0049" num="0050">Assuming that the user device is authorized to access the requested data, the DS processing unit <b>16</b> issues slice read commands to at least a threshold number of the DS units <b>36</b> storing the requested data (e.g., to at least 10 DS units for a 16/10 error coding scheme). Each of the DS units <b>36</b> receiving the slice read command, verifies the command, accesses its virtual to physical memory mapping, retrieves the requested slice, or slices, and transmits it to the DS processing unit <b>16</b>.</p>
<p id="p-0050" num="0051">Once the DS processing unit <b>16</b> has received a read threshold number of slices for a data segment, it performs an error decoding function and de-slicing to reconstruct the data segment. When Y number of data segments has been reconstructed, the DS processing unit <b>16</b> provides the data file <b>38</b> and/or data block <b>40</b> to the user device <b>14</b>. Note that the first type of user device <b>12</b> performs a similar process to retrieve a data file and/or data block.</p>
<p id="p-0051" num="0052">The storage integrity processing unit <b>20</b> performs the third primary function of data storage integrity verification. In general, the storage integrity processing unit <b>20</b> periodically retrieves slices <b>45</b>, and/or slice names, of a data file or data block of a user device to verify that one or more slices have not been corrupted or lost (e.g., the DS unit failed). The retrieval process mimics the read process previously described.</p>
<p id="p-0052" num="0053">If the storage integrity processing unit <b>20</b> determines that one or more slices is corrupted or lost, it rebuilds the corrupted or lost slice(s) in accordance with the error coding scheme. The storage integrity processing unit <b>20</b> stores the rebuild slice, or slices, in the appropriate DS unit(s) <b>36</b> in a manner that mimics the write process previously described.</p>
<p id="p-0053" num="0054"><figref idref="DRAWINGS">FIG. 2</figref> is a schematic block diagram of an embodiment of a computing core <b>26</b> that includes a processing module <b>50</b>, a memory controller <b>52</b>, main memory <b>54</b>, a video graphics processing unit <b>55</b>, an input/output (TO) controller <b>56</b>, a peripheral component interconnect (PCI) interface <b>58</b>, at least one IO device interface module <b>62</b>, a read only memory (ROM) basic input output system (BIOS) <b>64</b>, and one or more memory interface modules. The memory interface module(s) includes one or more of a universal serial bus (USB) interface module <b>66</b>, a host bus adapter (HBA) interface module <b>68</b>, a network interface module <b>70</b>, a flash interface module <b>72</b>, a hard drive interface module <b>74</b>, and a DSN interface module <b>76</b>. Note the DSN interface module <b>76</b> and/or the network interface module <b>70</b> may function as the interface <b>30</b> of the user device <b>14</b> of <figref idref="DRAWINGS">FIG. 1</figref>. Further note that the IO device interface module <b>62</b> and/or the memory interface modules may be collectively or individually referred to as IO ports.</p>
<p id="p-0054" num="0055">The processing module <b>50</b> may be a single processing device or a plurality of processing devices. Such a processing device may be a microprocessor, micro-controller, digital signal processor, microcomputer, central processing unit, field programmable gate array, programmable logic device, state machine, logic circuitry, analog circuitry, digital circuitry, and/or any device that manipulates signals (analog and/or digital) based on hard coding of the circuitry and/or operational instructions. The processing module <b>50</b> may have an associated memory and/or memory element, which may be a single memory device, a plurality of memory devices, and/or embedded circuitry of the processing module <b>50</b>. Such a memory device may be a read-only memory, random access memory, volatile memory, non-volatile memory, static memory, dynamic memory, flash memory, cache memory, and/or any device that stores digital information. Note that if the processing module <b>50</b> includes more than one processing device, the processing devices may be centrally located (e.g., directly coupled together via a wired and/or wireless bus structure) or may be distributedly located (e.g., cloud computing via indirect coupling via a local area network and/or a wide area network). Further note that when the processing module <b>50</b> implements one or more of its functions via a state machine, analog circuitry, digital circuitry, and/or logic circuitry, the memory and/or memory element storing the corresponding operational instructions may be embedded within, or external to, the circuitry comprising the state machine, analog circuitry, digital circuitry, and/or logic circuitry. Still further note that, the memory element stores, and the processing module <b>50</b> executes, hard coded and/or operational instructions corresponding to at least some of the steps and/or functions illustrated in <figref idref="DRAWINGS">FIGS. 1-13</figref>.</p>
<p id="p-0055" num="0056"><figref idref="DRAWINGS">FIG. 3</figref> is a schematic block diagram of an embodiment of a dispersed storage (DS) processing module <b>34</b> of user device <b>12</b> and/or of the DS processing unit <b>16</b>. The DS processing module <b>34</b> includes a gateway module <b>78</b>, an access module <b>80</b>, a grid module <b>82</b>, and a storage module <b>84</b>. The DS processing module <b>34</b> may also include an interface <b>30</b> and the DSnet interface <b>32</b> or the interfaces <b>68</b> and/or <b>70</b> may be part of user <b>12</b> or of the DS processing unit <b>14</b>. The DS processing module <b>34</b> may further include a bypass/feedback path between the storage module <b>84</b> to the gateway module <b>78</b>. Note that the modules <b>78</b>-<b>84</b> of the DS processing module <b>34</b> may be in a single unit or distributed across multiple units.</p>
<p id="p-0056" num="0057">In an example of storing data, the gateway module <b>78</b> receives an incoming data object that includes a user ID field <b>86</b>, an object name field <b>88</b>, and the data field <b>40</b> and may also receive corresponding information that includes a process identifier (e.g., an internal process/application ID), metadata, a file system directory, a block number, a transaction message, a user device identity (ID), a data object identifier, a source name, and/or user information. The gateway module <b>78</b> authenticates the user associated with the data object by verifying the user ID <b>86</b> with the managing unit <b>18</b> and/or another authenticating unit.</p>
<p id="p-0057" num="0058">When the user is authenticated, the gateway module <b>78</b> obtains user information from the management unit <b>18</b>, the user device, and/or the other authenticating unit. The user information includes a vault identifier, operational parameters, and user attributes (e.g., user data, billing information, etc.). A vault identifier identifies a vault, which is a virtual memory space that maps to a set of DS storage units <b>36</b>. For example, vault <b>1</b> (i.e., user <b>1</b>'s DSN memory space) includes eight DS storage units (X=8 wide) and vault <b>2</b> (i.e., user <b>2</b>'s DSN memory space) includes sixteen DS storage units (X=16 wide). The operational parameters may include an error coding algorithm, the width n (number of pillars X or slices per segment for this vault), a read threshold T, a write threshold, an encryption algorithm, a slicing parameter, a compression algorithm, an integrity check method, caching settings, parallelism settings, and/or other parameters that may be used to access the DSN memory layer.</p>
<p id="p-0058" num="0059">The gateway module <b>78</b> uses the user information to assign a source name <b>35</b> to the data. For instance, the gateway module <b>60</b> determines the source name <b>35</b> of the data object <b>40</b> based on the vault identifier and the data object. For example, the source name may contain a file identifier (ID), a vault generation number, a reserved field, and a vault identifier (ID). As another example, the gateway module <b>78</b> may generate the file ID based on a hash function of the data object <b>40</b>. Note that the gateway module <b>78</b> may also perform message conversion, protocol conversion, electrical conversion, optical conversion, access control, user identification, user information retrieval, traffic monitoring, statistics generation, configuration, management, and/or source name determination.</p>
<p id="p-0059" num="0060">The access module <b>80</b> receives the data object <b>40</b> and creates a series of data segments <b>1</b> through Y <b>90</b>-<b>92</b> in accordance with a data storage protocol (e.g., file storage system, a block storage system, and/or an aggregated block storage system). The number of segments Y may be chosen or randomly assigned based on a selected segment size and the size of the data object. For example, if the number of segments is chosen to be a fixed number, then the size of the segments varies as a function of the size of the data object. For instance, if the data object is an image file of 4,194,304 eight bit bytes (e.g., 33,554,432 bits) and the number of segments Y=131,072, then each segment is 256 bits or 32 bytes. As another example, if segment sized is fixed, then the number of segments Y varies based on the size of data object. For instance, if the data object is an image file of 4,194,304 bytes and the fixed size of each segment is 4,096 bytes, the then number of segments Y=1,024. Note that each segment is associated with the same source name.</p>
<p id="p-0060" num="0061">The grid module <b>82</b> receives the data segments and may manipulate (e.g., compression, encryption, cyclic redundancy check (CRC), etc.) each of the data segments before performing an error coding function of the error coding dispersal storage function to produce a pre-manipulated data segment. After manipulating a data segment, if applicable, the grid module <b>82</b> error encodes (e.g., Reed-Solomon, Convolution encoding, Trellis encoding, etc.) the data segment or manipulated data segment into X error coded data slices <b>42</b>-<b>44</b>.</p>
<p id="p-0061" num="0062">The value X, or the number of pillars (e.g., X=16), is chosen as a parameter of the error coding dispersal storage function. Other parameters of the error coding dispersal function include a read threshold T, a write threshold W, etc. The read threshold (e.g., T=10, when X=16) corresponds to the minimum number of error-free error coded data slices required to reconstruct the data segment. In other words, the DS processing module <b>34</b> can compensate for X-T (e.g., 16&#x2212;10=6) missing error coded data slices per data segment. The write threshold W corresponds to a minimum number of DS storage units that acknowledge proper storage of their respective data slices before the DS processing module indicates proper storage of the encoded data segment. Note that the write threshold is greater than or equal to the read threshold for a given number of pillars (X).</p>
<p id="p-0062" num="0063">For each data slice of a data segment, the grid module <b>82</b> generates a unique slice name <b>37</b> and attaches it thereto. The slice name <b>37</b> includes a universal routing information field and a vault specific field and may be 48 bytes (e.g., 24 bytes for each of the universal routing information field and the vault specific field). As illustrated, the universal routing information field includes a slice index, a vault ID, a vault generation, and a reserved field. The slice index is based on the pillar number and the vault ID and, as such, is unique for each pillar (e.g., slices of the same pillar for the same vault for any segment will share the same slice index). The vault specific field includes a data name, which includes a file ID and a segment number (e.g., a sequential numbering of data segments <b>1</b>-Y of a simple data object or a data block number).</p>
<p id="p-0063" num="0064">Prior to outputting the error coded data slices of a data segment, the grid module may perform post-slice manipulation on the slices. If enabled, the manipulation includes slice level compression, encryption, CRC, addressing, tagging, and/or other manipulation to improve the effectiveness of the computing system.</p>
<p id="p-0064" num="0065">When the error coded data slices of a data segment are ready to be outputted, the grid module <b>82</b> determines which of the DS storage units <b>36</b> will store the EC data slices based on a dispersed storage memory mapping associated with the user's vault and/or DS storage unit attributes. The DS storage unit attributes may include availability, self-selection, performance history, link speed, link latency, ownership, available DSN memory, domain, cost, a prioritization scheme, a centralized selection message from another source, a lookup table, data ownership, and/or any other factor to optimize the operation of the computing system. Note that the number of DS storage units <b>36</b> is equal to or greater than the number of pillars (e.g., X) so that no more than one error coded data slice of the same data segment is stored on the same DS storage unit <b>36</b>. Further note that EC data slices of the same pillar number but of different segments (e.g., EC data slice <b>1</b> of data segment <b>1</b> and EC data slice <b>1</b> of data segment <b>2</b>) may be stored on the same or different DS storage units <b>36</b>.</p>
<p id="p-0065" num="0066">The storage module <b>84</b> performs an integrity check on the outbound encoded data slices and, when successful, identifies a plurality of DS storage units based on information provided by the grid module <b>82</b>. The storage module <b>84</b> then outputs the encoded data slices <b>1</b> through X of each segment <b>1</b> through Y to the DS storage units <b>36</b>. Each of the DS storage units <b>36</b> stores its EC data slice(s) and maintains a local virtual DSN address to physical location table to convert the virtual DSN address of the EC data slice(s) into physical storage addresses.</p>
<p id="p-0066" num="0067">In an example of a read operation, the user device <b>12</b> and/or <b>14</b> sends a read request to the DS processing unit <b>14</b>, which authenticates the request. When the request is authentic, the DS processing unit <b>14</b> sends a read message to each of the DS storage units <b>36</b> storing slices of the data object being read. The slices are received via the DSnet interface <b>32</b> and processed by the storage module <b>84</b>, which performs a parity check and provides the slices to the grid module <b>82</b> when the parity check was successful. The grid module <b>82</b> decodes the slices in accordance with the error coding dispersal storage function to reconstruct the data segment. The access module <b>80</b> reconstructs the data object from the data segments and the gateway module <b>78</b> formats the data object for transmission to the user device.</p>
<p id="p-0067" num="0068"><figref idref="DRAWINGS">FIG. 4</figref> is a schematic block diagram of an embodiment of a grid module <b>82</b> that includes a control unit <b>73</b>, a pre-slice manipulator <b>75</b>, an encoder <b>77</b>, a slicer <b>79</b>, a post-slice manipulator <b>81</b>, a pre-slice de-manipulator <b>83</b>, a decoder <b>85</b>, a de-slicer <b>87</b>, and/or a post-slice de-manipulator <b>89</b>. Note that the control unit <b>73</b> may be partially or completely external to the grid module <b>82</b>. For example, the control unit <b>73</b> may be part of the computing core at a remote location, part of a user device, part of the DS managing unit <b>18</b>, or distributed amongst one or more DS storage units.</p>
<p id="p-0068" num="0069">In an example of write operation, the pre-slice manipulator <b>75</b> receives a data segment <b>90</b>-<b>92</b> and a write instruction from an authorized user device. The pre-slice manipulator <b>75</b> determines if pre-manipulation of the data segment <b>90</b>-<b>92</b> is required and, if so, what type. The pre-slice manipulator <b>75</b> may make the determination independently or based on instructions from the control unit <b>73</b>, where the determination is based on a computing system-wide predetermination, a table lookup, vault parameters associated with the user identification, the type of data, security requirements, available DSN memory, performance requirements, and/or other metadata.</p>
<p id="p-0069" num="0070">Once a positive determination is made, the pre-slice manipulator <b>75</b> manipulates the data segment <b>90</b>-<b>92</b> in accordance with the type of manipulation. For example, the type of manipulation may be compression (e.g., Lempel-Ziv-Welch, Huffman, Golomb, fractal, wavelet, etc.), signatures (e.g., Digital Signature Algorithm (DSA), Elliptic Curve DSA, Secure Hash Algorithm, etc.), watermarking, tagging, encryption (e.g., Data Encryption Standard, Advanced Encryption Standard, etc.), adding metadata (e.g., time/date stamping, user information, file type, etc.), cyclic redundancy check (e.g., CRC32), and/or other data manipulations to produce the pre-manipulated data segment.</p>
<p id="p-0070" num="0071">The encoder <b>77</b> encodes the pre-manipulated data segment <b>92</b> using a forward error correction (FEC) encoder (and/or other type of erasure coding and/or error coding) to produce an encoded data segment <b>94</b>. The encoder <b>77</b> determines which forward error correction algorithm to use based on a predetermination associated with the user's vault, a time based algorithm, user direction, DS managing unit direction, control unit direction, as a function of the data type, as a function of the data segment <b>92</b> metadata, and/or any other factor to determine algorithm type. The forward error correction algorithm may be Golay, Multidimensional parity, Reed-Solomon, Hamming, Bose Ray Chauduri Hocquenghem (BCH), Cauchy-Reed-Solomon, or any other FEC encoder. Note that the encoder <b>77</b> may use a different encoding algorithm for each data segment <b>92</b>, the same encoding algorithm for the data segments <b>92</b> of a data object, or a combination thereof.</p>
<p id="p-0071" num="0072">The encoded data segment <b>94</b> is of greater size than the data segment <b>92</b> by the overhead rate of the encoding algorithm by a factor of X/T, where X is the width or number of slices, and T is the read threshold. In this regard, the corresponding decoding process can accommodate at most X-T missing EC data slices and still recreate the data segment <b>92</b>. For example, if X=16 and T=10, then the data segment <b>92</b> will be recoverable as long as 10 or more EC data slices per segment are not corrupted.</p>
<p id="p-0072" num="0073">The slicer <b>79</b> transforms the encoded data segment <b>94</b> into EC data slices in accordance with the slicing parameter from the vault for this user and/or data segment <b>92</b>. For example, if the slicing parameter is X=16, then the slicer <b>79</b> slices each encoded data segment <b>94</b> into 16 encoded slices.</p>
<p id="p-0073" num="0074">The post-slice manipulator <b>81</b> performs, if enabled, post-manipulation on the encoded slices to produce the EC data slices. If enabled, the post-slice manipulator <b>81</b> determines the type of post-manipulation, which may be based on a computing system-wide predetermination, parameters in the vault for this user, a table lookup, the user identification, the type of data, security requirements, available DSN memory, performance requirements, control unit directed, and/or other metadata. Note that the type of post-slice manipulation may include slice level compression, signatures, encryption, CRC, addressing, watermarking, tagging, adding metadata, and/or other manipulation to improve the effectiveness of the computing system.</p>
<p id="p-0074" num="0075">In an example of a read operation, the post-slice de-manipulator <b>89</b> receives at least a read threshold number of EC data slices and performs the inverse function of the post-slice manipulator <b>81</b> to produce a plurality of encoded slices. The de-slicer <b>87</b> de-slices the encoded slices to produce an encoded data segment <b>94</b>. The decoder <b>85</b> performs the inverse function of the encoder <b>77</b> to recapture the data segment <b>90</b>-<b>92</b>. The pre-slice de-manipulator <b>83</b> performs the inverse function of the pre-slice manipulator <b>75</b> to recapture the data segment <b>90</b>-<b>92</b>.</p>
<p id="p-0075" num="0076"><figref idref="DRAWINGS">FIG. 5</figref> is a diagram of an example of slicing an encoded data segment <b>94</b> by the slicer <b>79</b>. In this example, the encoded data segment <b>94</b> includes thirty-two bits, but may include more or less bits. The slicer <b>79</b> disperses the bits of the encoded data segment <b>94</b> across the EC data slices in a pattern as shown. As such, each EC data slice does not include consecutive bits of the data segment <b>94</b> reducing the impact of consecutive bit failures on data recovery. For example, if EC data slice <b>2</b> (which includes bits <b>1</b>, <b>5</b>, <b>9</b>, <b>13</b>, <b>17</b>, <b>25</b>, and <b>29</b>) is unavailable (e.g., lost, inaccessible, or corrupted), the data segment can be reconstructed from the other EC data slices (e.g., 1, 3 and 4 for a read threshold of 3 and a width of 4).</p>
<p id="p-0076" num="0077"><figref idref="DRAWINGS">FIG. 6</figref> is a flowchart illustrating an example of storing data as encoded data slices. The method begins with step <b>102</b> were a processing module receives a store data object message from one or more of a user device, a storage integrity processing unit, a dispersed storage (DS) processing unit, a DS managing unit, and a DS unit. The store data object message includes one or more of a data object name, a data object size, a data type, a data object, an input metadata, a priority indicator, a security indicator, a performance indicator, a user device identifier (ID), and input requirements.</p>
<p id="p-0077" num="0078">The method continues at step <b>104</b> where the processing module determines metadata regarding data of the data object. Such metadata summarizes attributes of the data object including identification of priority data, identification of non-priority data, a data type, a data size indicator, and storage requirements. Such a determination may be based on one or more of a vault lookup, a command, a message, a predetermination, a data object analysis, the data object name, the data object size, a data type, the data object, the input metadata, the priority indicator, the security indicator, the performance indicator, the input requirements, and retrieval of a metadata file that is linked to a data object indicating previous metadata.</p>
<p id="p-0078" num="0079">The method continues at step <b>106</b> where the processing module determines requirements associated with storing the data object including one or more of expected access frequency, priority, security, performance, access latency, and reliability. Such a determination may be based on one or more of the metadata, a metadata analysis, a vault lookup, a command, a message, a predetermination, a data object analysis, the data object name, the data object size, a data type, the data object, the input metadata, the priority indicator, the security indicator, the performance indicator, and the input requirements. For example, the processing module determines that the access latency requirement is slower than average and the reliability requirement is higher than average when the performance indicator indicates that more reliability is favored over faster access latency.</p>
<p id="p-0079" num="0080">The method continues at step <b>108</b> where the processing module determines DS unit performance history with regards to DS units of a dispersed storage network (DSN) memory. Such DS unit performance history includes one or more of history of reliability, availability, access latency, bandwidth utilization, security performance, and cost. Such a determination may be based on one or more of a vault lookup, a command, a message, a predetermination, and DS unit query. The processing module determines the DS unit performance history for a plurality of DS units where the plurality of DS units are candidates to be included in a DS unit storage set.</p>
<p id="p-0080" num="0081">The method continues at step <b>110</b> where the processing module determines DS unit estimated performance. Such DS unit estimated performance includes one or more of a performance based indication regarding storage of a data segment as a set of encoded data slices, an estimation of reliability, estimated availability, estimated access latency, estimated bandwidth utilization, estimated security performance, estimated cost, and estimated availability. Such a determination may be based on one or more of a vault lookup, a command, a message, a predetermination, a DS unit query, the DS unit performance history, and an estimation algorithm. For example, the processing module determines that DS unit estimated access latency performance is lower than average when the DS unit access latency performance history was lower than average. As another example, the processing module determines the DS unit estimated reliability to be lower than average when the DS unit reliability history was lower than average. As yet another example, the processing module determines a performance based indication regarding storage of a data segment as a set of encoded data slices as the DS unit estimated performance.</p>
<p id="p-0081" num="0082">The method continues at step <b>112</b> where processing module determines error coding dispersal storage function parameters (e.g., operational parameters). Such parameters may include one or more of a pillar width n, a read threshold, a decode threshold k, a write threshold, an encode/decode algorithm, and an encryption method. Such a determination may be based on one or more of a vault lookup, a command, a message, a predetermination, a DS unit query, the DS unit performance history, the DS unit estimated performance, the requirements, the metadata, and information received in the store data object message. For example, the processing module determines to utilize a relatively large number of DS units in the storage set (e.g., a higher pillar width n) and a lower decode threshold k when the processing module determines that the DS units are less reliable than average and the requirements include higher than average reliability. As another example, the processing module determines to utilize a relatively small number of DS units in the DS unit storage set and a higher decode threshold k when the processing module determines that the DS units are more reliable than average and the requirements include greater efficiency of storage.</p>
<p id="p-0082" num="0083">The method continues at step <b>114</b> where the processing module determines the DS unit storage set based on one or more of an encoded data slice, an associated slice name, a vault lookup, identification of a slice name range to be rebuilt, a second DS unit identifier associated with the DS unit affiliated with the associated slice name, a virtual dispersed storage network (DSN) address to physical location table lookup, a command, a message, a predetermination, a DS unit query, the error coding dispersal storage function parameters, the DS unit performance history, the DS unit estimated performance, the requirements, the metadata, and the information received in the store data object message. Note that the processing module may re-determine the error coding dispersal storage function parameters when DS units that meet the requirements are not available. Alternatively, the processing module may determine the DS unit storage set prior to determining the error coding dispersal storage function parameters.</p>
<p id="p-0083" num="0084">The method continues at step <b>116</b> where the processing module dispersed storage error encodes the data to produce a plurality of sets of encoded data slices in accordance with the error coding dispersal storage function parameters. Next, the processing module appends one or more of the metadata, the requirements, the DS unit performance history, the DS unit estimated performance, a source name, a slice name, and the error coding dispersal storage function parameters to one or more of data segments created from the data object prior to encoding and slicing the data segment to enable subsequent re-creation of the data object. Alternatively, the processing module creates a metadata file that includes one or more of the metadata, the requirements, the DS unit performance history, the DS unit estimated performance, the source name, the slice name, and the error coding dispersal storage function parameters. Next, the processing module stores the metadata file the DSN memory as encoded metadata slices to enable subsequent retrieval and re-creation of the data object. The method at step <b>118</b> continues where the processing module sends the plurality of sets encoded data slices to DS units of the DS unit storage set for storage therein.</p>
<p id="p-0084" num="0085"><figref idref="DRAWINGS">FIG. 7</figref> is a flowchart illustrating an example of re-storing data as encoded data slices, which includes some similar steps to <figref idref="DRAWINGS">FIG. 6</figref>. The method begins with step <b>120</b> where a processing module determines a dispersed storage (DS) unit storage set based on one or more of a data object name, a user identifier (ID), where a sequence left off last time, a directory entry, a storage location table lookup, a command, a message, a predetermination, and a query. As a specific example, the processing module determines a DS unit storage set <b>457</b> based on the storage location table lookup corresponding to a data object foo.txt, wherein foo.txt is a next entry of a directory entry.</p>
<p id="p-0085" num="0086">The method continues with steps <b>104</b>-<b>110</b> of <figref idref="DRAWINGS">FIG. 6</figref> and then continues with step <b>122</b> where the processing module determines whether to change the DS unit storage set and/or to change error coding dispersal storage function parameters (e.g., operational parameters) based on a comparison of the DS unit estimated performance to the requirements. For example, the processing module compares a performance based indication (e.g., the DS unit estimated performance based on the DS unit performance history) with a performance threshold of the requirements. Note that the DS unit estimated performance may have changed since encoded data slices were originally stored to the DS unit storage set. Further note that the requirements may have changed since the slices were originally stored to the DS unit storage set. The processing module determines to change the DS unit storage set and/or the error coding dispersal storage function parameters when the processing module determines that the comparison of the DS unit estimated performance to the requirements is unfavorable.</p>
<p id="p-0086" num="0087">For example, the processing module determines to change the DS unit storage set when a DS unit estimated reliability level is below a required reliability level. As another example, the processing module determines to change the error coding dispersal storage function parameters when a DS unit estimated access latency time is above a required access latency. As yet another example, the processing module determines to change the DS unit storage set and the error coding dispersal storage function parameters when the DS unit estimated reliability level is below the required reliability level and the DS unit estimated access latency time is above the required access latency.</p>
<p id="p-0087" num="0088">The method repeats back to step <b>120</b> when the processing module determines not to change the DS unit storage set and/or the error coding dispersal storage function parameters (e.g., the performance based indication compares favorably with the performance threshold). The method continues to step <b>112</b> of <figref idref="DRAWINGS">FIG. 6</figref> when the processing module determines to change the DS unit storage set and/or the error coding dispersal storage function parameters (e.g., the performance based indication compares unfavorably with the performance threshold).</p>
<p id="p-0088" num="0089">The method continues at step <b>124</b> where the processing module retrieves a set of encoded data slices from the DS unit storage set by sending a read encoded data slice message to at least a read threshold number of DS units of the DS unit storage set and receiving at least a decode threshold number of encoded data slices of the set of encoded data slices. The method continues at step <b>126</b> where the processing module dispersed storage error decodes the at least the decode threshold number of encoded data slices of the set of encoded data slices in accordance with the error coding dispersal storage function parameters to reproduce a data segment as a reproduced data segment.</p>
<p id="p-0089" num="0090">The method continues at step <b>128</b> where the processing module adjusts the error coding dispersal storage function parameters based on the unfavorable comparison of the performance based indication with the performance threshold to produce performance adjusted error coding dispersal storage function parameters. Such adjusting includes one or more of determining desired error coding dispersal storage function parameters based on the performance threshold and the performance based indication, determining a difference between desired error coding dispersal storage function parameters and the error coding dispersal storage function parameters to produce a parameters difference, and adjusting the error coding dispersal storage function parameters based on the parameters difference, wherein determining at least one of the desired error coding dispersal storage function parameters and the parameters difference is based on at least one of a set of DS units, the error coding dispersal storage function parameters, a vault lookup, a command, a message, a predetermination, a DS unit query, a historical DS unit performance level, an estimated DS unit performance level, storage requirements, security requirements, and metadata.</p>
<p id="p-0090" num="0091">For example, the processing module adjusts the error coding dispersal storage function parameters by increasing a difference between a decode threshold and a pillar width and adjusting an encoding matrix in accordance with the increasing of the difference when the performance based indication compares unfavorably with the performance threshold as a result of under-performance. As another example, the processing module adjusts the error coding dispersal storage function parameters by decreasing a difference between a decode threshold and a pillar width and adjusting an encoding matrix in accordance with the increasing of the difference when the performance based indication compares unfavorably with the performance threshold as a result of over-performance. As yet another example, the processing module adjusts the error coding dispersal storage function parameters to include a different encryption algorithm when the security requirements have changed. Next, the processing module saves the performance adjusted error coding dispersal storage function parameters by storing the performance adjusted error coding dispersal storage function parameters in a local memory and/or as encoded parameters slices in a dispersed storage network (DSN) memory.</p>
<p id="p-0091" num="0092">The method continues at step <b>130</b> where the processing module determines a new DS unit storage set based on one or more of a vault lookup, a command, a message, a predetermination, a DS unit query, the error coding dispersal storage function parameters, the performance adjusted error coding dispersal storage function parameters, the DS unit storage set, the DS unit performance history, the DS unit estimated performance, the requirements, the metadata, and information received in the store data object message. Next, processing module saves the new DS unit storage set selection by storing the new DS unit storage set selection in a local memory and/or as encoded DS unit selection slices in the DSN memory.</p>
<p id="p-0092" num="0093">The method continues at step <b>132</b> where the processing module encodes the reproduced data segment in accordance with the performance adjusted error coding dispersal storage function parameters to produce a second set of encoded data slices. Next, the processing module selects a storage set of encoded data slices from the set of encoded data slices and the second set of encoded data slices based on a difference between the performance adjusted error coding dispersal storage function parameters and the error coding dispersal storage function parameters. Such selecting of the storage set of encoded data slices includes at least one of selecting the set of encoded data slices and selecting at least one encoded data slice of the second set of encoded data slices. Next, processing module updates a storage location table to associate a corresponding slice name of a set of slice names with a corresponding encoded data slice of the storage set of encoded data slices to facilitate subsequent retrieval.</p>
<p id="p-0093" num="0094">Alternatively, retrieval may be accomplished by a lookup of original locations of original encoded data slices and extend address ranges of the original locations to provide locations of newer encoded data slices associated with the original encoded data slices. Note that the first decode threshold number k of encoded data slices of the second set of encoded data slices specify the reproduced data segment in its original format when an encoding matrix includes a unity sub-matrix. Further note that remaining n-k encoded data slices of the second set of encoded data slices specify parity information that may be utilized in subsequent retrieval process to correct for errors when the first k encoded data slices are not successfully retrieved. Further note that the first set of encoded data slices are included in the second set of encoded data slices when the second set of encoded data slices are produced by encoding the reproduced data segment with an encoding matrix that is identical to the encoding matrix utilized to produce the first set of encoded data slices with the exception that one or more rows are added which result in generation of further parity slices. For example, the processing module produces one new slice (e.g., slice number <b>17</b>) in the second set of encoded data slices when the error coding dispersal storage function parameters include a pillar width of 16, and a decode threshold of 10, and the performance adjusted error coding dispersal storage function parameters include a pillar width of 17 and a decode threshold of 10. The method continues at step <b>134</b> where the processing module outputs each of the encoded data slices of the storage set of encoded data slices that is selected from the second set of encoded data slices to the new DS unit storage set of the DSN memory for storage therein.</p>
<p id="p-0094" num="0095"><figref idref="DRAWINGS">FIG. 8A</figref> is a diagram illustrating data segmentation of data that includes a data object <b>136</b>, a segment set <b>138</b>, a segment set R <b>140</b>, and a segment set P <b>142</b>. The data object <b>136</b> includes data wherein the data comprises non-priority data <b>1</b>-<b>4</b> and priority data <b>1</b>-<b>3</b>. Note that priority data may be more important with regards to subsequent utilization of the data object as compared to the non-priority data. In an example, priority data includes header information, codec information, and base frames associated with a compressed video file and non-priority data includes difference video frames of the compressed video file.</p>
<p id="p-0095" num="0096">The data object <b>136</b> may be stored in a dispersed storage network (DSN) memory as a plurality of sets of encoded data slices, wherein each set of encoded data slices corresponds to encoding a plurality of data segments of the data object <b>136</b>. The segment set <b>138</b> represents data segments <b>1</b>-<b>8</b>, wherein each of the data segments are substantially the same size created as a result of segmentation of the data object <b>136</b> without regard to non-priority data or priority data. Alternatively, or in addition to, the data object <b>136</b> may be stored in the DSN memory as a plurality of sets of priority encoded data slices corresponding to encoding a plurality of priority data segments of the data object <b>136</b>. The segment set R <b>140</b> represents priority data segments <b>2</b>-<b>4</b> and <b>6</b>-<b>8</b>, wherein each of the data segments are substantially the same size as corresponding data segments <b>2</b>-<b>4</b>, and <b>6</b>-<b>8</b> that contain priority data of the plurality of data segments created as a result of segmentation of the data object <b>136</b> to capture priority data <b>1</b>-<b>3</b>. Alternatively, or in addition to, the segment set P <b>142</b> represents priority data <b>1</b>-<b>3</b>, wherein each of the data segments are substantially the same size as corresponding priority data <b>1</b>-<b>3</b>. A method of storing data segments and priority data segments is discussed in greater detail with reference to <figref idref="DRAWINGS">FIG. 9</figref>. A method of retrieving data segments and priority data segments is discussed in greater detail with reference to <figref idref="DRAWINGS">FIG. 10</figref>.</p>
<p id="p-0096" num="0097">Note that the storing of the plurality of sets of priority encoded data slices provides a priority data retrieval reliability improvement when the priority data segments are stored in addition to data segments corresponding to priority data. Further note that the storing of the plurality of sets of priority encoded data slices provides a priority data retrieval reliability improvement when the priority data is stored as priority data segments rather than as data segments and when error coding dispersal storage function parameters associated with the encoding of the priority data segments provides more reliable storage as compared to error coding dispersal storage function parameters associated with the encoding of data segments. Such differences in error coding dispersal storage function parameters are discussed in greater detail with reference to <figref idref="DRAWINGS">FIG. 8B</figref>.</p>
<p id="p-0097" num="0098"><figref idref="DRAWINGS">FIG. 8B</figref> is a diagram illustrating an example of encoding data segments that includes a data object <b>136</b>, a segment set <b>138</b>, and a segment set P <b>142</b> of <figref idref="DRAWINGS">FIG. 8A</figref> and a plurality of sets of encoded data slices <b>139</b> and a plurality of sets of priority encoded data slices <b>143</b>. Each data segment of the segment set <b>138</b> is dispersed storage error encoded in accordance with first error coding dispersal storage function parameters to produce the plurality of sets of encoded data slices <b>139</b>. For example, data segment <b>3</b> is dispersed storage error encoded to produce a set of encoded data slices <b>3</b>_<b>1</b>-<b>3</b>_<b>4</b>, when a pillar width is 4 of the first error coding dispersal storage function parameters. Each priority data segment of the segment set P <b>142</b> is dispersed storage error encoded in accordance with second error coding dispersal storage function parameters to produce the plurality of sets of priority encoded data slices <b>143</b>. For example, data segment P<b>2</b> is dispersed storage error encoded to produce a set of encoded data slices P<b>2</b>_<b>1</b>-P<b>2</b>_<b>8</b>, when a pillar width is 8 of the second error coding dispersal storage function parameters.</p>
<p id="p-0098" num="0099">Note that the first error coding dispersal storage function parameters may be determined such that dispersed storage error encoding data segments containing only non-priority data <b>1</b>-<b>4</b> of the segment set <b>138</b> to produce encoded data slices of the plurality of sets of encoded data slices <b>139</b> in accordance with the first error coding dispersal storage function parameters will result in a desired level of non-priority data retrieval reliability. For example, first error coding dispersal storage function parameters that include a pillar width of 4 and a decode threshold of 3 are selected to provide a desired level of non-priority data retrieval reliability. Note that improved retrieval reliability is provided when a difference between a pillar width and a decode threshold of the second error coding dispersal storage function parameters is greater than a difference between a pillar width and a decode threshold of the first error coding dispersal storage function parameters. The second error coding dispersal storage function parameters may be determined such that dispersed storage error encoding priority data segments containing priority data <b>1</b>-<b>3</b> of the segment set P <b>142</b> to produce priority encoded data slices of the plurality of sets of priority encoded data slices <b>143</b> in accordance with the second error coding dispersal storage function parameters will result in a desired level of priority data retrieval reliability. For example, second error coding dispersal storage function parameters that include a pillar width of 8 and a decode threshold of 5 are selected to provide a higher level of priority data retrieval reliability as compared to utilizing first error coding dispersal storage function parameters when the pillar width is 4 and the decode threshold is 3.</p>
<p id="p-0099" num="0100"><figref idref="DRAWINGS">FIG. 9</figref> is a flowchart illustrating an example segmenting data, which includes some similar steps to <figref idref="DRAWINGS">FIG. 6</figref>. The method begins with steps <b>102</b>-<b>114</b> of <figref idref="DRAWINGS">FIG. 6</figref> and then continues with step <b>148</b> where a processing module encodes data into a plurality of sets of encoded data slices in accordance with first error coding dispersal storage function parameters. Note that the processing module may encode all data (e.g., non-priority data and priority data) or the processing module encodes the non-priority data alone. For example, the processing module identifies non-priority data segments of the data and encodes the non-priority data segments into the plurality of sets of encoded data slices in accordance with the first error coding dispersal storage function parameters, wherein the first error coding dispersal storage function parameters include a first pillar width and a first decode threshold optimized for data recovery (e.g., retrieving and decoding) speed and non-optimal for data recovery reliability. The method continues at step <b>150</b> where the processing module outputs the plurality of sets of encoded data slices to the first dispersed storage (DS) unit storage set of a dispersed storage network (DSN) memory for storage therein. Next, the processing module updates a storage location table to associate the plurality of sets of encoded data slices with the data.</p>
<p id="p-0100" num="0101">The method continues at step <b>152</b> where the processing module determines whether to create priority data segments (e.g., and store them in the DSN memory as encoded data slices) based on one or more of requirements, metadata, a data object, a determination of the priority/non-priority data, which data segments from the original segment set include priority data, a command, a predetermination, a lookup, DS unit performance history, and DS unit estimated performance. For example, the processing module determines to create more data segments when the metadata identifies priority data and when the performance history of the first DS unit storage set is unfavorable as compared to the requirements (e.g., the DS unit reliability history or DS unit estimated reliability is below a threshold). The method ends at step <b>154</b> when the processing module determines not to create priority data segments. The method continues to step <b>136</b> when the processing module determines to create priority data segments.</p>
<p id="p-0101" num="0102">The continues at step <b>156</b> where the processing module determines an approach to create priority data segments based on one or more of the requirements, the data object, a determination of the priority/non-priority data, a size of the priority data, a location of the priority data, which data segments from the original segment set include priority data, a command, a predetermination, a lookup, DS unit performance history, and DS unit estimated performance. For example, the processing module determines to create a segment set R when the size of the priority data is substantially contained within a data segment of the original data segment set described above (e.g., without overlapping two or more data segments). Note that the processing module may utilize the data segments of the original segment set to produce (e.g., copy from a temporary memory) the data segments of the segment set R. As another example, the processing module determines to create a segment set P when the size of the priority data is substantially not contained within a data segment of the original data segment set (e.g., substantially overlapping two or more data segments).</p>
<p id="p-0102" num="0103">The method continues at step <b>158</b> where the processing module determines priority data segments of the data. Such a determination includes at least one of identifying content of the data having a desired priority level, wherein data segments containing the content are identified as the priority data segments, determining a desired relationship between a data recovery speed and a data recovery reliability, and determining the priority data segments based on the desired relationship, receiving an indicator that identifies the priority data segments, and accessing a table regarding the data to identify the priority data segments. For example, the processing module copies the data segments from the original segment set that correspond to priority data of the data object when the approach is to form a segment set R of priority data segments. As another example, the processing module forms each priority data segment from the priority data sections of the data object when the approach is to form a segment set P of priority data segments that replicate the priority data. As yet another example, the processing module encodes video data into the plurality of sets of encoded data slices in accordance with the first error coding dispersal storage function parameters, wherein the plurality of set of encoded data slices is retrieved in response to a video on demand request and the processing module determines key frames of the video data as the priority data segments.</p>
<p id="p-0103" num="0104">The method continues at step <b>160</b> where the processing module saves priority data segment information to facilitate subsequent retrieval where the priority data segment information may include one or more of a location of the priority data in the data object, a size of the priority data segments, a size of the priority data, and a number of priority data sections. For example, the processing module saves the priority data segment information as data appended to one or more of the priority data segments. As another example, the processing module saves the priority data segment information as a separate data object in the DSN memory as a plurality of sets of encoded priority data segment information slices.</p>
<p id="p-0104" num="0105">The method continues at step <b>162</b> where the processing module determines second error coding dispersal storage function parameters (e.g., second operational parameters) and a second DS unit storage set based on one or more of the determined approach to create priority data segments, the priority data segments, the requirements, the metadata, the DS unit performance history, the DS unit estimated performance, the first DS unit storage set, the first error coding dispersal storage function parameters, the data object, a command, a predetermination, and a vault lookup. For example, the processing module determines the second error coding dispersal storage function parameters and the second DS unit storage set to be substantially identical to the first error coding dispersal storage function parameters and the first DS unit storage set when a nominal level of improved retrieval reliability is required. As another example, the processing module determines the second error coding dispersal storage function parameters and the second DS unit storage set to be substantially different from the first error coding dispersal storage function parameters and the first DS unit storage set. As a specific example, the processing module determines the second error coding dispersal storage function parameters to include a second pillar width and a second decode threshold optimized for data recovery reliability and non-optimal for data recovery speed when an improved level of retrieval reliability is required.</p>
<p id="p-0105" num="0106">The method continues at step <b>164</b> where the processing module encodes the priority data segments in accordance with the second error coding dispersal storage function parameters to produce a plurality of sets of priority encoded data slices. The method continues at step <b>166</b> where the processing module outputs the plurality of sets of priority encoded data slices to the second DS unit storage set of the DSN memory for storage therein. Next, the processing module updates the storage location table to associate the plurality of sets of priority encoded data slices with the priority data segments. The method repeats back to step <b>152</b> to potentially create more priority and/or redundant data segments.</p>
<p id="p-0106" num="0107"><figref idref="DRAWINGS">FIG. 10</figref> is a flowchart illustrating an example of re-creating data, which includes similar steps to <figref idref="DRAWINGS">FIG. 6</figref> and <figref idref="DRAWINGS">FIG. 9</figref>. The method begins with step <b>168</b> where a processing module receives a retrieve data object message (e.g., from any one of a user device, a storage integrity processing unit, a dispersed storage (DS) processing unit, a DS managing unit, and a DS unit). The retrieve data object message includes one or more of a data object name, a data object size, a data type, an input metadata, a priority data indicator, a priority indicator, a security indicator, a performance indicator, and input requirements. The method continues at steps <b>112</b>-<b>114</b> of <figref idref="DRAWINGS">FIG. 6</figref> and then continues with step <b>170</b> where the processing module retrieves a set of encoded data slices from a first DS unit storage set of a dispersed storage network (DSN) memory, wherein a data segment was encoded in accordance with first error coding dispersal storage function parameters to produce the set of encoded data slices.</p>
<p id="p-0107" num="0108">The method continues at step <b>172</b> where the processing module determines whether the set of encoded data slices are associated with a data segment or a priority data segment to facilitate re-creating data segments. Such a determination may be based on one or more of accessing a storage location table to identify the set of encoded data slices with the data, accessing the storage location table to identify the second set of encoded data slices, the first error coding dispersal storage function parameters, an origin of retrieval of the set of encoded data slices, a command, a message, and a query. The processing module decodes the set of encoded data slices in accordance with the first error coding dispersal storage function parameters to produce the data segment when the data segment is not the priority data segment.</p>
<p id="p-0108" num="0109">The processing module determines whether to decode the set of encoded data slices in accordance with the first error coding dispersal storage function parameters or to decode a second set of encoded data slices in accordance with second error coding dispersal storage function parameters when the data segment is the priority data segment, wherein the data segment was encoded in accordance with the second error coding dispersal storage function parameters to produce the second set of encoded data slices, wherein the first error coding dispersal storage function parameters include a first pillar width and a first decode threshold optimized for data recovery speed and non-optimal for data recovery reliability and the second error coding dispersal storage function parameters include a second pillar width and a second decode threshold optimized for data recovery reliability and non-optimal for data recovery speed.</p>
<p id="p-0109" num="0110">Such determining whether to decode the set of encoded data slices or the second set of encoded data slices includes at least one of determining a desired relationship between the data recovery speed and the data recovery reliability, decoding the set of encoded data slices when the desired relationship compares favorably to a relationship threshold, and decoding the second set of encoded data slices when the desired relationship compares unfavorably to the relationship threshold, receiving an indicator that indicates whether to decode the set of encoded data slices or the second set of encoded data slices, and accessing a table based on identity of the data segment to determine whether to decode the set of encoded data slices or the second set of encoded data slices. For example, the processing module retrieves the set of encoded data slices in response to a video on demand request and determines whether the data segment corresponds to a key frame of video data. Next, the processing module identifies the data segment as a priority data segment and determines to decode the second set of encoded data slices when the data segment corresponds to the key frame (e.g., priority data).</p>
<p id="p-0110" num="0111">The method continues at step <b>174</b> where the processing module determines if enough data segments have been re-created. Such a determination may be based on one or more of a comparison of the number of re-created data segments to a number of data segments of the data object, a vault lookup, a command, a message, a predetermination, a priority data indicator, metadata, and information received in the retrieve data object message. For example, the processing module determines that enough data segments have been received when all of the data segments have been received and metadata in the retrieve data object message indicated that all of the data segments are required for this retrieval transaction. As another example, the processing module determines that enough data segments have not been received when all of the data segments have not been received and metadata in the retrieve data object message indicates that all of the data segments are required for this retrieval transaction.</p>
<p id="p-0111" num="0112">As yet another example, the processing module determines that enough data segments have been received when all of the data segments have not been received, data segments containing priority data have been received that contain all of the priority data, and metadata in the retrieve data object message indicates that only the priority data is required for this retrieval transaction. As a further example, the processing module determines that not enough data segments have been received when all of the data segments have not been received, not enough data segments containing priority data have been received such that at least some of the priority data has not been retrieved, and metadata in the retrieve data object message indicates that only the priority data is required for this retrieval transaction.</p>
<p id="p-0112" num="0113">The method branches to step <b>180</b> when the processing module determines that enough data segments have not been received. The method continues to step <b>176</b> when the processing module determines that enough data segments have been received. The method continues at step <b>176</b> where the processing module re-creates priority data and/or non-priority data by aggregating the successfully re-created data segments and priority data segments. The method continues at step <b>178</b> where the processing module sends the data to the requester.</p>
<p id="p-0113" num="0114">The method continues at step <b>180</b> where the processing module determines whether all of the priority data segments have been recovered (e.g., retrieving a segment set R and/or retrieving a segment set P and decoding the segments) based on one or more of previously recovered data segments, a vault lookup, a message, a command, and a list of segment sets tried. The method branches to step <b>184</b> when the processing module determines that all priority data segments have not been recovered. The method continues to step <b>182</b> when the processing module determines that all priority data segments have been recovered. The method continues at step <b>182</b> where the processing module sends a fail message to the requester and/or the DS managing unit.</p>
<p id="p-0114" num="0115">The method continues at step <b>184</b> where the processing module determines additional priority data segments to try next based on one or more of previously recovered priority data segments, a vault lookup, a message, a command, and a list of segment sets recovered. For example, the processing module determines to recover an additional priority data segment set after trying to recover the original data segment set. As another example, the processing module determines to try segment set P after trying to retrieve the original data segment set and a priority segment set. The method continues at step <b>162</b> of <figref idref="DRAWINGS">FIG. 9</figref>.</p>
<p id="p-0115" num="0116">The method continues at step <b>190</b> where the processing module sends a retrieve slice command to at least a DS unit of the second DS unit storage set to retrieve a second set of encoded data slices from a second DS unit storage set of the DSN memory. The processing module receives priority encoded data slices from at least one DS unit of the second DS unit storage set in response to the retrieve slice command. The processing module retrieves at least a read threshold number of encoded priority data slices from the second DS unit storage set corresponding to each of the desired priority data segments. The method continues at step <b>192</b> where the processing module dispersed storage error decodes the second set of encoded data slices in accordance with the second error coding dispersal function parameters to produce the priority data segment as a recovered data segment. The method repeats back to step <b>172</b> to fully re-create data segments and determine if enough data segments have been re-created to facilitate aggregating data segments to reproduce the data.</p>
<p id="p-0116" num="0117"><figref idref="DRAWINGS">FIG. 11</figref> is a flowchart illustrating an example of caching encoded data slices, which includes many steps similar to <figref idref="DRAWINGS">FIG. 6</figref>. The method begins with steps <b>102</b>, <b>108</b>, <b>112</b>, <b>114</b>, <b>116</b>, <b>118</b> of <figref idref="DRAWINGS">FIG. 6</figref> and then continues with step <b>194</b> where a processing module determines which encoded data slices to cache based on one or more of a comparison of dispersed storage (DS) unit access latency history to a threshold, DS unit performance history, a DS unit storage set, error coding dispersal storage function parameters, metadata, requirements, a vault lookup, a command, and information received in the store data object message. For example, the processing module determines the slices to cache when the slices correspond to the DS units with an access latency time performance that is above a threshold. Alternatively, processing module skips step <b>108</b> to enable always caching the encoded data slices not subject to DS unit performance history.</p>
<p id="p-0117" num="0118">The method continues at step <b>196</b> where the processing module caches the slices that are to be cached as cached encoded data slices. For example, the processing module determines to temporarily store the encoded data slices in one or more memories of one or more of a DS processing unit, a user device, a DS managing unit, a storage integrity processing unit, and a DS unit. The processing module determines cache location based on one or more of a candidate cache memory list, memory availability indicator, a size indicator of the encoded data slices to cache, a performance indicator of cache memory, requirements, the DS unit storage set, the error coding dispersal storage function parameters, a vault lookup, a command, a predetermination, and information received in the store data object message. As a specific example, the processing module caches the encoded data slices in a memory associated with a DS processing unit such that the encoded data slices are readily available for retrieval with a relatively low access latency. Alternatively, or in addition to, the processing module facilitates storage of the encoded data slice in temporary memory to produce a temporarily stored encoded data slice when estimated DS unit performance level compares unfavorably with a performance threshold, wherein the temporarily stored encoded data slice is retrieved in response to a retrieval request of the encoded data slice when confirmation of a DS unit storing the encoded data slice has not been received.</p>
<p id="p-0118" num="0119">The method continues at step <b>198</b> where the processing module updates a storage location table (e.g., a virtual dispersed storage network (DSN) address to physical location table) to associate a slice name with a temporary memory identifier (ID) of the temporary memory. For example, the processing module updates the virtual DSN address to physical location table to include pillars <b>1</b>-<b>9</b> as stored in DS units <b>1</b>-<b>9</b>, pillar <b>10</b> as stored in a DS processing unit cache memory, and pillars <b>11</b>-<b>16</b> is stored in DS units <b>11</b>-<b>16</b> when the pillar width is 16 and the read threshold is 10.</p>
<p id="p-0119" num="0120">The method continues at step <b>200</b> where the processing module determines whether the slices are available for retrieval from the DS units based on receiving a response from the DS units, wherein the response indicates that the encoded data slices are available for retrieval. The method advances to step <b>202</b> when the processing module determines that the slices are available for retrieval from the DS units. The method continues at step <b>202</b> where the processing module updates a storage location table (e.g., the virtual DSN address to physical location table) to associate slice names of the encoded data slices with DS unit IDs of the DS unit storage set and to delete an association of the slice names with the temporary memory ID of the temporary memory. The method continues at step <b>204</b> where the processing module facilitates deleting of the cached encoded data slices from the temporary memory.</p>
<p id="p-0120" num="0121">In an example of operation of a corresponding retrieval sequence, the processing module receives a retrieve data object message from a requester and determines DS unit locations based on a lookup of the virtual DSN address to physical location table. Note that the table may indicate a combination of DS units and or cache memory locations for at least some of encoded data slices to be retrieved. The processing module determines error coding dispersal storage function parameters based on a vault lookup. The processing module retrieves the encoded data slices from the determined locations dispersed storage error decodes the encoded data slices to produce data segments in accordance with the error coding dispersal storage function parameters. The processing module aggregates the data segments to produce the data object. The processing module sends the data object to the requester.</p>
<p id="p-0121" num="0122"><figref idref="DRAWINGS">FIG. 12</figref> is a flowchart illustrating an example of caching rebuilt encoded data slices which includes many similar steps to <figref idref="DRAWINGS">FIGS. 6</figref>, <b>7</b>, and <b>11</b>. The method begins with step <b>206</b> where a processing module determines to rebuild data where the data may be at least a portion of a data object stored as encoded data slices in a dispersed storage network (DSN) memory. Such a determination may be based on one or more of detection of a missing slice, detection of a corrupted slice, detection of a tampered slices, detection of a failed memory device, detection of a failed DS unit, detection of a failed site, a message, a command, and a DS unit query. For example, the processing module receives a message from a DS unit indicating that one of four hard drive memories has failed and has been replaced with a new hard drive memory. The method continues with steps <b>114</b>, <b>108</b>, and <b>112</b> of <figref idref="DRAWINGS">FIG. 6</figref>. The method continues with steps <b>124</b>-<b>126</b> of <figref idref="DRAWINGS">FIG. 7</figref> to reproduce a data object corresponding to at least an encoded data slice to be rebuilt. Note that the processing module may obtain an encoded data slice and an associated slice name for storage in a DS unit and/or a temporary memory wherein the obtaining the encoded data slice comprises at least one of receiving the encoded data slice, creating the encoded data slice, rebuilding the encoded data slice from a set of associated encoded data slices, and receiving the encoded data slice as a rebuilt encoded data slice that was rebuilt from the set of associated encoded data slices.</p>
<p id="p-0122" num="0123">The method continues at step <b>208</b> where the processing module dispersed storage error encodes a data segment associated with the portion of the data object to be rebuilt to produce an encoded data slice as a rebuilt slice in accordance with error coding dispersal storage function parameters. The method continues at step <b>210</b> where the processing module sends the encoded data slice to an associated DS unit of a DS unit storage for storage therein. Alternatively, the processing module sends the encoded data slice through the associated DS unit subsequent to step <b>196</b> where the processing module caches the rebuilt slice.</p>
<p id="p-0123" num="0124">The method continues at step <b>212</b> where the processing module determines a temporary memory based on at least one of a slice name, a size of the encoded data slice, a comparison of DS unit access latency history to a threshold, a DS unit performance history, the DS unit storage set, the error coding dispersal storage function parameters, metadata, requirements, a vault lookup, a command, and information obtained associated with the encoded data slice, wherein the temporary memory includes one or more of another DS unit, local memory, cache memory, and main memory. The method continues at step <b>196</b> of <figref idref="DRAWINGS">FIG. 11</figref> to cache the rebuilt slice in the temporary memory. The method continues at step <b>198</b> of <figref idref="DRAWINGS">FIG. 11</figref>.</p>
<p id="p-0124" num="0125">The method continues at step <b>214</b> where the processing module determines whether the slice is available for retrieval from the DS unit based on receiving a response from the DS unit, wherein the response indicates that the encoded data slice is available for retrieval. The method advances to step <b>216</b> when the processing module determines that the slice is available for retrieval from the DS unit. The method continues at step <b>216</b> where the processing module updates a storage location table (e.g., the virtual DSN address to physical location table) to associate the slice name of the encoded data slice with a DS unit ID of the DS unit and to delete an association of the slice name with the temporary memory ID of the temporary memory. The method continues at step <b>217</b> where the processing module facilitates deleting of the cached encoded data slice from the temporary memory.</p>
<p id="p-0125" num="0126"><figref idref="DRAWINGS">FIG. 13</figref> is another flowchart illustrating another example of caching encoded data slices, which includes many similar steps to <figref idref="DRAWINGS">FIGS. 6</figref>, <b>11</b>, and <b>12</b>. The method begins with steps <b>102</b>, <b>108</b>, <b>114</b>, <b>112</b>, <b>116</b>, and <b>118</b> of <figref idref="DRAWINGS">FIG. 6</figref> to produce encoded data slices and to send encoded data slices to a DS unit storage set for storage therein. The method continues with step <b>212</b> of <figref idref="DRAWINGS">FIG. 12</figref> and then steps <b>196</b>-<b>198</b> of <figref idref="DRAWINGS">FIG. 11</figref> to cache the encoded data slices as temporarily stored encoded data slices. The method continues at step <b>218</b> where the processing module determines whether the encoded data slices slice are available for retrieval from the DS unit storage set based on receiving response from the DS units, wherein the responses indicates that a corresponding encoded data slice is available for retrieval and that a DS unit storage set performance is above a threshold based on performance indicator. The method advances to steps <b>202</b>-<b>204</b> of <figref idref="DRAWINGS">FIG. 11</figref> when the processing module determines that the encoded data slices are available for retrieval from the DS unit storage set and that the DS unit storage set performance is above the threshold.</p>
<p id="p-0126" num="0127">In a retrieval example of operation, the processing module receives a retrieval request and determines whether to retrieve a temporarily stored encoded data slice from the temporary memory or an encoded data slice from the DS unit in response to the retrieval request. Such a determination may be based on one or more of a DS unit performance indicator, system performance indicator, he DS unit reliability indicator, and an access latency estimate. Next, the processing module sends a read request to a DS unit of the DS unit storage set regarding retrieval of the encoded data slice when selecting the encoded data slice from the DS unit in response to the retrieval request.</p>
<p id="p-0127" num="0128">As may be used herein, the terms &#x201c;substantially&#x201d; and &#x201c;approximately&#x201d; provides an industry-accepted tolerance for its corresponding term and/or relativity between items. Such an industry-accepted tolerance ranges from less than one percent to fifty percent and corresponds to, but is not limited to, component values, integrated circuit process variations, temperature variations, rise and fall times, and/or thermal noise. Such relativity between items ranges from a difference of a few percent to magnitude differences. As may also be used herein, the term(s) &#x201c;operably coupled to&#x201d;, &#x201c;coupled to&#x201d;, and/or &#x201c;coupling&#x201d; includes direct coupling between items and/or indirect coupling between items via an intervening item (e.g., an item includes, but is not limited to, a component, an element, a circuit, and/or a module) where, for indirect coupling, the intervening item does not modify the information of a signal but may adjust its current level, voltage level, and/or power level. As may further be used herein, inferred coupling (i.e., where one element is coupled to another element by inference) includes direct and indirect coupling between two items in the same manner as &#x201c;coupled to&#x201d;. As may even further be used herein, the term &#x201c;operable to&#x201d; or &#x201c;operably coupled to&#x201d; indicates that an item includes one or more of power connections, input(s), output(s), etc., to perform, when activated, one or more its corresponding functions and may further include inferred coupling to one or more other items. As may still further be used herein, the term &#x201c;associated with&#x201d;, includes direct and/or indirect coupling of separate items and/or one item being embedded within another item. As may be used herein, the term &#x201c;compares favorably&#x201d;, indicates that a comparison between two or more items, signals, etc., provides a desired relationship. For example, when the desired relationship is that signal <b>1</b> has a greater magnitude than signal <b>2</b>, a favorable comparison may be achieved when the magnitude of signal <b>1</b> is greater than that of signal <b>2</b> or when the magnitude of signal <b>2</b> is less than that of signal <b>1</b>.</p>
<p id="p-0128" num="0129">While the transistors in the above described figure(s) is/are shown as field effect transistors (FETs), as one of ordinary skill in the art will appreciate, the transistors may be implemented using any type of transistor structure including, but not limited to, bipolar, metal oxide semiconductor field effect transistors (MOSFET), N-well transistors, P-well transistors, enhancement mode, depletion mode, and zero voltage threshold (VT) transistors.</p>
<p id="p-0129" num="0130">The present invention has also been described above with the aid of method steps illustrating the performance of specified functions and relationships thereof. The boundaries and sequence of these functional building blocks and method steps have been arbitrarily defined herein for convenience of description. Alternate boundaries and sequences can be defined so long as the specified functions and relationships are appropriately performed. Any such alternate boundaries or sequences are thus within the scope and spirit of the claimed invention.</p>
<p id="p-0130" num="0131">The present invention has been described, at least in part, in terms of one or more embodiments. An embodiment of the present invention is used herein to illustrate the present invention, an aspect thereof, a feature thereof, a concept thereof, and/or an example thereof. A physical embodiment of an apparatus, an article of manufacture, a machine, and/or of a process that embodies the present invention may include one or more of the aspects, features, concepts, examples, etc. described with reference to one or more of the embodiments discussed herein.</p>
<p id="p-0131" num="0132">The present invention has been described above with the aid of functional building blocks illustrating the performance of certain significant functions. The boundaries of these functional building blocks have been arbitrarily defined for convenience of description. Alternate boundaries could be defined as long as the certain significant functions are appropriately performed. Similarly, flow diagram blocks may also have been arbitrarily defined herein to illustrate certain significant functionality. To the extent used, the flow diagram block boundaries and sequence could have been defined otherwise and still perform the certain significant functionality. Such alternate definitions of both functional building blocks and flow diagram blocks and sequences are thus within the scope and spirit of the claimed invention. One of average skill in the art will also recognize that the functional building blocks, and other illustrative blocks, modules and components herein, can be implemented as illustrated or by discrete components, application specific integrated circuits, processors executing appropriate software and the like or any combination thereof.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for execution by a processing module of a computing device of a distributed storage network (DSN) device, the method comprises:
<claim-text>determining that storage of data requires updating, wherein the data is encoded in accordance with a dispersed storage error encoding function using dispersed storage error encoding parameters to produce a plurality of sets of encoded data slices, which is stored in memory of the DSN, wherein the dispersed storage error encoding parameters includes a total number of encoded data slices per set of encoded data slices and a decode threshold number of encoded data slices that are required from a set of encoded data slices to recover a data segment of the data;</claim-text>
<claim-text>for a first type of updating of the storage of the data:
<claim-text>increasing the total number while maintaining the decode threshold number;</claim-text>
<claim-text>for each of the sets of encoded data slices of the plurality of sets of encode data slices:
<claim-text>creating at least one more encoded data slice in accordance with the dispersed storage error encoding function and the increased total number; and</claim-text>
<claim-text>sending the at least one more encoded data slice to the memory of the DSN for storage therein; and</claim-text>
</claim-text>
</claim-text>
<claim-text>for a second type of updating of the storage of the data:
<claim-text>increasing the total number and increasing the decode threshold number;</claim-text>
<claim-text>recovering the data from retrieved encoded data slices of the plurality of sets of encoded data slices;</claim-text>
<claim-text>encoding the recovered data in accordance with the dispersed storage error encoding function using the increased total number and the increased decode threshold number to produce an updated plurality of sets of encoded data slices; and</claim-text>
<claim-text>sending the updated plurality of sets of encoded data slices to the memory of the DSN for storage therein.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the determining that storage of data requires updating comprises one of:
<claim-text>determining under performance of the DSN with respect to accessing the plurality of sets of encoded data slices; and</claim-text>
<claim-text>determining over performance of the DSN with respect to accessing the plurality of sets of encoded data slices.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprises:
<claim-text>for a third type of updating of the storage of the data:
<claim-text>decreasing the total number while maintaining the decode threshold number;</claim-text>
<claim-text>for each of the sets of encoded data slices of the plurality of sets of encode data slices:
<claim-text>selecting at least one encoded data slice based on the decreased total number and the total number; and</claim-text>
<claim-text>deleting the selected at least one encoded data slice from the memory of the DSN.</claim-text>
</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprises:
<claim-text>for a third type of updating of the storage of the data:
<claim-text>decreasing the decode threshold number and maintaining the total number;</claim-text>
<claim-text>recovering the data from retrieved encoded data slices of the plurality of sets of encoded data slices;</claim-text>
<claim-text>encoding the recovered data in accordance with the dispersed storage error encoding function using the total number and the decreased decode threshold number to produce another updated plurality of sets of encoded data slices; and</claim-text>
<claim-text>sending the other updated plurality of sets of encoded data slices to the memory of the DSN for storage therein.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprises:
<claim-text>for a third type of updating of the storage of the data:
<claim-text>decreasing the decode threshold number and decreasing the total number;</claim-text>
<claim-text>recovering the data from retrieved encoded data slices of the plurality of sets of encoded data slices;</claim-text>
<claim-text>encoding the recovered data in accordance with the dispersed storage error encoding function using the decreased total number and the decreased decode threshold number to produce another updated plurality of sets of encoded data slices; and</claim-text>
<claim-text>sending the other updated plurality of sets of encoded data slices to the memory of the DSN for storage therein.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprises:
<claim-text>determining the type of updating based on a comparison of a performance based indication with a performance threshold.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprises:
<claim-text>for each of the at least one more encoded data slice created for the first type of updating of the storage of the data:
<claim-text>creating a slice name to links the at least one more encoded data slice to a correspond set of encoded data slices of the plurality of sets of encoded data slices; and</claim-text>
<claim-text>updating a storage location table to include the slices names.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the sending the at least one more encoded data slice to the memory of the DSN comprises:
<claim-text>identifying storage units of the DSN that are storing the plurality of sets of encoded data slices;</claim-text>
<claim-text>selecting at least one more storage unit of the DSN; and</claim-text>
<claim-text>sending the at least one more encoded data slice of each of the plurality of sets of encoded data slices to the selected at least one more storage unit.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the sending the updated plurality of sets of encoded data slices to the memory of the DSN comprises:
<claim-text>selecting storage units of the DSN; and</claim-text>
<claim-text>sending the updated plurality of sets of encoded data slices to the selected storage units.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. A computer comprises:
<claim-text>an interface;</claim-text>
<claim-text>a memory; and</claim-text>
<claim-text>a processing module coupled to the interface and the memory, wherein the processing module is operable to:
<claim-text>determine that storage of data requires updating, wherein the data is encoded in accordance with a dispersed storage error encoding function using dispersed storage error encoding parameters to produce a plurality of sets of encoded data slices, which is stored in memory of the DSN, wherein the dispersed storage error encoding parameters includes a total number of encoded data slices per set of encoded data slices and a decode threshold number of encoded data slices that are required from a set of encoded data slices to recover a data segment of the data;</claim-text>
<claim-text>for a first type of updating of the storage of the data:
<claim-text>increase the total number while maintaining the decode threshold number;</claim-text>
<claim-text>for each of the sets of encoded data slices of the plurality of sets of encode data slices:
<claim-text>create at least one more encoded data slice in accordance with the dispersed storage error encoding function and the increased total number; and</claim-text>
<claim-text>send, via the interface, the at least one more encoded data slice to the memory of the DSN for storage therein; and</claim-text>
</claim-text>
</claim-text>
<claim-text>for a second type of updating of the storage of the data:
<claim-text>increase the total number and increasing the decode threshold number;</claim-text>
<claim-text>recover the data from retrieved encoded data slices of the plurality of sets of encoded data slices;</claim-text>
<claim-text>encode the recovered data in accordance with the dispersed storage error encoding function using the increased total number and the increased decode threshold number to produce an updated plurality of sets of encoded data slices; and</claim-text>
<claim-text>send, via the interface, the updated plurality of sets of encoded data slices to the memory of the DSN for storage therein.</claim-text>
</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The computer of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the processing module is further operable to determine that storage of data requires updating by one of:
<claim-text>determining under performance of the DSN with respect to accessing the plurality of sets of encoded data slices; and</claim-text>
<claim-text>determining over performance of the DSN with respect to accessing the plurality of sets of encoded data slices.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The computer of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the processing module is further operable to:
<claim-text>for a third type of updating of the storage of the data:
<claim-text>decrease the total number while maintaining the decode threshold number;</claim-text>
<claim-text>for each of the sets of encoded data slices of the plurality of sets of encode data slices:
<claim-text>select at least one encoded data slice based on the decreased total number and the total number; and</claim-text>
<claim-text>delete the selected at least one encoded data slice from the memory of the DSN.</claim-text>
</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The computer of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the processing module is further operable to:
<claim-text>for a third type of updating of the storage of the data:
<claim-text>decrease the decode threshold number and maintaining the total number;</claim-text>
<claim-text>recover the data from retrieved encoded data slices of the plurality of sets of encoded data slices;</claim-text>
<claim-text>encode the recovered data in accordance with the dispersed storage error encoding function using the total number and the decreased decode threshold number to produce another updated plurality of sets of encoded data slices; and</claim-text>
<claim-text>send, via the interface, the other updated plurality of sets of encoded data slices to the memory of the DSN for storage therein.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The computer of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the processing module is further operable to:
<claim-text>for a third type of updating of the storage of the data:
<claim-text>decrease the decode threshold number and decreasing the total number;</claim-text>
<claim-text>recover the data from retrieved encoded data slices of the plurality of sets of encoded data slices;</claim-text>
<claim-text>encode the recovered data in accordance with the dispersed storage error encoding function using the decreased total number and the decreased decode threshold number to produce another updated plurality of sets of encoded data slices; and</claim-text>
<claim-text>send, via the interface, the other updated plurality of sets of encoded data slices to the memory of the DSN for storage therein.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The computer of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the processing module is further operable to:
<claim-text>determine the type of updating based on a comparison of a performance based indication with a performance threshold.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The computer of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the processing module is further operable to:
<claim-text>for each of the at least one more encoded data slice created for the first type of updating of the storage of the data:
<claim-text>create a slice name to links the at least one more encoded data slice to a correspond set of encoded data slices of the plurality of sets of encoded data slices; and</claim-text>
<claim-text>update a storage location table to include the slices names.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The computer of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the processing module is further operable to send the at least one more encoded data slice to the memory of the DSN by:
<claim-text>identifying storage units of the DSN that are storing the plurality of sets of encoded data slices;</claim-text>
<claim-text>selecting at least one more storage unit of the DSN; and</claim-text>
<claim-text>sending, via the interface, the at least one more encoded data slice of each of the plurality of sets of encoded data slices to the selected at least one more storage unit.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The computer of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the processing module is further operable to send the updated plurality of sets of encoded data slices to the memory of the DSN by:
<claim-text>selecting storage units of the DSN; and</claim-text>
<claim-text>sending, via the interface, the updated plurality of sets of encoded data slices to the selected storage units. </claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
