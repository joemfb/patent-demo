<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08626778-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08626778</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13076253</doc-number>
<date>20110330</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>707756</main-classification>
<further-classification>707736</further-classification>
<further-classification>707758</further-classification>
<further-classification>706 12</further-classification>
<further-classification>706 14</further-classification>
<further-classification>715200</further-classification>
</classification-national>
<invention-title id="d2e43">System and method for conversion of JMS message data into database transactions for application to multiple heterogeneous databases</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6687848</doc-number>
<kind>B1</kind>
<name>Najmi</name>
<date>20040200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714  44</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6753889</doc-number>
<kind>B1</kind>
<name>Najmi</name>
<date>20040600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>715784</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6877023</doc-number>
<kind>B1</kind>
<name>Maffeis et al.</name>
<date>20050400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709202</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>7031987</doc-number>
<kind>B2</kind>
<name>Mukkamalla et al.</name>
<date>20060400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>7039773</doc-number>
<kind>B2</kind>
<name>Hu et al.</name>
<date>20060500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>7299230</doc-number>
<kind>B2</kind>
<name>Liou et al.</name>
<date>20071100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>  1  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>7571173</doc-number>
<kind>B2</kind>
<name>Yang et al.</name>
<date>20090800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>8224834</doc-number>
<kind>B2</kind>
<name>Akaboshi</name>
<date>20120700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707759</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2002/0169842</doc-number>
<kind>A1</kind>
<name>Christensen et al.</name>
<date>20021100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709206</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2002/0174340</doc-number>
<kind>A1</kind>
<name>Dick et al.</name>
<date>20021100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713178</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2004/0148585</doc-number>
<kind>A1</kind>
<name>Sengodan</name>
<date>20040700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717101</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2004/0254919</doc-number>
<kind>A1</kind>
<name>Giuseppini</name>
<date>20041200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2005/0253739</doc-number>
<kind>A1</kind>
<name>Hu</name>
<date>20051100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2006/0212356</doc-number>
<kind>A1</kind>
<name>Lambert et al.</name>
<date>20060900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>2007/0299885</doc-number>
<kind>A1</kind>
<name>Pareek et al.</name>
<date>20071200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707202</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>2008/0077601</doc-number>
<kind>A1</kind>
<name>Liou et al.</name>
<date>20080300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707100</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>2009/0106327</doc-number>
<kind>A1</kind>
<name>Dilman et al.</name>
<date>20090400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00018">
<document-id>
<country>US</country>
<doc-number>2009/0313311</doc-number>
<kind>A1</kind>
<name>Hoffmann et al.</name>
<date>20091200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00019">
<document-id>
<country>US</country>
<doc-number>2010/0191884</doc-number>
<kind>A1</kind>
<name>Holenstein et al.</name>
<date>20100700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00020">
<document-id>
<country>US</country>
<doc-number>2011/0029681</doc-number>
<kind>A1</kind>
<name>Lee et al.</name>
<date>20110200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709230</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00021">
<document-id>
<country>US</country>
<doc-number>2011/0179011</doc-number>
<kind>A1</kind>
<name>Cardno et al.</name>
<date>20110700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00022">
<document-id>
<country>US</country>
<doc-number>2011/0307524</doc-number>
<kind>A1</kind>
<name>Aitken et al.</name>
<date>20111200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00023">
<document-id>
<country>US</country>
<doc-number>2012/0030165</doc-number>
<kind>A1</kind>
<name>Guirguis et al.</name>
<date>20120200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00024">
<document-id>
<country>US</country>
<doc-number>2012/0030172</doc-number>
<kind>A1</kind>
<name>Pareek et al.</name>
<date>20120200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00025">
<document-id>
<country>US</country>
<doc-number>2012/0295716</doc-number>
<kind>A1</kind>
<name>Lee et al.</name>
<date>20121100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>463 42</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00026">
<document-id>
<country>WO</country>
<doc-number>2007134250</doc-number>
<kind>A2</kind>
<date>20071100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00027">
<othercit>&#x201c;Oracle GoldenGate-An overview&#x201d;, Alex Blyth, Jul. 2010.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00028">
<othercit>&#x201c;Oracle GoldenGate: Architecture for Real-Time Replication&#x201d;, Jan. 2010.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00029">
<othercit>&#x201c;Oracle GoldenGate&#x201d;, Oracle Data Sheet, Sep. 2009.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00030">
<othercit>&#x201c;Oracle Technology Overview&#x201d;, Jun. 2010.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00031">
<othercit>Louis, Oracle GoldenGate: Architecture for Real-Time Replication, Jan. 2010, 69 pages, Oracle International Corporation.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00032">
<othercit>Unknown Author, Oracle GoldenGate, Oracle Data Sheet, Sep. 2009, 4 pages, Oracle International Corporation.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00033">
<othercit>Blyth, Oracle GoldenGate&#x2014;An Overview, Jul. 2010, 58 pages, Oracle International Corporation.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00034">
<othercit>Unknown Author, Oracle Technology Overview, Jun. 2010, 30 pages, Oracle International Corporation.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00035">
<othercit>Guirguis, et al., &#x201c;BronzeGate: Real-time Transactional Data Obfuscation for GoldenGate,&#x201d; 2010, Proceeding EDBT '10 Proceedings of the 13th International Conference on Extending Database Technology, pp. 645-650.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00036">
<othercit>Soorma, GoldenGate Tutorial 1&#x2014;Concepts and Architecture, Feb. 18, 2010, 4 pages. Relevant pages: whole document.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00037">
<othercit>Oracle International Corporation, Oracle GoldenGate Administrative Guide, Version 10.4, Oct. 2009, 343 pages. Relevant pp. 13, 14, 16 and 333-337, Fig. 2.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00038">
<othercit>Unknown Author, MySQL 5.0 Reference Manual Achieved version from Apr. 1, 2010, Jan. 4, 2010, 3 pages. Relevant pages: whole document.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00039">
<othercit>International Searching Authority, International Search Report and Written Opinion for PCT International Patent Application No. PCT/US2011/036508, Feb. 18, 2013, 10 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>17</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>3</number-of-drawing-sheets>
<number-of-figures>3</number-of-figures>
</figures>
<us-related-documents>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61367323</doc-number>
<date>20100723</date>
</document-id>
</us-provisional-application>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20120023116</doc-number>
<kind>A1</kind>
<date>20120126</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Wilkes</last-name>
<first-name>Stephen</first-name>
<address>
<city>Santa Clara</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Nielsen</last-name>
<first-name>Michael Scott</first-name>
<address>
<city>San Francisco</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Pora</last-name>
<first-name>Codin</first-name>
<address>
<city>San Francisco</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Wilkes</last-name>
<first-name>Stephen</first-name>
<address>
<city>Santa Clara</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Nielsen</last-name>
<first-name>Michael Scott</first-name>
<address>
<city>San Francisco</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Pora</last-name>
<first-name>Codin</first-name>
<address>
<city>San Francisco</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Fliesler Meyer LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Oracle International Corporation</orgname>
<role>02</role>
<address>
<city>Redwood Shores</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Le</last-name>
<first-name>Hung</first-name>
<department>2161</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A system and method for performing real-time conversion of data which is present in the form of messages on JMS-compliant or other messaging systems into database transactions, which can then subsequently be applied to multiple heterogeneous databases or other systems. In accordance with an embodiment, the invention provides a means by which data can be read from messages, and converted to a set of database operations that are then stored as a persistent trail file (for example, as an Oracle GoldenGate trail file). The operations, as recorded in the trail file, can then be routed via a network and applied to target systems as required. In accordance with an embodiment, the data can be read in real-time from the messaging system, and written out as quickly as it can be consumed to the persistent trail files.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="142.58mm" wi="277.96mm" file="US08626778-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="277.79mm" wi="164.34mm" orientation="landscape" file="US08626778-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="257.39mm" wi="157.48mm" orientation="landscape" file="US08626778-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="219.96mm" wi="195.50mm" orientation="landscape" file="US08626778-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CLAIM OF PRIORITY</heading>
<p id="p-0002" num="0001">This application claims the benefit of priority to U.S. Provisional Patent Application No. 61/367,323, titled &#x201c;SYSTEM AND METHOD FOR CONVERSION OF JMS MESSAGE DATA INTO DATABASE TRANSACTIONS FOR APPLICATION TO MULTIPLE HETEROGENEOUS DATABASES&#x201d;, filed Jul. 23, 2010; which application is herein incorporated by reference.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">COPYRIGHT NOTICE</heading>
<p id="p-0003" num="0002">A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.</p>
<heading id="h-0003" level="1">FIELD OF INVENTION</heading>
<p id="p-0004" num="0003">The present invention is generally related to transferring data between different systems, and is particularly related to a system and method for performing real-time conversion of data present in the form of messages on JMS-compliant messaging systems into database transactions, which can subsequently be applied to multiple heterogeneous databases.</p>
<heading id="h-0004" level="1">BACKGROUND</heading>
<p id="p-0005" num="0004">A common data integration problem is the need to apply data transactions that occur in a first system, at a second, perhaps totally different, system, whilst preserving the transactional semantics of the data. Oftentimes, the operations belonging to particular transactions need to be applied either entirely or partially as soon as possible after the original transaction has completed (i.e. in real-time). In some environments, messages representing a change to an original data are placed on a messaging system and/or a message queue by an application at the first system. Generally, in order to perform a similar operation at a second system (e.g. a database), custom software code must be developed to read the data from the message queue, and apply it as appropriate to the second system). Problems can occur if the second system is not known a priori, or if the transaction needs to be recovered, since there is no means to restore data from messages that have already been consumed. Certain systems would benefit from such integration, but no real-time means is currently available. This is the general area that embodiments of the invention are intended to address.</p>
<heading id="h-0005" level="1">SUMMARY</heading>
<p id="p-0006" num="0005">Described herein is a system and method for performing real-time conversion of data which is present in the form of messages on JMS-compliant or other messaging systems into database transactions, which can then subsequently be applied to multiple heterogeneous databases or other systems. In accordance with an embodiment, the invention provides a means by which data can be read from messages in a messaging system, and converted to a set of database operations that are then stored as a persistent trail file (for example, as an Oracle GoldenGate trail file). The operations, as recorded in the trail file, can then be routed via a network and applied to target systems as required, for example to maintain a replicated set of information at one or more different or heterogeneous systems. The data in the message can be formatted in a variety of ways, for example, as fixed width, delimited, or XML data, and the system can be configured to convert this data as appropriate. In accordance with an embodiment, the data can be read in real-time from the messaging system, and written out as quickly as it can be consumed to the persistent trail files. In scenarios where there is no current means of integration of two systems, the invention can be used as a bridge if, for example, the source system is modified or configured to write data changes to a messaging system, and Oracle GoldenGate is used as a means of delivery to the target system. Embodiments of the invention address the problem of propagating transactions from a message queue to a target system in real-time, do not require custom programs to be developed that are specific to each target database system, and provide a way to retransmit transactions in failure scenarios.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0006" level="1">BRIEF DESCRIPTION OF THE FIGURES</heading>
<p id="p-0007" num="0006"><figref idref="DRAWINGS">FIG. 1</figref> is an illustration of the overall architecture of a system for conversion of JMS message data into database transactions, in accordance with an embodiment.</p>
<p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. 2</figref> is another illustration of the system for conversion of message data into database transactions, in accordance with an embodiment.</p>
<p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. 3</figref> is a flowchart of a process for conversion of message data into database transactions, in accordance with an embodiment.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0007" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0010" num="0009">Described herein is a system and method for performing real-time conversion of data present in the form of messages on JMS-compliant messaging systems into database transactions which can subsequently be applied to multiple heterogeneous databases. Advantages of the solution include that it operates in real-time, providing the ability to integrate changes from one system to another as they occur with very little latency; provides flexible conversion options that allow the system to read a variety of formats of source messages, including XML, fixed width and delimited data, and have complete control on how those messages are converted into equivalent database operations; supports persistent storage of operations in a trail file and enables operations to be replayed into target systems should the target system need to be recovered from an earlier point in time; enables messages to be read from the queue in a transactional fashion and transaction semantics are embedded in the resultant trail; works out-of-the-box without any custom coding requirements to read messages and convert to operations in a trail; and, once the message queue data has been converted to trail files, can be applied to other heterogeneous databases.</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 1</figref> is an illustration of the overall architecture of a system for conversion of message data into database transactions, in accordance with an embodiment. As shown in the architecture <b>102</b> of <figref idref="DRAWINGS">FIG. 1</figref>, the system comprises a messaging capture adaptor <b>108</b>, which provides for conversion and communication of data from one or more source systems <b>104</b>, which in turn include or are associated with one or more messaging systems or messaging queues <b>106</b>. In accordance with an embodiment, a Java Message Service (JMS) system can be used, although other types of Message-oriented Middleware (MoM) or messaging system can be similarly used. As data changes occur at the source system, information about those data changes can be placed on an appropriate message queue and/or message topic, for subsequent retrieval.</p>
<p id="p-0012" num="0011">In accordance with an embodiment, the messaging capture adaptor can be provided as an extension to a data capture and replication system or product <b>110</b>, for example as an extension to the Oracle GoldenGate product which enables extraction and replication of data in the form of trail information or trail files <b>112</b> from a first database or transaction system to a second database or transaction system.</p>
<p id="p-0013" num="0012">At runtime, while the source system operates, messages are placed onto queues or topics corresponding to changes in the data at the source system, and using standard, e.g. JMS techniques for placing messages onto such queues. Depending on the particular implementation and user's preferences, an existing queue or topic can be used, or alternately a new queue or new topic can be configured for use in the replication process. The choice between using a queue or topic can also vary with the particular implementation and user preference, generally a queue will provide a 1:1 association between a message provider and a message queue subscriber, while a topic will allow for 1:N associations between a message provider and multiple N topic subscribers.</p>
<p id="p-0014" num="0013">In accordance with an embodiment, the messaging capture adaptor retrieves messages from the configured queues or topics, similarly using standard, e.g. JMS techniques for retrieving messages from such queues, converts the messages, and provides them as an output to the data capture and replication system or product. The extract process can then be used to generate a trail containing the processed data, which trail can be fed to other systems <b>114</b>, <b>115</b>, or and/or databases <b>116</b>.</p>
<p id="p-0015" num="0014">In accordance with an embodiment, the messaging capture adaptor can be provided as a Vendor Access Module (VAM) plug-in or application program interface (API) to the data capture and replication system or product. A set of properties <b>124</b>, rules, and external files and definitions <b>126</b> can be used to provide messaging connectivity information, and to define how the messages are to be parsed and mapped to records in the target trail.</p>
<p id="p-0016" num="0015">In accordance with an embodiment, the messaging capture adaptor comprises three major components: a messaging connectivity component <b>118</b>; a data parsing component <b>120</b>; and a VAM Interface component or API <b>122</b>. It will be evident that in accordance with other embodiments, different arrangements and other types of components, features, coding or logic, can be used to provide similar functionality.</p>
<p id="h-0008" num="0000">Messaging Connectivity Component</p>
<p id="p-0017" num="0016">In accordance with an embodiment, all messaging connectivity is provided through, e.g. a generic JMS interface. The JMS connectivity can be configured through property files, in a similar way to existing Java delivery components, that allow the following to be set: the Java classpath for the JMS client; a JMS source destination (queue or topic) name; JNDI connection properties, such as standard JNDI connection properties for Initial Context, connection factory JNDI name, and destination JNDI name; and Security information, such as JNDI authentication credentials, and JMS connection username and password.</p>
<p id="p-0018" num="0017">In accordance with an embodiment, the messaging capture adaptor can connect to the messaging provider on start-up; the &#x2018;extract&#x2019; process can be configured to automatically restart using standard &#x2018;manager&#x2019; autorestart parameters in the event of any connectivity related errors during processing.</p>
<p id="p-0019" num="0018">In accordance with an embodiment, the messaging capture adaptor supports JMS text messages. When asked by the messaging capture adaptor for the next message, the messaging connectivity component: starts a local JMS transaction if not already started; reads a message off the queue; if no message exists returns end-of-file; and otherwise returns the contents of the message and any message header properties to the messaging capture adaptor. Once the messaging capture adaptor has successfully parsed the message, has output an entire transaction to a trail, and ensured the transaction has been flushed to disk, the messaging connectivity component commits the JMS local transaction, removing the messages from the queue or topic. In the event of any error this local transaction can be rolled back, leaving the unprocessed messages on JMS server.</p>
<p id="p-0020" num="0019">In accordance with an embodiment, JMS properties obtained from the header are available as values in all parsers when specified in the properties file in the form $JMSProperty.</p>
<p id="h-0009" num="0000">Data Parsing Component</p>
<p id="p-0021" num="0020">In accordance with an embodiment, the messaging capture adaptor provides one or more of: fixed width message parsing delimited message parsing XML message parsing In order to parse the data and translate it to Oracle GoldenGate records, the data parsing component needs to be provided with the source and target formats of the data, and rules to translate from the source to the target. The mechanisms used to provide this information are parser dependent.</p>
<p id="p-0022" num="0021">In accordance with an embodiment, a separate utility <b>128</b> can be provided to generate a sourcedefs file <b>132</b> that is based on the data definition and parser properties. Since the trail may be stored in the form of binary data in a trail file, the sourcedefs file allows another system or product to decipher its contents.</p>
<p id="h-0010" num="0000">VAM Communications Component/Interface Component</p>
<p id="p-0023" num="0022">In accordance with an embodiment, the VAM plug-in or application program interface (API) provides a read interface that can invoked through a standard Oracle GoldenGate extract parameter file as is demonstrated in the following sample:</p>
<p id="p-0024" num="0023">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="196pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>add extract &#x3c;extname&#x3e;, VAM</entry>
</row>
<row>
<entry/>
<entry>add extttrail ./dirdat/aa, extract &#x3c;extname&#x3e;, megabytes 100</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0025" num="0024">In accordance with an embodiment, the messaging capture adaptor can be provided as a shared library (for example as a .so or .dll file) that integrates into the dataflow via, e.g. the GoldenGate extract process. In accordance with these embodiments, the separate utility can use the same properties file as the messaging capture adaptor, reading in properties and any parser specific data definition, and creating a GoldenGate sourcedefs file to be used by an Oracle GoldenGate product.</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 2</figref> is another illustration of the system for conversion of JMS message data into database transactions, in accordance with an embodiment. As shown in <figref idref="DRAWINGS">FIG. 2</figref>, in a typical or Generic GoldenGate installation, a source system <b>142</b> can include a database <b>146</b>, extract process <b>148</b> for creating trails <b>150</b>, and a pump process <b>152</b> for communicating trails to other systems. A target system <b>144</b> can similarly include a database <b>158</b>, and a replication process <b>156</b> for processing received trails <b>154</b>. The messaging capture adaptor VAM <b>108</b> can be added to the Generic Oracle GoldenGate installation, and used to retrieve data published to messages queues or topics, and communicate that data from the source system to the target system.</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 3</figref> is a flowchart of a process for conversion of JMS message data into database transactions, in accordance with an embodiment. As shown in <figref idref="DRAWINGS">FIG. 3</figref>, in step <b>170</b>, the source system is configured or associated with a messaging system (e.g., a JMS, MoM, or other system and/or message queues or topics) that allows data changes at the source system to be published or placed on a message queue or topic. In step <b>172</b>, the messaging capture adaptor is configured to selectively retrieve, parse and convert messages sent to the messaging system, e.g. to a particular queue or topic. In step <b>174</b>, for a particular transaction, the messaging capture adaptor requests messages from one or more message queue or topic, as configured. In step <b>176</b>, a local transaction is created if it does not already exist, and/or updated corresponding to the particular transaction, and messages are retrieved for use in creating a trail for the transaction or data operation at the source system. In step <b>178</b>, after verifying the trail creation and/or persistent storage of the trail file, the local transaction is committed, which remove the message from the one or more message queue or topic. In step <b>180</b>, the trail information or trail file is communicated or &#x201c;pumped&#x2019; to one or more target systems (e.g. database), for use in replicating transaction at those target systems, for example using Oracle GoldenGate or another product.</p>
<p id="h-0011" num="0000">Messaging Capture Adaptor Implementation</p>
<p id="p-0028" num="0027">As described above, in accordance with an embodiment, the system comprises a messaging capture adaptor which provides for conversion and communication of data from one or more source systems, which in turn include or are associated with one or more messaging systems or messaging queues. The following sections describe a particular implementation of such an embodiment messaging capture adaptor.</p>
<p id="p-0029" num="0028">in accordance with an embodiment, the Messaging Capture Adaptor (Adaptor) can be provided as an extension to a system such as, e.g. Oracle GoldenGate for Java, that processes data received in the form of messages on a message queue, and communicates with an Oracle GoldenGate extract process in order to generate a GoldenGate trail containing the processed data.</p>
<p id="p-0030" num="0029">In accordance with an embodiment, the Adaptor can be provided as a Vendor Access Module (VAM) plug-in to a generic extract process. A set of properties, rules and external files can provide messaging connectivity information and define how messages are parsed and mapped to records in the target GoldenGate trail. As described above with regard to <figref idref="DRAWINGS">FIG. 1</figref>, in accordance with an embodiment, the Adaptor comprises three major components: a messaging connectivity component <b>118</b>; a data parsing component <b>120</b>; and a VAM Interface component or API <b>122</b>.</p>
<p id="p-0031" num="0030">In accordance with an embodiment, the Message Capture can be provided as a shared library (for example, a .so or .dll file) that integrates into the dataflow via the GoldenGate extract process. A separate utility can be provided that uses the same properties file as the Message Capture, reads in properties and any parser specific data definition, and creates a GoldenGate &#x201c;sourcedefs&#x201d; file to be used in conjunction with the GoldenGate trail produced by the Message Capture.</p>
<p id="h-0012" num="0000">Messaging Connectivity</p>
<p id="p-0032" num="0031">In accordance with an embodiment, all messaging connectivity is through a generic JMS interface. The JMS connectivity should be configured through property files, in a similar way to existing Java delivery components, allowing the following to be set: the Java classpath for the JMS client; the JMS source destination (i.e. queue or topic) name; JNDI connection properties (i.e. standard JNDI connection properties for Initial Context; connection factory JNDI name; and destination JNDI name); and security information (i.e. JNDI authentication credentials; JMS connection username and password).</p>
<p id="p-0033" num="0032">The Adaptor can connect to the messaging provider on start-up; and the &#x2018;extract&#x2019; process can be configured to automatically restart using standard &#x2018;manager&#x2019; autorestart parameters in the event of any connectivity related errors during processing.</p>
<p id="p-0034" num="0033">In accordance with an embodiment, the Adaptor supports JMS text messages. When asked by the Adaptor for the next message, the Messaging Connectivity component: starts a local JMS transaction if not already started; reads a message off the queue; if no message exists returns end of file; otherwise returns the contents of the message and any message header properties to the Adaptor.</p>
<p id="p-0035" num="0034">Once the Adaptor has successfully parsed the message, has output an entire transaction to the trail, and ensured the transaction has been flushed to disk, the Messaging Connectivity component commits the JMS local transaction, removing the messages from the queue or topic. In the event of any error this local transaction can be rolled back, leaving the unprocessed messages on JMS server.</p>
<p id="p-0036" num="0035">JMS properties obtained from the header are available as values in all parsers when specified in the properties file in the form $JMSProperty.</p>
<p id="h-0013" num="0000">Data Parsing</p>
<p id="p-0037" num="0036">In accordance with an embodiment, the Adaptor provides one or more of: fixed width message parsing; delimited message parsing; or XML message parsing.</p>
<p id="p-0038" num="0037">In order to parse the data and translate it to, for example, Oracle GoldenGate records, the Parser needs to be provided with the source and target formats of the data, and rules to translate from source to target. The mechanisms used to provide this information are parser dependent. In accordance with an embodiment, a separate utility can be provided to generate an Oracle GoldenGate &#x201c;source defs&#x201d; file based on the data definition and parser properties.</p>
<p id="h-0014" num="0000">Fixed Width Parsing</p>
<p id="p-0039" num="0038">In accordance with an embodiment, the Adaptor supports fixed with parsing based on a data definition provided, e.g. in Cobol Copybook format, together with a set of properties that indicate how to map the Copybook to logical table records in an Oracle GoldenGate trail file and associated source definitions file. The Copybook should have records defined at level 01 that will map onto logical tables, together with higher level fields (05, 20, etc.) that correspond to columns of these logical tables. The data to be parsed should consist of a standard format header containing a number of fixed width fields, followed by a data segment also containing fixed width fields. The header should be defined by one of the Copybook level 01 records.</p>
<p id="p-0040" num="0039">Within this record definition there must be fields that represent: a commit timestamp/change time for the record; a function code to differentiate operations of the following types (Insert; Update; Delete); and the Copybook record name required to parse the data segment.</p>
<p id="p-0041" num="0040">The Copybook record name for the header record definition, and the field names for timestamp, function code and data record name should be configurable through a set of properties. An example Copybook definition containing these values is as follows:</p>
<p id="p-0042" num="0041">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="35pt" align="left"/>
<colspec colname="2" colwidth="105pt" align="left"/>
<colspec colname="3" colwidth="63pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>01</entry>
<entry>HEADER.</entry>
<entry/>
</row>
<row>
<entry/>
<entry/>
<entry>20&#x2003;Hdr-Timestamp</entry>
<entry>&#x2002;PIC X(23)</entry>
</row>
<row>
<entry/>
<entry/>
<entry>20&#x2003;Hdr-Source-DB-Function</entry>
<entry>PIC X</entry>
</row>
<row>
<entry/>
<entry/>
<entry>20&#x2003;Hdr-Source-DB-Rec-Id</entry>
<entry>PIC X(8)</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
with corresponding example configuration properties of:
</p>
<p id="p-0043" num="0042">
<tables id="TABLE-US-00003" num="00003">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="168pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>fixed.header=HEADER</entry>
</row>
<row>
<entry/>
<entry>fixed.timestamp=Hdr-Timestamp</entry>
</row>
<row>
<entry/>
<entry>fixed.optype=Hdr-Source-DB-Function</entry>
</row>
<row>
<entry/>
<entry>fixed.table=Hdr-Source-DB-Rec-Id</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0044" num="0043">The logical table name output by the Adaptor will match the table value defined above. In accordance with an embodiment, it is possible to define the logical schema name through a static property:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0044">fixed.schema=&#x201c;MYSCHEMA&#x201d;</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0045" num="0045">Additionally, in accordance with an embodiment, it is possible to use more than one field to determine a record name. The defined fields will simply be concatenated in the order they are provided. For example:</p>
<p id="p-0046" num="0046">
<tables id="TABLE-US-00004" num="00004">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="21pt" align="left"/>
<colspec colname="2" colwidth="112pt" align="left"/>
<colspec colname="3" colwidth="70pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>01</entry>
<entry>HEADER.</entry>
<entry/>
</row>
<row>
<entry/>
<entry/>
<entry>20&#x2003;Hdr-Source-DB</entry>
<entry>PIC X(8).</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="126pt" align="left"/>
<colspec colname="2" colwidth="56pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>20&#x2003;Hdr-Source-DB-Rec-Id</entry>
<entry>PIC X(8).</entry>
</row>
<row>
<entry/>
<entry>20&#x2003;Hdr-Source-DB-Rec-Version</entry>
<entry>PIC 9(4).</entry>
</row>
<row>
<entry/>
<entry>20&#x2003;Hdr-Source-DB-Function</entry>
<entry>PIC X</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="140pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>20&#x2003;Hdr-Timestamp</entry>
<entry>PIC X(22)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>fixed.header=HEADER</entry>
</row>
<row>
<entry/>
<entry>fixed.table=Hdr-Source-DB-Rec-Id,Hdr-Source-DB-Rec-Version</entry>
</row>
<row>
<entry/>
<entry>fixed.schema=&#x201d;MYSCHEMA&#x201d;</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
will give logical schema and table names of the form:
<ul id="ul0003" list-style="none">
    <li id="ul0003-0001" num="0000">
    <ul id="ul0004" list-style="none">
        <li id="ul0004-0001" num="0047">MYSCHEMA.Hdr-Source-DB-Rec-Id+Hdr-Source-DB-Rec-Version</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0047" num="0048">In accordance with an embodiment, the Adaptor should parse the timestamp using a default format of &#x201c;YYYY-MM-DD HH:MM:SS:FFF&#x201d; with FFF depending on the size of the field. It should also be possible to override this default format using a comment before any date/time field that contains the format in a normalized fashion. For example, to parse using the format &#x201c;YYYY-MM-DD-HH.MM.SS.FF&#x201d; a comment would be added as follows:</p>
<p id="p-0048" num="0049">
<tables id="TABLE-US-00005" num="00005">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21pt" align="left"/>
<colspec colname="2" colwidth="196pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>01</entry>
<entry>&#x2002;HEADER.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21pt" align="left"/>
<colspec colname="2" colwidth="154pt" align="left"/>
<colspec colname="3" colwidth="42pt" align="left"/>
<tbody valign="top">
<row>
<entry>*</entry>
<entry>DATEFORMAT YYYY-MM-DD-HH.MM.SS.FF</entry>
<entry/>
</row>
<row>
<entry/>
<entry>&#x2002;20&#x2003;Hdr-Timestamp</entry>
<entry>PIC X(23)</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0049" num="0050">The values in the optype should be mapped onto standard GoldenGate operation types using a set of properties, indicating which value of the optype maps onto which operation type. For example:</p>
<p id="p-0050" num="0051">
<tables id="TABLE-US-00006" num="00006">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="168pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>fixed.optype=Hdr-Source-DB-Function</entry>
</row>
<row>
<entry/>
<entry>fixed.optype.insertval=A</entry>
</row>
<row>
<entry/>
<entry>fixed.optype.updateval=U</entry>
</row>
<row>
<entry/>
<entry>fixed.optype.deleteval=D</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0051" num="0052">Any fields in the header record not mapped to the GoldenGate header fields should be output as columns for all records parsed by the Adaptor. The data in the header and record data will be parsed based on the PIC definition of that data and written to the trail depending on the translated data type as follows: any field definition preceded by a timestamp format comment should be translated to an Oracle GoldenGate date/time field with an appropriate size, if no timestamp format is present, the field should be treated as its underlying datatype; any X field should be translated to CHAR datatype with the defined length; and any 9 field should be translated to a NUMBER datatype with the defined precision and scale. Signed and unsigned numbers with and without decimal points should be supported. Table 1 shows some examples.</p>
<p id="p-0052" num="0053">
<tables id="TABLE-US-00007" num="00007">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="35pt" align="left"/>
<colspec colname="2" colwidth="84pt" align="left"/>
<colspec colname="3" colwidth="98pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="3" rowsep="1">TABLE 1</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>PIC XX</entry>
<entry>CHAR(2)</entry>
</row>
<row>
<entry/>
<entry>PIC X(16)</entry>
<entry>CHAR(16)</entry>
</row>
<row>
<entry/>
<entry>PIC 9(4)</entry>
<entry>NUMBER(4)</entry>
</row>
<row>
<entry/>
<entry>* YYMM</entry>
<entry>DATE(10)</entry>
</row>
<row>
<entry/>
<entry>PIC 9(4)</entry>
<entry>YYYY-MM-DD</entry>
</row>
<row>
<entry/>
<entry>PIC 99.99</entry>
<entry>NUMBER(4,2)</entry>
</row>
<row>
<entry/>
<entry>PIC 9(5)V99</entry>
<entry>NUMBER(7,2)</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0053" num="0054">In order to identify key columns within data (not header) records in the copybook, a comment of * KEY should be used. This will mark these columns as keys when the source definitions are generated with the utility. For example:</p>
<p id="p-0054" num="0055">
<tables id="TABLE-US-00008" num="00008">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="91pt" align="left"/>
<colspec colname="3" colwidth="63pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>10</entry>
<entry>TABLE1</entry>
<entry/>
</row>
<row>
<entry/>
<entry>*</entry>
<entry>KEY</entry>
</row>
<row>
<entry/>
<entry/>
<entry>20&#x2003;Key</entry>
<entry>PIC X(19)</entry>
</row>
<row>
<entry/>
<entry/>
<entry>20&#x2003;PAN_Seq_Num</entry>
<entry>PIC 9(3)</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
indicates that the Key column is a key for the TABLE1 table.
<br/>
Delimited Parsing
</p>
<p id="p-0055" num="0056">In accordance with an embodiment, the Adaptor supports delimited parsing based on a set of properties and a pre-existing source definitions file. The properties determine the delimiters to use and other rules; the source definitions file determines the valid tables that can be handled and the ordering and data types of columns in those tables. A delimited message has the format:
<ul id="ul0005" list-style="none">
    <li id="ul0005-0001" num="0000">
    <ul id="ul0006" list-style="none">
        <li id="ul0006-0001" num="0057">{METACOLS|}<sup>n</sup>[{COLNAMES|}]<sup>m</sup>[{COLBEFOREVALS|}]<sup>m</sup>{COLVALUES|}<sup>m</sup>\n
<br/>
where:
</li>
        <li id="ul0006-0002" num="0058">There can be n meta columns each followed by a field delimiter |</li>
        <li id="ul0006-0003" num="0059">And m columns each followed by a field delimiter (except the last one)</li>
        <li id="ul0006-0004" num="0060">For each column the name, and before value are optional</li>
        <li id="ul0006-0005" num="0061">Each record is terminated by an end of line delimiter \n</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0056" num="0062">The meta columns determine fields in the delimited record that have special meaning, corresponding to a header for that record. Valid meta columns should include:
<ul id="ul0007" list-style="none">
    <li id="ul0007-0001" num="0000">
    <ul id="ul0008" list-style="none">
        <li id="ul0008-0001" num="0063">optype&#x2014;determining if the record is an insert, update or delete</li>
        <li id="ul0008-0002" num="0064">timestamp&#x2014;indicating the value to be used for the commit timestamp of the record</li>
        <li id="ul0008-0003" num="0065">schemaandtable&#x2014;the full table name SCHEMA.TABLE for the record</li>
        <li id="ul0008-0004" num="0066">schema&#x2014;just the SCHEMA name for the record</li>
        <li id="ul0008-0005" num="0067">table&#x2014;just the TABLE name for the record</li>
        <li id="ul0008-0006" num="0068">txind&#x2014;whether this record is beginning, middle, end or whole transaction</li>
        <li id="ul0008-0007" num="0069">id&#x2014;value to be used as the RSN/CSN of the record and transaction (first record)
<br/>
Some of these meta columns may have additional properties as follows:
</li>
        <li id="ul0008-0008" num="0070">optype&#x2014;values corresponding to insert, updates and deletes (default to I,U,D)</li>
        <li id="ul0008-0009" num="0071">timestamp&#x2014;format of the timestamp (default to &#x201c;YYYY-DD-MM HH:MM:SS.FFF&#x201d;)</li>
        <li id="ul0008-0010" num="0072">txind&#x2014;values corresponding to begin, end, middle, whole (default to 0, 1, 2, 3)</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0057" num="0073">The parsing of the delimited data should be governed by a set of properties that determine delimiters and other values as follows:
<ul id="ul0009" list-style="none">
    <li id="ul0009-0001" num="0000">
    <ul id="ul0010" list-style="none">
        <li id="ul0010-0001" num="0074">fielddelim&#x2014;define a value in ascii or hex for the field delimiter (can be 1 or more chars)</li>
        <li id="ul0010-0002" num="0075">recorddelim&#x2014;define a value in ascii or hex for the record delimiter (1 or more chars)</li>
        <li id="ul0010-0003" num="0076">quote&#x2014;define a value in ascii or hex to use as for quoted values (1 or more chars)</li>
        <li id="ul0010-0004" num="0077">nullindicator&#x2014;define a value in ascii or hex to use for NULL values (1 or more chars)</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0058" num="0078">In accordance with an embodiment, a value can be defined to look for inside data values that equates to an escaped version of any of the above delimiters. For example, inside a quoted value, replace &#x201c; &#x201d; with &#x201c;, or \\\n with \n. Data values may be present in the record with or without quotes. However, unescaping will only happen within quoted values, and a non-quoted string that matches a null indicator will be treated as null. The following additional properties should allow for more fine grained control over how the text in a delimited record is parsed:
<ul id="ul0011" list-style="none">
    <li id="ul0011-0001" num="0000">
    <ul id="ul0012" list-style="none">
        <li id="ul0012-0001" num="0079">hasbefores&#x2014;indicates before values are also present for each record</li>
        <li id="ul0012-0002" num="0080">hasnames&#x2014;indicates column names are also present for each record</li>
        <li id="ul0012-0003" num="0081">afterfirst&#x2014;indicates column after values come before column before values</li>
        <li id="ul0012-0004" num="0082">isgrouped&#x2014;indicates all column names, before values (where present) and after values are grouped together in three blocks, rather than alternately per column</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0059" num="0083">When parsing dates, a default format of &#x201c;YYYY-DD-MM HH:MM:SS.FFF&#x201d; should be used. However, in certain cases this will need to be overridden. The user should be able to override this on a global, table or column level. For example:</p>
<p id="p-0060" num="0084">
<tables id="TABLE-US-00009" num="00009">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="182pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>dateformat.default=MM/DD/YYYY-HH:MM:SS</entry>
</row>
<row>
<entry/>
<entry>dateformat.MY.TABLE=DD/MMM/YYYY</entry>
</row>
<row>
<entry/>
<entry>dateformat.MY.TABLE.COL1=MMYYYY</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0061" num="0085">In accordance with an embodiment, the parser should first read and validate the meta columns for each record. Once this step is complete, the table name should be available. This should be used to lookup the column definitions for that table in the source definitions file. The columns should then be parsed and output in the trail in the order, and in the format, defined by the source definitions. If the specified table is not present, the capture should stop.</p>
<p id="h-0015" num="0000">XML Parsing</p>
<p id="p-0062" num="0086">In accordance with an embodiment, the Adaptor supports XML parsing based on a set of properties and a pre-existing source definitions file. The properties determine the rules used to determine XML elements and/or attributes that correspond to transactions, operations and columns; the source definitions file determines the valid tables that can be handled and the ordering and data types of columns in those tables. An XML message to be parsed can be formatted in one of two general styles:
<ul id="ul0013" list-style="none">
    <li id="ul0013-0001" num="0000">
    <ul id="ul0014" list-style="none">
        <li id="ul0014-0001" num="0087">Dynamic XML&#x2014;contents of the XML determining tables and columns are data values at runtime that cannot be predetermined through a sample XML or XSD document</li>
        <li id="ul0014-0002" num="0088">Static XML&#x2014;contents of the XML determining tables and columns element or attribute names can be predetermined through a sample XML or XSD document
<br/>
To further clarify this, here are two examples containing the same data:
<br/>
Dynamic XML
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0063" num="0089">
<tables id="TABLE-US-00010" num="00010">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>&#x3c;transaction id=&#x201c;1234&#x201d; ts=&#x201c;2010-02-05:10:11:21&#x201d;&#x3e;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x3c;operation table=&#x201c;MY.TABLE&#x201d; optype=&#x201c;I&#x201d;&#x3e;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x3c;column name=&#x201c;keycol&#x201d; index=&#x201c;0&#x201d;&#x3e;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x3c;aftervalue&#x3e;&#x3c;![CDATA[keyval]]&#x3e;&#x3c;/aftervalue&#x3e;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x3c;/column&#x3e;</entry>
</row>
<row>
<entry/>
<entry>&#x3c;column name=&#x201c;col1&#x201d; index=&#x201c;1&#x201d;&#x3e;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x3c;aftervalue&#x3e;&#x3c;![CDATA[col1val]]&#x3e;&#x3c;/aftervalue&#x3e;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x3c;/column&#x3e;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x3c;/operation&#x3e;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x3c;/transaction&#x3e;</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0064" num="0090">Every operation to every table will have the same basic message structure consisting of transaction, operation and column elements. The table name, operation type, timestamp, column names, column values, etc. are obtained from attribute or element text values.</p>
<p id="h-0016" num="0000">Static XML</p>
<p id="p-0065" num="0091">
<tables id="TABLE-US-00011" num="00011">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>&#x3c;NewMyTableEntries&#x3e;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x3c;NewMyTableEntry&#x3e;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x3c;CreateTime&#x3e;2010-02-05:10:11:21&#x3c;/CreateTime&#x3e;</entry>
</row>
<row>
<entry/>
<entry>&#x3c;KeyCol&#x3e;keyval&#x3c;/KeyCol&#x3e;</entry>
</row>
<row>
<entry/>
<entry>&#x3c;Col1&#x3e;col1val&#x3c;/Col1&#x3e;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x3c;/NewMyTableEntry&#x3e;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x3c;/NewMyTableEntries&#x3e;</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0066" num="0092">In this case, the NewMyTableEntries element marks the transaction boundaries. The NewMyTableEntry indicates an insert to MY.TABLE. The timestamp is present in an element text value, and the column names are indicated by element names.</p>
<p id="p-0067" num="0093">In accordance with an embodiment, it should be possible to define rules in the properties file to parse either of these two styles of XML through a set of XPath like properties. The goal of the properties is to map the XML to a predefined source definitions files through XPath matches.</p>
<p id="h-0017" num="0000">XML Parsing Rules</p>
<p id="p-0068" num="0094">Independent of the style of XML, the system should be enabled to determine how to ascertain: transaction boundaries; operation entries and meta data including table name, operation type, timestamp; and column entries and meta data including column name and/or index, column before and/or after values.</p>
<p id="p-0069" num="0095">This can be done through a set of inter-related rules. In accordance with an embodiment, for each type of XML message to be processed there can be one high-level rules that encapsulates the detailed rules to obtain the above data. These can be specified through a set of properties. For example:</p>
<p id="p-0070" num="0096">
<tables id="TABLE-US-00012" num="00012">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>xmlparser.rules=genericrule</entry>
</row>
<row>
<entry/>
<entry>xmlparser.rules.genericrule.type=tx</entry>
</row>
<row>
<entry/>
<entry>xmlparser.rules.genericrule.subrules=oprule</entry>
</row>
<row>
<entry/>
<entry>xmlparser.rules.oprule.type=op</entry>
</row>
<row>
<entry/>
<entry>...</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
Generic Rule Concepts
</p>
<p id="p-0071" num="0097">All rules should have the following generic properties: name&#x2014;a mechanism to identify the rule (part of property name); type&#x2014;either transaction, operation or column; match&#x2014;an XPath expression determining when to activate the rule (can be omitted); and subrules&#x2014;a set of rule names to be executed when this rule is matched. Each of the rule types should then have additional properties specific to that type.</p>
<p id="h-0018" num="0000">XPath Expressions</p>
<p id="p-0072" num="0098">In accordance with an embodiment, the XML parser supports a subset of XPath expressions necessary to match elements and extract data. It is not the intention to support the full set of XPath functionality. An expression can be used to match a particular element, or extract data. In the data extraction case most of the path is used to match, the tail of the expression is used for extraction. The following constructs should be supported:</p>
<p id="p-0073" num="0099">
<tables id="TABLE-US-00013" num="00013">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>/e - use absolute path from the root of the document to match e</entry>
</row>
<row>
<entry>./e or e - use relative path from current node being processed to match e</entry>
</row>
<row>
<entry>../e - use a path based on the parent of the current node (can be repeated)</entry>
</row>
<row>
<entry>to match e</entry>
</row>
<row>
<entry>//e - matches e wherever it occurs in a document</entry>
</row>
<row>
<entry>* - wildcard match to match any element (partial wild-carded names are</entry>
</row>
<row>
<entry>out of scope)</entry>
</row>
<row>
<entry>[n] - match the nth occurrence of an expression</entry>
</row>
<row>
<entry>= [x=v] - match when x is equal to some value v where x can be: @att -</entry>
</row>
<row>
<entry>some attribute value, text( ) - some text value, name( ) the element name,</entry>
</row>
<row>
<entry>position( ) the element position.</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
This should support simple expressions such as:
</p>
<p id="p-0074" num="0100">
<tables id="TABLE-US-00014" num="00014">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="182pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>match root element: /My/Element</entry>
</row>
<row>
<entry/>
<entry>match sub element to current node: ./Sub/Element</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
or more complex expressions such as:
</p>
<p id="p-0075" num="0101">
<tables id="TABLE-US-00015" num="00015">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>match nth element: /My/*[n]</entry>
</row>
<row>
<entry/>
<entry>match nth Some element: /My/Some[n]</entry>
</row>
<row>
<entry/>
<entry>match any text val: /My/*[text( ) =&#x2018;value&#x2019;]</entry>
</row>
<row>
<entry/>
<entry>match text in Some element: /My/Some[text( ) = &#x2018;value&#x2019;]</entry>
</row>
<row>
<entry/>
<entry>match any attribute: /My/*[@att = &#x2018;value&#x2019;]</entry>
</row>
<row>
<entry/>
<entry>match attribute in Some element: /My/Some[@att = &#x2018;value&#x2019;]</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0076" num="0102">In addition to matching paths, the XPath expressions can also be used to obtain data values, either absolutely, or relative to the current node being processed. Data value expressions can contain any of the path elements above, but must end with one of:
<ul id="ul0015" list-style="none">
    <li id="ul0015-0001" num="0000">
    <ul id="ul0016" list-style="none">
        <li id="ul0016-0001" num="0103">@att&#x2014;some attribute value</li>
        <li id="ul0016-0002" num="0104">text( )&#x2014;the text content (value) of an element</li>
        <li id="ul0016-0003" num="0105">content( )&#x2014;the full content, including any child XML nodes of an element</li>
        <li id="ul0016-0004" num="0106">name( )&#x2014;the name of an element</li>
        <li id="ul0016-0005" num="0107">position( )&#x2014;the position of an element in its parent
<br/>
Examples of these include:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0077" num="0108">
<tables id="TABLE-US-00016" num="00016">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="196pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>extract relative element text value: ./My/Element/text( )</entry>
</row>
<row>
<entry/>
<entry>extract absolute attribute value: /My/Element/@att</entry>
</row>
<row>
<entry/>
<entry>extract element text value with match: /My/Some[@att =</entry>
</row>
<row>
<entry/>
<entry>&#x2018;value&#x2019;]/Sub/text( )</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
Other Value Expressions
</p>
<p id="p-0078" num="0109">In accordance with an embodiment, in addition to XPath expressions, values should also be able to be directly extracted from JMS message properties as detailed earlier, or hardcoded values of the form &#x201c;value&#x201d;.</p>
<p id="h-0019" num="0000">Transaction Rules</p>
<p id="p-0079" num="0110">In accordance with an embodiment, the boundary for a transaction is the highest level rule. The options for how to determine transactions from the contents of XML are as follows: each message contains a single transaction; each message can contain multiple transactions; transaction can span messages. These are specified as follows:
<ul id="ul0017" list-style="none">
    <li id="ul0017-0001" num="0000">
    <ul id="ul0018" list-style="none">
        <li id="ul0018-0001" num="0111">single&#x2014;transaction rule match not defined</li>
        <li id="ul0018-0002" num="0112">multiple&#x2014;each transaction rule match defines new transaction</li>
        <li id="ul0018-0003" num="0113">span&#x2014;no transaction rule is defined, a transaction indicator is specified in an operation rule</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0080" num="0114">If a transaction rule is specified, the following properties of the rule may also be defined through XPath or other expressions:
<ul id="ul0019" list-style="none">
    <li id="ul0019-0001" num="0000">
    <ul id="ul0020" list-style="none">
        <li id="ul0020-0001" num="0115">timestamp&#x2014;time at which the transaction occurred</li>
        <li id="ul0020-0002" num="0116">id&#x2014;an identifier for the transaction (optional)
<br/>
Examples of transaction rules are as follows:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0081" num="0117">
<tables id="TABLE-US-00017" num="00017">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>// transaction is whole message, timestamp comes from JMS property</entry>
</row>
<row>
<entry>singletxrule.timestamp=$JMSTimeStamp</entry>
</row>
<row>
<entry>// match root element transaction and obtain timestamp from ts attribute</entry>
</row>
<row>
<entry>dyntxrule.match=/Transaction</entry>
</row>
<row>
<entry>dyntxrule.timestamp=@ts</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
Transaction rules can have multiple subrules, but each must be of type operation.
<br/>
Operation Rules
</p>
<p id="p-0082" num="0118">In accordance with an embodiment, an operation rule can either be a subrule of a transaction rule, or a highest level rule (if transactionality is determined via a property of the operation. In addition to the standard rule properties an operation rule should also define the following through XPath or other expressions:
<ul id="ul0021" list-style="none">
    <li id="ul0021-0001" num="0000">
    <ul id="ul0022" list-style="none">
        <li id="ul0022-0001" num="0119">timestamp&#x2014;timestamp of the operation (optional if transaction rule is defined)</li>
        <li id="ul0022-0002" num="0120">table&#x2014;name of the table on which this is an operation and</li>
        <li id="ul0022-0003" num="0121">schema&#x2014;name of schema for the table or just</li>
        <li id="ul0022-0004" num="0122">schemaandtable&#x2014;both schema and table name together in the form SCHEMA.TABLE</li>
        <li id="ul0022-0005" num="0123">optype&#x2014;whether this is an insert, update or delete operation based on optype values:
        <ul id="ul0023" list-style="none">
            <li id="ul0023-0001" num="0124">optype.insertval&#x2014;value indicating an insert, defaults to &#x2018;I&#x2019;</li>
            <li id="ul0023-0002" num="0125">optype.updateval&#x2014;value indicating an update, defaults to &#x2018;U&#x2019;</li>
            <li id="ul0023-0003" num="0126">optype.deleteval&#x2014;value indicating a delete, defaults to &#x2018;D&#x2019;</li>
        </ul>
        </li>
        <li id="ul0022-0006" num="0127">id&#x2014;an identifier for the operation (optional)</li>
        <li id="ul0022-0007" num="0128">txind&#x2014;whether this operation is begin/middle/end/whole operation if (optional, and only valid if the operation rule is not a subrule of a transaction rule)
<br/>
Examples of operation rules are as follows:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0083" num="0129">
<tables id="TABLE-US-00018" num="00018">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>// dynamically obtain operation info from the /Operation element of a</entry>
</row>
<row>
<entry>/Transaction</entry>
</row>
<row>
<entry>dynoprule.match=./Operation</entry>
</row>
<row>
<entry>dynoprule.schemaandtable=@table</entry>
</row>
<row>
<entry>dynoprule.optype=@type</entry>
</row>
<row>
<entry>// statically match /NewMyTableEntry element to an insert operation on</entry>
</row>
<row>
<entry>the MY.TABLE</entry>
</row>
<row>
<entry>table:</entry>
</row>
<row>
<entry>statoprule.match=./NewMyTableEntry</entry>
</row>
<row>
<entry>statoprule.schemaandtable=&#x201d;MY.TABLE&#x201d;</entry>
</row>
<row>
<entry>statoprule.optype=&#x201d;I&#x201d;</entry>
</row>
<row>
<entry>statoprule.timestamp=./CreateTime/text( )</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
Operation rules can have multiple subrules, of type operation or column.
<br/>
Column Rules
</p>
<p id="p-0084" num="0130">In accordance with an embodiment, a column rule must be a subrule of an operation rule. In addition to the standard rule properties, a column rule should also define the following through XPath or other expressions:
<ul id="ul0024" list-style="none">
    <li id="ul0024-0001" num="0000">
    <ul id="ul0025" list-style="none">
        <li id="ul0025-0001" num="0131">name&#x2014;the name of the column within the table definition and/or</li>
        <li id="ul0025-0002" num="0132">index&#x2014;the index of the column within the table definition
        <ul id="ul0026" list-style="none">
            <li id="ul0026-0001" num="0133">(NOTE: if only one of the above is defined, the other will be determined)</li>
        </ul>
        </li>
        <li id="ul0025-0003" num="0134">before.value&#x2014;before value of the column (required for deletes, optional for updates)</li>
        <li id="ul0025-0004" num="0135">before.isnull&#x2014;indicates whether the before value of the column is null</li>
        <li id="ul0025-0005" num="0136">before.ismissing&#x2014;indicates whether the before value of the column is missing</li>
        <li id="ul0025-0006" num="0137">after.value&#x2014;before value of the column (required for deletes, optional for updates)</li>
        <li id="ul0025-0007" num="0138">after.isnull&#x2014;indicates whether the before value of the column is null</li>
        <li id="ul0025-0008" num="0139">after.ismissing&#x2014;indicates whether the before value of the column is missing</li>
        <li id="ul0025-0009" num="0140">value&#x2014;an expression to use for both before.value and after.value (does not support different before values for updates) unless overridden by specific before or after values</li>
        <li id="ul0025-0010" num="0141">isnull&#x2014;an expression to use for both before.isnull and after.isnull unless overridden</li>
        <li id="ul0025-0011" num="0142">ismissing&#x2014;an expression to use for both before.ismissing and after.ismissing unless overridden
<br/>
Examples of column rules are as follows:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0085" num="0143">
<tables id="TABLE-US-00019" num="00019">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>// dynamically obtain column info from the /Column element of an</entry>
</row>
<row>
<entry>/Operation</entry>
</row>
<row>
<entry>dyncolrule.match=./Column</entry>
</row>
<row>
<entry>dyncolrule.name=@name</entry>
</row>
<row>
<entry>dyncolrule.before.value=./beforevalue/text( )</entry>
</row>
<row>
<entry>dyncolrule.after.value=./aftervalue/text( )</entry>
</row>
<row>
<entry>// statically match /KeyCol and /Col1 elements to columns in MY.TABLE</entry>
</row>
<row>
<entry>statkeycolrule.match=/KeyCol</entry>
</row>
<row>
<entry>statkeycolrule.name=&#x201d;keycol&#x201d;</entry>
</row>
<row>
<entry>statkeycolrule.value=./text( )</entry>
</row>
<row>
<entry>statcol1rule.match=/Col1</entry>
</row>
<row>
<entry>statcol1rule.name=&#x201d;col1&#x201d;</entry>
</row>
<row>
<entry>statcol1rule.value=./text( )</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0086" num="0144">In accordance with an embodiment, the example shown in Table 2 uses the XML samples provided before, with appropriate rules to generate the same resulting operation on the MY.TABLE table.</p>
<p id="p-0087" num="0145">
<tables id="TABLE-US-00020" num="00020">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="98pt" align="left"/>
<colspec colname="3" colwidth="119pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="3" rowsep="1">TABLE 2</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>&#x3c;transaction id=&#x2033;1234&#x2033;</entry>
<entry>&#x3c;NewMyTableEntries&#x3e;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="28pt" align="left"/>
<colspec colname="2" colwidth="126pt" align="left"/>
<colspec colname="3" colwidth="105pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>ts=&#x2033;2010-02-05:10:11:21&#x2033;&#x3e;</entry>
<entry>&#x3c;NewMyTableEntry&#x3e;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="14pt" align="left"/>
<colspec colname="2" colwidth="154pt" align="left"/>
<colspec colname="3" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x3c;operation table=&#x2033;MY.TABLE&#x2033;</entry>
<entry>&#x3c;CreateTime&#x3e;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="182pt" align="left"/>
<colspec colname="2" colwidth="77pt" align="left"/>
<tbody valign="top">
<row>
<entry>optype=&#x2033;I&#x2033;&#x3e;</entry>
<entry>2010-02-05:10:11:21</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="28pt" align="left"/>
<colspec colname="2" colwidth="140pt" align="left"/>
<colspec colname="3" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x3c;column name=&#x2033;keycol&#x2033; index=&#x2033;0&#x2033;&#x3e;</entry>
<entry>&#x3c;/CreateTime&#x3e;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="126pt" align="left"/>
<colspec colname="3" colwidth="91pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x2002;&#x3c;aftervalue&#x3e;</entry>
<entry>&#x3c;KeyCol&#x3e;keyval&#x3c;/KeyCol&#x3e;</entry>
</row>
<row>
<entry/>
<entry>&#x3c;![CDATA[keyval]]&#x3e;</entry>
<entry>&#x3c;Col1&#x3e;col1val&#x3c;/Col1&#x3e;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="112pt" align="left"/>
<colspec colname="3" colwidth="105pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x2002;&#x3c;/aftervalue&#x3e;</entry>
<entry>&#x3c;/NewMyTableEntry&#x3e;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="28pt" align="left"/>
<colspec colname="2" colwidth="112pt" align="left"/>
<colspec colname="3" colwidth="119pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x3c;/column&#x3e;</entry>
<entry>&#x3c;/NewMyTableEntries&#x3e;</entry>
</row>
<row>
<entry/>
<entry>&#x3c;column name=&#x2033;col1&#x2033; index=&#x2033;1&#x2033;&#x3e;</entry>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x2002;&#x3c;aftervalue&#x3e;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="56pt" align="left"/>
<colspec colname="2" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x3c;![CDATA[col1val]]&#x3e;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x2002;&#x3c;/aftervalue&#x3e;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="28pt" align="left"/>
<colspec colname="2" colwidth="231pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x3c;/column&#x3e;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="14pt" align="left"/>
<colspec colname="2" colwidth="245pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x3c;/operation&#x3e;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="140pt" align="left"/>
<colspec colname="2" colwidth="119pt" align="left"/>
<tbody valign="top">
<row>
<entry>&#x3c;/transaction&#x3e;</entry>
<entry/>
</row>
<row>
<entry>dyntxrule.match=/Transaction</entry>
<entry>stattxrule.match=/NewMyTable-</entry>
</row>
<row>
<entry>dyntxrule.timestamp=@ts</entry>
<entry>Entries</entry>
</row>
<row>
<entry>dyntxrule.subrules=dynoprule</entry>
<entry>stattxrule.subrules= statoprule</entry>
</row>
<row>
<entry>dynoprule.match=./Operation</entry>
<entry>statoprule.match=./NewMyTable-</entry>
</row>
<row>
<entry>dynoprule.schemaandtable=@table</entry>
<entry>Entry</entry>
</row>
<row>
<entry>dynoprule.optype=@type</entry>
<entry>statoprule.schemaandtable=&#x201d;MY.</entry>
</row>
<row>
<entry>dynoprule.subrules=dyncolrule</entry>
<entry>TABLE&#x201d;</entry>
</row>
<row>
<entry>dyncolrule.match=./Column</entry>
<entry>statoprule.optype=&#x201d;I&#x201d;</entry>
</row>
<row>
<entry>dyncolrule.name=@name</entry>
<entry>statoprule.timestamp=./Create-</entry>
</row>
<row>
<entry>dyncolrule.before.value=./beforevalue/</entry>
<entry>Time/text( )</entry>
</row>
<row>
<entry>text( )</entry>
<entry>statoprule.subrules=</entry>
</row>
<row>
<entry>dyncolrule.after.value=./aftervalue/te</entry>
<entry>statkeycolrule,</entry>
</row>
<row>
<entry>xt( )</entry>
<entry/>
</row>
<row>
<entry/>
<entry>&#x2002;statcol1rule</entry>
</row>
<row>
<entry/>
<entry>statkeycolrule.match=/KeyCol</entry>
</row>
<row>
<entry/>
<entry>statkeycolrule.name=&#x201d;keycol&#x201d;</entry>
</row>
<row>
<entry/>
<entry>statkeycolrule.value=./text( )</entry>
</row>
<row>
<entry/>
<entry>statcol1rule.match=/Col1</entry>
</row>
<row>
<entry/>
<entry>statcol1rule.name=&#x201d;col1&#x201d;</entry>
</row>
<row>
<entry/>
<entry>statcol1rule.value=./text( )</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259pt" align="left"/>
<tbody valign="top">
<row>
<entry>INSERT INTO MY.TABLE (KEYCOL, COL1)</entry>
</row>
<row>
<entry>VALUES (&#x2018;keyval&#x2019;, &#x2018;col1val&#x2019;)</entry>
</row>
<row>
<entry>Occurred at 2010-02-05 10:11:21</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
Source Definitions Generation Utility
</p>
<p id="p-0088" num="0146">In accordance with an embodiment, a utility that generates a GoldenGate source definitions file from the properties defined in a properties file can be provided, which reads in the properties file, and outputs a normalized definition of tables, based on property settings and other parser specific data definition values. The usage should be:
<ul id="ul0027" list-style="none">
    <li id="ul0027-0001" num="0000">
    <ul id="ul0028" list-style="none">
        <li id="ul0028-0001" num="0147">{program-name}-prop {property file}[-out{output file}]
<br/>
This will default to outputting the source defs to standard out, but can be directed to a file with the&#x2014;out parameter, e.g.
</li>
        <li id="ul0028-0002" num="0148">{program-name}-prop dirprm/vam.properties-out dirdef/vamdefs.def
<br/>
The output sourcedefs file can then be used in a pump or delivery process to understand the trail data created through the VAM.
<br/>
Installation Prerequisites
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0089" num="0149">In accordance with an embodiment, the Message Capture Adapter requires and/or is intended for use with a build of Oracle GoldenGate version 10.4 or above.</p>
<p id="h-0020" num="0000">Installing the Message Capture</p>
<p id="p-0090" num="0150">In accordance with an embodiment, the Message Capture can be prebuilt and prepackaged for a particular platform (e.g. on windows it is shipped as a zip file; on UNIX, as a &#x201c;tar&#x201d; file). The file should contain: shared library; required Java code; sample VAM properties file(s); and a sample extract parameter file.</p>
<p id="h-0021" num="0000">Configuration&#x2014;Typical GoldenGate Configuration for Message Capture</p>
<p id="p-0091" num="0151">In accordance with an embodiment, a typical GoldenGate Configuration for Message Capture is shown and described above with regard to <figref idref="DRAWINGS">FIG. 2</figref>. In accordance with an embodiment, the message capture VAM can be added to a generic GoldenGate installation using the following commands in GGSCI:</p>
<p id="p-0092" num="0152">
<tables id="TABLE-US-00021" num="00021">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="196pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>add extract &#x3c;extname&#x3e;, VAM</entry>
</row>
<row>
<entry/>
<entry>add extttrail ./dirdat/aa, extract &#x3c;extname&#x3e;, megabytes 100</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
Using the VAM
</p>
<p id="p-0093" num="0153">In accordance with an embodiment, the VAM should be invoked through a standard GoldenGate extract parameter file, for example as shown in Table 3.</p>
<p id="p-0094" num="0154">
<tables id="TABLE-US-00022" num="00022">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="14pt" align="left"/>
<colspec colname="2" colwidth="105pt" align="left"/>
<colspec colname="3" colwidth="98pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="3" rowsep="1">TABLE 3</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>Extract E_JMS</entry>
<entry>Extract name</entry>
</row>
<row>
<entry/>
<entry>VAM libjava5vam.so, PARAMS</entry>
<entry>The location of the Vam</entry>
</row>
<row>
<entry/>
<entry>(dirprm/vam.properties)</entry>
<entry>library is by default</entry>
</row>
<row>
<entry/>
<entry/>
<entry>found in the GG install</entry>
</row>
<row>
<entry/>
<entry/>
<entry>directory. The VAM</entry>
</row>
<row>
<entry/>
<entry/>
<entry>properties file should be</entry>
</row>
<row>
<entry/>
<entry/>
<entry>in &#x2018;dirprm&#x2019;.</entry>
</row>
<row>
<entry/>
<entry>TRANLOGOPTIONS</entry>
<entry>Tells extract that</entry>
</row>
<row>
<entry/>
<entry>VAMCOMPATIBILITY 1</entry>
<entry>metadata will be sent by</entry>
</row>
<row>
<entry/>
<entry>TRANLOGOPTIONS</entry>
<entry>the MsgVam.</entry>
</row>
<row>
<entry/>
<entry>GETMETADATAFROMVAM</entry>
<entry/>
</row>
<row>
<entry/>
<entry>ExtTrail dirdat/aa</entry>
<entry>A target trail. Forward</entry>
</row>
<row>
<entry/>
<entry/>
<entry>slashes (&#x201c;/&#x201d;) work for</entry>
</row>
<row>
<entry/>
<entry/>
<entry>Windows or Unix.</entry>
</row>
<row>
<entry/>
<entry>Table GGS.*;</entry>
<entry>A list of tables to</entry>
</row>
<row>
<entry/>
<entry>Table FOO.*;</entry>
<entry>process; the table name</entry>
</row>
<row>
<entry/>
<entry/>
<entry>can be a wildcard. A</entry>
</row>
<row>
<entry/>
<entry/>
<entry>schema name (e.g., GGS)</entry>
</row>
<row>
<entry/>
<entry/>
<entry>must be specified.</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0095" num="0155">Due to the nature of messaging systems, standard GoldenGate repositioning commands may not be supported. For example, alter e_jms begin now will have no effect on the extract, it will always resume taking messages from the end of the queue.</p>
<p id="h-0022" num="0000">Configuring Message Capture</p>
<p id="p-0096" num="0156">In accordance with an embodiment, the Message Capture reads properties from a properties file specified via the PARAMS parameter within the extract parameter file as shown above. This properties file contains information such as logging settings, parser mappings, and JMS connection settings.</p>
<p id="h-0023" num="0000">Detailed Requirements</p>
<p id="p-0097" num="0157">The following sections detail the various property settings required for the Message Capture VAM. The property settings are split into the following sections: Logging; JMS Connection; and Parsing. Each property specification includes usage description and examples. All properties in the property file are of the form:
<ul id="ul0029" list-style="none">
    <li id="ul0029-0001" num="0000">
    <ul id="ul0030" list-style="none">
        <li id="ul0030-0001" num="0158">fully.qualified.name=value</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0098" num="0159">The value may be a single string, integer, or boolean, or could be comma delimited strings. Comments can be entered in to the properties file with the # prefix at the beginning of the line. For example:</p>
<p id="p-0099" num="0160">
<tables id="TABLE-US-00023" num="00023">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="63pt" align="left"/>
<colspec colname="1" colwidth="154pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry># This is a property comment</entry>
</row>
<row>
<entry/>
<entry>some.property=value</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0100" num="0161">Properties themselves can also be commented, which is useful in testing configurations without losing previous property settings.</p>
<p id="h-0024" num="0000">Logging</p>
<p id="p-0101" num="0162">Logging is standard to many GoldenGate adaptors and is controlled by the following properties. In accordance with an embodiment, for the Messaging Capture and other Java Adaptors, the Java side of the integration can also be configured to produce an additional log file.</p>
<p id="h-0025" num="0000">log.logname</p>
<p id="p-0102" num="0163">Takes any valid ascii string as the prefix to the log file name. The log file produced has the current data appended to it in yyyymmdd format, together with the .log extension.
<ul id="ul0031" list-style="none">
    <li id="ul0031-0001" num="0000">
    <ul id="ul0032" list-style="none">
        <li id="ul0032-0001" num="0164">log.logname={log-prefix}
<br/>
For example:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0103" num="0165">
<tables id="TABLE-US-00024" num="00024">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="70pt" align="left"/>
<colspec colname="1" colwidth="147pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry># log file prefix</entry>
</row>
<row>
<entry/>
<entry>log.logname=msgvam</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
would produce a log file of name msgvam<sub>&#x2014;</sub>20090503.log on May 3, 2009. The log file will roll over each day independent of the starting/stopping of processes. It is possible to include directory names in the name of the log file, e.g. dirrpt/msgvam, but the directories should already exist.
<br/>
log.level
</p>
<p id="p-0104" num="0166">Set the overall log level of the logging module for all modules.
<ul id="ul0033" list-style="none">
    <li id="ul0033-0001" num="0000">
    <ul id="ul0034" list-style="none">
        <li id="ul0034-0001" num="0167">log.level=ERROR|WARN|INFO|DEBUG
<br/>
The log levels are defined as follows:
</li>
        <li id="ul0034-0002" num="0168">ERROR&#x2014;Only write messages if errors occur</li>
        <li id="ul0034-0003" num="0169">WARN&#x2014;Write error and warning messages</li>
        <li id="ul0034-0004" num="0170">INFO&#x2014;Write error, warning and informational messages</li>
        <li id="ul0034-0005" num="0171">DEBUG&#x2014;Write all messages, including debug ones.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0105" num="0172">The default logging level is INFO. The messages in this case will be produced on startup, shutdown and periodically during operation, but would not impede performance of the data path. If the level is switch to DEBUG, large volumes of messages may occur which could impede performance. For example:</p>
<p id="p-0106" num="0173">
<tables id="TABLE-US-00025" num="00025">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="70pt" align="left"/>
<colspec colname="1" colwidth="147pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry># global logging level</entry>
</row>
<row>
<entry/>
<entry>log.level=INFO</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
sets the global logging level to INFO
<br/>
log.tostdout
</p>
<p id="p-0107" num="0174">Determines whether log information should be written to standard out. Useful if the extract process running the VAM is started on the command line, or on operating systems where stdout is piped into the report file.
<ul id="ul0035" list-style="none">
    <li id="ul0035-0001" num="0000">
    <ul id="ul0036" list-style="none">
        <li id="ul0036-0001" num="0175">log.tostdout=true|false
<br/>
The default is false. If true, log output is written to stdout.
<br/>
log.tofile
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0108" num="0176">Determines whether log information should be written to the specified log file.
<ul id="ul0037" list-style="none">
    <li id="ul0037-0001" num="0000">
    <ul id="ul0038" list-style="none">
        <li id="ul0038-0001" num="0177">log.tofile=true|false
<br/>
The default is false. If true, log output is written to the named log file.
<br/>
JMS Connection Properties
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0109" num="0178">In accordance with an embodiment, these specify how to start up the JVM running the JMS integration, and properties for the JMS Connection.</p>
<p id="h-0026" num="0000">jvm.bootoptions</p>
<p id="p-0110" num="0179">This property configures the arguments passed to the internal instance of the JVM:
<ul id="ul0039" list-style="none">
    <li id="ul0039-0001" num="0000">
    <ul id="ul0040" list-style="none">
        <li id="ul0040-0001" num="0180">jvm.bootoptions={JVM option}[, . . . ]</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0111" num="0181">These options should be the same as would be passed to &#x201c;java&#x201d; if this it were executed on the command-line. Options may include: the classpath; system properties; JVM memory options (max memory, initial memory, etc.) that are valid for the particular instance of Java being used. Valid options may vary per JVM version and provider. On Windows, classpath entries must be separated with a semicolon (&#x201c;;&#x201d;). On Linux/UNIX, they must be separated with a colon (&#x201c;:&#x201d;). Additional system properties may be set, such as the Log 4j configuration file. For example:</p>
<p id="p-0112" num="0182">
<tables id="TABLE-US-00026" num="00026">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>jvm.bootoptions=-Djava.class.path=.:dirprm:ggjava/ggjava.jar:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>-Dlog4j.configuration=log4j.properties</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
jms.report.output
</p>
<p id="p-0113" num="0183">Determines where the jms report is written to:
<ul id="ul0041" list-style="none">
    <li id="ul0041-0001" num="0000">
    <ul id="ul0042" list-style="none">
        <li id="ul0042-0001" num="0184">jms.report.output=report|log|both
<br/>
where report will target the JMS report to the OGG report file (default), log will write it to the Java log file (if one is configured) and both will target both locations. For example:
</li>
        <li id="ul0042-0002" num="0185">jms.report.output=both
<br/>
jms.report.time
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0114" num="0186">Determines the frequency of report generation based on time.
<ul id="ul0043" list-style="none">
    <li id="ul0043-0001" num="0000">
    <ul id="ul0044" list-style="none">
        <li id="ul0044-0001" num="0187">jms.report.time={time-specification}
<br/>
For example, to write a report every 6 hours,
</li>
        <li id="ul0044-0002" num="0188">jms.report.time=6 hr
<br/>
jms.report.records
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0115" num="0189">Determines the frequency of report generation based on number of records.
<ul id="ul0045" list-style="none">
    <li id="ul0045-0001" num="0000">
    <ul id="ul0046" list-style="none">
        <li id="ul0046-0001" num="0190">jms.report.records={number}
<br/>
For example, to write a report every 1000 records,
</li>
        <li id="ul0046-0002" num="0191">jms.report.records=1000
<br/>
jms.id
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0116" num="0192">Determines how to create a unique ID passed back from the JMS integration to the Message Capture VAM. This may be used by the VAM as a unique sequence ID for records.
<ul id="ul0047" list-style="none">
    <li id="ul0047-0001" num="0000">
    <ul id="ul0048" list-style="none">
        <li id="ul0048-0001" num="0193">jms.id=ogg|time|wmq|activemq|{message-header}|{custom-java-class}
<br/>
where:
</li>
        <li id="ul0048-0002" num="0194">ogg&#x2014;obtains message header property &#x201c;GG_ID&#x201d; which is set by OGG JMS delivery.</li>
        <li id="ul0048-0003" num="0195">time&#x2014;use a system timestamp as a starting point for message IDs</li>
        <li id="ul0048-0004" num="0196">wmq&#x2014;reformats a WebSphere MQ Message ID for use with the VAM</li>
        <li id="ul0048-0005" num="0197">activemq&#x2014;reformats an ActiveMQ Message ID for use with the VAM</li>
        <li id="ul0048-0006" num="0198">{message-header}&#x2014;can include JMSMessageID, JMSCorrelationID, JMSTimestamp or any other user set custom JMS message header</li>
        <li id="ul0048-0007" num="0199">{custom-java-class)&#x2014;a custom Java class which creates a string to be used as an ID.</li>
    </ul>
    </li>
</ul>
</p>
<heading id="h-0027" level="1">EXAMPLES</heading>
<p id="p-0117" num="0200">
<tables id="TABLE-US-00027" num="00027">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="70pt" align="left"/>
<colspec colname="1" colwidth="147pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>jms.id=JMSMessageID</entry>
</row>
<row>
<entry/>
<entry>jms.id=time</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
The ID returned must be unique, incrementing, and fixed-width. If there are duplicate numbers, the duplicates will be skipped. If the message ID changes length, &#x201c;extract&#x201d; will abend.
<br/>
jms.destination
</p>
<p id="p-0118" num="0201">Determines the queue or topic name to be looked up via JNDI.
<ul id="ul0049" list-style="none">
    <li id="ul0049-0001" num="0000">
    <ul id="ul0050" list-style="none">
        <li id="ul0050-0001" num="0202">jms.destination={jndi-name}
<br/>
For example:
</li>
        <li id="ul0050-0002" num="0203">jms.destination=sampleQ
<br/>
jms.connectionFactory
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0119" num="0204">Determines the connection factory name to be looked up via JNDI.
<ul id="ul0051" list-style="none">
    <li id="ul0051-0001" num="0000">
    <ul id="ul0052" list-style="none">
        <li id="ul0052-0001" num="0205">jms.connectionFactory={jndi-name}
<br/>
For example:
</li>
        <li id="ul0052-0002" num="0206">jms.connectionFactory=ConnectionFactory
<br/>
jms.user, jms.password
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0120" num="0207">Determine the user name and password of the JMS connection itself, as specified by the JMS provider.</p>
<p id="p-0121" num="0208">
<tables id="TABLE-US-00028" num="00028">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="70pt" align="left"/>
<colspec colname="1" colwidth="147pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>jms.user={user-name}</entry>
</row>
<row>
<entry/>
<entry>jms.user={password}</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
This is not used for JNDI security&#x2014;for setting JNDI authentication, the properties &#x201c;java.naming.security.&#x201d; can be used)
<br/>
For example:
</p>
<p id="p-0122" num="0209">
<tables id="TABLE-US-00029" num="00029">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="70pt" align="left"/>
<colspec colname="1" colwidth="147pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>jms.user=myuser</entry>
</row>
<row>
<entry/>
<entry>jms.password=mypasswd</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
JNDI Properties
</p>
<p id="p-0123" num="0210">In accordance with an embodiment, in addition to specific properties for the Message Capture VAM, the JMS integration should also support setting of JNDI properties required to obtain a connection to an Initial Context from which the connection factory and destination can be looked up. The following properties must be set:</p>
<p id="p-0124" num="0211">
<tables id="TABLE-US-00030" num="00030">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="182pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>java.naming.provider.url={url}</entry>
</row>
<row>
<entry/>
<entry>java.naming.factory.initial={java-class-name}</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
and the following may be set if JNDI security is enabled:
</p>
<p id="p-0125" num="0212">
<tables id="TABLE-US-00031" num="00031">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>java.naming.security.principal={user-name}</entry>
</row>
<row>
<entry>java.naming.security.credentials={password-or-other-authenticator}</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
For example:
</p>
<p id="p-0126" num="0213">
<tables id="TABLE-US-00032" num="00032">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>java.naming.provider.url= t3://localhost:7001</entry>
</row>
<row>
<entry/>
<entry>java.naming.factory.initial=weblogic.jndi.WLInitialContextFactory</entry>
</row>
<row>
<entry/>
<entry>java.naming.security.principal=jndiuser</entry>
</row>
<row>
<entry/>
<entry>java.naming.security.credentials=jndipw</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
Parser Properties
</p>
<p id="p-0127" num="0214">In accordance with an embodiment, these specify which parser to use, how the unique record sequence number is obtained, and specific properties of the chosen parser.</p>
<p id="h-0028" num="0000">parser.type</p>
<p id="p-0128" num="0215">Specifies the parser to use:
<ul id="ul0053" list-style="none">
    <li id="ul0053-0001" num="0000">
    <ul id="ul0054" list-style="none">
        <li id="ul0054-0001" num="0216">parser.type=fixed|delim|xml
<br/>
where:
</li>
        <li id="ul0054-0002" num="0217">fixed&#x2014;invokes the fixed width parser</li>
        <li id="ul0054-0003" num="0218">delim&#x2014;invokes the delimited parser</li>
        <li id="ul0054-0004" num="0219">xml&#x2014;invokes the xml parser
<br/>
The remaining properties are parser specific.
<br/>
For example:
</li>
        <li id="ul0054-0005" num="0220">parser. type=delim
<br/>
Fixed Parser Properties
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0129" num="0221">In accordance with an embodiment the following are required properties for parser=fixed.</p>
<p id="h-0029" num="0000">fixed.schema</p>
<p id="p-0130" num="0222">Specifies what kind of file is used by the Message Capture as metadata. The two valid options are sourcedefs and copybook.
<ul id="ul0055" list-style="none">
    <li id="ul0055-0001" num="0000">
    <ul id="ul0056" list-style="none">
        <li id="ul0056-0001" num="0223">fixed.schema=sourcedefs|copybook
<br/>
For example:
</li>
        <li id="ul0056-0002" num="0224">fixed.schema=copybook
<br/>
Other properties will be required to be set, based on the value of this property to determine how to parse the incoming data.
<br/>
fixed.sourcedefs
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0131" num="0225">If the sourcedefs option was specified above, then this property specifies the location of the sourcedefs file to be read in.
<ul id="ul0057" list-style="none">
    <li id="ul0057-0001" num="0000">
    <ul id="ul0058" list-style="none">
        <li id="ul0058-0001" num="0226">fixed.sourcedefs={file-location}
<br/>
For example:
</li>
        <li id="ul0058-0002" num="0227">fixed.sourcedefs=dirdef/hrdemo.def
<br/>
fixed.copybook
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0132" num="0228">Location of the copybook file to be read in by the Message Capture process. To be used if the schema property was set to copybook.
<ul id="ul0059" list-style="none">
    <li id="ul0059-0001" num="0000">
    <ul id="ul0060" list-style="none">
        <li id="ul0060-0001" num="0229">fixed.copybook={file-location}
<br/>
For example:
</li>
        <li id="ul0060-0002" num="0230">fixed.copybook=test_copy_book.cpy
<br/>
fixed.header
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0133" num="0231">Determines the name of the source defs entry or copy book record that contains header information used to determine the data block structure:
<ul id="ul0061" list-style="none">
    <li id="ul0061-0001" num="0000">
    <ul id="ul0062" list-style="none">
        <li id="ul0062-0001" num="0232">fixed.header={record-name}
<br/>
For example:
</li>
        <li id="ul0062-0002" num="0233">fixed.header=HEADER
<br/>
fixed.seqid
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0134" num="0234">Determines the name of the header field, JMS property, or system value that contains the seqid used to uniquely identify individual records. This value must be continually increasing and have the last character be the least significant.
<ul id="ul0063" list-style="none">
    <li id="ul0063-0001" num="0000">
    <ul id="ul0064" list-style="none">
        <li id="ul0064-0001" num="0235">fixed.seqid={field-name}|${jms-property}|*seqid
<br/>
where:
</li>
        <li id="ul0064-0002" num="0236">field-name&#x2014;indicates the name of a header field containing the seqid</li>
        <li id="ul0064-0003" num="0237">jms-property&#x2014;uses the value of the specified JMS header property, a special value of this is $jmsid which uses the value returned by the mechanism chosen by the jms.id property</li>
        <li id="ul0064-0004" num="0238">seqid&#x2014;indicates a simple continually incrementing 64 bit integer generated by the system
<br/>
For example:
</li>
        <li id="ul0064-0005" num="0239">fixed.seqid=$jmsid
<br/>
fixed.timestamp
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0135" num="0240">Determines the name of the field, JMS property, or system value that contains the timestamp.
<ul id="ul0065" list-style="none">
    <li id="ul0065-0001" num="0000">
    <ul id="ul0066" list-style="none">
        <li id="ul0066-0001" num="0241">fixed.timestamp={field-name}|${jms-property}|*ts
<br/>
For example:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0136" num="0242">
<tables id="TABLE-US-00033" num="00033">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>fixed.timestamp=TIMESTAMP</entry>
</row>
<row>
<entry/>
<entry>fixed.timestamp=$JMSTimeStamp</entry>
</row>
<row>
<entry/>
<entry>fixed.timestamp=*ts</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
fixed.timestamp.format
</p>
<p id="p-0137" num="0243">Determines the format of the timestamp field.
<ul id="ul0067" list-style="none">
    <li id="ul0067-0001" num="0000">
    <ul id="ul0068" list-style="none">
        <li id="ul0068-0001" num="0244">fixed.timestamp.format={format}
<br/>
where the format can include punctuation characters plus:
</li>
        <li id="ul0068-0002" num="0245">YYYY&#x2014;four digit year</li>
        <li id="ul0068-0003" num="0246">YY&#x2014;two digit year</li>
        <li id="ul0068-0004" num="0247">M[M]&#x2014;one or two digit month</li>
        <li id="ul0068-0005" num="0248">D[D]&#x2014;one or two digit day</li>
        <li id="ul0068-0006" num="0249">HH&#x2014;hours in twenty four hour notation</li>
        <li id="ul0068-0007" num="0250">MI&#x2014;minutes</li>
        <li id="ul0068-0008" num="0251">SS&#x2014;seconds</li>
        <li id="ul0068-0009" num="0252">F<sup>n</sup>&#x2014;n number of fractions
<br/>
The default format is &#x201c;YYYY-MM-DD:HH:MI:SS.FFF&#x201d;
<br/>
For example:
</li>
        <li id="ul0068-0010" num="0253">fixed.timestamp.format=YYYY-MM-DD-HH.MI.SS
<br/>
fixed.txid
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0138" num="0254">Determines the name of the field, JMS property, or system value that contains the txid used to unique identify transactions. This value must be continually increasing for each transaction.
<ul id="ul0069" list-style="none">
    <li id="ul0069-0001" num="0000">
    <ul id="ul0070" list-style="none">
        <li id="ul0070-0001" num="0255">fixed.txid={field-name}|${jms-property}|*txid
<br/>
For most cases using the system value of *txid is preferred. For example:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0139" num="0256">
<tables id="TABLE-US-00034" num="00034">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="70pt" align="left"/>
<colspec colname="1" colwidth="147pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>fixed.txid=$JMSTxId</entry>
</row>
<row>
<entry/>
<entry>fixed.txid=*txid</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
fixed.txowner
</p>
<p id="p-0140" num="0257">Optionally, determines the name of the field, JMS property, or static value that contains an arbitrary user name associated with a transaction. This value may be used to exclude certain transactions from processing
<ul id="ul0071" list-style="none">
    <li id="ul0071-0001" num="0000">
    <ul id="ul0072" list-style="none">
        <li id="ul0072-0001" num="0258">fixed.txowner={field-name}|${jms-property}|&#x201c;{value}&#x201d;
<br/>
For example:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0141" num="0259">
<tables id="TABLE-US-00035" num="00035">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>fixed.txowner=$MessageOwner</entry>
</row>
<row>
<entry/>
<entry>fixed.txowner=&#x201d;jsmith&#x201d;</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
fixed.txname
</p>
<p id="p-0142" num="0260">Optionally, determines the name of the field, JMS property, or static value that contains an arbitrary name to be associated with a transaction
<ul id="ul0073" list-style="none">
    <li id="ul0073-0001" num="0000">
    <ul id="ul0074" list-style="none">
        <li id="ul0074-0001" num="0261">fixed.txname={field-name}|${jms-property}|&#x201c;value&#x201d;
<br/>
For example:
</li>
        <li id="ul0074-0002" num="0262">fixed.txname=&#x201c;fixedtx&#x201d;
<br/>
fixed.optype
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0143" num="0263">Determines the name of the field, or JMS property that contains the operation type, which is validated against the op type values specified in the next sections.
<ul id="ul0075" list-style="none">
    <li id="ul0075-0001" num="0000">
    <ul id="ul0076" list-style="none">
        <li id="ul0076-0001" num="0264">fixed.header.optype={field-name}|${jms-property}
<br/>
For example:
</li>
        <li id="ul0076-0002" num="0265">fixed.header.optype=FUNCTION
<br/>
fixed.optype.insertval
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0144" num="0266">The value to look for to identify an operation as an Insert type operation. The default is &#x2018;I&#x2019;.
<ul id="ul0077" list-style="none">
    <li id="ul0077-0001" num="0000">
    <ul id="ul0078" list-style="none">
        <li id="ul0078-0001" num="0267">fixed.optype.insertval={value}|\x{hex-value}
<br/>
For example:
</li>
        <li id="ul0078-0002" num="0268">fixed.optype.insertval=A
<br/>
fixed.optype.updateval
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0145" num="0269">The value to look for to identify an operation as an Update type operation. The default is &#x2018;U&#x2019;.
<ul id="ul0079" list-style="none">
    <li id="ul0079-0001" num="0000">
    <ul id="ul0080" list-style="none">
        <li id="ul0080-0001" num="0270">fixed.optype.updateval={value}|\x{hex-value}
<br/>
For example:
</li>
        <li id="ul0080-0002" num="0271">fixed.optype.updateval=M
<br/>
fixed.optype.deleteval
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0146" num="0272">The value to look for to identify an operation as a Delete type operation. The default is &#x2018;D&#x2019;.
<ul id="ul0081" list-style="none">
    <li id="ul0081-0001" num="0000">
    <ul id="ul0082" list-style="none">
        <li id="ul0082-0001" num="0273">fixed.optype.deleteval={value}|\x{hex-value}
<br/>
For example:
</li>
        <li id="ul0082-0002" num="0274">fixed.optype.deleteval=R
<br/>
fixed.table
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0147" num="0275">Determines the name of the table, which enables the parser to look up the corresponding data record definition needed to translate the portion of the data remaining after the header.
<ul id="ul0083" list-style="none">
    <li id="ul0083-0001" num="0000">
    <ul id="ul0084" list-style="none">
        <li id="ul0084-0001" num="0276">fixed.table={field-name}|${jms-property}[, . . . ]</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0148" num="0277">More than one comma delimited field name may be used to determine the name of the table Each field name corresponds to a field in the header record defined by the fixed.header property, or JMS property. The values of these fields are concatenated together to identify the data record. For example:</p>
<p id="p-0149" num="0278">
<tables id="TABLE-US-00036" num="00036">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="196pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>fixed.table=$JMSTableName</entry>
</row>
<row>
<entry/>
<entry>fixed.table=SOURCE_Db,SOURCE_Db_Rec_Version</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
fixed.schema
</p>
<p id="p-0150" num="0279">Determines the static name of the schema when generating table names SCHEMA.TABLE.
<ul id="ul0085" list-style="none">
    <li id="ul0085-0001" num="0000">
    <ul id="ul0086" list-style="none">
        <li id="ul0086-0001" num="0280">fixed.schema=&#x201c;{value}&#x201d;
<br/>
For example:
</li>
        <li id="ul0086-0002" num="0281">fixed.schema=&#x201c;OGG&#x201d;
<br/>
fixed.txind
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0151" num="0282">Optionally determines the name of the field, or JMS property that contains a transaction indicator, which is validated against the transaction indicator values. If not defined all operations within a single message will be seen to have occurred within a whole transaction. If defined, then will determine the beginning, middle and end of transactions. Transactions defined in this way can span messages.
<ul id="ul0087" list-style="none">
    <li id="ul0087-0001" num="0000">
    <ul id="ul0088" list-style="none">
        <li id="ul0088-0001" num="0283">fixed.txind={field-name}|${jms-property}
<br/>
For example:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0152" num="0284">fixed.txind=$TX_IND</p>
<p id="h-0030" num="0000">fixed.txind.beginval</p>
<p id="p-0153" num="0285">The value to look for to identify an operation as the beginning of a transaction. Defaults to &#x2018;B&#x2019;.
<ul id="ul0089" list-style="none">
    <li id="ul0089-0001" num="0000">
    <ul id="ul0090" list-style="none">
        <li id="ul0090-0001" num="0286">fixed.txind.beginval={value}|\x{hex-value}
<br/>
For example:
</li>
        <li id="ul0090-0002" num="0287">fixed.txind.beginval=0
<br/>
fixed.txind.middleval
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0154" num="0288">The value to look for to identify an operation as the middle of a transaction. Defaults to &#x2018;M&#x2019;.
<ul id="ul0091" list-style="none">
    <li id="ul0091-0001" num="0000">
    <ul id="ul0092" list-style="none">
        <li id="ul0092-0001" num="0289">fixed.txind.middleval={value}|\x{hex-value}
<br/>
For example:
</li>
        <li id="ul0092-0002" num="0290">fixed.txind.middleval=1
<br/>
fixed.txind.endval
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0155" num="0291">The value to look for to identify an operation as the end of a transaction. Defaults to &#x2018;E&#x2019;.
<ul id="ul0093" list-style="none">
    <li id="ul0093-0001" num="0000">
    <ul id="ul0094" list-style="none">
        <li id="ul0094-0001" num="0292">fixed.txind.endval={value}|\x{hex-value}
<br/>
For example:
</li>
        <li id="ul0094-0002" num="0293">fixed.txind.endval=2
<br/>
fixed.txind.wholeval
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0156" num="0294">The value to look for to identify an operation as a whole transaction. Defaults to &#x2018;W&#x2019;.
<ul id="ul0095" list-style="none">
    <li id="ul0095-0001" num="0000">
    <ul id="ul0096" list-style="none">
        <li id="ul0096-0001" num="0295">fixed.txind.wholeval={value}|\x{hex-value}
<br/>
For example:
</li>
        <li id="ul0096-0002" num="0296">fixed. txind.wholeval=3
<br/>
Delimited Parser Properties
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0157" num="0297">In accordance with an embodiment the following are required properties for parser=delim.</p>
<p id="h-0031" num="0000">delim.sourcedefs</p>
<p id="p-0158" num="0298">Specifies the location of the sourcedefs file to be read in.
<ul id="ul0097" list-style="none">
    <li id="ul0097-0001" num="0000">
    <ul id="ul0098" list-style="none">
        <li id="ul0098-0001" num="0299">delim.sourcedefs={file-location}
<br/>
For example:
</li>
        <li id="ul0098-0002" num="0300">delim.sourcedefs=dirdef/hrdemo.def
<br/>
delim.header
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0159" num="0301">Determines the list of values to be read before encountering the data and assigns names to each value.
<ul id="ul0099" list-style="none">
    <li id="ul0099-0001" num="0000">
    <ul id="ul0100" list-style="none">
        <li id="ul0100-0001" num="0302">delim.header={name}, [ . . . ]
<br/>
The names used should be unique and can be referenced in other delim properties by wherever header fields can be used. For example:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0160" num="0303">
<tables id="TABLE-US-00037" num="00037">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>delim.header=optype, tablename, ts</entry>
</row>
<row>
<entry/>
<entry>delim.timestamp=ts</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
delim.seqid
</p>
<p id="p-0161" num="0304">Determines the name of the header field, JMS property, or system value that contains the seqid used to uniquely identify individual records. This value must be continually increasing and have the last character be the least significant.
<ul id="ul0101" list-style="none">
    <li id="ul0101-0001" num="0000">
    <ul id="ul0102" list-style="none">
        <li id="ul0102-0001" num="0305">delim.seqid={field-name}|${jms-property}|*seqid
<br/>
where:
</li>
        <li id="ul0102-0002" num="0306">field-name&#x2014;indicates the name of a header field containing the seqid</li>
        <li id="ul0102-0003" num="0307">jms-property&#x2014;uses the value of the specified JMS header property, a special value of this is $jmsid which uses the value returned by the mechanism chosen by the jms.id property</li>
        <li id="ul0102-0004" num="0308">seqid&#x2014;indicates a simple continually incrementing 64 bit integer generated by the system
<br/>
For example:
</li>
        <li id="ul0102-0005" num="0309">delim.seqid=$jmsid
<br/>
delim.timestamp
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0162" num="0310">Determines the name of the JMS property, header field, or system value that contains the timestamp.
<ul id="ul0103" list-style="none">
    <li id="ul0103-0001" num="0000">
    <ul id="ul0104" list-style="none">
        <li id="ul0104-0001" num="0311">delim.timestamp={field-name}|${jms-property}|*ts
<br/>
For example:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0163" num="0312">
<tables id="TABLE-US-00038" num="00038">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>delim.timestamp=TIMESTAMP</entry>
</row>
<row>
<entry/>
<entry>delim.timestamp=$JMSTimeStamp</entry>
</row>
<row>
<entry/>
<entry>delim.timestamp=*ts</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
delim.timestamp.format
</p>
<p id="p-0164" num="0313">Determines the format of the timestamp field.
<ul id="ul0105" list-style="none">
    <li id="ul0105-0001" num="0000">
    <ul id="ul0106" list-style="none">
        <li id="ul0106-0001" num="0314">delim.timestamp.format={format}
<br/>
where the format can include punctuation characters plus:
</li>
        <li id="ul0106-0002" num="0315">YYYY&#x2014;four digit year</li>
        <li id="ul0106-0003" num="0316">YY&#x2014;two digit year</li>
        <li id="ul0106-0004" num="0317">M[M]&#x2014;one or two digit month</li>
        <li id="ul0106-0005" num="0318">D[D]&#x2014;one or two digit day</li>
        <li id="ul0106-0006" num="0319">HH&#x2014;hours in twenty four hour notation</li>
        <li id="ul0106-0007" num="0320">MI&#x2014;minutes</li>
        <li id="ul0106-0008" num="0321">SS&#x2014;seconds</li>
        <li id="ul0106-0009" num="0322">F<sup>n</sup>&#x2014;n number of fractions
<br/>
The default format is &#x201c;YYYY-MM-DD:HH:MI:SS.FFF&#x201d; For example:
</li>
        <li id="ul0106-0010" num="0323">delim.timestamp.format=YYYY-MM-DD-HH.MI.SS
<br/>
delim.txid
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0165" num="0324">Determines the name of the JMS property, header field, or system value that contains the txid used to unique identify transactions. This value must be continually increasing for each transaction.
<ul id="ul0107" list-style="none">
    <li id="ul0107-0001" num="0000">
    <ul id="ul0108" list-style="none">
        <li id="ul0108-0001" num="0325">delim.txid={field-name}|${jms-property}|*txid
<br/>
For most cases using the system value of *txid is preferred. For example:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0166" num="0326">
<tables id="TABLE-US-00039" num="00039">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="70pt" align="left"/>
<colspec colname="1" colwidth="147pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>delim.txid=$JMSTxId</entry>
</row>
<row>
<entry/>
<entry>delim.txid=*txid</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
delim.txowner
</p>
<p id="p-0167" num="0327">Optionally, determines the name of the JMS property, header field, or static value that contains an arbitrary user name associated with a transaction. This value may be used to exclude certain transactions from processing
<ul id="ul0109" list-style="none">
    <li id="ul0109-0001" num="0000">
    <ul id="ul0110" list-style="none">
        <li id="ul0110-0001" num="0328">delim.txowner={field-name}|${jms-property}|&#x201c;{value}&#x201d;
<br/>
For example:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0168" num="0329">
<tables id="TABLE-US-00040" num="00040">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>delim.txowner=$MessageOwner</entry>
</row>
<row>
<entry/>
<entry>delim.txowner=&#x201d;jsmith&#x201d;</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
delim.txname
</p>
<p id="p-0169" num="0330">Optionally, determines the name of the JMS property, header field, or static value that contains an arbitrary name to be associated with a transaction
<ul id="ul0111" list-style="none">
    <li id="ul0111-0001" num="0000">
    <ul id="ul0112" list-style="none">
        <li id="ul0112-0001" num="0331">delim.txname={field-name}|${jms-property}|&#x201c;value&#x201d;
<br/>
For example:
</li>
        <li id="ul0112-0002" num="0332">delim.txname=&#x201c;fixedtx&#x201d;
<br/>
delim.optype
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0170" num="0333">Determines the name of the JMS property, or header field, that contains the optype to be validated against an optype insertval, etc.
<ul id="ul0113" list-style="none">
    <li id="ul0113-0001" num="0000">
    <ul id="ul0114" list-style="none">
        <li id="ul0114-0001" num="0334">delim.optype={field-name}|${jms-property}
<br/>
For example:
</li>
        <li id="ul0114-0002" num="0335">delim.optype=optype
<br/>
delim.optype.insertval
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0171" num="0336">The value to look for to identify an operation as an Insert type operation. The default is &#x2018;I&#x2019;.
<ul id="ul0115" list-style="none">
    <li id="ul0115-0001" num="0000">
    <ul id="ul0116" list-style="none">
        <li id="ul0116-0001" num="0337">delim.optype.insertval={value}|\x{hex-value}
<br/>
For example:
</li>
        <li id="ul0116-0002" num="0338">delim.optype.insertval=A
<br/>
delim.optype.updateval
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0172" num="0339">The value to look for to identify an operation as an Update type operation. The default is &#x2018;U&#x2019;.
<ul id="ul0117" list-style="none">
    <li id="ul0117-0001" num="0000">
    <ul id="ul0118" list-style="none">
        <li id="ul0118-0001" num="0340">delim.optype.updateval={value}|\x{hex-value}
<br/>
For example:
</li>
        <li id="ul0118-0002" num="0341">delim.optype.updateval=M
<br/>
delim.optype.deleteval
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0173" num="0342">The value to look for to identify an operation as a Delete type operation. The default is &#x2018;D&#x2019;.
<ul id="ul0119" list-style="none">
    <li id="ul0119-0001" num="0000">
    <ul id="ul0120" list-style="none">
        <li id="ul0120-0001" num="0343">delim.optype.deleteval={value}|\x{hex-value}
<br/>
For example:
</li>
        <li id="ul0120-0002" num="0344">delim.optype.deleteval=R
<br/>
delim.schemaandtable
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0174" num="0345">Determines the name of the JMS property, or header field that contains the schema and table name in the form SCHEMA.TABLE.
<ul id="ul0121" list-style="none">
    <li id="ul0121-0001" num="0000">
    <ul id="ul0122" list-style="none">
        <li id="ul0122-0001" num="0346">delim.schemaandtable={field-name}|${jms-property}
<br/>
For example:
</li>
        <li id="ul0122-0002" num="0347">delim.schemaandtable=$FullTableName
<br/>
delim.schema
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0175" num="0348">Determines the name of the JMS property, header field, or hard-coded value that contains the schema name.
<ul id="ul0123" list-style="none">
    <li id="ul0123-0001" num="0000">
    <ul id="ul0124" list-style="none">
        <li id="ul0124-0001" num="0349">delim.schema={field-name}|${jms-property}|&#x201c;value&#x201d;
<br/>
For example:
</li>
        <li id="ul0124-0002" num="0350">delim.schema=&#x201c;OGG&#x201d;
<br/>
delim.table
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0176" num="0351">Determines the name of the JMS property, or header field that contains the table name.
<ul id="ul0125" list-style="none">
    <li id="ul0125-0001" num="0000">
    <ul id="ul0126" list-style="none">
        <li id="ul0126-0001" num="0352">delim.table={field-name}|${jms-property}
<br/>
For example:
</li>
        <li id="ul0126-0002" num="0353">delim.table=TABLE_NAME
<br/>
delim.txind
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0177" num="0354">Optionally determines the name of the JMS property, or header field that contains the transaction indicator to be validated against beginval etc. If not defined all operations within a single message will be seen to have occurred within a whole transaction. If defined, then will determine the beginning, middle and end of transactions. Transactions defined in this way can span messages.
<ul id="ul0127" list-style="none">
    <li id="ul0127-0001" num="0000">
    <ul id="ul0128" list-style="none">
        <li id="ul0128-0001" num="0355">delim.txind={field-name}|${jms-property}
<br/>
For example:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0178" num="0356">delim.txind=txind
<ul id="ul0129" list-style="none">
    <li id="ul0129-0001" num="0000">
    <ul id="ul0130" list-style="none">
        <li id="ul0130-0001" num="0357">delim.txind.beginval</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0179" num="0358">The value to look for to identify an operation as the beginning of a transaction. Defaults to &#x2018;B&#x2019;.
<ul id="ul0131" list-style="none">
    <li id="ul0131-0001" num="0000">
    <ul id="ul0132" list-style="none">
        <li id="ul0132-0001" num="0359">delim.txind.beginval={value}|\x{hex-value}
<br/>
For example:
</li>
        <li id="ul0132-0002" num="0360">delim.txind.beginval=0
<br/>
delim.txind.middleval
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0180" num="0361">The value to look for to identify an operation as the middle of a transaction. Defaults to &#x2018;M&#x2019;.
<ul id="ul0133" list-style="none">
    <li id="ul0133-0001" num="0000">
    <ul id="ul0134" list-style="none">
        <li id="ul0134-0001" num="0362">delim.txind.middleval={value}|\x{hex-value}
<br/>
For example:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0181" num="0363">delim.txind.middleval=1</p>
<p id="h-0032" num="0000">delim.txind.endval</p>
<p id="p-0182" num="0364">The value to look for to identify an operation as the end of a transaction. Defaults to &#x2018;E&#x2019;.
<ul id="ul0135" list-style="none">
    <li id="ul0135-0001" num="0000">
    <ul id="ul0136" list-style="none">
        <li id="ul0136-0001" num="0365">delim.txind.endval={value}|\x{hex-value}
<br/>
For example:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0183" num="0366">delim.txind.endval=2</p>
<p id="h-0033" num="0000">delim.txind.wholeval</p>
<p id="p-0184" num="0367">The value to look for to identify an operation as a whole transaction. Defaults to &#x2018;W&#x2019;.
<ul id="ul0137" list-style="none">
    <li id="ul0137-0001" num="0000">
    <ul id="ul0138" list-style="none">
        <li id="ul0138-0001" num="0368">delim.txind.wholeval={value}|\x{hex-value}
<br/>
For example:
</li>
        <li id="ul0138-0002" num="0369">delim.txind.wholeval=3
<br/>
delim.fielddelim
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0185" num="0370">Determines the delimiter value to be used to separate fields (columns) in the data. Can be defined through characters or hex values:
<ul id="ul0139" list-style="none">
    <li id="ul0139-0001" num="0000">
    <ul id="ul0140" list-style="none">
        <li id="ul0140-0001" num="0371">delim.fielddelim={value}|\x{hex-value}
<br/>
For example:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0186" num="0372">
<tables id="TABLE-US-00041" num="00041">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="70pt" align="left"/>
<colspec colname="1" colwidth="147pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>delim.fielddelim=,</entry>
</row>
<row>
<entry/>
<entry>delim.fielddelim=\xc7</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
delim.linedelim
</p>
<p id="p-0187" num="0373">Determines the delimiter value to be used to separate lines (records) in the data. Can be defined through characters or hex values:
<ul id="ul0141" list-style="none">
    <li id="ul0141-0001" num="0000">
    <ul id="ul0142" list-style="none">
        <li id="ul0142-0001" num="0374">delim.linedelim={value}|\x{hex-value}
<br/>
For example:
</li>
        <li id="ul0142-0002" num="0375">delim.linedelim=&#x2225;</li>
        <li id="ul0142-0003" num="0376">delim.linedelim=\x0a
<br/>
delim.quote
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0188" num="0377">Determines the value to be used to identify quoted data, Can be defined through characters or hex values:
<ul id="ul0143" list-style="none">
    <li id="ul0143-0001" num="0000">
    <ul id="ul0144" list-style="none">
        <li id="ul0144-0001" num="0378">delim.quote={value}|\x{hex-value}
<br/>
For example:
</li>
        <li id="ul0144-0002" num="0379">delim.quote=&#x201d;
<br/>
delim.nullindicator
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0189" num="0380">Determines the value to be used to identify NULL data, Can be defined through characters or hex values:
<ul id="ul0145" list-style="none">
    <li id="ul0145-0001" num="0000">
    <ul id="ul0146" list-style="none">
        <li id="ul0146-0001" num="0381">delim.nullindicator={value}|\x{hex-value}
<br/>
For example:
</li>
        <li id="ul0146-0002" num="0382">delim.nullindicator=NULL
<br/>
delim.fielddelim.escaped
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0190" num="0383">Determines the value to look for that indicates a true field delimiter is present in some data. This will then be replaced with the fielddelim value.
<ul id="ul0147" list-style="none">
    <li id="ul0147-0001" num="0000">
    <ul id="ul0148" list-style="none">
        <li id="ul0148-0001" num="0384">delim.fielddelim.escaped={value}|\x{hex-value}
<br/>
For example:
</li>
        <li id="ul0148-0002" num="0385">delim.fielddelim.escaped=$,$
<br/>
delim.linedelim.escaped
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0191" num="0386">Determines the value to look for that indicates a true line delimiter is present in some data. This will then be replaced with the linedelim value.
<ul id="ul0149" list-style="none">
    <li id="ul0149-0001" num="0000">
    <ul id="ul0150" list-style="none">
        <li id="ul0150-0001" num="0387">delim.linedelim.escaped={value}|\x{hex-value}
<br/>
For example:
</li>
        <li id="ul0150-0002" num="0388">delim.linedelim.escaped=\x0affa0
<br/>
delim.quote.escaped
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0192" num="0389">Determines the value to look for that indicates a true quote is present in some data. This will then be replaced with the quote value.
<ul id="ul0151" list-style="none">
    <li id="ul0151-0001" num="0000">
    <ul id="ul0152" list-style="none">
        <li id="ul0152-0001" num="0390">delim.quote.escaped={value}|\x{hex-value}
<br/>
For example:
</li>
        <li id="ul0152-0002" num="0391">delim.quote.escaped=&#x201c;&#x201c;
<br/>
delim.nullindicator.escaped
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0193" num="0392">Determines the value to look for that indicates a true null indicator is present in some data. This will then be replaced with the nullindicator value.
<ul id="ul0153" list-style="none">
    <li id="ul0153-0001" num="0000">
    <ul id="ul0154" list-style="none">
        <li id="ul0154-0001" num="0393">delim.nullindicator.escaped={value}|\x{hex-value}
<br/>
For example:
</li>
        <li id="ul0154-0002" num="0394">delim.nullindicator.escaped={NULL}
<br/>
delim.hasbefores
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0194" num="0395">Determines whether before values are present in the data.
<ul id="ul0155" list-style="none">
    <li id="ul0155-0001" num="0000">
    <ul id="ul0156" list-style="none">
        <li id="ul0156-0001" num="0396">delim.hasbefores=true|false
<br/>
Defaults to false. If true, the parser will expect to find before and after values of columns for all records. The before values will then be used for updates and deletes, the after values for updates and inserts. The &#x2018;afterfirst&#x2019; property determines whether the before images should be expected before the after images or after them. If false, then no before values will be expected. For example:
</li>
        <li id="ul0156-0002" num="0397">delim.hasbefores=true
<br/>
delim.hasnames
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0195" num="0398">Determines whether column names are present in the data.
<ul id="ul0157" list-style="none">
    <li id="ul0157-0001" num="0000">
    <ul id="ul0158" list-style="none">
        <li id="ul0158-0001" num="0399">delim.hasnames=true|false
<br/>
Defaults to false. If true, the parser will expect to find column names for all records. The parser will validate the column names against the expected column names. If false, then no column names will be expected. For example:
</li>
        <li id="ul0158-0002" num="0400">delim.hasnames=true
<br/>
delim.afterfirst
<br/>
Determines whether the after values should be expected before or after the before values.
</li>
        <li id="ul0158-0003" num="0401">delim.afterfirst=true|false
<br/>
Defaults to false. If true, the parser will expect to find the after values before the before values. If false, then the after values will be expected before the before values. For example:
</li>
        <li id="ul0158-0004" num="0402">delim.afterfirst=true
<br/>
delim.isgrouped
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0196" num="0403">Determines whether the column names, before and after images should be expected grouped together for all columns or interleaved for each column.
<ul id="ul0159" list-style="none">
    <li id="ul0159-0001" num="0000">
    <ul id="ul0160" list-style="none">
        <li id="ul0160-0001" num="0404">delim.isgrouped=true|false
<br/>
Defaults to false. If true, the parser will expect find a group of columns names first (if hasnames is true) followed by a group of before values (if hasbefores), followed by a group of after values (the afterfirst setting will reverse the before and after value order). If false, the parser will expect to find a column name (if hasnames), before value (if hasbefores) and after value for each column. For example:
</li>
        <li id="ul0160-0002" num="0405">delim.isgrouped=true
<br/>
delim.dateformat
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0197" num="0406">Determines the date format for column data. Should be able to parse using similar format strings to parser.timestamp.format. This should be able to be specified at a global level, a table level or column level.</p>
<p id="p-0198" num="0407">
<tables id="TABLE-US-00042" num="00042">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>delim.dateformat={format}</entry>
</row>
<row>
<entry/>
<entry>delim.dateformat.{TABLE}={format}</entry>
</row>
<row>
<entry/>
<entry>delim.dateformat.{TABLE}.{COLUMN}={format}</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
where:
<ul id="ul0161" list-style="none">
    <li id="ul0161-0001" num="0000">
    <ul id="ul0162" list-style="none">
        <li id="ul0162-0001" num="0408">{format} is as defined for parser.timestamp.format</li>
        <li id="ul0162-0002" num="0409">{TABLE} is a fully qualified table name</li>
        <li id="ul0162-0003" num="0410">{COLUMN} is a column of the specified table.
<br/>
For example:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0199" num="0411">
<tables id="TABLE-US-00043" num="00043">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="196pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>delim.dateformat=YYYY-MM-DD HH:MI:SS</entry>
</row>
<row>
<entry/>
<entry>delim.dateformat.MY.TABLE=DD/MM/YY-HH.MI.SS</entry>
</row>
<row>
<entry/>
<entry>delim.dateformat.MY.TABLE.EXP_DATE=YYMM</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
XML Parser Properties
<br/>
xml.sourcedefs
</p>
<p id="p-0200" num="0412">Specifies the location of the sourcedefs file to be read in.
<ul id="ul0163" list-style="none">
    <li id="ul0163-0001" num="0000">
    <ul id="ul0164" list-style="none">
        <li id="ul0164-0001" num="0413">xml.sourcedefs={file-location}
<br/>
For example:
</li>
        <li id="ul0164-0002" num="0414">xml.sourcedefs=dirdef/hrdemo.def
<br/>
xml.rules
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0201" num="0415">Determines the list of XML rules to be used for parsing a message and converting to transactions, operations and columns:
<ul id="ul0165" list-style="none">
    <li id="ul0165-0001" num="0000">
    <ul id="ul0166" list-style="none">
        <li id="ul0166-0001" num="0416">xml.rules={xml-rule-name}[, . . . ]
<br/>
The specified XML rules will be processed in the order listed. All rules matching a particular XML document may result in the creation of transactions, operations and columns. The specified XML rules should be transaction or operation type rules. For example:
</li>
        <li id="ul0166-0002" num="0417">xml.rules=dyntxrule, statoprule
<br/>
{rulename}.type
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0202" num="0418">Determines the type of an XML rule:
<ul id="ul0167" list-style="none">
    <li id="ul0167-0001" num="0000">
    <ul id="ul0168" list-style="none">
        <li id="ul0168-0001" num="0419">{rulename}.type=tx|op|col
<br/>
where:
</li>
        <li id="ul0168-0002" num="0420">tx&#x2014;indicates a transaction rule</li>
        <li id="ul0168-0003" num="0421">op&#x2014;indicates an operation rule</li>
        <li id="ul0168-0004" num="0422">col&#x2014;indicates a column rule
<br/>
For example:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0203" num="0423">
<tables id="TABLE-US-00044" num="00044">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="77pt" align="left"/>
<colspec colname="1" colwidth="140pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>dyntxrule.type=tx</entry>
</row>
<row>
<entry/>
<entry>statoprule.type=op</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
{rulename}.match
</p>
<p id="p-0204" num="0424">Specifies an XPath expression used to determine whether the rule is activated for a particular document or not:
<ul id="ul0169" list-style="none">
    <li id="ul0169-0001" num="0000">
    <ul id="ul0170" list-style="none">
        <li id="ul0170-0001" num="0425">{rulename}.match={xpath-expression}
<br/>
If the XPath expression returns any nodes from the document, the rule has been match and further processing occurs. If it does not return any nodes, the rule is ignored for that particular document.
<br/>
For example:
</li>
        <li id="ul0170-0002" num="0426">dyntxrule.match=/Transaction
<br/>
will activate the dyntxrule if the document has a root element of Transaction
</li>
        <li id="ul0170-0003" num="0427">statoprule.match=./NewMyTableEntry
<br/>
where statoprule is a subrule of stattxtule, will activate the statoprule if the parent rules matching nodes have child elements of NewMyTableEntry
<br/>
{rulename}.subrules
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0205" num="0428">Specifies a list of rule names that should be check for matches if the parent rule is activated by its match.
<ul id="ul0171" list-style="none">
    <li id="ul0171-0001" num="0000">
    <ul id="ul0172" list-style="none">
        <li id="ul0172-0001" num="0429">{rulename}.subrules={xml-rule-name}[, . . . ]
<br/>
The specified XML rules will be processed in the order listed. All matching rules may result in the creation of transactions, operations and columns. The valid subrules will be determined by the parent type. Transaction rules can only have operation subrules. Operation rules can have operation or column subrules. Column rules cannot have subrules. For example:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0206" num="0430">
<tables id="TABLE-US-00045" num="00045">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="182pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>dyntxrule.subrules=dynoprule</entry>
</row>
<row>
<entry/>
<entry>statoprule.subrules=statkeycolrule, statcol1rule</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
{txrule}.timestamp
</p>
<p id="p-0207" num="0431">Optionally determines the XPath expression or JMS property that contains the transaction commit timestamp, or to use the current system time.
<ul id="ul0173" list-style="none">
    <li id="ul0173-0001" num="0000">
    <ul id="ul0174" list-style="none">
        <li id="ul0174-0001" num="0432">{txrule}.timestamp={xpath-expression}|${jms-property}|*ts
<br/>
The timestamp for the transaction may be overridden at the operation level, or may only be present at the operation level. Any XPath expression must end with a value accessor such as @att of text( ).
<br/>
For example:
</li>
        <li id="ul0174-0002" num="0433">dyntxrule.timestamp=@ts
<br/>
{txrule}.timestamp.format
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0208" num="0434">Determines the format of the timestamp field.
<ul id="ul0175" list-style="none">
    <li id="ul0175-0001" num="0000">
    <ul id="ul0176" list-style="none">
        <li id="ul0176-0001" num="0435">{txrule}.timestamp.format={format}
<br/>
where the format can include punctuation characters plus:
</li>
        <li id="ul0176-0002" num="0436">YYYY&#x2014;four digit year</li>
        <li id="ul0176-0003" num="0437">YY&#x2014;two digit year</li>
        <li id="ul0176-0004" num="0438">M[M]&#x2014;one or two digit month</li>
        <li id="ul0176-0005" num="0439">D[D]&#x2014;one or two digit day</li>
        <li id="ul0176-0006" num="0440">HH&#x2014;hours in twenty four hour notation</li>
        <li id="ul0176-0007" num="0441">MI&#x2014;minutes</li>
        <li id="ul0176-0008" num="0442">SS&#x2014;seconds</li>
        <li id="ul0176-0009" num="0443">F<sup>n</sup>&#x2014;n number of fractions
<br/>
The default format is &#x201c;YYYY-MM-DD:HH:MI:SS.FFF&#x201d; For example:
</li>
        <li id="ul0176-0010" num="0444">dyntxrule.timestamp.format=YYYY-MM-DD-HH.MI.SS
<br/>
{txrule}.seqid
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0209" num="0445">Determines the seqid for a particular transaction. This can be used when there are multiple transactions per message. Determines the XPath expression, JMS property, or system value that contains the transactions seqid. Any XPath expression must end with a value accessor such as @att of text( ).</p>
<p id="p-0210" num="0446">{txrule}.seqid={xpath-expression}|${jms-property}|*seqid</p>
<p id="h-0034" num="0000">For example:</p>
<p id="p-0211" num="0000">
<ul id="ul0177" list-style="none">
    <li id="ul0177-0001" num="0000">
    <ul id="ul0178" list-style="none">
        <li id="ul0178-0001" num="0447">dyntxrule.seqid=@seqid
<br/>
{txrule}.txid
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0212" num="0448">Determines the XPath expression, JMS property, or system value that contains the txid used to unique identify transactions. This value must be continually increasing for each transaction.
<ul id="ul0179" list-style="none">
    <li id="ul0179-0001" num="0000">
    <ul id="ul0180" list-style="none">
        <li id="ul0180-0001" num="0449">{txrule}.txid={xpath-expression}|${jms-property}|*txid
<br/>
For most cases using the system value of *txid is preferred. For example:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0213" num="0450">
<tables id="TABLE-US-00046" num="00046">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="63pt" align="left"/>
<colspec colname="1" colwidth="154pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>dyntxrule.txid=$JMSTxId</entry>
</row>
<row>
<entry/>
<entry>dyntxrule.txid=*txid</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
{txrule}.txowner
</p>
<p id="p-0214" num="0451">Optionally, determines the XPath expression, JMS property, or static value that contains an arbitrary user name associated with a transaction. This value may be used to exclude certain transactions from processing
<ul id="ul0181" list-style="none">
    <li id="ul0181-0001" num="0000">
    <ul id="ul0182" list-style="none">
        <li id="ul0182-0001" num="0452">{txrule}.txowner={xpath-expression}|${jms-property}|&#x201c;{value}&#x201d;
<br/>
For example:
</li>
        <li id="ul0182-0002" num="0453">dyntxrule.txowner=$MessageOwner</li>
        <li id="ul0182-0003" num="0454">dyntxrule.txowner=&#x201c;jsmith&#x201d;
<br/>
{txrule}.txname
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0215" num="0455">Optionally, determines the XPath expression, JMS property, or static value that contains an arbitrary name to be associated with a transaction</p>
<p id="h-0035" num="0000">{txrule}.txname={xpath-expression}|${jms-property}|&#x201c;value&#x201d;</p>
<p id="h-0036" num="0000">For example:</p>
<p id="p-0216" num="0000">
<ul id="ul0183" list-style="none">
    <li id="ul0183-0001" num="0000">
    <ul id="ul0184" list-style="none">
        <li id="ul0184-0001" num="0456">dyntxrule.txname=&#x201c;fixedtx&#x201d;
<br/>
{oprule}.timestamp
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0217" num="0457">Optionally determines the XPath expression or JMS property that contains the operation commit timestamp, or to use the current system time.
<ul id="ul0185" list-style="none">
    <li id="ul0185-0001" num="0000">
    <ul id="ul0186" list-style="none">
        <li id="ul0186-0001" num="0458">{oprule}.timestamp={xpath-expression}|${jms-property}|*ts
<br/>
The timestamp for the operation may override a timestamp at the transaction level. Any XPath expression must end with a value accessor such as @att of text( ). For example:
</li>
        <li id="ul0186-0002" num="0459">statoprule.timestamp=./CreateTime/text( )
<br/>
{oprule}.timestamp.format
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0218" num="0460">Determines the format of the timestamp field.
<ul id="ul0187" list-style="none">
    <li id="ul0187-0001" num="0000">
    <ul id="ul0188" list-style="none">
        <li id="ul0188-0001" num="0461">{oprule}.timestamp.format={format}
<br/>
where the format can include punctuation characters plus:
</li>
        <li id="ul0188-0002" num="0462">YYYY&#x2014;four digit year</li>
        <li id="ul0188-0003" num="0463">YY&#x2014;two digit year</li>
        <li id="ul0188-0004" num="0464">M[M]&#x2014;one or two digit month</li>
        <li id="ul0188-0005" num="0465">D[D]&#x2014;one or two digit day</li>
        <li id="ul0188-0006" num="0466">HH&#x2014;hours in twenty four hour notation</li>
        <li id="ul0188-0007" num="0467">MI&#x2014;minutes</li>
        <li id="ul0188-0008" num="0468">SS&#x2014;seconds</li>
        <li id="ul0188-0009" num="0469">F<sup>n</sup>&#x2014;n number of fractions
<br/>
The default format is &#x201c;YYYY-MM-DD:HH:MI:SS.FFF&#x201d; For example:
</li>
        <li id="ul0188-0010" num="0470">statoprule.timestamp.format=YYYY-MM-DD-HH.MI.SS
<br/>
{oprule}.seqid
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0219" num="0471">Optionally overrides any seqid defined in parent transaction rules. Must be present if there is no parent transaction rule. Determines the seqid for a particular operation. Determines the XPath expression, JMS property, or system value that contains the operations seqid. Any XPath expression must end with a value accessor such as @att of text( ).
<ul id="ul0189" list-style="none">
    <li id="ul0189-0001" num="0000">
    <ul id="ul0190" list-style="none">
        <li id="ul0190-0001" num="0472">{oprule}.seqid={xpath-expression}|${jms-property}|*seqid
<br/>
For example:
</li>
        <li id="ul0190-0002" num="0473">dynoprule.seqid=@seqid
<br/>
{oprule}.txid
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0220" num="0474">Optionally overrides any txid defined in parent transaction rules. Must be present if there is no parent transaction rule. Determines the XPath expression, JMS property, or system value that contains the txid used to unique identify transactions. This value must be continually increasing for each transaction.
<ul id="ul0191" list-style="none">
    <li id="ul0191-0001" num="0000">
    <ul id="ul0192" list-style="none">
        <li id="ul0192-0001" num="0475">{oprule}.txid={xpath-expression}|${jms-property}|*txid
<br/>
For most cases using the system value of *txid is preferred. For example:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0221" num="0476">
<tables id="TABLE-US-00047" num="00047">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="63pt" align="left"/>
<colspec colname="1" colwidth="154pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>dynoprule.txid=$JMSTxId</entry>
</row>
<row>
<entry/>
<entry>dynoprule.txid=*txid</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
{oprule}.txowner
</p>
<p id="p-0222" num="0477">Optionally, determines the XPath expression, JMS property, or static value that contains an arbitrary user name associated with a transaction. This value may be used to exclude certain transactions from processing
<ul id="ul0193" list-style="none">
    <li id="ul0193-0001" num="0000">
    <ul id="ul0194" list-style="none">
        <li id="ul0194-0001" num="0478">{oprule}.txowner={xpath-expression}|${jms-property}|&#x201c;{value}&#x201d;
<br/>
For example:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0223" num="0479">
<tables id="TABLE-US-00048" num="00048">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="168pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>dynoprule.txowner=$MessageOwner</entry>
</row>
<row>
<entry/>
<entry>dynoprule.txowner=&#x201d;jsmith&#x201d;</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
{oprule}.txname
</p>
<p id="p-0224" num="0480">Optionally, determines the XPath expression, JMS property, or static value that contains an arbitrary name to be associated with a transaction
<ul id="ul0195" list-style="none">
    <li id="ul0195-0001" num="0000">
    <ul id="ul0196" list-style="none">
        <li id="ul0196-0001" num="0481">{oprule}.txname={xpath-expression}|${jms-property}|&#x201c;value&#x201d;
<br/>
For example:
</li>
        <li id="ul0196-0002" num="0482">dynoprule.txname=&#x201c;fixedtx&#x201d;
<br/>
{oprule}.schemandtable
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0225" num="0483">Determines the XPath expression JMS property or hard-coded value that contains the schema and table name in the form SCHEMA.TABLE. Any XPath expression must end with a value accessor such as @att ot text( ). Verified to ensure the table exists in source defs.
<ul id="ul0197" list-style="none">
    <li id="ul0197-0001" num="0000">
    <ul id="ul0198" list-style="none">
        <li id="ul0198-0001" num="0484">{oprule}.schemaandtable={xpath-expression}|${jms-property}|&#x201c;value&#x201d;
<br/>
For example:
</li>
        <li id="ul0198-0002" num="0485">statoprule.schemaandtable=&#x201c;MY.TABLE&#x201d;
<br/>
{oprule}.schema
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0226" num="0486">Determines the XPath expression, JMS property or hard-coded value that contains the schema name. Any XPath expression must end with a value accessor such as @att ot text( ).
<ul id="ul0199" list-style="none">
    <li id="ul0199-0001" num="0000">
    <ul id="ul0200" list-style="none">
        <li id="ul0200-0001" num="0487">{oprule}.schema={xpath-expression}|${jms-property}|&#x201c;value&#x201d;
<br/>
For example:
</li>
        <li id="ul0200-0002" num="0488">statoprule. schema=@schema
<br/>
{oprule}.table
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0227" num="0489">Determines the XPath expression, JMS property or hard-coded value that contains the table name. Any XPath expression must end with a value accessor such as @att ot text( ).
<ul id="ul0201" list-style="none">
    <li id="ul0201-0001" num="0000">
    <ul id="ul0202" list-style="none">
        <li id="ul0202-0001" num="0490">{oprule}.table={xpath-expression}|${jms-property}|&#x201c;value&#x201d;
<br/>
For example:
</li>
        <li id="ul0202-0002" num="0491">statoprule.table=$TableName
<br/>
{oprule}.optype
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0228" num="0492">Determines the XPath expression, JMS property or hard-coded value that contains the optype to be validated against an optype insertval, etc. Any XPath expression must end with a value accessor such as @att of text( ).
<ul id="ul0203" list-style="none">
    <li id="ul0203-0001" num="0000">
    <ul id="ul0204" list-style="none">
        <li id="ul0204-0001" num="0493">{oprule}.optype={xpath-expression}|${jms-property}|&#x201c;value&#x201d;
<br/>
For example:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0229" num="0494">
<tables id="TABLE-US-00049" num="00049">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="70pt" align="left"/>
<colspec colname="1" colwidth="147pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>dynoprule.optype=@type</entry>
</row>
<row>
<entry/>
<entry>statoprule.optype=&#x201d;I&#x201d;</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
{oprule}.optype.insertval
</p>
<p id="p-0230" num="0495">The value to look for to identify an operation as an Insert type operation. The default is &#x2018;I&#x2019;.
<ul id="ul0205" list-style="none">
    <li id="ul0205-0001" num="0000">
    <ul id="ul0206" list-style="none">
        <li id="ul0206-0001" num="0496">{oprule}.optype.insertval={value}|\x{hex-value}
<br/>
For example:
</li>
        <li id="ul0206-0002" num="0497">dynoprule.optype.insertval=A
<br/>
{oprule}.optype.updateval
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0231" num="0498">The value to look for to identify an operation as an Update type operation. The default is &#x2018;U&#x2019;.
<ul id="ul0207" list-style="none">
    <li id="ul0207-0001" num="0000">
    <ul id="ul0208" list-style="none">
        <li id="ul0208-0001" num="0499">{oprule}.optype.updateval={value}|\x{hex-value}
<br/>
For example:
</li>
        <li id="ul0208-0002" num="0500">dynoprule.optype.updateval=M
<br/>
{oprule}.optype.deleteval
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0232" num="0501">The value to look for to identify an operation as a Delete type operation. The default is &#x2018;D&#x2019;.
<ul id="ul0209" list-style="none">
    <li id="ul0209-0001" num="0000">
    <ul id="ul0210" list-style="none">
        <li id="ul0210-0001" num="0502">{oprule}.optype.deleteval={value}|\x{hex-value}
<br/>
For example:
</li>
        <li id="ul0210-0002" num="0503">dynoprule.optype.deleteval=R
<br/>
{oprule}.txind
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0233" num="0504">Optionally determines the XPath expression or JMS property that contains the transaction indicator to be validated against beginval etc. If not defined all operations within a single message will be seen to have occurred within a whole transaction. If defined, then will determine the begin, middle and end of transactions. Any XPath expression must end with a value accessor such as @att of text( ). Transactions defined in this way can span messages.
<ul id="ul0211" list-style="none">
    <li id="ul0211-0001" num="0000">
    <ul id="ul0212" list-style="none">
        <li id="ul0212-0001" num="0505">{oprule}.txind={xpath-expression}|${jms-property}
<br/>
For example:
</li>
        <li id="ul0212-0002" num="0506">dynoprule.txind=@txind
<br/>
{oprule}.txind.beginval
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0234" num="0507">The value to look for to identify an operation as the beginning of a transaction. Defaults to &#x2018;B&#x2019;.</p>
<p id="p-0235" num="0508">{oprule}.txind.beginval={value}|\x{hex-value}</p>
<p id="h-0037" num="0000">For example:</p>
<p id="p-0236" num="0000">
<ul id="ul0213" list-style="none">
    <li id="ul0213-0001" num="0000">
    <ul id="ul0214" list-style="none">
        <li id="ul0214-0001" num="0509">dynoprule.txind.beginval=0
<br/>
{oprule}.txind.middleval
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0237" num="0510">The value to look for to identify an operation as the middle of a transaction. Defaults to &#x2018;M&#x2019;.
<ul id="ul0215" list-style="none">
    <li id="ul0215-0001" num="0000">
    <ul id="ul0216" list-style="none">
        <li id="ul0216-0001" num="0511">{oprule}.txind.middleval={value}|\x{hex-value}
<br/>
For example:
</li>
        <li id="ul0216-0002" num="0512">dynoprule.txind.middleval=1
<br/>
{oprule}.txind.endval
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0238" num="0513">The value to look for to identify an operation as the end of a transaction. Defaults to &#x2018;E&#x2019;.
<ul id="ul0217" list-style="none">
    <li id="ul0217-0001" num="0000">
    <ul id="ul0218" list-style="none">
        <li id="ul0218-0001" num="0514">{oprule}.txind.endval={value}|\x{hex-value}
<br/>
For example:
</li>
        <li id="ul0218-0002" num="0515">dynoprule.txind.endval=2
<br/>
{oprule}.txind.wholeval
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0239" num="0516">The value to look for to identify an operation as a whole transaction. Defaults to &#x2018;W&#x2019;.
<ul id="ul0219" list-style="none">
    <li id="ul0219-0001" num="0000">
    <ul id="ul0220" list-style="none">
        <li id="ul0220-0001" num="0517">{oprule}.txind.wholeval={value}|\x{hex-value}
<br/>
For example:
</li>
        <li id="ul0220-0002" num="0518">dynoprule.txind.wholeval=3
<br/>
{colrule}.name
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0240" num="0519">Determines the XPath expression or hard-coded value that contains a column name. If not specified then the column index must be specified and the column name will be resolved from that. If specified the column name will be verified against the source definitions file. Any XPath expression must end with a value accessor such as @att ot text( ).
<ul id="ul0221" list-style="none">
    <li id="ul0221-0001" num="0000">
    <ul id="ul0222" list-style="none">
        <li id="ul0222-0001" num="0520">{colrule}.name={xpath-expression}|&#x201c;value&#x201d;
<br/>
For example:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0241" num="0521">
<tables id="TABLE-US-00050" num="00050">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="63pt" align="left"/>
<colspec colname="1" colwidth="154pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>dyncolrule.name=@name</entry>
</row>
<row>
<entry/>
<entry>statkeycolrule.name=&#x201d;keycol&#x201d;</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
{colrule}.index
</p>
<p id="p-0242" num="0522">Determines the XPath expression or hard-coded value that contains a column index. If not specified then the column name must be specified and the column index will be resolved from that. If specified the column index will be verified against the source definitions file. Any XPath expression must end with a value accessor such as @att ot text( ).
<ul id="ul0223" list-style="none">
    <li id="ul0223-0001" num="0000">
    <ul id="ul0224" list-style="none">
        <li id="ul0224-0001" num="0523">{colrule}.index={xpath-expression}|&#x201c;value&#x201d;
<br/>
For example:
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0243" num="0524">
<tables id="TABLE-US-00051" num="00051">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="63pt" align="left"/>
<colspec colname="1" colwidth="154pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>dyncolrule.index=@index</entry>
</row>
<row>
<entry/>
<entry>statkeycolrule.index=1</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
{colrule}.value
</p>
<p id="p-0244" num="0525">Determines the XPath expression or hard-coded value that contains a column value. Any XPath expression must end with a value accessor such as @att ot text( ). If the XPath expression fails to return any data because a node or attribute does not exist, the column value will be deemed as null. To differentiate between null and missing values (for updates) the isnull and is missing properties should be set. The value returned is used for delete before values, and update/insert after values.
<ul id="ul0225" list-style="none">
    <li id="ul0225-0001" num="0000">
    <ul id="ul0226" list-style="none">
        <li id="ul0226-0001" num="0526">{colrule}.value={xpath-expression}|&#x201c;value&#x201d;
<br/>
For example:
</li>
        <li id="ul0226-0002" num="0527">statkeycolrule.value=./text( )
<br/>
{colrule}.isnull
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0245" num="0528">Optionally determines the XPath expression used to discover if a column value is null. The XPath expression must end with a value accessor such as @att ot text( ). If the XPath expression returns any value, then the column value is null.
<ul id="ul0227" list-style="none">
    <li id="ul0227-0001" num="0000">
    <ul id="ul0228" list-style="none">
        <li id="ul0228-0001" num="0529">{colrule}.isnull={xpath-expression}
<br/>
For example:
</li>
        <li id="ul0228-0002" num="0530">dyncolrule.isnull=@isnull
<br/>
{colrule}.ismissing
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0246" num="0531">Optionally determines the XPath expression used to discover if a column value is missing. The XPath expression must end with a value accessor such as @att ot text( ). If the XPath expression returns any value, then the column value is missing.
<ul id="ul0229" list-style="none">
    <li id="ul0229-0001" num="0000">
    <ul id="ul0230" list-style="none">
        <li id="ul0230-0001" num="0532">{colrule}.ismissing={xpath-expression}
<br/>
For example:
</li>
        <li id="ul0230-0002" num="0533">dyncolrule.ismissing=./missing
<br/>
{colrule}.before.value
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0247" num="0534">Optionally override {colrule}.value to specifically say how to obtain before values used for updates or deletes. Has the same format as {colrule}.value. For example:
<ul id="ul0231" list-style="none">
    <li id="ul0231-0001" num="0000">
    <ul id="ul0232" list-style="none">
        <li id="ul0232-0001" num="0535">dyncolrule.before.value=./beforevalue/text( ) {colrule}.before.isnull</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0248" num="0536">Optionally override {colrule}.isnull to specifically say how to determine if a before value is null for updates or deletes. Has the same format as {colrule}.isnull. For example:
<ul id="ul0233" list-style="none">
    <li id="ul0233-0001" num="0000">
    <ul id="ul0234" list-style="none">
        <li id="ul0234-0001" num="0537">dyncolrule.before.isnull=./beforevalue/@isnull
<br/>
{colrule}.before.ismissing
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0249" num="0538">Optionally override {colrule}.ismissing to specifically say how to determine if a before value is missing for updates or deletes. Has the same format as {colrule}.ismissing. For example:
<ul id="ul0235" list-style="none">
    <li id="ul0235-0001" num="0000">
    <ul id="ul0236" list-style="none">
        <li id="ul0236-0001" num="0539">dyncolrule.before.ismissing=./beforevalue/missing
<br/>
{colrule}.after.value
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0250" num="0540">As per {colrule}.before.value except for after values.</p>
<p id="h-0038" num="0000">{colrule}.after.isnull</p>
<p id="p-0251" num="0541">As per {colrule}.before.isnull except for after values.</p>
<p id="h-0039" num="0000">{colrule}.after.ismissing</p>
<p id="p-0252" num="0542">As per {colrule}.before.ismissing except for after values.</p>
<p id="p-0253" num="0543">The present invention may be conveniently implemented using one or more conventional general purpose or specialized digital computer, computing device, machine, or microprocessor, including one or more processors, memory and/or computer readable storage media programmed according to the teachings of the present disclosure. Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure, as will be apparent to those skilled in the software art.</p>
<p id="p-0254" num="0544">In some embodiments, the present invention includes a computer program product which is a non-transitory storage medium or computer readable medium (media) having instructions stored thereon/in which can be used to program a computer to perform any of the processes of the present invention. The storage medium can include, but is not limited to, any type of disk including floppy disks, optical discs, DVD, CD-ROMs, microdrive, and magneto-optical disks, ROMs, RAMs, EPROMs, EEPROMs, DRAMs, VRAMs, flash memory devices, magnetic or optical cards, nanosystems (including molecular memory ICs), or any type of media or device suitable for storing instructions and/or data.</p>
<p id="p-0255" num="0545">The foregoing description of the present invention has been provided for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations will be apparent to the practitioner skilled in the art. The embodiments were chosen and described in order to best explain the principles of the invention and its practical application, thereby enabling others skilled in the art to understand the invention for various embodiments and with various modifications that are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalence.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A system for performing real-time conversion of data present in the form of messages into database transactions which can subsequently be applied to a database, comprising:
<claim-text>a computer including a microprocessor; and</claim-text>
<claim-text>a messaging capture adaptor, which includes
<claim-text>a messaging connectivity component that reads messages from a message queue at a first or source system, and</claim-text>
<claim-text>a data parsing component that parses data within the messages, from a source format of the first or source system, to a target format of a target database or second system;</claim-text>
</claim-text>
<claim-text>wherein the messaging capture adaptor
<claim-text>starts a local transaction,</claim-text>
<claim-text>retrieves the messages from the message queue at the first or source system,</claim-text>
<claim-text>processes data within the messages, according to a set of properties, rules and other messaging connectivity information that define how the messages should be parsed and mapped to records in the target database or second system,</claim-text>
<claim-text>generates a trail file containing the processed data, for use in applying the processed data as database operations to the target database or second system, and</claim-text>
<claim-text>commits the local transaction.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the message queue is a Java Message Service (JMS) queue and the messages are JMS messages.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the messaging capture adaptor communicates with an extract process to generate the trail file.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the messaging capture adaptor includes the set of properties, rules and other messaging connectivity information that define how the messages received at the first or source system should be parsed and mapped to records in the target database or second system, to create the trail file.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The system of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the messaging capture adaptor comprises a vendor access module or communications component or interface.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the messaging capture adaptor operates to request messages from a designated queue at the first or source system by
<claim-text>starting a local messaging service transaction if not already started,</claim-text>
<claim-text>reading a message off the designated queue, and</claim-text>
<claim-text>if a message exists, then returning the contents of the message and any message header properties to the messaging capture adaptor.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The system of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein,
<claim-text>if the messaging capture adaptor has successfully parsed the message, has output an entire transaction to the trail, and has ensured the transaction has been flushed to disk, the local messaging service transaction is then committed, removing the messages from the queue or topic at the first or source system, and</claim-text>
<claim-text>in the event of an error, the local messaging service transaction is rolled back, leaving the message unprocessed at the first or source system.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the messaging capture adaptor supports any one or more of fixed width message parsing, delimited message parsing, or XML message parsing.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. A method for performing real-time conversion of data present in the form of messages into database transactions which can subsequently be applied to a database, comprising the steps of:
<claim-text>providing a messaging capture adaptor, which includes
<claim-text>a messaging connectivity component that reads messages from a message queue at a first or source system, and</claim-text>
<claim-text>a data parsing component that parses data within the messages, from a source format of the first or source system, to a target format of a target database or second system;</claim-text>
</claim-text>
<claim-text>wherein the messaging capture adaptor
<claim-text>starts a local transaction,</claim-text>
<claim-text>retrieves the messages from the message queue at the first or source system,</claim-text>
<claim-text>processes data within the messages, according to a set of properties, rules and other messaging connectivity information that define how the messages should be parsed and mapped to records in the target database or second system,</claim-text>
<claim-text>generates a trail file containing the processed data, for use in applying the processed data as database operations to the target database or second system, and</claim-text>
<claim-text>commits the local transaction.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the message queue is a Java Message Service (JMS) queue and the messages are JMS messages.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the messaging capture adaptor communicates with an extract process to generate the trail file.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the messaging capture adaptor includes the set of properties, rules and other messaging connectivity information that define how the messages received at the first or source system should be parsed and mapped to records in the target database or second system, to create the trail file.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the messaging capture adaptor comprises a vendor access module or communications component or interface.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the messaging capture adaptor operates to request messages from a designated queue at the first or source system by
<claim-text>starting a local messaging service transaction if not already started,</claim-text>
<claim-text>reading a message off the designated queue, and
<claim-text>if a message exists, then returning the contents of the message and any message header properties to the messaging capture adaptor.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein,
<claim-text>if the messaging capture adaptor has successfully parsed the message, has output an entire transaction to the trail, and has ensured the transaction has been flushed to disk, the local messaging service transaction is then committed, removing the messages from the queue or topic at the first or source system, and</claim-text>
<claim-text>in the event of an error, the local messaging service transaction is rolled back, leaving the message unprocessed at the first or source system.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the messaging capture adaptor supports any one or more of fixed width message parsing, delimited message parsing, or XML message parsing.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. A non-transitory computer readable medium, including instructions stored thereon which when read and executed by a computer cause the computer to perform the steps comprising:
<claim-text>providing a messaging capture adaptor, which includes
<claim-text>a messaging connectivity component that reads messages from a message queue at a first or source system, and</claim-text>
<claim-text>a data parsing component that parses data within the messages, from a source format of the first or source system, to a target format of a target database or second system;</claim-text>
</claim-text>
<claim-text>wherein the messaging capture adaptor
<claim-text>starts a local transaction,</claim-text>
<claim-text>retrieves the messages from the message queue at the first or source system,</claim-text>
<claim-text>processes data within the messages, according to a set of properties, rules and other messaging connectivity information that define how the messages should be parsed and mapped to records in the target database or second system,</claim-text>
<claim-text>generates a trail file containing the processed data, for use in applying the processed data as database operations to the target database or second system, and</claim-text>
<claim-text>commits the local transaction.</claim-text>
</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
