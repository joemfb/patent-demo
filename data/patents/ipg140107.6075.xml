<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627199-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627199</doc-number>
<kind>B1</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13038356</doc-number>
<date>20110301</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>17</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>715234</main-classification>
</classification-national>
<invention-title id="d2e43">Incremental computing of changes to computer user interfaces</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6826726</doc-number>
<kind>B2</kind>
<name>Hsing et al.</name>
<date>20041100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>7181684</doc-number>
<kind>B2</kind>
<name>Chittu et al.</name>
<date>20070200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>7340673</doc-number>
<kind>B2</kind>
<name>Malone</name>
<date>20080300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>7805523</doc-number>
<kind>B2</kind>
<name>Mitchell et al.</name>
<date>20100900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>7962547</doc-number>
<kind>B2</kind>
<name>Kern et al.</name>
<date>20110600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>7984137</doc-number>
<kind>B2</kind>
<name>O'Toole et al.</name>
<date>20110700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709224</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>8239756</doc-number>
<kind>B2</kind>
<name>Maes et al.</name>
<date>20120800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2009/0235156</doc-number>
<kind>A1</kind>
<name>Wake et al.</name>
<date>20090900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2010/0313149</doc-number>
<kind>A1</kind>
<name>Zhang et al.</name>
<date>20101200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00010">
<othercit>http://ambassadortothecomputers.blogspot.com/2010/05/how-froc-works.html, (May 7, 2010), 12 pgs.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00011">
<othercit>Meyerovich, Leo, et al., &#x201c;Flapjax: A Programming Language for Ajax Applications&#x201d;, Department of Computer Science, Brown University, Providence, Rhode Island (CS-09-04), (Apr. 2009), 21 pgs.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00012">
<othercit>&#x201c;U.S. Appl. No. 13/017,730 , Response filed Oct. 1, 2012 to Non Final Office Action mailed Mar. 30, 2012&#x201d;, 12 pgs.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00013">
<othercit>&#x201c;U.S. Appl. No. 13/017,730 , Response filed May 29, 2013 to Final Office Action mailed Dec. 6, 2012&#x201d; 58 pgs.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00014">
<othercit>&#x201c;U.S. Appl. No. 13/017,730, Final Office Action mailed Dec. 6, 2012&#x201d;, 16 pgs.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00015">
<othercit>&#x201c;U.S. Appl. No. 13/017,730, Notice of Allowance mailed Jun. 27, 2013&#x201d;, 23 pgs.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00016">
<othercit>Whitmer, Ray, &#x201c;Document Object Model XPath&#x201d;, (Feb. 26, 2004), 1-16.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>16</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>715234</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>15</number-of-drawing-sheets>
<number-of-figures>18</number-of-figures>
</figures>
<us-related-documents>
<continuation-in-part>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>13017730</doc-number>
<date>20110131</date>
</document-id>
<parent-status>PENDING</parent-status>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>13038356</doc-number>
</document-id>
</child-doc>
</relation>
</continuation-in-part>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61299916</doc-number>
<date>20100129</date>
</document-id>
</us-provisional-application>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Handley</last-name>
<first-name>Malcolm</first-name>
<address>
<city>San Francisco</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Moskovitz</last-name>
<first-name>Dustin</first-name>
<address>
<city>San Francisco</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Rosenstein</last-name>
<first-name>Justin</first-name>
<address>
<city>San Francisco</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Handley</last-name>
<first-name>Malcolm</first-name>
<address>
<city>San Francisco</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Moskovitz</last-name>
<first-name>Dustin</first-name>
<address>
<city>San Francisco</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Rosenstein</last-name>
<first-name>Justin</first-name>
<address>
<city>San Francisco</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Schwegman Lundberg &#x26; Woessner, P.A.</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Asana, Inc.</orgname>
<role>02</role>
<address>
<city>San Francisco</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Hutton, Jr.</last-name>
<first-name>Doug</first-name>
<department>2176</department>
</primary-examiner>
<assistant-examiner>
<last-name>Smith</last-name>
<first-name>Tionna</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A method is provided to update information in a computer system comprising providing a reactive value hierarchy structure in a non-transitory computer readable storage device; in response to a change in a reactive value corresponding to a node in the hierarchy, marking nodes within the hierarchy that share as dirty a path with a node corresponding to a changed reactive value; traversing down through the hierarchy to a level where a reactive value is located that is either dirty or clean; if the reactive value is dirty, traversing back up to a dependent node in the hierarchy and compute a new reactive value and repeating the traversing down step; if the reactive value is clean, traversing back up to a dependent node and repeating the traversing down step; and producing at least one side-effect in the computer system in response to a compute of a new reactive value.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="158.75mm" wi="104.31mm" file="US08627199-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="256.12mm" wi="174.41mm" file="US08627199-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="211.84mm" wi="176.02mm" file="US08627199-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="222.17mm" wi="168.49mm" file="US08627199-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="198.63mm" wi="183.22mm" orientation="landscape" file="US08627199-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="262.38mm" wi="177.21mm" orientation="landscape" file="US08627199-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="257.98mm" wi="181.53mm" orientation="landscape" file="US08627199-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="210.90mm" wi="172.55mm" file="US08627199-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="171.87mm" wi="175.68mm" file="US08627199-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="256.12mm" wi="173.14mm" file="US08627199-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="168.49mm" wi="164.34mm" file="US08627199-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="176.02mm" wi="163.41mm" file="US08627199-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="146.73mm" wi="183.22mm" file="US08627199-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="155.28mm" wi="163.75mm" file="US08627199-20140107-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="199.56mm" wi="148.34mm" file="US08627199-20140107-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="253.58mm" wi="179.15mm" file="US08627199-20140107-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CLAIM OF PRIORITY</heading>
<p id="p-0002" num="0001">This application is a Continuation-in Part of and claims the benefit of priority under 35&#xa7;120 to U.S. patent application Ser. No. 13/017,730, filed on Jan. 31, 2011, which claims the benefit of priority under 35 U.S.C. &#xa7;119(e) to U.S. Provisional Patent Application Ser. No. 61/299,916, filed on Jan. 29, 2010, the benefit of priority of each of which is claimed hereby, and each of which are incorporated by reference herein in its entirety.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">TECHNICAL FIELD</heading>
<p id="p-0003" num="0002">The present application relates generally to the technical field of computing incremental changes to information provided through a user interface of a computer connected to a computer network and, in one specific example, to web-based reactive computing of incremental changes to a user interface.</p>
<heading id="h-0003" level="1">BACKGROUND</heading>
<p id="p-0004" num="0003">Multiple factors, such as increasing broadband connectivity, the inconvenience associated with computer viruses and hardware redundancy, and the emergence of advertising supported software as a business model, have bolstered the migration of the functionality of locally stored software applications to network based web applications.</p>
<p id="p-0005" num="0004">Web applications can require communications over a network with a server, such as a web or database server, which introduces latency issues that affect responsiveness, especially in comparison to locally stored applications. Current web application implementations seek to minimize the effects of latency on application performance by reducing the number of queries and the amount of transmitted data. This can be accomplished by requesting only the altered data and by dynamically updating affected elements of an HTML document, rather than reloading the entire HTML document. Moreover, a user interfaces may present data that is complex or abundant requiring significant effort to keep the data up to date. The operations defining the data to be queried for and updated and how to update an HTML document are often accomplished through customized software. The creation and maintenance of the customized software can require significant developer resources.</p>
<heading id="h-0004" level="1">SUMMARY</heading>
<p id="p-0006" num="0005">In one aspect, a method is provided of determining which reactive values of a reactive value hierarchy encoded in a computer readable storage device need to be recomputed in response to a change in at least one reactive value of the hierarchy and in what order so that a reactive value is recomputed only if at least one of its inputs has a different value and only if the reactive value is still in use and will still be in use even after all of the changes to reactive values in the hierarchy have been determined.</p>
<p id="p-0007" num="0006">In another aspect, a tangible side-effect is produced in a computer system in response to a compute of a new reactive value.</p>
<p id="p-0008" num="0007">These and other features and advantages of embodiments of the invention will become apparent from the following description of embodiments thereof in combination with the appended drawings.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0009" num="0008">Some embodiments are illustrated by way of example and not limitation in the figures of the accompanying drawings in which:</p>
<p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. 1</figref> is an illustrative block diagram of a system for implementing web-based incremental computing, according to an example embodiment.</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 2</figref> is an illustrative block diagram of a system that analyzes web application source code and implements web-based incremental computing, according to an example embodiment.</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIGS. 3A-3B</figref> are illustrative drawings of a first reactive value hierarchy structure (<figref idref="DRAWINGS">FIG. 3A</figref>) encoded in a computer readable storage device that corresponds to a function that can be decomposed into reactive values and executed on a computing system and a process to update the structure in response to changes in one or more reactive values (<figref idref="DRAWINGS">FIG. 3B</figref>) in accordance with some embodiments.</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 4A</figref> is an illustrative drawing of a second reactive value hierarchy structure in accordance with some embodiments. <figref idref="DRAWINGS">FIG. 4B</figref> is an illustrative drawing of the second reactive value hierarchy structure of <figref idref="DRAWINGS">FIG. 4A</figref> annotated to show connectivity state information structures used to implement nodes of the hierarchy structure in accordance with some embodiments. <figref idref="DRAWINGS">FIG. 4C</figref> is an illustrative drawing of the second reactive value hierarchy structure of <figref idref="DRAWINGS">FIG. 4A</figref> annotated to show change state information structures containing change state information produced in response detection of one or more changed reactive values in accordance with some embodiments.</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 5</figref> is an illustrative flow diagram of a traversal and change state traversal process to traverse the reactive value hierarchy structure of <figref idref="DRAWINGS">FIG. 4A</figref> in accordance with some embodiments.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 6</figref> is an illustrative flow diagram of a second change state determination process that runs in conjunction with the change state traversal process of <figref idref="DRAWINGS">FIG. 5</figref>.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIGS. 7A-7C</figref> are illustrative drawings of three aspects of a recursive process in accordance with some embodiments to traverse the hierarchy to ensure that reactive values are current by identifying reactive values that need to he computed and by computing new values for the identified reactive values.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 8</figref> is an illustrative flow diagram representing a process to update the reactive value hierarchy structure and to remove invalid state information in the event that the function uses a different branch during different runs.</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 9</figref> is an illustrative drawing of the second reactive value hierarchy structure of <figref idref="DRAWINGS">FIG. 4A</figref> modified to represent relationships among reactive values on a different execution path in accordance with some embodiments.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 10</figref> is an illustrative flow diagram of the computation process performed by a watch process in accordance with some embodiments.</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIGS. 11A-11B</figref> are illustrative drawings of portions of the graph of <figref idref="DRAWINGS">FIGS. 4A-4C</figref> during running of the recursive process of <figref idref="DRAWINGS">FIGS. 7A-7C</figref>.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 12</figref> is an illustrative block diagram of machine in the example form of a computer system within which a set instructions, for causing the machine to perform any one or more of the methodologies discussed herein, may be executed.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0006" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0022" num="0021">Example methods and systems for supporting incremental computing are described. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of example embodiments. It will be evident, however, to one skilled in the art that the present invention may be practiced without these specific details. As used herein, the term &#x201c;or&#x201d; may be construed in an inclusive and exclusive sense. Items that appear in multiple drawings are labeled with identical reference numerals in each drawing.</p>
<p id="p-0023" num="0022">Web applications, such as applications presented via a browser and accessed over a network, provide application users and application developers with certain advantages over locally installed applications. An application developer can design a web application to conform to internet standards to ensure cross-platform compatibility (e.g., Windows, Linux) and a consistent user experience across platforms. Web applications also allow an application developer to update and maintain an application without the need for distributing and installing updates on a user's computer. An application user can access the web application from any device that supports a web client without needing to locally install the application.</p>
<p id="p-0024" num="0023">The popularity of web applications and the maturation of web application technologies has resulted in a growing focus on areas such as software as a service (SaaS) and cloud computing. The demand for web applications and their related products also has resulted in increasingly complex web applications that require greater amounts of data and computational resources while simultaneously supporting a responsive and rich user experience mirroring the user experience provided by locally installed applications.</p>
<p id="p-0025" num="0024">Complex web applications can be difficult to write as they depend on data and instructions received over a network from a server. Expensive round trips to a server, such as, but not limited to, a query from a client to a server for data and a response message from the server back to the client, or a similar set of queries between. a web server and database server or a data requestor and a data provider, are affected by network latency that may frustrate a responsive user experience. Latency increases with the amount of data requested. In contrast, locally installed applications may access data from a local disk over a hardware bus with a lower latency.</p>
<p id="p-0026" num="0025">Application developers can reduce the effects of network latency by defining the round trip server queries to fetch relevant data values and by dynamically updating select elements of a webpage based off the fetched data. One method for reducing the amount of data transmitted to update a webpage is to query for data that has been altered, as opposed to reloading an entire webpage. For example, assume that an HTML document presenting a list of data points should be updated when a data point of the list is altered. Rather than requesting from the server the entire HTML document and the entire list of data points, a web application can retrieve only the altered data point and dynamically update the element of the HTML document corresponding to the altered data value, while maintaining the unaffected elements of the HTML document. In an example embodiment, a data value change may affect more than one element of a webpage. However, the customized software defining when and how to update elements of a webpage can be more complex than the operations supporting the main functionality of the web application. In addition, changes to the functionality of the web application may result in changes to the customized software, which may be highly nuanced and difficult to modify. Thus, the production and maintenance of web applications currently may include involvement with customized software, which can often be time consuming and inefficient.</p>
<p id="p-0027" num="0026">According to an example embodiment, a web technology framework may permit an application developer to design and write a web application and have the customized software controlling updates to webpage elements be automatically generated. in one embodiment, efficient creation and maintenance of web applications is enabled by analyzing source code to generate code that monitors data values which affect what is displayed to a user and that automatically updates webpage elements when a change in data values occurs.</p>
<p id="p-0028" num="0027">Incremental computing, also referred to herein as reactive computing, is a paradigm in which a data value change causes only those outputs which depend on the changed data value to be recomputed. Alternatively stated, an incremental computer program is a program that after a certain kind of input change computes new results based on the previously computed result. A related idea is reactive programming, which is a programming paradigm where data values change over time in reaction to certain events. In contrast, for example, in a traditional imperative computing environment, the function A=B+C assigns a value to A at a particular time which does not change if the value of B later changes. In a reactive programming environment, A is a dynamic value, or a behavior, whose value updates whenever the value of B or the value of C changes. An example of a reactive program is a spreadsheet program. Some cells of a spreadsheet may be defined with a value, e.g., a number, while other cells are defined in terms of values computed using other cells, e.g., formulas. Thus, in a reactive programming spreadsheet application, a cell C1 that is defined as (cell A1+cell B1) will change its value when the value of cell A1 changes, as a function of reactive programming. Moreover, in an application of incremental computing, when the value of cell A1 or B1 changes, the spreadsheet application will re-compute the value of C1 but not other cells unrelated to A1 or B1 that are displayed. In an example embodiment of incremental computing, a data value change may cause only certain elements of a webpage to be altered. In a further embodiment, web applications can be written to support incremental computation, which minimizes the amount of data transmitted from a server and defines when data should be transmitted.</p>
<p id="p-0029" num="0028">As used here, the term &#x2018;function&#x2019; signifies a portion of a computer program that performs a specific task. As used herein, a function is a type of procedure or routine. As used herein, a function performs some operation and may or may not return a value. As used herein, the term &#x2018;process&#x2019; signifies a running (i.e. executing) computer program or portion of a computer program such as a function.</p>
<p id="p-0030" num="0029">Systems that conform to the principles of incremental computing and reactive programming may build a dependency graph to capture the nature of the data dependences. A dependency graph is a directed graph and may assist in the effective propagation of changes and recalculations when a data value changes. A dependency graph represents the dependencies of objects towards each other. A dependency graph may represent the evaluation path of a function and the data values and evaluated expressions that it depends upon. In an example embodiment, non-root nodes in a dependency graph that have no children represent atomic data values of the system. In an example embodiment, such atomic data values may be a string, integer, or a structured object recognized by the system, such as a list. For sake of brevity, non-root childless nodes in a dependency tree will herein be described as &#x201c;mutable values.&#x201d; Other nodes that are defined by and depend on &#x201c;mutable values,&#x201d; or nodes with children, for sake of brevity, are herein described as reactive values or &#x201c;R values.&#x201d; As used herein, the term reactive value or R value signifies an object or data structure encoded in a computer readable storage device that can compute a value and keep track of enough information (inputs and dependents, for example) that a framework knows when to recompute that value. A reactive value comprises a handle to a value that can change over time.</p>
<p id="p-0031" num="0030">A node of a dependency graph with no parent represents the output of the function, and is also an R value. An R value whose function has a &#x2018;side-effect&#x2019; is referred to as a &#x2018;watch&#x2019;. A &#x2018;side-effect&#x2019; is a modification of a state, a tangible impact on the outside world or an observable interaction with a calling function. For example, a function which emphasizes change in the state of variables, e.g., x=x+1, has a side-effect. A side-effect may involve modification of a DOM, changing mutable variables or altering some other data structure encoded in a computer readable storage device, for example.</p>
<p id="p-0032" num="0031">Changes propagated to a webpage, such as in an incremental computing and reactive programming paradigm, can be accomplished through a webpage's document object model (DOM). A DOM is a platform and language neutral interface that allows programs and scripts to dynamically access and update the content, structure, and style of a webpage. The DOM provides an interface (API) to get, change, add and delete HTML/XML elements and values. A DOM defines a webpage in a tree structure with various element and node types, which may mirror the elements of the webpage. DOM nodes may be dynamically edited to edit the webpage, and the tree of DOM nodes may be traversed through the API.</p>
<p id="p-0033" num="0032">In an example embodiment, a web application maintains a dependency tree to determine which nodes of the DOM of a webpage to update and how, when a mutable value changes. In an example embodiment, an application developer can write an application and provide it to a compiler. The compiler may then analyze the source code and output interpreted code, such as, but not limited to, JavaScript, that runs on a web client or web server that implements an incremental computing system. The incremental computing system may monitor displayed data values and execute functions and access the DOM to incrementally update the webpage when a data value changes.</p>
<p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. 1</figref> is an illustrative block diagram of a system <b>100</b> for implementing web-based incremental computing, according to some embodiments. The system for implementing web-based incremental computing contains a web application host system <b>102</b>. The web application host system <b>102</b> hosts data and may compute instructions to support a web application <b>108</b>. The web application <b>108</b> is an application accessed through a web client <b>106</b> over a network <b>118</b>, such as a communications network embodied by the internet or an intranet. The web client <b>106</b> may be, but is not limited to, MICROSOFT INTERNET EXPLORER&#xae;, SAFARI&#xae;, OPERA&#xae;, a graphical web browser or a mobile application. The web client <b>106</b> is executed from a client machine <b>104</b>, such as, but not limited to, a personal computer, cell phone, mobile device or machine capable of launching a web client <b>106</b>.</p>
<p id="p-0035" num="0034">The web application host system <b>102</b> distributes data to the web application <b>108</b> through a web server <b>120</b>. The web server <b>120</b> may host or access an application server <b>122</b>, such as, but not limited to, an APACHE APPLICATION SERVER&#xae;. The application server <b>122</b> hosts various applications that control and prepare data, including, but not limited to, an incremental computing application <b>124</b>.</p>
<p id="p-0036" num="0035">The incremental computing application <b>124</b> collects and sends data to the web application <b>108</b>. In an example embodiment, the incremental computing application <b>124</b> may provide push notification to the web application <b>108</b> when data values have changed. The incremental computing application <b>124</b> accesses a database server <b>128</b> through a network <b>126</b>, such as the internet or an intranet, to collect data which is provided to the web server <b>120</b>. Content gathered for the web server <b>120</b> is communicated to the client machine's <b>104</b> web client <b>106</b> to support in the execution of the web application <b>108</b>.</p>
<p id="p-0037" num="0036">The web application <b>108</b> presented by the web client <b>106</b> may be updated when data values change. The web application <b>108</b> recognizes a data change through an input listener <b>110</b> or a receiving module <b>114</b>. The input listener <b>110</b> may capture user input or the occurrence of a trigger event. In an example embodiment, mouse clicks, keyboard input, mouse movement, or other user input, or a trigger event such as the arrival of a certain time, may cause a data value change and be captured by the input listener <b>110</b>. For example, user input such as a mouse click may check a box which changes a data value, propagating a change to the web application <b>108</b>. The receiving module <b>114</b> may also notify the web application <b>108</b> of data value changes. In an example embodiment, the incremental computing application <b>124</b> may monitor the relevant data values stored on the database server <b>128</b> and push a notification to the web application <b>108</b> through the receiving module <b>114</b>. In an example embodiment, the web application periodically polls the web server <b>120</b> and the incremental computing application <b>124</b> using the messaging module <b>112</b> to check whether data values have changed. The data values may be stored in the database server <b>128</b>, on the web server <b>120</b>, with the web application <b>108</b>, or with the incremental computing application <b>124</b>. In an example embodiment, the notification of a data value change that has a side-effect is enabled by a watch <b>117</b> acts as a reactive value that is notified of changes just as other reactive values are notified of changes.</p>
<p id="p-0038" num="0037">When the web application <b>108</b> is notified of a data value change by the input listener <b>110</b> or the receiving module <b>114</b> an updating module <b>116</b> is called to propagate changes. As explained in copending commonly assigned patent application Ser. No. 12/932,671, filed on even day herewith entitled, SERVER SIDE USER INTERFACE SIMULATION, which is expressly incorporated herein by this reference, in some embodiments, the same incremental computing code is run on both the server and the client so as to propagate changes the same way on the server and on the client so that the server loads any new values that must be sent to the client.</p>
<p id="p-0039" num="0038">In an example embodiment, the data value change notification may include the new value of the data. The propagated changes may include changing what is displayed by the web application and may entail further data queries sent through the messaging module <b>112</b> and received by the receiving module <b>114</b>. In an example embodiment, the updating module <b>116</b> receives notification of a data value change and propagates that change to the web application <b>108</b> by accessing the DOM <b>115</b> of the web application to alter affected elements. In an example embodiment, the watches <b>117</b> cause changes to the web application <b>108</b> by executing functions, which may be facilitated by the updating module <b>116</b>, which accesses the DOM <b>115</b> of the web application and alters affected elements. The watches <b>117</b> are part of the incremental computing application and are used to update the DOM. In an example embodiment, we use values with side-effects, called watches, to update the DOM in response to changes in other rvalues.</p>
<p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. 2</figref> is an illustrative block diagram of a system <b>200</b> that analyzes web application source code and implements web-based incremental computing, according to an example embodiment. An application developer may write source code <b>202</b> defining a web application. In an example embodiment, the web application source code <b>202</b> is written in a functional language or a side-effect free imperative language implementation, which means that the code is written in an imperative language and care is taken to ensure that the code does not create side-effects. The source code may be side-effect free only for a limited duration. The application may he written to assume random access to data stored on the web server <b>210</b> or a database server <b>214</b>. The web application source code <b>202</b> is provided to a compiler <b>204</b> that may translate the source code <b>202</b> to interpreted code <b>206</b>, such as, but not limited to, JavaScript or other functional or imperative languages that may be run on a web client <b>212</b>, such as, but not limited to, MICROSOFT INTERNET EXPLORER&#xae;, a web server <b>210</b> or any machine that may request data from a server. In an example embodiment, the compiler provides JavaScript code that can be run on the web client <b>212</b> of a client machine <b>208</b> or a web server <b>210</b>. Alternatively, the code can be written directly in JavaScript so as not to require a compiler. The code <b>206</b> implements the process of monitoring data value changes and updating data presented through the web application <b>108</b>, specifically, user interface data, in a fashion compliant with the tenants of incremental computing. In an example embodiment, the interpreted code <b>206</b> monitors data values through watches that update the web application through the DOM of the webpage. A web client <b>212</b> on a client machine <b>208</b> may execute the interpreted code <b>206</b> to monitor and request data from a web server <b>210</b> or a database server <b>214</b>. A data request to the web server <b>210</b> may result in a query from the web server <b>210</b> to the database server <b>217</b>. The interpreted code <b>206</b> may also be executed on a web server <b>210</b> to request data from a database server <b>214</b> or to push data and instructions to the web application <b>108</b>.</p>
<p id="p-0041" num="0040"><figref idref="DRAWINGS">FIGS. 3A-3B</figref> are illustrative drawings of a first reactive value hierarchy structure (<figref idref="DRAWINGS">FIG. 3A</figref>) encoded in a computer readable storage device that corresponds to a function. that can be decomposed into reactive values and executed on a computing system and a process to update the structure in response to changes in one or more reactive values (<figref idref="DRAWINGS">FIG. 3B</figref>) in accordance with some embodiments. In accordance with some embodiments the hierarchy is a directed acyclic graph (DAG) structure. Significantly, reactive values can have more than one dependent values, which is permitted in a DAG structure.</p>
<p id="p-0042" num="0041">Referring to <figref idref="DRAWINGS">FIG. 3A</figref>, a first example function, F=(A*B)+C, can be decomposed into reactive values, A, B, (A*B) and C, which are listed herein in order of their input to and use in the function. The first reactive value hierarchy structure <b>30</b> represents hierarchical dependency and input order relationships among nodes and corresponding reactive values used in the first function. For example, reactive value (A*B) which corresponds to node <b>34</b> is dependent upon reactive values A and B which correspond to nodes <b>36</b> and <b>38</b>, and conversely, reactive values A and B which correspond to nodes <b>36</b> and <b>38</b> are inputs to node <b>34</b> which corresponds to reactive value (A*B).</p>
<p id="p-0043" num="0042">The first reactive value hierarchy structure <b>30</b> also represents order of input to and use of reactive values within the first function. Relative positioning of node <b>36</b> which corresponds to value A to the left of node <b>38</b> which corresponds to value B and relative positioning of node B to the left of node C indicates an ordering of nodes <b>36</b>, <b>38</b> and <b>40</b> that corresponds to the ordering of reactive values A, B and C in the first function. Likewise, ordering of node <b>32</b> which corresponds to (A*B) to the left of node <b>40</b> indicates an ordering of nodes <b>32</b> and <b>40</b> that corresponds to the ordering of reactive values (A*B) and C in the first function.</p>
<p id="p-0044" num="0043">Referring to <figref idref="DRAWINGS">FIG. 3B</figref>, there are shown example path traversals used to update the first hierarchy structure <b>30</b> in response to changes in reactive values. In this example, assume that reactive values B and C have changed. Corresponding nodes <b>38</b> and <b>40</b> are marked as &#x2018;dirty&#x2019; (D) since the input values corresponding to nodes <b>38</b> and <b>40</b> have changed. Moreover, nodes <b>34</b> and <b>32</b> are marked as &#x2018;possibly dirty&#x2019; (P) since they correspond to reactive values that depend upon nodes that have changed and have been marked as dirty.</p>
<p id="p-0045" num="0044">A traversal downward from root node <b>32</b> starts with path (1) from node <b>32</b> to node <b>34</b>. Since node <b>34</b> is possibly dirty, traversal downward continues on path (2) to node <b>32</b>, which is not dirty and therefore clean. Traversal proceeds back upward on path (3) to node <b>34</b>, which is the dependent node of node <b>36</b> from which the downward traversal to node <b>36</b> proceeded. Since node <b>34</b> remains possibly dirty, traversal proceeds downward to the next in order node <b>38</b> on path (4). Node <b>34</b> is dirty and traversal proceeds back up to node <b>34</b> on path (5). Since input node <b>38</b> of node <b>34</b> was found to be dirty, a compute (indicated by C=6) of the reactive value corresponding to node <b>34</b> takes place. As a result of the compute, bode <b>34</b> is no longer possibly dirty. Assume for this example that node <b>34</b> computes to a value no different from its prior value and is determined to be not changed, and therefore, clean. Traversal upwards through the hierarchy then proceeds on path (7) from node <b>34</b> to node <b>32</b>. Next, since node <b>32</b> is possibly dirty, traversal proceeds to the next in order input node <b>40</b> on path (8). Node <b>40</b> is dirty, and traversal proceeds on path (9) back upward to node <b>32</b> where a new reactive value corresponding to node <b>32</b> is computed (indicated by C=10)</p>
<p id="p-0046" num="0045">It will be appreciated that the description of <figref idref="DRAWINGS">FIGS. 3A-3B</figref> is general in nature and is provided by way of overview. Additional details of embodiments are provided below.</p>
<p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. 4A</figref> is an illustrative drawing of a second reactive value hierarchy structure <b>400</b> in accordance with some embodiments. Table 1 shows a second example function in computer program pseudo-code form, containing reactive values that correspond to the nodes of the reactive value hierarchy structure of <figref idref="DRAWINGS">FIG. 4A</figref>. The reactive value hierarchy structure indicates hierarchy relationships among nodes that represent hierarchy relationships among reactive values of the example function. For instance, according to the function and the hierarchy structure, the reactive value (X+Y) that corresponds to node R3 depends upon reactive value X that corresponds to node X and depends upon reactive value Y that corresponds to node Y.</p>
<p id="p-0048" num="0047">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="35pt" align="left"/>
<colspec colname="2" colwidth="119pt" align="left"/>
<colspec colname="3" colwidth="35pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="3" rowsep="1">TABLE 1</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry/>
<entry>f( ){</entry>
<entry/>
</row>
<row>
<entry/>
<entry/>
<entry>if(x==1)</entry>
<entry/>
</row>
<row>
<entry/>
<entry/>
<entry>return &#x3c;p&#x3e; (X+Y), (Z+1) &#x3c;p&#x3e;;</entry>
<entry/>
</row>
<row>
<entry/>
<entry/>
<entry>else</entry>
<entry/>
</row>
<row>
<entry/>
<entry/>
<entry>return (N+1);</entry>
<entry/>
</row>
<row>
<entry/>
<entry/>
<entry>}</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0049" num="0048">The illustrative second reactive value hierarchy structure <b>400</b> of <figref idref="DRAWINGS">FIG. 4A</figref> is produced in the course of execution of the example function of Table 1. More specifically, a processor is configured to execute the example function of Table 1 a first time with mutable value assignments to be X=1; Y=2; Z=3. No value is computed for (N&#x2212;1) since that reactive value is not in use in the first pass. The processor is further configured to produce the reactive value hierarchy structure in the course of the use of the reactive values during execution of the function to represent relationships among the reactive values during execution of the function.</p>
<p id="p-0050" num="0049">In this illustrative example, the second function has been parsed into reactive values X, Y, Z, N, (X==1), (X+Y), (Z+1.) and (N+1). Reactive values X, Y, Z and N are mutable reactive values. It will be appreciated that the granularity of parsing of a function into reactive values is a matter of design choice and may be accomplished automatically at compile time or may be accomplished at runtime either automatically or manually. As shown in <figref idref="DRAWINGS">FIG. 4A</figref>, mutable values X, Y and Z of the function, respectively, correspond to nodes X, Y and Z of the reactive value hierarchy structure. Reactive value (X==1) of the function corresponds to node R1 of the reactive value hierarchy structure. Reactive value (X+Y) of the function corresponds to node R3 of the reactive value hierarchy structure. Reactive value (Z+1) of the function corresponds to node R4 of the reactive value hierarchy structure. A reactive value corresponding to node R0 acts to observe whether reactive value R1 (X==1) is TRUE or FALSE, and if TRUE, then the reactive value corresponding to R0 returns the reactive value (corresponding to node R2 and if FALSE returns the reactive value (N+1). In this example, the reactive value (X==1) returns TRUE.</p>
<p id="p-0051" num="0050">Referring again to <figref idref="DRAWINGS">FIG. 4A</figref>, the hierarchy structure is encoded in computer readable storage device. The hierarchy structure defines DAG relationships among reactive values. The hierarchy structure includes a root node R0. Node R0 is associated directly in the hierarchy structure with node R1 and node R2, since no other nodes intervene between node R0 and R1 or between node R0 and node R2.</p>
<p id="p-0052" num="0051">Node R0 is associated directly with node W0, a watch node, which is a dependent node of node R0. Conversely, node R0 is an input node to node W1.</p>
<p id="p-0053" num="0052">Node R1 is associated with node R0 as an input node to node R0, and node R0 is associated with node R1 as a dependent node of node R1. Similarly, node R2 is associated with node R0 as an input node to node R0, and node R0 is associated with node R2 as a dependent node of node R2. Node R1 is directly associated with node X, which corresponds to a mutable value X. Node X is associated with node R1 as an input node to node R1. node R1 is associated with node X as a dependent node of node X. Accordingly, as used herein, the term reactive value encompasses mutable values.</p>
<p id="p-0054" num="0053">Node R2 is associated directly in the hierarchy structure with node W1 and node W2, since no other nodes intervene between node R2 and node W1 or between node R2 and node W2. Nodes W1 and W2 are watch nodes, which are explained more fully below, that cause side-effects in response to reactive value changes. Node W1 is associated with node R2 as an input node to node R2, and node R2 is associated with node W1 as a dependent node of node W1. Similarly, node W2 is associated with node R2 as an input to node R2, and node R2 is associated with node W2 as a dependent node of node W2.</p>
<p id="p-0055" num="0054">Node W1 is associated directly in the hierarchy structure with node R3, since no other nodes intervene between node W1 and node R3. Node R3 is associated with node W1 as an input node to node W1, and node W1 is associated with node R3 as a dependent node of node R3.</p>
<p id="p-0056" num="0055">Node W2 is associated directly in the hierarchy structure with node R4, since no other nodes intervene between node W2 and node R4. Node R4 is associated with node W2 as an input node to node W2, and node W2 is associated with node R4 as a dependent node of node R4.</p>
<p id="p-0057" num="0056">Node R3 is directly associated with node Y, which corresponds to a mutable value Y. Node Y is associated with node R3 as an input node to node R3, and node R3 is associated with node Y as a dependent node of node Y. Node R3 also is directly associated with node X, which corresponds to a mutable value X. Node X is associated with node R3 as an input node to node R3, and node R3 is associated with node X as a dependent node of node X.</p>
<p id="p-0058" num="0057">Node R4 is directly associated with node Z, which corresponds to a mutable value Z. Node Z is associated with node R4 as an input node to node R4, and node R4 is associated with node Z as a dependent node of node Z.</p>
<p id="p-0059" num="0058">As used herein, the term &#x2018;mutable value&#x2019; signifies a subtype of a reactive value that changes because it is given a new value. A reactive value has the property that it can change and also has the property that it has a dependency relationship with another value such that the reactive value changes in response to a change in other value. A mutable value also can change, but not in response to another value. In the method and system described herein no distinction is made between a value that changes in reaction to a change in another value and a value that changes because it is given a new value. So for the purposes of the system and method described herein, a mutable value is a subtype of a reactive value type.</p>
<p id="p-0060" num="0059"><figref idref="DRAWINGS">FIG. 4B</figref> is an illustrative drawing of the reactive value hierarchy structure <b>400</b> of <figref idref="DRAWINGS">FIG. 4A</figref> annotated to show connectivity state information structures used to implement nodes of the hierarchy structure in accordance with some embodiments. The connectivity state information structures are encoded in computer readable storage device. Each node of the hierarchy <b>400</b> comprises a connectivity state information structure that indicates input node relationships and dependent node relationships with nodes that it is directly associated with. Collectively, the nodes' connectivity state information structures define the structure of the reactive value hierarchy structure. For example, an R0 connectivity state information structure indicates that node R0 is associated with nodes R1 and R2 as input nodes to node R0 and has the null set as nodes associated with R0 as dependent nodes of R0. Also, for example, an R3 connectivity state information structure indicates that node R3 is associated with nodes X and Y as input nodes to node R3 and is associated with node R2 as a dependent node of R3.</p>
<p id="p-0061" num="0060">The reactive value hierarchy structure <b>400</b> also indicates precedence order of operations of the example function. In the example reactive value hierarchy structure of <figref idref="DRAWINGS">FIG. 4A</figref>, nodes are shown ordered left-to-right to match the order in which their corresponding reactive values are used during execution of the example function. For example, the first reactive value used in the execution of function is reactive value X corresponding to node X, and the first reactive value computed is (X==1) corresponding to node R1. Accordingly, node X and R0 are ordered to the left of the other nodes in the graphs. This ordering is indicated in the connectivity state information structures of <figref idref="DRAWINGS">FIG. 4B</figref>, which indicate ordered sets of one or more input nodes. The ordering of the inputs corresponds to the order in which reactive values corresponding to the inputs are used in the course of execution of the function. Referring to the R0 connectivity state information structure, the inputs are ordered first R1 and then R2 because R1 is used by the function before R2 is used. For example, referring to the R3 connectivity state information structure, the inputs are ordered first X and then Y because X is used by the function before Y is used.</p>
<p id="p-0062" num="0061">The ordering of nodes according to order of reactive value use by the function is significant. A function may contain a conditional or branch such that the reactive values used in one part of the function may depend upon the reactive values computed in another part of the function. Thus, conditional or branch decisions by the function may influence the validity of portions of the reactive value hierarchy structure in subsequent executions of the function in which a different conditional or branch decisions are a possibility. More specifically, conditional or branch decisions may influence the validity of connectivity state information such as that shown in <figref idref="DRAWINGS">FIG. 4B</figref>.</p>
<p id="p-0063" num="0062">Continuing with the example of the first time execution of the function of Table 1, mutable value X=1. Therefore, reactive value (X==1) is TRUE, and the function branches to &#x2018;return &#x3c;p&#x3e;(X+Y), (Z+1)&#x3c;p&#x3e;&#x2019;. Thus, there is no use of reactive value (N+1) during the first run of the example function. This branch by the function, which is dependent upon the value of mutable value X is captured in the connectivity state information of <figref idref="DRAWINGS">FIG. 4B</figref>, which includes connectivity state information that correspond to reactive values Y, Z, (X+Y) and (Z+1), but that does not include nodes that correspond to reactive values N or (N+1).</p>
<p id="p-0064" num="0063">Still continuing with the example, assume that following construction of the reactive value hierarchy structure of <figref idref="DRAWINGS">FIG. 4A</figref>, the mutable value assignments change to X=0; Y=2; Z=3; and N=1. This change in reactive/mutable values is detected by an API (Application Programming Interface) that records each changed mutable value, marks the values as dirty and propagates the changes to the graph <b>400</b>. Thus, in response to the change in reactive values, change state information is produced for nodes within the hierarchy.</p>
<p id="p-0065" num="0064"><figref idref="DRAWINGS">FIG. 4C</figref> is an illustrative drawing of the reactive value hierarchy structure <b>400</b> of <figref idref="DRAWINGS">FIG. 4A</figref> marked with information in associated data structures to show change state information structures containing change state information produced in response detection of one or more changed reactive values in accordance with some embodiments. The change state information structures are encoded in a computer readable storage device and are associated with nodes in the hierarchy.</p>
<p id="p-0066" num="0065">The change state information structures include a first change indication of whether a reactive value corresponding to an associated node is &#x2018;dirty&#x2019;. An indication that a node is &#x2018;dirty&#x2019; signifies that the corresponding reactive value must be computed. A node is dirty if a reactive value of one of its input nodes changes. Such a change may result from a change in a mutable value associated with an input node, for example. Such a change also may result when a new value is computed for a reactive value of an input node to a node, and the new value is different from a previous value associated with the input node. However, an indication that marks an associated node as not dirty (i.e. &#x2018;!dirty&#x2019;) leaves open the possibility that the associated node may become dirty. The first change indication (i.e., the dirty state) of a node may change in the course of exploration of the hierarchy to determine which reactive values need to be computed and which do not. When a dirty state of a node becomes &#x2018;dirty&#x2019;, then the reactive value associated with that node needs to be computed before its value can be used by another node in the hierarchy. However, if a reactive value associated with a node is no longer used in the course of a function to which the hierarchy corresponds, due to a conditional branch for example, then the reactive value need not be computed for that dirty node. As explained below, computation of an updated value for a dirty node may result in arrival at the same value that the reactive value had previously or in arrival at a new changed reactive value. The change state information structure also includes a second change indication to indicate whether changes to reactive values corresponding to other nodes upon which an associated node depends may require a computation of the reactive value corresponding to that associated node. In some embodiments, the second change indication comprises a count referred to as a &#x2018;dirty count&#x2019;, which is a count of the number of direct inputs to a given node that are possibly dirty. The dirty count, is useful to avoid unnecessary traversal effort in determining which nodes, if any, require a compute. The dirty count of a node is adjusted in the course of exploration of the hierarchy to determine which reactive values need to be computed and which do not. When a dirty count associated with a node is adjusted so as to become &#x2018;0&#x2019; then traversal down through the hierarchy from that node in search of dirty nodes can stop.</p>
<p id="p-0067" num="0066"><figref idref="DRAWINGS">FIG. 5</figref> is an illustrative flow diagram of a traversal and change state traversal process <b>500</b> to traverse the reactive value hierarchy structure <b>400</b> of <figref idref="DRAWINGS">FIG. 4A</figref> in accordance with some embodiments. <figref idref="DRAWINGS">FIG. 6</figref> is an illustrative flow diagram of a second change state determination process <b>600</b> that runs in conjunction with the change state traversal process <b>500</b>. In some embodiments, the second change state determination process <b>600</b> adjusts dirty count for individual nodes of the hierarchy. The processes are implemented with computer program code, and each module of the flow diagrams represents configuration of a processor to implement the act specified for the module.</p>
<p id="p-0068" num="0067">Referring to <figref idref="DRAWINGS">FIG. 5</figref>, module <b>502</b> selects a changed reactive value. Module <b>504</b> sets the first change state information to dirty for the selected changed reactive value to indicate that the reactive value has changed. Module <b>506</b> selects a dependent node of the changed reactive value that has not yet had state change information adjusted in view of the currently selected changed reactive value. Module <b>508</b> traverses upward through the hierarchy from the currently selected dependent node based upon connectivity state information, such as that in <figref idref="DRAWINGS">FIG. 4B</figref>, and increments second change state information, such as the dirty count information, associated with nodes along the way according to the second change state determination process <b>600</b> of <figref idref="DRAWINGS">FIG. 6</figref>. Upon completion of a traversal to the highest node in the hierarchy that corresponds to a reactive value that is transitively dependent upon the currently selected changed reactive value, decision module <b>510</b> determines whether there is an additional node that is directly dependent upon the selected changed reactive value and that has not yet had state change information adjusted in view of the currently selected changed reactive value. If yes, then control returns to module <b>506</b> and that other dependent node is selected, and modules <b>508</b> traverses from that next selected directly dependent node. If no, then control flows to decision module <b>512</b>, which determines whether there is another changed value that has not been selected in module <b>502</b>. If yes, then control flows to module <b>502</b> and another changed value is selected. If no, then the process <b>500</b> ends.</p>
<p id="p-0069" num="0068">Referring to <figref idref="DRAWINGS">FIG. 6</figref>, module <b>602</b> adjusts a given node's second change information. In some embodiments, the given node's second change information comprises a count, and the adjustment involves incrementing the count referred to as the dirty count. The second change information for a given node may be dependent, transitively or directly, upon one or more changed reactive values lower in the hierarchy. As explained with reference to <figref idref="DRAWINGS">FIG. 5</figref>, the second change information for each different changed reactive value that reactive value corresponding to the given node is dependent upon is propagated to the given node by a different input node for which the given node is a dependent node. Thus, for example, if the given node is dependent, either transitively or directly, upon two changed reactive values, then the dirty count for the reactive node is incremented by two.</p>
<p id="p-0070" num="0069">Module <b>604</b> propagates second changed information from the given node to each node that corresponds to a reactive value that is directly dependent upon the reactive value that corresponds to the given node. More particularly, when the dirty count associated with a given node previously had second change information indicating that the given node was previously clean, e.g., a dirty count of zero (0), and the second change information for the given node changes, e.g., the dirty count increments from zero (0) to one (1), to indicate that the given node has become possibly dirty, module <b>604</b> increments the dirty count of each node that is directly dependent upon that given node. More particularly, in response to a given node corresponding to a reactive value either (i) becoming dirty when it was not previously dirty or (ii) having a dirty count, DC&#x3e;0, when it's dirty count was not previously a dirty count DC&#x3e;0, module <b>604</b> causes the dirty count of each node that is a direct dependent of that node is incremented. Subsequent incrementing of the dirty count of that given node does not result in module <b>604</b> causing additional incrementing of dirty counts of direct dependents to that given node.</p>
<p id="p-0071" num="0070">The term &#x2018;given node&#x2019; as used herein is shorthand for an arbitrary node within the hierarchy. In general, the descriptions of behavior relative to a given node is applicable to other similarly situated nodes within the hierarchy.</p>
<p id="p-0072" num="0071">Continuing again with the example, the processes <b>500</b>, <b>600</b> of <figref idref="DRAWINGS">FIGS. 5-6</figref> are explained with reference to <figref idref="DRAWINGS">FIGS. 4B-4C</figref>. Module <b>502</b> selects changed reactive value X that corresponds to node X. Module <b>504</b> marks the first state information associated with node X as &#x2018;dirty&#x2019; as shown in <figref idref="DRAWINGS">FIG. 4C</figref>. Marking the node X as dirty ensures that dependent nodes of node X need to compute new reactive values. Module <b>506</b> selects dependent node R1 and causes traversal up through the hierarchy to node R0. Module <b>508</b> uses the connectivity information shown in <figref idref="DRAWINGS">FIG. 4B</figref> to find the traversal path from node X to node R1 to node R0. In the course of the traversal, the process <b>600</b> of <figref idref="DRAWINGS">FIG. 6</figref> causes incrementing by one of second change information, the dirty count, of both nodes R1 and R0. Decision module <b>510</b> determines that node X has another dependent node, and module <b>506</b> selects node R3. Module <b>508</b> uses the connectivity information shown in <figref idref="DRAWINGS">FIG. 4B</figref> to find the traversal path from node X to node R3 and to node W1 and to node R0. In the course of the traversal, the process <b>600</b> of <figref idref="DRAWINGS">FIG. 6</figref> causes incrementing by one of second change information, the dirty counts, of nodes R3, W1, R2 and R0. Decision module <b>510</b> determines that there are no more dependent nodes of node X.</p>
<p id="p-0073" num="0072">Module <b>502</b> selects changed reactive value Z that corresponds to node Z. Module <b>504</b> marks the first state information associated with node Z as &#x2018;dirty&#x2019;. Marking the node Z as dirty ensures that dependent nodes of node Z need to compute new reactive values. Module <b>506</b> selects dependent node R4 and causes traversal up through the hierarchy to node W2, to node R2 and to node R0. Module <b>508</b> uses the connectivity information shown in <figref idref="DRAWINGS">FIG. 4B</figref> to find the traversal path from node X to node R3 and to node W1 and to node R0. In the course of the traversal, the process <b>600</b> of <figref idref="DRAWINGS">FIG. 6</figref> causes incrementing by one of second change information, the dirty counts, of nodes R4, W2 and R2. Note that the dirty count of R0, which is &#x2018;2&#x2019; as shown in <figref idref="DRAWINGS">FIG. 4C</figref>, is not incremented due to this traversal from node Z since module <b>604</b> previously propagated a dirty count increment from node R2 to R0. Decision module <b>510</b> determines that there are no more dependent nodes to node Z. Decision module <b>512</b> determines that there are no more changed reactive values. The traversal process <b>500</b> ends.</p>
<p id="p-0074" num="0073">It will be noted that the change state structures in <figref idref="DRAWINGS">FIG. 4C</figref> that have dirty count (DC)&#x3e;1 are marked with &#x201c;P&#x201d;, which stands for &#x2018;possibly dirty&#x2019; state. A possibly dirty state is inferred for a node that had not been marked as &#x2018;dirty&#x2019;, but that has DC&#x3e;0. A node is &#x2018;clean&#x2019; if it is &#x2018;!dirty&#x2019; (i.e. not dirty) and its associated DC=0.</p>
<p id="p-0075" num="0074">After change state has been determined according to processes <b>500</b> and <b>600</b>, the function is executed a second time, but with the aid of the reactive value hierarchy structure annotated with change state information such as that shown in the example drawing of <figref idref="DRAWINGS">FIG. 4B</figref>. In the course of the second execution of the function, the hierarchy is traversed to determine which reactive values need to be recomputed in response to the changed reactive values. New values are computed only for those reactive values provided for in the hierarchy that require computation according to the traversal. As explained more fully below, if the second execution of the function branches to an execution path different from that used during the first execution of the function, then values for reactive values on that different execution path that are not included within the hierarchy may have to be computed. Moreover, if the function branches to a different execution path the second time, then some reactive values within the hierarchy may become obsolete.</p>
<p id="p-0076" num="0075"><figref idref="DRAWINGS">FIGS. 7A-7C</figref> are illustrative drawings of three aspects of a recursive process in accordance with some embodiments to traverse the hierarchy to ensure that reactive values are current by identifying reactive values that need to he computed and by computing new values for the identified reactive values. FIG. <b>7</b>A is an illustrative flow diagram representing a first process <b>700</b> to investigate possibly nodes directly input nodes to a given node to determine whether any of them is dirty. <figref idref="DRAWINGS">FIG. 7B</figref> is an illustrative flow diagram representing a second process <b>740</b> to compute a reactive value for a node when it is determined to be dirty and to adjust change state information of nodes dependent upon the given node. <figref idref="DRAWINGS">FIG. 7C</figref> is an illustrative flow diagram representing a third process <b>780</b> to return a reactive value of a given node to a dependent node. The processes are implemented with computer program code, and each module of the flow diagrams represents configuration of a processor to implement the act specified for the module.</p>
<p id="p-0077" num="0076">Referring to <figref idref="DRAWINGS">FIG. 7A</figref>, decision module <b>702</b> monitors dirty count (DC) and dirty status for a given node. While DC&#x3e;0 and dirty status is not dirty (?dirty), module <b>704</b> requests the performance of the recursive process (<figref idref="DRAWINGS">FIGS. 7A-7C</figref>) on each input node in order to the given node. The given node gets a return value from each input node that completes the recursive process. It will be appreciated that the while the given node is possibly dirty, the first process <b>700</b> traverses downward through the hierarchy to its direct input nodes. One or more of those direct input nodes, in turn, may traverse down to its direct input node. This downward traversal continues until a node that is marked dirty is encountered whereupon the second process <b>740</b> runs. If the decision module <b>702</b>, determines that for the given node the condition [DC&#x3e;0 &#x26;&#x26; !dirty] is not true, then the checking of input nodes by module <b>704</b> stops and control flows to the second process <b>740</b></p>
<p id="p-0078" num="0077">Referring to <figref idref="DRAWINGS">FIG. 7B</figref>, decision module <b>742</b> determines whether the given node's dirty state indicates that the given node is dirty. If yes, then module <b>746</b> computes an updated value for the reactive value and stores it in cache associated with the given node. In computing an updated value for a reactive value, module <b>746</b> calls the function for that reactive value. If that called function, in turn, calls for other reactive values. The module <b>746</b> calls such reactive values in the order in which they are to be computed. The module <b>746</b> runs the recursive function <b>700</b> on each called reactive value.</p>
<p id="p-0079" num="0078">For example, assume that module <b>746</b> is to compute an updated value for node R3. Pursuant to the second example function, module <b>746</b> first gets the value for X. Getting the value for X involves running the recursive process <b>700</b> on node X. Second, according to the second example function, module <b>746</b> gets the value for Y. Getting the value for Y involves running the recursive process <b>700</b> on node Y. Next, the module <b>746</b> computes (X+Y) using the updated values that have been obtained. Note that the module <b>746</b> obtained the updated reactive values for nodes X and V in the order in which the second example function uses the respective values: first, X, and second, Y.</p>
<p id="p-0080" num="0079">Once a newly computed value has been determined, decision module <b>748</b> determines whether the newly computed value for the reactive value is changed from a previously computed previously cached value for the reactive value. If yes, then module <b>750</b> marks all direct dependents of the given module as &#x2018;dirty&#x2019;. In other words, module <b>750</b> adjusts the change state information associated with dependent nodes of the given node from not dirty to dirty. Note that if a dependent node already is marked &#x2018;dirty&#x2019;, then no change is required to mark that node dirty. Next, module <b>752</b> resets the dirty state of the given node to not dirty (!dirty). Module <b>754</b> decrements the dirty count of all direct dependents of the given node. If after decrementing a direct dependent node's dirty count or changing its dirty state to FALSE, the DC state of that node is zero (0) and the node is marked as not dirty then the dirty count on all dependent nodes to that node must be decremented. This evaluation is repeated at each dependent node and at each level of dependent nodes. Thus, there can be a ripple effect in the propagation of &#x2018;no longer possibly dirty&#x2019; state information up through the hierarchy <b>400</b>. Module <b>756</b> returns the cached value to the dependent node of the given node that requested that the first process <b>700</b> run on the given node.</p>
<p id="p-0081" num="0080">It will be appreciated that the first process <b>700</b> causes a systematic traversal downward through the hierarchy from a given possibly dirty node in search of a changed reactive value, but once a changed reactive value is located (i.e., a dirty reactive value is located) in the course of the downward traversal, an updated value for that changed reactive value is computed and dirty counts of all direct dependents are updated, using the second process <b>740</b>, which causes the traversal to move back up a level to the given node. More specifically, module <b>704</b>'s causing the first process <b>700</b> to address each of the input nodes, in order one after another, lower in the hierarchy effects a systematic downward traversal that ultimately is interrupted by the running of the second process <b>740</b> to address the changed reactive value of some node lower in the hierarchy. Thus, overall, the search process is thorough but is cut short when meaningful information, i.e. a dirty node, is identified.</p>
<p id="p-0082" num="0081">It also will be appreciated that the second process <b>740</b> averts propagating dirty status upward through the hierarchy if a changed reactive value lower in the hierarchy does not result in a change in a related reactive value higher in the hierarchy. Specifically, module <b>750</b> marks dependent nodes as dirty only if the computed reactive value for the given node is changed from a previously cached reactive value for the given node. Thus, if a reactive value change occurring lower in the hierarchy that resulted in the given node's being marked as &#x2018;dirty&#x2019; does not actually result in a change in the reactive value of the given node, then the given node does not percolate the dirty status upward in the hierarchy and the affect of the changed reactive value lower in the hierarchy fizzles out at the level of the given node.</p>
<p id="p-0083" num="0082">Moreover, if a change simultaneously causes a node associated with a first reactive value to become dirty and also causes a second reactive value to stop depending upon the first reactive value, then a new reactive value for the first reactive value will not be computed. More particularly, the process starts at the root rvalue and traverses a DAG looking for dirty rvalues. As rvalues are recomputed their inputs may change. An rvalue is recomputed only after it is known that the rvalue will still be in use after the change has been fully propagated. This ensures that rvalues will not be recomputed only to later become unused in the same propagation.</p>
<p id="p-0084" num="0083">Referring to <figref idref="DRAWINGS">FIG. 7B</figref>, if decision module <b>742</b> determines that the given node is not dirty, then control flows to the third process <b>780</b>.</p>
<p id="p-0085" num="0084">Referring to <figref idref="DRAWINGS">FIG. 7C</figref>, decision module <b>782</b> determines whether a previous reactive value was cached for the given node. If not, then module <b>784</b> calls for the first process <b>100</b> to run on each input node to the given node. It will be appreciated that since the given node is not marked dirty, none of the input nodes to the given node contain changed reactive values, and each such input node should revert to the same third process <b>780</b> and return values to the given node. Module <b>786</b> uses the values returned due to module <b>784</b> to compute a reactive value for the given node and to store it in cache. Module <b>788</b> returns the reactive value to the node that requested that the first process <b>100</b> be run on the given node. If decision module <b>782</b> determines that the given node has a previously cached value already, then control flows to module <b>788</b>, which returns the reactive value to the node that requested that the first process <b>100</b> be run on the given node.</p>
<p id="p-0086" num="0085">Continuing with the above example and referring to <figref idref="DRAWINGS">FIGS. 4B-4C</figref>, the recursive process of <figref idref="DRAWINGS">FIGS. 7A-7C</figref> begins with an instance of the recursive process running on the root node R0. It will be appreciated that &#x2018;running on the root node&#x2019; means running and processing data associated with the root node R0. Referring to <figref idref="DRAWINGS">FIG. 4C</figref>, the change state data for the root node R0 shows that R0 is possibly dirty (P) since DC&#x3e;0. Specifically, DC=2 for node R0. Therefore, an instance of process <b>700</b> runs on R0. <figref idref="DRAWINGS">FIG. 4B</figref> includes R0 state information associated with R0 that shows the ordering of input nodes R1 and R2 to R0. Pursuant to decision module <b>702</b> and module <b>704</b>, the process <b>100</b> running on the root node R0 requests that the recursive process run on node R1, which is the first in order input node to R0, and waits for a return from R1.</p>
<p id="p-0087" num="0086">Next, an instance of the recursive process runs on node R1, and the instance of recursive process running on node R0 waits for a return from R1. Referring to <figref idref="DRAWINGS">FIG. 4C</figref>, the change state data for node R1 shows that R1 is possibly dirty (P) since DC=12 and the dirty state is set to not dirty. Therefore, pursuant to decision module <b>702</b> and module <b>704</b>, the process <b>100</b> running on node R1 requests that the recursive process run on node X, which is the only input node to R0, and waits for a return from node X.</p>
<p id="p-0088" num="0087">The recursive process runs on node X, and the instance of the recursive process running on node R1 waits for a return from node X. Referring to <figref idref="DRAWINGS">FIG. 4C</figref>, the change state data for node X shows that X is dirty Therefore, process <b>740</b> runs. Since X corresponds to a mutable value no actual computation is required, and the changed value of X is put into cache pursuant to module X. Since the value of X changed (from X=1 in <figref idref="DRAWINGS">FIG. 4B</figref> to X=1 in <figref idref="DRAWINGS">FIG. 4C</figref>) module <b>750</b> causes the dirty states of both nodes R1 and R3, which are direct dependent nodes of node X to become &#x2018;dirty&#x2019;. Pursuant to module <b>752</b>, the dirty state of node X is set to not dirty; pursuant to module <b>754</b>, the dirty counts of each of nodes R1 and R3 the direct dependent nodes of node X are decremented by 1. The newly cached value of node X is returned to the waiting recursive process running on node R1 pursuant to module <b>756</b>.</p>
<p id="p-0089" num="0088">Module <b>704</b> of the instance of the recursive process running on R1 asks for X's value. Since X is now clean, module <b>704</b> returns the cached value of X to node R1.</p>
<p id="p-0090" num="0089">The instance of the recursive process running on R1 receives the returned changed value of X. Since the value associated with R1 has changed, module <b>750</b> sets the dirty state of R0 to dirty; module <b>752</b> sets the dirty state of R1 to not dirty; module <b>754</b> decrements the dirty count of R0 by 1 (to DC=1); and module <b>756</b> returns the new value (a branch decision in this case) to R0.</p>
<p id="p-0091" num="0090">The instance of the process running on node R0 receives the returned value and notes that the R0 change state information now indicates that R0 is dirty. Pursuant to module <b>746</b>, the process running on R0 requests that the recursive process run on node R1 After receiving a return from node R1, and pursuant to module <b>744</b>, the process running on R0 requests that the recursive process run on node R2.</p>
<p id="p-0092" num="0091">Note that in this second time running the function, the branch decision branches to a different execution path. This time, since X=0, the conditional statement (X==1) results in a branch to reactive value (N=1).</p>
<p id="p-0093" num="0092"><figref idref="DRAWINGS">FIG. 8</figref> is an illustrative flow diagram representing a process <b>800</b> to update the reactive value hierarchy structure and to remove invalid state information in the event that the function uses a different branch during different runs. The process <b>800</b> runs in the course of the running of the recursive process (<figref idref="DRAWINGS">FIGS. 7A-7C</figref>). For each given node visited (i.e. on which the recursive process runs), module <b>802</b> determines whether the node has a changed reactive value. Referring to <figref idref="DRAWINGS">FIG. 7B</figref>, module <b>748</b> may serve as a source of changed value information. If no, the process ends for that node. If yes, then decision module <b>804</b> determines whether the node is a branch node. If no, then the process ends for that node. If yes, then module <b>806</b> updates the hierarchy graph to add reactive values for the new branch and to remove from the hierarchy reactive values that were used in the previous branch but that are not used in the current branch. Module <b>808</b> removes change state information used during graph traversal that is invalid in view of the modifications to the hierarchy graph due to the new branch.</p>
<p id="p-0094" num="0093">Continuing again with the example, and referring to <figref idref="DRAWINGS">FIG. 4A</figref> and to <figref idref="DRAWINGS">FIG. 9</figref>, and to <figref idref="DRAWINGS">FIG. 7B</figref>, assume that module <b>746</b> is to compute an updated reactive value for node R1. According to the second example function, module <b>746</b> gets a reactive value for node X. Getting a reactive value for node X involves running the process <b>700</b> on node X.</p>
<p id="p-0095" num="0094">First, assume that as shown in <figref idref="DRAWINGS">FIG. 4A</figref>, the value returned for X of X is 1. Module <b>746</b> runs the function associated with node R1 which calls node R2, which corresponds to reactive value &#x2018;&#x3c;P&#x3e; . . . &#x3c;P&#x3e;&#x2019; since (X==1) evaluates to TRUE.</p>
<p id="p-0096" num="0095">Next, assume instead that as shown in <figref idref="DRAWINGS">FIG. 9</figref>, the value returned for X of X is 0. Module <b>746</b> runs the function associated with node R1 which calls node R5, which corresponds to reactive value (N+1), since (X==1) evaluates to FALSE.</p>
<p id="p-0097" num="0096">Thus, as between <figref idref="DRAWINGS">FIGS. 4A-4C</figref>, and <figref idref="DRAWINGS">FIG. 9</figref>, computing node R1 for different reactive values for X between a first execution of the second example function (where X has the value 1) and a second execution of the second example function (where X has the value 0) results in different branch execution paths for the function: to node R2 the first time and to node R5 the second time.</p>
<p id="p-0098" num="0097">The different branch execution paths result in changes to the hierarchy as explained with reference to <figref idref="DRAWINGS">FIG. 8</figref>.</p>
<p id="p-0099" num="0098"><figref idref="DRAWINGS">FIG. 8</figref>, the processor configured to run the function also is configured to implement the process <b>800</b>. Module <b>802</b> determines that R1 has a changed reactive value, and module <b>804</b> determines that R1 is a reactive value branch. Accordingly, module <b>806</b> modifies the reactive value hierarchy graph structure as shown in <figref idref="DRAWINGS">FIG. 9</figref> to represent relationships among reactive values used during execution of the function using the (N+1) branch path. Node R5, which corresponds to reactive value (N+1) has been substituted in place of R2 in the hierarchy. Moreover, the strike-out (i.e. x) through the &#x2018;R2&#x2019; in the R0 connect state information indicates that module <b>806</b> has removed node R2 as an input node to R0. Conversely, the presence of R5 in the R0 connect state information indicates that module <b>806</b> has added node R5 as an input to R0. Thus, reactive values corresponding to node R2 have become obsolete during execution of the function using the (N+1) branch. By the transitive property, removal of R2 also removes W1, and removal of W1 also removes nodes R3 and Y from the hierarchy. Additionally, removal of R2 also removes node W2, and removal of W2 also removes nodes R4 and Z from the hierarchy. Thus, reactive values corresponding to nodes R3, Y, R4 and Z also have become obsolete during execution of the function using the (N+1) branch, Module <b>808</b> observes the DC information associated with removed nodes that marks those nodes as possibly dirty and that acts to decrement the DC of remaining nodes (i.e. nodes that are not obsolete) dependent upon the removed possibly dirty nodes. In this example, the DC for R0 is decremented by 2 as indicated by the strike-out through &#x201c;2&#x201d; in the R0 state change information. Thus, R0 change state information that previously had marked node R0 as being part of a possibly &#x2018;dirty path&#x2019; has been changed so that node R0 no longer is marked as being part of a possibly &#x2018;dirty path&#x2019;. Accordingly, the recursive process does not traverse down from R0 to R5 in search of a dirty node. More particularly, continuing with the above example, R0 had been possibly dirty because of R1 and R2. After recomputing the path including R1, however, R1 became clean. Node R2 previously had its dirty count decremented to DC=1 (not shown), and R2 previously remained possibly dirty. In this example, node R0 has become clean due to the different branch taken in this subsequent execution of the function, which results in the reactive value corresponding to node R0 no longer depending upon the reactive value corresponding to R2. Node R2 has become obsolete and has been replaced in the hierarchy by R5. Thus, the processor is configured not only to update the hierarchy but also to clean up connectivity information and change state information that is no longer valid.</p>
<p id="p-0100" num="0099">Watches W1 and W2 are interleaved within the reactive value hierarchy structure <b>400</b> of <figref idref="DRAWINGS">FIGS. 4A-4C</figref> to cause &#x2018;side-effects&#x2019;. As used herein the term &#x2018;side-effect&#x2019; signifies</p>
<p id="p-0101" num="0100"><figref idref="DRAWINGS">FIG. 10</figref> is an illustrative flow diagram of the computation process performed by a watch process <b>1000</b> in accordance with some embodiments. The process <b>1000</b> is implemented with computer program code and the flow diagram represents configuration of a processor to implement the acts specified for the modules. The watches behave just as other reactive values within the hierarchy. The process <b>1000</b> represents the reactive value compute performed by the example watches. Module <b>1002</b> gets a reactive value &#x201c;A&#x201d; from a node within the hierarchy. Module <b>1004</b> uses the obtained reactive value &#x201c;A&#x201d; to update node &#x201c;B&#x201d; within the hierarchy. Module <b>1006</b> returns the &#x2018;null&#x2019; value to the recursive process requesting that the watch perform the compute. Thus, each watch includes two parameters: a &#x2018;get node&#x2019; where the watch gets a reactive value and a &#x2018;put node&#x2019; where a reactive value puts the reactive value.</p>
<p id="p-0102" num="0101"><figref idref="DRAWINGS">FIGS. 11A-11B</figref> are illustrative drawings of portions of the graph of <figref idref="DRAWINGS">FIGS. 4A-4C</figref> during running of the recursive process of <figref idref="DRAWINGS">FIGS. 7A-7C</figref>, assuming in this example, however, that values for Y and Z changed but not the value for X, such that the function executes along the same branch it used during the first time that it execution. Referring to the example in <figref idref="DRAWINGS">FIG. 11A</figref>, assume that the recursive process has reached a stage in which the change data for W1 indicates that WI is dirty. The role of node R2 is to construct a DOM node &#x3c;p&#x3e; . . . &#x3c;p&#x3e; using a Browser API and values for text node &#x201c;t1&#x201d; and &#x201c;t2&#x201d; provided as explained below, by the watches W1 and W2.</p>
<p id="p-0103" num="0102">For the purposes of this example, the get node for W1 is R3, and the put node of W1 is a first text node &#x201c;t1&#x201d; within the DOM node demarcated by &#x3c;p&#x3e; . . . &#x3c;p&#x3e;. It will be appreciated that the reactive value corresponding to R2 is an HTML tag that contains the text expression for the reactive values of nodes R3 and R4 within a paragraph tag. Since W1 is dirty, W1 computes. As W1 computes according to the process <b>1000</b>, module <b>1002</b> gets the reactive value computed in R3 and module <b>1004</b> places that computed value in the left side text node &#x201c;t1&#x201d; within the DOM node. Module <b>1006</b> returns the value &#x2018;null&#x2019; to R2, which is the same value that it always returns. Accordingly, module <b>748</b> of <figref idref="DRAWINGS">FIG. 7B</figref> detects no change, and the DC of R2 is decremented pursuant to module <b>754</b>. However, node R2 is not marked dirty since there was no perceived change in the value of W1: the W1 value was null before the compute, and it is null after the compute. Thus, for example, the watch. W1 changes a tangible manifestation of the DOM on a computing device screen without propagating dirty state upward through the hierarchy. In other words, the traversal associated with W1 fizzles out in the hierarchy with W1.</p>
<p id="p-0104" num="0103">Referring now to the example in <figref idref="DRAWINGS">FIG. 11B</figref>, assume that the recursive process has reached a stage in which the change data for W2 indicates that W2 is dirty. Note that W1 and W2 compute in order in which the reactive values they use are utilized by the function. The get node for W2 is R4, and the put node of W2 is a first text node &#x201c;t2&#x201d; within the DOM node demarcated by &#x3c;p&#x3e; . . . =p&#x3e;. Since W2 is dirty, W2 computes. As W2 computes, module <b>1002</b> gets the reactive value computed in R4 and module <b>1004</b> places that computed value in the right side text node &#x201c;t2&#x201d; within the DOM node. Module <b>1006</b> returns the value &#x2018;null&#x2019; to R2, which is the same value that it always returns. The DC of R2 is decremented. Node R2 is not marked dirty since there was no perceived change in the value of W2: the W2 value was null before the compute, and it is null after the compute. Thus, for example, the watch W2, like the watch module W1, changes a tangible manifestation of the DOM on a computing device screen without propagating dirty state upward through the hierarchy. In other words, the traversal associated with W1 fizzles out in the hierarchy with W1.</p>
<p id="h-0007" num="0000">Modules, Components and Logic</p>
<p id="p-0105" num="0104">Certain embodiments are described herein as including logic or a number of components, modules, or mechanisms. Modules may constitute either software modules (e.g., code embodied on a machine-readable medium or in a transmission signal) or hardware modules. A hardware module is tangible unit capable of performing certain operations and may be configured or arranged in a certain manner. In example embodiments, one or more computer systems (e.g., a standalone, client or server computer system) or one or more hardware modules of a computer system (e.g., a processor or a group of processors) may be configured by software (e.g., an application or application portion) as a hardware module that operates to perform certain operations as described herein.</p>
<p id="p-0106" num="0105">In various embodiments, a hardware module may be implemented mechanically or electronically. For example, a hardware module may comprise dedicated circuitry or logic that is permanently configured (e.g., as a special-purpose processor, such as a field programmable gate array (FPGA) or an application-specific integrated circuit (ASIC)) to perform certain operations. A hardware module may also comprise programmable logic or circuitry (e.g., as encompassed within a general-purpose processor or other programmable processor) that is temporarily configured by software to perform certain operations. It will be appreciated that the decision to implement a hardware module mechanically, in dedicated and permanently configured circuitry, or in temporarily configured circuitry (e.g., configured by software) may be driven by cost and time considerations.</p>
<p id="p-0107" num="0106">Accordingly, the term &#x201c;hardware module&#x201d; should be understood to encompass a tangible entity, be that an entity that is physically constructed, permanently configured (e.g., hardwired) or temporarily configured (e.g., programmed) to operate in a certain manner and/or to perform certain operations described herein. Considering embodiments in which hardware modules are temporarily configured (e.g., programmed), each of the hardware modules need not be configured or instantiated at any one instance in time. For example, where the hardware modules comprise a general-purpose processor configured using software, the general-purpose processor may be configured as respective different hardware modules at different times. Software may accordingly configure a processor, for example, to constitute a particular hardware module at one instance of time and to constitute a different hardware module at a different instance of time.</p>
<p id="p-0108" num="0107">Hardware modules can provide information to, and receive information from, other hardware modules. Accordingly, the described hardware modules may be regarded as being communicatively coupled. Where multiple of such hardware modules exist contemporaneously, communications may be achieved through signal transmission (e.g., over appropriate circuits and buses) that connect the hardware modules. In embodiments in which multiple hardware modules are configured or instantiated at different times, communications between such hardware modules may be achieved, for example, through the storage and retrieval of information in memory structures to which the multiple hardware modules have access. For example, one hardware module may perform an operation, and store the output of that operation in a memory device to which it is communicatively coupled. A further hardware module may then, at a later time, access the memory device to retrieve and process the stored output. Hardware modules may also initiate communications with input or output devices, and can operate on a resource (e.g., a collection of information).</p>
<p id="p-0109" num="0108">The various operations of example methods described herein may be performed, at least partially, by one or more processors that are temporarily configured (e.g., by software) or permanently configured to perform the relevant operations. Whether temporarily or permanently configured, such processors may constitute processor-implemented modules that operate to perform one or more operations or functions. The modules referred to herein may, in some example embodiments, comprise processor-implemented modules.</p>
<p id="p-0110" num="0109">Similarly, the methods described herein may be at least partially processor-implemented. For example, at least some of the operations of a method may be performed by one or processors or processor-implemented modules. The performance of certain of the operations may be distributed among the one or more processors, not only residing within a single machine, but deployed across a number of machines. In some example embodiments, the processor or processors may be located in a single location (e.g., within a home environment, an office environment or as a server farm), while in other embodiments the processors may be distributed across a number of locations.</p>
<p id="p-0111" num="0110">The one or more processors may also operate to support performance of the relevant operations in a &#x201c;cloud computing&#x201d; environment or as a &#x201c;software as a service&#x201d; (SaaS). For example, at least some of the operations may be performed by a group of computers (as examples of machines including processors), these operations being accessible via a network (e.g., the Internet) and via one or more appropriate interfaces (e.g., Application Program Interfaces (APIs).</p>
<p id="h-0008" num="0000">Electronic Apparatus and System</p>
<p id="p-0112" num="0111">Example embodiments may be implemented in digital electronic circuitry, or in computer hardware, firmware, software, or in combinations of them. Example embodiments may be implemented using a computer program product, e.g., a computer program tangibly embodied in an information carrier, e.g., in a machine-readable medium for execution by, or to control the operation of, data processing apparatus, e.g., a programmable processor, a computer, or multiple computers.</p>
<p id="p-0113" num="0112">A computer program can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand-alone program or as a module, subroutine, or other unit suitable for use in a computing environment. A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.</p>
<p id="p-0114" num="0113">In example embodiments, operations may be performed by one or more programmable processors executing a computer program to perform functions by operating on input data and generating output. Method operations can also be performed by, and apparatus of example embodiments may be implemented as, special purpose logic circuitry, e.g., a field programmable gate array (FPGA) or an application-specific integrated circuit (ASIC).</p>
<p id="p-0115" num="0114">The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other. In embodiments deploying a programmable computing system., it will be appreciated that that both hardware and software architectures require consideration. Specifically, it will be appreciated that the choice of whether to implement certain functionality in permanently configured hardware (e.g., an ASIC), in temporarily configured hardware (e.g., a combination of software and a programmable processor), or a combination of permanently and temporarily configured hardware may be a design choice. Below are set out hardware (e.g., machine) and software architectures that may be deployed, in various example embodiments.</p>
<p id="h-0009" num="0000">Example Machine Architecture and Machine-Readable Medium</p>
<p id="p-0116" num="0115"><figref idref="DRAWINGS">FIG. 12</figref> is a block diagram of machine in the example form of a computer system <b>1200</b> within which instructions, for causing the machine to perform any one or more of the methodologies discussed herein, may be executed. In alternative embodiments, the machine operates as a standalone device or may be connected (e.g., networked) to other machines. In a networked deployment, the machine may operate in the capacity of a server or a client machine in server-client network environment, or as a peer machine in a peer-to-peer (or distributed) network environment. The machine may be a personal computer (PC), a tablet PC, a set-top box (STB), a Personal Digital Assistant (PDA), a cellular telephone, a web appliance, a network router, switch or bridge, or any machine capable of executing instructions (sequential or otherwise) that specify actions to be taken by that machine. Further, while only a single machine is illustrated, the term &#x201c;machine&#x201d; shall also be taken to include any collection of machines that individually or jointly execute a set (or multiple sets) of instructions to perform any one or more of the methodologies discussed herein.</p>
<p id="p-0117" num="0116">The example computer system <b>1200</b> includes a processor <b>1202</b> (e.g., a central processing unit (CPU), a graphics processing unit (GPU) or both), a main memory <b>1204</b> and a static memory <b>1206</b>, which communicate with each other via a bus <b>1208</b>. The computer system <b>1200</b> may further include a video display unit <b>1210</b> (e.g., a liquid crystal display (LCD) or a cathode ray tube (CRT)). The computer system <b>1200</b> also includes an alphanumeric input device <b>1212</b> (e.g., a keyboard), a user interface (UI) navigation device <b>1214</b> (e.g., a mouse), a disk drive unit <b>1216</b>, a signal generation device <b>1218</b> (e.g., a speaker) and a network interface device <b>1220</b>. The processor <b>1202</b> can be used to run the processes and to perform the functions described herein and to create the hierarchies described herein.</p>
<p id="h-0010" num="0000">Machine-Readable Storage Device</p>
<p id="p-0118" num="0117">The disk drive unit <b>1216</b> includes a machine-readable medium <b>1222</b> on which is stored one or more sets of instructions and data structures (e.g., software) <b>1224</b> embodying or utilized by any one or more of the methodologies or functions described herein. The instructions <b>1224</b> may also reside, completely or at least partially, within the main memory <b>1204</b> and/or within the processor <b>1202</b> during execution thereof by the computer system <b>700</b>, the main memory <b>1204</b> and the processor <b>1202</b> also constituting machine-readable media.</p>
<p id="p-0119" num="0118">While the machine-readable storage device <b>1222</b> is shown in an example embodiment to be a single medium, the term &#x201c;machine-readable medium&#x201d; may include a single medium or multiple media (e.g., a centralized or distributed database, and/or associated caches and servers) that store the one or more instructions or data structures. The term &#x201c;machine-readable medium&#x201d; shall also be taken to include any non-transitory tangible medium that is capable of storing, encoding or carrying instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present invention, or that is capable of storing, encoding or carrying data structures utilized by or associated with such instructions. The term &#x201c;machine-readable medium&#x201d; shall accordingly be taken to include, but not be limited to, solid-state memories, and optical and magnetic media. Specific examples of machine-readable media include non-volatile memory, including by way of example semiconductor memory devices, e.g., Erasable Programmable Read-Only Memory (EPROM), Electrically Erasable Programmable Read-Only Memory (EEPROM), and flash memory devices; magnetic disks such as internal hard disks and removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The machine readable storage devices described herein can store code to implement the information structures and code to execute processes and functions described herein.</p>
<p id="h-0011" num="0000">Transmission Medium</p>
<p id="p-0120" num="0119">The instructions <b>1224</b> may further be transmitted or received over a communications network <b>1226</b> using a transmission medium. The instructions <b>1224</b> may be transmitted using the network interface device <b>1220</b> and any one of a number of well-known transfer protocols (e.g., HTTP). Examples of communication networks include a local area network (&#x201c;LAN&#x201d;), a wide area network (&#x201c;WAN&#x201d;), the Internet, mobile telephone networks. Plain Old Telephone (POTS) networks, and wireless data networks (e.g., WiFi and WiMax networks). The term &#x201c;transmission medium&#x201d; shall be taken to include any non-transitory tangible medium that is capable of storing, encoding or carrying instructions for execution by the machine, and includes digital or analog communications signals or other intangible media to facilitate communication of such software.</p>
<p id="p-0121" num="0120">Although an embodiment has been described with reference to specific example embodiments, it will be evident that various modifications and changes may be made to these embodiments without departing from the broader spirit and scope of the invention. Accordingly, the specification and drawings are to be regarded in an illustrative rather than a restrictive sense. The accompanying drawings that form a part hereof, show by way of illustration, and not of limitation, specific embodiments in which the subject matter may be practiced. The embodiments illustrated are described in sufficient detail to enable those skilled in the art to practice the teachings disclosed herein. Other embodiments may be utilized and derived therefrom, such that structural and logical substitutions and changes may be made without departing from the scope of this disclosure. This Detailed Description, therefore, is not to be taken in a limiting sense, and the scope of various embodiments is defined only by the appended claims, along with the full range of equivalents to which such claims are entitled.</p>
<p id="p-0122" num="0121">Such embodiments of the inventive subject matter may be referred to herein, individually and/or collectively, by the term &#x201c;invention&#x201d; merely for convenience and without intending to voluntarily limit the scope of this application to any single invention or inventive concept if more than one is in fact disclosed. Thus, although specific embodiments have been illustrated and described herein, it should be appreciated that any arrangement calculated to achieve the same purpose may be substituted for the specific embodiments shown. This disclosure is intended to cover any and all adaptations or variations of various embodiments. Combinations of the above embodiments, and other embodiments not specifically described herein, will be apparent to those of skill in the art upon reviewing the above description.</p>
<p id="p-0123" num="0122">The Abstract of the Disclosure is provided to comply with 37 C.F.R. &#xa7;1.72(b), requiring an abstract that will allow the reader to quickly ascertain the nature of the technical disclosure. It is submitted with the understanding that it will not be used to interpret or limit the scope or meaning of the claims. In addition, in the foregoing Detailed Description, it can be seen that various features are grouped together in a single embodiment for the purpose of streamlining the disclosure. This method of disclosure is not to be interpreted as reflecting an intention that the claimed embodiments require more features than are expressly recited in each claim. Rather, as the following claims reflect, inventive subject matter lies in less than all features of a single disclosed embodiment. Thus the following claims are hereby incorporated into the Detailed Description, with each claim standing on its own as a separate embodiment.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method comprising:
<claim-text>configuring a processor to execute a function first time;</claim-text>
<claim-text>in the course of execution of the function, producing a reactive value hierarchy structure in a non-transitory computer readable storage device that includes a plurality of respective nodes that correspond to respective reactive values used in the first execution of the function and that indicates relationships among nodes that correspond to relationships among corresponding reactive values during the first execution of the function;</claim-text>
<claim-text>wherein respective nodes in the hierarchy act as dependent nodes to other nodes lower in the hierarchy that act as inputs nodes to the respective nodes;</claim-text>
<claim-text>wherein the respective nodes act as input nodes to the other nodes higher in the hierarchy that act as dependent nodes to the respective nodes; and</claim-text>
<claim-text>wherein respective nodes are associated with respective ordered sets of one or more input nodes ordered according to order of use of their corresponding reactive values during the first execution of the function;</claim-text>
<claim-text>identifying one or more changed reactive values associated with one or more nodes;</claim-text>
<claim-text>traversing upward within the hierarchy starting from the nodes identified as having changed reactive values to identify multiple nodes within the hierarchy that are possibly dirty due to the one or more identified reactive value changes;</claim-text>
<claim-text>associating dirty state and dirty count information in the storage device with the multiple nodes identified as possibly dirty; configuring the processor to execute the function a second time using the changed reactive values;</claim-text>
<claim-text>wherein configuring the processor to execute the function a second time includes:</claim-text>
<claim-text>configuring the processor to recursively run a process to ensure current reactive values for the nodes within the hierarchy;</claim-text>
<claim-text>wherein the process includes:</claim-text>
<claim-text>monitoring dirty state information and dirty count information associated with a given node;</claim-text>
<claim-text>while the dirty state information associated with the given node indicates not dirty and the dirty count information of the given node indicates that the given node is possibly dirty, requesting the process in order one at a time on successive ordered input nodes to the given node;</claim-text>
<claim-text>when the dirty state information associated with the given node is dirty, computing a current reactive value for the given node and decrementing the dirty count information of direct dependent nodes of the of the given node and if the computed current reactive value for the given node is changed then marking as dirty, dirty state information associated with direct dependent nodes of the given node; and</claim-text>
<claim-text>when the dirty state information associated with the given node indicates not dirty and the dirty count information indicates that the given node is not dirty, returning a current reactive value of the given node to a dependent node that requested performing the process on the given node.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>,
<claim-text>wherein computing a current reactive value includes requesting the process on each input node to the given node.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further including:
<claim-text>decrementing the dirty count information of the given node upon occurrence of computing the current reactive value.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further including:
<claim-text>returning the computed current reactive value of the given node to the dependent node that requested performing of the process on the given node.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further including:
<claim-text>marking as not dirty, dirty state information associated with the given node upon occurrence of computing the current reactive value.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further including:
<claim-text>marking as not dirty, dirty state information associated with the given node upon occurrence of computing the current reactive value;</claim-text>
<claim-text>wherein returning the current reactive value of the given node to a dependent node that requested performing the process on the given node involves returning the computed current reactive value.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>,
<claim-text>wherein dirty information state of an associated node is indicative of whether a reactive value of that associated node changed due to the received reactive value change.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>,
<claim-text>wherein dirty count information of an associated node is indicative of number of nodes that are direct inputs to that associated node have reactive values that possibly changed due to the received reactive value change.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. A method comprising:
<claim-text>configuring a processor to execute a function first time;</claim-text>
<claim-text>in the course of execution of the function, producing a reactive value hierarchy structure in a non-transitory computer readable storage device that includes a plurality of respective nodes that correspond to respective reactive values used in the first execution of the function and that indicates relationships among nodes that correspond to relationships among corresponding reactive values during the first execution of the function;</claim-text>
<claim-text>wherein respective nodes in the hierarchy act as dependent nodes to other nodes lower in the hierarchy that act as inputs nodes to the respective nodes; wherein the respective nodes act as input nodes to the other nodes higher in the hierarchy that act as dependent nodes to the respective nodes; and</claim-text>
<claim-text>wherein respective nodes are associated with respective ordered sets of one or more input nodes ordered according to order of use of their corresponding reactive values during the first execution of the function;</claim-text>
<claim-text>in response to a change in a reactive value corresponding to a node in the hierarchy, marking nodes within the hierarchy that share a path with a node corresponding to a changed reactive value with indicia to indicate that they are possibly dirty;</claim-text>
<claim-text>configuring the processor to execute the function a second time;</claim-text>
<claim-text>in the course of executing the function the second time, configuring the processor to perform a recursive process that includes:</claim-text>
<claim-text>traversing down through one or more levels of the hierarchy following a path indicated by the marking that includes a possibly dirty node from the lowest order input node not yet traversed at successive levels of the hierarchy to a level where the reactive value has changed;</claim-text>
<claim-text>determining whether the changed reactive value indicates that the reactive value of the dependent node at a next level above in the hierarchy that was most recently traversed down from is dirty or clean;</claim-text>
<claim-text>if the reactive value of the dependent node at a next level above in the hierarchy that was most recently traversed down from is determined to be dirty then computing a new reactive value for that node;</claim-text>
<claim-text>if the reactive value of the dependent node at a next level above in the hierarchy that was most recently traversed down from is determined to be clean then traversing back up to a dependent node at a next level above in the hierarchy that was most recently traversed down from and repeating the traversing down step;</claim-text>
<claim-text>determining whether the computed new reactive value results in one or more reactive values in the hierarchy being obsolete; and</claim-text>
<claim-text>removing from one or more nodes in the hierarchy a marking that indicates a shared path with a possibly dirty node that is obsolete.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>,
<claim-text>wherein the step of executing the function the second time includes performing the recursive process for multiple different paths indicated by the marking as including a possibly dirty node.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>,
<claim-text>wherein the step of executing the function the second time includes performing the recursive process for each of multiple different paths indicated by the marking as including a possibly dirty node; and</claim-text>
<claim-text>wherein the step of removing from one or more nodes in the hierarchy a marking that indicates a shared path with a possibly dirty node avoids performing the recursive process for the path that had been indicated by the removed marking.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>,
<claim-text>wherein determining whether the computed new reactive value results in one or more reactive values in the hierarchy being obsolete involves determining whether the function branched to an execution path the second time that is different from an execution path that the function branched to the first time.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. An article of manufacture that includes a non-transitory computer readable storage device encode with program code to cause a processor to perform a process comprising: configuring a processor to execute a function first time;
<claim-text>in the course of execution of the function, producing a reactive value hierarchy structure in a non-transitory computer readable storage device that includes a plurality of respective nodes that correspond to respective reactive values used in the first execution of the function and that indicates relationships among nodes that correspond to relationships among corresponding reactive values during the first execution of the function;</claim-text>
<claim-text>wherein respective nodes in the hierarchy act as dependent nodes to other nodes lower in the hierarchy that act as inputs nodes to the respective nodes;</claim-text>
<claim-text>wherein the respective nodes act as input nodes to the other nodes higher in the hierarchy that act as dependent nodes to the respective nodes; and</claim-text>
<claim-text>wherein respective nodes are associated with respective ordered sets of one or more input nodes ordered according to order of use of their corresponding reactive values during the first execution of the function;</claim-text>
<claim-text>identifying one or more changed reactive values associated with one or more nodes; traversing upward within the hierarchy starting from the nodes identified as having changed reactive values to identify multiple nodes within the hierarchy that are possibly dirty due to the one or more identified reactive value changes;</claim-text>
<claim-text>associating dirty state and dirty count information in the storage device with the multiple nodes identified as possibly dirty; configuring the processor to execute the function a second time using the changed reactive values;</claim-text>
<claim-text>wherein configuring the processor to execute the function a second time includes:</claim-text>
<claim-text>configuring the processor to recursively run a process to ensure current reactive values for the nodes within the hierarchy;</claim-text>
<claim-text>wherein the process includes:</claim-text>
<claim-text>monitoring dirty state information and dirty count information associated with a given node;</claim-text>
<claim-text>while the dirty state information associated with the given node indicates not dirty and the dirty count information of the given node indicates that the given node is possibly dirty, requesting the process in order one at a time on successive ordered input nodes to the given node;</claim-text>
<claim-text>when the dirty state information associated with the given node is dirty, computing a current reactive value for the given node and decrementing the dirty count information of direct dependent nodes of the of the given node and if the computed current reactive value for the given node is changed then marking as dirty, dirty state information associated with direct dependent nodes of the given node; and</claim-text>
<claim-text>when the dirty state information associated with the given node indicates not dirty and the dirty count information indicates that the given node is not dirty, returning a current reactive value of the given node to a dependent node that requested performing the process on the given node.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. A system that includes a processor and a computer readable storage device and a communication bus connecting the processor and the device, wherein the computer readable storage device is encoded with program code to cause the processor to perform a process comprising:
<claim-text>configuring a processor to execute a function first time;</claim-text>
<claim-text>in the course of execution of the function, producing a reactive value hierarchy structure in a non-transitory computer readable storage device that includes a plurality of respective nodes that correspond to respective reactive values used in the first execution of the function and that indicates relationships among nodes that correspond to relationships among corresponding reactive values during the first execution of the function;</claim-text>
<claim-text>wherein respective nodes in the hierarchy act as dependent nodes to other nodes lower in the hierarchy that act as inputs nodes to the respective nodes;</claim-text>
<claim-text>wherein the respective nodes act as input nodes to the other nodes higher in the hierarchy that act as dependent nodes to the respective nodes; and</claim-text>
<claim-text>wherein respective nodes are associated with respective ordered sets of one or more input nodes ordered according to order of use of their corresponding reactive values during the first execution of the function;</claim-text>
<claim-text>identifying one or more changed reactive values associated with one or more nodes; traversing upward within the hierarchy starting from the nodes identified as having changed reactive values to identify multiple nodes within the hierarchy that are possibly dirty due to the one or more identified reactive value changes;</claim-text>
<claim-text>associating dirty state and dirty count information in the storage device with the multiple nodes identified as possibly dirty; configuring the processor to execute the function a second time using the changed reactive values;</claim-text>
<claim-text>wherein configuring the processor to execute the function a second time includes:</claim-text>
<claim-text>configuring the processor to recursively run a process to ensure current reactive values for the nodes within the hierarchy;</claim-text>
<claim-text>wherein the process includes:</claim-text>
<claim-text>monitoring dirty state information and dirty count information associated with a given node;</claim-text>
<claim-text>while the dirty state information associated with the given node indicates not dirty and the dirty count information of the given node indicates that the given node is possibly dirty, requesting the process in order one at a time on successive ordered input nodes to the given node;</claim-text>
<claim-text>when the dirty state information associated with the given node is dirty, computing a current reactive value for the given node and decrementing the dirty count information of direct dependent nodes of the of the given node and if the computed current reactive value for the given node is changed then marking as dirty, dirty state information associated with direct dependent nodes of the given node; and</claim-text>
<claim-text>when the dirty state information associated with the given node indicates not dirty and the dirty count information indicates that the given node is not dirty, returning a current reactive value of the given node to a dependent node that requested performing the process on the given node.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. An article of manufacture that includes a non-transitory computer readable storage device encode with program code to cause a processor to perform a process comprising:
<claim-text>configuring a processor to execute a function first time;</claim-text>
<claim-text>in the course of execution of the function, producing a reactive value hierarchy structure in a non-transitory computer readable storage device that includes a plurality of respective nodes that correspond to respective reactive values used in the first execution of the function and that indicates relationships among nodes that correspond to relationships among corresponding reactive values during the first execution of the function;</claim-text>
<claim-text>wherein respective nodes in the hierarchy act as dependent nodes to other nodes lower in the hierarchy that act as inputs nodes to the respective nodes;</claim-text>
<claim-text>wherein the respective nodes act as input nodes to the other nodes higher in the hierarchy that act as dependent nodes to the respective nodes; and</claim-text>
<claim-text>wherein respective nodes are associated with respective ordered sets of one or more input nodes ordered according to order of use of their corresponding reactive values during the first execution of the function;</claim-text>
<claim-text>in response to a change in a reactive value corresponding to a node in the hierarchy, marking nodes within the hierarchy that share a path with a node corresponding to a changed reactive value with indicia to indicate that that they are possibly dirty;</claim-text>
<claim-text>configuring the processor to execute the function a second time;</claim-text>
</claim-text>
<claim-text>in the course of executing the function the second time, configuring the processor to perform a recursive process that includes:
<claim-text>traversing down through one or more levels of the hierarchy following a path indicated by the marking that includes a possibly dirty node from the lowest order input node not yet traversed at successive levels of the hierarchy to a level where the reactive value has changed;</claim-text>
<claim-text>determining whether the changed reactive value indicates that the reactive value of the dependent node at a next level above in the hierarchy that was most recently traversed down from is dirty or clean;</claim-text>
<claim-text>if the reactive value of the dependent node at a next level above in the hierarchy that was most recently traversed down from is determined to be dirty then computing a new reactive value for that node;</claim-text>
<claim-text>if the reactive value of the dependent node at a next level above in the hierarchy that was most recently traversed down from is determined to be clean then traversing back up to a dependent node at a next level above in the hierarchy that was most recently traversed down from and repeating the traversing down step;</claim-text>
<claim-text>determining whether the computed new reactive value results in one or more reactive values in the hierarchy being obsolete; and</claim-text>
<claim-text>removing from one or more nodes in the hierarchy a marking that indicates a shared path with a possibly dirty node that is obsolete.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. A system that includes a processor and a computer readable storage device and a communication bus connecting the processor and the device, wherein the computer readable storage device is encoded with program code to cause the processor to perform a process comprising:
<claim-text>configuring a processor to execute a function first time;</claim-text>
<claim-text>in the course of execution of the function, producing a reactive value hierarchy structure in a non-transitory computer readable storage device that includes a plurality of respective nodes that correspond to respective reactive values used in the first execution of the function and that indicates relationships among nodes that correspond to relationships among corresponding reactive values during the first execution of the function;</claim-text>
<claim-text>wherein respective nodes in the hierarchy act as dependent nodes to other nodes lower in the hierarchy that act as inputs nodes to the respective nodes;</claim-text>
<claim-text>wherein the respective nodes act as input nodes to the other nodes higher in the hierarchy that act as dependent nodes to the respective nodes; and</claim-text>
<claim-text>wherein respective nodes are associated with respective ordered sets of one or more input nodes ordered according to order of use of their corresponding reactive values during the first execution of the function;</claim-text>
<claim-text>in response to a change in a reactive value corresponding to a node in the hierarchy, marking nodes within the hierarchy that share a path with a node corresponding to a changed reactive value with indicia to indicate that they are possibly dirty;</claim-text>
<claim-text>configuring the processor to execute the function a second time;</claim-text>
<claim-text>in the course of executing the function the second time, configuring the processor to perform a recursive process that includes:</claim-text>
<claim-text>traversing down through one or more levels of the hierarchy following a path indicated by the marking that includes a possibly dirty node from the lowest order input node not yet traversed at successive levels of the hierarchy to a level where the reactive value has changed;</claim-text>
<claim-text>determining whether the changed reactive value indicates that the reactive value of the dependent node at a next level above in the hierarchy that was most recently traversed down from is dirty or clean;</claim-text>
<claim-text>if the reactive value of the dependent node at a next level above in the hierarchy that was most recently traversed down from is determined to be dirty then computing a new reactive value for that node;</claim-text>
<claim-text>if the reactive value of the dependent node at a next level above in the hierarchy that was most recently traversed down from is determined to be clean then traversing back up to a dependent node at a next level above in the hierarchy that was most recently traversed down from and repeating the traversing down step;</claim-text>
<claim-text>determining whether the computed new reactive value results in one or more reactive values in the hierarchy being obsolete; and removing from one or more nodes in the hierarchy a marking that indicates a shared path with a possibly dirty node that is obsolete. </claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
