<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627180-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627180</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13768203</doc-number>
<date>20130215</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>11</class>
<subclass>C</subclass>
<main-group>29</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>714769</main-classification>
<further-classification>714763</further-classification>
</classification-national>
<invention-title id="d2e43">Memory controller ECC</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5077737</doc-number>
<kind>A</kind>
<name>Leger et al.</name>
<date>19911200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5459850</doc-number>
<kind>A</kind>
<name>Clay et al.</name>
<date>19951000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>5729497</doc-number>
<kind>A</kind>
<name>Pawlowski</name>
<date>19980300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>5754567</doc-number>
<kind>A</kind>
<name>Norman</name>
<date>19980500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>5825788</doc-number>
<kind>A</kind>
<name>Pawlowski</name>
<date>19981000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>5862154</doc-number>
<kind>A</kind>
<name>Pawlowski</name>
<date>19990100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>5864569</doc-number>
<kind>A</kind>
<name>Roohparvar</name>
<date>19990100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>5960453</doc-number>
<kind>A</kind>
<name>Pawlowski</name>
<date>19990900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>6034891</doc-number>
<kind>A</kind>
<name>Norman</name>
<date>20000300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>6178537</doc-number>
<kind>B1</kind>
<name>Roohparvar</name>
<date>20010100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>6279072</doc-number>
<kind>B1</kind>
<name>Williams et al.</name>
<date>20010800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>6397290</doc-number>
<kind>B1</kind>
<name>Williams et al.</name>
<date>20020500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>6906961</doc-number>
<kind>B2</kind>
<name>Eggleston et al.</name>
<date>20050600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>6956577</doc-number>
<kind>B2</kind>
<name>Radke et al.</name>
<date>20051000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>7409623</doc-number>
<kind>B2</kind>
<name>Baker et al.</name>
<date>20080800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>7536627</doc-number>
<kind>B2</kind>
<name>Gross et al.</name>
<date>20090500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>2003/0037299</doc-number>
<kind>A1</kind>
<name>Smith</name>
<date>20030200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714763</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00018">
<document-id>
<country>US</country>
<doc-number>2004/0153817</doc-number>
<kind>A1</kind>
<name>Norman et al.</name>
<date>20040800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00019">
<document-id>
<country>US</country>
<doc-number>2004/0210709</doc-number>
<kind>A1</kind>
<name>Conley et al.</name>
<date>20041000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00020">
<document-id>
<country>US</country>
<doc-number>2005/0005193</doc-number>
<kind>A1</kind>
<name>Nakagawa et al.</name>
<date>20050100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714  6</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00021">
<document-id>
<country>US</country>
<doc-number>2005/0160217</doc-number>
<kind>A1</kind>
<name>Gonzalez et al.</name>
<date>20050700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00022">
<document-id>
<country>US</country>
<doc-number>2005/0268203</doc-number>
<kind>A1</kind>
<name>Keays et al.</name>
<date>20051200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00023">
<document-id>
<country>US</country>
<doc-number>2005/0283650</doc-number>
<kind>A1</kind>
<name>Zhang et al.</name>
<date>20051200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>19</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>714  6</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714763</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714769</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>6</number-of-drawing-sheets>
<number-of-figures>9</number-of-figures>
</figures>
<us-related-documents>
<continuation>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>12897260</doc-number>
<date>20101004</date>
</document-id>
<parent-grant-document>
<document-id>
<country>US</country>
<doc-number>8381076</doc-number>
</document-id>
</parent-grant-document>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>13768203</doc-number>
</document-id>
</child-doc>
</relation>
</continuation>
<continuation>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>11384965</doc-number>
<date>20060320</date>
</document-id>
<parent-grant-document>
<document-id>
<country>US</country>
<doc-number>7810017</doc-number>
<date>20101005</date>
</document-id>
</parent-grant-document>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>12897260</doc-number>
</document-id>
</child-doc>
</relation>
</continuation>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20130159813</doc-number>
<kind>A1</kind>
<date>20130620</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only" applicant-authority-category="assignee">
<addressbook>
<orgname>Micron Technology, Inc.</orgname>
<address>
<city>Boise</city>
<state>ID</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Radke</last-name>
<first-name>William H.</first-name>
<address>
<city>Los Gatos</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Leffert Jay &#x26; Polglaze, P.A.</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Micron Technology, Inc.</orgname>
<role>02</role>
<address>
<city>Boise</city>
<state>ID</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Rizk</last-name>
<first-name>Sam</first-name>
<department>2112</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Memory controllers having a data buffer coupled to receive and hold data from a memory device, and an Error Correction Code (ECC) generator/checker coupled to the data buffer. The ECC generator/checker is configured to generate ECC codes for the data and to compare the generated ECC codes with ECC codes received with the data. The memory controllers are configured to permit different ECC coverage area sizes and/or different ECC code types for different portions of the memory device.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="93.22mm" wi="164.93mm" file="US08627180-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="186.77mm" wi="145.97mm" orientation="landscape" file="US08627180-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="208.53mm" wi="166.03mm" file="US08627180-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="180.59mm" wi="166.03mm" orientation="landscape" file="US08627180-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="224.03mm" wi="171.62mm" file="US08627180-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="171.96mm" wi="115.65mm" orientation="landscape" file="US08627180-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="187.11mm" wi="136.40mm" file="US08627180-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">This application is a Continuation of U.S. application Ser. No. 12/897,260, titled &#x201c;VARIABLE SECTOR-COUNT ECC,&#x201d; filed Oct. 4, 2010 (allowed), which is a Continuation of U.S. application Ser. No. 11/384,965, titled &#x201c;VARIABLE SECTOR-COUNT ECC,&#x201d; filed Mar. 20, 2006 (now U.S. Pat. No. 7,810,017), each of which is commonly assigned and incorporated herein by reference.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">TECHNICAL FIELD</heading>
<p id="p-0003" num="0002">The present invention relates generally to integrated circuits and in particular the present invention relates to data error correction codes of memory devices.</p>
<heading id="h-0003" level="1">BACKGROUND</heading>
<p id="p-0004" num="0003">Memory devices are typically provided as internal storage areas in the computer. The term memory identifies data storage that comes in the form of integrated circuit chips. There are several different types of memory used in modern electronics, one common type is RAM (random-access memory). RAM is characteristically found in use as main memory in a computer environment. RAM refers to read and write memory; that is, you can both write data into RAM and read data from RAM. This is in contrast to read-only memory (ROM), which permits you only to read data. Most RAM is volatile, which means that it requires a steady flow of electricity to maintain its contents. As soon as the power is turned off, whatever data was in RAM is lost.</p>
<p id="p-0005" num="0004">Computers almost always contain a small amount of ROM that holds instructions for starting up the computer. Unlike RAM, ROM cannot be written to. An EEPROM (electrically erasable programmable read-only memory) is a special type non-volatile ROM that can be erased by exposing it to an electrical charge. EEPROM comprise a large number of memory cells having electrically isolated gates (floating gates). Data is stored in the memory cells in the form of charge on the floating gates. Charge is transported to or removed from the floating gates by specialized programming and erase operations, respectively. Other types of non-volatile memory and storage include, but are not limited to, Polymer Memory, Ferroelectric Random Access Memory (FeRAM), Ovionics Unified Memory (OUM), Nitride Read Only Memory (NROM), and Magnetoresistive Random Access Memory (MRAM).</p>
<p id="p-0006" num="0005">In memory and memory systems, error correction codes (ECC's) allow errors in the data stored in the memory to be detected and in many cases corrected. ECC codes include block codes, that are associated with a block of stored data (a memory data sector), and stream codes, that are typically utilized with streams of transmitted data. ECC codes include, but are not limited to, Hamming codes, Reed-Solomon (R-S) codes, Bose-Chaudhuri-Hochquenghem (BCH) codes, circular redundancy check codes (CRC, it is noted herein that CRC codes are often only utilized for error detection), Golay codes, Reed-Muller codes, Goppa codes, and Denniston codes. In most memories and memory systems, error detection and/or ECC code generation is accomplished via a dedicated ECC hardware (referred to herein as ECC generators or ECC generator/checkers) as the data is read in or out. Unlike error detection, error correction is typically a more difficult process and generally involves a time consuming algorithmic process. As a result, error correction of data that has been detected as corrupt is generally done by a microprocessor or specialized hardware that can be contained either in an external microprocessor, in an external memory controller or within the memory device itself.</p>
<p id="p-0007" num="0006">The prevalence of errors in modern memory devices, and in non-volatile and Flash memory devices in particular, have been tending to increase with smaller device sizes, increased array density, lower operating voltages and through the storage of multiple data bits in memory cells via multiple charge storage centers/centroids per cell or through the use of multiple threshold voltage levels in multi-level cells (MLCs). In addition, increased active usage of non-volatile memory devices in electronic devices and increases in the amount and relative size (granularity) of the data being stored in these memory devices has tended to increase the incidence of operationally induced failures over long periods of active use due to due to physical damage, impurity migration, write fatigue, electrical transients, etc. This increase in the number of times data is written combined with the increasing prevalence in errors due to reductions in feature sizes can affect memory operation, data reliability and speed; slowing the data rate of the memory device or memory system as these errors are corrected and/or increasing the incidence of uncorrectable data errors when the number of bit errors exceed the limits of the ECC code's correction ability.</p>
<p id="p-0008" num="0007">For the reasons stated above, and for other reasons stated below which will become apparent to those skilled in the art upon reading and understanding the present specification, there is a need in the art for improved ECC apparatus and methods that allows for improved correction of data in memories.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. 1</figref> is a simplified block diagram of a system containing a non-volatile memory device in accordance with an embodiment of the present invention.</p>
<p id="p-0010" num="0009"><figref idref="DRAWINGS">FIGS. 2A</figref>, <b>2</b>B, and <b>2</b>C detail user data and their associated ECC codes in accordance with embodiments of the present invention.</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIGS. 3A and 3B</figref> detail memory systems with memory and memory controllers with ECC generation, error check and correction circuits in accordance with embodiments of the present invention.</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 4</figref> details a Flash memory controller with ECC error check and correction circuits in accordance with an embodiment of the present invention.</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 5</figref> is a simplified block diagram of a memory module in accordance with an embodiment of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0014" num="0013">In the following detailed description of the preferred embodiments, reference is made to the accompanying drawings that form a part hereof, and in which is shown by way of illustration specific preferred embodiments in which the inventions may be practiced. These embodiments are described in sufficient detail to enable those skilled in the art to practice the invention, and it is to be understood that other embodiments may be utilized and that logical, mechanical and electrical changes may be made without departing from the spirit and scope of the present invention. The following detailed description is, therefore, not to be taken in a limiting sense, and the scope of the present invention is defined only by the claims and equivalents thereof.</p>
<p id="p-0015" num="0014">Memory devices, control circuitry, or data handling routines, in accordance with embodiments of the present invention, facilitate the detection and correction of data in memory systems or devices by disassociating the user data structures being stored and the data size used for ECC to allow the ECC data size, coding, and algorithm to be selected based on the application, in effect, changing the granularity of the minimum data storage used for ECC for the purposes of efficient coverage. In one embodiment of the present invention the detection and correction of data errors in memory systems or devices is facilitated by increasing the data coverage area of the ECC codes (the ECC coverage area) to increase the relative size of the user data being covered by the same relative amount of ECC code storage. This approach averages any bit errors over a larger data area and allows for a greater number of errors to be detected and corrected in the increased data coverage area by the larger ECC code stored in the combined ECC code area, but does not substantially change the overall amount of ECC code data storage over a single sector based approach.</p>
<p id="p-0016" num="0015">In another embodiment of the present invention, the size of the data block being utilized for ECC coverage is variable and can be selected such that differing memory devices, differing areas of the memory array, or differing memory areas storing differing types of data or having differing storage or use characteristics (such as requiring speed over increased error coverage or having increased error rates) can have a differing ECC data coverage block size. For example, a 4 sector ECC data grouping in one erase block, a 3 sector ECC data grouping in a second erase block, a 2 sector ECC data group in a third erase block, a single sector ECC data group in a fourth erase block, and a selected data space size and ECC grouping in a fifth erase block or memory array segment. It is also noted that the ECC algorithm, math base (9-bit, 10-bit, 11-bit, etc.), or encoding scheme (R-S, BCH, Hamming, etc.) can also be varied between these differing areas of the memory array.</p>
<p id="p-0017" num="0016">In one embodiment of the present invention two 512 byte data sectors with separate 12 byte/10 symbol, 9-bit math ECC codes (each able to detect 6 individual errors and correct 4 of them within their associated single sectors), are now for ECC error detection and correction purposes combined in the embodiment to be two joined 512 byte sectors (or a single 1024 byte block) covered by a single joined ECC code having 25 bytes and being able to correct 9 errors and detect 11 in the combined 1024 byte ECC coverage space. In another embodiment of the present invention four 512 byte sectors and their ECC's are combined to allow for correction of up to 19 errors and the detection of 21 in the 2048 byte user data space covered.</p>
<p id="p-0018" num="0017">Memory devices typically contain user data areas and overhead data areas. In particular, in non-volatile memory devices, such as Flash memory devices, each erase block typically contains user data areas and overhead data areas. The overhead data areas contain overhead information for operation of the erase block and/or the user data area the overhead data space is associated with. Such overhead information typically includes, but is not limited to, erase block management (EBM) data, or sector status information. In Flash memory devices each erase block is typically divided into a series of sectors, where the sectors each generally contain 512 bytes of user data space and an associated control or overhead area. One or more of the sectors are each typically written to a single row of the Flash memory array (also known as a physical page or column page or &#x201c;page&#x201d;) within the erase block.</p>
<p id="p-0019" num="0018">As stated above, modern memories are dealing with a greater incidence of errors in them. This is due to reductions in feature sizes, increased memory array/memory device densities, differing manufacturing processes, lower operating voltages, etc. In addition, in operating memory devices, electrostatic damage (ESD), write fatigue, electrical cross talk, and noise can also play a part in array damage or corruption of stored data. Therefore, the probability one or more bit errors in a given read memory segment or sector is increasing.</p>
<p id="p-0020" num="0019">Typically, because of manufacturing related or use induced imperfections and errors, memory devices and other computer usable storage or media are abstracted by various software drivers, management routines, and hardware support circuitry to appear to their host systems as virtual perfect data storage, without errors or defective regions. This abstraction of the memory device or computer usable storage generally accomplished through the marking of bad memory blocks, replacement of defective blocks or memory elements with spare/redundant blocks or elements, and through the use of error correction methods, such as ECC codes, to detect and correct data errors in the retrieved data. However, these redundant elements are expensive to include and take away from the space available for the memory array, therefore there are limits to what can be fixed in a given memory device by such methods, particularly given the density of current memory devices.</p>
<p id="p-0021" num="0020">As a result of the increased incidence of errors, memory controllers and embedded ECC systems currently are being asked to deal with an increased number of situations where error correction is required. However, the data space reserved for the ECC code storage is generally remaining the same, while the number of errors that the ECC codes and algorithms are being asked to detect and correct are increasing. As a result, the rate of unrecoverable errors in the memory system or device is increasing appreciably as the incidence of errors increases.</p>
<p id="p-0022" num="0021">As stated above, memories typically utilize ECC codes to detect and correct a limited number of errors in stored user data. ECC codes, and block ECC codes in particular, are commonly based on specialized polynomial equations, where the stored ECC codes are the generated coefficients of a polynomial for the current data. When the data is read out of a memory the data integrity is checked by regenerating these coefficients from the read data; serially running the read data through a hardware ECC generator/checker to regenerate the ECC code, and comparing them against the coefficients in the stored ECC code. If the generated and stored ECC codes do not match an error has been detected. Once an error in read data is detected, the transfer of the data out of the memory device or system is halted and ECC correction algorithm is started. The ECC correction algorithm, generally speaking, solves for the zeros of the polynomial to locate the data word(s) and bit(s) within the data words that need to be corrected.</p>
<p id="p-0023" num="0022">In utilizing error correction methodologies in memory devices or other computer usable storage, it would be desirable to be able to correct an infinite number of errors. However, for each error the ECC code/memory device can correct there is an overhead cost. These overhead costs come in the form of increased storage space required for storing the ECC codes to allow detection and correction errors in the stored data, and in increased size and complexity of the hardware circuits and/or software routines required to utilize the ECC codes and reduced speed of operation. In addition, ECC codes and algorithms are typically designed to allow for the detection of more errors than they can correct for in order to increase operational stability in the ECC algorithm. As such, efficient and practical ECC code error correction is typically limited by storage space requirements, and by complexity and speed of use of the selected ECC codes and algorithms. On the other hand, the actual incidences of individual symbol errors in prior art memory devices or computer usable storage has typically been low, so that the statistical odds of having more than a limited number of bit errors in a 512-byte sector of user data has been typically low enough in the past so that a limited ECC error detection and correction ability (thus having low additional storage requirements and a high speed of operation) has been sufficient for abstraction purposes. As stated above, with increasing data storage density in modern memory devices, decreased process feature sizes and memory cell spacing, there will generally be an increasing level of bit errors in the stored data.</p>
<p id="p-0024" num="0023">In the past, ECC codes in memory devices or computer usable storage have traditionally been utilized on a per-sector basis, where each sector of 512 bytes of data has an ECC code associated with it to detect and correct a limited number of errors that occur in the sector. This corresponded with the typical user data structure being stored and retrieved in these devices (a sector) and, in many cases, matched the row size (also known as the physical page size) of the memory devices being utilized, allowing for convenience and speed in data storage and retrieval in these devices. With improvements in modern memory technology and manufacturing processes, many modern memory devices, in particular non-volatile memory devices, now can store four or more sectors on a row/physical page of their memory arrays, with further page size increases likely forthcoming. Yet in these devices ECC coding is still done on per sector basis.</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 1</figref> details a simplified diagram of a system <b>128</b> incorporating of an embodiment of the present invention, having a memory device <b>100</b> connected to a host <b>102</b>, which is typically a processing device or memory controller. The memory <b>100</b> has a control interface <b>106</b> and an address/data interface <b>108</b> that are each connected to the processing device <b>102</b> to allow memory read and write accesses. It is noted that in alternative embodiments, the address/data interface <b>108</b> can be divided into separate interfaces. Internal to the memory device a control state machine/control circuit <b>110</b> directs the internal operation; managing the memory array <b>112</b> and updating RAM control registers <b>114</b>. The RAM control registers and tables <b>114</b> are utilized by the control state machine <b>110</b> during operation of the memory <b>100</b>. The memory array <b>112</b> contains a sequence of memory banks or segments <b>116</b>. Memory access addresses are received on the address/data interface <b>108</b> of the memory <b>100</b> and divided into a row and column address portions. On a read access the row address is latched and decoded by row decode circuit <b>120</b>, which selects and activates a row page (not shown) of memory cells across a selected memory bank. The bit values encoded in the output of the selected row of memory cells are connected from a local bitline/string (not shown) to a global bitline (not shown) and detected by sense amplifiers <b>122</b> associated with the memory bank. The column address of the access is latched and decoded by the column decode circuit <b>124</b>. The output of the column decode circuit selects the desired column data from the sense amplifier outputs and connected to the data buffer <b>126</b> for transfer from the memory device through the address/data interface <b>108</b>. On a write access the row decode circuit <b>120</b> selects the row page and column decode circuit selects write sense amplifiers <b>122</b>. Data values to be written are connected from the data buffer <b>126</b> to the data cache and then to the write data latches of the write sense amplifiers <b>122</b> selected by the column decode circuit <b>124</b> and written to the selected memory cells (not shown) of the memory array <b>112</b>. In one embodiment, the written cells are then reselected by the row and column decode circuits <b>120</b>, <b>124</b> and sense amplifiers <b>122</b> so that they can be read to verify that the correct values have been programmed into the selected memory cells. It is noted that in another embodiment of the present invention, the column decode <b>124</b> may be optionally placed between the memory array <b>112</b> and the sense amplifiers <b>122</b>.</p>
<p id="p-0026" num="0025">As stated above, one type of non-volatile memory is a Flash memory. A Flash memory is a type of EEPROM that is typically erased and reprogrammed in blocks instead of one byte at a time. A typical Flash memory comprises a memory array, which includes a large number of non-volatile memory cells. Each of the memory cells typically includes a conductive floating gate (or non-conductive floating node/charge trapping layer) field-effect transistor (FET) capable of holding a charge. The data in a cell is determined by the presence or absence of the charge in the floating gate. The cells are usually grouped into sections called &#x201c;erase blocks.&#x201d; The memory cells of a Flash memory array are typically arranged into a &#x201c;NOR&#x201d; architecture (each cell directly coupled to a bit line) or a &#x201c;NAND&#x201d; architecture (cells coupled into &#x201c;strings&#x201d; of cells, such that each cell is coupled indirectly to a bit line and requires activating the other cells of the string for access). Each of the cells within an erase block can be electrically programmed in a random basis by charging the floating gate. The charge can be removed from the floating gate by a block erase operation, wherein all floating gate memory cells in the erase block are erased in a single operation.</p>
<p id="p-0027" num="0026">It is noted that embodiments of the present invention are not limited to NAND or NOR architecture memory arrays or memory devices and can apply to other block erasing memory array architectures and memory devices, including, but not limited to AND and virtual ground architecture memory arrays and memory devices.</p>
<p id="p-0028" num="0027">Because all the cells in an erase block of a Flash memory device are generally erased all at once, one cannot directly rewrite a Flash memory cell without first engaging in a block erase operation. EBM, typically under the control of an internal state machine, an external Flash memory controller, or software driver, provides an abstraction layer for this to the host (a processor or an external memory controller), allowing the Flash device to appear as a freely rewriteable device, including, but not limited to, managing the logical address to physical erase block translation mapping for reads and writes, the assignment of erased and available erase blocks for utilization, and the scheduling erase blocks that have been used and closed out for block erasure. Erase block management also allows for load leveling of the internal floating gate memory cells to help prevent write fatigue failure. Write fatigue is where the floating gate memory cell, after repetitive writes and erasures, no longer properly erases and removes charge from the floating gate. Load leveling procedures increase the mean time between failure of the erase block and Flash memory device as a whole.</p>
<p id="p-0029" num="0028">In many modern Flash memory device implementations, the host interface and Erase Block Management routines additionally allow the Flash memory device to appear as a read/write mass storage device (i.e., a magnetic disk) to the host. One such approach is to conform the interface to the Flash memory to be identical to a standard interface for a conventional magnetic hard disk drive allowing the Flash memory device to appear as a block read/write mass storage device or disk.</p>
<p id="p-0030" num="0029">Memory devices, control circuitry, or data handling routines, in accordance with embodiments of the present invention, facilitate the detection and correction of data in memory systems or devices by decoupling the user data structures being stored and the base data size being utilized for ECC to allow the ECC data size, coding, and algorithm to be selected based on the requirements of the application (such as either an increase error coverage or speed of operation). In one embodiment of the present invention, ECC detection and correction is increased by enlarging the data area or block size of user data being covered by the ECC code symbols (the ECC coverage area) larger than the base stored user data structure size (e.g., single sector user data storage with a multiple sector ECC coverage area). This averages the possible bit errors that may occur in the ECC coverage area over a larger amount of user data and allows a greater number of errors to be detected and corrected within this larger ECC coverage area but have the same ECC code storage space as a single sector based approach.</p>
<p id="p-0031" num="0030">In one embodiment, a memory controller, memory system or memory device contains an ECC coverage area (or ECC data block) that differs from the base stored user data structure size. In another embodiment, a memory controller, memory system or memory device tags memory structures, such as, but not limited to, sectors, pages, erase blocks, memory segments, and memory array banks to identify the base ECC coverage area and ECC encoding utilized in the memory structure. In yet another embodiment, differing memory devices in a memory system utilize differing base ECC coverage areas and ECC encodings. In a further embodiment, a different base ECC coverage area and ECC encoding is utilized dependent on the type of memory being utilized and/or the data being stored, such as a MLC NAND Flash storing digital images (having a low data reliability requirement), an EEPROM storing boot code (requiring high data reliability), or a DRAM utilized as scratch pad memory (having a high access speed/low data reliability requirement). In yet a further embodiment, the ECC coverage area and coding is adaptive based on the number of errors (the bit error rate) and/or use level of the underlying memory area, such that as a memory area experiences an increasing wear level, increasing number of bit errors, or increasing number of unrecoverable data errors, the ECC coverage area and coding scheme utilized in the area is increased to allow for greater data reliability. In some cases, this increased ECC coverage area and correction ability can be utilized by the memory device or system as an alternative to marking the memory area as bad and requiring that it be removed from use.</p>
<p id="p-0032" num="0031">Reed-Solomon error correction block codes are one of a number of block codes commonly utilized in memory device applications and embodiments of the present invention. It is noted that preferred embodiments of the present invention utilize Bose-Chaudhuri-Hochquenghem (BCH) based ECC codes and algorithms, such as Reed-Solomon (R-S) codes. However, it is also noted that they can utilize other ECC codes, including, but not limited to, Hamming codes, circular redundancy check codes (CRC), Golay codes, Reed-Muller codes, Goppa codes, and Denniston codes. As stated above, with a block code generator, a block of data is fed into the block code generator to generate the ECC code to be stored associated with the data block in the memory device.</p>
<p id="p-0033" num="0032">In one prior art ECC generator/checker, a Reed-Solomon code generator is fed a data sector of 512 bytes and generates ten 9-bit symbols (formatted into a 12 byte code) that form the ECC code to tag on to the end of the data block. From these ten 9-bit symbols of the 12 byte ECC code it is typically possible to detect 6 errors and correct 4 in the data sector as it is read from the memory device. As noted above, to promote stability in the ECC algorithm operation and prevent valid, but incorrect, ECC error correction solutions, ECC coding schemes are sometimes chosen so that they can detect more errors than they can correct as a safety margin.</p>
<p id="p-0034" num="0033">ECC code generators typically serialize the data block into a data stream to generate the ECC code. A similar process is also generally utilized to check a read data block by regenerating the ECC code from the read data block and evaluating it against the stored associated ECC code. In generating an ECC code from a data sector/data block, the ECC code generator divides the user data of the stored data block into symbols of the same math base (such as 9-bit data symbols) as the ECC code it was stored with.</p>
<p id="p-0035" num="0034">In checking data block and its associated ECC code, the ECC code generator/code check hardware produces a stream of binary digits (Syndrome generation) in what is know as a Linear Feedback Shift Register (LFSR) code. If the stream of binary digits is all zeros, no errors have been detected in the read data block. If one or more non-zero bits are output, there is an error and further processing is required by the ECC correction algorithm to try to determine the location of the error(s) and correct them.</p>
<p id="p-0036" num="0035">In determining the location of the errors, an ECC algorithm (such as a BCH-based Reed-Solomon code) utilizes the stored symbols of the ECC code and solves for the zeros of the error location polynomial to locate the symbol(s) in the data block that are corrupted and the bit(s) within that symbol that are incorrect. In doing so, it utilizes a Berlekamp Algorithm to solve a series of equations to find the zero's of the error location polynomial in Galois fields in 2^N space. A Chien search is then conducted, by inserting these zeros into each location to see if this is one of the bit locations that satisfies the error solution.</p>
<p id="p-0037" num="0036">In embodiments of the present invention, the ECC data coverage area, math base of the symbols, and ECC algorithms of ECC generator/checkers are preferably designed for the largest ECC data coverage area being utilized in the embodiment. For use with smaller ECC data coverage areas or in embodiments with variable ECC coverage areas, the data space and algorithm loops are truncated so that only the symbols contained within these smaller ECC data coverage areas are utilized in generating and checking the ECC. However, it is noted that a different LFSR register may be required for each different ECC coverage size. It is also noted that changing between differing symbol math bases and ECC encoding schemes within the embodiment (such as, from 9-bit symbols to 10-bit symbols or Hamming codes to R-S codes) can cause there to be a change the base ECC algorithms and/or hardware.</p>
<p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. 2A</figref> details a data sector <b>202</b> and its associated 9-bit math Reed-Solomon ECC code <b>204</b>. In <figref idref="DRAWINGS">FIG. 2A</figref>, the user data is stored in a 512-byte sector <b>202</b> that is concurrent with the ECC coverage area and is divided into 456 9-bit symbols for ECC purposes. The ECC code <b>204</b> contains ten 9-bit symbols stored in 12 bytes. The Reed-Solomon ECC encoding of the single data sector/ECC coverage area <b>202</b> and ECC code <b>204</b> allows for the detection of 6 symbol errors and the correction of 4 symbol errors. It is noted that this encoding includes an additional error detection margin of 2 bits over the 4 bit correction ability to help foster predictable and stable operation of the ECC error correction.</p>
<p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. 2B</figref> details a dual sector ECC coverage area <b>212</b> and its associated 10-bit math Reed-Solomon ECC code <b>214</b> of an embodiment of the present invention. In <figref idref="DRAWINGS">FIG. 2B</figref>, the user data is stored in two 512-byte sectors <b>212</b> that are grouped together to form a single 1024 byte ECC coverage area having 820 10-bit symbols for ECC purposes. The ECC code <b>214</b> contains 20 10-bit symbols stored in a 25 byte joined ECC code area. The Reed-Solomon ECC encoding of the dual data sector/ECC coverage area <b>212</b> and associated ECC code <b>214</b> with 10-bit math allows for the detection of 11 errors and the correction of 9 errors in one embodiment of the present invention. It is noted that this encoding includes the same 2 error detection margin over the correction ability to help foster predictable and stable operation of the ECC error correction. However, due to the combined dual sector coverage, this 2 error detection margin is for the dual sector ECC coverage area, as a whole, and does not need to be repeated for both sectors. The excess coding ability thus freed up allows for an increase in the error correction ability of the combined ECC code <b>214</b> to be able to correct for 9 errors in the dual sector <b>212</b> instead of a linear increase of 8 bits. Even without taking advantage of this ability to decrease the error detection margin in the error correction, since the error correction ability for the combined dual sector <b>212</b> is now combined, and since that bit errors are typically random and occur at a constant, infrequent, rate throughout the memory area being covered, statistically we have a much greater error detection and correction ability for the dual sector ECC coverage area <b>212</b> than in a single sector approach (i.e., the statistical odds of an additional bit error occurring within a given data area is smaller with higher numbers of errors, such that the odds of a 2-bit error occurring in an ECC coverage area is less than the occurrence of a 1-bit error, a 3-bit error even less so, etc.). In other words, we are much less likely to have more than 8 bit errors in 2 sectors than more than 4 bit errors in 1 sector. However, we do increase the complexity of the resulting ECC algorithm and/or associated hardware, decreasing access speed.</p>
<p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. 2C</figref> details a quad sector ECC coverage area <b>222</b> and associated 11-bit math Reed-Solomon ECC code <b>224</b> of another embodiment of the present invention. In <figref idref="DRAWINGS">FIG. 2C</figref>, the user data is stored in four 512-byte sectors <b>222</b> that are grouped together to form a single 2048 byte ECC coverage area of 1490 11-bit ECC symbols. The ECC code <b>224</b> contains 40 11-bit symbols stored in a 55-byte ECC code storage area. The Reed-Solomon ECC encoding of the quad data sector/ECC coverage area <b>222</b> and associated ECC code <b>224</b> with 11-bit math allows for the detection of 21 errors and the correction of 19 errors in one embodiment of the present invention.</p>
<p id="p-0041" num="0040"><figref idref="DRAWINGS">FIG. 2D</figref> details an embodiment of the present invention having a generalized ECC coverage area <b>232</b> storing Y-bytes of user data divided into Z ECC symbols using X-bit math and protected by an associated X-bit math BCH ECC code <b>234</b>. It is noted that in one embodiment the size of the ECC coverage area <b>232</b> can be variable and set by the amount of data to be stored during the access or area of memory being utilized. The ECC code <b>234</b> contains N X-bit symbols stored in a M-byte ECC code storage area. The ECC encoding of the generalized ECC coverage area <b>232</b> and associated ECC code <b>234</b> allows for the detection of J symbol errors and the correction of K symbol errors (and thus their contained bit errors).</p>
<p id="p-0042" num="0041">It is noted that other ECC coverage areas sizes, ECC encoding schemes and ECC codes of <figref idref="DRAWINGS">FIGS. 2A</figref>, <b>2</b>B, <b>2</b>C and <b>2</b>D incorporating embodiments of the present invention will be apparent to those skilled in the art with the benefit of the present disclosure.</p>
<p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. 3A</figref> is a simplified diagram of a system <b>300</b> that incorporates a Flash memory device <b>304</b> embodiment of the present invention. In the system <b>300</b> of <figref idref="DRAWINGS">FIG. 3A</figref>, the Flash memory <b>304</b> is coupled to a processor <b>302</b> with an address/data bus <b>306</b>. Internally to the Flash memory device, a control state machine <b>310</b> directs internal operation of the Flash memory device; managing the Flash memory array <b>308</b> and updating RAM control registers and tables <b>314</b>. The Flash memory array <b>308</b> contains floating gate memory cells arranged in a sequence of erase blocks <b>316</b>, <b>318</b>. Each erase block <b>316</b>, <b>318</b> contains a series of physical pages, each page containing one or more logical sectors <b>324</b> (shown here for illustration purposes as a single logical sector <b>324</b> per physical page/row) that contain a user data space <b>320</b> and a control/overhead data space <b>322</b>. The overhead data space <b>322</b> contains overhead information for operation of the sector <b>320</b>, such as an error correction code (not shown), status flags, or an erase block management data field area (not shown). The RAM control registers and tables <b>314</b> are loaded at power up from the non-volatile erase block management registers and tables (not shown) by the control state machine <b>310</b>. The user data space <b>320</b> in each logical sector <b>324</b> is typically 512 bytes long. It is noted that other interfaces to the Flash memory <b>304</b> and formats for the erase blocks <b>316</b>, <b>318</b>, physical pages, and sectors <b>324</b> are possible and should be apparent to those skilled in the art with benefit of the present disclosure. In <figref idref="DRAWINGS">FIG. 3A</figref>, the Flash memory <b>304</b> contains ECC generation and checking hardware <b>312</b> incorporating embodiments of the present invention.</p>
<p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. 3B</figref> is a simplified diagram of another system <b>350</b> that incorporates a Flash memory system <b>360</b> embodiment of the present invention. In the system <b>350</b> of <figref idref="DRAWINGS">FIG. 3B</figref>, the Flash memory system <b>360</b>, such as a memory system or Flash memory card, is coupled to a processor <b>352</b> with an address <b>354</b>, control <b>356</b>, and data bus <b>358</b>. Internal to the Flash memory system <b>360</b>, a memory controller <b>366</b> directs internal operation of the Flash memory system <b>360</b>; managing the Flash memory devices <b>362</b>, directing data accesses, updating internal control registers and tables (not shown), and/or directing operation of other possible hardware systems (not shown) of the Flash memory system <b>360</b>. The memory controller <b>366</b> has an internal ECC generation and checking hardware (not shown) that incorporates embodiments of the present invention. The memory controller <b>366</b> may optionally incorporate a small local embedded processor to help manage the Flash memory system <b>360</b>. The memory controller <b>366</b> is coupled to and controls one or more Flash memory devices <b>362</b> via an internal control bus <b>364</b>. It is noted that other architectures Flash memory systems <b>360</b>, external interfaces <b>354</b>, <b>356</b>, <b>358</b>, and manners of coupling the memory controller <b>366</b> to the Flash memory devices <b>362</b>, such as directly coupled individual control busses and signal lines, are possible and should be apparent to those skilled in the art with benefit of the present disclosure.</p>
<p id="p-0045" num="0044">The Flash memory devices <b>362</b> each contain a sequence of erase blocks <b>316</b>, <b>318</b> in their internal memory arrays. Each erase block <b>316</b>, <b>318</b> contains a series of physical pages, each physical page having one or more logical sectors <b>324</b> that contain a user data space <b>320</b> and a control/overhead data space <b>322</b> (shown here for illustration purposes as a single logical sector <b>324</b> per physical page/row). The overhead data space <b>322</b> contains an ECC code (not shown) and other overhead information for operation of the logical sector <b>320</b>, such as status flags, or an erase block management data field area (not shown).</p>
<p id="p-0046" num="0045">It is noted that the ECC checking and correction of Flash memory embodiments of the present invention can apply to other non-volatile memory types including, but not limited to, polymer memory, multi-level cells (MLC) storage, NOR Flash, NAND Flash, virtual ground, FeRAM, OUM, NROM, and MRAM and should be apparent to those skilled in the art with the benefit of the present invention.</p>
<p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. 4</figref> shows a simplified diagram of a memory controller output <b>400</b> of an embodiment of the present invention coupled through a memory interface <b>402</b> to one or more Flash memory devices and through a host interface <b>404</b> to an external host (not shown), which typically is a processor or computer system. In the memory controller <b>400</b>, a data buffer <b>406</b> is coupled to serially receive and hold a selected data block that is serially read through the memory interface <b>402</b> from a selected Flash memory device before it is transferred from the data buffer <b>406</b> through the host interface <b>404</b> under control of the host transfer hardware <b>414</b>. The serially streamed data block is also coupled to a Reed-Solomon ECC generator/checker hardware <b>408</b>, which regenerates the ECC codes from the data block and checks them against the stored ECC codes attached at the end of the data block stream. Once the data block is read and evaluated, the Reed-Solomon ECC generator/checker hardware <b>408</b> signals <b>410</b> to the host transfer hardware <b>414</b> to start the data transfer if the data block is correct (the data block ECC codes have been generated and evaluated correctly against the stored ECC codes for the data block, typically generating a string of zeros from the Reed-Solomon ECC generation hardware <b>408</b>). If the data block is corrupted (the generated data block ECC codes have evaluated incorrectly against the stored ECC codes for the data block, typically generating a non-zero value output from the Reed-Solomon ECC generation hardware <b>408</b>) the Reed-Solomon ECC generator/checker hardware <b>408</b> signals <b>412</b> a (typically internal) microprocessor or dedicated ECC correction hardware <b>416</b> to correct the errors by utilizing a Reed-Solomon ECC correction algorithm. The microprocessor <b>416</b> solves the Reed-Solomon ECC correction algorithm, solving the Berlekamp polynomial, and executing a Chien search from the stored ECC code to determine the bits to be corrected in the data block and applies the correction <b>418</b> to the data block contents held in the data buffer <b>406</b>. After applying the correction to the data buffer <b>406</b>, the microprocessor <b>416</b> signals <b>420</b> the host transfer hardware <b>414</b> to begin transferring the data block from the data buffer <b>406</b> out through the host interface <b>404</b>.</p>
<p id="p-0048" num="0047">It is noted that, although the memory controller <b>400</b> is designed to be externally coupled to one or more Flash memory devices, memory outputs that are internal to a memory device incorporating embodiments of the present invention should be apparent to those skilled in the art with the benefit of the present disclosure. It is also noted that other embodiments incorporating differing ECC code schemes and math bases are also possible and should be apparent to those skilled in the art with the benefit of the present disclosure.</p>
<p id="p-0049" num="0048"><figref idref="DRAWINGS">FIG. 5</figref> is an illustration of an exemplary memory module <b>500</b>. Memory module <b>500</b> is illustrated as a memory card, although the concepts discussed with reference to memory module <b>500</b> are applicable to other types of removable or portable memory, e.g., USB flash drives, and are intended to be within the scope of &#x201c;memory module&#x201d; as used herein. In addition, although one example form factor is depicted in <figref idref="DRAWINGS">FIG. 5</figref>, these concepts are applicable to other form factors as well.</p>
<p id="p-0050" num="0049">In some embodiments, memory module <b>500</b> will include a housing <b>505</b> (as depicted) to enclose one or more memory devices <b>510</b>, though such a housing is not essential to all devices or device applications. At least one memory device <b>510</b> is a non-volatile memory including circuits of or adapted to perform elements of methods of the present invention. Where present, the housing <b>505</b> includes one or more contacts <b>515</b> for communication with a host device. Examples of host devices include digital cameras, digital recording and playback devices, PDAs, personal computers, memory card readers, interface hubs and the like. For some embodiments, the contacts <b>515</b> are in the form of a standardized interface. For example, with a USB flash drive, the contacts <b>515</b> might be in the form of a USB Type-A male connector. For some embodiments, the contacts <b>515</b> are in the form of a semi-proprietary interface, such as might be found on CompactFlash&#x2122; memory cards licensed by SanDisk Corporation, Memory Stick&#x2122; memory cards licensed by Sony Corporation, SD Secure Digital&#x2122; memory cards licensed by Toshiba Corporation and the like. In general, however, contacts <b>515</b> provide an interface for passing control, address and/or data signals between the memory module <b>500</b> and a host having compatible receptors for the contacts <b>515</b>.</p>
<p id="p-0051" num="0050">The memory module <b>500</b> may optionally include additional circuitry <b>520</b> which may be one or more integrated circuits and/or discrete components. For some embodiments, the additional circuitry <b>520</b> may include a memory controller for controlling access across multiple memory devices <b>510</b> and/or for providing a translation layer between an external host and a memory device <b>510</b>. For example, there may not be a one-to-one correspondence between the number of contacts <b>515</b> and a number of I/O connections to the one or more memory devices <b>510</b>. Thus, a memory controller could selectively couple an I/O connection (not shown in <figref idref="DRAWINGS">FIG. 5</figref>) of a memory device <b>510</b> to receive the appropriate signal at the appropriate I/O connection at the appropriate time or to provide the appropriate signal at the appropriate contact <b>515</b> at the appropriate time. Similarly, the communication protocol between a host and the memory module <b>500</b> may be different than what is required for access of a memory device <b>510</b>. A memory controller could then translate the command sequences received from a host into the appropriate command sequences to achieve the desired access to the memory device <b>510</b>. Such translation may further include changes in signal voltage levels in addition to command sequences.</p>
<p id="p-0052" num="0051">The additional circuitry <b>520</b> may further include functionality unrelated to control of a memory device <b>510</b> such as logic functions as might be performed by an ASIC (application specific integrated circuit). Also, the additional circuitry <b>520</b> may include circuitry to restrict read or write access to the memory module <b>500</b>, such as password protection, biometrics or the like. The additional circuitry <b>520</b> may include circuitry to indicate a status of the memory module <b>500</b>. For example, the additional circuitry <b>520</b> may include functionality to determine whether power is being supplied to the memory module <b>500</b> and whether the memory module <b>500</b> is currently being accessed, and to display an indication of its status, such as a solid light while powered and a flashing light while being accessed. The additional circuitry <b>520</b> may further include passive devices, such as decoupling capacitors to help regulate power requirements within the memory module <b>500</b>.</p>
<p id="p-0053" num="0052">It is also noted that other ECC error detection and correction sequences, methods, and circuits in memory embodiments of the present invention are possible and should be apparent to those skilled in the art with benefit of the present disclosure.</p>
<heading id="h-0006" level="1">CONCLUSION</heading>
<p id="p-0054" num="0053">Improved memory devices, circuitry, and data methods have been described that facilitate the detection and correction of data in memory systems or devices by disassociating the user data structures being stored and the base data size being utilized for ECC to allow the ECC data size, coding, and algorithm to be selected based on the application. This allows the ECC being utilized to be selected for either increased error coverage or speed of operation. In one embodiment of the present invention, the data area or block size of user data being covered by the ECC code symbols is a fixed increased data size compared to the stored user data structure size (e.g., single sector user data storage with a multiple sector ECC coverage area). This averages the possible bit errors that may occur in the ECC coverage area over a larger amount of user data and allows a greater number of errors to be detected and corrected within this larger ECC coverage area by increasing the ECC code storage space through a simple combining of the sector-based ECC code storage space. This increases the ECC complexity but allows the overall data size of the ECC codes being stored to be equivalent to a single sector based approach with an increased bit error detection and correction ability. In yet another embodiment of the present invention, the size of the data block being utilized for ECC coverage is variable and can be selected such that differing areas of the memory array or areas storing differing data types can have a differing ECC data block size, selected for either increased data reliability and error coverage or speed of operation. For example, a 4 sector ECC data grouping in one erase block, a 2 sector ECC data group in a second erase block, a single sector ECC data group in a third erase block, and a selected data space size and ECC grouping in a fourth erase block or memory array segment.</p>
<p id="p-0055" num="0054">Although specific embodiments have been illustrated and described herein, it will be appreciated by those of ordinary skill in the art that any arrangement, which is calculated to achieve the same purpose, may be substituted for the specific embodiment shown. This application is intended to cover any adaptations or variations of the present invention. Therefore, it is manifestly intended that this invention be limited only by the claims and the equivalents thereof.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A memory controller, comprising
<claim-text>a data buffer coupled to receive and hold data from a memory device;</claim-text>
<claim-text>an Error Correction Code (ECC) generator/checker coupled to the data buffer, wherein the ECC generator/checker is configured to generate ECC codes for the data and to compare the generated ECC codes with ECC codes received with the data;</claim-text>
<claim-text>wherein the ECC generator/checker is configured to generate ECC codes using a particular ECC coverage area size for data received from a particular portion of the memory device; and</claim-text>
<claim-text>wherein the memory controller is configured to modify the particular ECC coverage area size for the particular portion of the memory device.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The memory controller of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the particular ECC coverage area size and the modified particular ECC coverage area size each comprise an integer number of sectors of user data.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The memory controller of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the memory controller is further configured to modify the particular ECC coverage area size for the particular portion of the memory device in response to a use characteristic of the memory device.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The memory controller of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the memory controller is further configured to modify the particular ECC coverage area size for the particular portion of the memory device based on a data type stored in the particular portion of the memory device.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The memory controller of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the memory controller is further configured to modify the particular ECC coverage area size for the particular portion of the memory device based on a bit error rate of the particular portion of the memory device.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The memory controller of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the memory controller is further configured to modify an ECC code type for the particular portion of the memory device when modifying the particular ECC coverage area size for the particular portion of the memory device.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The memory controller of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the modified ECC code type for the particular portion of the memory device is an ECC code type having a different math base than an ECC code type for the particular portion of the memory device before modification.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The memory controller of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the memory controller is further configured to use a different ECC code type for a different portion of the memory device.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The memory controller of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the memory controller is further configured to use a different ECC coverage area size for a different portion of the memory device.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The memory controller of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the memory controller is further configured to perform a read operation on the particular portion of the memory device, to store user data read from the particular portion of the memory device to the data buffer, and to verify the user data by comparing the generated ECC codes to ECC codes read from the particular portion of the memory device.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. A memory controller, comprising
<claim-text>a data buffer coupled to receive and hold data from a memory device; and</claim-text>
<claim-text>an Error Correction Code (ECC) generator/checker coupled to the data buffer, wherein the ECC generator/checker is configured to generate ECC codes for the data and to compare the generated ECC codes with ECC codes received with the data;</claim-text>
<claim-text>wherein the ECC generator/checker is configured to use a first ECC code type for data received from a first portion of the memory device and to use a second ECC code type for data received from a second portion of the memory device; and</claim-text>
<claim-text>wherein the first ECC code type has a different math base than the second ECC code type.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The memory controller of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the first ECC code type is associated with a first ECC coverage area size and the second ECC code type is associated with a second ECC coverage area size.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The memory controller of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the first ECC coverage area size and the second ECC coverage area size each comprise an integer number of sectors of user data.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The memory controller of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the memory controller is configured to modify the first ECC code type based on at least one criteria selected from the group consisting of a data type stored in the first portion of the memory device and a bit error rate of the first portion of the memory device.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The memory controller of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the memory controller is further configured to perform a read operation on a particular portion of the memory device, to store user data read from the particular portion of the memory device to the data buffer, and to verify the user data by comparing the generated ECC codes for the user data read from the particular portion of the memory device to ECC codes read from the particular portion of the memory device.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. A memory controller, comprising
<claim-text>a data buffer coupled to receive and hold data from a memory device;</claim-text>
<claim-text>an Error Correction Code (ECC) generator/checker coupled to the data buffer, wherein the ECC generator/checker is configured to generate ECC codes for the data and to compare the generated ECC codes with ECC codes received with the data;</claim-text>
<claim-text>wherein the ECC generator/checker is configured to generate ECC codes using a first ECC coverage area size for data received from a first portion of the memory device and to generate ECC codes using a second ECC coverage area size for data received from a second portion of the memory device.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The memory controller of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the first ECC coverage area size is associated with a first ECC code type and the second ECC coverage area size is associated with a second ECC code type.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The memory controller of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the first ECC coverage area size and the second ECC coverage area size each comprise an integer number of sectors of user data.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The memory controller of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the memory controller is configured to modify the first ECC coverage area size based on at least one criteria selected from the group consisting of a data type stored in the first portion of the memory device and a bit error rate of the first portion of the memory device.</claim-text>
</claim>
</claims>
</us-patent-grant>
