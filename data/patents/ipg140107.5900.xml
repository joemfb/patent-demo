<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627009-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627009</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12211159</doc-number>
<date>20080916</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>937</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>12</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>711122</main-classification>
<further-classification>711E12052</further-classification>
<further-classification>711138</further-classification>
</classification-national>
<invention-title id="d2e53">Cache filtering method and apparatus</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5625793</doc-number>
<kind>A</kind>
<name>Mirza</name>
<date>19970400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6769047</doc-number>
<kind>B2</kind>
<name>Kurupati</name>
<date>20040700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6804750</doc-number>
<kind>B2</kind>
<name>LaBerge</name>
<date>20041000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>7149850</doc-number>
<kind>B2</kind>
<name>Minami</name>
<date>20061200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>7325102</doc-number>
<kind>B1</kind>
<name>Cypher</name>
<date>20080100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711146</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>7596661</doc-number>
<kind>B2</kind>
<name>Hsu et al.</name>
<date>20090900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711122</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2006/0112233</doc-number>
<kind>A1</kind>
<name>Hu et al.</name>
<date>20060500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711138</main-classification></classification-national>
</us-citation>
<us-citation>
<nplcit num="00008">
<othercit>Johnson, Teresa et al, &#x201c;Run-time Adaptive Cache Hierarchy Management via Reference Analysis,&#x201d; Proceedings of the 24th Annual International Symposium on Computer Architecture, (ISCA 1997), vol. 25, Issue 2 (May 1997).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00009">
<othercit>Mekhiel, Nagi, &#x201c;LHA: Latency Hiding Algorithm for DRAM,&#x201d; 2nd Annual Workshop on Memory Performance Issues (WMPI 2002), Mar. 2002.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00010">
<othercit>PCT/CA2009/001169, International Search Report, 3 pages, Nov. 24, 2009.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00011">
<othercit>Mowry, Todd et al., Design and Evaluation of a Compiler Algorithm for Prefetching, Computer Systems Laboratory, Stanford University, CA (1992).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00012">
<othercit>Gonzalez, Antonio, et al., A Data Cache with Multiple Caching Strategies Tuned to Different Types of Locality, Universitat Politecnica de Catalunya, Departmento de Arquitetura de Computadores, Barcelona, Spain (1995).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00013">
<othercit>Saulsbury, Ashley, et al., Missing the Memory Wall: the Case for Processor/Memory Integration, Sun Microsystems Computer Corporation, Swedish Institute of Computer Science (1996).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00014">
<othercit>Ranganathan, Parthasarathy, et al., The Interaction of Software Prefetching with ILP Processors in Shared-Memory Systems, Department of Electrical and Computer Engineering, Rice University, Houston, TX (1997).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00015">
<othercit>Mekhiel, Nagi, The Effect of an Intercepting Cache on Performance of Fast Page and Cache DRAM, Department of Electrical and Computer Engineering, Ryerson Polytechnic University, Toronto, Ontario (1998).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00016">
<othercit>Sanchez, Jesus, et al., A Locality Sensitive Multi-Module Cache with Explicit Management, Universitat Politecnica de Catalunya, Department of Computer Architecture, Barcelona, Spain (1999).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00017">
<othercit>Truong, Dan N., et al., Improving Cache Behavior of Dynamically Allocated Data Structures, IRISA&#x2014;INRIA, Campus de Beaulieu, Rennes, CEDEX, France (1998).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00018">
<othercit>Mutlu, Onur, et al., Cache Filtering Techniques to Reduce the Negative Impact of Useless Spectulative Memory References on Processor Performance, Department of Electrical and Computer Engineering, The University of Texas at Austin (2004).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00019">
<othercit>Mekhiel, Nagi, Multi-Level Cache with Most Frequently Used Policy: a New Concept in Cache Design, Department of Electrical and Computer Engineering, Ryerson Polytechnic University, Toronto, Ontario (1995).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00020">
<othercit>Tomasko, Michelle, et al., Colorado State University, Computer Science Technical Report, Fort Collins, CO (1997).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>16</number-of-claims>
<us-exemplary-claim>13</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>711122</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>20</number-of-drawing-sheets>
<number-of-figures>20</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20100070709</doc-number>
<kind>A1</kind>
<date>20100318</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Mekhiel</last-name>
<first-name>Nagi Nassief</first-name>
<address>
<city>Markham</city>
<country>CA</country>
</address>
</addressbook>
<residence>
<country>CA</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Mekhiel</last-name>
<first-name>Nagi Nassief</first-name>
<address>
<city>Markham</city>
<country>CA</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<last-name>Haszko</last-name>
<first-name>Dennis R.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Mosaid Technologies Incorporated</orgname>
<role>03</role>
<address>
<city>Ottawa</city>
<country>CA</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Padmanabhan</last-name>
<first-name>Manorama</first-name>
<department>2189</department>
</primary-examiner>
<assistant-examiner>
<last-name>Ahmed</last-name>
<first-name>Hamdy S</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A method and apparatus used within memory and data processing that reduces the number of references allowed in processor cache by using active rows to reject references that are less frequently used from the cache. Comparators within a memory controller are used to generate a signal indicative of a row hit or miss, which signal is then applied to one or more demultiplexers to enable or disable transfer of a memory reference to processor cache locations. The cache may be level one (L1) or level two (L2) caches including data and or instructions or some combination of L1, L2, data, and instructions.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="205.06mm" wi="100.08mm" file="US08627009-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="215.90mm" wi="144.53mm" file="US08627009-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="207.86mm" wi="109.14mm" file="US08627009-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="225.98mm" wi="101.94mm" file="US08627009-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="202.86mm" wi="152.06mm" file="US08627009-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="198.54mm" wi="156.29mm" file="US08627009-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="229.87mm" wi="149.44mm" orientation="landscape" file="US08627009-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="245.45mm" wi="151.81mm" file="US08627009-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="252.39mm" wi="169.25mm" file="US08627009-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="165.10mm" wi="99.40mm" file="US08627009-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="151.21mm" wi="93.98mm" file="US08627009-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="227.92mm" wi="146.73mm" orientation="landscape" file="US08627009-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="227.67mm" wi="147.91mm" orientation="landscape" file="US08627009-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="127.42mm" wi="149.27mm" file="US08627009-20140107-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="124.88mm" wi="151.13mm" file="US08627009-20140107-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="122.94mm" wi="150.45mm" file="US08627009-20140107-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00016" num="00016">
<img id="EMI-D00016" he="131.57mm" wi="149.78mm" file="US08627009-20140107-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00017" num="00017">
<img id="EMI-D00017" he="125.90mm" wi="148.67mm" file="US08627009-20140107-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00018" num="00018">
<img id="EMI-D00018" he="126.92mm" wi="151.47mm" file="US08627009-20140107-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00019" num="00019">
<img id="EMI-D00019" he="118.79mm" wi="147.91mm" file="US08627009-20140107-D00019.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00020" num="00020">
<img id="EMI-D00020" he="133.94mm" wi="151.81mm" file="US08627009-20140107-D00020.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">TECHNICAL FIELD</heading>
<p id="p-0002" num="0001">The present invention relates generally to memory and processing. More particularly, the present invention relates to a method and apparatus for cache filtering.</p>
<heading id="h-0002" level="1">BACKGROUND</heading>
<p id="p-0003" num="0002">Within the art of computer processing and memory systems in particular, the speed gap between processor and main memory has grown. This gap directly impacts the performance of overall computing systems. To alleviate performance concerns, computing systems include a cache mechanism upon which they depend to bridge this speed gap. The success of such cache mechanisms in bridging this speed gap varies with parameters such as size, block size, and associativity. However, such cache mechanisms cannot continuously improve performance by changing these parameters because in doing so there is reached a point of diminishing returns due increasing system complexity, power consumption and the behavior of the cache itself.</p>
<p id="p-0004" num="0003">Existing caching mechanisms generally depend upon spatial and temporal localities of references in order for the caching to be effective. However, some situations such as multimedia applications have limited localities and are more dependent on the performance of main memory. Also, applications that are written in C, C++, and Object Oriented Programming use dynamically allocated data structures to map data to available memory space. As such data could be scattered in memory and therefore lack spatial locality. Data elements in these applications might not be reused soon enough in time and thus also lack temporal locality. The lack of spatial and temporal locality in these types of computing applications makes conventional cache mechanisms less effective.</p>
<p id="p-0005" num="0004">Within memory systems, a reference that lacks spatial and temporal locality but is used many times is more important to keep in cache than a reference that is captured in cache but never used again. Cached references that are not used again are undesirable because they compete with the other more frequently used references. As well, references that have poor spatial and temporal locality but are rich in their frequency of use must not be removed or replaced.</p>
<p id="p-0006" num="0005">Improvements to such cache mechanisms have generally been achieved by utilizing the locality of references that might not exist in some applications. Most often, this is accomplished with the added cost of extra hardware to keep more references in cache by increasing the size or associativity of cache, providing extra levels of memory hierarchy, or providing pre-fetching buffers.</p>
<p id="p-0007" num="0006">Accordingly, cache mechanisms have become less efficient due to the growing gap between processor speed and main memory speed and the lack of localities in some applications. To deal with cache limitations and the continuous increase in cache miss penalty, hardware and software pre-fetching schemes have been used to fetch the data from the main memory in advance, before the data is needed. While such pre-fetching methods are useful for regular access patterns found in some applications, such methods cannot hide very long cache miss latencies which may extend to hundreds of cycles in modern and future processors.</p>
<p id="p-0008" num="0007">Other methods have been proposed to better manage primary memory cache (i.e., level 1 or L1 cache) through selective allocation. These selective allocation schemes statically partition the cache so that cache blocks are allocated in different sub-caches based upon their spatial and temporal localities. However, these methods are problematic in that they may perform poorly if the access patterns do not suit the partitioning.</p>
<p id="p-0009" num="0008">Other methods have been proposed which employ the frequency of use of references in a multi-level cache so as to move the most frequently used references to a higher level cache in order to improve L1 cache performance. However, this approach is suitable for systems with a small L1 cache, becoming less effective when L1 cache size and associativity increases.</p>
<p id="p-0010" num="0009">Still other methods have been proposed using the first level cache as a filter so as to bring useful speculative memory references to first level cache. However, this approach yields limited performance improvements and disadvantageously increases hardware cost in order to predict the usefulness of references.</p>
<p id="p-0011" num="0010">It is, therefore, desirable to provide a cache mechanism that bridges the speed gap between modern memory systems and computer processors in a cost-effective manner that does not rely upon costly additional hardware and can handle large memory caches.</p>
<heading id="h-0003" level="1">SUMMARY</heading>
<p id="p-0012" num="0011">It is an object of the present invention to obviate or mitigate at least one disadvantage of previous cache mechanisms.</p>
<p id="p-0013" num="0012">It has been herein recognized by analysis of the behavior of memory references that there are few references that are used many times and many references that are never used more than one time. Moreover, it has been found that the number of addresses that are used two or more times are roughly half the number of addresses that are used one or more times. This means that half of the addresses that are transferred to conventional cache are never used. They are transferred to the cache from the main memory using valuable processor and memory bus time. Furthermore, the references that are never used in cache compete with the references that are frequently used and could displace them. It is therefore useful to keep in cache references that are used more frequently and reject less frequently used references.</p>
<p id="p-0014" num="0013">In general, embodiments of the present invention provide for dynamic management of the cache by monitoring the behavior of references to DRAM open rows. Data in DRAM is not affected by the processor's pre-fetching schemes or caching. When having data in caches, their localities change because only a limited size of data are transferred to the cache at a given time. Existing schemes that use the behavior of data in caches are influenced by the processor and are limited in their scope to the cache localities. Accordingly, it becomes evident that cache limitations cannot be cured from the cache itself, but rather one must look outside the cache. Embodiments of the present invention provide a new approach to improve cache performance without increasing system complexity. This is made possible by utilizing the behavior of references and their frequency of use in main memory.</p>
<p id="p-0015" num="0014">Embodiments of the present invention provide for rejection of addresses that are used once, thereby reducing cache conflicts and evictions of useful blocks. Miss penalty is also reduced due to the reduction in transfer time of the whole cache block for rejected references. Embodiments of the present invention provide for transfer of one word to the processor register if it rejects the reference from the cache. In a typical multi core chip, the demand for memory bus utilization increases and limits system scalability. Embodiments of the present invention provide for reduction of bus utilization by eliminating the transfer of long cache blocks to processor for references that are used only once.</p>
<p id="p-0016" num="0015">In a first aspect, the present invention provides a method of cache filtering, the method including: upon a cache miss, obtaining a row hit/miss signal for a given memory reference; and rejecting the memory reference associated with the row hit/miss signal when the row hit/miss signal indicates a row miss.</p>
<p id="p-0017" num="0016">In a further embodiment, there is provided a method of cache filtering within a Dynamic Random Access Memory (DRAM), the method including: generating a row hit/miss signal corresponding to a memory reference; and upon occurrence of level one (L1) and level two (L2) cache misses and where the row hit/miss signal indicates a row miss, accessing data in the DRAM and latching a row address in a corresponding row latch.</p>
<p id="p-0018" num="0017">In a further embodiment, the present invention provides an apparatus for data processing, the apparatus including: a memory having a plurality of locations; a memory controller coupled to the memory, the memory controller including at least one comparator for generating a row hit/miss signal corresponding to a memory reference related to one of the plurality of locations; and at least one demultiplexer operatively coupled to the memory controller where the row hit/miss signal is used by the demultiplexer so as to route data related to the memory reference; and row latches for latching a row corresponding to the data.</p>
<p id="p-0019" num="0018">In a further embodiment, there is provided a method of cache filtering within a Static Random Access Memory (SRAM), the method including: generating a row hit/miss signal corresponding to a memory reference; and upon occurrence of level one (L1) and level two (L2) cache misses and where the row hit/miss signal indicates a row miss, accessing data in the SRAM using random access mode and latching a row corresponding to the data.</p>
<p id="p-0020" num="0019">Other aspects and features of the present invention will become apparent to those ordinarily skilled in the art upon review of the following description of example embodiments of the invention in conjunction with the accompanying figures.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0021" num="0020">Embodiments of the present invention will now be described, by way of example only, with reference to the attached Figures.</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram illustrating a Dynamic Random Access Memory (DRAM) and row latches within a DRAM controller used in conjunction with an embodiment of the present invention.</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram for a system including a processor, DRAM, and DRAM controller and illustrating an embodiment of the present invention.</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 3</figref> is a block diagram in accordance with an embodiment of the present invention with regard to the DRAM controller as seen in <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 4</figref> is a diagram illustrating data transfer upon row signal indicating a row hit.</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 5</figref> is a diagram illustrating data transfer upon row signal indicating a row miss.</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 6</figref> is a flowchart illustrating an embodiment of the cache filtering method in accordance with an embodiment of the present invention.</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 7</figref> is an illustration of a system having multiple active partial rows within a given bank and within the system an embodiment of the present invention is applicable.</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 8</figref> is an illustration similar to <figref idref="DRAWINGS">FIG. 7</figref>, but where the system involves an adaptable regions variation.</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 9</figref> is a block diagram illustrating another embodiment of the present invention in terms of instruction and data caches.</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 10</figref> is a block diagram illustrating still another embodiment of the present invention in terms of L1 data caches.</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 11</figref> is a flowchart illustrating the embodiment of the cache filtering method in accordance with <figref idref="DRAWINGS">FIG. 10</figref>.</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 12</figref> is a flowchart illustrating another embodiment of the cache filtering method in accordance closed page DRAM policy.</p>
<p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. 13</figref> is a graphical illustration of benchmark traces versus their address usage averages.</p>
<p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. 14</figref> is a comparative graphical illustration of L1 miss rate for the benchmark traces identified in <figref idref="DRAWINGS">FIG. 13</figref> and used within a conventional system as compared to a system using a cache filtering in accordance with an embodiment of the present invention.</p>
<p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. 15</figref> is a comparative graphical illustration of L2 miss rate for the benchmark traces identified in <figref idref="DRAWINGS">FIG. 13</figref> and used within a conventional system as compared to a system using a cache filtering in accordance with an embodiment of the present invention.</p>
<p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. 16</figref> is a comparative graphical illustration of DRAM row hit rate for the benchmark traces identified in <figref idref="DRAWINGS">FIG. 13</figref> and used within a conventional system as compared to a system using a cache filtering in accordance with an embodiment of the present invention.</p>
<p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. 17</figref> is a comparative graphical illustration of performance for the benchmark traces identified in <figref idref="DRAWINGS">FIG. 13</figref> and used within a conventional system as compared to a system using a cache filtering in accordance with an embodiment of the present invention.</p>
<p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. 18</figref> is a comparative graphical illustration of performance for the benchmark traces identified in <figref idref="DRAWINGS">FIG. 13</figref> averaged within differing L2 cache sizes and used within a conventional system as compared to a system using a cache filtering in accordance with an embodiment of the present invention.</p>
<p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. 19</figref> is a comparative graphical illustration of performance for the benchmark traces identified in <figref idref="DRAWINGS">FIG. 13</figref> averaged within differing numbers of banks and used within a conventional system as compared to a system using a cache filtering in accordance with an embodiment of the present invention.</p>
<p id="p-0041" num="0040"><figref idref="DRAWINGS">FIG. 20</figref> is a comparative graphical illustration of performance for the benchmark traces identified in <figref idref="DRAWINGS">FIG. 13</figref> interleaved in pairs and used within a conventional system as compared to a system using a cache filtering in accordance with an embodiment of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0042" num="0041">Embodiments of the present invention provide a cache filtering method and apparatus that improves performance by using, in an illustrative embodiment, Dynamic Random Access Memory (DRAM) active rows to reject references that are less frequently used from cache without increasing system complexity.</p>
<p id="p-0043" num="0042">The present cache filter method and apparatus assumes a DRAM based memory system, however it should be understood that one could also use Static Random Access Memory (SRAM) or any other type of suitable storage without straying from the intended scope of at least some embodiments of the present invention.</p>
<p id="p-0044" num="0043">The following example, described with regard to the figures, is given to explain and illustrate one embodiment in accordance with the present invention and is detailed in terms of a conventional DRAM-based main memory system utilizing the present invention.</p>
<p id="p-0045" num="0044"><figref idref="DRAWINGS">FIG. 1</figref> shows a block diagram for a DRAM and row latches within a DRAM controller. The DRAM assumes using a multi-bank system that consists of 32 banks shown as bank<b>0</b> through bank<b>31</b>. Each bank has 1024 rows (i.e., r<b>0</b> through r<b>1023</b>) and each row has 1024 columns (i.e., c<b>0</b> through r<b>1023</b>). Total DRAM storage is 32 M words. Each word is assumed to be 4 Byte such that the total DRAM size=128 MB. The processor address (A<b>26</b>-A<b>0</b>) is used to access any byte in the 128 MB storage.</p>
<p id="p-0046" num="0045">The processor address is used to select a single location in terms of bank, row, column, and byte selections. Bank select involves address A<b>16</b>-A<b>12</b> being used to select one bank out of 32 banks. Row select involves address A<b>26</b>-A<b>17</b> being used to select one row in the accessed bank out of 1024 rows. Each bank is allowed to keep one row active at a time if open page policy is used. It is important to note that the cache filtering in accordance with embodiments of the present invention can use a closed page policy by storing the most recently accessed row of each bank in the DRAM controller's row latches. Row<b>720</b> is assumed to be accessed in bank<b>0</b>, and row<b>566</b> is assumed to be accessed in bank<b>31</b>. Column select involves address A<b>11</b>-A<b>2</b> being used to select one column out of 1024 in the accessed row. Byte select involves address A<b>1</b>-A<b>0</b> being used to select one Byte out of a 4 Byte word in the accessed Column and Row.</p>
<p id="p-0047" num="0046">As is typical of most cache mechanisms, embodiments of the present invention use an Open Page (OP) policy to exploit faster column access in DRAM. One active row should be latched in each bank. The number of latches needed is therefore equal to 32. Each latch stores 10 bits of address (A<b>26</b>-A<b>17</b>) each time a row is activated in DRAM. These latches are implemented in the DRAM controller. In this example, the first row latch stores the address of the active row in bank<b>0</b> which is 720. The last row latch stores the address of the active row in bank<b>31</b> which is 566. These inputs to these latches are all connected to the processor address A<b>26</b>-A<b>17</b>. Each row latch is clocked by a decoded RAS signal corresponding to each DRAM bank to latch a specific row address. These RAS signals act as a clock signal allowing each latch to store its accessed row when the row becomes active as in any conventional open page DRAM design.</p>
<p id="p-0048" num="0047"><figref idref="DRAWINGS">FIG. 2</figref> shows a block diagram for a system using the present invention. Referring to <figref idref="DRAWINGS">FIG. 2</figref>, a processor <b>200</b> includes level 1 (L1) caches <b>27</b>A, <b>27</b>B and level 2 (L2) cache <b>28</b>. The L2 cache <b>28</b> is a unified cache. The L1 cache <b>27</b>A is a portion for instructions receiving information via an instruction bus <b>26</b> and the cache <b>27</b>B is a portion for data receiving information via a data bus <b>25</b>. The instruction bus <b>26</b> is in communication with an instruction register <b>21</b>. A multi-bank DRAM <b>202</b> is used with open page policy. DRAM banks are page interleaved to increase row hit rate. A DRAM controller <b>201</b> receives memory requests from the processor <b>200</b> and generates Column Address Strobe (CAS) and Row Address Strobe (RAS) signals to access DRAM <b>202</b>. The DRAM controller <b>201</b> compares the row address of the current memory request to the addresses of the latched active rows and gives a row hit indication if there is a match. The first access to a location in DRAM <b>202</b> generates a row miss indication. The DRAM controller <b>201</b> then latches the accessed row to keep it active. If the next access to the same memory bank is to the same address, there will be a row hit.</p>
<p id="p-0049" num="0048">In general, embodiments of the present invention use the row hit signal to determine via comparators whether the DRAM reference has been used before. If the row comparator signal is a miss then this is either the first access to such location in DRAM or this row has been deactivated due to such location not being used or an intervening access to another location. If the row comparator signal is a hit, embodiments of the present invention allow the transfer of referenced data to the L1 and L2 caches and embodiments of the present invention reduce the number of references allowed in cache by rejecting references that generate row misses. This reduces the transfer time of data to the processor because, in a row miss, only one word is transferred to a register file <b>22</b>. By contrast, the whole block is transferred to the cache on both row hit and row miss in a conventional cache.</p>
<p id="p-0050" num="0049"><figref idref="DRAWINGS">FIG. 3</figref> shows a block diagram detailing the comparator use mentioned above and with specific regard to the DRAM controller <b>201</b>, processor <b>200</b>, and DRAM <b>202</b> seen in <figref idref="DRAWINGS">FIG. 2</figref>. Here, the DRAM controller <b>201</b> is shown with row latches including bank<b>0</b> row latch <b>31</b>-<b>1</b> through bank<b>31</b> row latch <b>31</b>-<b>32</b>. The row latches are used to latch the active rows of the accessed bank as mentioned above. Embodiments of the present invention also use row comparators <b>30</b>-<b>1</b> through <b>30</b>-<b>32</b>&#x2014;one for each row latch <b>31</b>-<b>1</b> through <b>31</b>-<b>32</b>&#x2014;to compare the current processor address to the latched row for the accessed bank in DRAM <b>202</b> so as to determine whether the current processor access is in an active row. Only the output of the comparator for the current accessed bank is considered. Other comparator outputs are disabled with a bank address decoder (not shown). The comparators <b>30</b>-<b>1</b> through <b>30</b>-<b>32</b> provide outputs signals representing determination results. In response to the comparator output signals, an OR gate <b>33</b> outputs a ROW HIT/MISS signal that is=1 if there is a row hit (i.e., a match between processor address A<b>26</b>-A<b>17</b> and the latched row) in the accessed bank. The comparators <b>30</b>-<b>1</b> through <b>30</b>-<b>32</b> compare bits A<b>26</b>-A<b>17</b> of the processor's address to the latched row for the accessed bank. If the current processor row address does not match the latched row, then comparator <b>33</b> outputs ROW HIT/MISS=0 thus indicating a miss. The DRAM controller <b>201</b> thus latches the current accessed row in the latch of the corresponding bank for next possible access to same row.</p>
<p id="p-0051" num="0050">The DRAM controller <b>201</b> also provides the processor <b>200</b> with the ROW HIT/MISS signal to decide whether to accept or reject the current memory reference to processor caches as required by the cache filtering method and apparatus in accordance with embodiments of the present invention. The DRAM controller <b>201</b> uses the processor address and control signals to generate the proper row address, column address and the rest of control signals (e.g., RAS, CAS, . . . etc) for the DRAM <b>202</b> to be accessed as in any conventional system.</p>
<p id="p-0052" num="0051">With further regard to <figref idref="DRAWINGS">FIG. 2</figref>, the processor <b>200</b> examines the ROW HIT/MISS signal <b>24</b> generated from the DRAM controller <b>201</b> and uses a de-multiplexer <b>23</b> to route the data to the caches or the register file <b>22</b>. The processor <b>200</b> also adjusts the timing needed for the data transfer to satisfy the size of data transfer. The processor <b>200</b> transfers a cache block, which normally consists of multiple words, and needs multiple processor bus cycles if the data is accepted in the cache as in any conventional system. If the reference from the DRAM <b>202</b> is rejected because it is less frequently used, then the processor needs only one cycle to transfer one word directly to the register file <b>22</b> in accordance with embodiments of the present invention.</p>
<p id="p-0053" num="0052"><figref idref="DRAWINGS">FIG. 4</figref> shows the timing of data transfer between the processor <b>400</b> and DRAM <b>410</b> along the data bus <b>420</b> when the ROW HIT/MISS signal is a hit which is the same bus timing as in a conventional system. The processor <b>400</b> needs to transfer the whole block in DRAM <b>410</b> to the L1 and L2 caches. Here, the L1 cache <b>401</b> includes block <b>401</b><i>a </i>and L2 cache <b>402</b> includes block <b>402</b><i>a</i>. The block size shown in DRAM <b>410</b> is assumed to be 32 words and takes 32 bus cycles <b>430</b> to complete the data transfer along data bus <b>420</b>. The register file <b>440</b> is described further in regard to <figref idref="DRAWINGS">FIG. 5</figref>.</p>
<p id="p-0054" num="0053"><figref idref="DRAWINGS">FIG. 5</figref> shows the timing of data transfer <b>430</b><i>a </i>when the ROW HIT/MISS signal is a miss and the processor <b>400</b> needs to transfer only the requested word to the register file <b>440</b>. The word takes one bus cycle.</p>
<p id="p-0055" num="0054"><figref idref="DRAWINGS">FIG. 6</figref> shows a flow chart of the cache filtering method in accordance with embodiments of the present invention. In general, a cache miss will occur with either a row hit or a row miss. In a cache miss to L1 and L2 and if the memory reference generates a row miss, the present method accesses data in the DRAM using random access mode and latches the accessed row. This represents the first use of an address and the method transfers data only to the register file. In a cache miss to L1 and L2 and if the memory reference generates a row hit, the method accesses the DRAM using open page mode and updates L1, L2 cache by transferring a whole block of data and keeps the row active. In operation, the data access will be either a READ access or a WRITE access.</p>
<p id="p-0056" num="0055">In the instance of a READ access as shown, the method initially determines whether L1 is a hit. If so, then the data will be read from L1 and the block will be rendered as Most Recently Used (MRU). If not, then the method will determine whether L2 is a hit. If so, then the data will be read from L2, L1 will be updated, the L1 and L2 blocks will be made MRU, and a Write Back (WB) of the L1 block will occur if the block is dirty&#x2014;i.e., if the block in cache has been modified by the processor, but not yet written back to storage. If L2 is not determined to be a hit, then the method will determine whether the hit is a row hit. If so, then the L2 block is checked whereupon a dirty L2 block will cause a WB of L2 or L1 to memory, a reading of memory using open page (OP) mode, an updating of L1 and L2, and making the blocks in L1 and L2 MRU. If the L2 block is not dirty, then memory is read using open page mode, L1 and L2 are updated, and the L1 and L2 block are made MRU. If L2 is not determined to be a hit and the method determines there is not a row hit, then memory will be read using random access transferring only a single word and the accessed row will be latched in the row latch. L1 and L2 are not updated.</p>
<p id="p-0057" num="0056">In the instance of a WRITE access, the method initially determines whether L1 is a hit. If so, then the data will be written to L1, the dirty bit will be set, and the block in L1 will be made MRU. If not, then the method will determine whether L2 is a hit. If so, then the data will be written to L1 and L2, the dirty bit in L1 and L2 will be set, and the L1 and L2 blocks will be made MRU. If L2 is determined not to be a hit, then the method will determine whether the access is a row hit. If not, then memory is written to using random access transferring only a single word, the accessed row is latched in the row latch, and L1 and L2 are not written to. If the access is a row hit and the L1 or L2 blocks are dirty, then the L2 or L1 blocks are written back to memory, then memory is written using open page mode, the L1 and L2 blocks are written to, and the L1 and L2 blocks made MRU. If the L1 or L2 blocks are not dirty, then memory is written using open page mode, the L1 and L2 blocks are written to, and the L1 and L2 blocks are made MRU.</p>
<p id="p-0058" num="0057">Alternative embodiments of the present invention are possible such that the method is optimized for different systems based on given system capabilities and the application requirements. Some systems may use more than two levels of cache or use different DRAM access policies such as a closed page policy, whereas still other applications may change their behavior at run time such as turning static selection of the filtered regions in the DRAM into a varying selection. To make the cache filtering method and apparatus in accordance with embodiments of the present invention optimized and suitable for such varied requirements, modifications of the embodiments in two ways is contemplated.</p>
<p id="p-0059" num="0058">Firstly, embodiments of the present invention may be modified in terms of selecting DRAM regions for filtering. A modification is made to increase the number of frequently used regions in each DRAM bank. The method described earlier has only one active row or region per each bank. Each row is a linear array of consecutive addresses. The modifications allows non-consecutive accesses in each bank to be used as frequently-used regions. Many applications have more than one active area being accessed in the same bank and therefore their data needs to be transferred to the cache.</p>
<p id="p-0060" num="0059">Secondly, embodiments of the present invention may be modified in terms of cache filter selection. In particular, the embodiments may be modified to be able to select a specific cache level or combinations of caches in the processor to reject less frequently used references from them. For example, the method could have the L1 data cache reject less frequently used accesses while the other levels accept them. The detailed descriptions of these alternative embodiments will now be further detailed hereinbelow.</p>
<p id="p-0061" num="0060">In accordance with a further embodiment of the present invention, a multiple active region variation is contemplated. In particular, in order to improve the selectivity of the previously described cache filtering method, two partial rows in each bank are selected for storage in the row latch. In the previously described method, only one row per bank is latched and each time an access goes to a different row in the same bank, the previously latched row must be replaced by the new one. In many applications, more than one area in the same bank can be active and must therefore be transferred to the cache. Multiple row latching allows the cache to be updated from more than one row in each bank. This makes the filtering more selective in rejecting less frequently used references and reduces the probability of rejecting accesses to an active DRAM area. In terms of the present description, &#x201c;active&#x201d; means that the processor still visits this area and accesses its data.</p>
<p id="p-0062" num="0061"><figref idref="DRAWINGS">FIG. 7</figref> shows a system that uses latches for multiple active partial rows in each bank. It should be noted that the DRAM banks do not need to use an open page policy to have the latches in the DRAM controller store one or more row address. Each access to the DRAM bank has a specific row address that can be stored in the corresponding latch in the DRAM controller.</p>
<p id="p-0063" num="0062">Still with reference to <figref idref="DRAWINGS">FIG. 7</figref>, the latches of each bank store two partial rows. Each partial row is one half of the whole row and, in the illustrated example, have only 512 columns (e.g., upper r<b>12</b>, lower r<b>823</b>). The size of each latch is twice the size of the latch needed to store one row address, with two additional bits for storing A<b>11</b>. Address A<b>11</b> determines whether the upper half or the lower half of the row is selected. Further, the bank<b>0</b> latch stores upper row<b>12</b> and lower row<b>823</b>, whereas the bank<b>31</b> latch stores lower row<b>17</b> and lower row<b>956</b>. This effectively means any access to these partial rows of these banks will be allowed in the cache.</p>
<p id="p-0064" num="0063">In accordance with still a further embodiment of the present invention, and with regard to <figref idref="DRAWINGS">FIG. 8</figref> an adaptable regions variation is contemplated. <figref idref="DRAWINGS">FIG. 8</figref> shows a block diagram of an adaptable regions variation. In this embodiment, the addresses in row latches are allowed to change based on a row select signal from the processor and a multiplexer that has the whole address of the processor as an input (A<b>31</b> through A<b>0</b>). This allows the active region to be defined anywhere within the bank array. For example, if the processor select signal selects A<b>11</b>-A<b>2</b> to be stored in the row latches, then any access that has A<b>11</b>-A<b>2</b> address the same as the latched A<b>11</b>-A<b>2</b> will be considered as an active access. This region is a vertical array of memory locations in the DRAM bank.</p>
<p id="p-0065" num="0064">To explain with another example, assume the processor passes through mux the latched address to be: A<b>24</b> to A<b>17</b>, and A<b>11</b>, A<b>10</b> (10 BITS). Here, A<b>26</b>, A<b>25</b> of row address are replaced with column address A<b>11</b>, A<b>10</b>. Assuming further that the processor initializes this address to 0 by making a false access to an address where A<b>24</b>-A<b>17</b>, A<b>11</b>, A<b>10</b>=0. Being obtained by having all possible values for the remainder of addresses A<b>26</b>, A<b>25</b>, A<b>9</b>-A<b>2</b>, the following locations will be accepted in cache:</p>
<p id="p-0066" num="0065">1-ROW#0 CL<b>255</b> . . . CL<b>0</b> (A<b>26</b>, A<b>25</b>=00)</p>
<p id="p-0067" num="0066">2-ROW#256 CL<b>255</b> to CL<b>0</b> (A<b>26</b>, A<b>25</b>=01)</p>
<p id="p-0068" num="0067">3-ROW#512 CL<b>255</b> to CL<b>0</b> of ROW#512 (A<b>26</b>, A<b>25</b>=10)</p>
<p id="p-0069" num="0068">4-ROW#768 CL<b>255</b> to CL<b>0</b> of ROW#768 (A<b>26</b>, A<b>25</b>=11)</p>
<p id="p-0070" num="0069">The adaptable regions variation is able to select any area in the DRAM bank from one horizontal array (i.e., row) to one vertical array (i.e., one column different rows) as needed by the application. The block diagram in <figref idref="DRAWINGS">FIG. 8</figref> also illustrates that each latch is able to store two regions which can take any row/column size or organization based on the select signals. Other variations in this embodiment could provide that more than two regions be stored in each bank latch. It should be readily apparent that the number of active regions and the size of each active region depends upon, and may vary with, the given application and system architecture without straying from the intended scope of embodiments of the present invention.</p>
<p id="p-0071" num="0070">In accordance with a further variation, an alternative embodiment of the invention will be described with regard to <figref idref="DRAWINGS">FIG. 9</figref> in terms of instruction and data caches within a processor <b>900</b>. <figref idref="DRAWINGS">FIG. 9</figref> shows a block diagram of an inventive cache filter used to reject less frequently used references from both instruction and data caches. Here, the processor <b>900</b> uses one demultiplexer <b>93</b> for data caches and one demultiplexer <b>94</b> for instruction caches. Rejected accesses from instruction caches are stored in the instruction register <b>91</b> and take one bus cycle. As before, when the ROW HIT/MISS signal is a miss the processor <b>900</b> needs to transfer only the requested word to the register file <b>92</b>.</p>
<p id="p-0072" num="0071">In accordance with still another variation, an alternative embodiment of the invention will be described with regard to <figref idref="DRAWINGS">FIG. 10</figref> in terms of L1 data caches. <figref idref="DRAWINGS">FIG. 10</figref> shows a block diagram of a cache filter scheme used to reject less frequently used references from L1 data cache only. Here, the processor <b>1000</b> uses the demultiplexer <b>103</b> for the L1 data cache to reject or accept data from the DRAM into the L1 data cache. Rejected accesses from L1 cache are stored in the register file <b>102</b>. <figref idref="DRAWINGS">FIG. 11</figref> shows a flow chart of memory data accessing for this variation. <figref idref="DRAWINGS">FIG. 11</figref> differs from the embodiment of invention shown in <figref idref="DRAWINGS">FIG. 6</figref> in that upon a row miss, the method updates the L2 cache with a block of data and does not allow data to be stored in the L1 data cache.</p>
<p id="p-0073" num="0072">In all of the above mentioned various embodiments, the DRAM access policy can be an open page policy or a closed page policy. Moreover, the latching of selected regions in each bank is not dependent on the DRAM access mode used.</p>
<p id="p-0074" num="0073">In accordance with yet another variation, an alternative embodiment of the invention will be described with regard to <figref idref="DRAWINGS">FIG. 12</figref> in terms of an inventive cache filter that uses a closed page DRAM policy. Here, <figref idref="DRAWINGS">FIG. 12</figref> differs from the embodiment of the invention shown in <figref idref="DRAWINGS">FIG. 6</figref> in that the row hit signal does not indicate that a DRAM open page is used. Rather, the row hit signal means that the latched address of the accessed region is active and was used before. It should be noted that here Closed Page (CP) mode is used in both row hit and row miss conditions.</p>
<p id="p-0075" num="0074">In operation, an embodiment of the present invention was applied using SPEC2000&#x2122; benchmark traces that were collected from a real system to analyze the frequency of use of memory addresses in applications. SPEC2000&#x2122; benchmark traces are a standardized set of relevant benchmarks that can be applied to the newest generation of high-performance computers. Such traces are set by the Standard Performance Evaluation Corporation (SPEC) which is a non-profit corporation formed to establish, maintain, and endorse SPEC benchmark suites.</p>
<p id="p-0076" num="0075">Utilizing the traces, the number of addresses in each application was counted and the frequency of their use was divided between addresses used for one time or more and addresses used for two times or more. To explain the frequency of use of addresses, the following addresses are assumed to be accessed in the order they are listed: A<b>1</b>, A<b>13</b>, A<b>2</b>, A<b>1</b>, A<b>55</b>, A<b>23</b>, A<b>13</b>, A<b>39</b>, A<b>13</b>, A<b>7</b>, A<b>13</b>, A<b>1</b>, A<b>11</b>, A<b>22</b>, A<b>13</b>, A<b>1</b>, A<b>11</b>, A<b>13</b>, A<b>39</b>, A<b>1</b>. The number of addresses that are used one time or more=9 which are: A<b>1</b>, A<b>13</b>, A<b>2</b>, A<b>55</b>, A<b>23</b>, A<b>39</b>, A<b>7</b>, A<b>11</b>, A<b>22</b> and are used for 20 times. The number of addresses that are used two times or more=4 which are: A<b>1</b>, A<b>13</b>, A<b>11</b>, A<b>39</b> and used for 15 times.</p>
<p id="p-0077" num="0076"><figref idref="DRAWINGS">FIG. 13</figref> shows the average number of addresses in 10 benchmarks and the frequency of their use. A 0.5 million reference sample was selected from each of the traces of theses applications. The size of the sample was selected to simplify the search. It was also found that a sample size of more than 0.5 million references did not have significant effect upon the statistics. The following traces from SPEC2000&#x2122; benchmarks were used: gcc, gzip, parser, vortex, perlmk, twolf, apsi, equake, swim, and mgrid. From the results shown in <figref idref="DRAWINGS">FIG. 13</figref>, it was established that: 1) The addresses have very high frequency of use such that the average number of the addresses for all traces that are used one time or more was equal to 27,036 and are used for 212,390 times, where the average use for each address was=7.8; and 2) the average number of addresses used two times or more for all traces was equal to 13,120 and used for 198,474 times, where the average usage for each address was=15.12.</p>
<p id="p-0078" num="0077">In evaluating performance, a conventional system using a modern processor and DRAM was compared against a second system using the same processor and DRAM with the inventive cache filtering method applied. The processor and DRAM parameters for the two systems shown below in TABLE 1. The parameters were selected to represent typical values used in a modern computer system.</p>
<p id="p-0079" num="0078">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="147pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="2" rowsep="1">TABLE 1</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry>Component</entry>
<entry>Value</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>Processor speed:</entry>
<entry>3.3 GHz</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="14pt" align="left"/>
<colspec colname="2" colwidth="56pt" align="left"/>
<colspec colname="3" colwidth="147pt" align="left"/>
<tbody valign="top">
<row>
<entry>L1</entry>
<entry>Instruction cache:</entry>
<entry>32 Kbytes, 4-way, 64 byte block, access</entry>
</row>
<row>
<entry/>
<entry/>
<entry>time = 0.3 ns.</entry>
</row>
<row>
<entry>L1</entry>
<entry>Data cache:</entry>
<entry>32 Kbytes, 4-way, 64 byte block, access</entry>
</row>
<row>
<entry/>
<entry/>
<entry>time = 0.6 ns.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="147pt" align="left"/>
<tbody valign="top">
<row>
<entry>L2 cache:</entry>
<entry>unified, 1 Mbytes, 8-way, 128 byte block,</entry>
</row>
<row>
<entry/>
<entry>access time = 3.6 ns.</entry>
</row>
<row>
<entry>Memory Processor</entry>
<entry>8 byte width, 500 MHz speed.</entry>
</row>
<row>
<entry>Bus:</entry>
</row>
<row>
<entry>DRAM:</entry>
<entry>32-banks, 4 Kbyte row-buffer, page interleaving,</entry>
</row>
<row>
<entry/>
<entry>open page policy.</entry>
</row>
<row>
<entry>DRAM timing:</entry>
<entry>open-page (row-buffer hit) = 50 ns, row</entry>
</row>
<row>
<entry/>
<entry>conflict = 100 ns.</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0080" num="0079">A simple trace-driven simulator was used with SPEC2000&#x2122; traces to model a multi-level cache system and DRAM with multiple banks. The simulator calculated the average time per each access by adding the cost, in time, for each access based on the type of operation and the cost of operation in the different memory levels. More specifically, the DRAM consisted of a number of banks interleaved around a DRAM page of 4 Kbyte size where each bank latched a specific row that consisted of 4096 column locations. Any access that maps the same row gives a row hit and is accessed in 50 ns while a row miss is accessed in 100 ns.</p>
<p id="p-0081" num="0080">The simulator followed the method shown in <figref idref="DRAWINGS">FIG. 6</figref> to simulate application of an embodiment of the present invention within a given processor and DRAM. The results are shown in <figref idref="DRAWINGS">FIG. 14</figref> which illustrates the miss rate of L1 data cache for a conventional system and a system with the present inventive cache filtering applied.</p>
<p id="p-0082" num="0081">From the graphical illustration of <figref idref="DRAWINGS">FIG. 14</figref>, it can be seen that the cache filtering in accordance with an embodiment of the present invention improves L1 data cache miss rate by an average of 2%. The embodiment of present invention helps L1 miss rate although it prevents first time accesses from being transferred to the cache. This is compensated for by the present invention rejecting the once-used references that would otherwise compete with other blocks and evict them. The embodiment of the present invention was not applied to the instruction cache on the assumption that most instructions have high localities and very few instructions are suitable for rejection. Thus the embodiment of the present invention would have limited benefit to instruction cache performance under this assumption.</p>
<p id="p-0083" num="0082"><figref idref="DRAWINGS">FIG. 15</figref> graphically illustrates the data miss rate of the L2 cache for a conventional system versus a system with an embodiment of the present invention applied. Here, it is shown that the inventive cache filtering increases the L2 data miss rate by 17% on average due to rejecting accesses of first time use. The cache filter gains from reducing the eviction rate and the number of write back operations as illustrated below by TABLE 2 in number of references to DRAM.</p>
<p id="p-0084" num="0083">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="49pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="center"/>
<colspec colname="3" colwidth="98pt" align="center"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="3" rowsep="1">TABLE 2</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>Trace</entry>
<entry>Conventional</entry>
<entry>Cache Filter</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>gcc:</entry>
<entry>503,074</entry>
<entry>505,755</entry>
</row>
<row>
<entry/>
<entry>gzip:</entry>
<entry>331,642</entry>
<entry>266,907</entry>
</row>
<row>
<entry/>
<entry>parser:</entry>
<entry>381,286</entry>
<entry>379,327</entry>
</row>
<row>
<entry/>
<entry>vortex:</entry>
<entry>607,004</entry>
<entry>603,903</entry>
</row>
<row>
<entry/>
<entry>perlmk:</entry>
<entry>494,767</entry>
<entry>481,144</entry>
</row>
<row>
<entry/>
<entry>twolf:</entry>
<entry>488,881</entry>
<entry>516,329</entry>
</row>
<row>
<entry/>
<entry>apsi:</entry>
<entry>398,304</entry>
<entry>380,816</entry>
</row>
<row>
<entry/>
<entry>equake:</entry>
<entry>373,932</entry>
<entry>356,196</entry>
</row>
<row>
<entry/>
<entry>swim:</entry>
<entry>540,008</entry>
<entry>574,946</entry>
</row>
<row>
<entry/>
<entry>mgrid:</entry>
<entry>440,030</entry>
<entry>487,450</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0085" num="0084">TABLE 2 shows the total number of DRAM references in the system with the inventive cache filter applied versus a conventional cache system. DRAM references are generated from the cache misses in L1 and L2 for instructions and data plus the write back operations. The reductions in the eviction rate and the number of write back operations helps to compensate for the increase in L2 miss rate. Furthermore, the conventional system must transfer the whole block (i.e., 128 Byte) to the processor each time there is an L2 miss. The inventive cache filter transfers 1 word (i.e., 8 Byte) to the processor upon a row miss and transfers the whole L2 block only upon a row hit.</p>
<p id="p-0086" num="0085">Although the number of DRAM references in the system with the inventive cache filter applied is, on average, the same as the number of DRAM references in the conventional system, the L2 cache miss rate of the conventional system is lower than the L2 miss rate of the cache with an embodiment of the present invention applied. All cache misses generated from rejecting used once references in the cache with an embodiment of the present invention applied do not evict any blocks. This reduces the number of write back operations in the inventive cache filter and compensates for the difference in L2 miss rate.</p>
<p id="p-0087" num="0086">With regard to <figref idref="DRAWINGS">FIG. 16</figref>, the row hit rate for each given benchmark trace is shown for both the conventional system and the system having a cache filter in accordance with an embodiment of the present invention. The results illustrate that the cache filtering in accordance with the embodiment improves row hit rate by up to 50% and by 24% on average. The effect of intercepting caches on row hit rate was evaluated and revealed that caches intercept accesses to the DRAM, make them more scattered, and reduce the row hit rate. This means that a higher L2 miss rate forces the system to access the DRAM more often and helps to keep the DRAM rows active for a longer time.</p>
<p id="p-0088" num="0087">The relative performance between the conventional system and the system having a cache filter in accordance with an embodiment of the present invention is shown by way of <figref idref="DRAWINGS">FIG. 17</figref>. Performance here was defined as the average time (ns) per an access in any level (i.e., L1, L2). Across the benchmark traces, the cache filter in accordance with an embodiment of the present invention improved system performance by up to 44% and by 22% on average as compared to the conventional system. This gain is attributable both to the reduction in transfer time of the cache blocks from the DRAM for rejected blocks as well as to the improvement in row hit rate.</p>
<p id="p-0089" num="0088">Performance was also assessed for the benchmark traces with regard to differing L2 caches sizes and such is illustrated by way of <figref idref="DRAWINGS">FIG. 18</figref>. Here, the average performance of the ten benchmark traces is shown for four different cache sizes (i.e., 256 KB, 512 KB, 1024, KB, and 2048 KB) repeated for the conventional system as compared to the system having a cache filter in accordance with an embodiment of the present invention. The performance of a system using the inventive cache filter can be seen to be equivalent to the performance of a conventional system that uses an L2 cache of doubled size. For example, the average performance of the inventive cache filter using an L2 cache size of 1 MByte was 5.21 ns, whereas the average performance of a conventional system using an L2 cache size of 2 MByte was 5.19 ns. On average, the inventive cache filter improves performance by 22% for the different L2 cache sizes shown. This effectively demonstrates that at least some embodiments of the present invention are scalable with increases in L2 cache size, thereby being well-suited for future technology having larger and larger caches.</p>
<p id="p-0090" num="0089">In addition to considering increased cache size, the number of DRAM banks was increased with the performance results shown in <figref idref="DRAWINGS">FIG. 19</figref>. Specifically, <figref idref="DRAWINGS">FIG. 19</figref> shows the average performance of the ten traces repeated using increasing multiples of DRAM banks (i.e., 2, 4, 8, 16, and 32 banks) for the conventional system compared to a system using the inventive cache filter. Here, performance of the conventional system improves by 2.8% when the number of banks changes from 2 to 32 which indicates very little dependency on the number of banks. In contrast, performance of the inventive cache filter improves by 13.6% when number of banks changes from 2 to 32 which indicates a relatively strong dependency on the number of banks. Overall, the inventive cache filter improves performance&#x2014;e.g., by 19.2% compared to a conventional system when using 8 banks. Practically speaking, this suggests that most of the gain from the inventive cache filter could be achieved with a small number of banks.</p>
<p id="p-0091" num="0090">Still further, performance was considered in terms of interleaving the benchmark traces so as to form a parallel program having multiple threads. In particular, <figref idref="DRAWINGS">FIG. 20</figref> shows the average performance of five applications where each application consists of two threads that are interleaved on a single instruction. To simulate the effect of a dual core processor using a simple trace driven simulator, the size and associativity of each cache (i.e., L1 instruction, L1 data and L2) was doubled while the DRAM organization remained unchanged from that described in TABLE 1. The results graphically illustrate that the inventive cache filter improves performance by an average of 21.2% for multi-threading applications. Such improvement being consistent with the performance improvements illustrated and described by way of <figref idref="DRAWINGS">FIGS. 18</figref>, <b>19</b>, and <b>20</b>.</p>
<p id="p-0092" num="0091">In general, the inventive cache filtering thus provides advantageous performance improvements of advanced processors that exhibit growing speed gaps between the processor and the DRAM as well as those applications lacking temporal and spatial localities. Such improvements being achieved without adding to the cost or complexity of the system.</p>
<p id="p-0093" num="0092">The above-described embodiments of the present invention are intended to be examples only. Alterations, modifications and variations may be effected to the particular embodiments by those of skill in the art without departing from the scope of the invention, which is defined solely by the claims appended hereto.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method of cache filtering, said method comprising:
<claim-text>upon a cache miss, obtaining a row hit/miss signal associated with a bank of a main memory for a given memory reference; and</claim-text>
<claim-text>rejecting said memory reference associated with said row hit/miss signal from the cache when said row hit/miss signal indicates a row miss.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising transferring to memory cache said memory reference associated with said row hit/miss signal when said row hit/miss signal indicates a row hit.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method as claimed in <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein said transferring includes updating both level one cache and level two cache with said memory reference.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein a row miss signal corresponds to a first access to a location in the DRAM.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. A method of cache filtering within a main memory, said method comprising:
<claim-text>generating a row hit/miss signal associated with a bank of the main memory corresponding to a memory reference; and</claim-text>
<claim-text>upon occurrence of level one (L1) and level two (L2) cache misses and where said row hit/miss signal indicates a row miss, accessing data in said main memory using random access mode and latching a row corresponding to said data.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method as claimed in <claim-ref idref="CLM-00005">claim 5</claim-ref>, further comprising transferring said data only to a register file.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method as claimed in <claim-ref idref="CLM-00006">claim 6</claim-ref>, further comprising,
<claim-text>upon occurrence of L1 and L2 cache misses and where said row hit/miss signal indicates a row hit,
<claim-text>accessing data in said DRAM using open page mode,</claim-text>
<claim-text>updating L1 and L2 cache, and</claim-text>
<claim-text>maintaining as active said row corresponding to said data.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method as claimed in <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein a row miss signal corresponds to a first access to a location in the DRAM.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. An apparatus for data processing, said apparatus comprising:
<claim-text>a main memory having a plurality of locations;</claim-text>
<claim-text>a memory controller coupled to said main memory, said memory controller including at least one comparator for generating a row hit/miss signal corresponding to a memory reference related to one of said plurality of locations;</claim-text>
<claim-text>at least one demultiplexer operatively coupled to said memory controller where said row hit/miss signal is used by said demultiplexer so as to route data related to said memory reference; and</claim-text>
<claim-text>row latches for latching a row corresponding to said data.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The apparatus as claimed in <claim-ref idref="CLM-00009">claim 9</claim-ref> wherein said at least one demultiplexer is also operatively coupled to both level one (L1) and level two (L2) caches of a processor.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The apparatus as claimed in <claim-ref idref="CLM-00010">claim 10</claim-ref> further including a second demultiplexer operatively coupled to an L1 instruction cache of said processor, where said row hit/miss signal is used by said second demultiplexer so as to route instruction related to said memory reference and another row latch latches a row corresponding to an instruction row address.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The apparatus as claimed in <claim-ref idref="CLM-00009">claim 9</claim-ref> wherein said at least one demultiplexer is also operatively coupled only to level one (L1) cache of a processor and without regard to level two (L2) cache of said processor.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. A method of cache filtering within a main memory comprising Static Random Access Memory (SRAM), said method comprising:
<claim-text>generating a row hit/miss signal associated with a bank of the SRAM and corresponding to a memory reference;</claim-text>
<claim-text>upon occurrence of level one (L1) and level two (L2) cache misses and where said row hit/miss signal indicates a row miss, accessing data in said SRAM using random access mode and latching a row corresponding to said data.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The method as claimed in <claim-ref idref="CLM-00013">claim 13</claim-ref>, further comprising transferring said data only to a register file.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method as claimed in <claim-ref idref="CLM-00014">claim 14</claim-ref>, further comprising,
<claim-text>upon occurrence of L1 and L2 cache misses and where said row hit/miss signal indicates a row hit,
<claim-text>accessing data in said SRAM using open page mode,</claim-text>
<claim-text>updating L1 and L2 cache, and</claim-text>
<claim-text>maintaining as active said row corresponding to said data.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The method as claimed in <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein a row miss signal corresponds to a first access to a location in the SRAM. </claim-text>
</claim>
</claims>
</us-patent-grant>
