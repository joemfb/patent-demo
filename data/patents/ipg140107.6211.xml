<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627335-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627335</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>11559275</doc-number>
<date>20061113</date>
</document-id>
</application-reference>
<us-application-series-code>11</us-application-series-code>
<us-term-of-grant>
<us-term-extension>1366</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>3</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>44</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>46</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>13</main-group>
<subgroup>00</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>719313</main-classification>
</classification-national>
<invention-title id="d2e53">Method and apparatus for data space profiling of applications across a network</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6145121</doc-number>
<kind>A</kind>
<name>Levy et al.</name>
<date>20001100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717135</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6363053</doc-number>
<kind>B1</kind>
<name>Schuster et al.</name>
<date>20020300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370230</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6519766</doc-number>
<kind>B1</kind>
<name>Barritz et al.</name>
<date>20030200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717130</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>7007269</doc-number>
<kind>B2</kind>
<name>Sluiman et al.</name>
<date>20060200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>7039910</doc-number>
<kind>B2</kind>
<name>Kosche et al.</name>
<date>20060500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>7086064</doc-number>
<kind>B1</kind>
<name>Stevens</name>
<date>20060800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>719310</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2002/0032754</doc-number>
<kind>A1</kind>
<name>Logston et al.</name>
<date>20020300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2003/0101336</doc-number>
<kind>A1</kind>
<name>Kosche</name>
<date>20030500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2003/0188226</doc-number>
<kind>A1</kind>
<name>Talcott et al.</name>
<date>20031000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2004/0163079</doc-number>
<kind>A1</kind>
<name>Noy et al.</name>
<date>20040800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717154</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2005/0010930</doc-number>
<kind>A1</kind>
<name>Vaught</name>
<date>20050100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>719318</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2005/0021708</doc-number>
<kind>A1</kind>
<name>Raghuraman et al.</name>
<date>20050100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2006/0230391</doc-number>
<kind>A1</kind>
<name>Alexander et al.</name>
<date>20061000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717130</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2006/0259751</doc-number>
<kind>A1</kind>
<name>Sohm et al.</name>
<date>20061100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>2007/0043861</doc-number>
<kind>A1</kind>
<name>Baron et al.</name>
<date>20070200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>2008/0127120</doc-number>
<kind>A1</kind>
<name>Kosche et al.</name>
<date>20080500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00017">
<othercit>Nicolai Kosche, &#x201c;Sun Sensible&#x201d;, Sun Microsystems, Sep. 15, 2005, pp. 1-11.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00018">
<othercit>U.S. Appl. No. 10/881,032, entitled &#x201c;Performance Instrumentation in a Fine Grain Multithreaded Multicore Processor&#x201d; .</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00019">
<othercit>U.S. Appl. No. 10/880,485 entitled &#x201c;Associating Data Source Information With Runtime Events&#x201d;.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00020">
<othercit>U.S. Appl. No. 10/840,180 entitled &#x201c;Method and Apparatus for Correlating Profile Data&#x201d;.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00021">
<othercit>U.S. Appl. No. 10/840,164 entitled &#x201c;Method and Apparatus for Profiling Data Addresses&#x201d;.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00022">
<othercit>U.S. Appl. No. 10/840,167 entitled &#x201c;Method and Apparatus for Data Object Profiling&#x201d;.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00023">
<othercit>U.S. Appl. No. 11/517,085, filed Sep. 7, 2006.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00024">
<othercit>U.S. Appl. No. 11/516,980, filed Sep. 7, 2006.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00025">
<othercit>U.S. Appl. No. 11/589,492, filed Oct. 30, 2006.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00026">
<othercit>U.S. Appl. No. 11/590,288, filed Oct. 31, 2006.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00027">
<othercit>U.S. Appl. No. 11/557,874, filed Nov. 8, 2006.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00028">
<othercit>U.S. Appl. No. 10/881,032, filed Jun. 30, 2004, Gregory F. Grohoski et al.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00029">
<othercit>U.S. Appl. No. 10/880,485, filed Jun. 30, 2004, Nicolai Kosche et al.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00030">
<othercit>U.S. Appl. No. 10/840,180, filed May 6, 2004, Nicolai Kosche et al.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00031">
<othercit>U.S. Appl. No. 10/840,164, filed May 6, 2004, Nicolai Kosche et al.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00032">
<othercit>U.S. Appl. No. 10/840,167, filed May 6, 2004, Nicolai Kosche et al.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00033">
<othercit>U.S. Appl. No. 11/517,085, filed Sep. 7, 2006, Nicolai Kosche et al.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00034">
<othercit>U.S. Appl. No. 11/516,980, filed Sep. 7, 2006, Nicolai Kosche et al.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00035">
<othercit>U.S. Appl. No. 11/589,492, filed Oct. 30, 2006, Nicolai Kosche et al.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00036">
<othercit>U.S. Appl. No. 11/590,288, filed Oct. 31, 2006, Nicolai Kosche et al.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00037">
<othercit>U.S. Appl. No. 111557,874, filed Nov. 8, 2006, Nicolai Kosche.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>20</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>719313</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>44</number-of-drawing-sheets>
<number-of-figures>51</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20080114806</doc-number>
<kind>A1</kind>
<date>20080515</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Kosche</last-name>
<first-name>Nicolai</first-name>
<address>
<city>San Francisco</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Kosche</last-name>
<first-name>Nicolai</first-name>
<address>
<city>San Francisco</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<last-name>Kowert</last-name>
<first-name>Robert C.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<orgname>Meyertons, Hood, Kivlin, Kowert &#x26; Goetzel, P.C.</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Oracle America, Inc.</orgname>
<role>02</role>
<address>
<city>Redwood City</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Ho</last-name>
<first-name>Andy</first-name>
<department>2194</department>
</primary-examiner>
<assistant-examiner>
<last-name>Mudrick</last-name>
<first-name>Timothy A</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A system and method for profiling a network application may provide for operating on context-specific data and costs. The system may include an apparatus for associating local extended address elements with a message sent from a first computing system to a second computing system across a network. The second computing system may store the received information as remote extended address information and may store its own local extended address information. An event agent may capture values of local and/or remote extended address elements in response to detecting the message or another system event and may associate the extended address elements with the message or system event in an event set accessible by a data space profiler. The extended address information may include time stamps. An event agent may determine network latency dependent on time stamps of messages and may generate an event if the latency exceeds a predetermined threshold.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="188.72mm" wi="97.96mm" file="US08627335-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="239.78mm" wi="168.91mm" file="US08627335-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="169.16mm" wi="131.49mm" file="US08627335-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="200.32mm" wi="149.86mm" file="US08627335-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="245.45mm" wi="143.34mm" file="US08627335-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="246.97mm" wi="178.82mm" file="US08627335-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="142.41mm" wi="162.64mm" file="US08627335-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="187.45mm" wi="178.82mm" file="US08627335-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="245.96mm" wi="180.09mm" file="US08627335-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="218.02mm" wi="83.82mm" file="US08627335-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="237.15mm" wi="186.27mm" file="US08627335-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="170.60mm" wi="139.02mm" file="US08627335-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="234.27mm" wi="159.94mm" file="US08627335-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="111.84mm" wi="167.22mm" file="US08627335-20140107-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="135.47mm" wi="169.76mm" file="US08627335-20140107-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="170.43mm" wi="172.55mm" file="US08627335-20140107-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00016" num="00016">
<img id="EMI-D00016" he="251.63mm" wi="184.74mm" file="US08627335-20140107-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00017" num="00017">
<img id="EMI-D00017" he="80.09mm" wi="111.17mm" file="US08627335-20140107-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00018" num="00018">
<img id="EMI-D00018" he="189.99mm" wi="141.99mm" file="US08627335-20140107-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00019" num="00019">
<img id="EMI-D00019" he="236.39mm" wi="113.62mm" file="US08627335-20140107-D00019.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00020" num="00020">
<img id="EMI-D00020" he="227.67mm" wi="143.76mm" file="US08627335-20140107-D00020.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00021" num="00021">
<img id="EMI-D00021" he="238.17mm" wi="127.08mm" file="US08627335-20140107-D00021.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00022" num="00022">
<img id="EMI-D00022" he="221.74mm" wi="178.39mm" file="US08627335-20140107-D00022.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00023" num="00023">
<img id="EMI-D00023" he="209.80mm" wi="180.34mm" orientation="landscape" file="US08627335-20140107-D00023.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00024" num="00024">
<img id="EMI-D00024" he="206.25mm" wi="172.64mm" file="US08627335-20140107-D00024.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00025" num="00025">
<img id="EMI-D00025" he="223.86mm" wi="140.29mm" orientation="landscape" file="US08627335-20140107-D00025.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00026" num="00026">
<img id="EMI-D00026" he="231.48mm" wi="131.32mm" orientation="landscape" file="US08627335-20140107-D00026.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00027" num="00027">
<img id="EMI-D00027" he="234.19mm" wi="175.60mm" orientation="landscape" file="US08627335-20140107-D00027.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00028" num="00028">
<img id="EMI-D00028" he="224.54mm" wi="134.20mm" orientation="landscape" file="US08627335-20140107-D00028.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00029" num="00029">
<img id="EMI-D00029" he="240.54mm" wi="185.17mm" orientation="landscape" file="US08627335-20140107-D00029.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00030" num="00030">
<img id="EMI-D00030" he="210.31mm" wi="188.13mm" file="US08627335-20140107-D00030.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00031" num="00031">
<img id="EMI-D00031" he="208.70mm" wi="181.36mm" file="US08627335-20140107-D00031.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00032" num="00032">
<img id="EMI-D00032" he="148.17mm" wi="185.42mm" file="US08627335-20140107-D00032.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00033" num="00033">
<img id="EMI-D00033" he="235.46mm" wi="175.68mm" orientation="landscape" file="US08627335-20140107-D00033.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00034" num="00034">
<img id="EMI-D00034" he="235.71mm" wi="168.23mm" orientation="landscape" file="US08627335-20140107-D00034.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00035" num="00035">
<img id="EMI-D00035" he="182.12mm" wi="172.72mm" orientation="landscape" file="US08627335-20140107-D00035.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00036" num="00036">
<img id="EMI-D00036" he="244.09mm" wi="163.91mm" orientation="landscape" file="US08627335-20140107-D00036.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00037" num="00037">
<img id="EMI-D00037" he="142.92mm" wi="169.16mm" file="US08627335-20140107-D00037.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00038" num="00038">
<img id="EMI-D00038" he="130.39mm" wi="176.28mm" file="US08627335-20140107-D00038.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00039" num="00039">
<img id="EMI-D00039" he="169.42mm" wi="92.63mm" file="US08627335-20140107-D00039.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00040" num="00040">
<img id="EMI-D00040" he="199.64mm" wi="97.45mm" file="US08627335-20140107-D00040.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00041" num="00041">
<img id="EMI-D00041" he="243.59mm" wi="166.29mm" file="US08627335-20140107-D00041.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00042" num="00042">
<img id="EMI-D00042" he="213.78mm" wi="185.59mm" file="US08627335-20140107-D00042.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00043" num="00043">
<img id="EMI-D00043" he="223.86mm" wi="176.02mm" file="US08627335-20140107-D00043.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00044" num="00044">
<img id="EMI-D00044" he="240.37mm" wi="166.96mm" file="US08627335-20140107-D00044.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0002" num="0001">1. Field of the Invention</p>
<p id="p-0003" num="0002">This invention relates to computing systems and more specifically to observing and optimizing costs of various system events through data space profiling.</p>
<p id="p-0004" num="0003">2. Description of the Relevant Art</p>
<p id="p-0005" num="0004">Computer systems originally contained a central processing unit encompassing many boards (and sometimes cabinets), and random access memory that responded in the same cycle time as the central processing unit. This central processing unit (CPU) was very costly. Initially, bulbs attached to wires within the CPU aided programmers in the identification of program behavior. These were among the earliest system profiling tools.</p>
<p id="p-0006" num="0005">Computer languages, such as FORTRAN and COBOL, improved programmer productivity. Profiling libraries were developed to break down the costs associated with the most precious resource on the system, i.e., CPU cycles. Profiling associated processor costs with processor instructions and the source representation of those instructions (e.g., functions and line numbers.) Programmer productivity climbed, as critical CPU bottlenecks were uncovered and resolved in program source code.</p>
<p id="p-0007" num="0006">As computers evolved, the CPU shrank down to a single board, and then to a single chip, i.e., the microprocessor. Large numbers of cheap commodity microprocessors were grouped together to solve large problems that could previously only be handled using mainframes. By the mid-1990s, the acquisition costs of microprocessors comprised a small fraction of the overall cost of many computer systems. The bulk of the system cost was the memory subsystem and the peripherals.</p>
<p id="p-0008" num="0007">Profiling code aids developers in identifying sections of code that consume excessive amounts of execution time. Profiling provides data to developers to aid in optimizing code. In general, two major classes of profiling techniques exist: code instrumentation and hardware assisted profiling. Code instrumentation techniques typically include the insertion of instructions into the instruction stream of a program to be profiled. In crude form, programmer insertion of printf source statements may be employed to profile code. More sophisticated approaches may employ compiler facilities or options to insert appropriate instructions or operations to support profiling. Upon execution of the instrumented code, execution characteristics are sampled, in part by operation of the added instructions. Typically, code instrumentation techniques impose overhead on original program code so instrumented and, unfortunately, the insertion of instructions into the instruction stream may itself alter the behavior of the program code being profiled.</p>
<p id="p-0009" num="0008">Hardware assisted profiling techniques have been developed, in part, to address such limitations by off-loading some aspects to dedicated hardware such as event counters. Practical implementations often employ aspects of both code instrumentation and hardware assistance. In some cases, profiling support is included in, or patched into, exception handler code to avoid imposing overhead on each execution of a sampled instruction. Suitable hardware event counters are provided in advanced processor implementations such as those in accordance with the SPARC&#xae; and Alpha processor architectures. SPARC architecture based processors are available from Sun Microsystems, Inc, Santa Clara, Calif. SPARC trademarks are used under license and are trademarks of SPARC International, Inc. in the United States and other countries. Products bearing SPARC trademarks are based on an architecture developed by Sun Microsystems. Systems that include Alpha processors are available from a number of sources including Compaq Computer Corporation.</p>
<p id="p-0010" num="0009">One reasonably comprehensive hardware assisted profiling environment is provided by the Digital Continuous Profiling Infrastructure (DCPI) tools that run on Alpha processor systems to provide profile information at several levels of granularity, from whole images down to individual procedures and basic blocks on down to detailed information about individual instructions, including information about dynamic behavior such as cache misses, branch mispredictions, and other forms of dynamic stalls. Detailed information on the DCPI tools and downloadable code may be found (as of the filing date) at http://h30097.www3.hp.com/dcpi/.</p>
<p id="p-0011" num="0010">Throughput performance is often achieved by improving concurrent program execution, reducing contention, and lowering the cost of coherency. However, in the majority of cases, data movement constrains achievable gain. In these situations, processors spend more time waiting for data movement than executing instructions. Computer architects, recognizing this dependency, introduced multi-threaded cores to hide data latency: while one thread is blocked fetching data, another can execute. These chip-multithreaded (CMT) processors may include many cores (CPUs) driving many virtual processor strands or threads of instruction execution. The performance-critical component in these systems is often the memory subsystem and not the strands of execution. The scalability of threads relies on the accurate identification and characterization of data motion. Despite evidence that data motion is a key determinant in throughput, an instruction-centric profiling paradigm persists.</p>
<p id="p-0012" num="0011">As computer architectures have evolved from single to multi-core, multi-threaded processor systems, the performance paradigm has shifted from data transformation to data movement. Software scalability depends on bottleneck analysis, prediction and avoidance. Traditional performance characterization focuses on the instruction pipeline and fails to address the crux of scalability, i.e., the majority of time is usually spent in data motion.</p>
<p id="p-0013" num="0012">The generally available performance tools provide the developer with instruction execution analysis, typically generated from instrumented applications. However, these tools tend to perturb the application's behavior and, more importantly, may fail to capture the dynamic nature of the program under test. In addition, these tools are directed to look only at instruction execution, monitoring the CPU, when the bottleneck is often in the memory subsystem. Therefore, traditional profiling tools fail to detect bottlenecks related to the memory systems of these modern systems, and do not addresses application scalability development for large-thread-count systems. Traditional profiling tools also fail to provide a mechanism to operate on context specific data and costs, including data related to the hardware and software execution context of an application to be profiled.</p>
<heading id="h-0002" level="1">SUMMARY</heading>
<p id="p-0014" num="0013">A system and method for data space profiling of a software application may include means for operating on context-specific data and costs. In some embodiments, the context-specific data may represent a hardware context for a network application. In such embodiments, context-specific profile data collected for analysis of the application may include a time stamp for a network message, a frame number, a port identifier, a network protocol name or type, or a network address.</p>
<p id="p-0015" num="0014">The system may include a tagging apparatus, a synchronization apparatus, and an event agent, in some embodiments. The tagging apparatus may be configured to tag a message sent from one computing system to another (e.g., as part of a network application) to include context-specific information. This information may be considered local extended address information in the context of the computing system sending the message. When the message is received by a second computing system, the extended address information received with the message may be considered remote extended address information in the context of the second computing system. In response to receiving the message or in response to detecting a system event, the second computing system may tag the message with additional local extended address information (i.e., local in the context of the second computing system) or may associate both the remote extended address information and additional local extended address information with the detected system event.</p>
<p id="p-0016" num="0015">The synchronization apparatus may be used, for example, to synchronize a time base on one computing system with a time base on another computing system. When two computing systems have been synchronized, a time stamp included in a message sent from the first computing system may be compared to a time stamp associated with receiving the message on the second computing system to determine a value for network latency. In some embodiments, an event agent may be configured to compare the determined network latency value with a predetermined threshold and to generate a system event if the determined network latency or an accumulated network latency meets or exceeds the predetermined threshold.</p>
<p id="p-0017" num="0016">An event agent may in some embodiments be configured to detect or generate other types of system events, in different embodiments. For example, an event agent may be configured to sample transactions between computing systems in order to profile the behavior of the underlying application(s). In another example, an event agent may be configured to detect a system event on one of the computing systems and to associate contextual information from one or both of the computing systems with the system event. In yet another example, an event agent may be configured to monitor the remote and/or local extended address information and to generate a system event in response to detecting a particular value or pattern of values in the information.</p>
<p id="p-0018" num="0017">Profiling data movement between two computing systems using these methods may involve profiling data movement between any two hardware and/or software systems that communicate with each other over a network, according to different embodiments. For example, messages sent and received by the computing systems may in some embodiments comprise software transactions of a network application executing on one or both of the computing systems according to a client/server or peer-to-peer configuration. In such embodiments, the methods may include capturing local and/or remote extended address information when a transaction begins and clearing it when the transaction ends.</p>
<p id="p-0019" num="0018">In some embodiments, local and/or remote extended address information associated with a message or other system event may be stored in an event set for analysis by a data space profiler. In such embodiments, the profiler may be configured to identify a performance bottleneck of a network application and/or its cause dependent at least in part on the local and/or remote extended address information.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 1</figref> illustrates a method for performing data space profiling, according to one embodiment.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIGS. 2A and 2B</figref> are block diagrams illustrating annotation of code to associate instruction instances with language constructs of source-level data objects, according to various embodiments.</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 3</figref> is a flow chart illustrating a method for attributing sampled runtime events to source-level data object language constructs, according to one embodiment.</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 4</figref> is a flow chart illustrating a method for attributing sampled runtime events to source-level data addresses, according to one embodiment.</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 5</figref> is a flow chart illustrating a method for determining an instruction instance that corresponds to a detected runtime event, according to various embodiments.</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 6</figref> is a conceptual diagram illustrating data addresses being attributed to sampled runtime events, according to one embodiment.</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 7</figref> is a conceptual diagram illustrating recording of profile data, according to one embodiment.</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIGS. 8A and 8B</figref> are conceptual diagrams of exemplary profile data structures, according to different embodiments.</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 9</figref> is a block diagram illustrating an exemplary sampled runtime event data structure, according to one embodiment.</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 10</figref> is a conceptual diagram illustrating correlation of multiple code behavior attributes according to realizations of the invention.</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 11</figref> is a flow chart illustrating a method for analyzing source-level data object profile data from the perspective of multiple code behavior attributes, according to one embodiment.</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 12</figref> is a block diagram illustrating various hardware components of an exemplary computer system, each of which may be identified by one or more extended address elements, according to one embodiment.</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 13</figref> is a block diagram illustrating various software components of an exemplary software program, each of which may be identified by one or more extended address elements, according to one embodiment.</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 14</figref> illustrates an exemplary computing system modeled as a Random Access Machine, according to one embodiment.</p>
<p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. 15</figref> is a conceptual diagram illustrating extracting profile data from an event space using multiple indices, according to one embodiment.</p>
<p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. 16</figref> is a flow chart illustrating a method for analyzing an event space by applying a relational agent to the events in the event space, according to one embodiment.</p>
<p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. 17</figref> is a table illustrating exemplary profile data revealing execution hindrances in terms of consumed execution time in relation to addresses, according to one embodiment.</p>
<p id="p-0037" num="0036"><figref idref="DRAWINGS">FIGS. 18A and 18B</figref> are tables illustrating exemplary profile data revealing execution hindrances in relation to source-level data object language constructs, according to various embodiments.</p>
<p id="p-0038" num="0037"><figref idref="DRAWINGS">FIGS. 19A-19F</figref> are tables illustrating exemplary filtered profile data, according to various embodiments.</p>
<p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. 20</figref> is a flow chart illustrating a method for preparing for data space profiling analysis, including building an event space, according to one embodiment.</p>
<p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. 21</figref> is a flow chart illustrating an exemplary method of identifying an asymmetric resource utilization and its cause, according to one embodiment.</p>
<p id="p-0041" num="0040"><figref idref="DRAWINGS">FIGS. 22A-22P</figref> illustrate simulated screen shots of a graphical user interface of a data profiler, according to one embodiment.</p>
<p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. 23</figref> is a flow chart illustrating a method of profiling using user-specified data associated with an event, according to one embodiment.</p>
<p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. 24</figref> is a flow chart illustrating a method of profiling an application across a network, according to one embodiment.</p>
<p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. 25</figref> is a flow chart illustrating a method of profiling an application across a network, according to a second embodiment.</p>
<p id="p-0045" num="0044"><figref idref="DRAWINGS">FIG. 26</figref> is a block diagram of an exemplary computer system suitable for implementation of a data profiler, according to one embodiment.</p>
<p id="p-0046" num="0045"><figref idref="DRAWINGS">FIG. 27</figref> is a data flow diagram illustrating data flow for an exemplary profiling experiment, according to one embodiment.</p>
<p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. 28</figref> is a data flow diagram illustrating data flow for an exemplary profiling experiment involving data movement between two computing systems, according to one embodiment.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<p id="p-0048" num="0047">While the invention is described herein by way of example for several embodiments and illustrative drawings, those skilled in the art will recognize that the invention is not limited to the embodiments or drawings described. It should be understood, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims. The headings used herein are for organizational purposes only and are not meant to be used to limit the scope of the description or the claims. As used throughout this application, the word &#x201c;may&#x201d; is used in a permissive sense (i.e., meaning having the potential to), rather than the mandatory sense (i.e., meaning must). Similarly, the words &#x201c;include&#x201d;, &#x201c;including&#x201d;, and &#x201c;includes&#x201d; mean including, but not limited to.</p>
<heading id="h-0004" level="1">DETAILED DESCRIPTION OF EMBODIMENTS</heading>
<p id="p-0049" num="0048">Modem computer systems are using increasing numbers of ever-faster processors to solve larger and larger problems. However, performance of those processors may be limited by the need to supply data to them at ever increasing rates. In some systems, a hierarchy of caches between the processors and main memory may be used to improve performance. In these systems, the processors may run at full speed when using data from the caches closest to the processors, but may be frequently stalled loading data from or storing data to the primary caches through secondary or tertiary caches and, ultimately, to or from main memory. Understanding how an application's data is structured in memory and how it passes from memory through the cache hierarchy may facilitate understanding and improving the performance of applications on these systems.</p>
<p id="p-0050" num="0049">The data space profiler described herein may provide per-instruction details of memory accesses in the annotated disassembly, and may provide data aggregated and sorted by object structure types and elements, in some embodiments. This may in some embodiments provide a new observability perspective for application developers. For example, the underlying framework of the profiler may provide a system and method for providing cache miss data to compilers and dynamic code generators, thus allowing cache-related application optimizations. The system and method may be applied to profiling data related to other types of runtime events, or execution hindrances, in some embodiments.</p>
<p id="p-0051" num="0050">While conventional profiling tools provide per image, per procedure, per source line, or per instruction level profile information, these tools do not provide profile information in relation to other aspects of code behavior. In particular, conventional profiling tools do not perform data space profiling. For example, while the majority of stall time may be caused by memory related operations or load type instruction instances, conventional tools do not provide information about these memory related operations from the perspective of data profiling objects, addresses (identifiers) of data profiling objects, or data profiling object definitions. Hence, conventional profiling tools do not provide information about data profiling objects that consume the most execution time. In addition, conventional tools do not correlate multiple code behavior attributes to consumed execution time. A system and method of data space profiling, as described herein, may allow the application developer (user) to optimize application code, data structures, memory hierarchy, and/or other hardware and software components by helping him or her understand the relationships between and contributions of these elements to the performance of the application.</p>
<p id="p-0052" num="0051">In the following description, references are made to source-level data objects, data objects, data profiling objects, profiling objects, extended addresses, extended address elements, address elements, runtime events, sampled runtime events, instruction instances, and language constructs. The terms &#x201c;source-level data object&#x201d; and &#x201c;data object&#x201d; may be used to describe any of various representations of data identifiable in source code, including variable names, data types, data structures, elements of data structures, data type definitions, operands, statically linked objects, expressions, etc. The terms &#x201c;data profiling object&#x201d; and &#x201c;profiling object&#x201d; may be used to describe any hardware component, software construct, data allocation construct (e.g., virtual to physical memory mappings done at runtime), or user-defined abstract component from whose perspective costs may be viewed. The term &#x201c;extended address&#x201d; may refer to a vector containing a plurality of &#x201c;extended address elements&#x201d; or &#x201c;address elements&#x201d;, each of which represents an identifier associated with a runtime event from the perspective of a particular data profiling object. The term &#x201c;runtime event&#x201d; may be used to describe an event that occurs during execution of code (e.g., during execution of a software application being profiled). For example, runtime events may represent data references, cache misses, cache references, data translation buffer misses, data translation buffer references, branch mispredictions, etc. Runtime events may be of particular interest because they may hinder execution of an application. For example, runtime events may consume execution time, or may be associated with consumption of execution time; hence, execution hindrance may be revealed in terms of execution time. &#x201c;Sampled runtime events&#x201d; may comprise a subset of all runtime events and may in some embodiments statistically represent all runtime events for a given execution run of a software application. The term &#x201c;code behavior attribute&#x201d; may refer to a cost metric, an extended address element or any other attribute associated with a runtime event. For example, a time (e.g., a timestamp value), a program counter (PC) value, execution time, number of cycles, virtual address, or process identifier (PID) may all be considered code behavior attributes, in some embodiments. They may also be considered extended address elements, in various embodiments. These attributes (or their values) may be used by the profiler in filtering and sorting profile data and in defining custom profiling objects and/or cost metrics, in some embodiments. The term &#x201c;instruction instance&#x201d; may be used to describe an instance of an instruction or machine operation, such as a macro instruction or a micro instruction, which corresponds to a construct in a source-level representation of program code. For example, an instruction instance may be an instance of a load type instruction. Finally, the term &#x201c;language construct&#x201d; may be used to describe a syntactically allowable portion of code formed from one or more lexical tokens in accordance with the rules of a source-level programming language.</p>
<p id="p-0053" num="0052">In some embodiments, instruction sequences and computer program products may be made using techniques in accordance with the present invention. For purposes of description, certain aspects of the present invention are detailed in the context of data profiling that includes associating sampled cache miss runtime events with different code behavior attributes, such as values of physical addresses, source-level data objects, or other data profiling objects and that includes presenting profile data that has been filtered based on addresses and source-level data objects. More generally, data space profiling may in some embodiments include associating any runtime event with one or more extended address elements and/or source-level data objects and presenting profile data filtered with one or more other code behavior attributes (e.g., source-level data object definitions, source-level data object addresses, stall time, cycle time, function/methods, instruction instances, etc.).</p>
<p id="h-0005" num="0000">Overview</p>
<p id="p-0054" num="0053">Providing source-level data object profile information along with other data profiling object information may in some embodiments allow targeted and more efficient optimization of application code. The combined profile information may enhance understanding of code behavior generally and with regard to specific hardware and/or software platforms. Correlating traditionally collected code behavior attributes and data profiling object profile data may further enhance understanding of code behavior.</p>
<p id="p-0055" num="0054">Profiling may in some embodiments involve translating code, executing the translated code and collecting statistical profile data about the code during execution, analyzing the collected profile data, and providing the analyzed profile data. In some embodiments, the profile data collected and analyzed following a runtime event may include execution costs associated with data movement in addition to, or instead of, traditionally collected profile data. In some embodiments, the profile data may be indexed according to multiple extended address elements associated with the event.</p>
<p id="p-0056" num="0055">Tagging code during code translation may provide the basis for identifying relationships between code execution time and language constructs representing source-level data objects of the code, in some embodiments. During data collection, sampled runtime events that consume execution time may be attributed to source-level data objects based on the tagging, in these embodiments. Profile data may then be presented that facilitates identification of execution hindrances based on one or more source-level data objects.</p>
<p id="p-0057" num="0056">During data collection, profile data, including correlations between extended address elements and sampled runtime events, may be collected. In some embodiments, while collecting this data, a determination may be made as to the validity of the addresses. If an address is determined to be valid, then the corresponding runtime event may be attributed to the valid address. Otherwise, an indication that the address is invalid may be made. The profile data, including any correlations between data addresses and execution hindrance, may be provided, and may facilitate optimization of the code, in some embodiments. In some embodiments, these correlations may be based on the association between data addresses and sampled runtime events.</p>
<p id="p-0058" num="0057">Furthermore, correlations between multiple code behavior attributes may be presented, in some embodiments. For example, data illustrating correlations between traditionally collected code behavior attributes (e.g., execution time) and the additional code behavior attributes associated with data profiling (e.g., virtual or physical addresses) may be presented. Profile data revealing execution hindrances may be aggregated based on source-level data objects, profiling object profile data and other code behavior attributes, in different embodiments. In some embodiments, profile data may be aggregated based on a first code behavior attribute, and then filtered based on an instance of the first code behavior attribute. The aggregated and filtered profile data may then be aggregated and filtered based on one or more additional code behavior attributes. In some embodiments, this capability to aggregate and filter profile data based on multiple code behavior attributes may allow code optimization decisions to be made based on presentation of profile data from various perspectives and on correlations between various code behavior attributes, including source-level data objects, their addresses, their definitions, instructions, functions/methods, etc.</p>
<p id="p-0059" num="0058">An exemplary method for performing data space profiling, as described above, is illustrated by the flow chart in <figref idref="DRAWINGS">FIG. 1</figref>. In this example, a developer (user) may first identify target objects to profile for a given application, as shown in <b>110</b>. These objects may include hardware components and/or programming (software) structures, in different embodiments. The user may create a control file specifying associations between hardware components and identifiers thereof, relational agents (functions) defining user-specified data objects, presentation (display) options, etc., in some embodiments. In some embodiments the user may translate the source code of the application to be profiled, such as by annotating the code to add tags or index structures. The source code may be a function or procedure, a library file, a data object class, a segment of code from an application, code for an entire application, etc., and may be written in any source-level language including, but not limited to, C, C++, Java, Lisp, Basic, Perl, COBOL, Fortran, etc. In some embodiments, software event agents may be inserted into the source code to assist in collecting profile data.</p>
<p id="p-0060" num="0059">In addition to the user-specified relational agents, standard or platform/application-specific relational agents may be generated for use in profiling an application, in some embodiments. In some embodiments, these relational agents may be generated by operating system software, such as by the compiler system or by a stand-alone component of the operating system configured for this purpose. These relational agents may be configured to associate various address elements with instructions, instances and data types, in some embodiments. For example, relational agents may associate procedures, line numbers, load objects, etc., with instructions. In another example, relational agents may associate scalars or complex data definitions with data types. In yet another example, relational agents may associate variable names and/or locations with instances of instructions. In some embodiments, standard or platform-specific relational agents may be generated by the operating system in parallel with the compilation of the application to be profiled, and may be dependent on the application itself and/or an associated control file. In other embodiments, variables may be registered for tracking, and one or more event agents may capture their values during profiling.</p>
<p id="p-0061" num="0060">The operating system may also include various software event agents, in some embodiments, and/or may be configured to receive profile information from hardware event agents and to store or communicate this data for use during an analysis phase.</p>
<p id="p-0062" num="0061">After the code and control files have been prepared, the application may be compiled and linked with all applicable files, functions, tasks, etc., needed to support profiling, as shown in <b>115</b>. Execution of the application, as shown in <b>120</b>, may in some embodiments include the steps of booting the collection framework, and then transferring control to the application program itself. Booting the collection framework may include initializing hardware event agents, interposing any address space modifications (e.g., changes to the address space made by the operating system) and allocating repositories for profile data collected during execution, according to various embodiments. For example, in one embodiment, each thread of a multi-threaded process may be allocated a separate repository for storing profile data, and each thread may be allocated a different portion of the available address space. Thus, the separate repositories may be thought of as per-thread or per-address-space repositories, in such embodiments.</p>
<p id="p-0063" num="0062">Once control is transferred to the application, event agents may begin collecting profiling information, as in <b>125</b>. In some embodiments, when certain hardware events occur, one or more software event agents may be executed in order to collect more profile data than any hardware agents collecting data for that event. Event agents may associate collected profiling data with various object identifiers, as will be discussed in more detail later. This is illustrated at <b>130</b>. The collected and associated profiling data may be stored in per-thread repositories, as described above, or in any suitable data structure, such as files, registers, tables, linked lists, databases, etc., for later use by the analyzer.</p>
<p id="p-0064" num="0063">At <b>135</b>, execution of the application may end, in some embodiments, before analysis begins. In other embodiments, the application may continue to run and collect more profiling data, or the application may continue to run, but with data collection disabled during analysis. The initial results may be examined at this point, in some embodiments.</p>
<p id="p-0065" num="0064">At <b>140</b>, it is determined if the performance of the application is satisfactory, in this example. In some embodiments, if the performance is satisfactory, profiling may be complete, as in <b>145</b>. If not, analysis of the profiling data may be initiated in order to identify and correct performance bottlenecks. In some embodiments, analysis may be performed even if the initial performance results were acceptable, such as in order to further optimize an acceptable application.</p>
<p id="p-0066" num="0065">To being the analysis phase, relational agents may be applied to the profile data collected by event agents and may be used to build the event space, as in <b>150</b>. The event space may in some embodiments include multi-dimensional correlations between costs (such as execution time), programming language constructs (such as functions) and hardware components (such as cache lines.) Relational agents may build the event space by recursively operating on each element of the profile data collected by event agents, in some embodiments. This will be described in more detail later.</p>
<p id="p-0067" num="0066">The analysis engine may in some embodiments be used to probe the event space in order to identify performance bottlenecks, such as those related to data motion in the system. This is illustrated at <b>155</b>. This analysis may include displaying costs associated with various hardware and software components of the system and the application being profiled, in some embodiments. The analysis may also include filtering the profile data for a given data object and aggregating the data with respect to additional data objects and/or filter criteria, in some embodiments. The analyzer may display the aggregated and filtered profile data by writing to a profiling report file, for example, or may include a graphical user interface that allows the developer to select data objects to display, zooming and position options, binning (aggregation) functions, filter clauses, etc. The analysis engine and an exemplary graphical user interface for the analyzer will be described in more detail later. As noted at <b>155</b>, the use of the analysis engine and graphical user interface thereof may allow a user to identify data motion bottlenecks from the event space data, such as those caused by resource sharing or conflicts between resources, in some embodiments. These tools may also allow the user to identify the root cause of the bottleneck, by allowing the user to display the extended address associated with a runtime event, and to trace the data motion back to source code. For example, the analyzer may allow a user to determine that a particular variable is being inefficiently shared between two threads.</p>
<p id="p-0068" num="0067">Once any bottlenecks and their underlying causes have been identified, the application may be optimized to correct a conflict, reduce sharing, or make whatever changes may be needed to avoid the identified bottleneck. In some embodiments, this may be done by the developer, while in other embodiments, the results of the data profiling analysis may serve as an input to an optimizing compiler or code generator, which may take advantage of this information to produce optimized code.</p>
<p id="h-0006" num="0000">Translating Code</p>
<p id="p-0069" num="0068">When translating application code for profiling, annotations may be made to source code for use during data collection. In some embodiments, these annotations may be used to connect source-level language constructs that represent source-level data objects to runtime events. In other embodiments, these annotations may be used to capture user-specified data to be associated with runtime events. In one example, language constructs, such as labels or define statements, may be added to source code and these constructs may be associated with runtime events. In another example, registering one or more variables (e.g., by annotating code using a descriptor apparatus) may allow the values of these variables to be associated with runtime events.</p>
<p id="p-0070" num="0069">In yet another example, code may be annotated to insert an instruction index construct into the code, in one embodiment, and the index may be mapped to a source-level language construct and/or an extended address element. This is illustrated in <figref idref="DRAWINGS">FIGS. 2A and 2B</figref>. These diagrams illustrate annotation of code to associate instruction instances with language constructs of data objects, according to various embodiments. <figref idref="DRAWINGS">FIG. 2A</figref> is a block diagram of annotated code, according to one embodiment. <figref idref="DRAWINGS">FIG. 2B</figref> is a block diagram of a language construct index table, according to one embodiment.</p>
<p id="p-0071" num="0070">Although <figref idref="DRAWINGS">FIGS. 2A and 2B</figref> illustrate one level of indirection for code annotation (i.e., one table lookup to determine a data language construct that corresponds to an annotation), in other embodiments there may be more than one level of indirection, or no indirection.</p>
<p id="p-0072" num="0071">The annotated code shown in <figref idref="DRAWINGS">FIG. 2A</figref> includes code lines <b>201</b>, <b>203</b>, and <b>205</b>. In this example, each code line includes a program counter, an instruction instance, and a construct index, as indicated in code line <b>201</b>. For example, code line <b>203</b> includes an instruction instance LDA [R<b>3</b>], R<b>5</b> at program counter 0x0024. Code line <b>203</b> has been tagged with the construct index &#x201c;0&#x201d;. Code line <b>205</b> includes an instruction instance LDA [R<b>4</b>+5], R<b>8</b> at program counter 0x0040, and has been tagged with the construct index &#x201c;2&#x201d;. In other embodiments, code lines may be tagged differently and/or may include different elements. For example, code annotations may be added in a separate section of the code, may be inserted inline with the code, or may be in a separate file, according to different embodiments.</p>
<p id="p-0073" num="0072">The exemplary language construct index table <b>231</b> of <figref idref="DRAWINGS">FIG. 2B</figref> illustrates example entries corresponding to the tags (i.e., construct indices) shown in the annotated code <b>209</b> of <figref idref="DRAWINGS">FIG. 2A</figref>. The language construct index table <b>231</b> includes construct index entries <b>0</b>-<b>2</b>. Construct index <b>0</b> corresponds to the source-level data object STRUCT TREE, which is a structure TREE. Construct index <b>1</b> corresponds to the source-level data object INT TREE.LEAFS, which is an integer data type that is an element of the structure TREE. The construct index <b>2</b> corresponds to the source-level data object STRUCT TREE.NODE, which is a structure NODE that is an element of TREE. Annotations and language construct index tables, such as those illustrated in <figref idref="DRAWINGS">FIGS. 2A and 2B</figref>, may in some embodiments be used during data collection to associate a sampled runtime event with a source-level data object language construct. The language construct index table <b>231</b> also indicates exemplary addresses of the source-level data objects.</p>
<p id="p-0074" num="0073">Annotated code, such as annotated code <b>209</b>, may in some embodiments be byte code specific to a platform, or may be generic across multiple platforms. Source-level data object language constructs may be indexed according to a variety of techniques in different embodiments. Source-level data objects may be indexed with respect to different source-level data objects in a sequential or hierarchical manner, according to different embodiments. In addition, other types of data objects (e.g., physical addresses, data object types) may be indexed, in some embodiments.</p>
<p id="p-0075" num="0074">Annotations or tagging done during translation and/or generation of code may in some embodiments provide the basis for associating sampled runtime events with source-level data object language constructs during data collection and later analysis. As previously noted, this information may facilitate a targeted and efficient optimization of code with respect to data objects.</p>
<p id="h-0007" num="0000">Collecting Profile Data</p>
<p id="p-0076" num="0075">During code execution, profile data may be collected and recorded by various software and/or hardware event agents, examples of which will be described in more detail later. In some embodiments, profiling may be based on the collection of statistical data during execution of code. In some embodiments, statistical data may not be collected for every runtime event because the overhead may significantly impact performance of the code. Therefore, in some embodiments, runtime events may be sampled. In some embodiments, in order to provide more detailed information about code behavior, additional information may be collected about runtime events than is collected using a traditional profiling tool. For example, in some embodiments, information may be collected that facilitates associating runtime events with source-level data object language constructs or other extended address elements associated with the events. One such embodiment is illustrated in <figref idref="DRAWINGS">FIG. 3</figref>.</p>
<p id="p-0077" num="0076">In the example embodiment illustrated in <figref idref="DRAWINGS">FIG. 3</figref>, runtime events may be attributed to source-level data object language constructs. In this example, at block <b>301</b>, execution of code begins. At block <b>303</b>, it is determined if a runtime event is detected. If a runtime event is not detected, then control flows to block <b>307</b>. If a runtime event is detected, then control flows to block <b>305</b>. In some embodiments, additional actions may be performed in response to detecting a runtime event (e.g., incrementing hardware counters associated with the detected events, generating a runtime event mask, etc.).</p>
<p id="p-0078" num="0077">At block <b>305</b>, it is determined if the runtime event is to be sampled. In some embodiments, a trap or interrupt may be generated when a runtime event to be sampled occurs. The trap or interrupt may include, reference, or be accompanied by a statistical packet(s) that provides information describing the sampled runtime event (e.g., processor identifier, type of runtime event, process identifier, cycle time, time stamp, thread identifier, type of cache miss, etc.). In some embodiments, runtime events may be sampled when a hardware counter reaches a certain threshold, while in other embodiments, runtime events may be sampled according to a configuration file or logic. In some embodiments, all runtime events may be profiled, while in others, only particular runtime events may be profiled. If the runtime event is to be sampled, then control flows to block <b>309</b>.</p>
<p id="p-0079" num="0078">At block <b>309</b>, the instruction instance that corresponds to the sampled runtime event is determined. Various techniques may be employed to determine the corresponding instruction instance in different embodiments. For example, in some embodiments, a technique is employed whereby an instruction instance that corresponds to a detected runtime event is determined by backtracking from a point in a representation of the program code, which coincides with the detection toward a preceding instruction instance associated with the sampled runtime event. Backtracking may identify the preceding instruction instance at a displacement from the detection point unless an ambiguity creating location is disposed between the detection point and the preceding instruction instance. Such a technique is described in greater detail in commonly-owned co-pending U.S. patent application Ser. No. 10/050,358, entitled &#x201c;Techniques for Associating Instructions with Execution Events&#x201d;, filed Jan. 16, 2002, and naming Nicolai Kosche, Brian J. Wylie, Christopher P. Aoki, and Peter C. Damron as inventors, the entirety of which is incorporated herein by reference.</p>
<p id="p-0080" num="0079">At block <b>311</b>, the source-level data object language construct associated with the determined instruction instance may be identified using the annotation. For example, if the determined instruction instance is the instruction instance at code line <b>205</b> of <figref idref="DRAWINGS">FIG. 2A</figref>, then the associated source-level data object language construct is STRUCT TREE.NODE. At block <b>313</b>, the sample runtime event is attributed to the identified source-level data object language construct (e.g., STRUCT TREE.NODE). In some embodiments, attributing includes recording the sampled runtime event as associated information in a profile database. In some embodiments, the source-level data object language construct may be indicated in the profile database along with the sampled runtime event. Other associated information (e.g., program counter value, runtime event type, etc.) may be written to the profile database and associated with the source-level data object language construct during data collection, in some embodiments. From block <b>313</b>, control flows to block <b>307</b>. At block <b>307</b>, if execution is determined to be complete, control flows to block <b>321</b>, and the code stops executing. If at block <b>307</b> it is determined that execution is not complete, control flows to block <b>303</b>. Control flows back and forth between blocks <b>307</b> and <b>303</b> until another runtime event is detected, at which time the collection process repeats.</p>
<p id="p-0081" num="0080">Collecting profile data that describes source-level data object language constructs and their associated sampled runtime events, may facilitate optimizing code from the perspective of source-level data objects. A developer or an application with optimization intelligence may modify code (e.g., using structure padding, member reordering, structure merging, structure splitting, etc.) based on code behavior related to particular source-level data objects based on identification with the language constructs.</p>
<p id="p-0082" num="0081">In addition to optimizing code with profile data that reveals code behavior with respect to source-level data objects, profile data that reveals code behavior related to data addresses (which are extended address elements) may also provide for more efficient and targeted code optimization. The data addresses may be associated with memory reference objects. Memory reference objects may include physical memory reference objects (e.g., cache levels, cache lines, cache sub-blocks, memory controllers, memory management page translation units, etc.) and/or logical memory references (e.g., memory segments, heap variables, stack variables, variable instances, expressions, data structures, etc.). With profile data from the perspective of data addresses, the memory reference objects associated with the data addresses may in some embodiments be correlated with sampled runtime events. As previously stated, attributing runtime events to data addresses may also provide for more efficient code optimization. Sampled runtime events may be attributed to data addresses during data collection.</p>
<p id="p-0083" num="0082"><figref idref="DRAWINGS">FIG. 4</figref> illustrates a flowchart for attributing sampled runtime events to data addresses, according to one embodiment. Blocks <b>401</b>-<b>409</b> are similar to corresponding blocks <b>301</b>-<b>309</b>, described above.</p>
<p id="p-0084" num="0083">At block <b>411</b>, a determined instruction instance is disassembled, or decoded, to determine the register entries used to compute the effective address. In some embodiments, the effective address is an address indicated by the instruction instance, and may correspond to the location of operand data, another address, etc. This address information is often dependent on the content of one or more registers at the time the instruction instance is executed. In some embodiments, at block <b>413</b>, it is determined if the contents of these registers have changed. If the contents have changed, then control flows to block <b>415</b>. If the contents have not changed, then control flows to block <b>417</b>.</p>
<p id="p-0085" num="0084">At block <b>415</b>, the effective address is indicated as invalid and control flows from block <b>415</b> to block <b>407</b>. At block <b>417</b>, the effective address is computed from the disassembled instruction instance. At block <b>419</b>, the sampled runtime event is attributed to the computed effective address. Control flows from block <b>419</b> to block <b>407</b>, and the collection process is repeated if any additional runtime events are detected during execution.</p>
<p id="p-0086" num="0085">In other embodiments, the operations depicted in <figref idref="DRAWINGS">FIG. 4</figref> may be implemented differently. For example, software implementations may perform the operations individually and sequentially, as depicted, or in parallel and combining certain operations. In addition, various hardware implementations may implement hardware to perform operations depicted in <figref idref="DRAWINGS">FIG. 4</figref>. For example, in one embodiment, hardware is utilized to determine which instruction instance is of interest, and to determine validity of the determined instruction instances of interest. In another example, hardware is utilized to effectively perform the operations depicted at blocks <b>409</b>, <b>411</b>, <b>413</b>, <b>415</b>, and <b>417</b>. In such embodiments hardware may compute effective addresses without decoding instruction instances, thus de facto determining validity of the instruction instances. Such a technique is described in greater detail in commonly assigned, co-pending U.S. patent application Ser. No. 10/113,357, entitled, &#x201c;Sampling Mechanism Including Instruction Filtering&#x201d;, filed Jan. 16, 2002, and naming Adam Talcon and Mario Wolczko as inventors, which is incorporated herein by reference in its entirety.</p>
<p id="p-0087" num="0086"><figref idref="DRAWINGS">FIG. 5</figref> is a flowchart for determining an instruction instance that corresponds to a sampled runtime event as described in block <b>309</b> of <figref idref="DRAWINGS">FIG. 3</figref> or block <b>409</b> of <figref idref="DRAWINGS">FIG. 4</figref>, according to one embodiment. In this example, control flows from block <b>305</b> (or <b>405</b>) to block <b>501</b>. At block <b>501</b>, a trap generated as a result of a sampled runtime event is received. At block <b>503</b>, a program counter value (PC) is determined from a trap or a statistical packet provided by the trap. At block <b>505</b>, the trigger instruction instance is determined according to the program counter value. At block <b>507</b>, it is determined if the trigger instruction instance is the cause of the sampled runtime event. If the trigger instruction instance is not the cause of the sampled runtime event, then control flows to block <b>511</b>. If the trigger instruction instance is determined to be the cause of the sampled runtime event, then control flows to block <b>509</b>.</p>
<p id="p-0088" num="0087">At block <b>509</b>, the trigger instruction instance may be submitted as corresponding to the runtime event. From block <b>509</b>, control flows to block <b>311</b> of <figref idref="DRAWINGS">FIG. 3</figref> or to block <b>411</b> of <figref idref="DRAWINGS">FIG. 4</figref>. At block <b>511</b>, a search may be initiated for the instruction instance that caused the sampled runtime event. At block <b>513</b>, it is determined if the instruction instance that caused the sampled runtime event is found. If the instruction instance is found, then control flows to block <b>515</b>. If the instruction instance is not found, then control flows to block <b>517</b>.</p>
<p id="p-0089" num="0088">At block <b>515</b>, the instruction instance determined to cause the sampled runtime event may be submitted as corresponding to the runtime event. Control flows from block <b>515</b> to block <b>311</b> of <figref idref="DRAWINGS">FIG. 3</figref> or block <b>411</b> of <figref idref="DRAWINGS">FIG. 4</figref>. At block <b>517</b>, it is indicated that the cause of the sampled runtime event could not be determined. Control flows from block <b>517</b> to block <b>307</b> of <figref idref="DRAWINGS">FIG. 3</figref> or block <b>407</b> of <figref idref="DRAWINGS">FIG. 4</figref>.</p>
<p id="p-0090" num="0089"><figref idref="DRAWINGS">FIG. 6</figref> is a conceptual diagram illustrating data addresses being attributed to sampled runtime events according to one embodiment. In this example, an instruction sequence <b>607</b> includes instruction instances <b>609</b>, <b>611</b>, and <b>613</b>. A sampled runtime event <b>601</b> is attributed to the corresponding instruction instance <b>609</b>. An effective address &#x201c;0x00000640&#x201d; is computed from the disassembled instruction instance <b>609</b> and stored in an entry in a table <b>621</b> along with an association between the sampled runtime event and the effective address. In other embodiments, table <b>621</b> may be implemented differently (e.g., using different physical structures, logical structures, a file, various data structures, etc.) and may include more, fewer, or different amounts and types of information than that described in this example.</p>
<p id="p-0091" num="0090">In this example, another sampled runtime event, event <b>603</b>, is attributed to the corresponding instruction instance <b>611</b>. Contents of the register entries corresponding to instruction instance <b>611</b> have changed, so the effective address may not be computed, in some embodiments. In other embodiments, if the contents of the registers have changed, the effective address may be computed by means other than that described in <figref idref="DRAWINGS">FIG. 4</figref>. One such means is described in more detail later. In the second entry in the table <b>621</b>, a null value or a value indicating &#x201c;uncomputable address&#x201d; may be stored and associated with the sampled runtime event <b>603</b>, in one embodiment. In other embodiments, an entry may not be included at all in table <b>621</b> if the effective address cannot be computed.</p>
<p id="p-0092" num="0091">A third sampled runtime event, event <b>605</b>, may be attributed to the corresponding instruction instance <b>613</b>. In this example, an effective address &#x201c;0x00000720&#x201d; may be computed from the disassembled instruction instance <b>613</b> and stored in the third entry of the table <b>621</b>. The address &#x201c;0x00000720&#x201d; may also be associated with the sampled runtime event <b>605</b> in the table <b>621</b>, in some embodiments.</p>
<p id="p-0093" num="0092">Data address profiling may in some embodiments facilitate determination of execution hindrance with different perspectives of memory references. For example, a user may be able to identify the cache line that consumes the most execution time, and correlate delay times with data addresses or statically linked objects (e.g., global or static variables in C/C++). In another example, a user may be able to ascertain which cache line consumes the most execution time based upon which associated addresses (either virtual or physical) are associated with the most delay. These associations between sampled runtime events and addresses may provide for efficient and targeted optimization of code with respect to data addresses and statically linked objects (e.g., static variables, global variables, etc.). In some embodiments, additional information, such as address type, may be associated with sampled runtime events and data address. In addition, data addresses may be converted between different representations at different times, in different embodiments. For example, virtual addresses may be converted to physical addresses during data collection or after data collection, according to different embodiments.</p>
<p id="h-0008" num="0000">Recording Profile Data</p>
<p id="p-0094" num="0093">The statistical data collected for data profiling may be recorded using various techniques, according to different embodiments. For example, <figref idref="DRAWINGS">FIG. 7</figref> illustrates one embodiment of a method for recording profile data. In this example, a data profiling module <b>701</b> receives statistical packets <b>706</b> for one or more sampled runtime events. The statistical packets <b>706</b> may be generated by one or more sampled runtime events that occur in execution space <b>705</b> for a code <b>709</b>. In <figref idref="DRAWINGS">FIG. 7</figref>, execution space <b>705</b> is located on a host machine <b>751</b>. The host machine <b>751</b> may also host all or part of data profiling module <b>701</b> (e.g., host machine <b>751</b> may host one or more daemon processes that collect statistical data). A data profiling server <b>753</b> may host the remaining parts of data profiling module <b>701</b>, which may periodically retrieve or receive collected statistical data from a daemon process on host machine <b>751</b>. In other embodiments, the data profiling module may be implemented differently. For example, data profiling module <b>701</b> may include multiple processes and/or sub-modules distributed between a host and a server, data profiling module <b>701</b> may be distributed over multiple nodes of a network, data profiling module <b>701</b> may be implemented within a single host machine, data profiling module <b>710</b> may work in conjunction with a code profiling module, etc.</p>
<p id="p-0095" num="0094">In this example, the data profiling module <b>701</b> may record the profile data generated from the statistical packets in profile data structures <b>703</b>A-<b>703</b>F. Afterward, the profile data in the data structures <b>703</b>A-<b>703</b>F may be recorded into a profile database <b>711</b>. In other embodiments, the profile database <b>711</b> and/or recording profile data may be implemented differently. For example, the profile database <b>711</b> may be an on-disk database or may be instantiated in main memory, in different embodiments. In some embodiments, the profile data may be recorded directly to the profile database and then analyzed, or may be stored in main memory for analysis. The results of analyzing the profile data in main memory may be stored in the profile database on a storage media, or elsewhere, according to different embodiments. In one example, collected profile data may be written to an on-disk database and organized into non-overlapping epochs. In some embodiments, the profile database <b>711</b> may be hosted by the data profiling server <b>753</b>. In other embodiments, the profile database <b>711</b> may be remote from the data profiling server <b>753</b>. In such embodiments, the profile data may be transmitted over a network (e.g., Ethemet, ATM, wireless, Frame Relay, etc.).</p>
<p id="p-0096" num="0095"><figref idref="DRAWINGS">FIGS. 8A-8B</figref> are conceptual diagrams of exemplary profile data structures according to different embodiments. <figref idref="DRAWINGS">FIG. 8A</figref> illustrates an exemplary source-level data object language construct indexed profile data structure, according to one embodiment. In <figref idref="DRAWINGS">FIG. 8A</figref>, the source-level data object language construct indexed profile data structure <b>801</b> includes an index into sampled runtime event data structures. The index includes indices <b>803</b>A-<b>803</b>G (e.g., each index may be a clustered index). Structures indicating profile data may be implemented differently in different embodiment (e.g., using unclustered indices, clustered indices, hashed indices, etc.). Each of the indices <b>803</b>A-<b>803</b>G references a sampled runtime event data structure. For example, index <b>803</b>A of <figref idref="DRAWINGS">FIG. 8A</figref> references a sampled runtime event data structure <b>805</b>. In some embodiments, each index references a single sampled runtime event data structure, which may reference other sampled runtime event data structures. In other embodiments, each of the indices may reference multiple sampled runtime event data structures. In the example illustrated by <figref idref="DRAWINGS">FIG. 8</figref>, the index <b>803</b>A may be a clustered index and the sampled runtime event data structure <b>805</b> may be a data array. Details of an exemplary sampled runtime event data structure are illustrated in <figref idref="DRAWINGS">FIG. 9</figref>.</p>
<p id="p-0097" num="0096">In this example, index <b>803</b>F is an index for STRUCT TREE. The source-level data object language construct STRUCT TREE may be hashed to generate a unique index that is the index <b>803</b>F, in some embodiments. Various techniques may be used for indexing in different embodiments (e.g., using a string &#x201c;STRUCT TREE&#x201d; as the index, assigning a unique value for each source-level data object in the code, etc.). Similarly, the index <b>803</b>G may be a hash of the source-level data object language construct INT TREE.LEAFS, in some embodiments.</p>
<p id="p-0098" num="0097"><figref idref="DRAWINGS">FIG. 8B</figref> illustrates an exemplary data address indexed profile data structure, according to one embodiment. In this example, <figref idref="DRAWINGS">FIG. 8B</figref> illustrates an address indexed profile data structure <b>821</b> that is similar to the data structure illustrated in <figref idref="DRAWINGS">FIG. 8A</figref>. In contrast to the source-level data object language construct indexed profile data structure <b>801</b> of <figref idref="DRAWINGS">FIG. 8A</figref>, a data address indexed profile data structure <b>821</b> indexes sampled runtime event data structures using indices based on data addresses. The data address indexed profile data structure <b>821</b> is indexed with indices <b>823</b>A-<b>823</b>G. In some embodiments, these may correspond to actual data addresses or may be computed values based on the actual data addresses. In this example, the index <b>823</b>A may reference a sampled runtime event data structure <b>808</b>, which may be similar to the sampled runtime event data structure <b>805</b> of <figref idref="DRAWINGS">FIG. 8A</figref>. In different embodiments, the combination of data structures may vary (e.g., sampled runtime event data structures across different profile data structures may be the same or different). In this example, the index <b>823</b>F may be based on a hash of the address &#x201c;0x00000640&#x201d; and the index <b>823</b>G may be based on a hash of the address &#x201c;0x00000720.&#x201d; As with the indices described in <figref idref="DRAWINGS">FIG. 8A</figref>, indices <b>823</b>A-<b>823</b>G may be implemented differently in different embodiments.</p>
<p id="p-0099" num="0098"><figref idref="DRAWINGS">FIG. 9</figref> is a block diagram illustrating an exemplary sampled runtime event data structure, according to one embodiment. The sampled runtime event data structure <b>900</b> illustrated in <figref idref="DRAWINGS">FIG. 9</figref> includes numerous fields as examples of statistical information that may be associated with sampled runtime events. This information may be extracted from statistical packets generated by a corresponding interrupt or trap, or may be collected by various other types of hardware or software event agents. The sampled runtime event data structure <b>900</b> illustrated in <figref idref="DRAWINGS">FIG. 9</figref> includes the following fields: an event type field <b>901</b>, a metric field <b>903</b>, a number of events field <b>905</b>, an address field <b>907</b>, address type field <b>909</b>, a thread identifier field <b>911</b>, a processor identifier field <b>913</b>, a process identifier (PID) field <b>915</b>, a program counter field <b>917</b>, and a function name field <b>919</b>. The sampled runtime event data structure <b>900</b> may include more, fewer, or different fields in different embodiments. For example, the sampled runtime event data structure <b>900</b> may be referenced by a corresponding address, therefore, the address field <b>907</b> may be removed or may be replaced with a different field, such as a source-level data object language construct field, an instruction instance field, an instruction instance type field, an event mask, an indexing structure, etc. In other embodiments, multiple address fields may be included, corresponding to the addresses of different hardware components and/or additional software constructs associated with the event. For example, addresses may be included to identify a memory board, core, strand, function, task, etc.</p>
<p id="p-0100" num="0099">In this example, the event type field <b>901</b> may indicate the type of sampled runtime event tracked by the sampled runtime event data structure <b>900</b> (e.g., data reference, cache miss, cache reference, data translation buffer miss, data translation buffer reference, etc.). The metric field <b>903</b> may indicate a metric associated with the sampled runtime event (e.g., number of cycles, execution time in seconds, memory stall time, etc.). In some embodiments, the metric field <b>903</b> may correspond to multiple metrics (e.g., a list of metrics for one or more sampled runtime events). The number of events field <b>905</b> may indicate the number of sampled runtime events that have occurred of the same type and/or with the same associated statistical information, in some embodiments. In some embodiments, the metric field <b>903</b> may be optional and the value may be inferred from the number of events field. Alternatively, the number of events may be inferred from the metric field <b>903</b>. In addition, a sampled runtime event data structure <b>900</b> may be maintained for each individual sampled runtime event that occurs, despite repetition of statistical information, some embodiments. In different embodiments, sampled runtime event data structures may share fields or a sampled runtime event data structure may indicate information for multiple sampled runtime events, for example.</p>
<p id="p-0101" num="0100">The address field <b>907</b> may indicate an address (e.g., in identifier of a cache line or cache sub-block, a random access memory address, a storage address, etc.) associated with the sampled runtime event. The address type field <b>909</b> may indicate the address type (e.g., physical address, virtual address, page, segment, memory board, cache line, etc.) of the address element indicated in the address field <b>907</b>. In different embodiments, the runtime event data structure may be implemented differently and may include more or less information than illustrated in <figref idref="DRAWINGS">FIG. 9</figref>. For example, a runtime event data structure may include multiple extended address element fields and accompanying address type fields, or it may include multiple address element fields but not address type fields because the address types may be inferred from the address elements themselves.</p>
<p id="p-0102" num="0101">The thread identifier field <b>911</b> may identify a thread associated with the runtime event. The processor identifier field <b>913</b> may identify the processor associated with the runtime event. The process identifier (PID) field <b>915</b> may indicate the PID provided by the host operating system to identify the process associated with the runtime event. The program counter field <b>917</b> may indicate value of the program counter(s) corresponding to the sampled runtime event. The function name field <b>919</b> may identify a function that corresponds to the sampled runtime event.</p>
<p id="p-0103" num="0102">As previously noted, in different embodiments, the sampled runtime event data structure may be implemented and/or utilized differently. For example, the sampled runtime event data structure <b>900</b> may be instantiated for each type of runtime event associated with a particular code behavior attribute, or as an element of a data structure associated with a particular code behavior attribute. The fields illustrated in <figref idref="DRAWINGS">FIG. 9</figref> are for illustration alone and are not meant to be limiting upon the invention. Various embodiments may include some or all of these fields, and may include additional fields not illustrated in <figref idref="DRAWINGS">FIG. 9</figref>. In addition, the sampled runtime event data structure <b>900</b> may be N-indexed in some embodiments. For example, the sampled runtime event data structure may be indexed by a hash table of addresses and by a hash table of source-level data object language constructs. In this example, the runtime event data structure may refer to the indexing elements of both hash tables. In some embodiments, a hash table may have indices corresponding to different types of sampled runtime events. Each of the indices may reference statistical information for that particular type of runtime event. In some embodiments, the fields may be grouped into nodes of a binary search tree for a particular runtime event.</p>
<p id="p-0104" num="0103">The data structures described above may correspond to profile data collected and stored in a per-thread or per-address-space repository, in some embodiments, or may represent profile data that has been processed by an intermediate agent for inclusion in the primary event space for the application. These data structures may be stored in separate tables of a single file, in separate files, in one or more databases, or in any other suitable memory structure on the machine on which the data was collected, on the machine on which the analyzer is run, or on a remote storage device, according to different embodiments.</p>
<p id="h-0009" num="0000">Analyzing Profile Data</p>
<p id="p-0105" num="0104">After profile data is collected, tools may analyze the profile data. In some embodiments, the tools may employ artificial intelligence and/or neural networks. The tools may be used to analyze the profile data to determine the cause of certain code behavior, such as stall cycles, in some embodiments. The profile data may be analyzed based on correlations between sampled runtime events (or consumed execution times corresponding to runtime events) and various code behavior attributes (e.g., source-level data object addresses, source-level data objects, source-level data object definitions, functions/methods, threads, time, processes, processors, etc.).</p>
<p id="p-0106" num="0105"><figref idref="DRAWINGS">FIG. 10</figref> is a conceptual diagram illustrating correlation of multiple code behavior attributes according to one embodiment. At block <b>1001</b>, code behavior attributes have been indicated. These code behavior attributes may have been specified directly by a user, in a configuration file, through default settings, etc., in different embodiments. In the example illustrated by <figref idref="DRAWINGS">FIG. 10</figref>, the code behavior attributes include source-level data object language constructs, instruction object language constructs, threads, and addresses. A profile data correlation report may be generated that includes correlation between specific instances of these code behavior attributes, correlation between all code behavior attributes, correlation between conventional profile data and all or particular ones of the code behavior attributes, correlation between the code behavior attributes and other code behavior attributes not listed here, between instances of these exemplary code behavior attributes and instances of other code behavior attributes, etc., in different embodiments.</p>
<p id="p-0107" num="0106">The code behavior attributes shown in block <b>1001</b> may be used to retrieve entries from source-level data object language construct indexed profile data structure <b>1003</b>, instruction object language construct indexed profile data structure <b>1004</b>, thread indexed profile data structure <b>1006</b>, and address indexed profile data structure <b>1005</b>, in some embodiments. In this example, a set of common attributes <b>1007</b> may be extracted from the various attribute indexes profile data structures <b>1003</b>-<b>1006</b>. For example, all addresses included within the various attribute indexed profile data structures <b>1003</b>-<b>1006</b> may be extracted. An operation may be performed on the extracted common set of attributes <b>1007</b> to find a set of intersecting common attributes <b>1011</b>. For example, an intersecting set of addresses may include each of the addresses that can be found in all of the various attribute indexed profile data structures <b>1003</b>-<b>1006</b>. With the set of intersecting common attributes <b>1011</b>, entries from the attribute indexed profile data structures <b>1003</b>-<b>1006</b> that correspond to the set of intersecting common attributes <b>1011</b> may be retrieved and the retrieved attribute indexed profile data entries <b>1015</b> may be displayed, stored, transmitted, analyzed, filtered, ordered, etc. The profile data of these retrieved entries may provide insight into code behavior, such as cycle time or memory stall time, from the perspective of any number of code behavior attributes. In different embodiments, fewer, more, or different code behavior attributes than those illustrated in <figref idref="DRAWINGS">FIG. 10</figref> may be utilized.</p>
<p id="p-0108" num="0107"><figref idref="DRAWINGS">FIG. 11</figref> is a flowchart for analyzing source-level data object profile data from the perspective of multiple code behavior attributes, according to one embodiment. In this example, at block <b>1101</b>, N code behavior attributes are received. At block <b>1103</b>, a control value X is set to 0. At block <b>1105</b>, all profile data entries matching code attribute X are retrieved. At block <b>1107</b>, the control value is incremented. At block <b>1109</b>, it is determined if the control value is greater than N. If the control value is greater than N, then control flows to block <b>1113</b>. If the control value is not greater than N, then control flows to block <b>1111</b>.</p>
<p id="p-0109" num="0108">At block <b>1111</b>, the retrieved profile data that does not match attribute X is removed. Control flows from block <b>1111</b> back to block <b>1107</b>. At block <b>1113</b>, the retrieved profile data is sorted. At block <b>1115</b>, the sorted and filtered profile data is provided. The profile data can be provided for display on a monitor, for saving to a file, for transmission over a network, etc.</p>
<p id="p-0110" num="0109">While the flow diagrams described above depict a particular order of operations performed by certain embodiments, it should be understood that such order is exemplary (e.g., alternative embodiments may perform the operations in a different order, may combine certain operations, may overlap certain operations, may perform certain operations in parallel, etc.). For example, the loop in <figref idref="DRAWINGS">FIG. 11</figref> at blocks <b>1107</b>, <b>1109</b>, and <b>1111</b> may be performed differently in different embodiments. In different embodiments, block <b>1113</b> of <figref idref="DRAWINGS">FIG. 11</figref> may not be performed at all, may be combined with block <b>1111</b>, or may be performed in parallel with block <b>1111</b>. In addition, profile data aggregated by a code behavior attribute may be further aggregated and/or filtered with one or more selected instances of the code behavior attribute and/or other code behavior attributes, some embodiments.</p>
<p id="p-0111" num="0110">Filtering profile data based on combinations of various code behavior attributes may in some embodiments allow analysis of the profile data from numerous perspectives. Correlating multiple code behavior attributes may in some embodiments facilitate more sophisticated code optimization than optimization based on traditional profiling techniques. Correlation of multiple code behavior attributes may also provide additional/alternative views of profile data (e.g., a view of profile data at a more thorough source-level) in some embodiments.</p>
<p id="h-0010" num="0000">Parallelism and Scalability</p>
<p id="p-0112" num="0111">As previously noted, developers may attempt to maximize performance by exploiting parallelism (e.g., by executing multiple threads of a multi-threaded process on multiple processor cores in parallel). However, data motion between hardware resources may inhibit application scalability and, thus, application performance. The data profiler described herein may in some embodiments facilitate performance improvements by allowing identification of bottlenecks caused by data motion between hardware resources. For example, data motion of a shared variable among processors exemplifies true sharing that may inhibit performance. In one example, a cache line full of data may migrate among two or more processors requesting a shared variable. References to data migrating between processors may be substantially slower than a local reference to the data. Identifying the migrating cache line and relating the cache line to the shared variable may facilitate solving the scaling problem, in this example. The data space profiler described herein may in some embodiments allow a developer to identify all data migrations within hardware and, thus, to resolve scaling challenges. The profiler may profile data motion in hardware and relate the costs to application source code (e.g., data definitions, function/methods, scheduling and memory allocations), in some embodiments.</p>
<p id="p-0113" num="0112">The data space profiler described herein may in some embodiments be used to profile a complete system through a coupling of event agents, relational agents, and the application of business intelligence, on-line analytic processing (OLAP), to performance engineering. Hardware and software event agents may capture data motion and runtime events involving data motion. These event agents may tightly couple the extended address elements of the event with the cost of the event. In other words, a specific cost (for example, execution time) may be associated with a specific address, where the address may include any combination of a program counter value, an effective address of the data, a physical address of the data, a processor address, a thread address, and other addresses.</p>
<p id="p-0114" num="0113">Examples of the different types of address elements that may be associated with data motion instructions and/or runtime events are illustrated in <figref idref="DRAWINGS">FIGS. 12 and 13</figref>. <figref idref="DRAWINGS">FIG. 12</figref>, for example, illustrates hardware components of the system, each of which may be identified by an &#x201c;address.&#x201d; These addresses may be used by the profiler as identifiers of profiling objects corresponding to the hardware components. In one embodiment, the address of each hardware component may include a virtual or physical address in the memory map of the system and/or the address space of a software application (e.g., each memory bank <b>1280</b> may be addressed by a starting address for the address bank, or using an offset from an address for the corresponding memory board <b>1270</b>). In another embodiment, the address of each hardware device may include a label or index for the component (e.g., each processor <b>1200</b> may be assigned a label: processor<b>1</b>, processor<b>2</b>, etc.) In other embodiments, some hardware components may be addressed using a memory-mapped address, while others are addressed using a label, index, or other identifier. In still other embodiments, the addresses identifying each hardware component in a system may include a combination of memory-mapped addresses, labels, indices, and other identifiers. As illustrated in <figref idref="DRAWINGS">FIG. 12</figref>, each memory sub-system component, board, integrated circuit device or functional module thereof, interface, or storage location may be considered a data profiling object and may be identified by a corresponding extended address element. In addition, functional or arbitrary sub-modules or sub-components of the data profiling objects illustrated in <figref idref="DRAWINGS">FIG. 12</figref> (e.g. a TLB within an MMU <b>1120</b>) may also be considered data profiling objects. In other examples and embodiments, more, fewer, or different hardware components may correspond to data profiling objects and each may be associated with one or more extended address elements.</p>
<p id="p-0115" num="0114">Each programming structure and source-level data object in a system may also be identified by an address, in some embodiments. <figref idref="DRAWINGS">FIG. 13</figref>, for example, illustrates various software components that may be identified by one or more addresses. In this example, each process <b>1350</b> may be identified by its PID and/or by a corresponding source-level language construct. Similarly, each load object <b>1340</b> may be identified by a corresponding source-level language construct or by a virtual or physical address corresponding to the start of the instructions therein, for example. Each function <b>1330</b>, thread <b>1310</b>, and instruction <b>1320</b> may also be identified by one or more addresses, including source-level language constructs, virtual and physical addresses, program counter values at the start of execution of the function/thread/instruction instance, etc., in various embodiments. Data objects, whether corresponding to individual data items (e.g., data objects <b>1360</b>) or elements within more complex data object structures (e.g., data objects <b>1370</b> within data structure <b>1380</b>), may be identified by source-level language constructs (e.g., variable names), virtual or physical addresses of the data objects, etc. <figref idref="DRAWINGS">FIG. 13</figref> also illustrates that a software thread <b>1310</b> may be executed on a particular hardware strand <b>1380</b>. The addresses associated with both software thread <b>1310</b> and strand <b>1380</b> may be considered address elements of runtime events associated with thread <b>1310</b>, in this example. Relational agents may map these address elements and associated runtime event costs, to other hardware and software data profiling objects involved in the events, such as cache lines or variable names, in various embodiments.</p>
<p id="p-0116" num="0115">The analysis engine may be used to drill down to the cause of observed bottlenecks by applying set arithmetic on the relationships mapped the event set, in some embodiments. For example, a user may display virtual addresses and then display physical addresses used by only the most costly cache line. By examining the two displays, the user may identify whether true sharing (e.g., between one physical and/or virtual address and one cache line) or conflicts (e.g., between many physical addresses and one cache line) may inhibit application scalability, and if so, where (e.g., by identifying the shared variable). The data space profiling system and method described herein may be applied to profiling data motion in networks of computers, computer sub-components, and networks of storage devices, in various embodiments.</p>
<p id="h-0011" num="0000">Profiling Using Turing Machine Model</p>
<p id="p-0117" num="0116">It has been proven elsewhere that all computation devices may be expressed using Turing Machines. In other words, if a system can be used to profile a Turing Machine, then it may be used to profile any/all computing system(s). Computing systems may be modeled as a Turing Machine sub-set or variant called a Random Access Machine. Traditional profiling tools focused on the state transition aspect of the Turing Machine. The data space profiler described herein models profiling of the machine tape of a Turing Machine instead. For example, <figref idref="DRAWINGS">FIG. 14</figref> illustrates a computing system modeled as a Random Access Machine, according to one embodiment. In this example, random access machine <b>1400</b> includes a tape <b>1420</b>, having storage locations numbered 0 to n, a state transition table <b>1430</b>, and a read/write head <b>1410</b>. In this example, the event set for the computing system is addressed by finite locations on tape:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>A={s,n}</i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>Event Set: <i>E={A, c}</i><?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0118" num="0117">In this example, A (Addresses) may be represented as a tuple comprising s (the state from the state transition table) and n (the address on the tape). Each event in the event set comprises an address (A) and a cost (c).</p>
<p id="p-0119" num="0118">Early profilers focused on s in the state transition table because data transformations (i.e., processors and execution units) were the most costly components in early systems. The data space profiling tool described herein provides a superset of existing profiling technologies, because in modern machines the state transitions are actually modeled in the random access tape. Virtually all hardware may all be profiled using this tool, because all computer hardware (computer memory, computer processors, computer networks, storage systems, and others) may be modeled as being equivalent to a Random Access Memory Turing Machine. For example, internal components of computers, networks of computers, computing grids, and storage networks may all be profiled and related to the objects that are most relevant to the developer (e.g., elements of the memory hierarchy that affect data movement.)</p>
<p id="p-0120" num="0119">The profiling methodology and tools described herein may be used to extend multidimensional data to the profiling of complete systems, not just instructions, in various embodiments. For example, they may not only capture virtual addresses of instructions (e.g., Program Counter values), as traditional profilers do, but they may capture a more complete set of extended address elements associated with runtime events. Event agents may include software and/or hardware to capture multiple extended address elements associated with an event. For example, in one embodiment the extended address may include: one or more virtual addresses (program data allocations), one or more program counter addresses (instructions), one or more physical addresses (hardware allocations), one or more cache addresses (identifies which caches are used), one or more software execution entity addresses (threads), one or more execution device addresses (HW strands), one or more temporal addresses (time), and other addresses (e.g., network addresses, storage locations, etc.)</p>
<p id="h-0012" num="0000">Tonology and Set Theory</p>
<p id="p-0121" num="0120">The architecture of the data space profiler described herein is based on a mathematical model using n-space topology. This model allows instruction execution information and data movement information to be merged. For example, instructions with high stall times caused by data movement may be traced to cache and/or memory bank conflicts, in some embodiments. These in turn may be traced to inter- or intra-thread conflicts or to interactions with other programs. Once these are identified, they may be traced back to the instructions that caused the conflict, in some embodiments. The mathematical model that under girds the profiler and enables correlations between these data objects is described below.</p>
<p id="p-0122" num="0121">The profiler architecture collects, manages, processes and presents multidimensional performance data for analysis. The profiler may in some embodiments expand on statistical event sampling mechanisms. Various event agents, or collectors, may be used to capture events that collectively create an event space, in some embodiments. This event space may then be mapped to hardware and software components. Relational operators may provide cost breakdowns from the event space for hardware components and software constructs. Events may be sliced, filtered, and viewed across different dimensions, in various embodiments. In other words, actionable insight may be drawn out of the data by slicing, dicing, and drilling down on it, using the relational agents and analysis engine of the profiler, in some embodiments.</p>
<p id="p-0123" num="0122">As previously noted, throughput performance is often achieved by improving concurrent program execution, reducing contention, and lowering the cost of coherency. However, in many of these cases, data movement constrains the achievable gain. In these situations, processors may spend more time waiting for data movement than executing instructions. Computer architects, recognizing this dependency, introduced multi-threaded cores to hide data latency. In these systems, while one thread is blocked fetching data, another can execute.</p>
<p id="p-0124" num="0123">Optimization that takes into account the scalability of threads may depend on the accurate identification and characterization of data motion. Despite evidence that data motion is a key determinant in throughput, an instruction-centric profiling paradigm persists. Analysis of instruction execution, such as using traditional profilers, yields limited scalability insights. Performance analysts may determine that algorithms have certain characteristics but only with great difficulty may they understand the effects of the memory hierarchy on performance. Hardly ever will they understand interactions with other parts of the program, other threads of execution, or other programs, yet these may be more important for system throughput and scalability than the choice of the best software algorithm.</p>
<p id="p-0125" num="0124">The architecture and mathematics of the data space profiler may be described using set theory and topology. Topology, as used herein, is the study of the properties that are preserved through deformations, twisting and stretching, or, the set of a collection of subsets that satisfy defining properties. Topological space, as used herein, is a set with a collection of subsets that together satisfy a certain set of properties that define that set.</p>
<p id="p-0126" num="0125">Topology may give more or maximum flexibility in discussing data space as compared to other descriptions. With topological analysis, employing propositions based on set theory (i.e., doing analysis based on numbers in lists) may be used. Whereas there are traditional set theory boundaries, flexibility may be obtained by means of abstraction. In this respect, sets may be viewed as ordered lists appearing in other lists.</p>
<p id="p-0127" num="0126">A Digital Continuous Profiling Infrastructure (DCPI) is described in the ProfileMe paper from WRL by Jefferey Dean, et al. This paper describes an event vector, {right arrow over (E)}, which expresses the required correlation between {PC, VA, cost}. In some embodiments of the data space profiler, hardware may enable profiling of the program counter, PC, on an out-of-order processor, and the virtual address, VA, with associated cost events. In this example, cost refers to the performance cost of execution of an associated instruction and the access to the virtual address.</p>
<p id="p-0128" num="0127">The Event Space, S, is described by:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>S={right arrow over (E)}<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0129" num="0128">Each element in vector {right arrow over (E)} is defined as:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>E={PC,VA,Cost,time}<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0130" num="0129">This paper states that in a constant cost gradient, one can infer PC costs and VA costs by the probability function P<sub>PC</sub>({right arrow over (E)}) and P<sub>VA</sub>({right arrow over (E)}) within the constant cost gradient. The functions approximate cost for the instructions and virtual addresses used. For example, take this Event Set:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>E={PC,VA,L2CacheMiss,time}<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>E={{0&#xd7;1<i>f</i>0,0&#xd7;20000004,1003,10.05}, {0&#xd7;200,0&#xd7;1<i>ffffff</i>8,1003,10.13 }, {0&#xd7;1<i>f</i>0,0&#xd7;20000084,1003,10.14}, {0&#xd7;2<i>c</i>8,0&#xd7;<i>fffff</i>800,1003,10.16}, {0&#xd7;200,0&#xd7;1<i>ffffff</i>8,1003,10.20}}<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0131" num="0130">In this example, the probabilities of the instructions at 0x1f0 and 0x200 incurring a cache miss are double the probability of the instruction at 0x2c8. The L2CacheMiss cost at 0x1f0 and 0x200 were each 2006 while that at 0x2c8 was 1003. In this example, the VA 0x1ffffff8 incurred a cache miss twice as often as the other addresses. Its cost was approximately 2006 compared with 1003 for the other VAs.</p>
<p id="p-0132" num="0131">In some embodiments, performance counters (e.g., hardware counters implemented in the processor) may include support for trap-on-overflow. In some embodiments, the pipeline may support approximate correlation for cost when cost is time or L2 read misses. In some embodiments, the analyzer portion of the data profiling tool may supports events that are not tightly correlated between the event and the PC, such as L2 read stalls.</p>
<p id="p-0133" num="0132">In some embodiments, compiler support may facilitate some of the functionality involved in data profiling. For example, type information may be propagated from a C front-end to the code generator or all the way to the data profiling tool analyzer, in some embodiments. In other embodiments, typing rules may be defined for developers that use C as a portable assembler. In some embodiments, weakly typed languages tightly associate types with the instruction. For example, in embodiments in which different instructions operate on different data types, the type may be represented as a function of the program counter (PC):
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>re&#x192;Type=Funct(PC)<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0134" num="0133">There may be many more of these tightly associated functions for other objects, in some embodiments. For example, the virtual page number may be a function of the virtual address and the cache line accessed may be a function of the physical address associated with a runtime event:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>Virtual Page=Func(VA)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>Cacheline=Func(PA)<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0135" num="0134">Even physical address, PA, may actually be represented as a function of VA (although in some embodiments it may be represented by a long function, i.e., the page tables for the process):
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>PA=Func(VA)<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0136" num="0135">In some embodiments, the PA value may be collected at event collection time, while in other it may be calculated from the VA value at a later time, such as by one of the relational agents.</p>
<p id="p-0137" num="0136">The Event Vector {right arrow over (E)} in the analyzer may in some embodiments look like:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>E={{right arrow over (PC)},Cost,time,VA,PA,CPU,process,stand,thread,refType}<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0138" num="0137">In this example, the instruction vector, {right arrow over (PC)}, is the call stack of the thread for the event and refType is the referenced type of the instruction at the leaf of {right arrow over (PC)}, which may be added by the analyzer during post-processing.</p>
<p id="p-0139" num="0138">The analyzer may collect a set of isomorphic event vectors, {right arrow over (E)}, each based on what cost was collected: VA and PA may be collected in specialized records when profiling is selected for hardware counter events. Homeomorphism is an equivalence relation and a mappable correspondence that is continuous in both directions between points in two topological spaces. In some embodiments, the collection may be represented as a homeomorphic Event Vector:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>E={{right arrow over (PC)},{right arrow over (Cost)},time,VA,PA,CPU,process,thread,re&#x192;Type, . . . }<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0140" num="0139">In this modification cost is represented as a vector that is execution time-based, memory-subsystem time based, L2 Cache Miss based, etc. That is, cost is based on execution time, as affected by the memory hierarchy (e.g., an L2 cache miss). Using this model may in some embodiments result in a unified Event Space S, where the event space is the union of all event vectors:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>S={right arrow over (E<sub>exectime</sub>)}&#x222a;{right arrow over (E<sub>memtime</sub>)}&#x222a;{right arrow over (E<sub>L2miss</sub>)}<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0141" num="0140">Software may also have layers of structures similar to the memory hierarchy. In some embodiments, a similar approach may be taken to profile user-defined objects within an application with additional association operators.</p>
<p id="p-0142" num="0141">Memory hardware structures are predominantly of two types: content-addressed memory (CAMs), and address-indexed structures. Indexed structures are also functions of a portion of the address.</p>
<p id="p-0143" num="0142">For virtually indexed structures, the index into the structure I, may be defined as a function of the virtual address element of the event vector:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>I=Func(VA)<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0144" num="0143">For physically indexed structures, the index I, may be defined as a function of the physical address element of the event vector:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>I=Func(PA)<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0145" num="0144">Most of the hardware structures of computers may be described by using topological spaces. With this technology, the pages, cache lines, and software structures in use may be observed, according to different embodiments. Event agents capturing these structures may be implemented as hardware event agents, in some embodiments, or as software agents, in others. These event agents may be standard for most instantiations of the profiler, or may be specific to the particular platform on which the profiled application is executed.</p>
<p id="p-0146" num="0145">Clock-based profiling may be enabled, in some embodiments, by treating a clock event as a hardware counter-type event. A backtracking mechanism may be used to unwind a single instruction and decode it for a memory operation to create a memory sub-system hardware counter-typed Event Space, S. This space, S, has a cost type of memory sub-system time, instead of hardware counter event type:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>E={{right arrow over (PC)},Cost,time,VA,PA,CPU,process,strand,thread,re&#x192;Type}<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0147" num="0146">Arbitrary object definitions (e.g., memory objects, other hardware components, software constructs, etc.) may be allowed in the profiler, in some embodiments. Along with user and system object association operators, they may make the profiler highly adaptable, and may enable space S to be mapped into S&#x2032; by an arbitrary function:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>S&#x2032;=Func(S)<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0148" num="0147">These association operators may replicate the mappings found in applications, operating systems and hardware. The operators may enable the mapping of space S, into cost Scost by aggregating the user-defined spaces and associated cost functions. For example, the instance of time spent in memory subsystem vs. cache line may be represented as:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>S<sub>cost</sub>={CostInterval&#xd7;Count(Funccacheline(S)),Funccacheline(S)}<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0149" num="0148">Some of the operators that may be included in the profiler are: bit-wise operators; and, xor and or (&#x26;, ^, |), shifts (&#x3e;&#x3e;and&#x3c;&#x3c;), arithmetic operators, comparators (==, &#x3c;, &#x3e;, . . . ), logical operators (!, &#x26;&#x26;, &#x2225;) the ternary range operators (?:). All of these operators may help fold space into components usually found in hardware and software structures. In some embodiments, all of the event vector elements may be available as tokens (TSTAMP, PADDR, etc.). Such embodiments may also include various vector operators, such as the inclusion operator (scalar IN vector) returning a Boolean, and the terminator operator (LEAF vector) returning a scalar.</p>
<p id="p-0150" num="0149">The Funccacheline( ) function maps an Event Space, S, by aggregating based on the definition of the hardware indexing operation for the cache line. In this example, the Count( ) of events that match a cache line may be aggregated, and the sum may be multiplied by the CostGradient per event. However, an arbitrary function can be used to generate cost:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>Scost={Func cost(S),Funcobject(S)}<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0151" num="0150">In this example, Funcobject( ) returns the hardware or software object from space S; and FCost( ) is the arbitrary cost function. This flexibility may in some embodiments enable a user to create profiles by costs such as cycles-per-instruction, something that may not be practical to do from a cache line perspective in hardware.</p>
<p id="p-0152" num="0151">Note that Funcobject( ), a user-specified object, may be used to define existing maps, such as inclusive costs within the function object:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>Funcinclusive_&#x192;unc(S)={(Func&#x192;unction(S)IN Funccallstack(S)}<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0153" num="0152">In this example, Funcfunction( ) returns the source-level language object view for the collection of instructions named Function; and Funccallstack( ) returns the call stack from the event space.</p>
<p id="p-0154" num="0153">The function for exclusive costs within a function object may be defined as:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>Func&#x192;unction(S)={Funcpc_to_&#x192;unction(S)}<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
Slices
</p>
<p id="p-0155" num="0154">The true power of data profiling may be in its ability to extract slices from space S. An operator that slices the event space by a specific time interval may be applied to the event set, as in this example:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>S&#x2032;={((Func<sub>second</sub>(S)&#x2267;10)&#x2229;(Func<sub>second</sub>(S)&#x3c;11))}<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0156" num="0155">In this example, the function Funcsecond( ) returns the time interval for the event space in seconds.</p>
<p id="p-0157" num="0156">With this slice, a user may be able to observe the system as it changes over time and observe, in detail, any phase of the program, machine, or hardware device. In this example, behavior may be observed over a period of one second commencing 10 seconds from the start of the application.</p>
<p id="p-0158" num="0157">Then using this new space S&#x2032;, the cost, Scost may be generated:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>SCost={FuncCost(Funcobject(S&#x2032;)),Funcobject(S&#x2032;)}<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0159" num="0158">In this example, Fobject( ) is a user-defined function that returns the aggregate of the related objects, and FCost( ) generates the cost. Note that in this case, the cost is two-dimensional. In other cases, multidimensional costs can be generated.
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>SCost={FuncCost(Func&#x192;unction(S&#x2032;)),FuncCost&#x2032;(S&#x2032;),FuncCost&#x2033;(S&#x2032;), Func&#x192;unction(S&#x2032;)}<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0160" num="0159">In this example, FuncCost&#x2032;( ) and FuncCost&#x2033;( ) may be arbitrary cost functions and the cost, SCost, may be transformed by sorting on any of the dimensions to provide the most insight. For example,
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>SCost={FuncCost(S),Funcsecond(S)}<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0161" num="0160">The data may be presented by FuncCost(S), ordered by the costliest second through the least costly second, or by Funcsecond(S), the execution sequence. Graphical representations of the cost may also provide in-depth insights, in some embodiments. A GUI implementation for the analyzer is described in detail later.</p>
<p id="p-0162" num="0161">Another example of a data selection may be to slice the event space by a single cache line (e.g. the nth set in the cache structure):
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>S&#x2032;={Funccacheline(S)=<i>n</i>&#x2212;1}<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0163" num="0162">Then using this new space S&#x2032;, the cost, Scost may be generated:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>S&#x2032;cost={Funccost(Funcobject(S&#x2032;),Funcobject(S&#x2032;))}<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0164" num="0163">In this example, Funcobject( ) is a user-defined function that returns the aggregate of the related objects, and FuncCost( ) generates the cost. In this case, the cost is two-dimensional. In other cases, multidimensional costs may be generated and these costs may be displayed as multi-colored or moving surfaces in a display, for example</p>
<p id="p-0165" num="0164">The cost, SCost, may be transformed by sorting on any of the dimensions to provide greater insight. For example:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>SCost={Sort(FuncCost(S),Funcsecond(S))}<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0166" num="0165">The data may be ordered primarily by FuncCost(S) and secondarily by Funcsecond(S); that is, from most costly to least costly with ties shown in execution sequence.</p>
<p id="p-0167" num="0166">After an aggregation operation, the costs may be generated from an associated selection that offers further insight, as in this example:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>SCost={FuncCost(FuncVA_by_cacheline(S&#x2032;)), FuncVA_by_cacheline(S&#x2032;)}<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0168" num="0167">The FuncVA_by_cacheline( ) association selector is designed to compare virtual addresses with cache hierarchy structures. It segments the virtual address space by the same alignment and size restrictions as by the cache hierarchy selector. By way of contrast, Funccacheline( ) lacks the address folding effects. FuncVA_by_cacheline( ) and Funccacheline( ) allow the performance analyst to trace virtual addresses to physical addresses to hardware structures and back.</p>
<p id="p-0169" num="0168">The associated operations may allow the observer to infer the characteristics of the virtual address to physical address to hardware structure mapping.</p>
<p id="p-0170" num="0169">For any physically indexed hardware:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>S&#x2032;=Funchardware(FuncPA(FuncVA(S)))<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0171" num="0170">Note that FuncPA( ) may be a complicated mapping operation. The effects of FuncPA( ) may be captured when the event space is created. Later, the properties of the operation FuncPA( ) may be observed by comparing spaces defined by: FuncVA_by_hardware(S) and FuncPA_by_hardware(S). These are the associated operations for the hardware object using either virtual or physical addresses.</p>
<p id="p-0172" num="0171">These association operators may enable the analyst to filter on one object in any of the association operators and then view the costs in the other association operators.</p>
<p id="p-0173" num="0172">Note that these associated mappings may be created to compare two spaces from the viewpoint of any arbitrary dimension. Additional association operators enable the analyst to drill down to processor boards, (e.g., Funcprocessor_board(S)), or memory boards, (e.g., Funcmemory_board(S)).</p>
<p id="p-0174" num="0173">When comparing the spaces produced by these mappings, the profiler may provide insight into whether or not memory references are remote or local to the processor. Set operators may then be applied to determine if an access is local or remote by comparing these association operators:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>Funcremote(S)={Funcprocessor_board(S)&#x2260;Funcmemory_board(S)}<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0175" num="0174">In this example, the Funcremote( ) operation returns the space where processors reference memory on remote memory boards. As noted earlier, this space can be mapped onto any cost space, SCost.</p>
<p id="p-0176" num="0175">As previously noted, the data space profiler architecture may provide various operators to manipulate set elements: bit-wise, arithmetic, comparators, logical, and ternary, in different embodiments. Set operators may also be available: union, intersection, inclusion, terminator, etc. Built-in functions may be used to manipulate data; e.g., to sort the data. The profiler may be readily implemented with in-order processors that support trap-on-overflow performance counters. For systems that lack hardware counters or hardware-based profiling infrastructure to drive sampling, clock events may enable data profiling, in some embodiments. A clock event may generate a Hardware Counter-Typed event representing retire latency. A backtracking mechanism may unwind a single instruction and decode it for a memory operation to create a Memory Sub-System Hardware Counter-Typed event space, S, which has a cost representing memory sub-system time.</p>
<p id="p-0177" num="0176">As noted earlier, a processor's memory subsystem may be viewed as a subspace, in some embodiments. In an exemplary system this might comprise an execution unit, L1 and L2 caches, bus, and memory, although the actual names and architecture are not significant. Cost may be attributed in this subspace as shown in Table 1. Using logic operations, events may be traced to each memory subsystem. By comparing event spaces, the time cost of each memory sub-system component cost may be related to other events, in some embodiments. In other words, latency for specific hardware devices and under which specific conditions they arose may be determined, in some embodiments.</p>
<p id="p-0178" num="0177">As previously noted, the association operator of types in weakly typed languages uses the instruction as an argument:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>re&#x192;Type=Func(PC)<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0179" num="0178">In some embodiments, data type information may be correlated with the instruction in the analysis engine. In some embodiments, data type information may be correlated with the PC, or address of the reference, by the runtime system. For example, a particular data type may in some embodiments be associated with a given memory location. In some embodiments, the compiler may generate a table that associates every instruction's memory reference with an identifier to its data type. During the analyzer's processing, the event set may be joined with the type tables and the result may be merged into the event set as the referenced type (refType).</p>
<p id="p-0180" num="0179">To gain resolution (data density) in specific dimensions, mappings may be applied while building the Event Space, S. For example, if call stacks are not relevant, the Event Space S may be transformed into S&#x2032; at data collection time:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>S={right arrow over (E)}={{right arrow over (PC)},{right arrow over (Cost)},time,VA,PA,CPU,process,thread,re&#x192;Type, . . . }<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>S&#x2032;={right arrow over (E)}&#x2032;={PC,{right arrow over (Cost)},time,VA,PA,CPU,process,thread,re&#x192;Type, . . . }<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0181" num="0180">In this example, data may be aggregated on PC, instead of {right arrow over (PC)}. Specificity in one dimension, call stacks, may be lost, but data density may be gained in the other dimensions by reducing the cost gradient. Data may be sampled more frequently because the data is pre-aggregated.</p>
<p id="p-0182" num="0181">Note that hardware may only need to guarantee the event tuple:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>E={PC,VA,Cost}<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0183" num="0182">However, Cost may be the vector {right arrow over (Cost)}, rather than a scalar. Adding a cost dimension may enable attribution into the event space, S.</p>
<p id="p-0184" num="0183">The memory subsystem of an exemplary large machine is described below. The actual names of the components are not significant; the concept to note is that the memory subsystem may be viewed as a dimension:</p>
<p id="p-0185" num="0184">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="7">
<colspec colname="1" colwidth="35pt" align="left"/>
<colspec colname="2" colwidth="28pt" align="left"/>
<colspec colname="3" colwidth="28pt" align="left"/>
<colspec colname="4" colwidth="35pt" align="left"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="35pt" align="left"/>
<colspec colname="7" colwidth="35pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="7" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>Execution</entry>
<entry>L1</entry>
<entry>L2</entry>
<entry>Bus</entry>
<entry>Bus</entry>
<entry>Bus</entry>
<entry>Memory</entry>
</row>
<row>
<entry>Unit</entry>
<entry>Cache</entry>
<entry>Cache</entry>
<entry>Controller</entry>
<entry/>
<entry>Controller</entry>
</row>
<row>
<entry namest="1" nameend="7" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0186" num="0185">The cost vector may provide attribution into this dimension with hardware that describes which component in the memory sub-system participated in the runtime event. In this example, logical unknown values are represented as X.</p>
<p id="p-0187" num="0186">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="8">
<colspec colname="1" colwidth="28pt" align="left"/>
<colspec colname="2" colwidth="21pt" align="center"/>
<colspec colname="3" colwidth="28pt" align="center"/>
<colspec colname="4" colwidth="28pt" align="center"/>
<colspec colname="5" colwidth="28pt" align="center"/>
<colspec colname="6" colwidth="21pt" align="center"/>
<colspec colname="7" colwidth="28pt" align="center"/>
<colspec colname="8" colwidth="35pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="8" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>Ex-</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
<row>
<entry/>
<entry>ecu-</entry>
<entry/>
<entry/>
<entry>Bus</entry>
<entry/>
<entry>Bus</entry>
</row>
<row>
<entry>Cost</entry>
<entry>tion</entry>
<entry>L1</entry>
<entry>L2</entry>
<entry>Con-</entry>
<entry/>
<entry>Con-</entry>
<entry/>
</row>
<row>
<entry>Type</entry>
<entry>Unit</entry>
<entry>Cache</entry>
<entry>Cache</entry>
<entry>troller</entry>
<entry>Bus</entry>
<entry>troller</entry>
<entry>Memory</entry>
</row>
<row>
<entry namest="1" nameend="8" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>Instr</entry>
<entry>1</entry>
<entry>X</entry>
<entry>X</entry>
<entry>X</entry>
<entry>X</entry>
<entry>X</entry>
<entry>X</entry>
</row>
<row>
<entry>Count</entry>
</row>
<row>
<entry>Memop</entry>
<entry>1</entry>
<entry>1</entry>
<entry>X</entry>
<entry>X</entry>
<entry>X</entry>
<entry>X</entry>
<entry>X</entry>
</row>
<row>
<entry>Count</entry>
</row>
<row>
<entry>L1</entry>
<entry>1</entry>
<entry>1</entry>
<entry>1</entry>
<entry>X</entry>
<entry>X</entry>
<entry>X</entry>
<entry>X</entry>
</row>
<row>
<entry>Cache</entry>
</row>
<row>
<entry>Miss</entry>
</row>
<row>
<entry>L2</entry>
<entry>1</entry>
<entry>1</entry>
<entry>1</entry>
<entry>1</entry>
<entry>1</entry>
<entry>1</entry>
<entry>X</entry>
</row>
<row>
<entry>Cache</entry>
</row>
<row>
<entry>Miss</entry>
</row>
<row>
<entry>Mem</entry>
<entry>1</entry>
<entry>1</entry>
<entry>1</entry>
<entry>1</entry>
<entry>1</entry>
<entry>1</entry>
<entry>1</entry>
</row>
<row>
<entry>Ref</entry>
</row>
<row>
<entry>Cache</entry>
<entry>1</entry>
<entry>1</entry>
<entry>1</entry>
<entry>1</entry>
<entry>1</entry>
<entry>1</entry>
<entry>0</entry>
</row>
<row>
<entry>to</entry>
</row>
<row>
<entry>Cache</entry>
</row>
<row>
<entry namest="1" nameend="8" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0188" num="0187">Note that with logic operations, all events may be attributed to each memory subsystem component that provides a type bit back to the event generating hardware device.</p>
<p id="p-0189" num="0188">Note that spaces may be created for each of these hardware components and compared to spaces for time, in some embodiments.</p>
<p id="p-0190" num="0189">In some embodiments, there may be a requirement to maintain a constant cost gradient. The collection device (e.g., event agents) may cycle through all possible event vectors that are meaningful, or may collapse certain ones at collection, by not attributing those components of the memory sub-system. The collection device may request an event stream with a constant gradient from the hardware for each specific element of {right arrow over (Cost)} that is being cycled through, in some embodiments.</p>
<p id="p-0191" num="0190">In some embodiments, by normalizing the cost gradient via an alternate source, each cost element in {right arrow over (Cost)} may be guaranteed to be constant and the statistical profiling paradigm may be maintained.</p>
<p id="p-0192" num="0191">The event space S may include both time and event cost type. Hardware devices (event agents) may provide a count, c, of the event cost type over time. The event scalar Cost may be normalized by the corresponding</p>
<p id="p-0193" num="0192">
<maths id="MATH-US-00001" num="00001">
<math overflow="scroll">
<mfrac>
  <mrow>
    <mo>&#x2146;</mo>
    <mi>c</mi>
  </mrow>
  <mrow>
    <mo>&#x2146;</mo>
    <mi>t</mi>
  </mrow>
</mfrac>
</math>
</maths>
<br/>
for every element in Event vector, {right arrow over (E)}.
</p>
<p id="p-0194" num="0193">By including more of these devices, more simultaneous attribution may be attained into the cost of the memory sub-system with the event space, S.</p>
<p id="p-0195" num="0194">Note that in the tightly associated tuple, the virtual address, VA, may be just the process identifier (PID) and the address within that PID (PID+address). This address and cost may be arbitrarily descriptive: IPv6 address, port number, etc. A distributed application may thus be profiled.
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>E={PC,address,{right arrow over (Cost)},time}<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0196" num="0195">As previously noted, software may include layers of structures similar to the memory sub-system cache hierarchy and user defined data-types. In some embodiments, a similar approach may be taken to profile the user-specified objects within an application with additional events and cost types, and the associated space definitions.</p>
<p id="p-0197" num="0196">Note that because collection may be distributed and the operations may be implemented in parallel, the profiler may be easily scaled to arbitrarily large applications and arbitrarily large computer systems, for example, those employing the new generation of CMT processors.</p>
<p id="p-0198" num="0197">As discussed above, each member of the event space may be multiple-indexed, i.e., indexed according to each of the multiple data object addresses associated with the event. This is illustrated in <figref idref="DRAWINGS">FIG. 15</figref>. In this example, an event set <b>1510</b> includes multiple events, each including mappings between the cost of the event (c) and the extended address associated with the event (A).</p>
<p id="p-0199" num="0198">The events in the event set, in this example, may be indexed according to the memory board accessed by the event (<b>1560</b>), the structure type of the event (<b>1550</b>), a source line associated with the event (<b>1540</b>), the cache set accesses by the event (<b>1530</b>), and the processor core associated with the event (<b>1520</b>). In this example, each index is dependent on the function defined by the relational agent corresponding to the data object. For example, each event may be associated with a source line index value n, where n is determined by a mathematical function dependent on the source code line number associated with the event. If a relational agent function defining source line index <b>1540</b> is applied to the events in the event space, the value of the source line index <b>1540</b> may be returned for each event, along with the cost of the runtime event associated with the source code line data object.</p>
<p id="p-0200" num="0199">Applying multiple relational agents to the events in the event space may provide filtering and aggregation of the events with respect to one or more data objects and may display data object costs associated with the filtered and aggregated data, in some embodiments. This filtering and aggregation method is analogous to the application of multiple set operation functions and other functions to an event set, as described above.</p>
<p id="h-0013" num="0000">User Model</p>
<p id="p-0201" num="0200">The user model for the data space profiling tools may be thought of as consisting of three steps: compiling the target program, collecting the data, and analyzing the data. These steps are discussed in detail below.</p>
<p id="h-0014" num="0000">Compiling the Target Program</p>
<p id="p-0202" num="0201">The user may compile the target program (i.e., the application to be profiled) just as he or she would for production use, in some embodiments. In some embodiments, command line switches or flags may be set at compilation to enable data space profiling. In some embodiments, these flags may cause changes to the symbolic information recorded with the executable: first, by ensuring that symbolic information about data references are written into the symbol tables; second, by cross-referencing each memory operation with the name of the variable or structure member being referenced; third, by adding information about all instructions that are branch targets; and fourth, by associating each instruction (PC) with a source line number.</p>
<p id="p-0203" num="0202">In some embodiments, enabling data profiling may cause the compiler to suppress optimizations, while in others it may not. When data profiling is enabled, the compiler may change the generated code slightly, in some embodiments. For example, it may add NOP instructions between loads and any joinnodes (labels or branches) to help ensure that a profile event is captured in the same basic block as the triggering instruction. In another example, the compiler may avoid scheduling load or store instructions in branch delay slots. The impact of these modifications on performance may be highly application-dependant, but may be generally minor. For example, the runtime for a particular application, as compiled with profiling enabled, may be approximately 1-2% greater than the runtime of the application compiled without enabling data profiling.</p>
<p id="h-0015" num="0000">Initiating Collection of Profile Data</p>
<p id="p-0204" num="0203">Data collection may be initiated using a collect command, in some embodiments. The collect command may specify data collection parameters along with the target program and any arguments the target program requires. For example, clock and hardware-counter profiling may be specified, independently of or along with tracing of synchronization delays, memory (heap) allocation and deallocation, or MPI messages, in different embodiments. In some embodiments, the result of a collect run (referred to herein as an experiment) may be stored a file-system directory with a log file giving a time-stamped trace of high-level events during the run, a loadobjects file describing the target executable and any shared objects it uses, and additional files, one for each type of data recorded, containing the profile events and the callstacks associated with them.</p>
<p id="p-0205" num="0204">To profile using hardware counters, the collect command may include one or more flags, which may specify one or more counters to be used. In such embodiments, if multiple counters are requested, they may be required to be implemented on different registers. Counters may be specified by name, and an overflow interval may be specified as &#x201c;on&#x201d;, &#x201c;high&#x201d;, or &#x201c;low&#x201d; or as a numerical value. The settings may be chosen to give overflow intervals corresponding to approximately 10 ms., 1 ms., and 100 ms. for the counter named &#x201c;cycles&#x201d;, for example. For other counters, the time corresponding to the overflow value may depend on the program behavior. In some embodiments, the intervals are chosen as prime numbers, to reduce the probability of correlations in the profiles.</p>
<p id="h-0016" num="0000">Event Agents</p>
<p id="p-0206" num="0205">As noted earlier, event agents may be implemented in hardware, in software, or in a combination of hardware and software, according to various embodiments. One example of a hardware event agent is a hardware counter. Modern processors may include one or more hardware counter registers, each of which may count one of a number of events. For example, the members of the UltraSPARC-III&#x2122; family of chips each include two counter registers. In some embodiments, each counter may be preloaded with a value, and when the counter overflows, an interrupt may be generated. The interrupt may be translated by the operating system into a signal delivered to the process being profiled. In some embodiments, when the signal is received by a handler that is part of the data collection system, it may cause a data record to be written by that handler for the event.</p>
<p id="p-0207" num="0206">In various embodiments, hardware counters may be usable for counting cycles, instructions completed, instruction cache (I$) misses, data cache (D$) read misses, data translation lookaside buffer (DTLB) misses, external cache (E$) references, E$ read misses, E$ stall cycles, and other runtime events. Some of the counters may count actual events (i.e., the number of times the particular trigger occurred), but others may count cycles. For example, cache counters that measure in cycles may be especially useful, since they may count the actual time lost because of the events, not just the number of events. The collect command, if run with no arguments, may in some embodiments generate a list of available counters for the machine on which it is run.</p>
<p id="p-0208" num="0207">Each proprietary processor may implement hardware performance counters tailored for its particular architecture, with considerable variation in the number of counters supported, the events counted, whether an interrupt is provided on counter overflow and whether such an interrupt is precise or not, or a detailed history is available for sampled instructions. The Alpha&#x2122; 21264 processor and Pentium&#x2122; 4 processor are examples of processors which provide hardware counter support that may be used in implementing data profiling, as described herein.</p>
<p id="p-0209" num="0208">Some processors employing hardware counters may not always deliver a precise trap when a hardware counter overflows. Since a counter may overflow quite late in the pipeline, the logic to deliver a precise trap may be complex, and may significantly affect the performance of the chip in normal operation. Therefore, the trap signal may be delivered after the event that caused the counter overflow and may arrive quite a bit later.</p>
<p id="p-0210" num="0209">At the time the signal arrives, the program counter value (PC) that is delivered with it may represent the next instruction to issue, which may not be the instruction following the one that caused the counter overflow. The data space profiler may in some embodiments take this &#x201c;skid&#x201d; into account in recording and interpreting the data. The hardware may not capture the address of the data whose reference causes a memory-related counter overflow event, in these cases. Instead, only the register set at the time of the signal delivery may be reported.</p>
<p id="p-0211" num="0210">Therefore, although a PC may be reported when the profile interrupt is delivered, the instruction at the location pointed to by the PC may not be the one triggering the event; that instruction may not yet have been executed. The instruction immediately preceding it in execution may be the one causing the event, but counter skid may add a great deal of uncertainty. To address this problem, the data space profiler may in some embodiments include an apropos backtracking search. In one embodiment, this backtracking search may be specified by the user by pre-pending a &#x201c;+&#x201d; to the name of a memory-related counter used for profiling. If the backtracking search is specified, then during data collection, the event agent may &#x201c;walk back&#x201d; in the address space from the PC reported with the overflow until it finds a memory-reference instruction of the appropriate type. In this example, the actual PC of the instruction causing the event may be called the trigger PC, while the PC determined by apropos backtracking may be referred to as the candidate trigger PC.</p>
<p id="p-0212" num="0211">The first memory reference instruction preceding the PC in address order may not be the first preceding instruction in execution order. In particular, if there is any instruction that is a branch target, there may be no way to determine which path to the PC was taken, so the true trigger PC may not be able to be determined. In some embodiments, it may be too expensive to locate branch targets at data collection time, so the candidate trigger PC may always be recorded, but it may need to be validated during data reduction.</p>
<p id="p-0213" num="0212">Once the event agent has backtracked to find the candidate trigger PC, it may be configured to disassemble the instruction and determine which registers are used to compute the effective address. However, as previously noted, the contents of the registers may have been changed by intervening instructions while the counter is skidding, so that even if the expression to compute the effective address is known, in some embodiments it may not be computable. The event agent may make this determination, and may either report a putative effective address, or may indicate that the address could not be determined. In other embodiments, a method for determining the effective address in these situations may be included in the data space profiler.</p>
<p id="p-0214" num="0213">Some processors may not include hardware performance counters or may not include enough hardware performance counters to capture all of the information desired by an analyst. In some embodiments, a software version of one or more hardware performance counters may be implemented. This event agent may consist of multiple software counters located in machine addressable storage. Each of these counters may be modified based on data collected from a hardware instruction sampling device, in some embodiments. The hardware instruction sampling device may in some embodiments be configured to return instruction sampling information based on a constant instruction rate. Each event packet from the sampling device may be scanned by the event agent. In some embodiments, if the event contains data associated with the counter device, the event agent may increment one of the counters by an amount equal to the instruction rate detected between events. This instruction sampling method may be used in system where no hardware counters are present or to supplement existing hardware counters, in different embodiments. In some embodiments, it may provide libcpc (and cpustat) functionality on systems that lack hardware performance counters and have instruction sampling.</p>
<p id="p-0215" num="0214">In some embodiments, clock-based profiling may be used as a basis of statistical sampling, and may use a fixed count of instructions for backtracking. In such embodiments, the fixed count may be any value (including zero) and may be a processor-specific or chip-specific predetermined number of instructions. In various embodiments, the instruction may be decoded, after being identified through backtracking, and if it includes a memory operation, a memory subsystem packet may be created, similar to those created when using hardware counter based profiling.</p>
<p id="p-0216" num="0215">As described above, a hardware counter mechanism may be used in some embodiments as the basis for statistical sampling. In other embodiments, execution time may be used as an estimate of the cost to attribute to the memory subsystem as a whole. When execution time is used as an estimate of cost attributable to the memory subsystem, an association may be made between execution time and a sampled runtime event, and this association may be included as a code behavior attribute in the event space, in some embodiments. In addition, this association may enable mapping of execution time costs to any data profiling object (e.g., any hardware device, software construct, or data allocation construct involved in a sampled runtime event), when used in conjunction with the data profiling system and method described herein.</p>
<p id="p-0217" num="0216">While the descriptions of runtime events included above primarily involve local runtime events, in some embodiments system-level events, such as cache-to-cache transfers and remote NUMA accesses, may be identified and profiled in much the same manner as local runtime events. In some embodiments, these system events may be the most costly runtime events in a modern multi-processor system. Precisely identifying these system events and associating them with computation objects and storage objects may in some embodiments enable observation, and optimization for these objects (e.g., through page migration or through another reorganization and/or re-allocation of the memory sub-system and hierarchy).</p>
<p id="p-0218" num="0217">In some embodiments, in order to analyze these and other system events, the profiler (e.g., using one or more event agents) may be configured to maintain an identifier between a requesting thread and the request to the system. When the request is satisfied and returned, the source type of the data may be propagated into performance instrumentation for the requesting thread. The event agent may include the conduit between the memory-subsystem and the performance instrumentation. In one embodiment, the source types defined may include: remote memory reference, local memory reference, cache-to-cache transfer, and others.</p>
<p id="p-0219" num="0218">In some embodiments, enabling observability and providing optimization tools with identification of system objects that may cause the most overhead may allow the user or optimization tools to optimize these system objects. Determination of a local or remote object references, as described above, may in some embodiments reduce the computation costs necessary to map memory locations based on operating system tables. This may also enable a quick determination of the volume of data movement, in addition to identification for optimization technologies. For example, this method may allow a user to identify stack pages that are remote to the execution unit and, thus, to enable migration with low overhead.</p>
<p id="p-0220" num="0219">As previously described, there may be many different hardware and/or software events agents employed during data space profiling. For example, some software event agents described earlier may be configured to monitor data movement packets to collect profiling information related to a data movement instruction, such as by capturing and/or computing different portions, or elements, of the extended address associated with the execution of the instruction.</p>
<p id="p-0221" num="0220">As described above, identifying an effective address associated with an event that modifies a source register (for example: <b>1</b>d [r<b>1</b>], r<b>1</b>) may be difficult using conventional profiling methodologies. In some embodiments, the data space profiler described herein may include means to extract the effective address from instructions associated with performance counters. In some embodiments, the method for extracting the effective address includes preventing the retirement of instructions associated with performance counter events. In some embodiments, this method may enable data space profiling on any application without the requirement for recompilation or backtracking. It may also enable data space profiling on kernel code.</p>
<p id="h-0017" num="0000">Analyzing the Profile Data</p>
<p id="p-0222" num="0221">As mentioned above, the result of a data-collection run for one or more software threads being profiled may be referred to as an experiment. In some embodiments, each experiment may be analyzed by an analyzer that includes a GUI program or a command-line equivalent (e.g., one that prints a profiling report based on analysis criteria entered). These two types of implementations may access the same shared-object (i.e., event space repository) to process the data, according to different embodiments.</p>
<p id="p-0223" num="0222">For all experiments, the profiling data collected may be reduced to an annotated representation of the program graph, with performance metrics for each node in the graph, in some embodiments. The nodes may correspond to PCs (i.e., program counter values) and the graph may correspond to the dynamic call graph of the program. The reduced data may be used to show a function list, for example, or to show callers and callees of a function. In some embodiments the data may include information about how the performance metrics are attributed to the callers and callees, and/or to show annotated source or disassembly code of the target.</p>
<p id="p-0224" num="0223">For hardware-counter based experiments, additional data structures may be built corresponding to the data objects referenced by the target. In these embodiments, the node in the program graph may corresponds to an instruction, and, for memory reference instructions, the symbol tables may be used to determine the name (e.g., the virtual address, physical address, or variable name) of the data object being referenced.</p>
<p id="p-0225" num="0224">In order to validate a candidate trigger PC, the data reduction process may first verify that there were no branch targets between the next PC as delivered with the counter overflow signal and the candidate trigger PC determined at data collection time. If there was an intervening branch target, the analysis code may not be able to determine how the code got to the point of the interrupt, and so may not be sure which instruction caused the event. In some embodiments, if this happens, the data analysis tool may insert an artificial branch-target PC, and may attribute the events to that artificial branch target.</p>
<p id="h-0018" num="0000">Relational Agents</p>
<p id="p-0226" num="0225">As previously mentioned, the data space profiler analysis (or OLAP) engine may include relational agents that map addresses (or identifiers) to profiling objects, including physical components and various software constructs. The relational agents map addresses to profiling objects by applying their functions to members of the event set and returning identifiers (addresses) of the events, as specified by their functions. <figref idref="DRAWINGS">FIG. 16</figref> illustrates one embodiment of a method for analyzing the event space by applying a relational agent to the events in the event space and extracting event data corresponding to a particular profiling object.</p>
<p id="p-0227" num="0226">In the example illustrated in <figref idref="DRAWINGS">FIG. 16</figref>, the analyzer may begin by initializing temporary event data lists (e.g., by clearing them, allocating memory for them, setting their values to NULL, etc.), as shown in <b>1610</b>.</p>
<p id="p-0228" num="0227">The analysis engine may then apply a relational agent to a first event in the event space and compute its value using the corresponding relational agent function, as shown in <b>1620</b>. In different embodiments, the relational agent may be a standard relational agent included in all profiling exercises, may be a platform-specific relational agent, or may be a user-specified (custom) relational agent, defining a custom profiling object. As discussed earlier, relational agents may be used to define profiling object identifiers, so that cost data associated with the profiling objects may be extracted from the event space. Some examples of relational agent definitions are listed below:</p>
<p id="p-0229" num="0228">
<tables id="TABLE-US-00003" num="00003">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>obj_define Vaddr VADDR</entry>
</row>
<row>
<entry/>
<entry>obj_define Paddr PADDR</entry>
</row>
<row>
<entry/>
<entry>obj_define Process PID</entry>
</row>
<row>
<entry/>
<entry>obj_define Thread (PID*1000)+THRID</entry>
</row>
<row>
<entry/>
<entry>obj_define ThreadID THRID</entry>
</row>
<row>
<entry/>
<entry>obj_define Seconds (TSTAMP/1000000000)</entry>
</row>
<row>
<entry/>
<entry>obj_define Minutes (TSTAMP/60000000000)</entry>
</row>
<row>
<entry/>
<entry>obj_define L1DataCacheLine (VADDR&#x26;0x1fe0)&#x3e;&#x3e;5</entry>
</row>
<row>
<entry/>
<entry>obj_define L2CacheLine (PADDR&#x26;0x7ffc0)&#x3e;&#x3e;6</entry>
</row>
<row>
<entry/>
<entry>obj_define L3CacheLine (PADDR&#x26;0x7fffc0)&#x3e;&#x3e;6</entry>
</row>
<row>
<entry/>
<entry>obj_define VA_L2 VADDR&#x3e;&#x3e;6</entry>
</row>
<row>
<entry/>
<entry>obj_define VA_L1 VADDR&#x3e;&#x3e;5</entry>
</row>
<row>
<entry/>
<entry>obj_define PA_L1 PADDR&#x3e;&#x3e;5</entry>
</row>
<row>
<entry/>
<entry>obj_define Vpage_32M VADDR&#x3e;&#x3e;25</entry>
</row>
<row>
<entry/>
<entry>obj_define Vpage_256M VADDR&#x3e;&#x3e;28</entry>
</row>
<row>
<entry/>
<entry>obj_define Ppage_32M PADDR&#x3e;&#x3e;25</entry>
</row>
<row>
<entry/>
<entry>obj_define Ppage_256M PADDR&#x3e;&#x3e;28</entry>
</row>
<row>
<entry/>
<entry>obj_define Processor CPUID&#x26;0x1ff</entry>
</row>
<row>
<entry/>
<entry>obj_define Core CPUID&#x26;0x3ff</entry>
</row>
<row>
<entry/>
<entry>obj_define Processor_Board (CPUID&#x26;0x1fc)&#x3e;&#x3e;2</entry>
</row>
<row>
<entry/>
<entry>obj_define CoreID CPUID&#x3e;&#x3e;9</entry>
</row>
<row>
<entry/>
<entry>obj_define Valid ((Error &#x3e; 0)? 0 : 1)</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0230" num="0229">Some of the information needed to compute the value of each of these profiling objects may be captured by event agents during execution (e.g., by monitoring event data packets) or may be requested from the operating system by event agents during execution and data collection. For example, in some embodiments, the values of CPUID, PID, and TSTAMP may be requested of the operating system by event agents during data collection. In other embodiments, these values may be read from a register or memory location by the event agents during data collection. Similarly, the values of VADDR and/or PADDR may be captured by event agents during data collection. The values of some or all of these profiling objects and/or other profiling objects may computed and stored in the event space during analysis, in some embodiments. In other embodiments, some or all of these values may be pre-computed and stored in the event space during data collection or at some point between data collection and analysis.</p>
<p id="p-0231" num="0230">When a relational agent is applied to the first event in the event space, its cost data and profiling object identifier (e.g., the address associated with the profiling object referenced by the relational agent) may be returned to the analysis engine and stored in a temporary data list, as shown in <b>1625</b>. For example, if the analyst (user) requests costs related to the profiling object &#x201c;Processor&#x201d;, the relational agent for the profiling object &#x201c;Processor&#x201d; (defined above) may apply the function CPUID&#x26;0x1ff to the profile data associated with the event (in this case, the CPUID) and may return the profiling object identifier value for Processor that is equal to the CPU identifier value AND-ed with 0x1ff, along with the cost of the event.</p>
<p id="p-0232" num="0231">An aggregation, or binning, may in some embodiments be applied to the data extracted by the relational agent, as shown in <b>1630</b>. For example, event data returned by the relational agent may be grouped with other event data having the same profiling object address, in some embodiments. In other embodiments, event data returned by the relational agent may be grouped by cost, by a range of costs, or by the value or a range of values for another code behavior attribute. In still other embodiments, sorting criteria may be applied to the extracted profile data by the analysis engine before it is presented. For example, sorting criteria may specify that the data be sorted in ascending value order or in descending value order. In another example, sorting criteria may specify an aggregation formula or a number of bins in which to distribute values. Sorting criteria may also specify that sorting should be done based a particular execution cost (e.g., if several cost metrics are to be displayed) or on the values of a particular profiling object identifier for each event. Sorting criteria may be specified using the graphical user interface in various ways in different embodiments. For example, the cost or profiling object on which to sort may be selected by highlighting a column header, selecting a radio button on the display or using other gestures. In another example, the aggregation rules or the number of bins may be selected by choosing an option from a pull-down menu or by entering an expression in a text window. In some embodiments, sorting criteria may be specified in a control file or on a command line, rather than through the GUI.</p>
<p id="p-0233" num="0232">As illustrated in <figref idref="DRAWINGS">FIG. 16</figref>, the analysis engine may apply the relational agent to each of the events in the event space, by repeating the operations shown in blocks <b>1620</b>-<b>1630</b>, until the relational agent has been applied to all events in the event space, as indicated at <b>1635</b>. In some embodiments, if the function for a particular relational agent cannot be computed for a given event (e.g., if the function is undefined for the event or not enough information was captured for the event to allow computation) the relational agent may return a NULL value or a value indicating that the profiling object identifier is unknown. In some embodiments, events returning a NULL or INVALID indication, may not written to the temporary data list for further analysis, while in others, they may be written to the temporary data list along with their NULL or INVALID indicator.</p>
<p id="p-0234" num="0233">Once the relational agent has been applied to all of the events in the event space, the temporary data list may be sorted according to any presentation options specified for the results, as in <b>1640</b>. For example, a default presentation option may specify that events should be sorted in descending cost order before being presented, in one embodiment. In other example, a user may specify in a control file or command line option that events should be sorted in an alphabetical or hierarchical order by their profiling object identifiers (e.g., one of their associated extended address elements). In some embodiments the list may be ordered according to the data associated with individual events, while in others the list may be ordered according to aggregated data, e.g., the aggregated data may be presented by bin.</p>
<p id="p-0235" num="0234">The extracted profile data may be presented graphically in some embodiments, or in other ways in other embodiments, as shown by the decision block <b>1645</b>. In some embodiments, the user may specify the manner in which to present the data in a configuration or control file or by entering a command line option upon invocation of the profiler or analyzer.</p>
<p id="p-0236" num="0235">If the data is not to be presented graphically, the sorted list may be returned to the user by being written to a report file or log file, or may be printed directly from the analyzer, in different embodiments. This is shown in block <b>1650</b>. In some embodiments, the output of the analyzer may be used as an input to an automated optimization process, such as an optimizing compiler or code generator. In other embodiments, a developer may use the results of the profiling exercise to determine changes to the application code, operating system code, system configuration, memory hierarchy, or other system resources in order to optimize the performance of the application being profiled for its target execution platform.</p>
<p id="p-0237" num="0236">If the results of the analysis are to be presented using a graphical interface, the display may be initialized according to initial positional and scaling settings, as in <b>1655</b>. For example, default values for positional settings (e.g., settings specifying which profiling objects, menus, function buttons, etc., to display) may be used for the initial display, in some embodiments. Similarly, a default scaling setting (e.g., specifying the zoom level for the data display) may be applied to the initial display of the results. In other embodiments, the user may specify the initial settings in a control or configuration file or by using a command line option. The initial display of the extracted events may include the corresponding cost data and profiling object identifier(s) of the events in text form (e.g., displayed as a text listing with data for each event on a separate line) or in graphical form (e.g., with cost data displayed in a histogram, and with each cost data value displayed as a separate bar). In some embodiments, the data displayed may be aggregated data. For example, one bar of the histogram may represent the sum of the execution costs for all events accessing a given L2 cache line and, thus, having the same L2cacheline address associated with them. In another embodiment, one bar on a histogram may represent the sum of the costs for the three highest cost event, where or not they correspond to the same profiling object identifier.</p>
<p id="p-0238" num="0237">The amount of aggregation may be dependent on the selected zoom level for the display and/or on aggregation rules applied to the profile data, in various embodiments. These aggregation rules may be specified by the user, in some embodiments, in a control or configuration file, on a command line, or using the graphical user input of the analyzer. In other embodiments, the analyzer may be configured to automatically determine a suitable zoom level and/or aggregation formula dependent on the amount of data to be displayed, the type of data to be displayed, the distribution of data displayed, or using some other criteria.</p>
<p id="p-0239" num="0238">Using the graphical interface, the user may select a particular extracted event on which to perform further analysis, as in <b>1660</b>. In one embodiment, for example, the user may select the profile data entry from the display that is associated with the highest cost for further analysis. In another embodiment, the user may specify a value or range of values for a particular profiling object for further investigation. For example, the user may wish to investigate all events for which the memory stall time was between 10 and 20 seconds and may select these events by highlighting them in the display. In another example, the user may wish to display all events accessing a particular virtual address, and may select an aggregated data entry corresponding to that particular address from the display.</p>
<p id="p-0240" num="0239">Once a particular extracted event, or set of events, is selected, the analysis engine may access the previously sorted data list, as in <b>1665</b>, and may filter the list according to the profiling object identifier value(s) selected, as in <b>1670</b>. In some embodiments, the analysis engine may combine individual entries into one or more aggregated values by cost or by identifier, depending on the sort criteria and/or on one or more current presentation options (e.g., zoom level).</p>
<p id="p-0241" num="0240">Finally, the extracted, sorted, filtered, and aggregated data may be displayed, as in <b>1675</b>. The format, zoom level, and content of the display may again depend on the presentation options selected and any aggregation rules that may be applicable, according to various embodiments.</p>
<p id="p-0242" num="0241">Some embodiments of the data space profiler do not use a graphical interface for presenting profile results at all, while others may provide the user with an option to present the results using a GUI or not. <figref idref="DRAWINGS">FIGS. 17-19</figref> illustrate profiling results presented in tabular form, for example. Although any number of formats may be utilized to present the data gathered and analyzed as previously described, this tabular format may be used to aid in illustrating the described inventions without obscuring the described inventions. The tables illustrated in <figref idref="DRAWINGS">FIGS. 17-19</figref> are exemplary and include example data, according to particular embodiments. In other embodiments, the profile data may be displayed differently. For example, the use of a graphical user interface will be described in detail later. The tables illustrated in <figref idref="DRAWINGS">FIG. 17-19</figref> are provided to aid in understanding the inventions and are not meant to be limiting upon the described inventions.</p>
<p id="p-0243" num="0242"><figref idref="DRAWINGS">FIG. 17</figref> is a table illustrating example profile data, according to one embodiment. In this example, the profile data may reveal an execution hindrance in terms of consumed execution times and may indicate a relationship between the execution hindrance and one or more addresses. In this example, three columns are illustrated. In other embodiments, more or fewer columns of data may be included. In this example, the first column of data indicates the amount of data stall, in seconds. The second column of data indicates corresponding addresses associated with each data stall event. The third column of data indicates the type of address indicated in column two. The first exemplary row in the table indicates the total number of seconds of data stall for the profiled code. The second exemplary row of the table indicates the amount of data stall attributed to the address &#x201c;0x02000640&#x201d;, which is indicated as a physical memory address. In the example illustrated in <figref idref="DRAWINGS">FIG. 17</figref>, the third row indicates the number of data stall seconds attributed to the physical address &#x201c;0x0000720.&#x201d; Another row within the table may indicate a virtual address. In another embodiment, an address column may indicate a tag and an address type column may indicate that the address refers to particular a cache line or cache sub-block, for example.</p>
<p id="p-0244" num="0243"><figref idref="DRAWINGS">FIGS. 18A-18B</figref> are exemplary tables displaying profile data according to different embodiments. In these examples, execution hindrance is indicated in terms of consumed execution times and in relation to source-level data object language constructs. For example, <figref idref="DRAWINGS">FIG. 18A</figref> is an exemplary table of profile data with respect to various source-level data object language constructs, according to one embodiment.</p>
<p id="p-0245" num="0244">The table illustrated in <figref idref="DRAWINGS">FIG. 18A</figref> includes five columns of profile data. Each row of profile data corresponds to a source-level data object language construct indicated in the fifth column of profile data, except for the first row of profile data. The first row indicates an aggregation of profile data for all source-level data object language constructs. The second and third rows of profile data respectively correspond to the source-level data object language constructs TREE and TABLE. The source-level data object language construct TREE is attributed with 166.402 seconds of external cache stall, 59.4% of data external cache read misses, 37.3% of data external cache references, and 70% of DTLB misses. The source-level data object language construct TABLE is attributed with 124.601 seconds of external cache stall, 39.5% of data external cache read misses, 41.4% of data external cache references, and 29.7% of data DTLB misses.</p>
<p id="p-0246" num="0245"><figref idref="DRAWINGS">FIG. 18B</figref> is an exemplary table of profile data with respect to source-level data object language constructs, which represent members of a source-level data object, according to one embodiment. The columns of profile data in <figref idref="DRAWINGS">FIG. 18B</figref> are similar to the columns of profile data in <figref idref="DRAWINGS">FIG. 18A</figref>. In contrast to <figref idref="DRAWINGS">FIG. 18A</figref>, the first row of profile data in <figref idref="DRAWINGS">FIG. 18B</figref> corresponds to all of the sampled runtime events (or execution hindrances) attributed to the source-level data object language construct TREE (an instance of the code behavior attribute of <figref idref="DRAWINGS">FIG. 18A</figref>). The second row of profile data in <figref idref="DRAWINGS">FIG. 18B</figref> corresponds to a particular member of the source-level data object language construct TREE. The particular member is the source-level data object language construct TREE.LEAFS, of data type integer. The source-level data object language construct TREE.LEAFS has been attributed with 29.1 of the 166.402 external cache stall seconds attributed to TREE, 8.2% of the 59.4% of data external cache read misses attributed to TREE, 3.7% of the 37.3% of data external cache references attributed to TREE, and 0.1% of the 70% of data DTLB misses attributed to TREE. The profile data presented in the table of <figref idref="DRAWINGS">FIG. 18B</figref> indicates that the source-level data object TREE is involved with a large percentage of DTLB misses, but that this large percentage is not related to the source-level data object LEAFS, which is a member of the source-level data object TREE. The use of the information presented in <figref idref="DRAWINGS">FIGS. 18A and 18B</figref>, along with other similar data profiling results, may facilitate more efficient optimization of the code then optimization based on traditional profiling, in some embodiments.</p>
<p id="p-0247" num="0246"><figref idref="DRAWINGS">FIGS. 19A-19F</figref> are tables illustrating aggregated and filtered profile data, according to different embodiments. These tables include correlated execution hindrances (observed as external cache stalls) and code behavior attributes, according to different embodiments. <figref idref="DRAWINGS">FIGS. 19A-19C</figref> each illustrate profile data aggregated and filtered by different code behavior attributes. <figref idref="DRAWINGS">FIGS. 19D-19F</figref> illustrate profile data aggregated and filtered by an instance of a first code behavior attribute (time range) and further aggregated by a second code behavior attribute. In <figref idref="DRAWINGS">FIGS. 19A-19C</figref>, a table includes three columns of profile data. The first column of profile data indicates external cache stall time in seconds. The second column of profile data indicates a percentage of cycles spent accessing external cache. The third column of profile data indicates a filter parameter (e.g., source-level data object, function/method, time, etc.). For example, <figref idref="DRAWINGS">FIG. 19A</figref> is an exemplary table illustrating profile data aggregating sampled runtime events by function, according to one embodiment.</p>
<p id="p-0248" num="0247">The table in <figref idref="DRAWINGS">FIG. 19A</figref> identifies profile data for the specified functions STACK_CONTROL and GARBAGE_COLLECT. Each of the rows in the table corresponds to a specified function, except the first row of the table, which indicates profile data from the perspective of all functions of the application being profiled. The second row indicates profile data across the columns from the perspective of the function STACK_CONTROL. The third row of the table indicates profile data across the columns from the perspective of the function GARBAGE_COLLECT. The profile data of the table in <figref idref="DRAWINGS">FIG. 19A</figref> reveals that the function STACK_CONTROL is responsible for the largest amount of stall time of all functions. In this example, the function STACK_CONTROL has caused 39.262 seconds of external cache (E$) stall seconds, or 5.00% of the total 785.235 seconds of E$ stall. The table of <figref idref="DRAWINGS">FIG. 19A</figref> also indicates that the function GARBAGE_COLLECT has caused 38.477 seconds of E$ stall, or 4.9% of the total E$ stall.</p>
<p id="p-0249" num="0248"><figref idref="DRAWINGS">FIG. 19B</figref> is an exemplary table illustrating profile data aggregated by source-level data object language constructs, according to one embodiment. The table in <figref idref="DRAWINGS">FIG. 19B</figref> is similar to the table in <figref idref="DRAWINGS">FIG. 19A</figref>, except that the third column of profile data indicates source-level data object language constructs. The first row of profile data indicates profile data for all source-level data object language constructs in the application being profiled. The second row of profile data indicates profile data for the source-level data object language construct TOS. The third row of profile data indicates profile data for the source-level data object language construct NUM_ENTRIES. The profile data in table <b>19</b>B reveals that the majority of stall caused by source-level data object language constructs corresponds to the source-level data object TOS. The source-level data object language construct TOS is attributed with 117.785 seconds of E$ stall, or 15% of the total E$ stall. The source-level data object language construct NUM_ENTRIES accounts for 94.239 seconds of E$ stall, or 12% of total E$ stall.</p>
<p id="p-0250" num="0249"><figref idref="DRAWINGS">FIG. 19C</figref> is an exemplary table illustrating profile data aggregated by time range, according to one embodiment. The table of <figref idref="DRAWINGS">FIG. 19C</figref> indicates profile data filtered by time range. In this example, 2% of E$ stall cycles persisted for 0-10 seconds, 3% of E$ stall cycles persisted for 10-20 seconds, and 25% of E$ stall cycles persisted for 20-30 seconds. In terms of E$ stall seconds, 15.704 stall seconds are attributable to stalls that persisted within 0-10 seconds, 23.557 stall seconds are attributable to stalls that persisted within 10-20 seconds, and 196.309 stall second are attributable to stalls that persisted within 20-30 seconds.</p>
<p id="p-0251" num="0250"><figref idref="DRAWINGS">FIG. 19D</figref> depicts profile data aggregated and filtered by both time range and function, according to one embodiment. In <figref idref="DRAWINGS">FIG. 19D</figref>, the profile data has been filtered to include only stalls that persisted for 20-30 seconds, and then aggregated by function. In this case, the functions GARBAGE_COLLECT and STACK_CONTROL each contributed stalls of between 20-30 seconds. In this example, the function GARBAGE_COLLECT was attributed with 4% of all E$ stalls or 16% of the stalls that persisted for 20-30 seconds. The function STACK_CONTROL was responsible for 0.75% of all E$ stalls or 3% of the 20-30 second stalls.</p>
<p id="p-0252" num="0251"><figref idref="DRAWINGS">FIG. 19E</figref> depicts profile data filtered by time for the function GARBAGE_COLLECT, according to one embodiment. In this example, a data structure H accessed in the function GARBAGE_COLLECT is responsible for 3.8% of E$ stalls, or 95% of the stalls attributable to the function GARBAGE_COLLECT. The data may be further filtered for finer granularity to determine which aspect of the structure H corresponds to the stalling in GARBAGE_COLLECT, in some embodiments.</p>
<p id="p-0253" num="0252"><figref idref="DRAWINGS">FIG. 19F</figref> depicts profile data filtered by time for the structure H accessed in the function GARBAGE_COLLECT, according to one embodiment. In this example, the table includes statistics for members HEAD, TAIL, and VOLUME for the structure H. The members HEAD, TAIL, and VOLUME respectively correspond to 50%, 0%, and 50% of the stall related to the structure H. In terms of the total E$ stall, the members HEAD, TAIL, and VOLUME relatively correspond to 1.9% (1.49195 seconds), 0% (0 seconds), and 1.9% (1.49195 seconds) of the stall. The table of <figref idref="DRAWINGS">FIG. 19F</figref> also indicates offsets associated with each of the elements of the structure H. Using the profile data filtered by the selected parameters and the offsets, a developer may determine that H.HEAD and H.VOLUME should be put together, for example.</p>
<p id="p-0254" num="0253">In order to facilitate identification of performance bottlenecks and the causes thereof, data space profiler described herein may include means to specify custom filter expressions and to apply them to the event space in order to further filter the profiling objects of interest. This functionality may provide a name space for user-specified mapping of costs to any hardware device and/or any software construct, in some embodiments. The analyzer may in some embodiments implement this functionality using four components: a parser, an expression generator, a token evaluator, and an expression evaluator. The parser may accept code specifying a filter expression entered by a user, such as in a file or through a graphical or command line user interface, according to different embodiments. The language constructs that may be used in custom filter expressions may be defined in a filter language specification, in some embodiments. In one embodiment, the filter language may be defined according a BNF grammar and the parser may be generated using yacc. The parser may first validate the expression, and if the expression is valid, the expression generator may generate a corresponding mathematical representation of expression for use in evaluating the expression as applied to the events in the event space. The parser or the expression generator may also be configured to associate a name with the filter expression, in some embodiments. The mathematical expression may contain scalar and/or vector operators for operating on tokens (e.g., cost data and/or extended address elements or other code behavior attributes associated with the events in the event space), according to various embodiments. Tokens may in some embodiments be generated using Lex.</p>
<p id="p-0255" num="0254">In some embodiments, the expression name corresponding to the custom filter expression may be added to the token space and may be used to build complex expressions for filtering. For example, one custom filter expression named &#x201c;slow_memory&#x201d; may be used to select events for which the memory stall time is greater than 20 seconds:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>(MaxMemStall&#x3e;20)<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0256" num="0255">Using this expression name, another filter expression may be built to further filter the slow_memory events in order to select only those that also meet the criteria &#x201c;L2CacheLine=2805&#x201d; using this expression:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>(slow_memory &#x26; (L2CacheLine IN (2805))<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0257" num="0256">Filter expressions may be specified in terms of various combinations of vector and scalar operations, including set operations. For example, in the filter expression above, the set operator &#x201c;IN&#x201d; indicates that the filter should be used to select only events &#x201c;in&#x201d; the set (i.e., the subset of the event space) in which the L2CacheLine value (address) associated with the events is equal to 2805.</p>
<p id="p-0258" num="0257">The token evaluator may return the values associated with the token name from the events selected by the filter expression, in some embodiments. Returning the values associated with the events selected by the filter criteria may involve providing the profiling object identifier (address) and cost data associated with the selected events. Each filter expression may be evaluated recursively by the expression evaluator, in some embodiments. This may involve evaluating operators and tokens to determine inclusion by the filter, in some embodiments. The use of custom filtering expressions is described later in conjunction with the detailed data space profiling example.</p>
<p id="p-0259" num="0258">In some embodiments, the analysis (OLAP) engine may be configured to manage all bookkeeping of event data and relational information, and to report causal relationships between bottlenecks in physical objects and/or memory allocation and source-level objects. For example, the OLAP engine may be configured to receive event data from multiple repositories (e.g., per-thread or per-address-space repositories), directly from various hardware and software event agents, from operating system calls, etc. The OLAP engine may be configured to build the event space from these inputs and to keep it up to date during execution, data collection, and/or analysis. For example, in some embodiments, analysis may not begin until execution of the application to be profiled is complete, but in other embodiments, execution may continue during analysis, with or without additional data collection being performed. In some such embodiments, the OLAP engine may be configured to update or refresh the event space periodically or when explicitly requested to do so by the user.</p>
<p id="p-0260" num="0259">In some embodiments, the event space may be implemented as a series of tables or as collection of linked lists. In other embodiments, the event space may be implemented in a database, such as an Oracle&#x2122; relational database. The OLAP engine may in some embodiments be configured to manage these tables, lists, or databases in order to maintain the relational information contained therein and to extract cost and other profile data therefrom, according to various relational agents and filters applied to the profile data in the event space. The OLAP engine may also be configured to maintain a list of relational agents, in some embodiments, while in others, lists of relational agents may be distributed between multiple hardware components or software modules of the data space profiler. In some embodiments, such as in various Java&#x2122; implementations, relational agents may be dynamically generated and applied, while in other embodiments (such as in various C implementations) relational agents may be static functions compiled once and then used later to build the event space.</p>
<p id="p-0261" num="0260"><figref idref="DRAWINGS">FIG. 20</figref> illustrates an exemplary method for preparing for analysis, which includes building the event space, according to one embodiment. In this example, the analysis engine may first load any &#x201c;out of band&#x201d; relational agents, i.e., any platform-specific or user-specified relational agents that are not built into the standard profiler. This is illustrated at <b>2010</b>. If a graphical user interface is included in the analysis engine, the presentation options for scaling and positioning of the initial display may be initialized, as in <b>2015</b>. As described earlier, these options may in some embodiments be specified in a control file, by the user as a command line option, or as defaults settings of the analyzer.</p>
<p id="p-0262" num="0261">The analysis engine may begin building the event space by identifying an event data repository from which to import event data, as in <b>2020</b>. As previously noted, event data repositories may be allocated and populated on a per-thread or per-address-space basis, in some embodiments.</p>
<p id="p-0263" num="0262">The analysis engine may read data associated with a first event in the first identified repository, as in <b>2025</b>. If all of the relational information for the event is included (e.g., the extended address is completely specified and the cost is included), the analysis engine may proceed from <b>2030</b> to <b>2040</b>. If not all of the relational information is included in the data set for the event, one or more relational agents may be accessed (i.e., loaded) and applied to the data that is included with the event record. In some embodiments, applying one or more relational agents to the data retrieved from the first repository may result in the remaining relational information being computed and the data associated with the event to be completely filled in. In some embodiments, not all elements of the extended address may be relevant or applicable to a given event. In such embodiments, the analysis engine may be configured to enter a NULL or INVALID value into the corresponding address field for the event. In some embodiments, after applying one or more relational agents to the data retrieved from the repository, some information may still be missing. In some embodiments, the analysis engine may be configured to access other event data records in order to determine the remaining values to be associated with the extended address of the event in question. The analysis engine may be configured to recursively compute values for the fields associated with the additional events and then to apply the results of those relationships in determining values for the remaining address fields of the event in question.</p>
<p id="p-0264" num="0263">In one example, a runtime event may represent a cache miss associated with a known (i.e., captured) PC value, VA, and PA. The PC value may translate to a function foo. If the extended address element values for function foo have already been loaded into the event space, they may be filled in for the cache miss event of interest. If they have not yet been loaded, the analysis engine may be configured to locate these values elsewhere (e.g., in an event data repository) and to load the appropriate values into the event space for the cache miss event. In some embodiments, the analysis engine may access an event data table entry for foo to extract some of the extended address element values, such as a data type associated with the function. Recursively loading event data from a series of event data tables may be implemented as a join function for different forks of a file system.</p>
<p id="p-0265" num="0264">At decision block <b>2040</b>, if there are more events to be imported, the analysis engine may be configured to repeat the operations illustrated in blocks <b>2025</b>-<b>2035</b> until all events in the first repository have been imported and the relational information for each has been loaded into the event space. At decision block <b>2045</b>, if it is determined that there are more repositories from which to import data, the analysis engine may be configured to repeat the operations illustrated in blocks <b>2020</b>-<b>2040</b>, until all the data from the relevant repositories has been imported and the relational information for each has been loaded into the event space.</p>
<p id="p-0266" num="0265">While in this example, the event space is built from multiple event data repositories sequentially, in other embodiments the event space may be built from multiple event data repositories in parallel. For example, the build process may spawn different threads, each of which may build a portion of the event space from a separate per-address-space event data repository.</p>
<p id="p-0267" num="0266">Once the event space has been populated, the analyzer may be configured to initialize any filters and displays, and to present initial results of the profiling exercise, such as by displaying the costs associated with each function of the application being profiled. This is illustrated in block <b>2050</b>. In some embodiments, the initial results displayed may always include the costs in view of each function, which may be a default result. In other embodiments, the user may specify the initial results to display using a control file, command line option, or other means. Similarly, as previously noted, initial presentation settings may be based on default values, user-specified values, or on the data to be displayed, in various embodiments. For example, the analyzer may be configured to initially display cost in view of the application's functions, and aggregated (binned) according to a zoom level that allows all of the data to be presented at once using a default number of bins.</p>
<p id="h-0019" num="0000">Graphical User Interface</p>
<p id="p-0268" num="0267">The data space profiling analyzer may in some embodiments include a graphical user interface, which may facilitate identification of asymmetric resource utilization and identification of the cause thereof. The flow chart of <figref idref="DRAWINGS">FIG. 21</figref> illustrates an exemplary method of identifying an asymmetric resource utilization and its cause, according to one embodiment.</p>
<p id="p-0269" num="0268">In this example, the user (analyst) may select a profiling object to display, as in <b>2110</b>. For example, the user may choose to display cost as related to the functions of an application. The user may select the object to display by selecting one of several tabs above a main data display window, in some embodiments. In such embodiments, each tab may correspond to a profiling object that may be viewed. In some embodiments, not all profiling objects may have associated tabs. For example, the user may be able to select which profiling objects to display and the analyzer may provide tabs only for those selected profiling objects.</p>
<p id="p-0270" num="0269">After the user selects a profiling object to display, the analysis engine may be configured to apply the corresponding relational agent to extract cost data and corresponding profiling object identifiers from the event space, as described earlier, and to display the extracted data. This is illustrated in block <b>2115</b>. As described earlier, the data may be displayed in various formats, including text formats (e.g., one or more lists or tables) and graphical formats (e.g., bar graphs or histograms) and may be ordered and/or aggregated according to current presentation options and/or aggregation guidelines.</p>
<p id="p-0271" num="0270">At block <b>2120</b>, the user may observe an asymmetric utilization of the profiling object being displayed. For example, if the cost of each function (represented by memory stall time) is being displayed, the user may detect that one of the functions is responsible for an inordinately large percentage of the total memory stall time of the application by observing the data in a histogram. If such an asymmetric utilization is detected, the user may investigate further in order to determine the cause. At <b>2140</b>, for example, the user may determine if the currently displayed profiling object is the cause of the observed performance bottleneck. For example, the memory stall time of each instance of the function associated with the largest cost may not be inordinately long compared to the memory stall time of other functions, but the number of instantiations of the function may be very large. Thus, the performance bottleneck may not be due to a data motion issue, but may be an artifact of repeatedly calling an otherwise efficient software function.</p>
<p id="p-0272" num="0271">If it is determined that the currently displayed profiling object is not the cause of the observed performance bottleneck, the user may filter on the object identifier associated with the observed bottleneck (e.g., the function name), as in block <b>2145</b>. The user may then determine if another profiling object view is available that might facilitate identification of the cause of the performance bottleneck, as in block <b>2150</b>. If another profiling object view is available, the user may repeat the operations illustrated in blocks <b>2110</b>-<b>2045</b> until the cause is identified, as indicated by the positive exit from decision block <b>2140</b>, or until there are no additional profiling objects to display, as in <b>2155</b>.</p>
<p id="p-0273" num="0272">If, at any time, the cause of the observed performance bottleneck is identified, the user may optimize the application, platform configuration, memory hierarchy, or other hardware and/or software components to correct or avoid the bottleneck, as in <b>2170</b>. In some embodiments, the user may attempt to correct the bottleneck and may re-run the profiling exercise, collecting a new profiling data set and analyzing the results, in order to verify that a correction was successfully implemented.</p>
<p id="h-0020" num="0000">Data Profiling Example Using Graphical User Interface</p>
<p id="p-0274" num="0273">As described above, a graphical user interface (GUI) for data space profiling may in some embodiments provide insights into understanding complex performance issues and problems. This GUI may be a component of the data space profiling analyzer, or may be a separate application for displaying data returned from the data analysis engine, in different embodiments. The GUI may support arbitrarily large profile data sets, without losing resolution of a sparse bottleneck. For example, when displaying a virtual address map address of a process, it may be possible to easily identify a hot virtual address causing a scaling bottleneck by using various sorting, aggregation, and presentation options available through the GUI, whereas it may be difficult to identify a hot virtual address by looking at many hundreds or thousands of individual data values in a histogram or printed list of individual cost values. In some embodiments, artificial intelligence may be used to facilitate data presentation and/or identification of asymmetric object utilizations. In one example, the analysis engine may be configured to pre-compute one or more cost metrics and to determine exceptional values (outliers) in the set.</p>
<p id="p-0275" num="0274">The GUI may, in some embodiments, include three main components for effectively presenting profile data: a display component which can pan values, a &#x201c;zoom-in&#x201d; and &#x201c;zoom-out&#x201d; apparatus which modifies the density of the display, and a sorting apparatus which selects from a histogram view or an object order display view, and sorts the data appropriately for display in that format. In some embodiments, the display component may group the data in aggregate form, providing buckets or bins from which to form the displayed values. The display component may include scroll bars to pan across the objects being displayed, i.e., to select different data profiling objects to display. The &#x201c;zoom-in&#x201d; and &#x201c;zoom-out&#x201d; apparatus may change the aggregation function for the displayed objects, in some embodiments. A default formula or user-specified formula may be used to determine how the data is aggregated according to the zoom level. The sorting apparatus may change the group order for the aggregation objects, in some embodiments. For example, in some embodiments when grouping data in cost order the GUI may provide a histogram, while when grouping data in object order it may provide an ordered list of data (in a tabular, text-based format) in which each line includes an object description (e.g., specifying the cache line). The GUI described herein may allow zooming and panning in a graphical environment across multiple profiling object views of profile data for a profiled application, and may present the data according to specified presentation and profiling object selections independent of metrics and costs. For example, in some embodiments the GUI may be configured to present cost data on a vertical axis no matter what profiling objects and/or metrics are selected for display. Graphical navigation of the multi-dimensional event space, as described herein, may in some embodiments facilitate a &#x201c;Look, filter, and look again&#x201d; approach to data space profiling.</p>
<p id="p-0276" num="0275">The data space profiler and graphical user interface described herein may in some embodiments facilitate identifying an asymmetric, exceptional, or otherwise unsatisfactory resource utilization or resource bottleneck that may hinder performance. The data space profiler and GUI may also facilitate identifying a cause of an observed performance bottleneck. <figref idref="DRAWINGS">FIGS. 22A-22P</figref> illustrate the use of a data space profiler, and graphical user interface thereof, to identify a performance bottleneck and its cause, according to one embodiment.</p>
<p id="p-0277" num="0276">In this example, the &#x201c;analyze&#x201d; command may be invoked, bringing up a graphical interface for analyzing the profile data collected during execution of a software application. In this example, the default configuration for the first displayed window may be a function-based view of the profile data, as in <figref idref="DRAWINGS">FIG. 22A</figref>. <figref idref="DRAWINGS">FIGS. 22A-22P</figref> illustrate simulated screen shots of various windows displayed during use of the data space profiler, according to one embodiment. In this example, <figref idref="DRAWINGS">FIG. 22A</figref> illustrates a main data display window <b>2210</b> in which profile data is displayed, and a series of tabs <b>2220</b>. Each tab <b>2220</b> corresponds to a data profiling object for which costs may be displayed. In this example, costs may be displayed by function, data structure (e.g., by data array or data array element), by 8K virtual page, by 8K physical page, by L1 cache line, by L2 cache line, by core, etc. In other examples and other embodiments, more, fewer, or different data profiling objects may be selected, as described herein. In some embodiments, not all profiling object tabs may be visible at the same time. In such embodiments, the user may be able to pan or scroll the tab display across the top of the main display window in order to view more or different profiling object tabs from which to make a selection for display.</p>
<p id="p-0278" num="0277">In the example illustrated in <figref idref="DRAWINGS">FIG. 22A</figref>, the &#x201c;function&#x201d; tab has been selected. Therefore, the data display window <b>2210</b> displays cost data by function. In this example, the cost data is presented in terms of CPU execution time and memory stall time. In some embodiments, the default or initial display presented by the analyzer may include displaying cost data in terms of CPU time and/or memory stall time, while in other embodiments, a different display may be the default display or a user may specify initial display options when invoking the analyzer, such as through a configuration file or one or more command line options. Similarly, in some embodiments displaying cost in terms of an application's functions may be a default condition of the analyzer, while in others the default display may include a different data profiling object view or the user may specify the initial data profiling object view to display.</p>
<p id="p-0279" num="0278">In the example shown in <figref idref="DRAWINGS">FIG. 22A</figref>, data display window <b>2210</b> displays profile data in 3 columns with each column having a heading at the top of the column. In this example, the data in the first column represents CPU time for each function of the application (in seconds). The data in the second column represents the memory stall time (in seconds) incurred during execution of each function. The third column displays the name of each function, task, or other programming structure of the application being profiled. Therefore, in this example, each line of profile data displayed in the data display window corresponds to the costs, in terms of CPU time and memory stall time, of one function, task, or other programming structure of the application being profiled.</p>
<p id="p-0280" num="0279">In the example illustrated by <figref idref="DRAWINGS">FIG. 22A</figref>, the total memory stall time for the application being profiled is 24,834.612 seconds. Portions of this stall time are attributable to many different functions, as shown in data display window <b>2210</b>. For example, the function function4 accounts for 6,785.927 seconds of the total stall time, and the function function2 accounts for 4,396.145 seconds of stall time. The data displayed in <figref idref="DRAWINGS">FIG. 22A</figref> may or may not help a user identify any bottlenecks causing memory stall in this application.</p>
<p id="p-0281" num="0280">To continue looking for bottlenecks, a user may choose to display a different view of the cost data for the application. In this example, the user may suspect that cache misses may be contributing to the stall time, and may choose to view costs by L2 cache line. To view the cost data by cache line, the user may select the L2CacheLine tab (e.g., by moving a cursor, using a mouse, etc.).</p>
<p id="p-0282" num="0281"><figref idref="DRAWINGS">FIG. 22B</figref> illustrates a display of cost data in terms of memory stall time for each line of the L2 cache, such as may be displayed following the selections described above, in some embodiments. In this example, the memory stall time is presented for each line of the L2 cache in seconds and as a percentage of the total stall time for the application. As shown in <figref idref="DRAWINGS">FIG. 22B</figref>, 21.89% of the memory stall time is attributable to a single cache line, in this case, L2_CacheLine Memory Object <b>2697</b>. This data may in some embodiments indicate a bottleneck hindering execution.</p>
<p id="p-0283" num="0282">Note that in <figref idref="DRAWINGS">FIG. 22B</figref>, the current display mode is a text mode, as indicated by radio buttons <b>2215</b>. In some embodiments, the user may choose to display profile data in either a text mode or a graphical mode. In some embodiments, the profile data may be ordered differently, depending on the presentation mode. For example, profile data may be displayed in order of cost (e.g., ascending or descending cost) in a graphical mode, but may be displayed in order of object (e.g., ascending or descending order of object name) in a text mode. In other embodiments, profile data may always be displayed in cost order or always in object order. In still other embodiments, a user may specify the display order in a configuration file or may change the display order during analysis, such as by selecting a column header in the data display window and/or an indicator of ascending or descending order. In <figref idref="DRAWINGS">FIG. 22B</figref>, for example, data is presented in a text format and in a descending cost order.</p>
<p id="p-0284" num="0283">In this example, the user may choose to display the profile data in a graphical mode next. In some embodiments, such as the one illustrated in <figref idref="DRAWINGS">FIG. 22B</figref>, the user may switch between a text mode and a graphical mode by selecting a radio button <b>2215</b> of the display. <figref idref="DRAWINGS">FIG. 22C</figref>, for example, illustrates memory stall time (as a percentage of the total memory stall time for the application), by L2 cache line, in a graphical format. In this example, data for all cache lines is not displayed individually, but is aggregated according to the scaling option (i.e., the zoom level) selected. In some embodiments, there may be a default zoom level for the analyzer, while in other embodiments, an initial zoom level for a graphical display may be determined by the analyzer at run time (e.g., based on the amount and range of data to be displayed), may be specified in a configuration file, or may be selected by a user at run time (e.g., using a command line option.) In some embodiments, the user may change the zoom level in order to get a closer look at the data or to better observe trends, patterns, or the &#x201c;big picture&#x201d; illustrated by the profile data.</p>
<p id="p-0285" num="0284">In some embodiments, such as the one illustrated in <figref idref="DRAWINGS">FIG. 22C</figref>, the user may change the zoom level by selecting zoom-in, zoom-out, minimum zoom level, or maximum zoom level radio buttons <b>2225</b>. In other embodiments, the zoom level may be selected by other means, such as using other graphical input means or by entering a command on a command line interface. Zooming in and zooming out of a profile data display window may in some embodiments change the way data is aggregated and/or presented, in some embodiments. For example, with arbitrarily large data sets, a graphical display may easily lose resolution of a sparse bottleneck, e.g. when displaying a large number of cost values, where only a small number of them cause an execution bottleneck. In some embodiments, the analyzer may be configured to modify the density of the display according to the current zoom level and to change the aggregation function for the displayed objects. For example, if the maximum zoom level is selected, the analyzer may, in some embodiments, display profile data values individually in data display window <b>2210</b>, although not all of the data may be visible at one time. In this example, the user may be able to observe all of the data values by panning across data display window <b>2210</b> using a scroll button, a mouse, etc. In another example, if the minimum zoom level is selected, the analysis engine may be configured to aggregate and display the data so that all of the data may be displayed in data display window <b>2210</b> at the same time, with a standard number of bins (e.g., the values corresponding to 40 bins may be displayed, evenly distributed across data display window <b>2210</b>, and the data may be aggregated into those 40 bins in descending cost order or in another order specified by the user.) In some embodiments, all bin values may be displayed, while in others only non-empty bins are displayed.</p>
<p id="p-0286" num="0285">If the selected zoom level is other than the minimum or maximum zoom level, the analysis engine may be configured to combine two or more profile data values into each of one or more groupings, or bins, and display a single profile data value for each grouping. In such embodiments, the number of groupings may be dependent on the selected zoom level and the number of data values to be displayed. The single profile data value displayed for each grouping may be determined according to different formulas, in different embodiments. For example, the aggregated value may represent a sum of the two or more profile data values, an average of the two or more profile data values, a logarithmic aggregation, a standard deviation for the profile data values, a median of the two or more profile data values, etc. In some embodiments, a default aggregation formula may be used, while in others a user-specified formula (e.g., one specified in a configuration file or input through a graphical or command-line interface) may be used.</p>
<p id="p-0287" num="0286">An example of a zoom-in function that changes the aggregation and display of profile data is illustrated in <figref idref="DRAWINGS">FIGS. 22C and 22D</figref>. In this example, each data value displayed in <figref idref="DRAWINGS">FIG. 22C</figref> may be an aggregation of two or more profile data values that were combined into a &#x201c;bin&#x201d; before being presented. For example, the data displayed for bin <b>1</b>, indicated by the first bar on the left, may represent the sum or average of two or more individual profile data values. By selecting the zoom-in function radio button, the user may choose to display the data according to a new zoom level, as illustrated in <figref idref="DRAWINGS">FIG. 22D</figref>. In this example, each bar displayed in data display window <b>2210</b> of <figref idref="DRAWINGS">FIG. 22D</figref> may correspond to a single profile data value. In other words, each bin may contain data for a single data profiling object. In this example, the bar on the far left may represent L2 cache line memory object <b>2697</b>, which is associated with 21.89% of the total memory stall time of the application.</p>
<p id="p-0288" num="0287">Note that in <figref idref="DRAWINGS">FIGS. 22C and 22D</figref>, the cost data represents the memory stall time attributable to L2 cache lines as a percentage of the total stall time for the profiled application. In <figref idref="DRAWINGS">FIG. 22A</figref>, cost data was presented in terms of CPU time in seconds and memory stall time in seconds. In <figref idref="DRAWINGS">FIG. 22B</figref>, memory stall time was presented in terms of both seconds and as a percentage of total stall time. If other tabs illustrated in <figref idref="DRAWINGS">FIGS. 22A-22P</figref> are selected, cost data would be presented in view of the profiling objects referenced by those tabs (e.g., as attributable to each process, thread, etc.). In different embodiments, different profiling tabs may be selected for display, based on the available data profiling object data in the event space.</p>
<p id="p-0289" num="0288">In some embodiments, the user may select the manner in which cost data is presented during analysis. In the example illustrated by <figref idref="DRAWINGS">FIGS. 22A-22P</figref>, the user may invoke a &#x201c;presentation options&#x201d; function, which may be used to specify presentation options. In this example, this function is selected using one of the radios buttons, presentation options function <b>2235</b>, illustrated in <figref idref="DRAWINGS">FIG. 22D</figref>. In some embodiments, invoking this function may cause another window and corresponding set of tabs to be displayed, and each tab of the second window may represent different attributes of the presentation that may be configured by the user.</p>
<p id="p-0290" num="0289"><figref idref="DRAWINGS">FIG. 22E</figref> illustrates one window that may be displayed when the presentation options function is invoked, in one embodiment. In this example, the &#x201c;metrics&#x201d; tab has been selected and the user may select the cost metrics to be displayed. In this example, &#x201c;Max. Mem. Stall&#x201d; has been selected and both &#x201c;time value&#x201d; and &#x201c;%&#x201d; have been selected. If these selections are applied to the profiling data, the display in data display window <b>2210</b> may resemble that illustrated in <figref idref="DRAWINGS">FIG. 22B</figref>.</p>
<p id="p-0291" num="0290">In order to look for a cause for the large contribution to memory stall time of the single L2 cache line memory object <b>2697</b>, the user may filter the profile data in the event set to focus in on this single L2 cache line. To that end, <figref idref="DRAWINGS">FIG. 22F</figref> illustrates the selection of the cost data corresponding to L2 cache line memory object <b>2697</b> and the invocation of the &#x201c;filter clause&#x201d; function radio button. When these two elements are selected, the analyzer may display a window in which a user may specify a filter clause for the profile data, as shown in <figref idref="DRAWINGS">FIG. 22G</figref>. In this example, filter clause window <b>2265</b> may be pre-loaded according to the data selected in the previous display. In this case, the filter clause is pre-loaded with &#x201c;L2Cacheline IN 2697&#x201d; because the L2CacheLine Memory Object <b>2697</b> entry was selected in the previous display. <figref idref="DRAWINGS">FIG. 22H</figref> illustrates an example data display resulting from applying this filter to the profile data set. In this example, only the data corresponding to L2 cache line <b>2697</b> is displayed. Therefore, as shown, 100% of the memory stall time being investigated is attributable to this cache line. In some embodiments, when a filter has been applied to profile data, the applied filter expression may be displayed along with the filtered data in the same window or in a separate window displayed at the same time as the data display window (not shown).</p>
<p id="p-0292" num="0291">In some embodiments, a user may add additional criteria to the pre-loaded filter clause, such as by selecting other data profiling objects or code behavior attributes, specifying a value or range of values (e.g., specifying a start value and an end value) for one or more data profiling objects or code behavior attributes, applying a set operator to one or more data profiling objects, etc. This will be described in more detail later.</p>
<p id="p-0293" num="0292">In this example, the information displayed so far may not be enough to determine the cause of the large memory stall time attributable to L2 cache line <b>2697</b>. Therefore, a user may choose to display cost data associated with other data profiling objects with respect to this cache line. For example, a user may select a &#x201c;core&#x201d; view of the profile data associated with this cache line, as shown in <figref idref="DRAWINGS">FIG. 22H</figref>. In this example, the results of this selection are illustrated in <figref idref="DRAWINGS">FIG. 22I</figref>. <figref idref="DRAWINGS">FIG. 22I</figref> illustrates that eight cores, each represented by its &#x201c;address&#x201d;, access L2 cache line <b>2697</b> during the execution of the profiled application. In this example, accesses of this cache line by each of the eight cores contribute roughly equally to the total stall time attributable to the cache line.</p>
<p id="p-0294" num="0293">Another profiling object view that may be useful for determining a cause of the observed bottleneck, in this example, is a view of the virtual address mapping or mappings for the L2 cache line in question. The VA_L2 tab may be selected, as shown in <figref idref="DRAWINGS">FIG. 22I</figref>, with the resulting display illustrated in <figref idref="DRAWINGS">FIG. 22J</figref>. <figref idref="DRAWINGS">FIG. 22J</figref> illustrates a display of the memory stall time attributable to each virtual address mapping to L2 cache line memory object <b>2697</b>. As shown in <figref idref="DRAWINGS">FIG. 22J</figref>, one virtual address mapping is associated with almost all of the stall time attributable to this L2 cache line.</p>
<p id="p-0295" num="0294">Using the filter clause function, the user may focus in on the one virtual address mapping at the root of the observed bottleneck. <figref idref="DRAWINGS">FIG. 22K</figref> illustrates the filter clause window <b>2265</b> pre-loaded with the previously selected filter in the data display window &#x201c;L2CacheLine IN (2697)&#x201d; and the newly selected filter clause element &#x201c;VA_L2 IN (288230376116256393)&#x201d; in the specify filter window <b>2275</b>. By choosing the set operator &#x201c;AND&#x201d; from the set operator radio buttons of the display, the user may construct a filter expression for the profile data of interest. This filter expression is shown in <figref idref="DRAWINGS">FIG. 22L</figref>, as &#x201c;((L2CacheLine IN (2697)) &#x26;&#x26; (VA_L2 IN (288230376116256393))&#x201d;. The analysis engine may apply this filter to the profile data resulting in the display illustrated by <figref idref="DRAWINGS">FIG. 22M</figref>, which depicts the cost (memory stall time) for only this combination of data profiling object identifiers and/or code behavior attribute values.</p>
<p id="p-0296" num="0295">Note that the relational agents return a different extended address element for each runtime event dependent on the profiling object from whose perspective the costs are extracted. Filter criteria, on the other hand, determine a sub-set of the event data for which to display this extended address element, in some embodiments.</p>
<p id="p-0297" num="0296">In order to determine if the single virtual address mapping corresponds to one physical memory location or multiple locations, the user may wish to view the profile data with respect to the physical address(es) associated with this virtual address. In some embodiments, the physical address for the L2 cache line may one of the profiling objects defined and selectable using one of the tabs in the analyzer display. In other embodiments, the user may be able to view this information by constructing a custom profiling object during analysis. In this example, the user may invoke the presentation options function and select the &#x201c;tabs&#x201d; tab, bringing up a window in which profiling objects may be selected for display. This window is illustrated in <figref idref="DRAWINGS">FIG. 22N</figref>. As shown in this example, different types of profiling objects may be selected for display in the analyzer GUI. For example, some profiling objects may be built-in profiling objects, standard in any instantiation of the analyzer, in some embodiments. These may include the profiling objects on the left side of the window, such as &#x201c;Functions&#x201d;, &#x201c;Callers-Callees&#x201d;, &#x201c;Source&#x201d;, etc. Other profiling objects may be specific to a particular system configuration, processor, operating system, or compiled application, in some embodiments. These may include profiling objects similar to those depicted on the right side of the window, such as Vpage<sub>&#x2014;</sub>8K, L2CacheLine, Core, etc. As shown in this example, data profiling objects may correspond to hardware elements of the system, such as cores, registers, or memory boards, or may correspond to elements in the programming view of the system, such as functions, threads, data segments, etc. Each of these data profiling objects corresponds to a relational agent (function) mapping the profiling object name to a formula for calculating its identifier, or address, according to various embodiments. In some embodiments, relational agents for custom profiling objects may be specified in a control file or included in an event data repository and loaded at invocation of the analyzer, rather than being specified during analysis.</p>
<p id="p-0298" num="0297">In some embodiments, the analysis engine may be configured to compute costs that are impractical or impossible to capture in hardware, but that may be extremely useful for performance analysis. For example, as threads are increased in a computer system, it may be useful to know how cycles-per-instruction increase for instructions that reference frequently accessed cache lines. In some embodiments, the analyzer may allow profiling of any hardware device that is address-indexed, and any software construct, via user-specified cost metrics. For example, the analyzer may include means to profile cache lines by the cost of cycles-per-instruction for instructions accessing the cache line by specifying what cost is requested for the hardware device or software construct.</p>
<p id="p-0299" num="0298">In order to compute user-specified cost metrics, the analyzer may include a parser and an expression evaluator, in some embodiments. A language description may specify names for computed costs and expressions for computing names and intrinsic cost metrics. In some embodiments, specifying a user-defined cost metric may involve defining a custom profiling object in terms of available cost metrics and/or other code behavior attributes (e.g., values of other profiling objects) and filtering the event data so that costs associated with the custom profiling object may be displayed. One example of the use of a custom profiling object in data space profiling is described below.</p>
<p id="p-0300" num="0299">As shown in <figref idref="DRAWINGS">FIG. 22N</figref>, custom profiling objects may be added to the list of profiling objects to be displayed, in some embodiments. In such embodiments, a new custom profiling object may be defined as a function of one or more already available profiling objects. Invoking the &#x201c;add custom object&#x201d; function may cause the analyzer to open a window in which a user may define a custom object, in some embodiments. In the example involving an identified bottleneck of L2 cache line <b>2697</b>, as mapped to virtual address 288230376116256393, the user may wish to view the physical address(es) mapped to this virtual address to get a better understanding of the bottleneck. In this example, a custom relational agent (function) may be defined to map the profiling object name PA_L2 (i.e., physical address grouping of an L2 cache line) to a formula for computing physical addresses for each cache line from the physical addresses previously captured by the event agents. In this example, the physical address mapped to each L2 cache line is the physical address shifted by 6. This formula may be based on the particular system configuration being profiled and in some embodiments may be different for different systems on which the same application may be profiled. For this example, the user may enter the object name PA_L2 and the formula (PADDR&#x3e;&#x3e;6) in the custom object creation window illustrated in <figref idref="DRAWINGS">FIG. 22O</figref> to create the desired custom data profiling object.</p>
<p id="p-0301" num="0300">As a result of defining the custom profiling object, a new tab labeled PA_L2 may be displayed by the analyzer, in some embodiments. This is shown in <figref idref="DRAWINGS">FIG. 22P</figref>. In some embodiments, creating a new custom object may cause the analysis engine to automatically calculate values for the new profiling object for each of the events in the event set for which the new profiling object is relevant (i.e., for those involving an L2 cache access, an L2 cache miss, etc.) In other embodiments, the analysis engine may not calculate values for the new profiling object until explicitly directed to do so by the user or until the user selects the new custom profiling object for display.</p>
<p id="p-0302" num="0301">When the new custom profiling object is selected, the cost data for the new profiling object may appear as illustrated in <figref idref="DRAWINGS">FIG. 22P</figref>. In this example, cost data previously collected and associated with various physical addresses may be mapped by the new relational agent according to the PA_L2 formula and displayed by PA_L2 memory object. The data displayed indicates that the single virtual address involved in the observed bottleneck is mapped to many different physical addresses, which are in turn mapped to a single L2 cache line. Therefore, this data indicates that the likely cause of the observed bottleneck is L2 cache misses due to conflicts between multiple physical addresses mapped to a single cache line.</p>
<p id="p-0303" num="0302">Once the user (analyst) identifies the cause of a performance bottleneck, he or she may take steps to eliminate the bottleneck, thereby optimizing performance of the profiled application. In the example described above, the analyst may examine other profiling objects, (e.g., virtual pages, processors, or other profiling objects) in order to determine how best to reorganize the memory mappings so that the observed conflict misses are reduced or avoided all together. In the example described above, the analyst may be able to reduce the total memory stall time for the application being profiled by shattering the virtual page associated with the many different physical addresses (in other words, by repairing the data allocation conflicts).</p>
<p id="p-0304" num="0303">While the examples above primarily illustrate the use of a GUI to display two-dimensional profile data (e.g., a cost on one axis and a profiling object identifier value on a second axis) the data space profiler and GUI may in some embodiments support the display of more than two event data dimensions at once. For example, the data may be displayed as a 3-dimensional object (e.g., a 3-dimensional histogram, drawn using perspective), in which cost may correspond to one axis and two different profiling object identifier values may correspond to the other two axes. In another example, a 3-dimensional object may be displayed as above, but a surface color on different portions of the object may represent a 4<sup>th </sup>profiling data identifier value or other cost or code behavior attribute.</p>
<p id="p-0305" num="0304">As shown in the example above, the data space profiler may allow custom data profiling objects and/or custom filter clauses to be specified by a user during analysis, in some embodiments. The data space profiler described herein may also include a method and apparatus to associate costs with a user-specified high-level data type, in some embodiments. In other words, it may provide a mechanism to operate on context specific data and costs. Context-specific data may in some embodiments include the values of one or more variables included in the application that are interesting to the developer for profiling purposes. For example, a developer may include program instructions in the application being profiled that define a variable representing the name of the user executing the program. In this example, the program instructions may prompt the user to enter his or her name or may capture the name of the user on whose behalf the application is being run through other means (such as through an operating system function). When a system event is detected, the user name may be included in the profile data collected and associated with the event, along with other extended address element values, as described above. In this way, the developer may be able to determine if the performance of the application varies between users (e.g., if there is anything about a particular user's inputs, data, or use model of the application that causes a difference in performance compared to other users.)</p>
<p id="p-0306" num="0305">In other examples, a variable defined in the application may represent the name or type of the transaction on whose behalf operations are executed (e.g., a particular query or query type), the application name, a job name, a lock identifier, a semaphore identifier, or an identifier of a storage location (e.g., the row of a database being accessed.) These variables may be updated by the application as it executes and the current value of each variable may be captured and associated with an event when it is detected. Being able to examine the value of these variables when a system event is detected may in some embodiments allow a developer to determine performance bottlenecks of the application and/or their causes.</p>
<p id="p-0307" num="0306">An apparatus for associating user-specified data with events may be employed as a part of an operation to translate application code to support data space profiling. This operation is described earlier in regard to <figref idref="DRAWINGS">FIG. 1</figref>, block <b>110</b>. The apparatus for associating user-specified data with events may include two components: a descriptor apparatus and an event agent. The descriptor apparatus may allow input of a user-specified function defining a high-level data type, or may include user specified debugging commentary or another definition of the high-level data and/or data type of interest, according to various embodiments. The descriptor apparatus may be inserted into the source code of the application by the compiler or other automated tools, or by a developer, in different embodiments. For example, in one embodiment a descriptor function included in the application may register particular variables defined in the application as profiling elements (e.g., as additional extended address elements). The descriptor function may specify which variables should be tracked for profiling purposes and where their values are stored, in some embodiments. In other embodiments, a descriptor function in the application may specify the variables to be tracked and the compiler may include program instructions for determining where the values of the variables are stored, such as through a compiler directive or debugging commentary. In still other embodiments, compiler directives or debugging commentary may be used to specify both the variables to be tracked and the storage locations for their values. In some embodiments, storage locations for the variables of interest may be allocated on a per-thread basis.</p>
<p id="p-0308" num="0307">The descriptor apparatus may specify one or more individual variables to be tracked or may specify a location at which a list of the variables to be tracked is stored, in different embodiments. For example, the descriptor apparatus may define a pointer to a data structure containing a list of variable identifiers whose values are to be included in the profile data and their respective storage locations. These variable identifiers may represent variables defined in the application or in any other program instructions executed along with the application, such as operating system variables, variables defined in other code linked with the application during execution, variables included in various run-time library functions, etc.</p>
<p id="p-0309" num="0308">In some embodiments, a de-registration function may also be included in an application. This function may be used to indicate that a particular variable is no longer of interest or may be invoked when storage for the variable's value is de-allocated by the operating system and the value is no longer valid. A developer may in some embodiments customize the profile data collected during execution of different functions or methods of an application through the use of one or more descriptor/registration functions and one or more de-registration functions. For example, a particular variable may be of interest during execution of a first function or method of the application, but may not have anything to do with the execution of other functions or methods. A developer may, therefore, include a registration function call to register the particular variable at the beginning of the first method and a de-registration function call for the particular variable at the end of the method. In this way, an event agent may only capture the value of the particular variable if a system event occurs during execution of the first method. Similarly, each of a plurality of methods included in the profiled application may invoke one or more descriptor/registration functions and/or de-registration functions in order to customize the variables tracked and captured as profile data for the method.</p>
<p id="p-0310" num="0309">The event agent may be implemented in hardware or in software, according to different embodiments, and may be configured to collect profile data related to the data type descriptions specified using the descriptor apparatus. In some embodiments, the event agent may be a function inserted into the source code of an application to be profiled. This function may be invoked when a system event is detected, and may be include program instructions configured to capture the values of each of the registered variables and to associate them with the system event. In some embodiments, the event agent may be configured to maintain a list of registered variables and their locations. In embodiments in which the descriptor function defines a pointer to a list of registered variables, the event agent may access the list in order to capture the values of the registered variables. In some embodiments, an event agent may request allocation of space for a variable and/or registration of a variable at runtime, such as in response to a user entering a command line directive to track the variable when profiling is initiated.</p>
<p id="p-0311" num="0310">Once the event agent has captured the values of the registered variables, it may be configured to associate the variables with the detected system event. In some embodiments, this may include storing the values of the registered variables in an event set (e.g., in an event space database) along with the values of other extended address elements captured by other event agents and associated with the event.</p>
<p id="p-0312" num="0311">The event agent may enable users to monitor their user-specified data as it flows through an application, in some embodiments, and may enable a developer to associate costs with user-specified data and/or data types. For example, a developer may be able to view costs associated with an Oracle&#x2122; database row on behalf of a specific Solaris&#x2122; user that initiated an ODBC (Open Database Connectivity) Transaction.</p>
<p id="p-0313" num="0312">It should be noted that the values of user-specified (registered) variables may be captured by a single event agent or by multiple event agents, according to different embodiments. For example, in some embodiments, one set of variables may be registered with a first event agent and another set of variables may be registered with a second event agent. The variables may be registered with different event agents dependent on their source (e.g., application code vs. operating system code; one method vs. another method; one thread vs. another thread), their type (e.g., global vs. local, string vs. numerical), their function within the application (e.g., as a flag, semaphore, loop counter, sensor reading), or on the type of event being detected, in different embodiments. For example, the value of a particular variable (e.g., a database row identifier) may be of interest when a cache miss is detected, but not when a hardware interrupt is detected. Therefore, an event agent capturing profile data when a cache miss is detected may be configured to capture the value of a database row being accessed, while an event agent capturing profile data when a hardware interrupt is detected may not capture this value. On the other hand, when a hardware interrupt is detected, an event agent may be configured to capture the value of a variable representing the value of a hardware sensor (e.g., a temperature sensor) read by the application.</p>
<p id="p-0314" num="0313">One method for using a descriptor apparatus and event agent to associate user-specified data with a system event is illustrated in <figref idref="DRAWINGS">FIG. 23</figref>. In this example, an application being profiled may register one or more variables with an event agent, as shown in <b>2310</b>. As described above, these variables may be registered for the whole application or on a per-method or per-thread basis. Registering the variables may include conveying to the event agent an identifier of each variable to be registered and its location, in some embodiments. In other embodiments, registering the variables may include conveying to the event agent a pointer to a data structure containing a list of variable identifiers and their respective storage locations.</p>
<p id="p-0315" num="0314">As the application being profiled is executed, program instructions may be configured to update the value of each of the registered variables, as in <b>2320</b>. If a system event is detected, as in <b>2330</b>, an event agent may be configured to access the storage locations of the registered variables and to capture the current values of each of the variables. This is illustrated at <b>2340</b>.</p>
<p id="p-0316" num="0315">The event agent may be configured to associate the captured values with the event and to store them in an event set, as in <b>2350</b>. For example, the identifier and value of each registered variable may be stored as an extended address element in an event set, as described above. In some embodiments, a data space profiler may access this additional data in the event space when profiling the application, as in <b>2360</b>. For example, relational agents may extract this data in order to associate costs of a system event with the user name on whose behalf the application is running when the system event is detected, the transaction executing an operation that caused the system event, or the database row being accessed when the system event was detected. The relational agents may extract cost data associated with the event and with a particular value of one or more of the registered variables by indexing on the value(s) of the one or more registered variables, as described above.</p>
<p id="p-0317" num="0316">The data space profiler may in some embodiments include means to extend the profiling techniques for profiling network applications. Traditionally, in order to profile network applications, they needed to be booted in an artificial network with &#x201c;nodes&#x201d; in different network zones and the &#x201c;network&#x201d; encapsulated by the operating system. This technique may be limited in the number of nodes that may be supported and in the size of applications that may be profiled. The data space profiler described herein may in some embodiments include a tagging component, an event generating component, and a synchronization component to support data space profiling techniques as applied to network applications.</p>
<p id="p-0318" num="0317">In some embodiments, the tagging component may associate network addresses, ports, protocols, source user-specified types, and other profiling objects and/or extended address elements with network event costs. The event cost through the protocol stack may be treated as a user-specified event within the operating system, in some embodiments. In this way, additional extended address elements representing a hardware context for a network application may be included in the profile data collected for analysis of the applications. Profiling data movement between two computing systems using these methods may involve profiling data movement between any two hardware and/or software systems that communicate with each other over a network, according to different embodiments. For example, these methods may be used to profile two instances of a network application executing on different hardware platforms that communicate with each other by sending messages over a network according to a client/server or peer-to-peer protocol.</p>
<p id="p-0319" num="0318">In some embodiments, when a message is sent from one computing system to another computing system across a network, the message may be tagged with local extended address information by the first computing system. This extended address information may include contextual information for the message according to the configuration and/or operation of the first computing system. For example, a tagging component on the first computing system may tag the message with any or all of the extended address elements (i.e., their identifiers and their values) described herein and corresponding to software constructs, data allocations, hardware components, user-specified data (registered variable values), etc. In some embodiments, the message may be tagged with time stamp information corresponding to the time at which the message was sent and which may be considered yet another extended address element. In still other embodiments, the message may be tagged with information about how the message is sent via the network, such as an output port identifier, network protocol name or type, or a network address of the first computing system. This information may collectively be referred to as A<sub>local </sub>(the local extended address) of the message in the context of the first computing system.</p>
<p id="p-0320" num="0319">When a second computing system receives the message, the extended address information received along with the message may be referred to as A<sub>remote </sub>(the remote extended address) of the message, in the context of the second computing system. In some embodiments, when the message is received, the second computing system may tag it with additional extended address information according to the configuration and/or operation of the second computing system. For example, the second computing system may tag the message with its own A<sub>local </sub>information, corresponding to a software construct, data allocation, hardware component, user-specified data value (registered variable value), time stamp (e.g., indicating the time that the message was received), an input port identifier, network protocol name or type, or a network address of the second computing system. In other embodiments, the second computing system may not tag the message with additional A<sub>local </sub>information until or unless a system event is detected.</p>
<p id="p-0321" num="0320">In some embodiments, sending or receiving a network message may be considered a network event of interest for profiling and information corresponding to this event may be captured by one or more event agents of the first and/or second computing systems. For example, a network message may correspond to a transaction between two computing systems, such as a query message or a reply message sent in response to a query. In such embodiments, when a message is sent from a first to a second computing system, an event agent of the first computing system may capture A<sub>local </sub>information corresponding to the message and associate it with the event (e.g., sending a network message or initiating a transaction request) in an event set of the first computing system. In this example, when the message is received by the second computing system, an event agent of the second computing system may capture the A<sub>remote </sub>and/or additional A<sub>local </sub>information corresponding to the message and may associate it with the event (receiving a network message or transaction request) in an event set of the second computing system. Similarly, if a reply message is sent back to the first computing system from the second computing system, an event agent of the first computing system may be configured to capture the information tagged by the second computing system (A<sub>local </sub>in the context of the second computing system) and received along with the message as A<sub>remote </sub>for the received message in the context of the first computing system. In some embodiments, A<sub>local </sub>and A<sub>remote </sub>information for a pair of network messages (e.g., a query message and a corresponding reply message) may be associated with each other and with both messages in an event set of the first and/or the second computing system.</p>
<p id="p-0322" num="0321">In other embodiments, when a different type of system event (i.e., other than the sending or receiving of a network message or transaction request/response) is detected, event agents of the affected computing system or systems may be configured to capture A<sub>local </sub>and/or A<sub>remote </sub>information corresponding to a current or most recent network message. For example, if a transaction or message received by the second computing system causes a system event in the second computing system, event agents of the second computing system may be configured to associate A<sub>local </sub>and A<sub>remote </sub>of the message with the event. Similarly, if a system event is detected on the first computing system that was caused by the network message or transaction (e.g., a network addressing error event or negative response to a query), event agents of the first computing system may be configured to associated A<sub>local </sub>and/or A<sub>remote </sub>of the message, transaction, or a message or transaction pair with the system event.</p>
<p id="p-0323" num="0322">In another example, if a system event is detected on the second computing system that is not caused by a message or transaction itself, event agents of the second computing system may be configured to associate A<sub>local </sub>and/or A<sub>remote </sub>information of the most recent message or transaction sent or received with the system event. Similarly, if a system event is detected on the first computing system that is not caused by a message or transaction itself, event agents of the first computing system may be configured to associate A<sub>local </sub>and/or A<sub>remote </sub>information of the most recent message or transaction sent or received with the system event. In some such embodiments, A<sub>local </sub>and A<sub>remote </sub>information may be considered general system context information rather than as information associated only with a particular message or transaction. In such embodiments, each computing system, application executing on each computing system, or thread of each application executing on each computing system, for example, may maintain a single set of current values for A<sub>local </sub>and A<sub>remote </sub>corresponding to the last message sent or received or the current state of the computing system, rather than maintaining and/or storing a unique set of A<sub>local </sub>and/or A<sub>remote </sub>values for each message sent or received. For example, in some embodiments, when a transaction between two computing systems is initiated, A<sub>local </sub>and A<sub>remote </sub>information may be stored on the first and/or second computing systems as described herein. In some embodiments, when the transaction is complete, the A<sub>local </sub>and/or A<sub>remote </sub>information may be cleared. In other embodiments, the A<sub>local </sub>and/or A<sub>remote </sub>information stored in response to a first transaction may be replaced with new information corresponding to a subsequent transaction, when the subsequent transaction occurs.</p>
<p id="p-0324" num="0323">Note that in some embodiments, a subset of the extended address elements (i.e., their identifiers and values) associated with an event (e.g., a network transaction) may be conveyed along with a network message. In some embodiments, the network application may register the extended address elements with an event agent to be conveyed along with network messages, in much the same manner as variables of an application are registered with other event agents. In some such embodiments, an event agent detecting a network event may be configured to capture and/or convey registered extended address element identifiers and their respective values along with a message sent or to capture registered extended address element identifiers and their respective values of received messages. In still other embodiments, an event agent detecting a system event may be configured to capture and associate the current state of the computing system as A<sub>local </sub>for the event when the event is detected and to associate the most recent A<sub>remote </sub>information (i.e., corresponding to the most recent network message or transaction) with the event.</p>
<p id="p-0325" num="0324">One method for associating network information with event costs is illustrated in <figref idref="DRAWINGS">FIG. 24</figref>. In this example, a message on a first computing system may be tagged with local extended address element information by a network application executing on the first system, as shown in <b>2620</b>. The network application may send the message to a second computing system, including the local extended address element information, as in <b>2630</b>.</p>
<p id="p-0326" num="0325">In this example, the second computing system may receive the message along with the local extended address element information from the first computing system and may store the information as remote information of the second computing system. This is illustrated at <b>2640</b>. As noted above, the local and remote extended address information may be associated with the message itself or may correspond to the most recent information associated with the application, a thread of the application, or a method of the application, in different embodiments. Also as noted above, the local and/or remote information sent and received/stored may correspond to a subset of available extended address information as specified in a registration of the subset of extended address elements with one or more event agents.</p>
<p id="p-0327" num="0326">In the example illustrated in <figref idref="DRAWINGS">FIG. 24</figref>, the second computing system may detect a system event, as in <b>2650</b>. As noted above, the system event may correspond to the sending or receiving of the network message/transaction itself, a system event caused by the network message/transaction, or another system event (i.e., one not caused by the network message/transaction). For example, an event agent may be configured to sample transactions between computing systems (e.g., by generating an event based on exceeding a predetermined count of the transactions) in order to profile the behavior of the underlying application(s), as previously described. In another example, an event agent may be configured to monitor the remote and/or local extended address information and to generate a system event in response to detecting a particular value or pattern of values in the information.</p>
<p id="p-0328" num="0327">In response to detecting the system event, the second computing system may associate the remote information with the system event and may associate other local information with the event, as in <b>2660</b>. As previously noted, the other local information (i.e., information that is local in the context of the second computing system) may be captured by an event agent at the time the message is received or may be captured by an event agent when the system event is detected, according to different embodiments. The remote and/or local information associated with the event by the event agent may be stored in an event set (e.g., an event space database) for later analysis.</p>
<p id="p-0329" num="0328">In some embodiments, a data space profiler, such as the one described herein, may be configured to access the event set data, including the values of any or all of the local and remote extended address elements described herein, and may use the data in profiling the application experiencing the system event. This is illustrated at <b>2670</b>. In some embodiments, relational agents may extract event data according to the values of one or more of the extended address elements, including the network information and/or time stamp information, and this data may facilitate the identification of performance bottlenecks and/or their causes. For example, the data may be used to identify an input or output port associated with an exceptional event cost or asymmetric resource utilization, such as an exceptionally slow input or output port or a port that is accessed disproportionately often within the system.</p>
<p id="p-0330" num="0329">The event generating component (or event agent) may in some embodiments compute the latency for the network event, and based on required cost, may issue an event when the cost exceeds a threshold. Thus, the data space profiler may be configured to use statistical sampling for profiling distributed applications of any size, supported by the extensions described above.</p>
<p id="p-0331" num="0330">One method for generating a system event based on computed network latency is illustrated in <figref idref="DRAWINGS">FIG. 25</figref>. In this example, a first computing system and a second computing system may each include one or more time bases. A time base of each of the computing systems may be synchronized with each other according to various known methods and within an acceptable margin (epsilon), as in <b>2710</b>. For example, they may be synchronized using Network Time Protocol (NTP). The synchronization may be invoked by a network application running on the first computing system or by another means (e.g., the systems may be periodically synchronized by the operating system) in different embodiments.</p>
<p id="p-0332" num="0331">In this example, a network message on the first system may be tagged with a local time stamp, according to the synchronized time base of the first system. This is illustrated at <b>2720</b>. This time stamp may correspond to the time at which the message is sent and may be one of a plurality of extended address elements to be conveyed with the network message, as described above.</p>
<p id="p-0333" num="0332">The network application executing on the first computing system may send the message to a second computing system including the local time stamp and any other relevant extended address element information. This information may collectively be referred to as A<sub>local</sub>, in the context of the first computing system. This is illustrated at <b>2730</b>.</p>
<p id="p-0334" num="0333">The second computing system may receive the message and may store the received local time stamp (part of the first computing system's A<sub>local</sub>) as a remote time stamp (part of the second computing system's A<sub>remote</sub>). This is illustrated in <b>2740</b>. The second system may also store a local time stamp (according to the synchronized time base of the second system) in response to receiving the message. In some embodiments, this local time stamp (part of the second computing system's A<sub>remote</sub>) may correspond to the time at which the message was received.</p>
<p id="p-0335" num="0334">As illustrated at <b>2750</b>, other extended address element information (i.e., all or a portion of A<sub>local </sub>of the first computing system, including element identifiers and their values) received along with the network message may be stored as extended address elements of A<sub>remote </sub>on the second computing system. In addition, other local extended address element information (i.e., local to the second computing system) may be stored on the second computing system as part of A<sub>local </sub>of the second computing system.</p>
<p id="p-0336" num="0335">In some embodiments, the second computing system may determine a value for network latency dependent on the time stamps in A<sub>remote </sub>(i.e., the time stamp when the message was sent) and in A<sub>local </sub>(i.e., the time stamp when the message was received.) This is illustrated at <b>2760</b>. For example, the network latency may be calculated as the difference between these two time stamps, in some embodiments. In other embodiments, the network latency may be calculated as the difference between the two time stamps less any other time attributable to activities other than sending and receiving the message. For example, if an instruction or function of the network application that initiates sending the message includes an address calculation or translation, or if it must access data on the first computing system before sending it to the second system (but after tagging the message with a time stamp), the time to perform these operations may be subtracted from the time stamp difference to calculate the time spent in the network transfer. Similarly, if the instruction or function receiving the message on the second computing system includes other activities subsequent to receiving the message but before tagging the message with a time stamp, the time to perform these activities may be subtracted from the time stamp difference to calculate the network latency. In some embodiments, if the time bases of the first and second computing systems are calibrated to each other or to a reference time base rather than being synchronized to the same time, a calibration adjustment may be applied to the difference in the time stamps to calculate the network latency. In another example, the accuracy of the network latency calculation may be dependent in part on the accuracy of the synchronization of the two time bases (i.e., as a function of epsilon, described above.)</p>
<p id="p-0337" num="0336">In some embodiments, the second system may be configured to determine if the calculated network latency meets or exceeds a predetermined threshold, as shown in <b>2770</b>. If not, illustrated by the negative exit from block <b>2770</b>, execution of the network application may proceed normally, as in <b>2775</b>. Network latency may be calculated for a single sampled message and/or may be calculated based on the accumulated latency across multiple samples during statistical sampling, in different embodiments. In one embodiment, the network latency values of multiple messages may be accumulated by an event agent and when the accumulated value (e.g., the total latency for multiple samples) meets or exceeds a pre-determined latency threshold, an event may be generated and/or a current message may be sampled. This event agent may be a software event agent or a hardware event agent, in different embodiments. In still other embodiments, the criteria for generating an event based on network latency may be defined in an expression that is evaluated against one or more collected and/or accumulated network latency values.</p>
<p id="p-0338" num="0337">In some embodiments, if the threshold is met or exceeded, or if other criteria for generating a network latency event is met, as illustrated by the positive exit from block <b>2770</b>, the second computing system may generate a system event. This is illustrated at <b>2780</b>. In this example, when this event is detected, an event agent may associate A<sub>remote </sub>and/or A<sub>local </sub>information with the system event in the event set. This information may be accessed by a data space profiler, in some embodiments, and may be used to identify performance bottlenecks of the network application sending or receiving the message. This is illustrated at <b>2790</b>. For example, when the network latency threshold is exceeded (indicating a slow network connection, stall, or other performance issue) the developer may extract other contextual information about the network activity at the time of this event, such as an identifier of the input and/or output port, the protocol being used, the network addresses of the sending and receiving computing systems, etc. This information may be extracted from the network message itself or from a statistical sample packet generated in response to detecting the event (i.e., that the threshold was exceeded), in different embodiments. Using this information the data space profiler may be configured to display information identifying, for example, that a particular port connection is down or is being accessed at a rate that is incompatible with its specified bandwidth. This information may in some embodiments be used by a developer or automatically (e.g., by an optimizing compiler) to improve the performance by re-configuring the computing system(s) and/or optimizing the network application code to correct a problem or avoid an observed asymmetric resource utilization.</p>
<p id="p-0339" num="0338">While the example illustrated in <figref idref="DRAWINGS">FIG. 25</figref> describes generating a system event in response to an observed network latency issue (e.g., a single or accumulated latency value exceeding a pre-determined threshold or meeting pre-determined network latency event criteria), in other embodiments, a computing system may be configured to generate a system event in response to other observed behavior of a network application by applying the system and methods described herein. For example, in some embodiments, the system and method described herein for capturing contextual information for a network application may be combined with the system and methods described herein for statistical sampling of system events and associating costs to these event to support profiling of distributed applications of arbitrary size and complexity. Accordingly, event agents of a computing system may be configured to generate system events (e.g., software traps) in response to detecting a value or pattern of interest for the values of any of the local or remote extended address elements sent, received, or otherwise determined during execution of an application being profiled. The techniques described above may be used to generate system events in response to a networking application meeting predetermined criteria related to network transaction metrics other than network latency, in some embodiments. For example, a system event may be generated in response to meeting event criteria defined by an expression dependent on a transmission rate, a number of transmissions, a re-transmission rate, a number of re-transmissions, a transmission failure rate, a number of transmission failures, a collision rate, a number of collisions, a transmission retry rate, a number of transmission retries, a transmission error rate, a number of transmission errors, or any other suitable networking performance metric or cost, in various embodiments. In some embodiments, the profile data associated with system events in an event space database may be filtered based on the value of one or more network performance metrics, stored as extended address elements associated with system events, when analyzing performance of a network application. For example, the data may be filtered such that only events in which a predetermined network latency threshold is exceeded are displayed during analysis.</p>
<p id="h-0021" num="0000">Computing System and Data Flow</p>
<p id="p-0340" num="0339">The described invention may be provided as a computer program product, or software, that may include a machine-readable medium having stored thereon instructions, which may be used to program a computer system (or other electronic devices) to perform the techniques of the present invention. For example, the various data space profiling methods described herein may be embodied in one or more of a data space profiling tool, a code optimizer, or a runtime library, according to different embodiments. In various embodiments, a machine-readable medium may include any mechanism for storing or transmitting information in a form (e.g., software, processing application) readable by a machine (e.g., a computer). The machine-readable medium may include, but is not limited to, magnetic storage medium (e.g., floppy disk); optical storage medium (e.g., CD-ROM); magneto-optical storage medium; read only memory (ROM); random access memory (RAM); erasable programmable memory (e.g., EPROM and EEPROM); flash memory; electrical, optical, acoustical or other form of propagated signal (e.g., carrier waves, infrared signals, digital signals, etc.); or other type of medium suitable for storing electronic instructions.</p>
<p id="p-0341" num="0340">An exemplary computer suitable for implementing the data space profiling system and methodology described herein is illustrated in <figref idref="DRAWINGS">FIG. 26</figref>. In this example, a computer system <b>2300</b> may include system memory <b>2310</b>, one or more processors <b>2370</b>, a memory management unit (MMU) <b>2380</b>, one or more input/output interfaces <b>2360</b>, one or more hardware counters <b>2350</b>, and an interconnect <b>2390</b>. Computer system <b>2300</b> may in some embodiments be communicatively coupled to one or more remote storage devices, such as disk storage <b>2380</b>, and may also be coupled to one or more hardware event agents, such as hardware counter <b>2350</b>.</p>
<p id="p-0342" num="0341">System memory <b>2310</b> may in some embodiments include program instructions and data configured to implement data profiler <b>2320</b>, which may perform the data space profiling operations described herein. Data profiler <b>2320</b> may include several software components including an analysis engine <b>2305</b>, user interface <b>2355</b>, one or more software event agents <b>2365</b>, and one or more relational agents <b>2375</b>, which may be configured to implement the operations for these components, as described herein. Software event agents <b>2365</b> may be configured to collect profile data associated with runtime events occurring during profiling of application code <b>2335</b>, for example. In different embodiments, program instructions and data configured to implement data profiler <b>2320</b> may be partitioned into more, fewer, or different software modules than those illustrated in <figref idref="DRAWINGS">FIG. 26</figref>. For example, in some embodiments, the operations described as being part of user interface <b>2355</b> (e.g., GUI operations) may be integrated within analysis engine <b>2305</b>. In other embodiments, one or more of event agents <b>2365</b> may be implemented on a different computer system and the profile data collected by them may be transmitted to computer system <b>2300</b> for analysis.</p>
<p id="p-0343" num="0342">System memory <b>2310</b> may also include program instructions and data configured to implement compiler <b>2315</b>, control file <b>2325</b>, and operating system code <b>2312</b>, in some embodiments. Control file <b>2325</b> may in some embodiments include configuration information to be used by the data space profiler. For example, it may include values for one or more presentation option settings (e.g., zoom level or profiling object tabs to display), aggregation (binning) rules, relational agent definitions, platform-specific options and definitions, etc. Operating system code <b>2312</b> may in some embodiments include one or more event agents <b>2365</b> and/or may be configured to received triggers, interrupts, event data packets, or other runtime-event-related information from various hardware event agents, such as hardware counters <b>2350</b>. System memory <b>2310</b> may also include one or more application programs, such as application code <b>2335</b>, which may be both executed and analyzed on computer system <b>2300</b>. In other embodiments, application code <b>2335</b> may be executed on a computer system other than computer system <b>2300</b>, but the resulting profile data may be analyzed on computer system <b>2300</b>.</p>
<p id="p-0344" num="0343">In some embodiments, system memory <b>2310</b> may also include a storage area for event space data <b>2345</b>. Event space data <b>2345</b> may include any or all of the storage areas described herein for storing data space profiling data and/or results. For example, in some embodiments, event space data <b>2345</b> may include one or more per-thread or per-address-space event data repositories, one or more temporary data files used by the analysis engine, and one or more event space repositories, for storing the complete event space for an application profiling experiment. In other embodiments, these various event data storage areas may be partitioned into more, fewer, or different memory storage areas and/or may be distributed across multiple machines or computer systems. In one embodiment, one or more of these data event storage areas may be located on a remote storage device, such as disk storage <b>2380</b>.</p>
<p id="p-0345" num="0344">Processor <b>2370</b> may be configured to implement any of various instruction set architectures, such as x86, SPARC, PowerPC, etc. In some embodiments, processor <b>2370</b> may include a single CPU core, multiple CPU cores, or any combination of one or more general-purpose CPU cores and special-purpose cores (e.g., digital signal processors, hardware accelerators, co-processors, etc.) In various embodiments, processor <b>2370</b> may be configured to implement a superscalar architecture or may be configured to implement multi-threading. In some embodiments, processor <b>2370</b> may be a chip-multithreaded (CMT) processor, as described herein.</p>
<p id="p-0346" num="0345">Interconnect <b>2390</b> may couple processor <b>2370</b> to memory <b>2310</b>, as illustrated. In some embodiments, interconnect <b>2390</b> may be configured to couple processor <b>2370</b> directly to a computer system network. In some embodiments, interconnect <b>2390</b> and input/output interface <b>2360</b> may be configured to implement one or more of various interface or network standards, e.g., Peripheral Component Interconnect (PCI), Ethemet, HyperTransport (HT), Infiniband, or any variant or successor of these or other suitable input/output protocols.</p>
<p id="p-0347" num="0346">Hardware event counters <b>2350</b> may in some embodiments be included in computer system <b>2300</b> to collect profiling data for runtime events occurring during profiling of application code <b>2335</b>. In other embodiments, hardware counters <b>2350</b> and/or other hardware event agents may be included in other components of computer system <b>2300</b>, such as in processor <b>2370</b>. In still other embodiments, hardware counters <b>2350</b> and/or other hardware event agents may be located on computer systems separate from computer system <b>2300</b>, such as if application code <b>2335</b> is executed on a different computer system and then analyzed on computer system <b>2300</b>. For example, <figref idref="DRAWINGS">FIG. 26</figref> illustrates an instance of hardware counter(s) <b>2350</b> located outside of computer system <b>2300</b> and coupled to disk storage <b>2380</b> and to input/output interface <b>2360</b>. In this example, these hardware counters may by configured to capture events related to disk storage accesses. In embodiments including remote hardware event agents, triggers, interrupts, event data packets and/or other event-related profiling information may be transmitted from these hardware event agents to computer system <b>2300</b> for analysis by data profiler <b>2320</b> and/or analysis engine <b>2305</b>.</p>
<p id="p-0348" num="0347">As noted above, the data space profiler described herein may be implemented on one machine but may be used to analyze profile data collected when an application runs on a separate machine or on multiple machines. <figref idref="DRAWINGS">FIG. 27</figref> illustrates a data flow diagram for a profiling experiment involving a multi-threaded application executing on multiple machines.</p>
<p id="p-0349" num="0348">In this example, two threads <b>2450</b> of an application execute on machine <b>2422</b> and another thread <b>2450</b> executes on machine <b>2411</b>. Each thread <b>2450</b> includes one or more software event agents <b>2455</b>, which transmit event data <b>2426</b> to a per-thread repository <b>2425</b>, which is located on the same machine on which the thread executes. Each machine also includes one or more hardware event agents <b>2465</b>, which transmit event data <b>2456</b> (e.g., a trigger or interrupt) to an operating system <b>2460</b> running on the same machine. Each operating system <b>2460</b> then transmits event data representing events detected by the hardware event agents (<b>2456</b>) and other event data <b>2466</b> (e.g., program counter values, physical addresses, etc.) related to runtime events of the threads operating on the same machine.</p>
<p id="p-0350" num="0349">In this example, a third machine <b>2433</b> may include analysis engine <b>2435</b>, which may include a graphical user interface, GUI <b>2436</b>. Analysis engine <b>2435</b> may build event space <b>2440</b> on machine <b>2433</b> from event data received from machine <b>2422</b> and machine <b>2411</b> (e.g., event data <b>2426</b>, <b>2456</b>, and <b>2466</b> from per-thread repositories <b>2425</b> and operating systems <b>2460</b>), in some embodiments. During analysis, relational agents <b>2437</b> of analysis engine <b>2435</b> may extract profiling object identifiers <b>2498</b> and event costs <b>2499</b> from event space <b>2440</b>, as described herein. The filtered, sorted, and/or aggregated data may then be presented to a user (analyst) through GUI <b>2436</b>.</p>
<p id="p-0351" num="0350">As described above, data space profiling may in some embodiments be applied to network applications and may be used to profile data movement between computing systems, such as when transaction requests or other messages are sent between computing systems. As previously noted, data movement between two computing systems may involve data movement between any two hardware or software systems, including, but not limited to two similar software systems or applications executing on a same hardware platform (e.g., two Oracle databases on one machine), two dissimilar software systems or applications executing on the same or different machines, or two similar or dissimilar software applications operating on different machines. <figref idref="DRAWINGS">FIG. 28</figref>, for example, illustrates a data flow diagram for an exemplary profiling experiment involving data movement between two computing systems, according to one embodiment. In this example, a thread <b>2450</b> of a network application executing on machine <b>2422</b> may send a transaction request or other message to a thread <b>2850</b> of a different network application executing on machine <b>2411</b>. In this example, the network applications executing on machines <b>2411</b> and <b>2422</b> may be similar, but threads <b>2450</b> and <b>2850</b> are threads of different applications. In another embodiment, they may be different threads of a same multi-threaded application distributed across the machines and configured to send and receive transaction requests or other messages from each other as described herein.</p>
<p id="p-0352" num="0351">In the example illustrated by <figref idref="DRAWINGS">FIG. 28</figref>, each of machines <b>2411</b> and <b>2422</b> may include a synchronizer (<b>2885</b> and <b>2585</b>, respectively), which may be used to synchronize a time base on each of the machines, as previously described. In this example, thread <b>2450</b> and thread <b>2850</b> may send and receive messages <b>2880</b> between machines <b>2411</b> and <b>2422</b> according to a communication protocol of interface modules <b>2575</b> and <b>2875</b>. Some messages <b>2880</b> may be used to synchronize time bases included in synchronizers <b>2885</b> and <b>2585</b>, for example, while other messages may include transaction requests, transaction responses, status information, or any other type of data passed between network applications.</p>
<p id="p-0353" num="0352">When a message <b>2880</b> is sent from thread <b>2450</b> on machine <b>2422</b>, tagging module <b>2560</b> may be configured to tag the message with local extended address information, as described above. When the message is received by thread <b>2850</b> on machine <b>2411</b>, the local extended address information received may be associated with the message by a software event agent <b>2855</b> on machine <b>2411</b> and stored as remote extended address information in per-thread repository <b>2825</b> on machine <b>2411</b>.</p>
<p id="p-0354" num="0353">A software event agent <b>2855</b> may tag the message with additional local extended address information (i.e., local in the context of machine <b>2411</b>) when the message is received, in some embodiments. In other embodiments, a software agent <b>2855</b> may tag the message with additional local extended address information only when a system event (i.e., an event other than receiving the message) is detected by a hardware event agent <b>2865</b> or a software event agent <b>2855</b> of machine <b>2411</b>. In still other embodiments, the received extended address information may not be associated with the received message, but may be stored on machine <b>2411</b> as remote extended address information corresponding to the current context of a network application executing on machine <b>2422</b>. Similarly, additional local extended address information stored on machine <b>2411</b> may not be associated with a received message, but may correspond to the current context of a network application executing on machine <b>2411</b>.</p>
<p id="p-0355" num="0354">In some embodiments, when a system event is detected by a hardware event agent <b>2865</b> or a software event agent <b>2855</b> of machine <b>2411</b>, the remote extended address information and additional local extended address information may be associated with the event and stored in per-thread repository <b>2825</b>. This is illustrated in <figref idref="DRAWINGS">FIG. 28</figref> as data <b>2826</b> being sent from thread <b>2850</b> to per-thread repository <b>2825</b>. Similarly, a software event agent <b>2455</b> or hardware event agent <b>2465</b> of machine <b>2422</b> may associate local extended address information and/or remote extended address information with an event (e.g., sending or receiving a message to/from machine <b>2411</b> or another system event) detected on machine <b>2422</b> and may store this information in per-thread repository <b>2425</b>. This is illustrated in <figref idref="DRAWINGS">FIG. 28</figref> as data <b>2426</b> being sent from thread <b>2450</b> to per-thread repository <b>2425</b>. As previously noted, local and/or remote extended address information on one or both of machines <b>2422</b> and <b>2411</b> may include one or more time stamps and/or various contextual information related to communication of the network applications executing on machines <b>2422</b> and/or <b>2411</b> (e.g., network addresses, port identifiers/addresses, protocol identifiers, etc.)</p>
<p id="p-0356" num="0355">The local and remote extended address information, including any time stamps and/or other contextual information may be transmitted to machine <b>2433</b> for analysis by operating systems <b>2460</b> and <b>2860</b>, in some embodiments. An analysis engine may then build an event space <b>2440</b>, as previously described, and may access this event data to profile the one or more network applications executing on machines <b>2411</b> and <b>2422</b>.</p>
<p id="p-0357" num="0356">Note that although <figref idref="DRAWINGS">FIG. 28</figref> and other examples described herein refer to message sent between two computing systems, the methods described herein may be applied to network application that send messages to multiple computing systems (e.g., using broadcast rather than unicast messages). In such embodiments, each of the computing systems receiving the messages may store the received extended address information as remote extended address information and may add its own local extended address information at the time the message is received or in response to another system event being detected. Similarly, hardware or software event agents on any of the receiving machines may be configured to generate a system event dependent on the behavior of the network application in its own context. For example, each computing system may determine if a network latency calculated between it and the sending system exceeds a predetermined threshold, and may generate a system event indicating a latency issue independent of a network latency calculated by the other computing systems. Alternatively, in some embodiments a first computing system may receive messages from network applications of multiple other computing systems. The receiving system may receive extended address information as remote extended address information for each of the other computing systems and may add its own local extended address information to the message and/or associate local information with a system event, as described herein.</p>
<p id="p-0358" num="0357">Using the above-described techniques, the data space profiler may be applied to network applications of arbitrary size and complexity, executing on an arbitrary number of computing systems, according to various embodiments. Thus, the data space profiler may in some embodiments use the additional contextual information provide by these techniques to profile the execution of the application across these computing systems to identify performance bottlenecks and their causes.</p>
<p id="p-0359" num="0358">While the invention has been described with reference to various realizations, it will be understood that these realizations are illustrative and that the scope of the invention is not limited to them. Many variations, modifications, additions, and improvements are possible. For example, while much of the description herein has focused on the illustrative context of memory reference related runtime events, applications to other runtime events and related profiling are also envisioned. Similarly, although instruction instance level profiling has been presumed, techniques described herein may be more generally applied to operations of a processor, pipeline or execution unit, whether such operations correspond one-to-one with instructions of an instruction set or are lower-level or higher-level operations performed by a particular implementation of a target architecture. For example, based on the description herein, persons of ordinary skill in the art will appreciate extensions to operations executable by a microcoded processor implementation or virtual machine implementation.</p>
<p id="p-0360" num="0359">Realizations in accordance with the present invention have been described in the context of particular embodiments. These embodiments are meant to be illustrative and not limiting. Many variations, modifications, additions, and improvements are possible. Accordingly, plural instances may be provided for components described herein as a single instance. Boundaries between various components, operations and data stores are somewhat arbitrary, and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of claims that follow. Finally, structures and functionality presented as discrete components in the exemplary configurations may be implemented as a combined structure or component. These and other variations, modifications, additions, and improvements may fall within the scope of the invention as defined in the claims that follow.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-math idrefs="MATH-US-00001" nb-file="US08627335-20140107-M00001.NB">
<img id="EMI-M00001" he="6.01mm" wi="76.20mm" file="US08627335-20140107-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method comprising:
<claim-text>a first computing system sending a message to a second computing system, wherein the message comprises data sent from the first computing system to the second computing system by a network application that is being profiled and that is executing on at least the first computing system, wherein the message further comprises one or more extended address elements that are local to the first computing system, wherein each extended address element comprises an extended address element identifier and a value of the extended address element, wherein at least one of the extended address elements represents an identifier of a hardware component, an identifier of a software construct, or an identifier of a data allocation, and wherein profiling the network application comprises profiling movement of the data via the message dependent, at least in part, on the one or more extended address elements;</claim-text>
<claim-text>the second computing system receiving the message;</claim-text>
<claim-text>the second computing system detecting a system event, wherein the system event is a system-level runtime event that occurred as a result of executing the network application;</claim-text>
<claim-text>the second computing system storing the one or more extended address elements that are local to the first computing system and that were included in the received message in an event space database, wherein the one or more extended address elements are stored in the event space database in association with the system event as remote extended address elements in a context of the second computing system so that a hardware component, software construct or data allocation at the first computing system is associated with the system event detected at the second computing system in the context of the second computing system.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising the second computing system associating one or more extended address elements that are local to the second computing system with the detected system event.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>,
<claim-text>wherein at least one of said one or more extended address elements that are local to the first computing system, said remote extended address elements, and said one or more extended address elements that are local to the second computing system comprises one of: a port identifier, a network protocol name or type, a connection identifier, an end point identifier, a frame number, or a network address; and</claim-text>
<claim-text>wherein at least one of said one or more extended address elements that are local to the first computing system, said remote extended address elements, and said one or more extended address elements that are local to the second computing system comprises one of: a time, a physical address of a memory component, a virtual address of a memory component, a physical address of a hardware component, a virtual address of a hardware component, a source-level data object language construct, a virtual address of a source-level data object language construct, a physical address of a source-level data object language construct, a program counter value, a virtual address of an instruction instance identifier, a physical address of an instruction instance identifier, a hardware thread identifier, a software thread identifier, a storage system software address, or a storage system hardware address.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising:
<claim-text>the second computing system storing said one or more extended address elements that are local to the second computing system in association with the detected system event in the event space database; and</claim-text>
<claim-text>a data space profiler accessing the event space database to identify a performance bottleneck of a system that experienced the detected system event dependent on at least one of said remote extended address elements or said one or more extended address elements that are local to the second computing system.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>,
<claim-text>wherein at least one of said remote extended address elements and at least one of said one or more extended address elements that are local to the second computing system represents a time stamp;</claim-text>
<claim-text>wherein the method further comprises:</claim-text>
<claim-text>synchronizing a time base of the first computing system and a time base of the second computing system; and</claim-text>
<claim-text>determining a network latency value dependent on a value of the at least one of said remote extended address elements representing a time stamp and a value of the at least one of said one or more extended address elements that are local to the second computing system representing a time stamp;</claim-text>
<claim-text>wherein said detecting the system event comprises determining that the network latency value meets pre-determined network latency event criteria; and</claim-text>
<claim-text>wherein the system event is generated on the second computing system.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the network latency value is an accumulated network latency value.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the system event is generated on the second computing system in response to the second computing system receiving the message and dependent on information contained in the message.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the system event is generated on the first computing system in response to an action taken by the second computing system, and wherein the action taken by the second computing system is dependent on the message.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the system event is generated on the second computing system in response to an action taken by the second computing system, and wherein the action taken by the second computing system is dependent on the message.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first computing system and the second computing system are software systems executing on a same hardware system.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the message comprises a software transaction between the first computing system and the second computing system.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, further comprising:
<claim-text>the first computing system storing values of said one or more extended address elements that are local to the first computing system in a local extended address element list when the transaction begins;</claim-text>
<claim-text>the first computing system storing different values of said one or more extended address elements that are local to the first computing system in the local extended address element list when the transaction ends;</claim-text>
<claim-text>the second computing system storing values of said remote extended address elements in a remote extended address element list when the transaction begins; and</claim-text>
<claim-text>the second computing system storing different values of said remote extended address elements in the remote extended address element list when the transaction ends.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>,
<claim-text>wherein said detecting the system event is dependent on one of: a transmission rate, a number of transmissions, a re-transmission rate, a number of re-transmissions, a transmission failure rate, a number of transmission failures, a collision rate, a number of collisions, a transmission retry rate, a number of transmission retries, a transmission error rate, and a number of transmission errors; and</claim-text>
<claim-text>wherein the system event is generated on the second computing system.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. A system, comprising:
<claim-text>a first computing system; and</claim-text>
<claim-text>a second computing system coupled to the first computing system via a network;</claim-text>
<claim-text>wherein the first computing system comprises:
<claim-text>means for storing one or more extended address elements that are local to the first computing system, wherein each extended address element comprises an extended address element identifier and a value of the extended address element, wherein at least one of the extended address elements represents an identifier of a hardware component, an identifier of a software construct, or an identifier of a data allocation; and</claim-text>
<claim-text>means for sending a message to the second computing system, wherein the message comprises data to be sent from the first computing system to the second computing system by a network application that is being profiled and that is executing on at least the first computing system, wherein the message further comprises the one or more extended address elements that are local to the first computing system, and wherein profiling the network application comprises profiling the movement of the data via the message dependent, at least in part, on the one or more extended address elements;</claim-text>
</claim-text>
<claim-text>wherein the second computing system comprises:
<claim-text>means for receiving the message;</claim-text>
<claim-text>means for storing the one or more extended address elements that are local to the first computing system and that were included in the received message as remote extended address elements in a context of the second computing system; and</claim-text>
<claim-text>means for storing one or more extended address elements that are local to the second computing system, wherein the one or more extended address elements that are local to the second computing system are stored in association with the remote extended address elements so that a hardware component, software construct or data allocation at the first computing system is associated with the one or more extended address elements that are local to the second computing system in the context of the second computing system.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The system of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the second computing system further comprises:
<claim-text>means for detecting a system event, wherein the system event is a system-level runtime event that occurred as a result of executing the network application;</claim-text>
<claim-text>means for associating the remote extended address elements and the one or more extended address elements that are local to the second computing system with the detected system event;</claim-text>
<claim-text>means for storing the remote extended address elements and the one or more extended address elements that are local to the second computing system in association with the detected system event in an event space database; and</claim-text>
<claim-text>means for accessing the event space database to identify a performance bottleneck of a software application causing the detected system event dependent on at least one of the remote extended address elements or the one or more extended address elements that are local to the second computing system.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The system of <claim-ref idref="CLM-00014">claim 14</claim-ref>,
<claim-text>wherein at least one of said remote extended address elements and at least one of said one or more extended address elements that are local to the second computing system represents a time stamp;</claim-text>
<claim-text>wherein the first computing system further comprises:
<claim-text>means for synchronizing a time base of the first computing system with a time base of the second computing system;</claim-text>
</claim-text>
<claim-text>wherein the second computing system further comprises:
<claim-text>means for synchronizing a time base of the second computing system with a time base of the first computing system;</claim-text>
<claim-text>means for determining a network latency value dependent on a value of the at least one of said remote extended address elements representing a time stamp and the at least one of said one or more extended address elements that are local to the second computing system representing a time stamp; and</claim-text>
<claim-text>means for generating the system event in response to said network latency value meeting or exceeding a pre-determined latency threshold value.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The system of <claim-ref idref="CLM-00014">claim 14</claim-ref>,
<claim-text>wherein the message comprises a software transaction between the first computing system and the second computing system;</claim-text>
<claim-text>wherein the first computing system further comprises:
<claim-text>means for storing values of the one or more extended address elements that are local to the first computing system in a local extended address element list when the transaction begins; and</claim-text>
<claim-text>means for storing different values of the one or more extended address elements that are local to the first computing system in the local extended address element list when the transaction ends;</claim-text>
</claim-text>
<claim-text>wherein the second computing system further comprises:
<claim-text>means for storing values of the remote extended address elements in a remote extended address element list when the transaction begins; and</claim-text>
<claim-text>means for storing different values of the remote extended address elements in the remote extended address element list when the transaction ends.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. A computer-readable storage medium, storing program instructions that when executed on a given computing system cause the given computing system to perform:
<claim-text>receiving a message from another computing system, wherein the message comprises data sent from the other computing system to the given computing system by a network application that is being profiled and that is executing on at least the other computing system, wherein the message further comprises one or more extended address elements that are local to the other computing system, wherein each extended address element comprises an extended address element identifier and a value of the extended address element, wherein at least one of the extended address elements represents an identifier of a hardware component, an identifier of a software construct, or an identifier of a data allocation, and wherein profiling the network application comprises profiling the movement of the data via the message dependent, at least in part, on the one or more extended address elements;</claim-text>
<claim-text>storing the one or more extended address elements that are local to the other computing system and that were included in the received message as remote extended address elements in a context of the given computing system; and</claim-text>
<claim-text>storing one or more extended address elements that are local to the given computing system, wherein the one or more extended address elements that are local to the given computing system are stored in association with the remote extended address elements so that a hardware component, software construct or data allocation at the other computing system is associated with the one or more extended address elements that are local to the given computing system in the context of the given computing system.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The storage medium of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein when executed on the given computing system, the program instructions further cause the given computing system to perform:
<claim-text>synchronizing a time base of the given computing system with a time base of the other computing system, wherein at least one of said remote extended address elements, and at least one of said one or more extended address elements that are local to the given computing system comprises a representation of a time stamp; and</claim-text>
<claim-text>determining a network latency value dependent on a value of the at least one of said remote extended address elements representing a time stamp and a value of the at least one of said one or more extended address elements that are local to the given computing system representing a time stamp.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The storage medium of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein when executed on the given computing system, the program instructions further cause the given computing system to perform:
<claim-text>detecting a system event, wherein the system event is a system-level runtime event that occurred as a result of executing the network application;</claim-text>
<claim-text>associating the remote extended address elements and the one or more extended address elements that are local to the given computing system with the detected system event;</claim-text>
<claim-text>storing the remote extended address elements and the one or more extended address elements that are local to the given computing system in association with the detected system event in an event space database; and</claim-text>
<claim-text>accessing the event space database to identify a performance bottleneck of a software application causing the detected system event dependent on at least one of the remote extended address elements or one of the one or more extended address elements that are local to the given computing system. </claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
