<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627136-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627136</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12978866</doc-number>
<date>20101227</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>412</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>11</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>714  411</main-classification>
<further-classification>709212</further-classification>
<further-classification>709218</further-classification>
<further-classification>709217</further-classification>
</classification-national>
<invention-title id="d2e53">Non-disruptive failover of RDMA connection</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>7593996</doc-number>
<kind>B2</kind>
<name>Gole et al.</name>
<date>20090900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709212</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>8041987</doc-number>
<kind>B2</kind>
<name>Allen et al.</name>
<date>20111000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714  511</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>8233380</doc-number>
<kind>B2</kind>
<name>Subramanian et al.</name>
<date>20120700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370218</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>8244825</doc-number>
<kind>B2</kind>
<name>Subramanian et al.</name>
<date>20120800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709212</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>8244826</doc-number>
<kind>B2</kind>
<name>Benner et al.</name>
<date>20120800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709212</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2002/0071386</doc-number>
<kind>A1</kind>
<name>Gronke</name>
<date>20020600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2005/0015459</doc-number>
<kind>A1</kind>
<name>Gole et al.</name>
<date>20050100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709212</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2008/0126509</doc-number>
<kind>A1</kind>
<name>Subramanian et al.</name>
<date>20080500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709214</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2012/0042202</doc-number>
<kind>A1</kind>
<name>Wenzel</name>
<date>20120200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714  63</main-classification></classification-national>
</us-citation>
<us-citation>
<nplcit num="00010">
<othercit>Int. Search Report cited in PCT Application No. PCT/US2011/067378 dated Apr. 4, 2013, 20 pgs.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>25</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>10</number-of-drawing-sheets>
<number-of-figures>10</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20120166886</doc-number>
<kind>A1</kind>
<date>20120628</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Shankar</last-name>
<first-name>Hari</first-name>
<address>
<city>San Jose</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Liu</last-name>
<first-name>Huadong</first-name>
<address>
<city>Research Triangle Park</city>
<state>NC</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Li</last-name>
<first-name>Hua</first-name>
<address>
<city>Research Triangle Park</city>
<state>NC</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Shankar</last-name>
<first-name>Hari</first-name>
<address>
<city>San Jose</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Liu</last-name>
<first-name>Huadong</first-name>
<address>
<city>Research Triangle Park</city>
<state>NC</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Li</last-name>
<first-name>Hua</first-name>
<address>
<city>Research Triangle Park</city>
<state>NC</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Cooper Legal Group LLC</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>NetApp Inc.</orgname>
<role>02</role>
<address>
<city>Sunnyvale</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>McCarthy</last-name>
<first-name>Christopher</first-name>
<department>2113</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A novel RDMA connection failover technique that minimizes disruption to upper subsystem modules (executed on a computer node), which create requests for data transfer. A new failover virtual layer performs failover of an RDMA connection in error so that the upper subsystem that created a request does not have knowledge of an error (which is recoverable in software and hardware), or of a failure on the RDMA connection due to the error. Since the upper subsystem does not have knowledge of a failure on the RDMA connection or of a performed failover of the RDMA connection, the upper subsystem continues providing requests to the failover virtual layer without interruption, thereby minimizing downtime of the data transfer activity.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="219.79mm" wi="165.69mm" file="US08627136-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="243.84mm" wi="181.78mm" file="US08627136-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="246.13mm" wi="166.54mm" orientation="landscape" file="US08627136-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="253.41mm" wi="171.62mm" file="US08627136-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="255.69mm" wi="179.49mm" file="US08627136-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="252.31mm" wi="160.27mm" orientation="landscape" file="US08627136-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="233.68mm" wi="153.50mm" orientation="landscape" file="US08627136-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="168.74mm" wi="166.54mm" orientation="landscape" file="US08627136-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="224.11mm" wi="143.34mm" file="US08627136-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="238.76mm" wi="141.65mm" file="US08627136-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="240.45mm" wi="137.16mm" file="US08627136-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">FIELD OF THE INVENTION</heading>
<p id="p-0002" num="0001">Embodiments described herein relate generally to computer systems and more particularly to non-disruptive failover of Remote Direct Memory Access (RDMA) connection.</p>
<heading id="h-0002" level="1">BACKGROUND</heading>
<p id="p-0003" num="0002">RDMA technology reduces processor workload in the transmission and reception of data across a network between two computer nodes by transferring data directly from memory of local computer node to memory of a remote computer node without involving remote node CPU. RDMA technology is typically implemented by a specialized hardware which resides on each computer node. An RDMA write operation transfers data from the memory of a local computer node directly to the memory of a remote computer node; an RDMA read operation requests transfer of data from the memory of a remote computer node directly to the memory of local computer node. Each RDMA connection uses a pair of memory data structures, a send queue and a receive queue, that allows the computer node to post work requests to the RDMA capable hardware. There is also a completion queue that stores completion notifications for the submitted work requests. A send queue, a receive queue and a completion queue are referred to as a queue structure (QS) throughout this document. Once the RDMA connection is established, a computer node can post a request in a queue (send or receive queue). Each queue stores a request from the time it is posted by the node until the time it is processed. An interconnect adapter on the node is then notified by an interconnect driver on the same node that the request is posted. It reads the request in the queue and does the actual data transfer over a network. After the data are received, the interconnect adapter at the computer node that receives the data writes data directly to destination memory at the second computer node. Then a completion result is sent back to the first computer node. The interconnect adapter at the first computer node posts the result to its completion queue.</p>
<p id="p-0004" num="0003">According to RDMA protocols and known implementations, when an error occurs in a queue structure (QS), all pending requests in the QS are flushed and returned in error. Then QS management logic destroys the QS in error and creates a new QS for the purpose of establishing a new connection. The error status is communicated to an upper subsystem module (such as a file system, for example), which stops posting requests until the new QS is created. This, in turn, disrupts operation of the applications using the RDMA connection. Accordingly, it is highly desirable to maintain RDMA connection between two or more computer nodes barring legitimate error cases, e.g.&#x2014;transient software or hardware errors when processing an I/O request.</p>
<p id="p-0005" num="0004">One useful application of RDMA technology is controller failover in a cluster storage environment in which a first computer node may have a predetermined failover &#x201c;partner&#x201d; node (a second computer node) that may take over or resume storage services of the first computer node upon failure at the first computer node. For received write requests from a client(s), a node may produce write logs and store them in its non-volatile storage device (from which, the node may at a later time flush the write logs to the storage devices). To ensure data consistency and provide high data availability, the write logs may also be stored remotely to a non-volatile storage device at a partner node. The transfer of write logs between two partner nodes in a cluster storage system typically takes place using the RDMA technology so that data in a local non-volatile storage device at a first computer node may be transferred directly to a non-volatile storage device of a second computer node to provide failover protection (e.g., in case the first computer node crashes).</p>
<p id="p-0006" num="0005">Currently, when an error occurs on an RDMA connection (for example, during the transfer of write logs to a partner node), the error status is communicated to the upper subsystem on the first computer node. Since the RDMA connection is in error, the first computer node no longer transfers the write logs to its partner node, thereby making the logs unsynchronized. As a result, high availability functionality is no longer available to the clients accessing the nodes. As a corollary to this, one computer node can no longer initiate takeover of its partner node, thereby causing disruption to the clients when something happens to either one of the nodes. Accordingly, it is desirable to significantly increase RDMA connection uptime between the nodes for purposes of RDMA transfer.</p>
<heading id="h-0003" level="1">SUMMARY</heading>
<p id="p-0007" num="0006">Embodiments described herein provide a novel failover technique that minimizes disruption to upper subsystem modules (executed on a computer node), which create requests for data transfer. A new failover virtual layer performs failover of an RDMA connection in error between one or more computer nodes so that the upper subsystem that created a request does not learn about a failure (other than the physical link failure or unrecoverable hardware failure) on the RDMA connection. Since the upper subsystem does not have knowledge of a failure on the RDMA connection or of a performed failover of the RDMA connection, the upper subsystem continues providing requests to the failover virtual layer without interruption, thereby minimizing downtime of the data transfer activity. Embodiments described herein provide non-disruptive failover for errors, which can be recoverable in software and hardware. For example, when I/O processing rate is slower than incoming I/O request rate and a send or receive queue cannot accommodate more I/O requests, a new failover virtual layer can provide additional request buffering to alleviate this problem.</p>
<p id="p-0008" num="0007">More specifically, according to one embodiment described herein, the new failover virtual layer creates virtual queue structures (QS) in memory on a computer node. The term QS as used herein includes a send queue, a receive queue, and a completion queue. The queue structure is identified by memory addresses. While the memory addresses of the virtual queue structure are provided to the upper subsystem modules via QS handles, these addresses are not provided to an interconnect adapter that performs transfer of data over the RDMA connection. The failover virtual layer also creates physical queue structures in memory, each queue identified by a memory address. In contrast to the virtual queue structures, the memory addresses of the physical queue structures are not provided to the upper subsystem modules while they are provided to the interconnect adapter that performs transfer of data over the RDMA connection. The new failover virtual layer associates a virtual queue structure with one or more physical queue structures. Thus, while in conventional approaches, memory addresses of physical queue structures are provided to the interconnect adapter, which uses them to access the physical queue structures. According to the novel virtual failover technique, the memory addresses of virtual queue structures are not provided to the interconnect adapter.</p>
<p id="p-0009" num="0008">When a failure occurs on an RDMA connection (such that a request cannot be posted on a physical queue structure for various reasons) the failover virtual layer marks in error the physical queue structure storing a request. In addition, the result of the transmission (e.g., failure) is posted to a completion queue corresponding to the physical queue structure. Importantly, since the upper subsystem module is not provided with the memory addresses of the physical queue structure and completion queue, the upper subsystem module is not aware of the failure. As a result, the upper subsystem continues posting requests to the failover virtual layer without interruption.</p>
<p id="p-0010" num="0009">The failover virtual layer identifies a second physical queue structure that is not in error and moves outstanding requests from the physical queue structure in error to the second physical queue structure. Once the requests are moved to the second physical queue structure and data are successfully transferred over the RDMA connection, the result of the completion (i.e., success) is posted to a completion queue of the second physical queue structure. The failover virtual layer then moves the &#x201c;successful&#x201d; completion status to completion queue of the virtual queue structure. At this point, the upper subsystem becomes aware of the successful completion of the request. Thus, the failover virtual layer makes the upper subsystem immune from the failure occurring on an underlying RDMA connection. The novel failover virtual layer advantageously helps to increase high availability uptime between nodes in a cluster environment when an error occurs on RDMA connection. Since the failover can be performed transparently to the upper subsystem modules, these modules continue posting requests to the failover virtual layer without being aware of the error. As a result, synchronization of the write logs is continued between two or more nodes in a cluster and the nodes can provide high availability functionality to clients without interruption.</p>
<p id="p-0011" num="0010">Other applications of the inventive techniques include non-disruptive failover of RDMA connection involving sending status information between two computer nodes in a cluster. Such a transmission can be performed using RDMA connection directly from a memory location of a first storage node to a memory location of its partner node over a network. Other uses of the novel techniques involve non-disruptive RDMA transfer of data blocks between two or more nodes in a cluster. Thus, the inventive failover virtual layer provides for non-disruptive failover of an RDMA connection regardless of the nature of the RDMA transfer.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0012" num="0011">One or more embodiments of the present invention are illustrated by way of example and not limitation in the figures of the accompanying drawings, in which like references indicate similar elements and in which:</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 1</figref> is a schematic block diagram of an exemplary cluster environment in which some embodiments operate;</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 2</figref> is a schematic block diagram of various components of an exemplary node shown in <figref idref="DRAWINGS">FIG. 1</figref>;</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 3A</figref> is a schematic block diagram of the software and hardware components used to perform RDMA transfer according to prior art techniques;</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 3B</figref> is a schematic block diagram of the software and hardware components to perform RDMA failover according to inventive embodiments described herein.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 4</figref> is a block diagram of various queues in the virtual queue structures and physical queue structures according to inventive embodiments described herein;</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 5A</figref> is a block diagram of an exemplary data structure for storing information about virtual queue structures and association between virtual queue structures and one or more physical queue structures according to inventive embodiments described herein;</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 5B</figref> is a block diagram of an exemplary data structure for storing information about physical queue structures according to inventive embodiments described herein;</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 6</figref> is a flow diagram illustrating a process of establishing an RDMA connection between two nodes shown in <figref idref="DRAWINGS">FIG. 1</figref> according to inventive embodiments described herein;</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 7</figref> is a flow diagram illustrating transfer of data between two nodes shown in <figref idref="DRAWINGS">FIG. 1</figref> according to inventive embodiments described herein; and</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 8</figref> is a flow diagram illustrating a failover mechanism of an RDMA connection according to inventive embodiments described herein.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION</heading>
<p id="h-0006" num="0000">Cluster Environment</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 1</figref> illustrates a block diagram of one embodiment of an environment including a cluster <b>100</b> configuration. Those skilled in the art would understand that the cluster environment is shown in order to describe one possible application of the inventive techniques for providing a failover mechanism of an RDMA connection. The novel techniques can be implemented in any environment supporting RDMA transfer between a first and a second computer node over a network. Those skilled in the art would understand that the novel techniques can be implemented in an N-way system among two or more nodes. The cluster system configuration includes nodes <b>200</b><i>a </i>and <b>200</b><i>b </i>coupled by a dedicated high performance interconnect, e.g. <b>210</b>, which implements RDMA data transmission, using, for example, InfiniBand, or iWARP (Internet Wide Area RDMA Protocol) with different RDMA architectures such as the Virtual Interface Architecture (VIA) or Open Fabrics Alliance architecture (OFA). For ease of description, node <b>200</b><i>a </i>is said to be a source node and node <b>200</b><i>b </i>is said to be a target node. Data can be transferred over interconnect <b>210</b> using RDMA protocol.</p>
<p id="p-0024" num="0023">Each node is configured for providing data access services to clients connected with the node. When a failure occurs within node <b>200</b><i>a </i>so that node <b>200</b><i>a </i>is no longer capable of processing access requests for clients <b>140</b>, the partner node <b>200</b><i>b </i>is configured to automatically resume or take over the data-access service functions provided by the failed node <b>200</b><i>a</i>. As such, when a node failure occurs, access requests sent from clients <b>140</b> to the failed node <b>200</b><i>a </i>may be re-directed to the partner node <b>200</b><i>b </i>for processing and execution. Note that failure of a node may occur unintentionally or intentionally (e.g., where a node is taken offline for servicing). Those skilled in the art would understand that although <figref idref="DRAWINGS">FIG. 1</figref> illustrates one pair of partner nodes <b>200</b><i>a </i>and <b>200</b><i>b</i>, the cluster configuration may include more than one such pair, or the cluster configuration may have &#x201c;N&#x201d; interconnected nodes, where N is an integer greater than one. Continuing with the description of <figref idref="DRAWINGS">FIG. 1</figref>, in one embodiment, the nodes <b>200</b><i>a </i>and <b>200</b><i>b </i>may be storage servers in a storage server cluster. Alternatively, other types of nodes in cluster configurations may be used. The node <b>200</b><i>a </i>is coupled to storage devices <b>150</b><i>a</i>, which includes multiple storage devices (e.g., disks). It should be noted that while node <b>200</b><i>a </i>is connected to storage devices <b>150</b><i>a</i>, node <b>200</b><i>a </i>is also connected to and capable of reading to and from storage devices <b>150</b><i>b </i>since it is a partner node of node <b>200</b><i>b</i>. Similarly, while node <b>200</b><i>b </i>is connected to storage devices <b>150</b><i>b</i>, it is also connected to and is capable of reading to and from storage devices <b>150</b><i>a</i>. The node <b>200</b><i>b </i>is coupled to storage devices <b>150</b><i>b</i>, which includes multiple storage devices (e.g., disks). Storage devices <b>150</b><i>a </i>and <b>150</b><i>b </i>can be disks, solid state storage devices, such as flash memory, non-volatile storage device (NVRAM), Magnetic Random Access Memory (MRAM), Phase Change RAM (PRAM), etc. The storage devices can be organized as one or more RAID groups.</p>
<p id="p-0025" num="0024">The nodes <b>200</b><i>a </i>and <b>200</b><i>b </i>are also coupled through a network <b>120</b> to a number of clients <b>140</b> (hereinafter simply &#x201c;clients&#x201d;). The nodes <b>200</b><i>a </i>and <b>200</b><i>b </i>receive and respond to various read and write requests from the clients <b>140</b>, relating to volumes, directories, LUNs, files, blocks, objects, and/or other units of data stored in (or to be stored in) the storage devices <b>150</b><i>a </i>and <b>150</b><i>b</i>. The clients <b>140</b> may submit access requests by issuing packets using file-based access protocols, such as the Common Internet File System (CIFS) protocol or Network File System (NFS) protocol, over the Transmission Control Protocol/Internet Protocol (TCP/IP) when accessing information in the form of files and directories. The clients may also submit requests by issuing packets using block-based access protocols, such as the Small Computer Systems Interface (SCSI) protocol encapsulated over TCP (iSCSI) and SCSI encapsulated over Fibre Channel (FCP). Nodes <b>200</b><i>a </i>and <b>200</b><i>b </i>are capable of providing clients with both file-level access and block-level access. Each of the clients <b>140</b> may be, for example, a conventional personal computer (PC), workstation, or the like. Network <b>120</b> may be, for example, a local area network (LAN), a metropolitan area network (MAN), a virtual private network (VPN), a wide area network (WAN), a global area network (GAN) such as the Internet, or other type of network or combination of networks. The network <b>120</b> may implement, for example, Ethernet protocol, Fibre Channel Protocol (FCP), or another protocol or a combination of protocols.</p>
<p id="p-0026" num="0025">As described earlier, the interconnect connection between the two or more nodes (i.e. Interconnect <b>210</b>) can be disrupted for various reasons, such as when an input/output (I/O) processing rate is slower than the incoming I/O workload, which means that the requests cannot be posted to send or receive queues. If the interconnect connection between the two or more nodes is disrupted, the logs at the local node are no longer mirrored to the partner node, thereby making high availability functionality no longer available. As a consequence, when one node is no longer able to process write or read requests from clients, a partner node can no longer initiate a takeover due to the disrupted interconnect connection, thereby causing disruption to the clients. As illustrated in <figref idref="DRAWINGS">FIG. 1</figref>, each node in the cluster includes an interconnect adapter <b>232</b> (RNIC), which implements RDMA protocol. Using the RNIC, a source node (e.g., node <b>200</b><i>a</i>) initiates a connection with its partner node (such as target node <b>200</b><i>b</i>), while the partner node accepts the connection. The RNIC may enable a RDMA read, RDMA write and send/receive operations. For example, an RDMA write operation transfers data from a memory, e.g., <b>224</b> (shown in <figref idref="DRAWINGS">FIG. 2</figref>) of one node (e.g., node <b>200</b><i>a</i>) to a memory of a partner node (e.g., node <b>200</b><i>b</i>).</p>
<p id="p-0027" num="0026">To ensure data consistency and provide high data availability, data in a non-volatile storage device at a source node may be mirrored to a target non-volatile storage device of a target node. To this end, node <b>200</b><i>a </i>may further mirror the write logs in local log cache <b>170</b> to remote log cache (shown in <figref idref="DRAWINGS">FIG. 2</figref>) for guaranteeing completion of write requests on storage devices. When node <b>200</b><i>a </i>is not able to accept read/write requests, node <b>200</b><i>b </i>may then access log cache on node <b>200</b><i>b </i>to execute any remaining write operations uncompleted by node <b>200</b><i>a</i>. Consistency between log caches <b>170</b> is thus desirable to enable completion of write requests on storage devices <b>150</b>.</p>
<p id="h-0007" num="0000">Components of a Node</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 2</figref> is a schematic block diagram of an exemplary node <b>200</b><i>a </i>or <b>200</b><i>b </i>that may be implemented in cluster <b>100</b>. Node <b>200</b><i>a </i>may illustratively be embodied as a storage system comprising a processor <b>222</b>, a memory <b>224</b>, a network adapter <b>225</b>, a cluster access adapter <b>226</b>, a storage adapter <b>228</b> and non-volatile storage, e.g., NVRAM <b>230</b>. These components can be interconnected by a system bus <b>223</b>. Direct memory transmission between two or more nodes can be performed using an interconnect adapter (or device) <b>232</b>, which can be implemented as a RDMA enabled remote network interface card (RNIC) supporting RDMA protocol.</p>
<p id="p-0029" num="0028">Network adapter <b>225</b> comprises a plurality of ports adapted to couple node <b>200</b> to one or more clients <b>140</b> over point-to-point links, wide area networks, virtual private networks implemented over a public network (Internet) or a shared local area network. Network adapter <b>225</b> thus may comprise the mechanical, electrical and signaling circuitry needed to connect the node to the network. Each client <b>140</b> may communicate with node <b>200</b> over network <b>120</b> by exchanging discrete frames or packets of data according to pre-defined protocols, such as TCP/IP.</p>
<p id="p-0030" num="0029">Cluster access adapter <b>226</b> may comprises a plurality of ports adapted to couple a pair of partner nodes <b>200</b><i>a </i>and <b>200</b><i>b </i>to other pairs in the cluster through a cluster switching fabric, which is not shown in <figref idref="DRAWINGS">FIG. 1</figref> or <figref idref="DRAWINGS">FIG. 2</figref>. In the illustrative embodiment, Ethernet is used as the clustering protocol and interconnect media, although it will be apparent to those skilled in the art that other types of protocols and transports may be utilized within the cluster architecture described herein.</p>
<p id="p-0031" num="0030">Storage adapter <b>228</b> cooperates with storage operating system <b>300</b> stored in memory and executed by processor <b>222</b> to access data requested by clients <b>140</b>. Storage of data of storage devices can be organized as one or more volumes that comprise a collection of e.g., disks. The disks within a volume/file system are typically organized as one or more groups, wherein each group may be operated as a Redundant Array of Independent (or Inexpensive) Disks (RAID).</p>
<p id="p-0032" num="0031">Memory <b>224</b> illustratively comprises storage locations that are addressable by the processor <b>222</b> and adapters <b>225</b>, <b>226</b>, <b>228</b> for storing program instructions and data in some embodiments. The processors and adapters may, in turn, comprise processing elements and/or logic circuitry configured to execute the instructions and manipulate the data stored in memory <b>224</b>. In some embodiments, memory <b>224</b> may comprise a form of random access memory (RAM) comprising &#x201c;volatile&#x201d; memory that is generally cleared by a power cycle or other reboot operation.</p>
<p id="p-0033" num="0032">Storage operating systems <b>300</b>, portions of which are typically resident in memory <b>224</b> and executed by the processing elements, functionally organizes node <b>200</b> by invoking operations in support of the storage services implemented by the node. It will be apparent to those skilled in the art that other processing and memory means, including various computer readable media, may be used for storing and executing program instructions pertaining to the invention described herein. In some embodiments, the storage operating system <b>300</b> comprises a plurality of software layers that are executed by processor <b>222</b>. These software layers are described in more detail in reference to <figref idref="DRAWINGS">FIG. 3B</figref>.</p>
<p id="p-0034" num="0033">Nov-volatile storage element, such as NVRAM <b>230</b> locally stores information relating to access requests from clients <b>140</b>. Preferably, NVRAM may be implemented to store write logs corresponding to write requests from clients <b>140</b> in the event of a system shutdown or other unforeseen problem. To that end, write logs may be generated by storage operating system <b>300</b> upon receipt of a write request from client <b>140</b> for carrying out the requested write operation at a later time. All or a predetermined portion of NVRAM may thus be implemented as a log cache <b>170</b> for storing write logs for deferred write requests. Log cache can be stored on other type of media or device suitable for storing instructions and data thereon.</p>
<p id="p-0035" num="0034">Interconnect adapter (device) <b>232</b> may be implemented as a RNIC to support RDMA operations defined by the RDMA protocol. RNIC at each node typically implements the RDMA protocol. Interconnect adapter can be a commercially available product.</p>
<p id="p-0036" num="0035">At this point, it is useful to describe how a typical RDMA connection is established to transfer data between two computing devices, such as storage systems <b>200</b><i>a </i>and <b>200</b><i>b</i>. Such a connection may be established, for example, in order to send write logs between the storage systems. To assist with the understanding how a typical RDMA transfer takes place over an established RDMA connection, <figref idref="DRAWINGS">FIG. 3A</figref> is provided.</p>
<p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. 3A</figref> illustrates various components of a computer node (such as node <b>200</b> shown in <figref idref="DRAWINGS">FIG. 1</figref>) used to establish RDMA connection between two or more nodes according to known implementations. <figref idref="DRAWINGS">FIG. 3A</figref> illustrates various modules executed in the operating system <b>300</b>. These modules are upper subsystem <b>310</b> modules and an interconnect layer <b>320</b>. The upper subsystem modules <b>310</b> may include a file system (which can be implemented as a Write Anywhere File System (WAFL) provided by NetApp, Inc. of Sunnyvale, Calif.), a redundant array of inexpensive disks (RAID) subsystem, or any other subsystem that creates a data request, which is provided to the interconnect layer <b>320</b>). The interconnect layer <b>320</b> of the operating system <b>300</b> may include the following components: a queue structure (QS) management module <b>330</b>, a pool of physical queue structures <b>340</b>, and an interconnect driver <b>350</b>. Queue structure management module <b>330</b> is responsible for creating physical queue structures (which include a send queue, a receive queue, and a completion queue), in response to a request from the upper subsystem <b>310</b>. An exemplary queue structure is shown in FIG. <b>4</b> and described below in reference to <figref idref="DRAWINGS">FIG. 4</figref>. As will be described in more detail below, queue structure management module <b>330</b> is also responsible for connecting the queue structures at a first computer node with queue structures at a second computer node connected over a network. Physical QS pool <b>340</b> is essentially a number of physical queue structures created by a QS management module <b>330</b> under direction of a module in the upper subsystem <b>310</b>. Each request is stored in the send queue or receive queue from the time it is posted by the QS management module until the time it is processed. The memory needed to create a physical queue structure may be allocated from the node's memory (e.g., <b>224</b>) or from any other accessible resources by the interconnect adapter. The allocated memory addresses are usually contiguous. Physical QSs should be distinguished with virtual QSs, which are created by a novel failover virtual layer (shown in <figref idref="DRAWINGS">FIG. 3B</figref>). A notable distinction between a physical queue structure and a virtual queue structure in that while the memory addresses of a physical queue structure are provided to the interconnect adapter <b>232</b>, which can access requests from the physical QS, the memory addresses of a virtual queue structure are not provided to the interconnect adapter, as will be described in greater detail below. The virtual QSs are accessible only to the upper subsystem via QS handles, which means that the memory handles of the VQS are provided to the upper subsystem. In conventional approaches, memory addresses of physical queue structures are provided to the interconnect adapter, which uses them to access the physical queue structures. According to the novel virtual failover technique, the memory addresses of virtual queue structures are not provided to the interconnect adapter.</p>
<p id="p-0038" num="0037">Still with reference to <figref idref="DRAWINGS">FIG. 3A</figref>, the operating system <b>300</b> further includes an interconnect driver <b>350</b> configured to manage the interconnect adapter <b>232</b>. Interconnect driver <b>350</b> is responsible for establishing connection between the two or more nodes and notifying the upper subsystem that the connection is established. As part of setting up the connection, physical QSs are created at the second computer node.</p>
<p id="p-0039" num="0038">It is now useful to describe how a typical RDMA connection is established according to existing known techniques. Initially, the upper subsystem initiates a call to the QS management module to create physical QSs in memory, e.g., <b>224</b>. Thus, creating the QSs essentially means creating data structures in memory and providing addresses of QSs in memory to the interconnect adapter. The QS management module then instructs the interconnect adapter to connect physical QSs at the source node with the physical QSs at the destination node by exchanging information, as defined by the RDMA protocol. As part of this procedure, physical QSs may be created at the target node if they are not already present.</p>
<p id="p-0040" num="0039">After the connection is established, the upper subsystem may send an RDMA write request to the QS management module. The request includes a source address (location in memory from which data to be transferred) and a destination address (location in memory where data to be stored as part of the RDMA operation). The QS management module posts the request into the physical send queue. Posting the request essentially means recording the request in a memory location (send queue in this case). The queue structure management module notifies the interconnect adapter, e.g., <b>232</b>, at the source node, that a new request is posted to the QS. Once the interconnect adapter receives notification, it uses the memory addresses of the QS to access the request. From the request, it identifies memory location of the data. The interconnect adapter accesses the data in memory (in the example of mirroring write logs between two storage systems, the data may include the write logs to be mirrored at the partner storage system). The interconnect adapter sends the data along with the destination addresses to the second computer device.</p>
<p id="p-0041" num="0040">When the request arrives at the second computer device, e.g., <b>200</b><i>b</i>, the interconnect adapter (e.g., <b>232</b> shown in <figref idref="DRAWINGS">FIG. 1</figref>) at <b>200</b><i>b </i>reads the destination address from the request and stores the data to the destination address in memory.</p>
<p id="p-0042" num="0041">Interconnect adapters at the storage systems <b>200</b><i>a </i>and <b>200</b><i>b </i>are capable to communicate with each other using the RDMA protocol. The interconnect adapter at the storage system <b>200</b><i>a </i>receives a completion status from the target partner node. Completion status can be marked as &#x201c;successful&#x201d; or &#x201c;failure&#x201d;, for example. The status is posted into the completion queue associated with a physical QS where the request was posted.</p>
<p id="p-0043" num="0042">As described herein, when an error occurs on the RDMA connection, the queues are transitioned to an error state so that all outstanding requests are returned in error to the completion queue, thereby disabling RDMA connection. The upper subsystem then instructs the interconnect layer to create a new QS and tries to reestablish the connection after the failure is observed. In the meantime, the upper subsystem stops creating new requests until the new connection is established. All failed requests and any additional requests are sent over the new connection. To minimize the downtime of the RDMA connection and minimize disruption to the upper protocol modules, the novel failover virtual layer is provided, as described below.</p>
<p id="h-0008" num="0000">Failover Virtual Layer</p>
<p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. 3B</figref> illustrates node <b>200</b> executing operating system <b>300</b>, which in turn includes a novel failover virtual layer <b>320</b> configured to minimize disruption to the upper subsystem modules. As illustrated in <figref idref="DRAWINGS">FIG. 3B</figref>, upper subsystem <b>312</b> communicates with the failover virtual layer <b>322</b> by creating requests and providing the requests to the failover virtual layer. Upper subsystem also receives completion results from the failover virtual layer <b>322</b>. Thus, failover virtual layer <b>322</b> is an intermediary between the upper subsystem and the interconnect adapter.</p>
<p id="p-0045" num="0044">Failover virtual layer <b>322</b>, in turn, includes the following components: a virtual queue structure management module <b>370</b>, a monitoring module <b>380</b>, a request scheduling module <b>360</b>, and an interconnect driver <b>350</b>. Importantly, the failover virtual layer <b>322</b> creates virtual QSs <b>343</b> and physical QSs <b>345</b>, as described herein.</p>
<p id="p-0046" num="0045">Upper subsystem <b>312</b> may be a file system (which can be implemented as a Write Anywhere File System (WAFL) provided by NetApp, Inc. of Sunnyvale, Calif.), a redundant array of inexpensive disks (RAID) subsystem, or any other subsystem that creates requests for data transfer and provides them to the failover virtual layer.</p>
<p id="p-0047" num="0046">Virtual queue structure management module <b>370</b> is configured to create virtual QSs and physical QSs. Addresses of physical QSs are registered with the interconnect adapter, which means they are communicated to the interconnect adapter. As such, physical QSs are accessible to the interconnect adapter. Addresses of virtual QSs are not communicated to the interconnect adapter, thereby &#x201c;hiding&#x201d; the virtual QSs from the interconnect adapter. Virtual QS management module is further configured to perform failover of RDMA connection when an error is detected on an existing RDMA connection. Importantly, the failover is performed in such a way that the upper subsystem is not aware of the error. Virtual QS management module further maintains information about virtual QSs and physical QSs. Virtual QS management module <b>370</b> interacts with the request scheduling module <b>360</b><i>a </i>and monitoring module <b>380</b>. Module <b>370</b> communicates with the interconnect adapter <b>232</b> via interconnect drivers <b>350</b>. For example, module <b>370</b> passes to interconnect driver <b>350</b> address of a physical QS where a request(s) is posted. The interconnect adapter uses this information to access the request from the QS, access data in the memory where the data are stored, and perform RDMA transfer of the data over the interconnect.</p>
<p id="p-0048" num="0047">Request scheduling module <b>360</b> of the failover virtual layer <b>322</b> is configured to select a physical queue structure where a request should be posted. Module <b>360</b> is responsible for moving the requests from a virtual QS to the physical QS as well as moving a completion status from the physical QS to the virtual QS. Scheduling module <b>360</b> is also configured to load balance the requests among physical QSs. According to novel techniques described herein, physical queue structures can be active and standby. An active queue structure is a queue structure where the request is posted for transmission while a standby queue structure is a queue structure that does not have a request queued to it. Those skilled in the art would understand that requests can only be posted to active queue structures. Thus, module <b>360</b> is configured to identify available active physical queue structure by, for example, querying a data structure in memory, which maintains information about physical queue structures (e.g., data structure <b>500</b> and <b>502</b> shown in <figref idref="DRAWINGS">FIG. 5</figref>). A decision as to which queue structure to choose can be based, for example, on the work load of a queue structure, capability of a queue structure, as well as other factors. When a request is sent from the upper subsystem module to a virtual queue structure, the request scheduling module is configured to determine which physical queue structure should store the request. Interconnect driver <b>350</b> is responsible for managing interconnect adapter(s) and for passing communication between physical queue structure pool and the interconnect adapter.</p>
<p id="p-0049" num="0048">Monitoring module <b>380</b> is responsible for monitoring physical queue structures to determine if a queue structure is in the error state. If the physical queue structure is in the error state, monitoring module <b>380</b> notifies VQS management module <b>370</b> so that it won't be used by the scheduling module <b>360</b> for posting a new request.</p>
<p id="p-0050" num="0049">Virtual QSs <b>343</b> are data structures created in memory by the virtual QS management module <b>370</b>. Referring now to <figref idref="DRAWINGS">FIG. 4</figref>, which illustrates exemplary virtual QS in more detail. An exemplary virtual QS, in one implementation, can have a send queue <b>412</b>, a receive queue <b>414</b>, and a completion queue <b>416</b>. Send queue is a queue where module <b>360</b> posts requests to do RDMA read, write and send operations; a receive queue <b>414</b> is where module <b>360</b> posts receive requests, and a completion queue <b>416</b> is where the completion results are posted. Exemplary completion results can be &#x201c;success&#x201d; and &#x201c;failure&#x201d;. Each queue can have a number of buffers, each buffer, for example, can store a request. A queue can be identified by an address in memory. Such address is provided to the upper subsystem via the QS handle. Importantly, an address of a virtual QS is not provided to the interconnect adapter, thereby preventing the interconnect adapter from directly notifying the virtual QS about the completion status. As such, the VQS are not accessible to the interconnect adapter. Upon creation of the virtual QS, virtual QS management module provides a receive size and a transmit size of its queues. The size of a queue essentially indicates the number of send or receive requests that can be posted to a queue. Virtual QSs are used by virtual QS module to post the requests prior to posting them to the physical QSs, thereby acting as buffers for requests prior to them being posted to the physical QS. Any number of virtual QSs can be created as long as the memory capacity permits.</p>
<p id="p-0051" num="0050">Physical QSs <b>345</b> are data structures created in memory by the virtual QS module. As demonstrated in <figref idref="DRAWINGS">FIG. 4</figref>, an exemplary physical QS can have a send queue <b>422</b>, a receive queue <b>424</b>, and a completion queue <b>426</b> where the completion results, such as &#x201c;success&#x201d; or &#x201c;failure&#x201d; are posted. Each physical queue can have a number of buffers, each buffer, for example, can store a request. A queue can be identified by an address in memory. Such an address is provided to an interconnect adapter on the node where the QSs are created. Importantly, the addresses of physical QSs are not provided to the upper subsystem module, thereby making the upper subsystem unaware of a potential failure in the physical QS. Upon creation of the physical QS, virtual QS management module provides a receive size and a transmit size of its queues. A virtual QS can be associated with more than one physical QS. Thus, although <figref idref="DRAWINGS">FIG. 4</figref> illustrates only two physical QSs, any number of physical QSs can be created.</p>
<p id="p-0052" num="0051">At this point, it is useful to describe various methods performed by the novel failover virtual layer <b>322</b>. The description that follows is divided into three sections. The &#x201c;Creation of Virtual and Physical QSs&#x201d; section describes novel mechanism of creation of virtual QSs and physical QSs and associating virtual queue structures with physical queue structures. The &#x201c;Data Transfer on RDMA Connection&#x201d; section describes a novel process of servicing a request over a network using RDMA connection. The &#x201c;Failover of RDMA Connection&#x201d; section discusses failover of RDMA connection when an error is detected. It should be noted that each section recites multiple steps, as will be described in reference to <figref idref="DRAWINGS">FIGS. 6 through 8</figref>.</p>
<p id="h-0009" num="0000">Creation of Virtual and Physical QSs</p>
<p id="p-0053" num="0052">Referring now to <figref idref="DRAWINGS">FIG. 6</figref>, a flowchart is provided to illustrate various steps to generate virtual queue structures (VQS) and to connect virtual queue structures and physical queue structures with remote virtual queue structures and physical queue structures. Initially, at step <b>610</b>, the virtual queue structure management module receives a request from the upper subsystem to create a QS for data transfer to and from its peer upper subsystem at the target node.</p>
<p id="p-0054" num="0053">In response to the request, virtual QS management module creates a virtual queue structure by allocating memory buffers in memory (e.g., <b>224</b>) for the queue structure, which may include a send queue, a receive queue, and a completion queue (step <b>615</b>). Virtual queue structure management module provides queue structure attributes, such as a queue size. Importantly, the virtual queue management module does not register the created virtual queue structures with the interconnect adapter, which essentially means that the addresses of the virtual queues in memory are not communicated to the interconnect adapter. As described herein, &#x201c;registering queue structures with the interconnect adapter&#x201d; means communicating the memory addresses of the queue structures to the interconnect adapter. Thus, the interconnect adapter cannot access VQS and VQSs are used as a staging area before the requests are posted to the physical queues.</p>
<p id="p-0055" num="0054">Once the virtual queue structures are created, the virtual queue structure management module notifies the upper subsystem module and returns a handle associated with the virtual queue structure. Such a handle is used to uniquely identify the virtual queue structure. It should be noted that module <b>370</b> can create as many virtual queue structures as the memory capacity permits.</p>
<p id="p-0056" num="0055">At step <b>620</b>, virtual queue structure management module <b>370</b> at a source node creates physical queue structures and registers the physical queue structures with the interconnect adapter at the first computer node. Registering physical queue structures with the interconnect adapter means communicating the memory addresses of the queue structures to the interconnect adapter. Other information that is typically passed to the interconnect adapter upon queue structure creation may include capabilities of the queues and the number of requests supported. It should be noted here that unlike known implementations, which were described in reference to <figref idref="DRAWINGS">FIG. 3A</figref>, the upper subsystem modules are not aware of the physical queue structures created by the virtual queue structure management module. Thus, from the upper subsystem standpoint, only virtual queue structures are created. This distinction is important since an error on a physical queue structure is not communicated to the upper subsystem modules directly, as described in more detail herein.</p>
<p id="p-0057" num="0056">Still with reference to <figref idref="DRAWINGS">FIG. 6</figref>, at step <b>630</b>, after the upper subsystem module receives the handle uniquely identifying the created virtual queue structure(s), such as ID, the upper subsystem initiates connection between the two or more nodes through the virtual queue structure management module. In the known prior art implementations, a physical queue structure at a source node is connected with a physical queue structure on a target node over the network. However, since the inventive techniques create both virtual queue structures and physical queue structures, module <b>370</b> initiates connection between a virtual queue structure at the source node and a virtual queue structure at the target node. During the connection negotiation process, virtual queue structure management module starts the queue structure connection process on a selected physical queue structure from the pool. The actual connection negotiation is performed using well-known client-server connection processes by which a first node sends a request to a second node, which is listening on one of its ports. During the process, the first node and second node exchange information to establish the connection. Once the connection is created among queue structures at the first and second node connected over the RDMA interconnect, virtual queue structure management module is notified.</p>
<p id="p-0058" num="0057">Once the connection between a source node and a target node is established, the virtual queue structure management module <b>370</b> selects a physical queue structure that is in the active state and associates each VQS with one or more physical QSs (step <b>640</b>). Associating a virtual queue structure with one or more physical queue structures (which are registered with the interconnect driver) may involve selecting an active physical queue structure from a pool of physical queue structures and providing a reference from the virtual QS to the active physical QS, for example, in a data structure (e.g., <b>500</b>).</p>
<p id="p-0059" num="0058">Module <b>370</b> keeps information about each queue structure. To this end, in one implementation, the Virtual QS management module queries data structure <b>500</b> shown in <figref idref="DRAWINGS">FIG. 5</figref> to determine the state of the queue structures. Once at least one physical queue structure on the first node is connected to a physical queue structure at the second node, the virtual queue structures are said to be connected and the upper-subsystem module is notified.</p>
<p id="p-0060" num="0059">Now with reference to <figref idref="DRAWINGS">FIG. 5A</figref>, data structure <b>500</b> for storing information about virtual queue structures and association between virtual queue structures and physical queue structures according to novel embodiments is illustrated. Such a data structure can be stored in memory <b>224</b>. Those skilled in the art would understand that although data structure <b>500</b> illustrates specific fields, other fields can be included in data structure <b>500</b>. Similarly, some of the fields can be omitted in other implementations.</p>
<p id="p-0061" num="0060">Field <b>505</b> stores information about an upper subsystem module that posted a request to the virtual QS management module. Such a subsystem module can be a file system, a RAID subsystem, or any other subsystem on the node). Those skilled in the art should understand that any number of virtual QSs can be created.</p>
<p id="p-0062" num="0061">Field <b>510</b> maintains a unique identifier (ID) of a virtual queue structure (VQS). Such an ID is assigned to the VQS upon its creation by e.g., virtual queue structure management module. The upper subsystem obtains the ID of the VQS when it is created and uses the VQS ID to submit a request to the queue structure and to check if any request submitted to the VQS is completed.</p>
<p id="p-0063" num="0062">Field <b>515</b> maintains the state of a virtual queue structure. The state can be, for example, CONNECTED, ERROR, or IDLE. According to one embodiment, as long as a physical queue structure associated with a virtual queue structure is in a CONNECTED state, VQS state is CONNECTED.</p>
<p id="p-0064" num="0063">Field <b>520</b> maintains information about a type of a queue on the virtual queue structure. As described herein, RDMA protocol uses a send, receive, and a completion queues to send requests, post receive buffers, and maintain a completion status, respectively.</p>
<p id="p-0065" num="0064">Field <b>530</b> maintains information about physical queue structures associated with the virtual queue structures as will be described in connection with <figref idref="DRAWINGS">FIG. 5B</figref> where data structure <b>502</b> storing information about physical QSs is shown.</p>
<p id="p-0066" num="0065">An exemplary entry in data structure <b>500</b> is illustrated. As shown in <figref idref="DRAWINGS">FIG. 5A</figref>, an exemplary entry includes a name of an upper subsystem module that initiated the RDMA connection (i.e., RAID), the VQS ID number (e.g., VQS#1), the state of the VQS (CONNECTED), a send queue, a receive queue, and a completion queue. The data structure further includes field <b>530</b> storing unique IDs of physical queue structures associated with the virtual queue structure.</p>
<p id="p-0067" num="0066">Exemplary data structure <b>502</b> storing information about physical QSs is illustrated in <figref idref="DRAWINGS">FIG. 5B</figref>. Field <b>535</b> maintains an ID of a physical QS, field <b>540</b> maintains information about a state of a physical queue structure. The state can be, for example, CONNECTED, ERROR, or IDLE. Additional status information in data structure <b>502</b> may include a status of a physical queue structure, i.e., ACTIVE or STANDBY. As used herein, an active queue structure is the physical queue structure that is used to perform data transfer while the standby queue structure is a physical queue structure that is not used in the data transfer. As will be described in more detail below, the distinction between an active and standby queue structure is important since according to novel embodiments described herein, when an active queue structure is in error, a request is posted to a standby queue structure, which essentially becomes an active queue structure. This way the connection does not need to be reestablished or worse yet the error does not need to be propagated to the upper subsystem module that initiated the data transfer.</p>
<p id="p-0068" num="0067">Field <b>550</b> maintains information about a type of the queue on the physical queue structure, such as a send, receive, or completion queue. An exemplary entry in data structure <b>502</b> may include an ID of the physical QS, a status (such as CONNECTED and ACTIVE or CONNECTED and STANDBY). The entry may include an ID of the request queues (such as send and receive queues). Status of the completion queue (such as having completions or Empty) can be determined by looking at the completion queue. &#x201c;Empty&#x201d; indicates that the completion result was moved to a completion queue of a VQS.</p>
<p id="p-0069" num="0068">Those skilled in the art would understand that although two data structures (e.g., <b>500</b> and <b>502</b>) are illustrated for storing information about virtual and physical queue structures, in other implementations, one data structure combining information about virtual and physical QSs can be used.</p>
<p id="p-0070" num="0069">Once the connection is established and the virtual queue structures are associated with one or more physical queue structures, module <b>370</b> notifies the upper subsystem module that it is ready to perform a data transfer.</p>
<p id="h-0010" num="0000">Data Transfer on RDMA Connection</p>
<p id="p-0071" num="0070">In one implementation, the steps described herein are performed by the upper subsystem, the virtual queue structure management module residing within the failover virtual layer at node <b>200</b><i>a </i>and the interconnect adapter. Those skilled in the art would appreciate that these steps can be performed by other components within a node. RDMA write operation is used as an example in this section.</p>
<p id="p-0072" num="0071">Initially, at step <b>705</b>, failover virtual layer, specifically, the queue structure management module <b>370</b> receives a request from the upper subsystem module (such as a file system, RAID, or any other subsystem of node <b>200</b>). In one embodiment, the request includes an address in memory at a first node where data are stored and an address in memory at a second node where data to be written. The nature of the data to be transferred depends on the type of the RDMA operation initiated by the upper subsystem module. For example, in one implementation, the data may represent write logs to be transferred from node <b>200</b><i>a </i>to node <b>200</b><i>b</i>. In other implementations, the data may include the node status information to be directly transferred to a memory of a partner node. Yet in other applications, the data may include changes to data blocks on the node <b>200</b><i>a </i>to be transferred directly to node <b>200</b><i>b</i>. Importantly, such data will be sent over a network from a memory of node <b>200</b><i>a </i>directly to a memory of node <b>200</b><i>b </i>over RDMA connection. In one embodiment, upon receiving the request from the upper layer module, module <b>370</b> gathers the source address and the destination address from the request and generates a local request based on this information. The local request may include the source address, the destination address, and length of the memory region. Module <b>370</b> then posts the local request to either a send or receive queue of the virtual queue structure in memory (step <b>710</b>). In addition, module <b>370</b> posts the request to the send or receive queue of the active physical queue structure physical queue structure in memory (step <b>720</b>). The active physical queue structure physical queue structure is associated with the VQS. As used herein, posting the request means copying the request to the memory location of a queue. In one implementation, the request scheduling module <b>360</b> helps to identify an active physical QS where the request can be posted.</p>
<p id="p-0073" num="0072">Upon posting the request in the VQS and physical QS, module <b>370</b> notifies (step <b>725</b>) the interconnect driver <b>350</b> that a request is posted to the active physical queue structure (which was selected by the request scheduling module, for example) by, i.e., providing an address in memory of the active physical queue structure. The interconnect driver <b>350</b>, in turn, notifies the interconnect adapter <b>232</b> that the request is posted. The interconnect adapter is only aware of the physical QSs created in memory and does not have knowledge about the created VQSs.</p>
<p id="p-0074" num="0073">The interconnect adapter, in turn, uses the address of the active physical queue structure to access the request in the physical QS. The interconnect adapter then obtains the source memory address of the data from the physical QS on the first node. The interconnect adapter then composes a data packet, which includes a source address, destination address, and data. The interconnect adapter then performs transfer of the data packet over the established RDMA connection to the second node (step <b>730</b>). When the data packet arrives at the second node, the interconnect adapter at the second node uses the destination address in the request to write the data directly to the memory at the second node. The interconnect adapters <b>232</b><i>a, b </i>(shown in FIG. <b>1</b>) at the first node and at the second node use RDMA protocol primitives to communicate. Thus, when the data are written to the memory at the second node, the interconnect adapter <b>232</b><i>b </i>at the second node communicates to the first node the completion status. The interconnect adapter <b>232</b><i>a </i>at the first node (i.e., node <b>200</b><i>a</i>), in one implementation, stores the completion status in the completion queue of the active physical queue structure (step <b>735</b>). The interconnect adapter <b>232</b><i>a </i>at the first node posts the completion status to the completion queue of the active physical queue structure rather than in that of the virtual queue structure since it is not aware of the virtual QS. As a corollary of this, while the interconnect adapter is aware of the status of the request completion, the upper subsystem module that created the request does not become aware of the request completion until after the completion status is moved to the completion queue of the virtual queue structure associated with the active physical queue structure, as further explained.</p>
<p id="p-0075" num="0074">At step <b>740</b>, request scheduling module examines the completion status. If the completion status is successful, i.e., the data transfer took place, request completion module moves the completion status from the completion queue of the active physical queue structure and puts it in the completion queue of the virtual queue structure. Now that the completion status is moved to the completion queue of the virtual queue structure, the upper subsystem module can examine the completion queue of the virtual queue structure. Thus, according to novel techniques described herein, the upper subsystem modules can become aware of the successful completion of the RDMA transfer only after the completion request is moved to the VQS accessible to the upper subsystems. As used herein, the term &#x201c;accessible&#x201d; means that the upper subsystems are configured to receive memory addresses of virtual queue data structures. If the completion status is a &#x201c;failure&#x201d;, the upper subsystem does not learn about the failover while the virtual QS management module performs failover of RDMA connection from one physical connection to another physical connection without disrupting the upper subsystem. Novel steps for providing non-disruptive failover of RDMA connection are described below in connection with <figref idref="DRAWINGS">FIG. 8</figref></p>
<p id="h-0011" num="0000">Failover of RDMA Connection</p>
<p id="p-0076" num="0075">Monitoring module <b>380</b> of the failover virtual layer periodically polls physical QSs in the pool of QSs to determine if any of the QSs are in error. Monitoring module <b>380</b> is in one implementation the recipient of all connection status notifications from the interconnect adaptor as well. If module <b>380</b> sees that one of the QSs is in error, it provides an indication that this particular QS cannot be used (step <b>810</b>). In one implementation, such an indication can be provided in data structure <b>502</b>, which maintains information about QSs. Request scheduling module <b>360</b> selects other physical QSs, which are associated with the virtual QS (step <b>820</b>). To this end, in one implementation, module <b>370</b> queries data structure <b>500</b> to identify other physical QSs associated with the virtual QS, which are not in the error state. Virtual QS management module prepares a standby physical QSs associated with the virtual QS to accommodate possible non-disruptive failover process in the future. For example, exemplary entry for physical QS#2 in data structure <b>502</b> indicates that it is in a standby state. Upon finding another physical QS, module <b>360</b> makes this QS an active QS, by for example, moving outstanding requests from the physical QS in error to the new active physical QS (step <b>830</b>). Moving the outstanding requests from one QS to another QS means copying the requests from one QS to another QS. Importantly, the upper subsystem does not have any information about the error that occurred on the active QS because the upper subsystem is not aware of the physical QSs created by module <b>370</b>. After selecting a new active physical QS to perform the RDMA transfer, virtual QS management module <b>370</b> notifies the interconnect driver that the request is posted to another physical QS. The interconnect driver, which manages the interconnect adapter, communicates to the interconnect adapter that the request is posted to a new physical QS (step <b>840</b>). In one implementation, the interconnect adapter obtains a memory handle of the active physical QS where the request is stored. The interconnect adapter uses the memory handle to access the request. The interconnect adapter <b>232</b><i>a </i>at the first computer node then uses the source address indicated in the request to access data in memory. The interconnect adapter then composes a data packet, which includes the source address, destination address, and data. The interconnect adapter sends the data packet over the RDMA connection (step <b>845</b>), which was earlier established.</p>
<p id="p-0077" num="0076">Once the request is completed, the interconnect adapter <b>232</b><i>a </i>at the source node receives an indication from interconnect adapter <b>232</b><i>b </i>at the second node. The interconnect adapter <b>232</b><i>a </i>at the first node updates the completion queue of the active physical QS where the outstanding requests were moved (step <b>850</b>).</p>
<p id="p-0078" num="0077">Once the completion status is posted to the physical QS, scheduling module accesses the completion queue of the physical QS where the requests were moved, determines that the completion status is successful, and moves the completion status to the completion queue of the virtual QS (step <b>860</b>). Upper subsystem periodically polls the completion status of the virtual QS. Thus, the upper subsystem learns that the request was successfully completed. Since the upper subsystem does not have any knowledge that a physical QS was in error and another physical QS was selected to perform the RDMA transfer, the upper subsystem continues creating requests for data transfer and providing them to the virtual QS management module without interruption. As a corollary to this, the failover mechanism performed by module <b>370</b> does not cause disruption to the upper subsystem.</p>
<p id="p-0079" num="0078">Although embodiments described herein, for the purpose of explanation, have been described with reference to specific exemplary embodiments, it will be understood that the embodiments describe herein are not limited to any specific implementation. For example, embodiments described herein can be practiced on any device. A person of ordinary skill in the art would understand that the inventive principles can be practiced with modifications and alternations to those embodiments or can be practiced in other embodiments within the spirit and scope of the appended claims. Also, those skilled in the art should note that the terms &#x201c;source node&#x201d;, &#x201c;first storage system&#x201d;, and &#x201c;first computer node&#x201d; or &#x201c;first node&#x201d; are used interchangeably herein. Similarly, the terms &#x201c;destination node&#x201d;, &#x201c;target node&#x201d;, and &#x201c;second computer node&#x201d; are used interchangeably herein. Unless specifically stated otherwise, it is to be appreciated that throughout the discussions utilizing terms such as &#x201c;processing&#x201d; or &#x201c;computing&#x201d; or &#x201c;determining&#x201d; or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical (e.g. electronic) quantities within the computer systems registers and memories into other data similarly represented as physical quantities within the computer system.</p>
<p id="p-0080" num="0079">The present novel embodiments described herein can be implemented by apparatuses for performing the operations herein. These apparatuses may be specially constructed for the required purposes or they may comprise a machine, such as a general-purpose computer selectively activated or reconfigured by a computer program (such as a collection of instructions for execution by a machine or processor for example) stored in the computer. Such a computer program may be stored in a computer readable storage medium, such as, but not limited to any type of disk including floppy disks, optical disks, magnetic optical disks, flash storage devices, read-only memories, random access memories, EPROMS, EEPROMS, magnetic or optical cards or any type of media suitable for storing physical (e.g. electronic) constructions and each coupled to a computer system bus. Each of these media may be coupled to a computer system bus through use of an appropriate device for reading and or for writing the media.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A system for performing non-disruptive failover of an RDMA connection between a first computer node and a second computer node, the system comprising:
<claim-text>an upper subsystem module at the first computer node configured to create a request; and</claim-text>
<claim-text>a failover virtual layer in communication with the upper subsystem module at the first computer node, the failover virtual layer configured to establish the RDMA connection between the first computer node and the second computer node, to detect an error on the RDMA connection and perform a failover of the RDMA connection so that the upper subsystem module does not have knowledge of the error on the RDMA connection and the upper subsystem module continues providing requests to the failover virtual layer while the RDMA connection sustained the error, wherein the failover virtual layer is further configured to create at least one virtual queue structure (VQS), a VQS accessible by the upper subsystem module and not accessible by an interconnect adapter at the first computer node.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the failover virtual layer is further configured to create at least two VQSs.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the failover virtual layer is further configured to create a physical queue structure (PQS) associated with the VQS.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the failover virtual layer is further configured to:
<claim-text>receive a completion status from the interconnect adapter;</claim-text>
<claim-text>post the completion status at a physical queue structure (PQS); and</claim-text>
<claim-text>responsive to the completion status being successful, move the completion status to the VQS, the VQS associated with the PQS.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. A system for performing non-disruptive failover of an RDMA connection between a first computer node and a second computer node, the system comprising:
<claim-text>an upper subsystem module at the first computer node configured to create a request, the request including a source memory address of data to be read over the RDMA connection and a destination memory address to store data to; and</claim-text>
<claim-text>a failover virtual layer configured to create at least one virtual queue structure (VQS), a VQS accessible by the upper subsystem module and not accessible by an interconnect adapter at the first computer node, the failover virtual layer further configured to create at least two physical queue structures (PQSs) associated with the VQS, the PQSs not accessible by the upper subsystem module.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The system of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the interconnect adapter is configured to perform data transfer between the first computer node and the second computer node over the RDMA connection.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The system of <claim-ref idref="CLM-00005">claim 5</claim-ref>, further comprising an interconnect driver configured to manage the interconnect adapter.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The system of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the interconnect adapter is configured not to receive a memory address of the VQS and is configured to receive memory addresses of the physical queue structures.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The system of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the upper subsystem module comprises at least one of a file system or a RAID system.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The system of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the failover virtual layer comprises:
<claim-text>a VQS management module configured to create the VQS and the PQSs and to perform failover of a PQS in error;</claim-text>
<claim-text>a request scheduling module configured to facilitate load balancing of requests among active PQSs; and</claim-text>
<claim-text>a monitoring module configured to monitor the PQSs to determine if one or more PQSs are in error.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The system of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein at least one of the VQS or the PQSs at the first computer node comprise one or more of:
<claim-text>a send queue configured to store RDMA read, RDMA write and send requests;</claim-text>
<claim-text>a receive queue configured to store receive requests; or</claim-text>
<claim-text>a completion queue configured to store a status of a RDMA transmission.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The system of <claim-ref idref="CLM-00005">claim 5</claim-ref>, further comprising a data structure for storing information about the VQS and the PQSs.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The system of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the data structure further maintains information about one or more PQSs in error.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. A method for performing an RDMA transfer between a first computer node and a second computer node, the method comprising:
<claim-text>creating at least one virtual queue structure (VQS) in a memory at the first computer node, a VQS for storing data transfer requests and completion status;</claim-text>
<claim-text>providing a handle of the VQS to an upper subsystem module so that the upper subsystem module is adapted to access the VQS using the handle while an interconnect adapter at the first computer node is not adapted to access the VQS, the upper subsystem module configured to provide the data transfer requests;</claim-text>
<claim-text>creating two or more physical queue structures (PQSs) in the memory;</claim-text>
<claim-text>registering the PQSs with the interconnect adapter so that the interconnect adapter is adapted to access the PQSs and the upper subsystem is adapted not to access the PQSs;</claim-text>
<claim-text>associating the VQS with the PQSs;</claim-text>
<claim-text>connecting the VQS at the first computer node with a second VQS at the second computer node; and</claim-text>
<claim-text>connecting the PQS at the first computer node with a second PQS at the second computer node.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein associating the VQS with the PQSs further comprises selecting an active PQS having an active status and providing a reference from the VQS to the active PQS.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. A method for performing non-disruptive failover of an RDMA connection between a first computer node and a second computer node, the method comprising:
<claim-text>receiving a request from an upper subsystem module, the request may include source and destination memory addresses;</claim-text>
<claim-text>posting the request to a virtual queue structure (VQS) associated with two or more physical queue structures (PQS) and posting the request to a first PQS, the VQS accessible to the upper subsystem module and not accessible to an interconnect adapter at the first computer node;</claim-text>
<claim-text>accessing the first PQS to obtain the source and destination memory address;</claim-text>
<claim-text>sending data over the RDMA connection between the first computer node and the second computer node;</claim-text>
<claim-text>responsive to determining that an error occurred on the RDMA connection, identifying a second PQS associated with the VQS, the second PQS not in error;</claim-text>
<claim-text>moving the request from the first PQS to the second PQS associated with the VQS;</claim-text>
<claim-text>using the second PQS to perform data transfer over the RDMA connection without notifying the upper subsystem module of the error so that the upper subsystem module continues posting requests to the VQS;</claim-text>
<claim-text>posting a completion status in the second PQS at the first computer node; and</claim-text>
<claim-text>responsive to the completion status being successful, moving the completion status to the VQS, thereby making the upper subsystem module aware of the successful completion.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. A method for performing non-disruptive failover of an RDMA connection between a first computer node and a second computer node, the method comprising:
<claim-text>receiving a data transfer request from an upper subsystem module;</claim-text>
<claim-text>providing a failover virtual layer at the first computer node and the second computer node, the failover virtual layer at the first computer node and the second computer node configured to establish an RDMA connection between the first computer node and the second computer node, to receive the data transfer request and to perform a failover of an RDMA transfer without notifying the upper subsystem module so that the upper subsystem module continues providing data transfer requests to the failover virtual layer; and</claim-text>
<claim-text>creating at least one virtual queue structure (VQS), a VQS accessible by the upper subsystem module and not accessible by an interconnect adapter at the first computer node.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The method of <claim-ref idref="CLM-00017">claim 17</claim-ref>, further comprising creating at least two VQSs.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The method of <claim-ref idref="CLM-00017">claim 17</claim-ref>, further comprising creating at least two physical queue structures (PQS) associated with the VQS.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The method of <claim-ref idref="CLM-00019">claim 19</claim-ref>, further comprising:
<claim-text>receiving a completion status from the interconnect adapter at the first computer node;</claim-text>
<claim-text>posting the completion status at a PQS; and</claim-text>
<claim-text>responsive to the completion status being successful, moving the completion status to the VQS associated with the PQS.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The method of <claim-ref idref="CLM-00019">claim 19</claim-ref>, further comprising:
<claim-text>receiving a completion status from the interconnect adapter at the first computer node;</claim-text>
<claim-text>posting the completion status at a PQS; and</claim-text>
<claim-text>responsive to the completion status being a failure, identifying a second PQS not in error and moving the requests to the second PQS without notifying the upper subsystem module.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. The method of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the data transfer request corresponds to write logs to be transferred from the first computer node to the second computer node.</claim-text>
</claim>
<claim id="CLM-00023" num="00023">
<claim-text>23. The method of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the data transfer request corresponds to data blocks to be transferred from the first computer node to the second computer node.</claim-text>
</claim>
<claim id="CLM-00024" num="00024">
<claim-text>24. A high availability (HA) cluster system for performing non-disruptive failover of an RDMA connection between a first storage node and a second storage node engaged in a transfer of write logs, the system comprising:
<claim-text>an upper subsystem module at the first computer node configured to create a request for the transfer of write logs, the request including a source memory address of write logs to be transferred over the RDMA connection and a destination memory address at the second computer node; and</claim-text>
<claim-text>a failover virtual layer in communication with the upper subsystem module at the first computer node, the failover virtual layer configured to establish the RDMA connection between the first computer node and the second computer node, obtain the write logs from memory and store the write logs to a memory of the second storage node, detect an error on the RDMA connection and perform a failover of the RDMA connection so that the upper subsystem module does not have knowledge of the error on the RDMA connection, wherein the failover virtual layer is further configured to create at least one virtual queue structure (VQS), a VQS accessible by the upper subsystem module and not accessible by an interconnect adapter at the first computer node.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00025" num="00025">
<claim-text>25. A computer-program product comprising a non-transitory computer-readable medium having computer program code embodied thereon for performing an RDMA transfer between a first computer node and a second computer node, the computer program code adapted to:
<claim-text>create at least one virtual queue structure (VQS) in a memory at the first computer node, a VQS for storing data transfer requests and completion status;</claim-text>
<claim-text>provide a handle of the VQS to an upper subsystem module so that the upper subsystem module is adapted to access the VQS using the handle while an interconnect adapter at the first computer node is not adapted to access the VQS, the upper subsystem module configured to provide the data transfer requests;</claim-text>
<claim-text>create two or more physical queue structures (PQSs) in the memory;</claim-text>
<claim-text>register the PQSs with the interconnect adapter so that the interconnect adapter is adapted to access the PQSs and the upper subsystem is adapted not to access the PQSs;</claim-text>
<claim-text>associate the VQS with the PQSs;</claim-text>
<claim-text>connect the VQS at the first computer node with a second VQS at the second computer node; and</claim-text>
<claim-text>connect a PQS at the first computer node with a second PQS at the second computer node.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
