<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627200-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627200</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12668788</doc-number>
<date>20080722</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<priority-claims>
<priority-claim sequence="01" kind="national">
<country>FR</country>
<doc-number>07 56689</doc-number>
<date>20070723</date>
</priority-claim>
</priority-claims>
<us-term-of-grant>
<us-term-extension>395</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>715237</main-classification>
<further-classification>715234</further-classification>
<further-classification>715239</further-classification>
</classification-national>
<invention-title id="d2e71">Method and device for encoding a structured document and device for decoding a document thus encoded</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6820075</doc-number>
<kind>B2</kind>
<name>Shanahan et al.</name>
<date>20041100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>715205</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6928425</doc-number>
<kind>B2</kind>
<name>Grefenstette et al.</name>
<date>20050800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>715209</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>2003/0061200</doc-number>
<kind>A1</kind>
<name>Hubert et al.</name>
<date>20030300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  3</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2003/0069877</doc-number>
<kind>A1</kind>
<name>Grefenstette et al.</name>
<date>20030400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  2</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>2005/0022114</doc-number>
<kind>A1</kind>
<name>Shanahan et al.</name>
<date>20050100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>715513</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2006/0167907</doc-number>
<kind>A1</kind>
<name>Jones</name>
<date>20060700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707100</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2007/0102764</doc-number>
<kind>A1</kind>
<name>Ando et al.</name>
<date>20070500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>257355</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2007/0204283</doc-number>
<kind>A1</kind>
<name>Ando et al.</name>
<date>20070800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>720718</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2007/0257247</doc-number>
<kind>A1</kind>
<name>Ando et al.</name>
<date>20071100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>257  3</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2008/0250055</doc-number>
<kind>A1</kind>
<name>Ruellan et al.</name>
<date>20081000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
<classification-national><country>US</country><main-classification>707102</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2008/0313282</doc-number>
<kind>A1</kind>
<name>Warila et al.</name>
<date>20081200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709206</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2009/0138529</doc-number>
<kind>A1</kind>
<name>Bellessort</name>
<date>20090500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
<classification-national><country>US</country><main-classification>707203</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2009/0183067</doc-number>
<kind>A1</kind>
<name>Fablet</name>
<date>20090700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
<classification-national><country>US</country><main-classification>715234</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2009/0287625</doc-number>
<kind>A1</kind>
<name>Fablet et al.</name>
<date>20091100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
<classification-national><country>US</country><main-classification>706 45</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>2010/0001886</doc-number>
<kind>A1</kind>
<name>Bellessort et al.</name>
<date>20100100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
<classification-national><country>US</country><main-classification>341 51</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>2010/0010995</doc-number>
<kind>A1</kind>
<name>Fablet et al.</name>
<date>20100100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
<classification-national><country>US</country><main-classification>707  6</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00017">
<document-id>
<country>EP</country>
<doc-number>1 122 655</doc-number>
<kind>A2</kind>
<date>20010800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00018">
<othercit>Ng, W., et al., &#x201c;XCQ: A Queriable XML Compression System&#x201d;, http://www.cse.ust.hk/&#x2dc;wilfred/paper/kais05.pdf (2005) (last visited Feb. 27, 2008), pp. 1-29.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00019">
<othercit>Yeung, L.W., et al., &#x201c;XCQ: XML Compression and Querying System&#x201d;, Proceedings of the 12<sup>th </sup>Int'l World Wide Web Conference, Budapest, Hungary (May 2003), pp. 1-2.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00020">
<othercit>Schneider, J., et al., &#x201c;Efficient XML Interchange (EXI) Format 1.0&#x201d;, http://w3.org/TR/2007/WD-exi-20070716/ (Jul. 2007)(last visited Nov. 15, 2007), pp. 1-46.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>23</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>715200</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>715234</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>715237</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>715239</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>16</number-of-drawing-sheets>
<number-of-figures>18</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20100192056</doc-number>
<kind>A1</kind>
<date>20100729</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Bellessort</last-name>
<first-name>Romain</first-name>
<address>
<city>Rennes</city>
<country>FR</country>
</address>
</addressbook>
<residence>
<country>FR</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Fablet</last-name>
<first-name>Youenn</first-name>
<address>
<city>La Dominelais</city>
<country>FR</country>
</address>
</addressbook>
<residence>
<country>FR</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Bellessort</last-name>
<first-name>Romain</first-name>
<address>
<city>Rennes</city>
<country>FR</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Fablet</last-name>
<first-name>Youenn</first-name>
<address>
<city>La Dominelais</city>
<country>FR</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Fitzpatrick, Cella, Harper &#x26; Scinto</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Canon Kabushiki Kaisha</orgname>
<role>03</role>
<address>
<city>Tokyo</city>
<country>JP</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Hong</last-name>
<first-name>Stephen</first-name>
<department>2178</department>
</primary-examiner>
<assistant-examiner>
<last-name>Vaughn</last-name>
<first-name>Gregory J</first-name>
</assistant-examiner>
</examiners>
<pct-or-regional-filing-data>
<document-id>
<country>WO</country>
<doc-number>PCT/IB2008/002884</doc-number>
<kind>00</kind>
<date>20080722</date>
</document-id>
<us-371c124-date>
<date>20100112</date>
</us-371c124-date>
</pct-or-regional-filing-data>
<pct-or-regional-publishing-data>
<document-id>
<country>WO</country>
<doc-number>WO2009/136225</doc-number>
<kind>A </kind>
<date>20091112</date>
</document-id>
</pct-or-regional-publishing-data>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">The method of encoding hierarchized data organized in a plurality of events comprises:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0000">a step of obtaining an information set of at least one event to be encoded, and</li>
        <li id="ul0002-0002" num="0000">a step of recovering a grammar according to the information set, said grammar making it possible to describe at least said information set,</li>
        <li id="ul0002-0003" num="0000">a step of determining whether at least a part, defined by a predetermined criterion, of said information set of at least one event to be encoded can be predicted unequivocally from said grammar,</li>
        <li id="ul0002-0004" num="0000">if the result of the determination step is positive, a step of encoding so-called &#x201c;conformity&#x201d; information representing this positive result, and</li>
        <li id="ul0002-0005" num="0000">a step of encoding the information of each said event to be encoded not included in said information set.</li>
    </ul>
    </li>
</ul>
</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="216.49mm" wi="188.38mm" file="US08627200-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="124.80mm" wi="127.59mm" file="US08627200-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="156.21mm" wi="188.38mm" file="US08627200-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="129.46mm" wi="192.79mm" file="US08627200-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="228.26mm" wi="131.40mm" file="US08627200-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="216.75mm" wi="145.03mm" file="US08627200-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="224.03mm" wi="189.40mm" file="US08627200-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="231.48mm" wi="177.97mm" file="US08627200-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="204.55mm" wi="170.94mm" file="US08627200-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="226.14mm" wi="170.94mm" file="US08627200-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="194.90mm" wi="179.15mm" file="US08627200-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="152.65mm" wi="177.12mm" file="US08627200-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="185.08mm" wi="90.25mm" file="US08627200-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="193.63mm" wi="145.80mm" file="US08627200-20140107-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="229.95mm" wi="168.99mm" file="US08627200-20140107-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="240.45mm" wi="176.53mm" file="US08627200-20140107-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00016" num="00016">
<img id="EMI-D00016" he="183.05mm" wi="158.92mm" file="US08627200-20140107-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<p id="p-0002" num="0001">The present invention concerns a method and device for encoding a structured document and a method and device for decoding a document thus encoded.</p>
<p id="p-0003" num="0002">XML (the acronym for &#x201c;Extensible Markup Language&#x201d;, that is to say extensible markup language) is a syntax for defining computer languages. XML makes it possible to create languages adapted to different uses but able to be processed by the same tools.</p>
<p id="p-0004" num="0003">An XML document is composed of elements, each element commencing with an opening tag comprising the name of the element (for example: &#x201c;&#x3c;tag&#x3e;&#x201d;) and ending with a closing tag also comprising the name of the element (for example: &#x201c;&#x3c;/tag&#x3e;&#x201d;), each element being able to contain other elements or text data. An element can be specified by attributes, each attribute being defined by a name and having a value. The attributes are placed in the opening tag of the element that they specify (for example &#x201c;&#x3c;tag attribute=&#x2018;value&#x2019;&#x3e;&#x201d;).</p>
<p id="p-0005" num="0004">XML syntax also makes it possible to define comments (for example: &#x201c;&#x3c;!&#x2014;Comment&#x2014;&#x3e;&#x201d;) and processing instructions that can specify to a computer application which processing operations to apply to the XML document (for example: &#x201c;&#x3c;?myprocessing?&#x3e;&#x201d;).</p>
<p id="p-0006" num="0005">It is considered hereinafter that XML data is described in terms of events, each event being able to be a start of an element (&#x3c;tag&#x3e;), an end of element (&#x3c;/tag&#x3e;), an attribute, a text content, a comment or a processing instruction.</p>
<p id="p-0007" num="0006">Several different XML languages can contain elements with the same name. In order to be able to mix several different XML languages, an addition has been made to the XML syntax making it possible to define namespaces (&#x201c;Namespaces&#x201d; in English). Two elements will be identical only if they have the same name and are situated in the same namespace. A namespace is defined by a URI (the acronym for &#x201c;Uniform Resource Identifier&#x201d;, meaning uniform resource identifier) (for example: &#x201c;http://canon.crf.xml/monlangage&#x201d;). The use of a namespace in an XML document requires defining a prefix that is a shortcut to the URI of this namespace. This prefix is defined by means of a specific attribute (for example: &#x201c;xmlns:ml=&#x2018;http://canon.crf.fr/xml/monlangage&#x2019;&#x201d; associates the prefix &#x201c;ml&#x201d; with the URI &#x201c;http://canon.crf.fr/xml/monlangage&#x201d;). Next, the namespace of an element or attribute is specified by causing its name to be preceded by the prefix associated with the namespace followed by &#x201c;:&#x201d; (for example: &#x201c;&#x3c;ml:tag ml:attribute=&#x2018;value&#x2019;&#x3e;&#x201d;).</p>
<p id="p-0008" num="0007">XML has many advantages and has become a standard for storing data in a file or for exchanging data. XML makes it possible in particular to have available many tools for processing the files generated. Moreover, an XML document can be edited manually with a simple text editor. In addition, as an XML document contains its structure integrated in the data, this document is highly readable even without knowing its specification.</p>
<p id="p-0009" num="0008">The main drawback of XML syntax is being very prolix. Thus the size of an XML document can be several times greater than the intrinsic size of the data. This great size of XML documents also gives rise to lengthy processing time when XML documents are generated and in particular read.</p>
<p id="p-0010" num="0009">To remedy these drawbacks, other methods for encoding an XML document have been sought. The aim of these methods is to code the content of the XML document in a more compact form, but making it possible to easily reconstruct the XML document. However, the majority of these methods do not keep all the advantages of the XML format.</p>
<p id="p-0011" num="0010">Among these methods, the most simple consist of coding the structure data in a binary format instead of using a text format. In addition, the redundancy of the structural information in the XML format can be eliminated or at least reduced (for example, it is not necessarily useful to specify the name of the element in the opening tag and closing tag).</p>
<p id="p-0012" num="0011">Another method is to use an index table, in particular for the names of elements and attributes that are generally repeated in an XML document. Thus, when an element name first occurs, this is coded normally in the file and an index is associated with it. Then, for the following occurrences of this element name, the index will be used in place of the complete string, reducing the size of the document generated but also facilitating reading (there is no longer any need to read the complete string in the file and, in addition, the element read can be determined by a comparison of integers instead of a comparison of character strings).</p>
<p id="p-0013" num="0012">Finally, apart from these elementary methods, there exist more sophisticated methods consisting in particular of taking into account more structural information in order to compress the data further. The case of Efficient XML can be cited, a format used as a basis for the standardization of a binary XML format by the EXI group of W3C (the acronym for Worldwide Web Consortium), which takes into account the order of appearance of the various events within a document in order to construct grammars that will make it possible to encode the most frequent events in a small number of bits.</p>
<p id="p-0014" num="0013">In this context, a grammar is composed of a set of productions, each production comprising an XML event description, an associated coding value and the indication of the following grammar to be used. To code an XML event using a grammar, the production containing the most precise description of the XML event is used. The coding value contained in this production is used to represent the event, and the information contained in the event and not described in the production is coded.</p>
<p id="p-0015" num="0014">A grammar is open to change. In a certain number of cases, after the occurrence of an XML event already described by a production of the grammar (if it is not described by a production, it cannot be encoded by the grammar), the grammar is modified in order to include a new production corresponding to this XML event. This production can either contain a more precise description of the event, reducing the number of items of information to be coded to represent the event, or have a more compact coding value.</p>
<p id="p-0016" num="0015">The coding values are expressed in the form of priorities having 1 to 3 levels. Coding a coding value amounts to coding the values of its priority. Each level is coded in a minimum number of bit or bits in order to be able to code the largest value of this level associated with a production of the grammar.</p>
<p id="p-0017" num="0016">In order to code an XML document, a set of grammars is used. A few grammars serve to code the structure peculiar to the XML document. In addition, for each type of XML element present in the document (an XML element type being a set of elements having the same name), a set of grammars is used to code the XML elements of this type.</p>
<p id="p-0018" num="0017">The rules of grammars used can be generic rules, common to all the XML documents and constructed from the XML syntax, or rules specific to a type of document, constructed from an XML schema describing the structure of this type of document.</p>
<p id="p-0019" num="0018">At decoding, the reverse process is used: the coding value is extracted and makes it possible to identify the coded XML event, as well as the supplementary information to be decoded.</p>
<p id="p-0020" num="0019">In addition, on decoding, the same grammar change rules are used, making it possible to have at any time a set of grammar rules identical to that which was used during coding.</p>
<p id="p-0021" num="0020">The following XML fragment is used to describe the coding of an XML document by means of the Efficient XML specification.</p>
<p id="p-0022" num="0021">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="168pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>&#x3c;person&#x3e;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="63pt" align="left"/>
<colspec colname="1" colwidth="154pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x3c;firstName&#x3e;John&#x3c;/firstName&#x3e;</entry>
</row>
<row>
<entry/>
<entry>&#x3c;lastName&#x3e;Smith&#x3c;/lastName&#x3e;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="168pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x3c;/person&#x3e;</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0023" num="0022">Since the encoder has not encountered a &#x201c;person&#x201d; element previously, a &#x201c;default&#x201d; grammar is created for this element. This is a grammar containing only generic productions. During the encoding of the &#x201c;person&#x201d; element, new productions will be inserted to make grammar linked to the &#x201c;person&#x201d; element more effective. The &#x201c;default&#x201d; grammar used to code the content of the &#x201c;person&#x201d; element is as follows (in a simplified fashion compared with the Efficient XML specification).</p>
<p id="h-0001" num="0000">:ElementContent:</p>
<p id="p-0024" num="0023">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="98pt" align="char"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>EE</entry>
<entry>0</entry>
</row>
<row>
<entry/>
<entry>SE (*) ElementContent</entry>
<entry>1.0</entry>
</row>
<row>
<entry/>
<entry>CH ElementContent</entry>
<entry>1.1</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="left" id="FOO-00001">&#x201c;EE&#x201d; corresponds to the end of element event, &#x201c;SE (*)&#x201d; corresponds to any start of element event (the name is not specified) and &#x201c;CH&#x201d; corresponds to a text content event.</entry>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0025" num="0024">During encoding, after having received the event corresponding to the start of &#x201c;person&#x201d; element (&#x201c;SE (person)&#x201d;) and having coded it, the encoder selects the coding grammar of the content of the &#x201c;person&#x201d; element described above.</p>
<p id="p-0026" num="0025">Next the encoder receives the event corresponding to the start of the &#x201c;firstName&#x201d; element (&#x201c;SE (firstName)&#x201d;). The production that corresponds to this event in the above grammar is the second:</p>
<p id="p-0027" num="0026">
<tables id="TABLE-US-00003" num="00003">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="98pt" align="center"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>SE (*) ElementContent</entry>
<entry>1.0</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0028" num="0027">The encoder therefore codes the priority &#x201c;1.0&#x201d;. As the first priority level comprises two distinct values (0 and 1), this level can be coded in one bit, with the value &#x201c;1&#x201d;. Likewise, the second priority level comprises two distinct values and can be coded in one bit, with the value &#x201c;0&#x201d;. The priority &#x201c;1.0&#x201d; is therefore coded here with the two bits &#x201c;10&#x201d;.</p>
<p id="p-0029" num="0028">Next, as the production does not specify the name of the element, &#x201c;firstName&#x201d; is coded.</p>
<p id="p-0030" num="0029">The encoding of the content of &#x201c;firstName&#x201d; grammar is then continued. To do this, the rule associated with this element is sought. As no &#x201c;firstName&#x201d; element has been encountered, a &#x201c;firstName&#x201d; is created from the default grammar. The &#x201c;firstName&#x201d; element contains a text node for a single child. Once this text node is encoded, the grammar of &#x201c;firstName&#x201d; is updated by inserting a text production (CH):</p>
<p id="p-0031" num="0030">ElementContent:</p>
<p id="p-0032" num="0031">
<tables id="TABLE-US-00004" num="00004">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="98pt" align="char"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>Characters</entry>
<entry>0</entry>
</row>
<row>
<entry/>
<entry>EE</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>SE (*) ElementContent</entry>
<entry>2.0</entry>
</row>
<row>
<entry/>
<entry>CH ElementContent</entry>
<entry>2.1</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0033" num="0032">Once the content of &#x201c;Firstname&#x201d; is coded, the encoder modifies the grammar associated with the &#x201c;person&#x201d; element in order to adapt the grammar to the XML data encountered. For this purpose, a new production is added to the grammar, this production corresponding to the start of the &#x201c;firstName&#x201d; element. The priority &#x201c;0&#x201d; is associated with this production and the other priorities are shifted in order to keep the unity of the priorities. The grammar becomes:</p>
<p id="p-0034" num="0033">ElementContent:</p>
<p id="p-0035" num="0034">
<tables id="TABLE-US-00005" num="00005">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="98pt" align="left"/>
<colspec colname="2" colwidth="84pt" align="char"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>SE (firstName) ElementContent</entry>
<entry>0</entry>
</row>
<row>
<entry/>
<entry>EE</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>SE (*) ElementContent</entry>
<entry>2.0</entry>
</row>
<row>
<entry/>
<entry>CH ElementContent</entry>
<entry>2.1</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0036" num="0035">The following event is the start of the &#x201c;lastName&#x201d; element. As with &#x201c;firstName&#x201d;, this element is coded using the production:</p>
<p id="p-0037" num="0036">
<tables id="TABLE-US-00006" num="00006">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="98pt" align="center"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>SE (*) ElementContent</entry>
<entry>2.0</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0038" num="0037">The first priority level having now three possible values, it is coded in two bits, with the value &#x201c;2&#x201d;. The second priority level is always coded in a single bit. The priority &#x201c;2.0&#x201d; is therefore coded here with the three bits &#x201c;100&#x201d;.</p>
<p id="p-0039" num="0038">The name of the &#x201c;lastName&#x201d; element is then coded. Then the content of &#x201c;lastName&#x201d; is coded by means of the grammar associated with the element &#x201c;lastName&#x201d;.</p>
<p id="p-0040" num="0039">After this the grammar is modified to add thereto a production corresponding to the start of the &#x201c;lastName&#x201d; element and then becomes:</p>
<p id="p-0041" num="0040">ElementContent:</p>
<p id="p-0042" num="0041">
<tables id="TABLE-US-00007" num="00007">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="98pt" align="left"/>
<colspec colname="2" colwidth="84pt" align="char"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>SE (lastName) ElementContent</entry>
<entry>0</entry>
</row>
<row>
<entry/>
<entry>SE (firstName) ElementContent</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>EE</entry>
<entry>2</entry>
</row>
<row>
<entry/>
<entry>SE (*) ElementContent</entry>
<entry>3.0</entry>
</row>
<row>
<entry/>
<entry>CH ElementContent</entry>
<entry>3.1</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0043" num="0042">If subsequently, in the document, the coder encounters another similar &#x201c;person&#x201d; element, this element will be coded using this grammar.</p>
<p id="p-0044" num="0043">Thus the first event corresponding to the content of the &#x201c;person&#x201d; element is the event of the start of the &#x201c;firstName&#x201d; element. This element is coded with the production:</p>
<p id="p-0045" num="0044">
<tables id="TABLE-US-00008" num="00008">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="98pt" align="left"/>
<colspec colname="2" colwidth="84pt" align="center"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>SE (firstName) ElementContent</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0046" num="0045">The production</p>
<p id="p-0047" num="0046">
<tables id="TABLE-US-00009" num="00009">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="70pt" align="left"/>
<colspec colname="2" colwidth="98pt" align="center"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>SE (*) ElementContent</entry>
<entry>3.0</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
also corresponds to this event but is less precise (it does not specify the name of the element). It is therefore the first production that is used.
</p>
<p id="p-0048" num="0047">The encoder therefore codes the priority of this production, namely &#x201c;1&#x201d;, which is coded with the two bits &#x201c;0.1&#x201d;. There is no need to code the name of the elements since this is specified by the production.</p>
<p id="p-0049" num="0048">The encoder next codes the content of the &#x201c;firstName&#x201d; element.</p>
<p id="p-0050" num="0049">As a production specific to the event of the start of the &#x201c;firstName&#x201d; element already exists in the grammar, it is not necessary to add a new production to the grammar.</p>
<p id="p-0051" num="0050">The encoder next codes, in a similar manner, the &#x201c;lastName&#x201d; element start event, coding only the priority &#x201c;0&#x201d; with the two bits: &#x201c;00&#x201d;.</p>
<p id="p-0052" num="0051">Thus, for the coding of the second &#x201c;person&#x201d; element similar to the first, the code generated is more compact, since it is no longer necessary to code the name of the elements contained in &#x201c;person&#x201d;, neither literally (by coding the whole of the character string), nor even using an index.</p>
<p id="p-0053" num="0052">If a schema is available to describe the content of a &#x201c;person&#x201d;, namely a &#x201c;firstName&#x201d; element and a &#x201c;lastName&#x201d; element, it is possible to construct from the very start the grammar generated after the end of the coding of the first &#x201c;person&#x201d; element.</p>
<p id="p-0054" num="0053">However, if the schema also specifies that the &#x201c;firstName&#x201d; and &#x201c;lastName&#x201d; elements must be ordered within the &#x201c;person&#x201d; element, &#x201c;firstName&#x201d; preceding &#x201c;lastName&#x201d;, it is possible to generate the following grammars to describe the content of &#x201c;person&#x201d;.</p>
<p id="p-0055" num="0054">ElementContent1:</p>
<p id="p-0056" num="0055">
<tables id="TABLE-US-00010" num="00010">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="105pt" align="left"/>
<colspec colname="2" colwidth="84pt" align="char"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>SE (firstName) Element Content2</entry>
<entry>0</entry>
</row>
<row>
<entry/>
<entry>EE</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>SE (*) ElementContent1</entry>
<entry>2.0</entry>
</row>
<row>
<entry/>
<entry>CH ElementContent1</entry>
<entry>2.1</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0057" num="0056">ElementContent2:</p>
<p id="p-0058" num="0057">
<tables id="TABLE-US-00011" num="00011">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="98pt" align="left"/>
<colspec colname="2" colwidth="84pt" align="char"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>SE (lastName) ElementContent3</entry>
<entry>0</entry>
</row>
<row>
<entry/>
<entry>EE</entry>
<entry>1</entry>
</row>
<row>
<entry/>
<entry>SE (*) ElementContent2</entry>
<entry>2.0</entry>
</row>
<row>
<entry/>
<entry>CH ElementContent2</entry>
<entry>2.1</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0059" num="0058">ElementContent3:</p>
<p id="p-0060" num="0059">
<tables id="TABLE-US-00012" num="00012">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="77pt" align="left"/>
<colspec colname="2" colwidth="98pt" align="char"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>EE</entry>
<entry>0</entry>
</row>
<row>
<entry/>
<entry>SE (*) ElementContent2</entry>
<entry>1.0</entry>
</row>
<row>
<entry/>
<entry>CH ElementContent2</entry>
<entry>1.1</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0061" num="0060">These grammars use the known order of appearance of the &#x201c;firstName&#x201d; and &#x201c;lastName&#x201d; elements to separate the productions into several grammars and reduce the number of productions per grammar and consequently the number of bits necessary for coding a priority.</p>
<p id="p-0062" num="0061">These grammars can even be reduced if the deviations with respect to the schema are not accepted and then become:</p>
<p id="p-0063" num="0062">ElementContent1:</p>
<p id="p-0064" num="0063">
<tables id="TABLE-US-00013" num="00013">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="105pt" align="left"/>
<colspec colname="2" colwidth="84pt" align="center"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>SE (firstName) Element Content2</entry>
<entry>0</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0065" num="0064">ElementContent2:</p>
<p id="p-0066" num="0065">
<tables id="TABLE-US-00014" num="00014">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="35pt" align="left"/>
<colspec colname="1" colwidth="98pt" align="left"/>
<colspec colname="2" colwidth="84pt" align="center"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>SE (lastName) ElementContent3</entry>
<entry>0</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0067" num="0066">ElementContent3</p>
<p id="p-0068" num="0067">
<tables id="TABLE-US-00015" num="00015">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="offset" colwidth="63pt" align="left"/>
<colspec colname="1" colwidth="14pt" align="left"/>
<colspec colname="2" colwidth="140pt" align="center"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>EE</entry>
<entry>0</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0069" num="0068">In this case, each grammar containing only one priority, this priority does not need to be coded. Thus all the events describing the content of the &#x201c;person&#x201d; element as described above are coded in zero bits.</p>
<p id="p-0070" num="0069">The present invention is situated particularly in the context where no XML schema is used by the encoder. Because of this, at the start of the encoding of the document, the generic rules apply for each new element encountered. Taking the previous example again, at the end of the encoding of the first &#x201c;person&#x201d; element, the rules illustrated in <figref idref="DRAWINGS">FIG. 1</figref> are obtained.</p>
<p id="p-0071" num="0070">The &#x201c;lastName&#x201d; element is inserted last in the rules since it is the last of the child elements of the &#x201c;person&#x201d; element. The order of insertion of the productions follows in this example the order of appearance of the elements.</p>
<p id="p-0072" num="0071">The EXI working group of W3C is currently working on the standardization of a binary XML format based on Efficient XML. In this context, various improvements have been proposed, including the use of coalescent grammars or combined events. In both cases, it is a case of grouping, in a single production, several events where it is known that they occur successively. These proposals have been made in the context of the use of XML schemas, an XML schema being a description of the content of an XML document, that is to say a definition of the XML elements used and their content (attributes, child elements, text content, etc). This is because, by virtue of an XML schema, it is possible to know that certain events will follow each other, for example a start of element and attributes required for this element, or the end of a child element and the end of the parent element. The idea evoked therefore consists of determining such events and then defining a production grouping them together. This approach therefore requires specific processing in order to identify events that follow each other and then the addition of one or more productions to the grammars: this is therefore a process that is expensive in terms of calculations, and whose impact may be negative. This is because, if based on schemas, it is possible to define rules with a low risk of errors (the case where the production grouping together the elements is not the production to be used). On the other hand, in the case where a schema is not used, the risk of error is higher and it may be therefore that a rarely used production is inserted, this insertion causing an increase in the coding cost of each production.</p>
<p id="p-0073" num="0072">The present invention aims to remedy these drawbacks.</p>
<p id="p-0074" num="0073">According to a first aspect, the present invention relates to a method of encoding hierarchized data organized in a plurality of events, comprising:
<ul id="ul0003" list-style="none">
    <li id="ul0003-0001" num="0000">
    <ul id="ul0004" list-style="none">
        <li id="ul0004-0001" num="0074">a step of obtaining an information set of at least one event to be encoded, and</li>
        <li id="ul0004-0002" num="0075">a step of recovering a grammar according to the information set, said grammar making it possible to describe at least said information set,</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0075" num="0076">characterized in that it also comprises:
<ul id="ul0005" list-style="none">
    <li id="ul0005-0001" num="0000">
    <ul id="ul0006" list-style="none">
        <li id="ul0006-0001" num="0077">a step of determining whether at least a part, defined by a predetermined criterion, of said information set of at least one event to be encoded can be predicted unequivocally from said grammar,</li>
        <li id="ul0006-0002" num="0078">if the result of the determination step is positive, a step of encoding so-called &#x201c;conformity&#x201d; information representing this positive result, and</li>
        <li id="ul0006-0003" num="0079">a step of encoding the information of each said event to be encoded not included in said information set.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0076" num="0080">In fact, the inventors have determined that the structures of XML elements have a tendency to repeat themselves. The implementation of the present invention takes advantage of this potential redundancy in order to better use the grammars and compress more compactly the elements that are already described by a grammar.</p>
<p id="p-0077" num="0081">In particular, the current encoding of EXI does not take advantage of this insertion order: in the above example, the presence of the &#x201c;lastName&#x201d; element as a child of &#x201c;person&#x201d; is encoded there in the same number of bits (here two) that there are before or after the &#x201c;firstName&#x201d; element. This remark applies also to the encoding of the content of the &#x201c;lastName&#x201d; element: an element containing only text on a first occasion in a document has great chances of containing only text in all its following occurrences. Currently an &#x201c;lastName&#x201d; element containing only text will use two bits to declare that it has a child text node and two bits to declare that it has an end of element event, four bits in total. It should be noted that, by implementing the present invention, contrary to the approach proposed at the W3C, which seeks to study data for determining events that it is advantageous to group within the same production, use is made of defined grammars to determine the conformity of the data, for example XML, to be encoded.</p>
<p id="p-0078" num="0082">The implementation of the present invention is all the more effective since all the added (non-generic) productions of a particular element exactly describe the following occurrences of this element.</p>
<p id="p-0079" num="0083">According to particular characteristics, during the determination step at least one event generated from productions of the said grammar or ordered in a predefined manner is recovered and the information set of at least one event generated is compared with the information set of at least one event to be encoded.</p>
<p id="p-0080" num="0084">For example, at the first determination step concerning a grammar, events are generated from productions of said grammar and, for the other determination steps concerning this grammar, these generated events are once again used. The duration of encoding is thus improved.</p>
<p id="p-0081" num="0085">According to particular characteristics, the encoding method as succinctly disclosed above comprises, if the result of the determination step is negative, a step of encoding said information set.</p>
<p id="p-0082" num="0086">According to particular characteristics, during the obtaining step, said information set of at least one event to be encoded comprises the structure information of at least one event to be encoded.</p>
<p id="p-0083" num="0087">According to particular characteristics, during the obtaining step, said information set of at least one event to be encoded comprises information indicating whether the value of said event can be encoded by reference to a previously encoded value.</p>
<p id="p-0084" num="0088">For example, events are indexed and this index is used.</p>
<p id="p-0085" num="0089">According to particular characteristics, the information set of at least one event to be encoded is divided into a plurality of subsets of information and the result of the determination step is positive if a predetermined selection of information subsets or at least one event to be encoded can be predicted unequivocally from said grammar.</p>
<p id="p-0086" num="0090">For example, the predictability is determined by subsets which are the attributes, the elements or direct child events or the sets of elements or descendant events.</p>
<p id="p-0087" num="0091">According to particular characteristics, a subset is selected according to the number of times that said information subset has been able to be predicted unequivocally from said grammar and/or the number of times that said information subset has not been able to be predicted, during the decoding of at least one previous event to be encoded among the plurality of events.</p>
<p id="p-0088" num="0092">According to particular characteristics, if the result of the determination step is positive and the information set comprises at least one non-selected information subset, the method also comprises a step of encoding each non-selected information subset.</p>
<p id="p-0089" num="0093">According to particular characteristics, if the result of the determination step is negative and the information set comprises at least one selected information subset, the method comprises a step of encoding so-called &#x201c;non-conformity&#x201d; information representing this negative result.</p>
<p id="p-0090" num="0094">According to particular characteristics, an information subset of said information set comprises the information relating to the events of the text type, or more particularly of the space type.</p>
<p id="p-0091" num="0095">According to particular characteristics, an information subset of said information set comprises the information relating to the events of the attribute type.</p>
<p id="p-0092" num="0096">According to particular characteristics, an information subset of said information set comprises the information relating to the events of the start of element type.</p>
<p id="p-0093" num="0097">By virtue of each of these provisions, even if the information set to be encoded differs slightly from what is predicted by the grammar, its encoding comprises information making it possible to reconstruct the part that can be predicted. The efficacy of the method that is the object of the present invention therefore extends to the events having a slight variation with what is predictable.</p>
<p id="p-0094" num="0098">According to particular characteristics, during the step of recovering a grammar, said grammar is recovered according to at least one previously encoded event.</p>
<p id="p-0095" num="0099">According to particular characteristics, the encoding method as succinctly disclosed above also comprises a step of updating the grammar recovered from the information set of at least one event to be encoded.</p>
<p id="p-0096" num="0100">According to particular characteristics, when a step of encoding all or part of said information set is implemented, the step of updating the recovered grammar takes into account the order of the events to be encoded.</p>
<p id="p-0097" num="0101">For example, the non-selected subsets are encoded according to coding methods known from the prior art.</p>
<p id="p-0098" num="0102">According to particular characteristics, the hierarchized data is the data of a structured XML document.</p>
<p id="p-0099" num="0103">According to particular characteristics, at least one said grammar is an EXI grammar.</p>
<p id="p-0100" num="0104">According to a second aspect, the present invention concerns a method of decoding hierarchized data organized in a plurality of events, characterized in that it comprises:
<ul id="ul0007" list-style="none">
    <li id="ul0007-0001" num="0000">
    <ul id="ul0008" list-style="none">
        <li id="ul0008-0001" num="0105">a step of obtaining so-called &#x201c;conformity&#x201d; information representing the fact that at least part of an information set of at least one event to be decoded can be predicted unequivocally from a grammar,</li>
        <li id="ul0008-0002" num="0106">a step of obtaining said grammar, and</li>
        <li id="ul0008-0003" num="0107">a step of generating the unequivocally predicted information from said grammar.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0101" num="0108">According to particular characteristics, the step of obtaining the so-called &#x201c;conformity&#x201d; information comprises a step of decoding the conformity information.</p>
<p id="p-0102" num="0109">According to particular characteristics, during the step of obtaining the so-called &#x201c;conformity&#x201d; information, the conformity information is obtained according to past decodings.</p>
<p id="p-0103" num="0110">According to a third aspect, the present invention relates to a device for encoding hierarchized data organized in a plurality of events, comprising:
<ul id="ul0009" list-style="none">
    <li id="ul0009-0001" num="0000">
    <ul id="ul0010" list-style="none">
        <li id="ul0010-0001" num="0111">a means of obtaining an information set of at least one event to be encoded, and</li>
        <li id="ul0010-0002" num="0112">a means of recovering a grammar according to the information set, said grammar making it possible to describe at least said information set,</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0104" num="0113">characterized in that it also comprises:
<ul id="ul0011" list-style="none">
    <li id="ul0011-0001" num="0000">
    <ul id="ul0012" list-style="none">
        <li id="ul0012-0001" num="0114">a means of determining whether at least a part, defined by a predetermined criterion, of said information set of at least one event to be encoded can be predicted unequivocally from said grammar,</li>
        <li id="ul0012-0002" num="0115">an encoding means adapted, if the result of the determination step is positive, to encode so-called &#x201c;conformity&#x201d; information representing this positive result, and adapted to encode the information of each said event to be encoded not included in said information set.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0105" num="0116">According to a fourth aspect, the present invention relates to a device for decoding hierarchized data organized in a plurality of events, characterized in that it comprises:
<ul id="ul0013" list-style="none">
    <li id="ul0013-0001" num="0000">
    <ul id="ul0014" list-style="none">
        <li id="ul0014-0001" num="0117">a means of obtaining so-called &#x201c;conformity&#x201d; information representing the fact that at least part of an information set of at least one event to be decoded can be predicted unequivocally from a grammar,</li>
        <li id="ul0014-0002" num="0118">a means of obtaining said grammar, and</li>
        <li id="ul0014-0003" num="0119">a means of generating the unequivocally predicted information from said grammar.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0106" num="0120">According to a fifth aspect, the present invention relates to a computer program that can be loaded into a computer system, said program containing instructions for implementing the encoding method or the decoding method as succinctly disclosed above.</p>
<p id="p-0107" num="0121">According to a sixth aspect, the present invention relates to an information carrier that can be read by a computer or a microprocessor, removable or not, storing instructions of a computer program, characterized in that it allows the implementation of the encoding method or of the decoding method as succinctly disclosed above.</p>
<p id="p-0108" num="0122">The advantages, aims and characteristics of this encoding device, this decoding method, this decoding device, this computer program and this information carrier being similar to those of the encoding method that is the object of the present invention, as succinctly disclosed above, they are not repeated here.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<p id="p-0109" num="0123">Other advantages, aims and characteristics of the present invention will emerge from the following description given, for explanatory purposes and in no way limiting, with regard to the accompanying drawings, in which:</p>
<p id="p-0110" num="0124"><figref idref="DRAWINGS">FIG. 1</figref> depicts an example of known encoding of an XML document element,</p>
<p id="p-0111" num="0125"><figref idref="DRAWINGS">FIGS. 2 and 3</figref> depict examples of encoding of an XML document element obtained by implementing a particular embodiment of the encoding method that is the object of the present invention,</p>
<p id="p-0112" num="0126"><figref idref="DRAWINGS">FIG. 4</figref> depicts a particular XML document,</p>
<p id="p-0113" num="0127"><figref idref="DRAWINGS">FIG. 5</figref> depicts another XML document,</p>
<p id="p-0114" num="0128"><figref idref="DRAWINGS">FIGS. 6 and 7</figref> depict a result of encoding of the document illustrated in <figref idref="DRAWINGS">FIG. 5</figref>, according to the Efficient XML format, and implementing a particular embodiment of the encoding method that is the object of the present invention, respectively,</p>
<p id="p-0115" num="0129"><figref idref="DRAWINGS">FIGS. 8 to 15</figref> depict, in the form of logic diagrams, steps implemented in a particular embodiment of the encoding method that is the object of the present invention,</p>
<p id="p-0116" num="0130"><figref idref="DRAWINGS">FIGS. 16 and 17</figref> depict, in the form of logic diagrams, steps implemented in a particular embodiment of the decoding method that is the object of the present invention, and</p>
<p id="p-0117" num="0131"><figref idref="DRAWINGS">FIG. 18</figref> depicts, schematically, a particular embodiment of a device for implementing the encoding and/or decoding methods that are the objects of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<p id="p-0118" num="0132">Although the present invention is described for structured data of an XML document, the present invention is not limited to this type of document but on the contrary extends to the encoding and decoding of all hierarchized data organized in a plurality of events.</p>
<p id="p-0119" num="0133"><figref idref="DRAWINGS">FIG. 1</figref> describes conventional EXI encoding. It should be noted that, in <figref idref="DRAWINGS">FIG. 1</figref>, as, later, in <figref idref="DRAWINGS">FIGS. 2 and 3</figref>, the left-hand column corresponds to the encoded data and the right-hand column corresponds to the situation for the &#x201c;person&#x201d; element after the encoding of this data.</p>
<p id="p-0120" num="0134">It will be observed that, by virtue of the implementation of the particular embodiment of the encoding method that is the object of the present invention illustrated in the figures, the order of insertion of the production corresponding to the element &#x201c;midName&#x201d; is modified so that the order of the productions corresponds to the order of the elements: the production &#x201c;midName&#x201d; is thus situated between the productions &#x201c;firstName&#x201d; and &#x201c;lastName&#x201d;, as illustrated in <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0121" num="0135">When a new &#x201c;person&#x201d; element is encountered, the implementation of the invention consists of comparing the content of the &#x201c;person&#x201d; element with its grammar. The most probable structure of the &#x201c;person&#x201d; element is determined from all the grammars of the &#x201c;person&#x201d; element and its known children (&#x201c;firstName&#x201d;, &#x201c;midName&#x201d; and &#x201c;lastName&#x201d;), as illustrated in <figref idref="DRAWINGS">FIG. 3</figref>.</p>
<p id="p-0122" num="0136">It is then possible to compare the &#x201c;person&#x201d; element to be encoded with the structure determined by the grammar. If the structure determined corresponds to the data to be encoded, it is then said that the data to be encoded is &#x201c;in conformity&#x201d; with the grammar, and it is then possible to use a specific encoding:
<ul id="ul0015" list-style="none">
    <li id="ul0015-0001" num="0000">
    <ul id="ul0016" list-style="none">
        <li id="ul0016-0001" num="0137">the fact that the structure determined corresponds to the element to be encoded is encoded by means of a bit set to &#x201c;1&#x201d;, and</li>
        <li id="ul0016-0002" num="0138">all the values of the element are encoded in their order of appearance.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0123" num="0139">If the data to be encoded is not in accordance with the structure determined by the grammar, a different encoding is performed for the &#x201c;person&#x201d; element:
<ul id="ul0017" list-style="none">
    <li id="ul0017-0001" num="0000">
    <ul id="ul0018" list-style="none">
        <li id="ul0018-0001" num="0140">the absence of conformity is encoded by a bit set to &#x201c;0&#x201d;, and</li>
        <li id="ul0018-0002" num="0141">the &#x201c;person&#x201d; element is encoded as is known in the prior art by including the priorities and values.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0124" num="0142">It should be noted that, in the latter case, the comparisons are made on the children of the &#x201c;person&#x201d; element.</p>
<p id="p-0125" num="0143">The comparison disclosed above functions very well when the structures are exactly repetitive. However, some documents, like the one given in the example illustrated in <figref idref="DRAWINGS">FIG. 4</figref>, contain elements where the comparison with the grammar will never be good. It is a case for example of elements whose content is a choice between several elements. In the example in <figref idref="DRAWINGS">FIG. 4</figref>, the element &#x201c;struct&#x201d; will never be in conformity with what is predicted by the grammar. The comparison of the element &#x201c;value&#x201d; with its grammar does not therefore function, because of the variability of the content of the element &#x201c;struct&#x201d;.</p>
<p id="p-0126" num="0144">To resolve this problem, in particular embodiments, including the one described with regard to the figures, the concept of opacity of the rules is introduced: the element &#x201c;struct&#x201d; not being in conformity with its grammar, the grammar is marked as being opaque at the end of a certain number of encodings of this element. The comparison of the element &#x201c;value&#x201d; then no longer takes account of the content of the element &#x201c;struct&#x201d; and can once again predict the exact structure of the element &#x201c;value&#x201d;.</p>
<p id="p-0127" num="0145">The example of a document in <figref idref="DRAWINGS">FIG. 4</figref> illustrates the principle of the opacity of the children of an element. Opacity levels applying to the various parts of an element are defined:
<ul id="ul0019" list-style="none">
    <li id="ul0019-0001" num="0000">
    <ul id="ul0020" list-style="none">
        <li id="ul0020-0001" num="0146">opacity of the children: when the variance of the elements is high,</li>
        <li id="ul0020-0002" num="0147">opacity of the attributes: when the variance of the attributes is high,</li>
        <li id="ul0020-0003" num="0148">opacity of the text nodes: when the variance of the presence of the text nodes is great.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0128" num="0149">The opacity levels of each grammar are determined at the encoder according to the result of the previous encodings. They are calculated at the decoder according to the result of the previous decodings, which makes it possible not to have to encode this opacity data item explicitly in the stream and therefore not to reduce the compression ratio.</p>
<p id="p-0129" num="0150">The spaces (&#x201c;whitespaces&#x201d;) are generally situated between two starts of elements, two ends of elements or between a start and end of an element. In Efficient XML, the spaces generate the insertion of a production &#x201c;Characters&#x201d; in the grammar that do not distinguish them from other text nodes. Preferentially, in order to be effective, the comparison between grammar and XML data used by the present invention takes these spaces into account.</p>
<p id="p-0130" num="0151">To this end, it should be noted that the elements with mixed content (elements containing child elements and text nodes that are not spaces) are relatively rare. Because of this, the conjoint presence in a grammar of a production CH and one or more productions SE generally corresponds to the presence of spaces between the starts/ends of elements. In such a case, the comparison between grammar and XML data is modified in order to include a test on the text nodes. The result of this test is positive when all the direct text nodes of the element compared are spaces. It is also possible to add the constraint that all the text nodes are already indexed. If the comparison fails several times, it is then decided to make these text nodes opaque.</p>
<p id="p-0131" num="0152">In the case where a production specific to the spaces is used (&#x201c;Whitespace&#x201d; production, possibly defining a value for the string of spaces), this method would also function. This is because, instead of detecting the &#x201c;Characters&#x201d; productions corresponding to spaces, it would suffice to apply the space insertion when a &#x201c;Whitespace&#x201d; production is encountered.</p>
<p id="p-0132" num="0153">Using a simple document, illustrated in <figref idref="DRAWINGS">FIG. 5</figref>, a description is given below of the result of the encoding of this document according to the Efficient XML format, illustrated in <figref idref="DRAWINGS">FIG. 6</figref>, on the one hand and implementing the present invention and using Efficient XML, illustrated in <figref idref="DRAWINGS">FIG. 7</figref>, as a basis on the other hand. For more convenience, the binary XML streams of <figref idref="DRAWINGS">FIGS. 6 and 7</figref> have been modified in order to be more legible: the encoding of the names and values of elements always commence at the start of a byte.</p>
<p id="p-0133" num="0154">In <figref idref="DRAWINGS">FIGS. 6 and 7</figref>, the characters in bold correspond to the priorities encoded for defining the structure of the document. The other characters correspond to the names of elements and values of elements encoded in UTF-8. The two streams are exactly identical as far as the second occurrence of the &#x201c;person&#x201d; element (the first character in italics in the figures). In both cases, the first step is to close the first &#x201c;lastName&#x201d; element and the first &#x201c;person&#x201d; element, which gives the series of &#x201c;0&#x201d; and then &#x201c;01&#x201d; bits, which form the start of the character &#x201c;0x31&#x201d;. Next the start of &#x201c;person&#x201d; element event is encoded, which will form the end of the character &#x201c;0X31&#x201d;, the character &#x201c;0x00&#x201d; and the first three bits &#x201c;001&#x201d; of the character &#x201c;0x20&#x201d; and &#x201c;0x30&#x201d;.</p>
<p id="p-0134" num="0155">The two encodings will then diverge: Efficient XML continues by encoding the priority corresponding to the start of the &#x201c;firstName&#x201d; element, which forms the character &#x201c;0x20&#x201d;. On the other hand, the implementation of the present invention determines first of all whether the new occurrence of the &#x201c;person&#x201d; element corresponds to the structure predicted by the grammar. As is the case in our example, a single bit set to &#x201c;1&#x201d; is added, which forms the character &#x201c;0x30&#x201d;.</p>
<p id="p-0135" num="0156">The encoder that is the object of the present invention next encodes the text values contained in the &#x201c;person&#x201d; element (&#x201c;Mary&#x201d; and &#x201c;Wesson&#x201d;) as far as the last character &#x201c;0x40&#x201d;, which corresponds to the encoding of the priority of the end of &#x201c;addressbook&#x201d; element event. The Efficient XML encoder encodes the value &#x201c;Mary&#x201d; and then the end of &#x201c;firstName&#x201d; element priority, the start of &#x201c;lastName&#x201d; element priority, which forms the character &#x201c;0x00&#x201d;, the value &#x201c;Wesson&#x201d; and then the end of &#x201c;lastName&#x201d;, &#x201c;person&#x201d; and &#x201c;addressbook&#x201d; element priorities, which forms the character &#x201c;0x28&#x201d;.</p>
<p id="p-0136" num="0157">The decoder that is the object of the present invention has a functioning symmetrical with that of the encoder, as illustrated in <figref idref="DRAWINGS">FIGS. 16 and 17</figref>.</p>
<p id="p-0137" num="0158">In the particular embodiment of the encoding method that is the object of the present invention illustrated in <figref idref="DRAWINGS">FIG. 8</figref>, an XML document is first of all obtained during a step <b>110</b>. Then, during a step <b>110</b>, it is determined whether the document has been fully processed. If so, the processing ends during a step <b>190</b>. Otherwise, during a step <b>120</b>, a set of information of at least one event to be encoded is obtained. In the embodiment described in <figref idref="DRAWINGS">FIG. 8</figref>, it is a question of data of a single XML event, precisely the XML event following the last event already encoded, and, during a step <b>130</b>, it is determined whether this event corresponds to a start of element. If not, during a step <b>150</b>, the conformity of the event, which may be true, false or unknown, is determined. In the last two cases, it is considered that the event is not in conformity and a step <b>151</b> is passed to, during which the priority associated with the event is encoded, according to the conventional encoding functioning.</p>
<p id="p-0138" num="0159">Following step <b>151</b> or if, during step <b>150</b>, it has been determined that the conformity is true, during a step <b>152</b>, it is determined whether the event has a value. If so, this value is encoded during a step <b>153</b>. In the case where the prediction of the conformity comprises the state of indexing of the value, that is to say if this value has already been indexed or not, the value is encoded without specifying its indexing state. If at step <b>152</b> it is determined that the event has no value, or following step <b>153</b>, a step <b>180</b> of updating the grammars is passed to, detailed in <figref idref="DRAWINGS">FIG. 14</figref>.</p>
<p id="p-0139" num="0160">If, during a step <b>130</b>, it is determined that the event corresponds to a start of element, during a step <b>140</b>, the grammar used for the content of the element that is processed, called &#x201c;G&#x201d;, is obtained and, during a step <b>145</b>, it is determined whether this grammar G is opaque. Generic grammars, which do not describe a precise element, and which are used in particular for the first instance of each element, are, by default, opaque. This is because, since they are generic, it is known that they do not correctly describe the XML data encountered. If the result of step <b>145</b> is positive, during a step <b>160</b>, the priority associated with the event is encoded and then step <b>180</b> is passed to. This is because, in the case of an opaque grammar, it is not necessary to compare the data with the grammar or to encode conformity information, since the priorities are always used for encoding the events.</p>
<p id="p-0140" num="0161">If the result of step <b>145</b> is negative, that is to say if the grammar is not opaque, during a step <b>170</b>, it is determined whether the start of element processed belongs to a content already considered in conformity with the said grammar. For an element having a parent, this means that, when the conformity of the children of the parent has been determined, the result has been positive. This information is therefore known since the parent was encoded before encoding the child. However, it may happen that an element does not have a parent (the case of a root element of an XML document), or that the determination has not been able to be made on the parent element (the case where the data is buffered or the size of the buffer is too small to contain the parent element entirely). In this case, the conformity is unknown and the processing is equivalent to that of a known false conformity, that is to say a non-conformity. If the result of step <b>170</b> is negative, during a step <b>171</b>, described in more detail with regard to <figref idref="DRAWINGS">FIG. 9</figref>, the conformity of the content of the element with respect to the grammars describing the element and its content are determined and, in the case of conformity, the conforming events are marked as such. Next, during a step <b>172</b>, the priority linked to the element start is encoded and then, during a step <b>173</b>, the conformity of the content of the element is encoded, known by virtue of step <b>171</b>. The conformity is coded in a bit equal to &#x201c;0&#x201d; if the data is not in conformity and &#x201c;1&#x201d; if the data is in conformity. The step <b>180</b> of updating the grammars is then passed to. If the result of step <b>170</b> is positive, that is to say if the event is an element start belonging to a conforming content, step <b>180</b> is passed to. This is because, in this case, the conformity of the content is already known and it is not necessary to code a priority.</p>
<p id="p-0141" num="0162">Following step <b>180</b>, step <b>110</b> is returned to in order to iterate the steps illustrated in <figref idref="DRAWINGS">FIG. 8</figref> as long as the end of the document has not been reached.</p>
<p id="p-0142" num="0163">A variant of <figref idref="DRAWINGS">FIG. 8</figref> consists of using a buffer containing only one event. In this case, the conformity is evaluated for any type of event and not only for the starts of elements (the case in <figref idref="DRAWINGS">FIG. 8</figref>), and the evaluation of the conformity consists of checking whether the event to be coded is described by the following production in the grammar (the current production being that which was used to encode the previous event). If the event is indeed that expected according to the grammar, the conformity information, true or false, is encoded in one bit and the priority associated with the event is not encoded. If this is not the case, the non-conformity information, or discordance, is coded, and then the priority. The advantage of this variant stems from the fact that, while being inexpensive in terms of memory (small size of buffer), it makes it possible to code the conforming events in only one bit. In addition, in the case of starts of elements, it is possible to evaluate also the conformity of the attributes (which are not necessarily seen as distinct events), and therefore to code the start of the element and the attributes in a single bit in the case of conformity (for the attributes, it is also necessary to code the values, in addition).</p>
<p id="p-0143" num="0164"><figref idref="DRAWINGS">FIG. 9</figref> details steps of determining conformity of an element. During a step <b>200</b>, an element to be processed is obtained. In order to proceed with the determination of the conformity of the element, the content of this element must be entirely known. In the case where the XML data is buffered, it may happen that the size of the buffer does not make it possible to contain the content of the element necessary for calculating the conformity of the element. It is therefore determined whether the known content is sufficient, during a step <b>205</b>, and if not the processing ends during a step <b>290</b>. If on the other hand the content is known, it is determined whether the conformity of the content of the element is already known, during a step <b>210</b>.</p>
<p id="p-0144" num="0165">This occurs in the case where the element studied is a child of an element that has already been processed, this parent element not having been identified as conforming. This is because, if the parent element had been identified as conforming, then all the content of this document would have been encoded as conforming content and step <b>171</b> of <figref idref="DRAWINGS">FIG. 8</figref>, which initiates the determination of the conformity, would then not have been arrived at, the result of step <b>170</b> then being positive. In the case where conformity is known, it is not necessary to repeat the determination of conformity, and the processing therefore ends during step <b>290</b>.</p>
<p id="p-0145" num="0166">If conformity is not known, the determination of the conformity is begun by the initialization to &#x201c;true&#x201d; of the conformity of the attributes and children, during a step <b>220</b>. This procedure is followed since, in the case where the attributes and children are opaque (see <figref idref="DRAWINGS">FIG. 9</figref>), it is considered that any content will be conforming (however, because of opacity, the data will be encoded in a conventional manner with priorities). During a step <b>230</b>, it is determined whether the attributes are opaque. This information is associated with the grammar associated with the event. If the result of step <b>230</b> is negative, during a step <b>231</b> detailed with regard to <figref idref="DRAWINGS">FIG. 10</figref>, it is determined whether the attributes are conforming. If such is not the case, the conformity of the attributes is changed to &#x201c;false&#x201d;, during a step <b>232</b>, and then the opacity of the attributes is updated, during a step <b>235</b>, detailed with regard to <figref idref="DRAWINGS">FIG. 15</figref>. In the case where the result of step <b>231</b> is positive, the step <b>235</b> of updating the opacity of the attributes is also passed to.</p>
<p id="p-0146" num="0167">If the result of step <b>230</b> is positive, that is to say if the attributes are opaque or following step <b>235</b>, during a step <b>240</b>, the opacity of the children is determined, the children all being direct descendants of the element in question. It should be noted that the children are usually textual content nodes or elements, but that it may also be a question of comments or processing instructions. In a similar manner to what is done for the attributes, the first step, in the case where the children are not opaque, is to determine the conformity of the children, during a step <b>241</b>. Two types of conformity exist for children: direct conformity, which concerns direct children, and general conformity, which concerns the children and their own children, and this recursively. The conformity used here is general conformity. If the general conformity is not positive, then the conformity of the children is changed to &#x201c;false&#x201d; during a step <b>242</b>. Following step <b>242</b> or if the result of step <b>241</b> is positive, during a step <b>245</b>, the opacity of the children is updated.</p>
<p id="p-0147" num="0168">In a variant, it is possible not to carry out the updating of the opacity of the children. Thus it is possible for example to decide in advance to fix the opacity of the children by means of parameters at the start of the encoding and, in this case, the opacity will remain the same throughout the encoding. This variant can also apply to the case of attributes.</p>
<p id="p-0148" num="0169">In a variant, the determination of conformity is carried out automatically, even in the case where the grammar is opaque, and the proportion of absences of conformity is recalculated after each determination of conformity. In this way, an opaque grammar can lose its opaque character if the proportion of absences of conformity drops again below an opacity threshold described with regard to step <b>750</b> illustrated in <figref idref="DRAWINGS">FIG. 15</figref>.</p>
<p id="p-0149" num="0170">If the result of step <b>240</b> is negative, or following step <b>245</b>, during a step <b>250</b> it is determined whether the attributes and content are conforming. If so, during a step <b>270</b>, the element is considered to be conforming. Otherwise, during a step <b>260</b>, the element is considered to be non-conforming. In both cases, the processing then ends during a step <b>290</b>. It should be noted that, in the case where the attributes are opaque or the children are conforming, it is necessary to code the first child by indicating its priority. This is because, the attributes being opaque, they are coded with priorities, and the decoder does not have the possibility of knowing that attributes are being passed to the children if this is not indicated to it. By encoding the first child with its priority, the decoder is capable of making the transition between the attributes and the children and, once the first child is decoded, passing into the management of conforming children.</p>
<p id="p-0150" num="0171">The process of comparing the XML data with the grammars (determination of conformity) requires, as detailed in <figref idref="DRAWINGS">FIGS. 10 and 11</figref>, navigating in parallel in the XML data and in the grammars. In order to reduce the cost of the comparison, it may be advantageous, during the first determination of conformity for a given grammar, to generate the corresponding XML events (that is to say the events obtained when the grammar is run through) and to store them in a structure associated with this grammar, for example in the form of a list of events. Thus, if the grammar does not change, it is possible to dispense with navigating in the grammars when the conformity is determined, since it suffices to compare the XML events to be encoded with the events expected according to the grammar. In the case where the grammar changes, the list of events is modified in order to reflect the modification made to the grammar. One problem that may arise, when it wished to generate the XML events from the grammars, stems from the grammars defining loops. This is the case for example with the grammar describing an element A, this element A itself containing another element A. In order to avoid saturating the memory, it is possible to fix an arbitrary limit to the number of events generated (for example linked to the size of the buffer, since it will never be possible to compare more events than there are in the buffer). Another solution, more sophisticated, consists of constructing only the XML events corresponding to the direct children of an element, and then iterating on the sub-elements if the evaluation has been successful. In this case, there necessarily arrives a moment when the evaluation fails, the grammar forming a loop but the XML data processed not forming one, and the problem is therefore resolved (in the case of an element A containing another element A, there necessarily arrives an instance of A in the XML data processed that does not contain A, otherwise the document would be infinite). Finally, since the evaluation fails certainly in the case of a loop, one of the grammars to which the loop relates will necessarily become opaque: as from this time, the problem of evaluation is no longer posed.</p>
<p id="p-0151" num="0172"><figref idref="DRAWINGS">FIG. 10</figref> describes the determination of the conformity of the attributes &#x201c;Ai&#x201d; of an XML element. During a step <b>300</b>, the index &#x201c;i&#x201d; of the attributes of the element is initialized and there is obtained &#x201c;a&#x201d;, the first attribute contained in the grammar G corresponding to the element in question. It should be noted that the first attribute &#x201c;a&#x201d; is zero if the grammar contains no element. Then, during a step <b>310</b>, it is determined whether the number of attributes Ai of the element is equal to the number of attributes in the grammar. If such is not the case, the attributes Ai cannot be conforming with respect to the grammar, and the conformity is therefore changed to &#x201c;false&#x201d;, during a step <b>360</b>, before ending the processing, during a step <b>390</b>.</p>
<p id="p-0152" num="0173">If on the contrary the number of attributes Ai of the element is equal to the number of attributes in the grammar, during a step <b>320</b> it is determined whether the index &#x201c;i&#x201d; is less than the number of attributes.</p>
<p id="p-0153" num="0174">If such is the case, this means that there remains at least one attribute to be processed and, during a step <b>350</b>, the attribute Ai is compared with the attribute &#x201c;a&#x201d; obtained from the grammar. If these two attributes are not equal, that is to say if they have different names, the conformity is marked as false, during a step <b>360</b>, and the processing ends at step <b>390</b>. On the other hand, if the attributes are identical, the index &#x201c;i&#x201d; is incremented and &#x201c;a&#x201d; is replaced by the following attribute of G. It should be noted that, &#x201c;a&#x201d; being zero if all the attributes of G have already been processed, during a step <b>340</b>, then step <b>320</b> is returned to so as to reiterate the comparison of attributes.</p>
<p id="p-0154" num="0175">When, during step <b>320</b>, it is determined that &#x201c;i&#x201d; is equal to the number of attributes, during a step <b>330</b>, the conformity changes to &#x201c;true&#x201d;, all the attributes having been compared successfully, and the processing ends at step <b>390</b>.</p>
<p id="p-0155" num="0176">It should be noted that the mechanism described here would function identically if it were sought to take into account the declaration of namespaces, or &#x201c;namespaces&#x201d; in English. These declarations, like the attributes, take place in the starts of elements. In practice, this type of conformity is not in all cases advantageous since many XML documents contain only a few declarations of namespaces, and this in the root element.</p>
<p id="p-0156" num="0177"><figref idref="DRAWINGS">FIG. 11</figref> describes the determination of the conformity of the children &#x201c;ENi&#x201d; of an element &#x201c;E&#x201d;. During this processing, two types of conformity are determined: the direct conformity of the children &#x201c;ENi&#x201d;, and the general conformity, which takes into account the descendants of the children &#x201c;ENi&#x201d;, according to a recursive conformity analysis. Direct conformity is used for considerations of opacity, while general conformity is used for encoding the content of the element depending on whether or not it is in conformity with the grammar. Distinguishing in this way direct conformity from general conformity makes it possible to avoid, as soon as the content of a child is not conforming, the content of the parent in its turn becoming non-conforming, such as for example in the document illustrated in <figref idref="DRAWINGS">FIG. 4</figref>.</p>
<p id="p-0157" num="0178">The processing begins at a step <b>400</b> of initializing the direct and general conformities to the value &#x201c;true&#x201d; and that of &#x201c;EN&#x201d; with the value &#x201c;EN0&#x201d; corresponding to the first child or the value &#x201c;0&#x201d; if no child exists. The index expected according to the grammar is then calculated, during a step <b>410</b> detailed with regard to <figref idref="DRAWINGS">FIG. 12</figref>, an index that corresponds to the index in the grammar of the production describing the next event to occur if the data is conforming. Moreover, the index actually obtained by virtue of the grammar and the current event is calculated, during a step <b>420</b>. It should be noted that the grammar returns the index of the production describing a given event when the type of event and, if the event has a name, its name, is supplied to it. Then, during a step <b>430</b>, the index expected and the index obtained are compared. If these indices are not equal, this means that the children are not in conformity with the grammar: direct conformity is therefore false and, consequently, general conformity is also false, which is marked during a step <b>435</b>, and the processing ends during a step <b>490</b>.</p>
<p id="p-0158" num="0179">On the other hand, if the indices are equal, this means that the children processed up till now are conforming, and a step <b>440</b> is therefore passed to, which consists of determining whether the event is a start of an element. It should be noted that, for more clarity, &#x201c;sub-element&#x201d; is spoken of in order to differentiate on the one hand the element or &#x201c;principal element&#x201d; and on the other hand the sub-elements, elements that are children of the principal element. Step <b>440</b> therefore consists of determining whether the event is a start of a sub-element.</p>
<p id="p-0159" num="0180">If the event is not a start of a sub-element, during a step <b>450</b>, it is determined whether or not this is the end of a sub-element, which consists of determining firstly whether no further child to be processed remains and secondly whether the next event to occur in the grammar is the end of the principal element, these two conditions being achieved for a sub-element end. If actually at the end of the sub-element, the processing ends at step <b>490</b>. Otherwise the following child is passed to, during a step <b>480</b>, the following child possibly being zero if no child remains, and then the processing is resumed at step <b>410</b>.</p>
<p id="p-0160" num="0181">In the case where the result of step <b>440</b> is positive, that is to say if the event is a sub-element start, during a step <b>460</b>, detailed in <figref idref="DRAWINGS">FIG. 9</figref>, the conformity of the sub-element is determined. If the conformity is not positive, the general conformity is changed to &#x201c;false&#x201d;, during a step <b>475</b>. It should be noted that direct conformity is not involved since the child &#x201c;EN&#x201d; was indeed the child expected according to the grammar, it is only its content that may not be in conformity. If the result of step <b>460</b> is positive or following step <b>475</b>, during a step <b>480</b>, the following child is obtained and step <b>410</b> is returned to.</p>
<p id="p-0161" num="0182">In the case where the comparison is made by taking account of the spaces, during a processing illustrated in <figref idref="DRAWINGS">FIG. 13</figref>, the comparison may also include a step where it is determined whether the spaces have already been encoded and therefore form part of the indexed-vocabulary tables. This is because, if such is the case, it is not necessary to encode information at each space in order to specify whether this makes reference to an indexed word, an indexed space in this case, or if its value is actually written as a character string, these characters being for example spaces or line returns. This method can easily be generalized to text nodes and to attribute values. These values having a lower probability of redundancy, it may be advantageous in this case to define the opacity concerning them as initially true; in the case where the evaluation is positive (typically in the case where the values are included in a restricted set: enumeration, Boolean, etc), the opacity will become false according to a criterion that is a function of the number of instances of the parent event and the number of possible values.</p>
<p id="p-0162" num="0183"><figref idref="DRAWINGS">FIG. 12</figref> describes the calculation of the index expected according to a grammar, the calculation beginning at step <b>500</b>. It should be noted that the calculation of the expected index is based on navigation in the grammars, this navigation being determined by Efficient XML. In the embodiment described and depicted, this navigation involves no novelty, and is therefore not detailed: in the same way as when a document is encoded with Efficient XML, it is sometimes necessary to stack grammars, when the depth of the document increases and/or at the start of an element, or to unstack grammars, when the depth of the document decreases and/or at the end of an element. Moreover, Efficient XML separates the conceptual grammar from an element in two grammars, one corresponding to the start of the element, a grammar that contains in particular attributes, and the other containing the children of the element. However, it happens that the grammar of the element start also contains a child and it is therefore necessary, when making comparisons, to use the two grammars.</p>
<p id="p-0163" num="0184">During a step <b>510</b>, it is determined whether it is a case of initialization, that is to say whether it is the first time, for the element where the conformity of the children is determined, that the expected index is calculated. If such is the case, during a step <b>515</b>, the first production inserted that can be a child of the element is sought in the grammar. &#x201c;Inserted&#x201d; means that it is not a case of a production present in the default grammar. &#x201c;May be a child&#x201d; means that it is not a case of an attribute or the declaration of a namespace but for example a start of an element, a textual content or a comment.</p>
<p id="p-0164" num="0185">If it is not a case of an initialization, the processing continues with step <b>520</b>, where it is determined whether a change of grammar is necessary, a case that presents itself when passing from the grammar describing the start of the element to the grammar describing its children. If such is the case, during a step <b>521</b>, the new grammar is obtained and then, during a step <b>522</b>, the expected index is calculated in the same way as during step <b>515</b>, the index of the first production inserted being able to be an element child.</p>
<p id="p-0165" num="0186">If the result of step <b>520</b> indicates that there is no need to change grammar, the current value of the expected index for the determination of current conformity is simply decremented, during a step <b>530</b>. This is because, according to the way in which the rules are inserted in the grammar, it is known that the following event, if the data is in conformity with the grammar, will be the one corresponding to the production that immediately follows, that is to say that with the immediately lower index.</p>
<p id="p-0166" num="0187">After steps <b>515</b>, <b>522</b> or <b>530</b>, during a step <b>540</b> it is determined whether the expected index is equal to &#x201c;&#x2212;1&#x201d;. If such is the case, this means that all the children have been processed and that therefore the next event is the end of the element. The value of the expected index is therefore modified with the index of the production describing the end of the element, during a step <b>541</b>. At the end of step <b>541</b> or if the result of step <b>540</b> is negative, the processing ends during a step <b>545</b>.</p>
<p id="p-0167" num="0188">There is described, with regard to <figref idref="DRAWINGS">FIG. 13</figref>, the calculation of the expected index in the case where it is assumed that the work is on a document containing spaces, or &#x201c;whitespaces&#x201d; in English. Certain points of details appearing in <figref idref="DRAWINGS">FIG. 12</figref> do not appear in <figref idref="DRAWINGS">FIG. 13</figref> for the purpose of emphasizing the aspects specific to the taking into account of spaces. In particular, in <figref idref="DRAWINGS">FIG. 13</figref>, the case of changing grammar is not mentioned and the case where the index is equal to &#x201c;&#x2212;1&#x201d; and where the index corresponding to the production describing the end of an element is chosen, this correspondence here being implicit, is not dealt with.</p>
<p id="p-0168" num="0189">In order to calculate the expected index, during a step <b>560</b>, it is determined whether the expected index must be initialized. If so, during a step <b>561</b>, the expected index takes the value of the index corresponding to the first production inserted describing a child and the processing ends during a step <b>590</b>. On the other hand, if the index is not to be initialized, during a step <b>570</b>, it is determined whether the previous index calculated, which is still the current index, corresponds to a space. If so, during a step <b>571</b>, the expected index is given the value of the index saved previously, that is to say the index that it would have been necessary to use for the current event but which was replaced by the index corresponding to a space. The processing then ends during step <b>590</b>.</p>
<p id="p-0169" num="0190">If, during step <b>570</b>, it is determined that the previous index calculated does not correspond to a space, during a step <b>580</b> the value of the expected index is decremented and then, during a step <b>581</b>, it is determined whether the index is that of a start or end of element. If such is the case, during a step <b>582</b>, it is determined whether the index previously calculated was also that of a start or end of element. If so, this means that there are two starts of an element, two ends of elements, a start and an end of an element or an end and a start of consecutive elements, and therefore that it is necessary to insert a space between the two if it is wished for the grammar to correspond to the data. It should be noted that, in the case where an end of element follows a start of element, this insertion is not always necessary, and it may therefore be advantageous not to process this case of the standard case differently. During step <b>583</b>, the expected index calculated during step <b>580</b> is saved, in order to be able to use it at the next calculation of the expected index, and then the expected index is given the value of the index of the production describing the textual content. Following step <b>583</b> or if the result of one of steps <b>581</b> and <b>582</b> is negative, the processing ends during step <b>590</b>.</p>
<p id="p-0170" num="0191"><figref idref="DRAWINGS">FIG. 14</figref> describes the updating of a grammar G after the use of a production P. This processing is applied both during encoding and during decoding. During a step <b>610</b>, it is determined whether the production priority used is of level &#x201c;0&#x201d;, that is to say a priority written with a single figure, for example &#x201c;0&#x201d;, &#x201c;1&#x201d; or &#x201c;2&#x201d;, as opposed to a priority of level &#x201c;1&#x201d; written with two figures such as for example &#x201c;2.0&#x201d; or of level <b>2</b> with three figures such as for example &#x201c;2.0.0&#x201d;. If the priority is of level &#x201c;0&#x201d;, this means that P describes as well as possible the event that is encoded, and there is therefore not any need to add a more complete new production P&#x2032; to the grammar. A step <b>690</b> is therefore passed to, where the processing ends.</p>
<p id="p-0171" num="0192">If on the other hand the priority of the production used is not of level &#x201c;0&#x201d;, this means that a generic rule is used, for which the priority requires more bits in order to be encoded, and it is therefore advantageous to add a new rule P&#x2032; having a priority of level &#x201c;0&#x201d;, which allows a more efficient encoding. This is because the number of bits required is lower, and, if it is a case of an event having a name, the name will be integrated in the production P&#x2032;, which will avoid encoding it during following occurrences.</p>
<p id="p-0172" num="0193">It should be noted that inserting new productions having a priority of level &#x201c;0&#x201d; and possibly including a name is not peculiar to the invention: it is a case of the normal functioning of Efficient XML. On the other hand, by implementing the present invention, the position of insertion of the productions reflects the order of appearance of the XML events, while with Efficient XML the productions are simply inserted at the start of the grammars.</p>
<p id="p-0173" num="0194">During a step <b>620</b>, the index &#x201c;i&#x201d; of the last production with a priority of level &#x201c;0&#x201d; to have been used for encoding an event of the grammar in question is determined, this index being updated each time a priority of level &#x201c;0&#x201d; is used. By default, that is to say in the case where no production has been used, this index is equal to &#x201c;0&#x201d;. The new production P&#x2032;, obtained conventionally, in particular by adding the name to P if the event in question has a name and, otherwise, a simple copying of P, is then inserted at the index &#x201c;i&#x201d; in the grammar, during a step <b>630</b>. Then the priorities of the following productions are incremented (all those whose level &#x201c;0&#x201d; was equal to &#x201c;i&#x201d; or more). In this way, the uniqueness of the priorities is well preserved. It should be noted that, with Efficient XML, since the productions were inserted at position 0, all the priorities must be incremented. The processing then ends during step <b>690</b>.</p>
<p id="p-0174" num="0195"><figref idref="DRAWINGS">FIG. 15</figref> describes the updating of the opacity for a grammar G. The way of updating the opacity does not vary according to the type of opacity in question (opacity of attributes, opacity of children). This is why opacity is spoken of generically with regard to this <figref idref="DRAWINGS">FIG. 15</figref> but, in practice, the opacity of a grammar G is updated for a given criterion: updating of the opacity for the attributes, updating of the opacity for the children, each type of opacity being characterized with its own variables: number of comparisons made and number of absences of conformity encountered.</p>
<p id="p-0175" num="0196">The processing is begun with the incrementation of the number of comparisons made, during a step <b>710</b>. Next, during a step <b>720</b>, it is determined whether the data is in conformity, that is to say whether or not the comparison has succeeded. If such is the case, then the processing ends during a step <b>790</b>. On the other hand, in the case where the data is not in conformity, during a step <b>730</b>, the number of absences of conformity encountered is incremented. Then, during a step <b>740</b>, the number of comparisons made is compared with a predetermined number. This predetermined number corresponds to the minimum number of comparisons to be made before being able to consider a grammar as opaque in the light of the opacity threshold. This is because, if a single comparison has been made and an absence of conformity has been determined, the degree of absence of conformity is 100%. However, it is not pertinent to make the grammar opaque since few data has been processed. A minimum number of comparisons to be made below which the proportion of absences of conformity is not compared with the opacity threshold defined below it in relation to step <b>750</b> is therefore predetermined (in absolute terms, this minimum number can for example be equal to five or ten: the lower it is the greater the risk of making a grammar opaque without this being justified; the higher it is the greater the risk of failing in determinations of conformity because of an element that it would be pertinent to consider as opaque. Consequently, if it is known in advance which types of document will be encoded, it is advantageous to fix the minimum number after having carried out experiments on files of this type.</p>
<p id="p-0176" num="0197">If the number of comparisons made is less than the minimum number of comparisons to be made, then the processing ends during step <b>790</b>. In the contrary case, during a step <b>750</b>, the proportion of absences of conformity is compared with a predetermined opacity threshold. There also, the opacity threshold is a compromise and it may therefore be advantageous to fix it after experiments if the intention is to work on a precise type of file. In absolute terms, it may be considered that, as from 10% or 20% of absences of conformity, it is pertinent to declare the grammar opaque for the criterion in question. If the proportion of absences of conformity is greater than the opacity threshold, during a step <b>760</b> the data is declared opaque. Following step <b>760</b> or if the proportion of absences of conformity is below the opacity threshold, the processing ends at step <b>790</b>.</p>
<p id="p-0177" num="0198"><figref idref="DRAWINGS">FIG. 16</figref> describes the decoding of a document encoded according to the particular embodiment of the encoding method that is the object of the present invention described previously. During a step <b>800</b>, the document is obtained. Then, during a step <b>810</b>, it is determined whether data conforming to a grammar is decoded. It is known whether the data is conforming by virtue of the data previously decoded. By default, the data is not conforming. In the case where the data is not conforming, during a step <b>811</b>, there is obtained the event to be followed by the decoding of a priority and, where applicable, by the decoding of the information complementary to this event, in particular its name for the start of an element. Then, during a step <b>812</b>, it is determined whether the decoded event is a start of an element. If such is the case, during a step <b>813</b>, it is determined whether the grammar describing the content of this element is opaque. If such is not the case, during a step <b>814</b>, the bit indicating the conformity of the content of the element is indicated, a bit equal to &#x201c;1&#x201d; for conforming data and &#x201c;0&#x201d; for non-conforming data. Then a step <b>830</b> of generating the decoded event is passed to.</p>
<p id="p-0178" num="0199">If, during step <b>813</b>, it is determined that the grammar is opaque, step <b>830</b> is performed. This is because, the grammar being opaque, there is no conformity bit to be decoded.</p>
<p id="p-0179" num="0200">If, during step <b>810</b>, it is determined that the data is conforming, during a step <b>820</b>, the event is obtained from the current grammar. Following step <b>820</b> or if the result of step <b>812</b> is negative, that is to say if the event is not a start of an element, during a step <b>821</b>, it is determined whether the event currently being decoded has a value, which is the case with the events with a text content in particular. If so, during a step <b>822</b>, the value of the event is decoded. Following step <b>822</b> or if, during step <b>821</b>, it was determined that the event has no value, the step <b>830</b> of generating the event is passed to.</p>
<p id="p-0180" num="0201">After step <b>830</b>, during a step <b>840</b>, detailed with regard to <figref idref="DRAWINGS">FIG. 17</figref>, the opacity data is updated. Then, during a step <b>850</b>, the grammars are updated. During a step <b>860</b>, it is determined whether the decoded event is the end of the document. If such is the case, the processing ends during a step <b>890</b>. Otherwise the processing continues at step <b>810</b>.</p>
<p id="p-0181" num="0202"><figref idref="DRAWINGS">FIG. 17</figref> describes the updating of the opacity data during the decoding of a document. This data concerns here the attributes and children. However, this data can, in the same way, apply to other data, for example to the namespaces that can be processed in the same way as the attributes, as disclosed above.</p>
<p id="p-0182" num="0203">During a step <b>910</b>, it is determined whether the current grammar is opaque for the current criterion. If such is the case, the processing ends during a step <b>990</b>. If the grammar is not opaque, the expected index is compared with the index obtained, during a step <b>920</b>. The expected index is the index of the production that must occur if the order of the grammar is followed, while the index obtained is the index actually obtained when the production is sought describing the decoded event in the grammar. It should be noted that, if the decoded data is conforming data, the expected index will necessarily be the same as the index obtained. However, it is necessary to update the opacity data, including in the case of success in the comparison, since the data has been encoded as conforming.</p>
<p id="p-0183" num="0204">If the expected and obtained indices are different, during a step <b>930</b>, it is accepted that, for the current grammar and the current parameter, typically attributes or children, the comparison has shown an absence of conformity and the processing ends during a step <b>990</b>. This is because, in order to increment counters, it is necessary to wait until the end of the element has been reached. Otherwise the opacity data would not be identical to that used by the encoder when the document was encoded.</p>
<p id="p-0184" num="0205">In the case where the expected index and the index obtained are identical, during a step <b>940</b>, it is determined whether the decoded event corresponds to the end of the element described by the current grammar. If such is not the case, the processing ends at step <b>990</b>. If it is a case of the end of the element, then the number of comparisons made for this grammar is incremented, during a step <b>950</b>, and then, during a step <b>960</b>, it is determined, for the attributes and for the children, whether the grammar must be declared opaque. For this purpose, the first step is to determine whether there has been an absence of conformity for the attributes. If so, during a step <b>961</b>, the number of absences of conformity for the attributes is incremented. Then, during a step <b>962</b>, the proportion of conformity absences is compared with the opacity threshold. The fact that the number of comparisons must be greater than a minimum number is not indicated in <figref idref="DRAWINGS">FIG. 17</figref>, but this is the case, in a completely similar manner to what is done during encoding. It is also crucial that the encoder and decoder share the same values for these parameters, otherwise decoding is not possible. If the proportion of absences of conformity is greater than the opacity threshold, then the grammar is considered to be opaque for the attributes, during a step <b>963</b>.</p>
<p id="p-0185" num="0206">If the result of one or other of steps <b>960</b> and <b>962</b> is negative, or following step <b>963</b>, during a step <b>970</b>, it is determined whether the comparison has shown an absence of conformity concerning the children. If so, during a step <b>971</b> the number of absences of conformity for the children is incremented. Thus, during a step <b>972</b>, the proportion of absences of conformity is compared with the opacity threshold. If the proportion of absences of conformity is greater than the opacity threshold, during a step <b>973</b>, the grammar is considered to be opaque for the children. If the result of one or other of steps <b>970</b> and <b>972</b> is negative or after step <b>973</b>, the processing ends during step <b>990</b>.</p>
<p id="p-0186" num="0207">It should be noted that, although, above, only one opacity threshold value was considered, both for the attributes and for the children, in variants, different values of this threshold are used according to the proportion to which it applies.</p>
<p id="p-0187" num="0208">There can be seen, in <figref idref="DRAWINGS">FIG. 18</figref>, a device that is the object of the present invention, or coder, <b>1000</b> and various peripherals adapted to implement the present invention. In the embodiment illustrated in <figref idref="DRAWINGS">FIG. 18</figref>, the device <b>1000</b> is a microcomputer of a known type connected, by means of an input card <b>1004</b>, to a means of acquiring or storing hierarchized data organized in a plurality of events, for example at least one XML document.</p>
<p id="p-0188" num="0209">The device <b>1000</b> comprises a communication interface <b>1018</b> connected to a network <b>1034</b> able to transmit, as an input, data to be encoded or decoded and/or, as an output, data encoded or decoded by the device. The device <b>1000</b> also comprises a storage means <b>1012</b>, for example a hard disk, and a drive <b>1014</b> for a diskette <b>1016</b>. The diskette <b>1016</b> and the storage means <b>1012</b> can contain data to be encoded or decoded, the encoded or decoded data and a computer program adapted to implement the method that is the object of the present invention.</p>
<p id="p-0189" num="0210">According to a variant, the program enabling the device to implement the present invention is stored in read-only memory ROM (the acronym for &#x201c;read-only memory&#x201d;, meaning non-rewritable memory) <b>1006</b>. According to another variant, the program is received by means of the communication network <b>1034</b> before being stored.</p>
<p id="p-0190" num="0211">This same device <b>1000</b> has a screen <b>1008</b> for displaying the data to be encoded or decoded or serving as an interface with the user in order to parameterize certain execution modes of the device <b>1000</b>, by means of a keyboard <b>1010</b> and/or a mouse for example.</p>
<p id="p-0191" num="0212">A central unit CPU (the acronym for &#x201c;central processing unit&#x201d;) <b>1003</b> executes the instructions of the computer program and programs necessary for its functioning, for example an operating system. When the device <b>1000</b> is powered up, the program stored in a non-volatile memory, for example the read-only memory <b>1006</b>, the hard disk <b>1012</b> or the diskette <b>1016</b>, are transferred into a random access memory RAM (the acronym for &#x201c;random access memory&#x201d;) <b>1008</b>, which will then contain the executable code of the program implementing the method that is the object of the present invention as well as registers for storing the variables necessary for its use.</p>
<p id="p-0192" num="0213">Naturally, the diskette <b>1016</b> can be replaced by any removable information carrier, such as a compact disk, USB key or memory card. In more general terms, an information storage means, which can be read by a computer or a microprocessor, integrated or not into the device, possibly removable, stores a program implementing the coding method that is the object of the present invention. A communication bus <b>1002</b> affords communication between the various elements included in the device <b>1000</b> or connected to it. The representation in <figref idref="DRAWINGS">FIG. 18</figref> of the bus <b>1002</b> is not limiting and in particular the central unit <b>1003</b> is able to communicate instructions to any element of the device <b>1000</b> directly or by means of another element of the device <b>1000</b>.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>The invention claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method of encoding hierarchized data organized in a plurality of events, comprising:
<claim-text>obtaining a first information set of at least one event to be encoded;</claim-text>
<claim-text>recovering a grammar based on the first information set, the grammar making it possible to describe at least the first information set;</claim-text>
<claim-text>determining a second information set including at least structural information, from the recovered grammar;</claim-text>
<claim-text>comparing the determined second information set to the first information set of at least one event to be encoded to determine whether at least a part, defined by a predetermined criterion, of the first information set of at least one event to be encoded can be predicted unequivocally from the grammar;</claim-text>
<claim-text>if the result of the comparison step is positive, encoding the unequivocally predicted part of the first information set using only a general code representing conformity information that is common to all information sets; and</claim-text>
<claim-text>encoding the information of each event to be encoded of the first information set that is not included in the determined second information set; and</claim-text>
<claim-text>if the result of the comparison step is negative, encoding the first information set using at least priorities from the recovered grammar.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein, during the comparison step, at least one event generated from predictions of the grammar ordered in a predefined manner is recovered and the set of information is compared with at least one event generated with the first information set of at least one event to be encoded.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein, during the obtaining step, the first information set of at least one event to be encoded comprises structure information of at least one event to be encoded.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein, during the obtaining step, the first information set of at least one event to be encoded comprises information indicating whether the value of the event can be encoded by reference to a previously encoded value.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first information set of at least one event to be encoded is divided into a plurality of subsets of information and the result of the comparison step is positive if a predetermined selection of subsets of information of at least one event to be encoded can be predicted unequivocally from the grammar.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method according to <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein a subset is selected according to the number of times that the information subset has been able to be predicted unequivocally from the grammar and/or the number of times that the information subset has not been able to be predicted, during the coding of at least one previous event to be encoded among the plurality of events.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method according to <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein, if the result of the comparison step is positive and the first information set comprises at least one non-selected information subset, the method also comprises a step of encoding each non-selected information subset.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method according to <claim-ref idref="CLM-00005">claim 5</claim-ref>, further comprising if the result of the comparison step is negative, encoding another general code different from the general code, representing non-conformity information that is common to all information sets.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method according to <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein an information subset of the first information set comprises the information relating to the events of the text type.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method according to <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein an information subset of the first information set comprises information relating to the events of the attribute type.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method according to <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein an information subset of the first information set comprises the information relating to the events of the start of element type.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein, during the step of recovering a grammar, the grammar is recovered according to at least one previously encoded event.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising updating the grammar recovered from the first information set of at least one event to be encoded.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The method according to <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein, during the implementation of a step of encoding all or part of the first information set, the step of updating the recovered grammar accounts for the order of the events to be encoded.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein a structure of the event is predicted from the recovered grammar.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The method according to <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the predicted structure is compared to the event to be encoded to determine whether or not they correspond to each other.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The method according to <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein in encoding the conformity information, the predicted structure is encoded when it is determined that the predicted structure corresponds to the event to be encoded.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The method according to <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the information of each event to be encoded in the encoding step includes information of the event that is not described by the predicted structure.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. A method of decoding hierarchized data organized in a plurality of events, comprising:
<claim-text>obtaining conformity information representing that at least part of a first information set of at least one event to be decoded can be predicted unequivocally from a grammar, wherein whether the at least one event can be predicted unequivocally is determined by comparing the first information set with a second information set including at least structural information from the grammar, wherein the unequivocally predicted part of the first information set is encoded using only a general code representing the conformity information, wherein the conformity information is common to all information sets, and wherein the encoding encodes the information of each event to be encoded of the first information set that is not included in the second information set;</claim-text>
<claim-text>obtaining the grammar; and</claim-text>
<claim-text>generating the unequivocally predicted information from the grammar.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The method according to <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein the step of obtaining the conformity information comprises decoding the conformity information.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The method according to <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein, during the step of obtaining the conformity information, the conformity information is obtained according to previous decodings.</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. A device for encoding hierarchized data organized in a plurality of events, comprising:
<claim-text>a means for obtaining a first information set of at least one event to be encoded;</claim-text>
<claim-text>a means for recovering a grammar based on the first information set, the grammar making it possible to describe at least the first information set;</claim-text>
<claim-text>a determining means for determining a second information set including at least structural information, from the recovered grammar;</claim-text>
<claim-text>a comparing means for comparing the determined second information set to the first information set of at least one event to be encoded to determine whether at least a part, defined by a predetermined criterion, of the first information set of at least one event to be encoded can be predicted unequivocally from the grammar; and</claim-text>
<claim-text>an encoding means for encoding, if the result of the comparison step is positive, the unequivocally predicted part of the first information set using only a general code representing conformity information that is common to all information sets, and the information of each event to be encoded of the first information set that is not included in the determined second information set,</claim-text>
<claim-text>wherein if the result of the comparison step is negative, the first information set is encoded using at least priorities from the recovered grammar.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00023" num="00023">
<claim-text>23. A device for decoding hierarchized data organized in a plurality of events, comprising:
<claim-text>a means for obtaining information representing that at least part of a first information set of at least one event to be decoded can be predicted unequivocally from a grammar, wherein whether the at least one event can be predicted unequivocally is determined by comparing the first information set with a second information set including at least structural information from the grammar, wherein the unequivocally predicted part of the first information set is encoded using only a general code representing conformity information that is common to all information sets, and wherein the encoding encodes the information of each event to be encoded of the first information set that is not included in the second information set;</claim-text>
<claim-text>a means for obtaining the grammar; and</claim-text>
<claim-text>a means for generating the unequivocally predicted information from the grammar. </claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
