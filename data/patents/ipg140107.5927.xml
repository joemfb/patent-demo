<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627036-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627036</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13230109</doc-number>
<date>20110912</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<us-term-of-grant>
<us-term-extension>192</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>12</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>711166</main-classification>
<further-classification>711156</further-classification>
<further-classification>711158</further-classification>
<further-classification>711159</further-classification>
<further-classification>345535</further-classification>
<further-classification>345543</further-classification>
</classification-national>
<invention-title id="d2e53">Memory management techniques</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5928365</doc-number>
<kind>A</kind>
<name>Yoshida</name>
<date>19990700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5999528</doc-number>
<kind>A</kind>
<name>Chow et al.</name>
<date>19991200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370365</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6021132</doc-number>
<kind>A</kind>
<name>Muller et al.</name>
<date>20000200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370412</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6081505</doc-number>
<kind>A</kind>
<name>Kilkki</name>
<date>20000600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370230</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>6229822</doc-number>
<kind>B1</kind>
<name>Chow et al.</name>
<date>20010500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370474</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>6269081</doc-number>
<kind>B1</kind>
<name>Chow et al.</name>
<date>20010700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370241</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>6282621</doc-number>
<kind>B1</kind>
<name>Parsons</name>
<date>20010800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>6408313</doc-number>
<kind>B1</kind>
<name>Campbell</name>
<date>20020600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>6947051</doc-number>
<kind>B2</kind>
<name>Gossalia</name>
<date>20050900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>6950919</doc-number>
<kind>B2</kind>
<name>Sharma et al.</name>
<date>20050900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711170</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>7035771</doc-number>
<kind>B2</kind>
<name>Butt</name>
<date>20060400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>7475093</doc-number>
<kind>B2</kind>
<name>Tomic et al.</name>
<date>20090100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>  1  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>7933283</doc-number>
<kind>B1</kind>
<name>Liu et al.</name>
<date>20110400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370412</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2004/0193783</doc-number>
<kind>A1</kind>
<name>Sharma et al.</name>
<date>20040900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711104</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>2011/0093854</doc-number>
<kind>A1</kind>
<name>Blanc et al.</name>
<date>20110400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718101</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>2012/0324196</doc-number>
<kind>A1</kind>
<name>Maillet et al.</name>
<date>20121200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711170</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>2012/0324197</doc-number>
<kind>A1</kind>
<name>Spradlin et al.</name>
<date>20121200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711170</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00018">
<document-id>
<country>US</country>
<doc-number>2012/0324198</doc-number>
<kind>A1</kind>
<name>Spradlin et al.</name>
<date>20121200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711170</main-classification></classification-national>
</us-citation>
<us-citation>
<nplcit num="00019">
<othercit>Gidenstam, Anders et al.; &#x201c;Efficient and Reliable Lock-Free Memory Reclamation Based on Reference Counting;&#x201d; Proceedings of the 8th International Symposium on Parallel Architectures, Algorithms and Networks (ISPAN'05); Dec. 7-9, 2005; pp. 202-207; IEEE Computer Society; Las Vegas, NV.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00020">
<othercit>Withington, P.T.; &#x201c;Memory Management;&#x201d; Published Mar. 13, 2001; pp. 1-33; Callitrope; Cambridge, MA.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00021">
<othercit>&#x201c;AppSense Performance Manager: Memory Control and Optimization;&#x201d; Copyright Dates: 2000-2008; Retrieved Date: Jun. 24, 2011; pp. 1-16; AppSense Incorporated.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00022">
<othercit>&#x201c;Graphics: Intel(c) 82915G/82910GL Express Chipset Family: Dynamic Video Memory Technology (DMVT 3.0) questions and answers;&#x201d; &#x201c;Last Modified&#x201d; Date: Apr. 20, 2011; &#x201c;Date Created&#x201d; Date: May 19, 2004; pp. 1-3; Intel Corporation.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>20</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>711166</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711156</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711158</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711159</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>345535</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>345543</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>10</number-of-drawing-sheets>
<number-of-figures>10</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20130067186</doc-number>
<kind>A1</kind>
<date>20130314</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Pronovost</last-name>
<first-name>Steve</first-name>
<address>
<city>Woodinville</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Abernethy</last-name>
<first-name>Maxwell</first-name>
<address>
<city>Seattle</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Balaz</last-name>
<first-name>Rudolph</first-name>
<address>
<city>Redmond</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="004" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Chitre</last-name>
<first-name>Ameet</first-name>
<address>
<city>Bellevue</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Pronovost</last-name>
<first-name>Steve</first-name>
<address>
<city>Woodinville</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Abernethy</last-name>
<first-name>Maxwell</first-name>
<address>
<city>Seattle</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Balaz</last-name>
<first-name>Rudolph</first-name>
<address>
<city>Redmond</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="004" designation="us-only">
<addressbook>
<last-name>Chitre</last-name>
<first-name>Ameet</first-name>
<address>
<city>Bellevue</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Chin IP, PLLC</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Chin</last-name>
<first-name>Davin</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Microsoft Corporation</orgname>
<role>02</role>
<address>
<city>Redmond</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Elmore</last-name>
<first-name>Stephen</first-name>
<department>2188</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Memory management techniques that permit an executing process to store content in memory and later retrieve that content from the memory, but that also permit a memory manager to discard that content to address memory pressure. A process executing on a computing device may notify a memory manager of the computing device that first memory space allocated to the process contains first content that is available for discard. If the memory manager detects the computing device is experiencing memory pressure, the memory manager may address the memory pressure by selecting memory space available for discard and discarding the content of the memory space. Before a process reuses content made available for discard, the process may notify the memory manager of the intent to reuse and, in response, receive empty memory and an indication that the content was discarded or receive an indication that the content is still available for use.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="268.39mm" wi="169.33mm" file="US08627036-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="242.74mm" wi="171.79mm" file="US08627036-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="268.99mm" wi="168.49mm" file="US08627036-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="259.67mm" wi="188.89mm" file="US08627036-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="274.07mm" wi="199.81mm" file="US08627036-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="265.09mm" wi="183.22mm" file="US08627036-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="251.71mm" wi="152.99mm" file="US08627036-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="251.63mm" wi="145.97mm" file="US08627036-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="250.87mm" wi="165.10mm" file="US08627036-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="203.12mm" wi="178.99mm" file="US08627036-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="243.92mm" wi="167.81mm" file="US08627036-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND</heading>
<p id="p-0002" num="0001">When multiple processes are executing on a computing device, the processes share the hardware resources of the computing device. Successful execution of all processes requires that no process use so much of any resource that other processes are unable to obtain enough of that resource to execute effectively. Among the hardware resources that can impact effective execution is memory of the computing device.</p>
<p id="p-0003" num="0002">A computing device may have two types of memory, which can be termed &#x201c;fast memory&#x201d; and &#x201c;slow memory.&#x201d; Fast memory is termed &#x201c;fast&#x201d; because exchanging information between fast memory and a processor is relatively quick as compared to exchanging information between slow memory and a processor. Fast memory includes memory that is directly accessible by a processor (e.g., a central processing unit (CPU) or a graphics processing unit (GPU)). Fast memory of a device may include &#x201c;internal memory&#x201d; and can be implemented as random access memory (RAM). Slow memory includes memory that is not directly accessible by a processor, but is instead installed in a computing device remote from a processor. Slow memory of a device may include secondary storage and can be implemented as one or more storage drives. Examples of storage drives include hard disk drives and solid-state drives (SSDs).</p>
<p id="p-0004" num="0003">Computing devices typically include a memory manager that determines how processes will use memory. A process may request from the memory manager one or more blocks of memory space and the memory manager may allocate to each executing process memory space consisting of a range of memory addresses for that process to use. Once the memory space is allocated, the process can write data to and read data from memory using addresses in its assigned range of addresses. When the process finishes using the memory, the process can again interact with the memory manager to request that the memory space be de-allocated or &#x201c;freed&#x201d; so that the memory space is available for use by another process.</p>
<p id="p-0005" num="0004">Because of the speed advantage of fast memory, when processes are interacting with content stored in memory, the content is placed in fast memory. However, the total amount of memory requested by all processes executing on a computing device may be greater than the amount of fast memory available on the computing device. To counter this problem, it is known for memory managers to us a technique called &#x201c;paging.&#x201d; Using paging, content that a process has requested be stored can be temporarily stored in slow memory.</p>
<p id="p-0006" num="0005">In paging, the ranges of memory addresses assigned to processes may be divided into pages. When a process reads or writes content to memory, the &#x201c;page&#x201d; containing that content is loaded in the fast memory. Though, when the page is not actively being accessed by a process, the memory manager may keep the content from the page in a page file in slow memory. A memory manager, for example, may move a page used by a process out of fast memory and store the page in the page file in slow memory, to allow space in the fast memory to be made available for storing other content (and other pages) that are actively being accessed by other processes. When a process needs to use content that has been placed into slow memory, the memory manager can retrieve the page containing the content from the page file in the slow memory and place the page and the content back in fast memory.</p>
<p id="p-0007" num="0006">As mentioned above, a memory manager will allocate memory space containing a range of addresses of memory to a process upon receiving from the process a request for memory. The range of addresses provided to the process are not hardware addresses of fast memory. This is because, when paging is used, the exact location at which content can be accessed in fast memory is not known at the time the memory space and the range of addresses is allocated. Instead, memory space in &#x201c;virtual memory&#x201d; is allocated to a process in response to a request for memory, and &#x201c;virtual addresses&#x201d; are provided to the process. The total amount of virtual memory available on a computing device is the sum of the size of fast memory and the maximum permitted size of the page file in slow memory.</p>
<p id="p-0008" num="0007">Virtual memory addresses are known to the memory manager and can be used by the memory manager to identify the actual locations in memory at which content is stored. A virtual memory address may correspond to an address of fast memory or to a location in the page file in slow memory. When a request to access a particular virtual memory address is received by the memory manager, the memory manager may review records regarding the virtual memory to determine an actual storage location corresponding to the virtual memory address. When the virtual memory address corresponds to a location in the page file in slow memory, the memory manager may retrieve the page containing the virtual memory address from the slow memory and write the page to fast memory. This may include removing another page from the fast memory to make space in fast memory for the page to be written and placing that other page in the page file of slow memory, then updating the actual storage locations of both in records regarding the virtual memory addresses.</p>
<p id="p-0009" num="0008">Accordingly, a process may interact with a memory manager to perform various functions regarding the memory. A process may first request an allocation of memory, in which case the memory manager may &#x201c;allocate&#x201d; to the process an amount of memory space in virtual memory. When the process is interacting with content stored in memory space, the memory manager may ensure that the content is stored in fast memory, and the memory manager may place the content in the page file in slow memory when the process is not interacting with the content. The process may also request that the memory manager &#x201c;de-allocate&#x201d; memory space in virtual memory that was previously allocated if the process will not use the contents of that memory space again. If the process later requires additional memory to store newly generated content, the process can request another allocation of memory space in virtual memory.</p>
<p id="p-0010" num="0009">Interactions with the memory manager, particularly the memory manager's allocation and de-allocation operations, can take a relatively long time for a process and therefore can slow down execution of a process. Because of this, when software designers write the code that defines the processes, the developers may try to reduce the number of allocation and de-allocation operations that are performed by the processes. The software designers may instead use memory &#x201c;reset&#x201d; operations in their code when memory space allocated to that process contains content that is not to be further used by the process. Upon receiving an instruction to &#x201c;reset&#x201d; specified memory space, if pages for that memory space are stored in the fast memory, the memory manager stops preserving the content of the memory space in the fast memory, such as by not writing content of the memory space into the page file when a page in fast memory is to be replaced with another page. No de-allocation of memory space is performed in response to a &#x201c;reset.&#x201d; Though there is no content (and possibly no pages) corresponding to the memory space following a reset of that memory, that memory space of virtual memory continues to be allocated to the process. By retaining the allocation, the memory space will already be available to the process when the process needs memory for some purpose in the future, without the need for a subsequent allocation operation. In this way, the process can avoid lengthy allocation and de-allocation operations. Also, because the content of the reset memory space is not occupying valuable space in the fast memory that can be used by other pages storing content for other memory space, the memory manager is not wasting time or resources managing that content using paging techniques.</p>
<heading id="h-0002" level="1">SUMMARY</heading>
<p id="p-0011" num="0010">Applicants have recognized and appreciated the advantages of allowing an executing process to notify a memory manager that space in virtual memory stores content that is available to be discarded. A memory manager may then conditionally discard that content, depending on memory requests of other processes, such as by removing the content from fast memory and not preserving the content when other content is to be written to fast memory. If the content has not been discarded when the process subsequently encounters an operation using that content, the process may reclaim the content and prevent discard.</p>
<p id="p-0012" num="0011">In conventional scenarios in which processes are not able to make content available for discard and not able to reclaim that content, software developers were likely to write code such that processes permanently retain memory space having content that has only a slight chance of being used again. Retaining such content can lead to fast memory being filled with such unused content, which can be one cause of memory pressure in a computing device. By providing an ability for a process to signal to a memory manager that the content can be discarded, processes may gain the speed advantage of caching more contents in memory, while a memory manager may gain the ability to discard such contents if memory pressure is detected. This may lead to memory in a computing system being more efficiently used.</p>
<p id="p-0013" num="0012">In some embodiments, a process executing on a computing device notifies a memory manager of a computing device that a first memory space allocated to the process contains first content available for discard. At some later time, the process may then notify the memory manager that the process intends to use the first content stored in the first memory space. The memory manager may maintain a record of allocated memory space for which contents are available for discard and not required to be preserved. The memory manager may also detect when a computing device is experiencing memory pressure and, in response, select first memory space from the record and cease to preserve the content of the first memory. When the memory manager receives from a process a notification that the process intends to reuse content previously marked as eligible for discard, then the memory manager may determine whether the content was discarded. If the content was not discarded, the memory manager may make the content available to the process. However, if the content was discarded, then the memory manager may instead make empty memory space available to the process and inform the process that the content was discarded.</p>
<p id="p-0014" num="0013">The foregoing is a non-limiting summary of the invention, which is defined by the attached claims.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF DRAWINGS</heading>
<p id="p-0015" num="0014">The accompanying drawings are not intended to be drawn to scale. In the drawings, each identical or nearly identical component that is illustrated in various figures is represented by a like numeral. For purposes of clarity, not every component may be labeled in every drawing. In the drawings:</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram of an example of a computing environment in which some embodiments may operate;</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 2</figref> is a flowchart of an example of a technique that may be implemented by an executing process for managing memory reserved by the process;</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 3</figref> is a flowchart of an example of a technique for selecting, during designing of a software process, one of a set of available memory management techniques for use;</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 4</figref> is a flowchart of an example of a technique for operating a memory manager of a computing device to manage memory reserved by an executing process;</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 5</figref> is a flowchart of an example of a technique for determining whether a computing device is experiencing memory pressure;</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 6</figref> is a flowchart of an example of a technique for determining, from memory for which the contents are available for discard, particular memory for which the content will be discarded;</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 7</figref> is a flowchart of an example of a technique for discarding of content of selected memory;</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 8</figref> is a flowchart of an example of a technique by which a memory manager may respond to use by an executing process of memory the executing process has indicated includes content available for discard without subsequently requesting that the content be reclaimed;</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 9</figref> is a diagram of one exemplary set of software elements with which embodiments may operate and an order in which the elements may process an offer operation in accordance with techniques described herein; and</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 10</figref> is a block diagram of an example of a computing device with which some embodiments may operate.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0026" num="0025">Applicants have recognized and appreciated the advantages of memory management techniques that permit an executing process (also referred to more simply as a &#x201c;process&#x201d; herein) to store content in memory and later retrieve that content from the memory, but that also permit a memory manager to discard that content before the content is retrieved. Such techniques would enable the memory manager to address incidents of memory pressure more effectively by discarding some content, such as that stored in fast memory, that is not necessary to preserve, while also allowing processes to avoid needing to regenerate content that has not been discarded.</p>
<p id="p-0027" num="0026">Accordingly, described herein are techniques for notifying a memory manager that allocated memory space of virtual memory of a computing device contains content that can be discarded and for subsequently notifying the memory manager of an intent to reuse the content in the memory space so as to prevent later discarding of that content. Additionally described are techniques for operating a memory manager to manage memory in response to such notifications and to detect and address memory pressure by discarding contents stored in fast memory and associated with the memory space indicated to be available for discard. In some embodiments operating in accordance with techniques described herein, when memory space is made available for discard and/or when a memory manager discards content of memory space, the memory space of virtual memory may continue to be allocated to a process. Because the memory space continues to be allocated, if content has been discarded the process can regenerate the content when needed and store the content in the previously-allocated memory space, without needing to perform an allocation operation.</p>
<p id="p-0028" num="0027">Applicants have recognized and appreciated that processes often do not use memory efficiently, which can lead to memory pressure and an accompanying slowdown of execution of processes on a computing device. One of the ways in which executing processes do not use memory efficiently is by storing in memory content that the process is not certain will be used again or not certain will be used again soon, but that can be regenerated later if needed. For example, a process may store in memory a computer graphic that is not certain to be displayed again in an interface, such as an image of a web page that is shown in an inactive web browser tab. The process may not know if or when a user may request to view the web page of that tab. Additionally, the images of the web page can be regenerated for use, such as by retrieving the images from a storage drive or from the web. An efficient way to use memory would be to remove contents such as these from memory, such that valuable memory space is not wasted storing these contents and such that the memory manager does not waste time preserving those contents through paging techniques. Conventional processes, however, often do not manage memory in a way that is efficient for overall use of the memory, but instead manage memory in a way that is efficient only for that process. Thus, rather than removing contents from memory, many processes leave contents in memory such that the contents can be retrieved quickly if needed again. When processes leave content in memory in this way, though, a computing device can experience memory pressure. Memory pressure can occur under various conditions, including when a computing device's fast memory contains more than a threshold amount of content and the memory manager must &#x201c;page&#x201d; content into slow memory of the computing device to make room in the fast memory for other contents to be stored.</p>
<p id="p-0029" num="0028">Applicants have further recognized and appreciated that these inefficiencies in memory management arise because current techniques limit a process to either requesting that contents be preserved or requesting that contents be erased through a de-allocation operation or a memory reset operation. Memory may be more efficiently used, however, if a better balance could be struck between the needs of processes to store information and the need of memory managers to manage efficient use of memory. Applicants have recognized and appreciated that such a better balance could be achieved if processes were able to notify a memory manager that the memory manager is not required to preserve content the process is storing in memory space allocated to the process. More particularly, Applicants have recognized the benefits of enabling processes to &#x201c;offer&#x201d; to the memory manager that the memory manager could discard content of specified memory space at some point in the future if the memory manager is to address memory pressure. To address memory pressure, for example, the memory manager could discard content that is stored in fast memory. Discarding such content would free some of the fast memory to hold other content that is being used by processes. Discarding such content would also reduce the need to perform paging to place this other content in the fast memory, which could result in faster execution times for other operations.</p>
<p id="p-0030" num="0029">Applicants have further recognized that designers of processes may more readily offer memory in this way if the processes could later &#x201c;reclaim&#x201d; contents for use, if the contents have not yet been discarded by the memory manager, when processes subsequently need to use the contents. Such a technique would both enable processes to store contents long-term in memory space in case the contents could be used again, thereby realizing the advantages of caching more data, and enable the memory manager to address memory pressure by discarding some contents that are available for discard.</p>
<p id="p-0031" num="0030">Described below are examples of various techniques that may be used in embodiments for &#x201c;offering&#x201d; memory space to a memory manager so as to make the content of the memory space available for discard and for &#x201c;reclaiming&#x201d; contents of previously-offered memory space. Also described are various techniques for operating a memory manager to manage memory in response to such offer and reclaim operations and to address memory pressure by discarding content present in fast memory and that has been indicated as available for discard. It should be appreciated, however, that each of the techniques described below are merely illustrative of techniques that may be implemented in accordance with principles described herein, and that embodiments are not limited to implementing the techniques described below.</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram of elements of one computing device <b>100</b> with which some embodiments may operate. Examples of computing devices with which embodiments may operate include client computers, such as laptop or desktop personal computers, mobile phones, and personal digital assistants (PDAs), and server computers, such as single servers and systems of interconnected computers cooperating and sharing processing power. It should be appreciated, though, that embodiments are not limited to operating with any particular type or types of computing devices.</p>
<p id="p-0033" num="0032">In the example of <figref idref="DRAWINGS">FIG. 1</figref>, computing device <b>100</b> includes one or more executing processes <b>102</b>, each of which interacts with a memory manager <b>104</b> to use memory of the computing device <b>100</b>. The processes <b>102</b> may be any suitable processes, including processes associated with application software, system software, and/or any other type of software. In some cases, the processes <b>102</b> may include processes associated with graphics drivers or with graphics libraries for rendering text and/or images to a display screen. Each of the processes <b>102</b> is associated with processor-executable instructions and are executed by one or more processors of the computing device <b>100</b>. The processors may include central processing units (CPUs), graphics processing units (GPUs), and/or any other suitable structure for executing instructions.</p>
<p id="p-0034" num="0033">The memory manager <b>104</b> manages the allocation and use of fast memory <b>108</b> of the computing device <b>100</b> through any suitable memory management techniques. Such memory management techniques may include known techniques for allocating memory space of virtual memory and ensuring content stored in memory space is available in fast memory <b>108</b> and accessible to processes <b>102</b> when requested. The memory manager <b>104</b> may manage any suitable one or more fast memories <b>108</b> of the computing device <b>100</b>, including system memory <b>110</b> and video memory <b>112</b>. Memory manager <b>104</b> may also make use of one or more slow memories <b>114</b> of the computing device <b>100</b> as part of employing paging techniques with fast memory <b>108</b>. For example, some content of fast memory <b>108</b> may be written to the page file <b>114</b>A. Fast memories <b>110</b>, <b>112</b> and slow memory <b>114</b> may be implemented in any suitable manner, as embodiments are not limited in this respect. In some cases, the fast memory <b>108</b>, including fast memories <b>110</b>, <b>112</b>, may be one or more random access memories (RAMs) and the slow memory <b>114</b> may be a magnetic disk storage (e.g., a hard disk drive) or a solid-state drive (SSD). The fast memory <b>108</b> may store any suitable information. In embodiments where fast memory <b>108</b> includes multiple memories, each memory may store particular types information for which it has been assigned responsibility. For example, system memory <b>110</b> may store processed data like intermediate or final results of calculations and video memory <b>112</b> may store information regarding graphics to be displayed in an interface.</p>
<p id="p-0035" num="0034">To use memory of the computing device <b>100</b>, the processes <b>102</b> may carry out a series of interactions with the memory manager <b>104</b>, some of which interactions are illustrated in <figref idref="DRAWINGS">FIG. 1</figref>. Each of these interactions may be carried out in any suitable manner, including through one or more Application Programming Interface (API) calls. To store an amount of data in memory, a process <b>102</b> may first request that the amount of memory be allocated to the process <b>102</b> for storing the data. When a request to allocate memory is received by the memory manager <b>104</b>, the memory manager <b>104</b> may, if the requested amount of memory space is available in virtual memory, update the record <b>104</b>A of allocated memory to indicate that the requested amount of memory is allocated and make that amount of memory space in virtual memory available to the process <b>102</b> for use. The record <b>104</b>A may also be updated with virtual memory addresses for memory space granted to the process <b>102</b> in response to the request for the allocation. Updating the record <b>104</b>A with the amount of allocated space allows the memory manager to ensure that no more than the total available memory is allocated at any time, where the total memory is the combined size of the fast memory <b>108</b> and the page file <b>114</b>A. Updating the record <b>104</b>A with the memory addresses also allows the memory manager <b>104</b> to track what process is using what memory. In addition to allocation operations, the interactions between processes <b>102</b> and the memory manager <b>104</b> may include de-allocation operations. Once the process <b>102</b> is finished using previously-requested and allocated memory space, the process <b>102</b> may request that the memory manager <b>104</b> de-allocate the memory space. When the memory is de-allocated, the memory space is no longer available to the process <b>102</b> and is made available for allocation to other processes. Upon receiving a de-allocation request, the memory manager <b>104</b> may also update the record <b>104</b>A to indicate that the amount of memory space is available and that the memory space corresponding to that amount of memory is no longer allocated.</p>
<p id="p-0036" num="0035">In the time between requests for allocation and de-allocation, the process <b>102</b> may perform various other interactions with the memory manager <b>104</b> to interact with allocated memory space. Such interactions may include requests to access previously-allocated memory space for writing information to or reading information from the previously-allocated memory space. In accordance with techniques described herein, other interactions may include &#x201c;offer&#x201d; and &#x201c;reclaim&#x201d; operations. A process <b>102</b> and memory manager <b>104</b> may carry out techniques described herein, including illustrative techniques described below in connection with <figref idref="DRAWINGS">FIGS. 2-9</figref>, to perform the offer and reclaim operations.</p>
<p id="p-0037" num="0036">Another role of the memory manager <b>104</b> may be to address instances of memory pressure in the computing device <b>100</b>. &#x201c;Memory pressure&#x201d; can be associated with any suitable conditions of memory of the computing device <b>100</b>, as embodiments are not limited to operating with any particular type or cause of memory pressure. Examples of conditions associated with memory pressure are discussed in detail below in connection with <figref idref="DRAWINGS">FIG. 5</figref>. In some embodiments, memory manager <b>104</b> may detect an incident of memory pressure when the fast memory <b>108</b> of computing device <b>100</b> is in a state that more memory space has been allocated than can be stored at one time in fast memory <b>108</b> at one time. Using conventional procedures, when such conditions triggered memory pressure, the memory manager <b>104</b> would have only engaged in paging to move some content of fast memory <b>108</b> to the page file <b>114</b>A. In accordance with techniques described herein, however, the memory manager <b>104</b> may additionally or alternatively address instances of memory pressure by discarding content that one or more processes <b>102</b> have indicated, through an offer operation, is available for discard.</p>
<p id="p-0038" num="0037">The process <b>102</b> performs an offer interaction when the process <b>102</b> wishes to &#x201c;offer&#x201d; to the memory manager <b>104</b> that the manager <b>104</b> may discard the contents of memory space as part of addressing memory pressure. As discussed in detail below, when a process <b>102</b> has stored content in previously-allocated memory space, but the process <b>102</b> does not know whether or when the content may be used again, or the process <b>102</b> knows that the content will not be used again within a certain threshold period of time, the process <b>102</b> may signal the memory manager <b>104</b> that the content of the allocated memory space is available for discard. To offer memory, the process <b>102</b> may carry out an offer interaction, such as by making an offer API call, that identifies the memory space to be offered. The memory to be offered may be identified in any suitable manner, including through explicitly identifying virtual memory addresses for the memory space or by providing a pointer to or and identifier for the content and/or the memory space. The memory manager may maintain a record <b>104</b>B of memory space that has been offered, such as by adding memory addresses of offered memory space to the record <b>104</b>B. Once one or more processes <b>102</b> offer memory space, if the memory manager <b>104</b> detects that the computing device <b>100</b> is experiencing memory pressure, then as part of addressing the memory pressure the memory manager <b>104</b> may select content from the record <b>104</b>B of offered memory space and discard the content stored in that memory space. For example, the memory manager <b>104</b> may select content stored in fast memory <b>108</b> and discard that content to address memory pressure.</p>
<p id="p-0039" num="0038">In some embodiments, when the memory manager <b>104</b> receives an offer interaction or when the memory manager <b>104</b> discards content, the memory manager <b>104</b> may not change an allocation of memory of the computing device <b>100</b> or update the record <b>104</b>A of allocated memory. Instead, the memory manager <b>104</b> may maintain memory allocation despite the offer interaction and even despite discard. The memory manager may maintain the allocation because the &#x201c;offer&#x201d; interaction from the process <b>102</b> may not immediately result in the memory manager discarding the content; rather, the content may be preserved indefinitely. Maintaining the allocation of memory through the offer interaction ensures that the record <b>104</b>A matches the actual use of the memory. Maintaining the allocation of memory despite a discard of the contents ensures that the previously-allocated memory space remains available to the process <b>102</b> performing the offer. An offer implies to the memory manager <b>104</b> that the process <b>102</b> may not need content of specified memory now, but also implies that the content could be needed at some later time. To ensure the process <b>102</b> is able to store and use the content at that later time&#x2014;even if the content was discarded and must be regenerated before use by the process <b>102</b>&#x2014;the memory manager <b>104</b> continues to allocate the memory space to the process <b>102</b>. Though, embodiments are not limited to operating in this manner and, in some embodiments, a discard of contents may also result in a de-allocation of memory space.</p>
<p id="p-0040" num="0039">In addition to offer interactions, a process <b>102</b> may also interact with the memory manager <b>104</b> to carry out a reclaim operation. At any point after the process <b>102</b> has indicated to the memory manager <b>104</b> that content of specified memory space is available for discard, the process <b>102</b> may need to use the content of the memory space. Because the content was made available for discard, the process <b>102</b> should not simply begin accessing the memory space in which the content was stored, as the content may have been discarded. Instead, the process <b>102</b> carries out a reclaim operation to indicate to the memory manager <b>104</b> that the process <b>102</b> intends to reuse the content, to make the content of the specified memory space no longer available for discard, and to request that the memory manager <b>104</b> inform the process <b>102</b> of whether the content is still available. If the content is still available, the memory manager <b>104</b> may ensure that the content is available in fast memory <b>108</b> (rather than in the page file <b>114</b>A) and inform the process <b>102</b> that the content is available for use. When the content was discarded by the memory manager <b>104</b>, the memory manager <b>104</b> may instead respond to the process <b>102</b> that the content is no longer available and make available to the process <b>102</b> empty memory space in which to store the content once the process <b>102</b> regenerates the content.</p>
<p id="p-0041" num="0040">In the discussion of the offer operation above, the memory manager was described as updating a record <b>104</b>A to indicate what memory space has been made available for discard through such an operation. The memory manager may also update such records upon a reclaim operation. Regardless of whether the content has been discarded, when a reclaim operation is carried out for specified memory space, record <b>104</b>A may be updated to reflect that the specified memory space is no longer available for discard. This can ensure that, if the content was not discarded, the content will not be discarded following the reclaim, and ensure that, if the content was discarded, regenerated content will not be discarded.</p>
<p id="p-0042" num="0041">As mentioned above, examples of ways in which some processes and memory managers may implement &#x201c;offer&#x201d; and &#x201c;reclaim&#x201d; operations are discussed in detail below in connection with <figref idref="DRAWINGS">FIGS. 2-9</figref>.</p>
<p id="p-0043" num="0042">It should be appreciated that embodiments that operate with computing devices according to the example of <figref idref="DRAWINGS">FIG. 1</figref> are not limited to implementing the device <b>100</b> or any elements thereof in any particular manner. For example, the memory manager <b>104</b> may be implemented in any suitable way, including as a stand-alone memory manager, as a memory manager integrated with an operating system of the computing device <b>100</b>, or as a memory manager integrated with graphics software and/or hardware of the computing device <b>100</b>, like a memory manager integrated with a graphics interface of the computing device <b>100</b>. Further, while system memory <b>110</b> and video memory <b>112</b> are illustrated separately in <figref idref="DRAWINGS">FIG. 1</figref> and are discussed separately in this example, it should be appreciated that in some cases the memories <b>110</b>, <b>112</b> may be embodied together. For example, in some embodiments the system memory <b>110</b> and video memory <b>112</b> may be implemented together as parts of a single integrated memory. Alternatively, some embodiments may not include or may not operate with either the system memory <b>110</b> or video memory <b>112</b>, or may operate with additional or alternative types of memory, as embodiments are not limited to operating with any types of memory.</p>
<p id="p-0044" num="0043">In addition, while the memory manager <b>104</b> was discussed as handling each of the system memory <b>110</b> and video memory <b>112</b>, it should be appreciated that memory manager <b>104</b> may be implemented as a single manager or as multiple different managers having divided responsibility. For example, a first memory manager may be implemented for the system memory <b>110</b> and a second memory manager may be implemented for the video memory <b>112</b>. Each of the memory managers may implement techniques described herein, such as by handling allocation, offer, reclaim, and de-allocation operations for the respective memories. Alternatively, where a single memory manager is implemented, the single memory manager may manage memory separately, such as by maintaining separate records of allocation and offers for the memory <b>110</b> and the memory <b>112</b> and/or by maintaining separate page files for the memory <b>110</b> and memory <b>112</b>.</p>
<p id="p-0045" num="0044">In the example of <figref idref="DRAWINGS">FIG. 2</figref> and in other examples below, techniques are described relative to &#x201c;memory&#x201d; irrespective of whether the memory is system memory, video memory, or any other memory. It should be appreciated that, unless indicated otherwise, techniques described herein may be used with any suitable type of memory, including system memory and video memory. Further, in the examples below, unless indicated otherwise, references to operations performed on &#x201c;memory space&#x201d; refers to space in virtual memory. For example, an allocation of memory space is an allocation of virtual memory and an offer of memory space is an offer to discard content of virtual memory. Such virtual memory may be virtual memory associated with system memory and/or with video memory, as appropriate in each example.</p>
<p id="p-0046" num="0045">As mentioned above, embodiments operating according to techniques described herein may operate in any suitable manner to perform offer and reclaim operations. <figref idref="DRAWINGS">FIG. 2</figref> illustrates one exemplary technique by which a process may interact with a memory manager to offer and reclaim memory.</p>
<p id="p-0047" num="0046">The process <b>200</b> of <figref idref="DRAWINGS">FIG. 2</figref> may be carried out by an executing process on a computing device. Prior to the start of process <b>200</b>, the executing process may carry out any sequence of operations to carry out the functionality of the executing process. Through the course of these operations, when the executing process encounters a need to store content in memory, the process <b>200</b> begins. The content to be stored in memory may be any suitable information, including computer code, results of computations, graphics or images for display, or other types of information, as embodiments are not limited to operating with any particular type of content. The process <b>200</b> begins in block <b>202</b>, in which the executing process requests, before the content is generated, that an amount of memory space necessary to store the content be allocated to the executing process. The request and allocation may be carried out in any suitable way, including using known techniques. Once the memory is allocated and made available to the executing process, in block <b>204</b>, the content to be stored is generated and the allocated memory is used to store the generated content. The content may be generated in any suitable way, which may be dependent on the type of the content.</p>
<p id="p-0048" num="0047">In one example, memory space may have been allocated in block <b>202</b> for use as a temporary staging buffer as part of a graphics rendering process. Such a temporary staging buffer may be used when graphics data is to be conveyed from the executing process that is executing on a central processing unit (CPU) of a computing device to a graphics processing unit (GPU) of the computing device so that rendering operations can be carried out by the GPU. These temporary staging buffers may be allocated virtual memory space associated with video memory, so as to make content accessible in video memory directly accessible by the GPU. Once memory space is allocated in block <b>202</b>, the executing process can perform various operations in block <b>204</b> to generate the graphics data. These operations may include retrieving the graphics data from a source such as a server, disk, or another executing process, or performing one or more computations to yield the graphics data as a result. Once generated, the graphics data may be placed into the memory space that was allocated in the allocated memory space.</p>
<p id="p-0049" num="0048">At some time after the content is generated, the executing process may, in block <b>206</b>, temporarily finish using the content. In some cases, the executing process may finish using the content immediately after generating the content, such as when the content is generated in advance of any need for the content. In other cases, though, the executing process may finish using the content after the content has been used by the executing process in some way. To continue the example of the graphics data, once the graphics data has been retrieved by the GPU from the video memory and used to render an interface, or once the interface has been changed or closed by a user, the executing process may be finished using the graphics data. In block <b>206</b>, the executing process is &#x201c;temporarily&#x201d; finished using the content when the content either will or might be used again at some point in the future. To continue the example of the graphics data, if the interface including the graphic may be displayed again at some later time after the interface is closed, such as when the interface is opened again, the graphic may be needed at that later time to display the interface. Thus, while at block <b>206</b> the executing process may be finished using the graphic because the GPU has received the data to be rendered and because the interface has now been closed, because the interface could be displayed again and the content may therefore be used again, the executing process may be considered to be temporarily finished using the graphic.</p>
<p id="p-0050" num="0049">As discussed above, leaving in memory content that is not certain to be used is an inefficient use of memory and may cause memory pressure. However, such caching may offer advantages to an executing process, as when time is saved from retrieving content from memory rather than regenerating the content. In accordance with techniques described herein, a balance may be struck by storing the content in memory but indicating that the content may be discarded if memory pressure occurs.</p>
<p id="p-0051" num="0050">Accordingly, in response to being temporarily finished using the content, the executing process may carry out an offer operation. In block <b>208</b>, the executing process notifies the memory manager that the content of the allocated memory space is available for discard. To notify the memory manager, the executing process may provide an identifier for the content and/or the memory space to the memory manager in some way. In some embodiments, one or more API calls may be used to pass an identifier to the memory manager. For example, where the content to be made available for discard is graphics data, an API function of a graphics library may be used to pass to the memory manager an identifier for a graphics data structure, such as a texture data structure, that uses the memory space. As another example, an API call may be used to pass a pointer to or an address for a particular position in virtual memory space or a physical address for a location in fast memory. Any suitable identifier may be passed in any suitable manner.</p>
<p id="p-0052" num="0051">After the executing process has indicated to the memory manager in block <b>208</b> that the memory space includes content that is available for discard, the executing process may continue executing and carry out any suitable operations. In some cases, the executing process may never again need the content for which the offer operation was made and the memory space may be de-allocated either in response to an explicit request from the executing process or through a garbage collection process. In other cases, though, the executing process may again need to use the content that was made available for discard in block <b>208</b>. To use the graphics example given above, if a graphic is part of an interface and was offered in response to the interface being closed, when the interface is opened again that graphic may once again be needed to render the interface.</p>
<p id="p-0053" num="0052">The process <b>200</b> therefore continues in block <b>210</b>, in which the executing process subsequently needs to use the contents of the offered memory space, and before using the contents again, performs a reclaim operation to indicate to the memory manager that the executing process intends to use previously-offered contents. A reclaim operation should be carried out for at least two reasons. First, because the content was made available for discard through the offer operation, the executing process should not merely access the memory space again, as the content may have been discarded. If the executing process were to access the memory space and use what is stored there, and the content had been discarded, the executing process may receive null data or junk data instead, which could corrupt the executing process. Performing a reclaim operation permits the executing process to interact with the memory manager and determine whether the content was discarded. Second, because the executing process intends to use the content again, the executing process should ensure that the content is not going to be discarded while the executing process is reusing the content. If a reclaim operation were not performed, the memory manager might consider the memory space as still containing content available for discard, and the content might be discarded while the executing process was reusing the content. This could corrupt the executing process. For at least these reasons, a reclaim operation is carried out when the executing process subsequently needs to use content that has previously been made available for discard.</p>
<p id="p-0054" num="0053">The reclaim operation of block <b>210</b> may be performed by notifying that the executing process intends to reuse the contents of specified memory. To notify the memory manager, as with the offer operation, the executing process may identify the content and/or the memory space to the memory manager in some way. In some embodiments, one or more API calls may be used to pass to the memory manager an identifier. For example, where the content to be reused is graphics data, an API function of a graphics library may be used to pass to the memory manager an identifier for a graphics data structure, such as a texture data structure, that uses the memory space. As another example, an API call may be used to pass a pointer to or an address for a particular position in virtual memory, or in system memory or video memory, to a memory manager. Any suitable identifier may be passed in any suitable manner.</p>
<p id="p-0055" num="0054">In response to the reclaim operation, the executing process may receive from the memory manager an indication of whether the content of the memory space is still available or has been discarded. In block <b>212</b>, a response from the memory manager is evaluated to determine whether the response indicates the content is still available. If so, then in block <b>214</b> the memory space is accessed and the content of the memory space is used, after which the process <b>200</b> ends. If, however, the response from the memory manager indicates that the content was discarded and is not still available, then in block <b>216</b> the content that was stored in the specified memory is regenerated and used. Regenerating the content may include any suitable actions, including performing again the actions of block <b>204</b> that were carried out to originally generate the content and storing the content in the memory space. After the content is regenerated, stored, and used in block <b>216</b>, the process <b>200</b> ends.</p>
<p id="p-0056" num="0055">Following the end of the process <b>200</b>, the executing process may take any suitable actions regarding the memory space. In some cases, the executing process may be finished using the content and may request that the memory space be de-allocated. In other cases, though, the executing process may once again be only temporarily finished using the content and may again perform an offer operation to make the content available for discard.</p>
<p id="p-0057" num="0056">The example process <b>200</b> of <figref idref="DRAWINGS">FIG. 2</figref> was described above in general terms, without being limited to any particular executing process, type of content, or type of memory. As mentioned above, the process <b>200</b> or any other process implementing techniques described herein may be implemented with any suitable process, content, or memory, as embodiments are not limited in this respect. However, further examples of processes, content, and memory that may be used in some embodiments may illustrate ways in which some techniques described herein, and the process <b>200</b> of <figref idref="DRAWINGS">FIG. 2</figref>, may be used.</p>
<p id="p-0058" num="0057">Some computing devices include graphics processing units (GPUs) for performing graphics-related operations and include video memory for storing information processed by the GPU. Such computing devices may be operated more efficiently, and be able to resolve memory pressure more readily, if techniques described herein were used in the management of the video memory.</p>
<p id="p-0059" num="0058">For example, processes that are executed on a CPU may include various operations to display content in a graphical user interface (GUI) and may engage the GPU to perform those operations. To engage the GPU, the process may request that the GPU perform particular rendering operations like drawing geometric shapes, displaying an object with a certain color, displaying a transparency effects, or rendering text to the interface. Each of these operations may include storing content in virtual memory that is associated with fast video memory. Using techniques described herein, the use of the video memory may be made more efficient. Many computing devices have very limited amounts of video memory, at least as compared to the amount of system memory that may be available. As a result, memory pressure in the video memory may be more common. Further, memory pressure may be more problematic when experienced in video memory. Because graphics operations may involve rendering data to a screen for interaction with a user, any delays in processing of graphics operations may be more likely to be noticed by users. Lastly, because of the time lags associated with allocation and de-allocation operations, and because of the many different temporary storage buffers that are used during rendering operations, processes may store more content in virtual memory long-term, and the video memory associated with that virtual memory can tend to become full of content quickly. Applying &#x201c;offer&#x201d; and &#x201c;reclaim&#x201d; techniques described herein may have two advantages to graphics processing applications. First, by permitting processes to indicate which content can be discarded, a video memory manager may be better able to address memory pressure that arises in video memory by discarding some content that is stored in the video memory, which can result in faster execution of operations for the graphics processing application. Second, any designers/programmers of processes who attempt to use memory efficiently may be more willing to maintain content in allocated memory space when knowing that the content will be discarded if memory pressure is encountered. As a result, these designers may design process to maintain more content in memory. Where memory pressure is not encountered, the increased caching by these processes may result in an increase in efficiency for the processes, as the processes will not waste time regenerating content that could have been stored in a cache, while not adversely impacting use of the fast video memory as content can be discarded if memory pressure arises.</p>
<p id="p-0060" num="0059">More specific uses or benefits may be seen in particular graphics scenarios. For example, a graphics library may automatically offer memory storing unused graphics data upon determining that the data is unlikely to be used again. The Direct3D&#xae; graphics library available from the Microsoft Corporation of Redmond, Wash., for example, could automatically offer memory space associated with unused render targets. A render target is a collection of data stored in memory that describes a frame to be drawn to a display screen. Render targets may be created for various parts of a 3D display such that the frames are available in advance of when they are needed and do not need to be generated dynamically, which could slow down execution of the process. However, some of the render targets may not be used following a chance in or closing of the 3D display. When such unused graphics data is left in memory space associated with video memory, a graphics library may automatically signal to a memory manager that the unused data is available for discard, so as to possibly increase the efficiency of memory usage.</p>
<p id="p-0061" num="0060">Graphics libraries may also use these memory management techniques in managing temporary scratch buffers that are created in virtual memory associated with video memory as part of rendering shapes and text for display. Graphics libraries such as the Direct2D&#x2122; library available from the Microsoft Corporation may use many of these buffers as part of rendering graphics and may reuse the content and/or the memory space in subsequent render operations. Similarly, the DirectImage&#x2122; library available from the Microsoft Corporation may use temporary surfaces in virtual memory associated with video memory to store intermediate results of imaging effects being sequentially applied to an image as a result of image editing. Because the content may be reused, such as when some effects are removed and the previously-intermediate results are to be displayed, processes tend to maintain these temporary buffers and the intermediate results in memory. When multiple applications each use such buffers, memory pressure can result in the fast video memory. Using techniques described herein, these scratch buffers can be offered once they are done being used, which can maintain the allocation of memory space to the process while still permitting the memory manager to discard content stored in the fast video memory to more effectively manage the video memory.</p>
<p id="p-0062" num="0061">Graphics drivers may also benefit from techniques described herein. Graphics drivers also create temporary buffers and use them as part of providing data to a GPU for processing. When processes begin rendering an interface, the first rendering operations are often large and complex as the interface is established. As a result, graphics drivers often create large buffers (e.g., several megabytes) in virtual memory associated with video memory when a process begins rendering an interface, so as to speed up this rendering process. The graphics drivers often leave these larger buffers in memory for a long while, as the graphics driver cannot be certain of when the application will again render a large amount of data (e.g., in response to a substantial change in interface). Such large allocations may cause memory pressure in the fast video memory, though. Using techniques described herein, the allocations to the drivers can be maintained while the content can be discarded when the memory manager seeks to address memory pressure.</p>
<p id="p-0063" num="0062">A process may use offer and reclaim operations as described herein when the process has been designed to do so. To be designed to use these operations, a designer or programmer of the process must insert computer code into the process that invokes these operations and causes the process to interact with a memory manager so as to carry out these operations. The decision to invoke these operations may therefore be made at design time, while the computer code for the process is being written. <figref idref="DRAWINGS">FIG. 3</figref> illustrates design constraints that may be used by a designer/programmer in deciding whether to invoke an offer operation or whether to invoke alternative memory management operations with respect to particular memory space having particular contents.</p>
<p id="p-0064" num="0063">The process <b>300</b> begins in block <b>302</b>, in which the designer/programmer identifies content that the process being designed will generate and use at a first time and needs to determine what the process should do with the content after the first time. The designer/processor may choose between several options: doing nothing with the content and leaving the content in memory; requesting that the memory space be de-allocated, in which case the contents are removed and the space is no longer available to the process; requesting that the memory space be reset, in which case the contents are removed and the space is preserved for later use by the process; or offering the memory space, in which case the content might be removed but the space is preserved for later use.</p>
<p id="p-0065" num="0064">The first design constraint that may be used in determining whether to use an &#x201c;offer&#x201d; operation is illustrated in block <b>304</b>: whether the process might use the content after the first time. If the content will not be used after the first time, there is little reason for the process to request that the memory manager preserve that content in any way. Accordingly, in block <b>304</b> the designer/programmer determines whether the process might use the content after the first time. If the content will not be subsequently used, then in block <b>306</b> the designer/programmer can design the process not to request that the content be preserved by performing either a de-allocation or reset operation, dependent on whether the process will need the memory space again. Once the process is designed in block <b>306</b> to de-allocate or reset the memory space, the process <b>300</b> ends.</p>
<p id="p-0066" num="0065">If, however, the designer/programmer determines in block <b>304</b> that the process might use the content after the first time, then a second design constraint is evaluated in block <b>308</b>: whether the content can be regenerated. If the content is unique, cannot be regenerated, or would be prohibitively difficult to regenerate such as by taking a long time or requiring a large number of resources, then the content should not be discarded or made available for discard. Accordingly, if the designer/programmer determines in block <b>308</b> that the content cannot be regenerated, then in block <b>310</b> the designer/programmer can design the process to take no action and leave the content in memory for possible later use.</p>
<p id="p-0067" num="0066">On the other hand, if the content can be regenerated, then leaving the content in memory may be taxing on the fast memory and may result in memory pressure, which might slow down all operations of a computing device. Thus, if it is determined in block <b>308</b> that the content can be regenerated, then a third design constraint can be evaluated.</p>
<p id="p-0068" num="0067">Even if content can be regenerated, it may not be efficient to discard and regenerate the content if the content is certain to be used quickly after the discard operation. A third design constraint, therefore, is whether the content will be used again soon, within a threshold amount of time in the future. The threshold may be any suitable threshold amount of time, as embodiments are not limited in this respect. If the designer/programmer determines in block <b>312</b> that the content is certain to be used again within the threshold time, then in block <b>310</b> the designer/programmer can design the process to take no action and leave the content in memory for the later use. Once the process is designed in block <b>310</b>, as a result of the determination in block <b>308</b> or in block <b>312</b>, the process <b>300</b> ends.</p>
<p id="p-0069" num="0068">If, however, in block <b>312</b> the designer/programmer is not certain of whether the process will use the content again with the threshold period of time, such as when use of the content depends on actions of a user or an entity other than the process, then in block <b>314</b> the designer/programmer may design the process to offer contents for discard to the memory manager. Once the process is designed in block <b>310</b>, the process <b>300</b> ends.</p>
<p id="p-0070" num="0069">Thus, using the design constraints of the example of <figref idref="DRAWINGS">FIG. 3</figref>, an offer operation may be used when the content can be regenerated and the content might be used at some future time, though it is uncertain when the content will be used again or any such use would be beyond a threshold amount of time in the future. It should be appreciated, however, that embodiments are not limited to employing these design constraints and that a designer/programmer may decide to invoke an offer or reclaim operation based on any suitable factors.</p>
<p id="p-0071" num="0070">It should also be appreciated that, while the example of <figref idref="DRAWINGS">FIG. 3</figref> relates to determining at design time whether to use an offer operation or a de-allocation operation, embodiments are not so limited. In some embodiments, a process can be designed to invoke an offer at runtime in response to satisfaction of one or more conditions or involve selecting between an offer and a reset or de-allocate based on satisfaction of one or more conditions. Such conditions may be results of determinations by the process during runtime. For example, the process may review content, a state of the process, interactions with a user, or any other suitable factors and determine whether content might be used again in the future, and when. As in the example of <figref idref="DRAWINGS">FIG. 3</figref>, if the content will not be used, then the process may decide to de-allocate memory storing the content, while if the content might be used, then the process may offer the memory space to the memory manager.</p>
<p id="p-0072" num="0071">The examples above focused on operations of an executing process in interacting with a memory manager to perform offer and reclaim operations during execution of the process. A memory manager may react in any suitable manner to receipt of offer and reclaim operations. <figref idref="DRAWINGS">FIGS. 4-9</figref> illustrate examples of processes that may be carried out by a memory manager to carry out actions requested by offer and reclaim operations and to interact with executing processes.</p>
<p id="p-0073" num="0072">The process <b>400</b> of <figref idref="DRAWINGS">FIG. 4</figref> may be carried out by a memory manager throughout interactions with an executing process. The executing process can carry out any suitable process for interacting with the memory manager, including the process <b>200</b> of <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0074" num="0073">Prior to the start of the process <b>400</b>, the memory manager may be operating to manage memory and interact with other executing processes to allocate and use memory of a computing device. The process <b>400</b> begins in block <b>402</b>, in which the memory manager allocates memory space to an executing process. The memory space may be allocated by the memory manager in response to a request from the executing process that a specified amount of memory be allocated to the executing process. If the executing process is carrying out the process <b>200</b> of <figref idref="DRAWINGS">FIG. 2</figref>, the request for allocation received by the memory manager in block <b>402</b> may be a request carried out according to block <b>202</b> of <figref idref="DRAWINGS">FIG. 2</figref>. Known allocation techniques may be used in block <b>402</b>. For example, to allocate memory, the memory manager may determine whether the requested amount of memory space is available for allocation. The memory manager may review records regarding memory allocation, including amounts of remaining memory, and, if sufficient memory space is available, grant the allocation and make available the requested amount of memory space.</p>
<p id="p-0075" num="0074">The memory manager can subsequently interact with the executing process as the executing process stores content in the allocated memory space, retrieves the content from the memory space, or performs any other suitable operations regarding the memory space. At some time following the allocation, though, the memory manager receives from the executing process a notification that the content of the memory allocated in block <b>404</b> is available for discard. The notification from the executing process can identify the content and/or the memory space in some way, such as using any of the exemplary ways of identifying content or memory space discussed above in connection with <figref idref="DRAWINGS">FIG. 2</figref>. For example, the notification may include an identifier for the content or may include an address of the memory space.</p>
<p id="p-0076" num="0075">Upon receiving the notification that content can be discarded, the memory manager may not immediately discard the content, unless the computing device is already experiencing memory pressure and the memory manager selects that content to discard. Rather, the memory manager may note that the content can be discarded if the memory manager detects that the computing device is experiencing memory pressure, as discussed below. In block <b>406</b>, therefore, in response to the notification received in block <b>404</b>, the memory manager may update records maintained by the memory manager regarding the memory space. In particular, the memory manager may update a record of memory space for which the content has been made available for discard. Maintaining and updating such records allows the memory manager to track what content can be discarded to resolve memory pressure. The record may be maintained in any suitable manner and contain any suitable information, as embodiments are not limited in this respect. In some cases, the record may include a listing of addresses for memory space for which the content can be discarded. Other information may be stored, including a time that the content was indicated to be available for discard or other suitable information that may be used in selecting from the record content that is to be discarded to address memory pressure. The record may be stored in any suitable manner, including as a record separate from any of the memory space, such as a listing of memory space for which the content has been made available for discard, and as settings associated with each of the memory spaces, such as being stored with other properties for memory space.</p>
<p id="p-0077" num="0076">A memory manager of a computing device may be responsible for managing a state of a fast memory to ensure that the fast memory is efficiently used and allocated and that the state of the fast memory does not interfere with the execution of processes on the computing devices. As part of this, a memory manager may be responsible for detecting instances of memory pressure. Exemplary ways of detecting memory pressure are discussed in detail below in connection with <figref idref="DRAWINGS">FIG. 5</figref>. In some embodiments, memory pressure can be experienced by a computing device where a fast memory of a computing device is in a state that causes additional time to be taken for carrying out routine operations of the computing device. For example, when the fast memory is in a state that requires paging content into and out of the fast memory, because more content is to be stored than can fit in the fast memory, memory pressure may be experienced.</p>
<p id="p-0078" num="0077">The memory manager may therefore periodically examine a state of the fast memory to determine whether the computing device is experiencing memory pressure. In block <b>408</b>, the memory manager may take any suitable actions to determine whether memory pressure exists in the computing device at that time. Any suitable detections or determinations may be made to determine whether memory pressure is being experienced, examples of which are described below in connection with <figref idref="DRAWINGS">FIG. 5</figref>. As one example, in some embodiments a determination may be made as to whether fast memory, including either or both of system memory and video memory, contains more than a threshold amount of content or is full, such that paging is necessary to place content into fast memory.</p>
<p id="p-0079" num="0078">It should be appreciated that while, for ease of illustration, the determination of block <b>408</b> is shown following receipt of an offer operation making content available for discard, a determination of whether a computing device is experiencing memory pressure may be made by the memory manager at any time. A determination of whether memory pressure exists is not limited to being made following an offer operation like the one of block <b>404</b>.</p>
<p id="p-0080" num="0079">If the memory manager determines in block <b>408</b> that the computing device is experiencing memory pressure, then in block <b>410</b> the memory manager may select and discard content that is available for discard. Examples of ways in which a memory manager may select content for discard are discussed below in connection with <figref idref="DRAWINGS">FIG. 6</figref>. In some embodiments, the memory manager may select content for discard based on a time at which the content was indicated to be available for discard, such that the oldest content is discarded first, though any suitable selection process may be carried out. In block <b>410</b>, when content is discarded, any suitable active or passive step may be taken to discard the content. In some cases, the content may be actively discarded, such as by actively deleting content or actively overwriting content in response to selecting the content for discard. In other cases, the content may be passively discarded, such as by ceasing to preserve the content, such that content selected for discard is not written to a page file or other storage when contents are being moved out of fast memory to make space for other content to be stored in the fast memory.</p>
<p id="p-0081" num="0080">When content is discarded, the memory manager may also update records regarding the memory to reflect the discard, such that the memory manager may be able to determine later whether content stored in specified memory space was discarded. The records may be maintained in any suitable manner. For example, the records may be maintained as a part of or separate from records regarding offered memory space. In some embodiments where the records are maintained together, information in a record of offered memory space regarding a specified memory space may be updated to reflect that content in that memory space has been discarded.</p>
<p id="p-0082" num="0081">Once the memory pressure has been addressed in block <b>410</b>, or if no memory pressure was detected in block <b>408</b>, the memory manager continues to execute and interact with other executing processes and manage memory. The process <b>400</b> continues in block <b>412</b> when the memory manager receives from the executing process, to which the memory space was allocated in block <b>402</b> and from which the notification was received in block <b>406</b>, a reclaim operation notifying the memory manager of an intent to reuse the content that was made available for discard in block <b>406</b>. In response to the notification of block <b>412</b>, in block <b>414</b> the memory manager may determine whether the content that is to be reclaimed by the executing process was discarded. Determining whether the content was discarded may be carried out in any suitable manner, including by reviewing the records regarding the memory that indicate whether content was discarded.</p>
<p id="p-0083" num="0082">If the memory manager determines in block <b>414</b> that the content was discarded, then in block <b>416</b> the memory manager makes available in fast memory empty memory space in an amount corresponding to the amount of the original allocation. The memory manager makes this empty memory space available so that the executing process can store the content in memory once the content is regenerated. Once the empty memory space is made available in fast memory, the memory manager responds to the executing process indicating that the content was discarded.</p>
<p id="p-0084" num="0083">If, however, the memory manager determines in block <b>414</b> that the content was not discarded, then the memory manager may make the content available in fast memory. Making the content available in fast memory may involve taking any suitable action, including retrieving the content from a page file and placing the content in fast memory if the content had been placed in the page file. Once the content is available, the memory manager may respond to the executing process with an indication that the content was not discarded and is available.</p>
<p id="p-0085" num="0084">After the memory manager responds to the executing process in either of block <b>416</b> or <b>418</b>, the process <b>400</b> continues back to block <b>404</b>. As discussed above, the memory manager may interact with one or more executing processes during accesses to memory spaces by the executing processes. An executing process may then in block <b>404</b> notify the memory manager that specified content is available for discard, which may in some cases be a second, third, etc. time the executing process has indicated that content in the memory space is available for discard.</p>
<p id="p-0086" num="0085">Eventually, at some later time not illustrated in <figref idref="DRAWINGS">FIG. 4</figref>, the memory space allocated in block <b>404</b> may be de-allocated as a result of either a specific instruction from the executing process or as part of a garbage collection process.</p>
<p id="p-0087" num="0086">As discussed above in connection with block <b>408</b> of <figref idref="DRAWINGS">FIG. 4</figref>, any suitable process may be carried out for detecting whether a computing device is experiencing memory pressure. Additionally, memory pressure may be associated with any suitable conditions on the computing device, as embodiments are not limited to operating with any particular type of memory pressure. Rather, embodiments may operate to discard content in response to any suitable condition on a computing device.</p>
<p id="p-0088" num="0087">The process <b>500</b> of <figref idref="DRAWINGS">FIG. 5</figref> is one exemplary technique for detecting memory pressure on a computing device. As illustrated in <figref idref="DRAWINGS">FIG. 5</figref>, five different conditions may be analyzed by a memory manager, each of which may lead to a determination that a computing device is undergoing memory pressure.</p>
<p id="p-0089" num="0088">The process <b>500</b> begins in block <b>502</b>, in which a memory manager of a computing device performs various operations to interact with executing processes to allocate memory and manage contents of memory. The memory manager may periodically or occasionally examine a state of memory of the computing device to determine whether the computing device is undergoing memory pressure. When the memory manager is to examine the state of the memory, the memory manager may perform the operations of blocks <b>504</b>-<b>518</b>.</p>
<p id="p-0090" num="0089">In block <b>504</b>, the memory manager may determine whether the fast memory contains more than a threshold amount of content. For example, the memory manager may determine whether the fast memory is full of content, which may occur when more virtual memory space has been allocated than the fast memory is capable of containing. For example, where fast memory has a capacity of two gigabytes, and three gigabytes of virtual memory has been allocated, then the fast memory may be full of contents. More virtual memory can be allocated than the fast memory can contain because paging techniques can be used to move contents into and out of the fast memory, such that contents to be accessed at some time are present in the fast memory and contents that will not be accessed are not present in the fast memory at that time. However, paging techniques require extra operations and time to write first content of the fast memory to a page file, retrieve second content from the page file, and replace the first content with the second content in the fast memory. These extra operations and time may slow down a computing device and processes executing on a computing device. Therefore, when the fast memory is detected to contain more than the threshold amount of content, the memory manager may detect memory pressure and conclude in block <b>514</b> that the computing device is experiencing memory pressure. As discussed above, when memory pressure is detected, content may be discarded as part of addressing the memory pressure. For example, content stored in the fast memory may be discarded. Where memory pressure results from the fast memory containing more than the threshold amount of content, discarding some content may relieve the memory manager of the need to write that content to a page file before writing other content to the fast memory, which may speed operations of the computing device.</p>
<p id="p-0091" num="0090">If, however, the memory manager determines in block <b>504</b> that the fast memory does not contain more than the threshold amount of content, then another condition may be checked in block <b>506</b>: whether the computing device is to undergo a power state transition. In some power state transitions, such as &#x201c;sleep&#x201d; or &#x201c;hibernate&#x201d; transitions, contents of fast memory may be written to slow memory (e.g., to a &#x201c;hiberfile&#x201d; stored in a storage drive) in a manner similar to paging so that the contents can be preserved throughout the power state transition. When contents are to be written to slow memory, the time necessary to write the contents may depend in part on the amount of contents to be written. When there is more content to be written, the writing may take more time. Accordingly, when the memory manager determines that the computing device is to undergo a power state transition, the memory manager may conclude in block <b>514</b> that the computing device is experiencing memory pressure. As above, memory pressure may be addressed by discarding some content, such as by discarding content stored in fast memory. In the case of a power state transition, discarding some contents may relieve the computing device of writing those contents to a slow memory during the power state transition and therefore expedite the power state transition.</p>
<p id="p-0092" num="0091">If the memory manager determines in block <b>506</b> that the computing device is not to undergo a power state transition, then the memory manager may determine next in block <b>508</b> whether an instruction was received to clear memory. Clearing of memory may be performed for a variety of reasons. For example, when a fast memory is to be re-synchronized to a system clock, contents of the fast memory may be cleared first to ensure that data is correctly read from and written to the fast memory following the change of the clock. Clearing of fast memory may result in contents of the fast memory being written to slow memory to preserve the contents through the clearing of memory. As in the examples of blocks <b>504</b> and <b>506</b> above, where there is more contents stored in the fast memory, writing the contents to slow memory may take more time and slow down operations of the computing device. The memory manager may therefore conclude in block <b>514</b> that the computing device is experiencing memory pressure when the memory manager detects that an instruction to clear fast memory has been received and, in response to the determination, discard content stored in the fast memory.</p>
<p id="p-0093" num="0092">The examples of blocks <b>504</b>-<b>508</b> included detecting whether general conditions of the computing device were causing memory pressure on the computing device. Specific content or specific instructions regarding content may also be detected by the memory manager as causing memory pressure on the computing device. For example, in block <b>510</b>, the memory manager may determine whether a threshold amount of time has passed since content, which was offered as available for discard, has been used by an executing process. If the threshold time has passed, then the memory manager may conclude that the content is likely not to be used and may be merely clogging the fast memory. The memory manager may therefore conclude in block <b>514</b> that the computing device is undergoing memory pressure and may, in response, discard contents to address the memory pressure. The contents that are discarded in response to the determination may be those contents that have not been used for the threshold period of time and may be clogging the fast memory.</p>
<p id="p-0094" num="0093">If, however, no contents have been untouched for the threshold amount of time, then in block <b>512</b> the memory manager may determine whether an instruction has been received to discard particular contents of specified memory space. Such an instruction may be received for any suitable reason, including for testing purposes. In some embodiments operating according to techniques described herein, memory that is allocated to a process and storing contents for a process may discard the contents without notification to the process without first determining whether the content was discarded. If a process attempts to use the contents, corruption may occur. Software testing can be carried out during design of a process to identify any instances of possible corruption of the process and eliminate that corruption. As part of testing a process, a testing facility may instruct the memory manager to discard particular contents that are stored in memory space allocated to a process and that the process has indicated is available for discard. The testing facility may then be able to determine how the process responds when the content has been discarded and whether any corruption results. Instructions to discard particular contents may be received for any suitable reason, though, and are not limited to testing purposes. If the memory manager determines in block <b>512</b> that an instruction to discard particular memory has been received, then the memory manager may conclude in block <b>516</b> that the computing device is experiencing memory pressure and, in response to the determination, discard content.</p>
<p id="p-0095" num="0094">If the memory manager did not conclude that any of the conditions of blocks <b>504</b>-<b>512</b> are present in the computing device, then the memory manager may conclude in block <b>514</b> that the computing device is not experiencing memory pressure. Once the memory manager reaches a conclusion in one of block <b>514</b> and <b>516</b>, the process <b>500</b> ends.</p>
<p id="p-0096" num="0095">For ease of illustration, the process <b>500</b> is shown in <figref idref="DRAWINGS">FIG. 5</figref> as successively reviewing the conditions to be evaluated. It should be appreciated, though, that embodiments that evaluate these conditions or any other conditions are not limited to reviewing conditions in any particular order, including the order shown in <figref idref="DRAWINGS">FIG. 5</figref>. Further, it should be appreciated that embodiments are not limited to successively reviewing any conditions. In some embodiments, rather than performing a process to review all possible conditions periodically or occasionally, the memory manager may be configured to review or detect particular conditions in response to particular events occurring on the computing device. For example, the memory manager and the computing device may be configured such that, when a power state transition begins, the memory manager responds to the event by addressing memory pressure. Similarly, the memory manager may be configured to respond to instructions to clear memory or discard particular contents by addressing memory pressure. In these embodiments, at least some conditions will be evaluated upon occurrence of events, rather than being evaluated periodically or occasionally.</p>
<p id="p-0097" num="0096">Regardless of how or under what conditions the memory manager detects the computing device to be experiencing memory pressure, the memory manager may respond to memory pressure by discarding content that has been made available for discard. In some cases, multiple regions of memory storing multiple contents may have been made available for discard by the processes to which the memory regions are allocated. To address memory pressure, a memory manager may discard all of the offered content or may instead select one or more memory regions and discard the content of the selected memory regions. Where memory is selected for discard, any suitable amount of memory may be discarded. In some embodiments, for example, fixed-size units of memory may be discarded together. The fixed-size units may be any suitable units, including a block size of a file system of the computing device, such as four kilobytes. In other embodiments, individual units of content, regardless of size, may be selected for discard until the memory manager determines that the memory pressure has been addressed or resolved.</p>
<p id="p-0098" num="0097">In embodiments where a memory manager selects content for discard, the memory manager may carry out any suitable process for selecting content for discard. In some embodiments, as in the example of <figref idref="DRAWINGS">FIG. 6</figref> below, a memory manager may select the content based on properties of content that has been made available for discard. Additionally or alternatively, a memory manager may select content when specific content caused the detection of memory pressure, such as the examples of blocks <b>510</b> and <b>512</b> of <figref idref="DRAWINGS">FIG. 5</figref>.</p>
<p id="p-0099" num="0098"><figref idref="DRAWINGS">FIG. 6</figref> illustrates one exemplary technique for selecting, from content available for discard, content that is to be discarded. In the example of <figref idref="DRAWINGS">FIG. 6</figref>, one of the parameters that may be weighed is a priority level for the content, as indicated by an executing process that generated the content. When the executing process notifies the memory manager that the content is available for discard, such as through an offer operation, the executing process may additionally notify the memory manager of a priority level of the content. A priority level may indicate a relative worth of the content to the executing process. The relative worth may be based on an expectation of the content's future use and/or on an expected difficulty of regenerating the content. More particularly, in some embodiments a priority level may be selected by an executing process based on a likelihood that the content will be used again, a time the content is expected to be used again, and/or a time necessary for the executing process to regenerate the content. Any suitable priority levels may be used, as embodiments are not limited in this respect. In some embodiments, priority levels may be selected from a scale of low, medium, and high. Where priority levels are used, the priority levels may be passed from the executing process to the memory manager in any suitable manner. For example, when the executing process notifies the memory manager that content is available for discard, in addition to other potentially-passed parameters such as identifiers for content or addresses for memory, the executing process may also pass a priority level for the content.</p>
<p id="p-0100" num="0099">As set forth in the example of <figref idref="DRAWINGS">FIG. 6</figref> below, in embodiments where priority levels are used, the priority levels may be used in determining a value of each content made available for discard. The determined values may be used in selecting content to be discarded.</p>
<p id="p-0101" num="0100">Prior to the start of the process <b>600</b>, the memory manager may have reviewed the state of memory in any suitable manner and determined, from that review, that the computing device is experiencing memory pressure. As discussed above, when memory pressure is detected, the memory manager may select from the content made available for discard specific memory to be discarded. The process <b>600</b> begins in block <b>602</b> with a review of the contents that have been indicated as available for discard. The review may be carried out in any suitable manner, such as by reviewing the content and/or reviewing properties regarding the content. In some embodiments, all of the content made available for discard may be reviewed in block <b>602</b>, while in other embodiments only a portion of the content may available for discard may be reviewed. Where only a portion is reviewed, the portion may be selected in any suitable manner. In some embodiments that review only a portion of the contents made available for discard, the portion may be those contents that are presently in fast memory of the computing device and that may therefore aid in addressing memory pressure when contents are discarded. This may be done because, in some cases, content that had been previously made available for discard might have been placed into a page file as a result of paging techniques. Because discarding content that is already present in a page file may not have as great an impact in addressing memory pressure as discarding content that is present in fast memory, in these embodiments the contents in the page file may not be reviewed. Though, in other embodiments, content stored in a page file could be reviewed and selected for discard where other content in fast memory is available for discard.</p>
<p id="p-0102" num="0101">In block <b>604</b>, once contents are reviewed in block <b>602</b>, the memory manager may determine a value of each content based on the properties of the contents. The value may be determined in any suitable manner, as embodiments are not limited in this respect. In some cases, a weighting function may be performed on any suitable properties of the content, including the properties described above, to yield a value for the content. As part of determining the value, properties of each of the content may be determined so that these properties can be considered. For example, in block <b>606</b>, a time that the content was indicated as available for discard may be determined. The time may be used to determine an age of the content, as the age may indicate how likely the content is to be used again. If content has been left unused in memory for a long while after being made available for discard, the memory manager can conclude that the content is unlikely to be used and thus may have a low value. A priority level can also be determined by the memory manager in block <b>608</b>, such as by reviewing a priority level communicated from an executing process. Reviewing the priority value in this way allows some input from the executing process to be considered in determining the value of the content. Lastly, whether the content is stored in system memory or in some other memory (e.g., video memory) may be considered. In some embodiments, content that is stored in system memory may be more quickly deleted than content in other memories, as the system memory may be used by more processes and may be in higher demand. For example, in embodiments where a video memory manager is determining which graphics content to discard from among available graphics content, the video memory manager may consider whether graphics data is stored in system memory. In some embodiments, when memory space is allocated for storing graphics data, the memory space may be allocated in either a &#x201c;memory-space segment,&#x201d; in which case the content may be stored in video memory, or in an &#x201c;aperture-space segment,&#x201d; in which case the content may be stored in system memory. In some such embodiments, the video memory manager may discard any contents stored in aperture-space segments, and therefore in system memory, upon expiration of a time period or otherwise before other graphics data stored in video memory.</p>
<p id="p-0103" num="0102">Based on determinations of blocks <b>606</b>-<b>610</b>, as well as any other suitable determinations regarding the contents made available for discard, in block <b>604</b> a value is determined for each of the contents made available for discard. Subsequently, in block <b>612</b>, the lowest-value content is discarded. As mentioned above, in some cases multiple units of content may be discarded together, so as to total to a particular size (e.g., a block size of a file system) or through repeating a discard until the memory manager determines that the memory pressure has been addressed or resolved. Accordingly, discarding of the lowest-value content in block <b>612</b> may include discarding of a single unit of content or may include successively discarding lowest-value content until some condition is met.</p>
<p id="p-0104" num="0103">Once content has been discarded in block <b>612</b>, the process <b>600</b> ends.</p>
<p id="p-0105" num="0104">As mentioned above, discarding of content may be carried out in any suitable manner, including through an active discard or through a passive discard. In an active discard, the content may be actively deleted or actively overwritten directly in response to the determination that the content should be discarded. A passive discard may not involve such a direct response to a determination to discard content. <figref idref="DRAWINGS">FIG. 7</figref> illustrates one technique which may be used for discarding content that has been selected for discard.</p>
<p id="p-0106" num="0105">Prior to the start of the process <b>700</b>, a memory manager may have detected that a computing device is experiencing memory pressure and may have reviewed contents available for discard. The process <b>700</b> begins in block <b>702</b>, in which content to be discarded is identified. Once that content is identified, then in block <b>704</b> the memory manager stops preserving those contents. By ceasing to preserve the contents, the memory manager may not be directly deleting or overwriting the contents, but the memory manager may instead be allowing such deletions or overwrites to occur. For example, when a memory manager normally engages in paging techniques to bring contents from a page file to fast memory, the memory manager typically copies some content that was in the fast memory to the page file. Where the memory manager has stopped preserving content in fast memory, however, when the memory manager brings content from the page file to the fast memory, the memory manager may not first copy the contents to be discarded into the page file. Thus, the memory manager allows the selected content to be overwritten in the fast memory during the paging process.</p>
<p id="p-0107" num="0106">In block <b>706</b>, once the memory manager has stopped preserving the content identified in block <b>702</b>, the memory manager may also maintain an allocation of memory space to an executing process associated with the discarded content. The memory manager may maintain the allocation in block <b>706</b> by not adjusting an allocation or refraining from adjusting an allocation. As mentioned above, an allocation of memory space to the executing process may not be adjusted because the executing process did not request that the memory space be de-allocated, but has only indicated that the contents of the memory may be discarded. When the contents are discarded, the executing process may respond by regenerating the contents when the contents are subsequently needed by the executing process. When contents are regenerated, the executing process will need memory space in which to store the contents. The memory manager may therefore continue to make the memory space available to the executing process, even following discard of the contents, as the memory space may be subsequently used by the executing process to store regenerated content.</p>
<p id="p-0108" num="0107">In block <b>708</b>, the memory manager may respond to the discard by recording in records of the memory manager that the content was discarded. As discussed above in connection with <figref idref="DRAWINGS">FIG. 4</figref>, any suitable records may be updated in any suitable manner to reflect the discard, as embodiments are not limited in this respect.</p>
<p id="p-0109" num="0108">Once the content is discarded in block <b>708</b>, the process <b>700</b> ends.</p>
<p id="p-0110" num="0109">The exemplary techniques described above may be used by an executing process to indicate to a memory manager that content is available for discard (an &#x201c;offer&#x201d; operation) and to subsequently indicate to a memory manager that the executing process intends to reuse the content and that the content, if not yet discarded, is no longer available for discard (a &#x201c;reclaim&#x201d; operation). As mentioned above, a reclaim operation should be performed after an offer operation and before any subsequent access to the memory space to ensure that the contents are still available and have not been discarded. A use of the contents when the contents have been discarded has the potential to cause corruption of an executing process, as the executing process may receive null or junk data in response to the use of the memory space in which the contents were stored.</p>
<p id="p-0111" num="0110">In some embodiments, a memory manager may be configured to attempt to prevent such corruption by detecting when an executing process is making an access to memory space that was made available for discard without first performing a reclaim operation. Process <b>800</b> of <figref idref="DRAWINGS">FIG. 8</figref> illustrates one such technique that may be used by memory managers.</p>
<p id="p-0112" num="0111">The process <b>800</b> begins in block <b>802</b>, in which the memory manager detects that an executing process is attempting to use memory space that was previously indicated as available for discard and that no reclaim notification has been received from the executing process. The detection may be made in any suitable manner. For example, the memory manager may receive from the executing process an API call to use the memory. In response to the detection of block <b>802</b>, the memory manager may carry out various operations prior to the executing process being permitted to access the memory. In block <b>804</b>, the memory manager discards the contents of the memory that is to be accessed, if the contents have not already been discarded. In block <b>806</b>, the memory manager makes empty memory space available in fast memory for use by the executing process in place of the content that was discarded, as the memory manager would have done had the content been discarded and a reclaim operation had been performed by the executing process. The memory manager may then in block <b>808</b> update records of the memory manager regarding memory space that contains content available for discard to indicate that the memory space that is to be accessed by the executing process is no longer available for discard. Once the empty memory space is available and the records have been updated, the process <b>800</b> ends.</p>
<p id="p-0113" num="0112">Techniques described herein can be used in any exemplary environment, with any suitable executing processes, content, and memory managers. In some embodiments, the techniques may be used as part of a system for rendering graphics to a display screen. <figref idref="DRAWINGS">FIG. 9</figref> illustrates elements of one such system for rendering graphics to a display screen, as well as exemplary API calls that may be used to exchange messages between the elements and an exemplary communication flow for processing an offer operation carried out by an executing process.</p>
<p id="p-0114" num="0113">In the example of <figref idref="DRAWINGS">FIG. 9</figref>, an executing process that interacts with a memory manager to request that memory be allocated and to interact with that memory may be a software application that renders graphics to a display screen as part of a user interface. The memory manager with which the software application interacts may be a video memory manager that manages a video memory of a computing device. The video memory manager may be implemented in any suitable way, including as the DirectX&#xae; graphics kernel (DxgKrnl) of the DirectX&#xae; graphics system available from the Microsoft Corporation. In the DirectX&#xae; system, the software application may in some cases not communicate directly with the DxgKrnl, but may instead communicate via an interface that takes responsibility for carrying out operations on behalf of the software application. This interface is the DirectX&#xae; Graphics Interface (DXGI). As illustrated in <figref idref="DRAWINGS">FIG. 9</figref>, to perform an offer operation, the software application may make an API function call to the DXGI requesting that a particular graphics resource be offered as content available for discard. The API function call made by the software application may be the IDXGIDevice2::Offer function call. As part of this function, the software application may provide to the DXGI an identifier for a graphics resource, such as a data structure storing graphics data, that is managed by the DirectX&#xae; system.</p>
<p id="p-0115" num="0114">When the DXGI receives the function call from the software application, the DXGI may in turn issue a function call to identify memory space that is associated with the graphics resource identified by the software application. As shown in <figref idref="DRAWINGS">FIG. 9</figref>, to determine the associated memory space, the DXGI may communicate with a graphics driver implemented according to the Windows Display Driver Model (WDDM). The API call made by the DXGI may be the OfferResourceDXGI function, which may also provide an identifier for the graphics resource.</p>
<p id="p-0116" num="0115">In response to the API function call made by the DXGI, the WDDM driver may in turn determine the memory space associated with the indicated graphics resource and respond to the DXGI. To respond to the DXGI, the WDDM driver may again perform an API function call, in this case the OfferAllocation call, which may pass to the DXGI an identifier for the memory space associated with the graphics resource. The memory space may be identified in any suitable manner, including through a memory address.</p>
<p id="p-0117" num="0116">As illustrated in <figref idref="DRAWINGS">FIG. 9</figref>, when the DXGI receives the identifier for the memory space from the WDDM driver, the DXGI may in turn communicate to the DxgKrnl (i.e., the video memory manager) to request that the memory space associated with the graphics resource be placed in an &#x201c;offered&#x201d; state and that the DxgKrnl manage the memory space as offered memory.</p>
<p id="p-0118" num="0117">While not illustrated in the example of <figref idref="DRAWINGS">FIG. 9</figref>, a similar communications flow, albeit with different API function calls, may be carried out in the graphics system for performing a reclaim operation.</p>
<p id="p-0119" num="0118">Techniques operating according to the principles described herein may be implemented in any suitable manner. Included in the discussion above are a series of flow charts showing the steps and acts of various processes that manage memory so as to make content that has been made available for discard when memory pressure is experienced by a computing device. The processing and decision blocks of the flow charts above represent steps and acts that may be included in algorithms that carry out these various processes. Algorithms derived from these processes may be implemented as software integrated with and directing the operation of one or more single- or multi-purpose processors, may be implemented as functionally-equivalent circuits such as a Digital Signal Processing (DSP) circuit or an Application-Specific Integrated Circuit (ASIC), or may be implemented in any other suitable manner. It should be appreciated that the flow charts included herein do not depict the syntax or operation of any particular circuit or of any particular programming language or type of programming language. Rather, the flow charts illustrate the functional information one skilled in the art may use to fabricate circuits or to implement computer software algorithms to perform the processing of a particular apparatus carrying out the types of techniques described herein. It should also be appreciated that, unless otherwise indicated herein, the particular sequence of steps and/or acts described in each flow chart is merely illustrative of the algorithms that may be implemented and can be varied in implementations and embodiments of the principles described herein.</p>
<p id="p-0120" num="0119">Accordingly, in some embodiments, the techniques described herein may be embodied in computer-executable instructions implemented as software, including as application software, system software, firmware, middleware, embedded code, or any other suitable type of software. Such computer-executable instructions may be written using any of a number of suitable programming languages and/or programming or scripting tools, and also may be compiled as executable machine language code or intermediate code that is executed on a framework or virtual machine.</p>
<p id="p-0121" num="0120">When techniques described herein are embodied as computer-executable instructions, these computer-executable instructions may be implemented in any suitable manner, including as a number of functional facilities, each providing one or more operations to complete execution of algorithms operating according to these techniques. A &#x201c;functional facility,&#x201d; however instantiated, is a structural component of a computer system that, when integrated with and executed by one or more computers, causes the one or more computers to perform a specific operational role. A functional facility may be a portion of or an entire software element. For example, a functional facility may be implemented as a function of a process, or as a discrete process, or as any other suitable unit of processing. If techniques described herein are implemented as multiple functional facilities, each functional facility may be implemented in its own way; all need not be implemented the same way. Additionally, these functional facilities may be executed in parallel and/or serially, as appropriate, and may pass information between one another using a shared memory on the computer(s) on which they are executing, using a message passing protocol, or in any other suitable way.</p>
<p id="p-0122" num="0121">Generally, functional facilities include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. Typically, the functionality of the functional facilities may be combined or distributed as desired in the systems in which they operate. In some implementations, one or more functional facilities carrying out techniques herein may together form a complete software package. These functional facilities may, in alternative embodiments, be adapted to interact with other, unrelated functional facilities and/or processes, to implement a software program application or software system. For example, in some embodiments functional facilities implementing these techniques may be incorporated into software applications as part of a graphics functionality of the software application, and/or into a graphics rendering system such as the DirectX&#xae; system available from the Microsoft Corporation of Redmond, Wash. In other implementations, the functional facilities may be adapted to interact with other functional facilities in such a way as form an operating system, including the Windows&#xae; operating system, available from the Microsoft&#xae; Corporation of Redmond, Wash. In other words, in some implementations, the functional facilities may be implemented alternatively as a portion of or outside of an operating system.</p>
<p id="p-0123" num="0122">Some exemplary functional facilities have been described herein for carrying out one or more tasks, including a memory manager and functionality of processes that interact with memory. It should be appreciated, though, that the functional facilities and division of tasks described is merely illustrative of the type of functional facilities that may implement the exemplary techniques described herein, and that embodiments are not limited to being implemented in any specific number, division, or type of functional facilities. In some implementations, all functionality may be implemented in a single functional facility. It should also be appreciated that, in some implementations, some of the functional facilities described herein may be implemented together with or separately from others (i.e., as a single unit or separate units), or some of these functional facilities may not be implemented.</p>
<p id="p-0124" num="0123">Computer-executable instructions implementing the techniques described herein (when implemented as one or more functional facilities or in any other manner) may, in some embodiments, be encoded on one or more computer-readable media to provide functionality to the media. Computer-readable media include magnetic media such as a hard disk drive, optical media such as a Compact Disk (CD) or a Digital Versatile Disk (DVD), a persistent or non-persistent solid-state memory (e.g., Flash memory, Magnetic RAM, etc.), or any other suitable storage media. Such a computer-readable medium may be implemented in any suitable manner, including as computer-readable storage media <b>1006</b> of <figref idref="DRAWINGS">FIG. 10</figref> described below (i.e., as a portion of a computing device <b>1000</b>) or as a stand-alone, separate storage medium. As used herein, &#x201c;computer-readable media&#x201d; (also called &#x201c;computer-readable storage media&#x201d;) refers to tangible storage media. Tangible storage media are non-transitory and have at least one physical, structural component. In a &#x201c;computer-readable medium,&#x201d; as used herein, at least one physical, structural component has at least one physical property that may be altered in some way during a process of creating the medium with embedded information, a process of recording information thereon, or any other process of encoding the medium with information. For example, a magnetization state of a portion of a physical structure of a computer-readable medium may be altered during a recording process.</p>
<p id="p-0125" num="0124">In some, but not all, implementations in which the techniques may be embodied as computer-executable instructions, these instructions may be executed on one or more suitable computing device(s) operating in any suitable computer system, including the exemplary computer systems of <figref idref="DRAWINGS">FIGS. 1 and 10</figref>, or one or more computing devices (or one or more processors of one or more computing devices) may be programmed to execute the computer-executable instructions. A computing device or processor may be programmed to execute instructions when the instructions are stored in a manner accessible to the computing device/processor, such as in a local memory (e.g., an on-chip cache or instruction register, a computer-readable storage medium accessible via a bus, a computer-readable storage medium accessible via one or more networks and accessible by the device/processor, etc.). Functional facilities that comprise these computer-executable instructions may be integrated with and direct the operation of computing devices such as a single multi-purpose programmable digital computer apparatus, a coordinated system of two or more multi-purpose computer apparatuses sharing processing power and jointly carrying out the techniques described herein, a single computer apparatus or coordinated system of computer apparatuses (co-located or geographically distributed) dedicated to executing the techniques described herein, one or more Field-Programmable Gate Arrays (FPGAs) for carrying out the techniques described herein, or any other suitable system.</p>
<p id="p-0126" num="0125"><figref idref="DRAWINGS">FIG. 10</figref> illustrates one exemplary implementation of a computing device in the form of a computing device <b>1000</b> that may be used in a system implementing the techniques described herein, although others are possible. It should be appreciated that <figref idref="DRAWINGS">FIG. 10</figref> is intended neither to be a depiction of necessary components for a computing device to operate in accordance with the principles described herein, nor a comprehensive depiction.</p>
<p id="p-0127" num="0126">Computing device <b>1000</b> may comprise at least one processor <b>1002</b>, a network adapter <b>1004</b>, and computer-readable storage media <b>1006</b>. Computing device <b>1000</b> may be, for example, a desktop or laptop personal computer, a personal digital assistant (PDA), a smart mobile phone, a server, a wireless access point or other networking element, or any other suitable computing device. Processors <b>1002</b> may include any suitable processors, including central processing units (CPUs) and/or graphics processing units (GPUs). Network adapter <b>1004</b> may be any suitable hardware and/or software to enable the computing device <b>1000</b> to communicate wired and/or wirelessly with any other suitable computing device over any suitable computing network. The computing network may include wireless access points, switches, routers, gateways, and/or other networking equipment as well as any suitable wired and/or wireless communication medium or media for exchanging data between two or more computers, including the Internet. Computer-readable media <b>1006</b> may be adapted to store data to be processed and/or instructions to be executed by processor <b>1002</b>. Processor <b>1002</b> enables processing of data and execution of instructions. The data and instructions may be stored on the computer-readable storage media <b>1006</b> and may, for example, enable communication between components of the computing device <b>1000</b>.</p>
<p id="p-0128" num="0127">The data and instructions stored on computer-readable storage media <b>1006</b> may comprise computer-executable instructions implementing techniques which operate according to the principles described herein. In the example of <figref idref="DRAWINGS">FIG. 10</figref>, computer-readable storage media <b>1006</b> stores computer-executable instructions implementing various facilities and storing various information as described above. Computer-readable storage media <b>1006</b> may store information regarding one or more processes <b>1008</b> executing on the processors <b>1002</b>. The computer-readable storage media <b>1006</b> may also include memory <b>1010</b>, which may include system memory, video memory, and/or a page file. A memory manager <b>1012</b> may also be encoded on the computer-readable storage media <b>1006</b> and may interact with the processes <b>1008</b> to manage memory in accordance with techniques described herein, including according to any of the exemplary techniques described above. The memory manager <b>1012</b> may also maintain records, including a record <b>1014</b> of memory space that has been offered and thus made available for discard by one or more of the processes <b>1008</b>.</p>
<p id="p-0129" num="0128">While not illustrated in <figref idref="DRAWINGS">FIG. 10</figref>, a computing device may additionally have one or more components and peripherals, including input and output devices. These devices can be used, among other things, to present a user interface. Examples of output devices that can be used to provide a user interface include printers or display screens for visual presentation of output and speakers or other sound generating devices for audible presentation of output. Examples of input devices that can be used for a user interface include keyboards, and pointing devices, such as mice, touch pads, and digitizing tablets. As another example, a computing device may receive input information through speech recognition or in other audible format.</p>
<p id="p-0130" num="0129">Embodiments have been described where the techniques are implemented in circuitry and/or computer-executable instructions. It should be appreciated that some embodiments may be in the form of a method, of which at least one example has been provided. The acts performed as part of the method may be ordered in any suitable way. Accordingly, embodiments may be constructed in which acts are performed in an order different than illustrated, which may include performing some acts simultaneously, even though shown as sequential acts in illustrative embodiments.</p>
<p id="p-0131" num="0130">Various aspects of the embodiments described above may be used alone, in combination, or in a variety of arrangements not specifically discussed in the embodiments described in the foregoing and is therefore not limited in its application to the details and arrangement of components set forth in the foregoing description or illustrated in the drawings. For example, aspects described in one embodiment may be combined in any manner with aspects described in other embodiments.</p>
<p id="p-0132" num="0131">Use of ordinal terms such as &#x201c;first,&#x201d; &#x201c;second,&#x201d; &#x201c;third,&#x201d; etc., in the claims to modify a claim element does not by itself connote any priority, precedence, or order of one claim element over another or the temporal order in which acts of a method are performed, but are used merely as labels to distinguish one claim element having a certain name from another element having a same name (but for use of the ordinal term) to distinguish the claim elements.</p>
<p id="p-0133" num="0132">Also, the phraseology and terminology used herein is for the purpose of description and should not be regarded as limiting. The use of &#x201c;including,&#x201d; &#x201c;comprising,&#x201d; &#x201c;having,&#x201d; &#x201c;containing,&#x201d; &#x201c;involving,&#x201d; and variations thereof herein, is meant to encompass the items listed thereafter and equivalents thereof as well as additional items.</p>
<p id="p-0134" num="0133">The word &#x201c;exemplary&#x201d; is used herein to mean serving as an example, instance, or illustration. Any embodiment, implementation, process, feature, etc. described herein as exemplary should therefore be understood to be an illustrative example and should not be understood to be a preferred or advantageous example unless otherwise indicated.</p>
<p id="p-0135" num="0134">Having thus described several aspects of at least one embodiment, it is to be appreciated that various alterations, modifications, and improvements will readily occur to those skilled in the art. Such alterations, modifications, and improvements are intended to be part of this disclosure, and are intended to be within the spirit and scope of the principles described herein. Accordingly, the foregoing description and drawings are by way of example only.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method of managing memory allocated to a process executing on a computing device, the method comprising:
<claim-text>notifying a memory manager of the computing device that first memory space allocated to the process contains first content available for discard; and</claim-text>
<claim-text>subsequently notifying the memory manager that the process will use the first content of the first memory space.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>in response to the subsequently notifying that the process will use the first content, receiving an indication from the memory manager of whether the first content was discarded.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising:
<claim-text>when the indication from the memory manager indicates that the first content was discarded, regenerating the first content and storing the regenerated first content in the first memory space.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein notifying the memory manager that the first content is available for discard comprises notifying the memory manager of a priority level for the first content that is available for discard.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein notifying the memory manager that the first content is available for discard comprises notifying the memory manager that memory space in video memory contains graphics data available for discard.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, further comprising requesting that a first amount of memory in the video memory be allocated to the process for use as a staging buffer for graphics operations of the process, and
<claim-text>wherein notifying the memory manager that the first content is available for discard comprises notifying the memory manager that the staging buffer contains content available for discard.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein notifying the memory manager that the first content is available for discard comprises notifying the memory manager that memory space in system memory contains data available for discard.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising, prior to notifying the memory manager that the first content is available for discard:
<claim-text>requesting that the first memory space be allocated to the process;</claim-text>
<claim-text>generating the first content and storing the first content in the first memory space; and</claim-text>
<claim-text>using the first content.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. A method of managing memory allocated to one or more processes executing on a computing device, the method comprising:
<claim-text>maintaining a record of allocated memory space for which contents of the allocated memory space are not required to be preserved, the maintenance of the record including:
<claim-text>removing an identifier of a first memory space from the record in response to a request from a first process to use content of the first memory space;</claim-text>
</claim-text>
<claim-text>detecting that the computing device is experiencing memory pressure;</claim-text>
<claim-text>selecting, based on the record, second memory space for which the content is not required to be preserved; and</claim-text>
<claim-text>ceasing to preserve content of the second memory space.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein maintaining the record of allocated memory for which the contents are not required to be preserved further includes:
<claim-text>prior to the request adding the first memory space to the record in response to a notification from the first process, to which the first memory space is allocated, that the content of the first memory space is available for discard.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, further comprising:
<claim-text>receiving a notification from the first process, to which the first memory space is allocated, that the first memory space contains content that is not required to be preserved; and</claim-text>
<claim-text>following receiving the notification, maintaining a memory allocation of the first process.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein maintaining the memory allocation of the first process comprises, following ceasing to preserve the content of the second memory space, continuing to allocate the second memory space to the first process.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein detecting that the computing device is experiencing memory pressure comprises determining that a main memory of the computing device contains more than a threshold amount of content.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein detecting that the computing device is experiencing memory pressure comprises determining that the computing device is to undergo a power state transition.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein selecting the second memory space based on the record comprises selecting the second memory space from among the allocated memory space for which the contents are not required to be preserved based at least in part on a time that memory was added to the record.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein selecting the second memory space based on the record comprises selecting the second memory space from among the allocated memory space for which the contents are not required to be preserved based at least in part on a priority level of the content set by a the first process to which the second memory space is allocated.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. At least one computer-readable memory having computer-executable instructions stored therein, the computer-executable instructions, for causing the at least one processor to execute a method of managing memory allocated to one or more processes executing on a computing device, the method comprising:
<claim-text>receiving from a first process to which first memory is allocated an indication that the first memory contains first content that is available for discard;</claim-text>
<claim-text>subsequently receiving from the first process a request to use the first content of the first memory that was indicated to be available for discard;</claim-text>
<claim-text>determining whether the content of the first memory was discarded; and</claim-text>
<claim-text>based on a result of the determining, responding to the request with a notification that the first content is available for use or that the first content was discarded.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The at least one computer-readable memory of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein receiving the indication that the first memory contains first content available for discard comprises receiving a priority level of the first content available for discard.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The at least one computer-readable memory of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the method further comprises:
<claim-text>in response to receiving the indication from the first process, adding the first memory to a record of allocated memory that contains content available for discard; and</claim-text>
<claim-text>in response to subsequently receiving the request to use the first content, removing the first memory from the record.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The at least one computer-readable memory of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein receiving the indication from the first process comprises receiving, from a graphics driver, an indication that data regarding a graphic, which is stored in video memory of the computing device, is available for discard. </claim-text>
</claim>
</claims>
</us-patent-grant>
