<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627409-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627409</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>11748639</doc-number>
<date>20070515</date>
</document-id>
</application-reference>
<us-application-series-code>11</us-application-series-code>
<us-term-of-grant>
<us-term-extension>1425</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>H</section>
<class>04</class>
<subclass>L</subclass>
<main-group>29</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>726  3</main-classification>
<further-classification>726  9</further-classification>
<further-classification>713152</further-classification>
<further-classification>713160</further-classification>
</classification-national>
<invention-title id="d2e53">Framework for automated dissemination of security metadata for distributed trust establishment</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6088796</doc-number>
<kind>A</kind>
<name>Cianfrocca et al.</name>
<date>20000700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713152</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>2005/0251533</doc-number>
<kind>A1</kind>
<name>Harken et al.</name>
<date>20051100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>7071041</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>2007/0079117</doc-number>
<kind>A1</kind>
<name>Bhogal et al.</name>
<date>20070400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713160</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2007/0100701</doc-number>
<kind>A1</kind>
<name>Boccon-Gibod et al.</name>
<date>20070500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>705 21</main-classification></classification-national>
</us-citation>
<us-citation>
<nplcit num="00005">
<othercit>Straub, Tobias, &#x201c;Usability Challenges of PKI,&#x201d; Dissertation, Dec. 2005 (289 pages).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>18</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>726  9</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>713152</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>713160</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>7</number-of-drawing-sheets>
<number-of-figures>7</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20080289019</doc-number>
<kind>A1</kind>
<date>20081120</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Lam</last-name>
<first-name>Peifung Eric</first-name>
<address>
<city>Mountain View</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Lam</last-name>
<first-name>Peifung Eric</first-name>
<address>
<city>Mountain View</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Kilpatrick Townsend &#x26; Stockton LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Oracle International Corporation</orgname>
<role>02</role>
<address>
<city>Redwood Shores</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Hoffman</last-name>
<first-name>Brandon</first-name>
<department>2433</department>
</primary-examiner>
<assistant-examiner>
<last-name>Anderson</last-name>
<first-name>Michael D</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Methods, systems, and machine-readable media for disseminating security metadata from one distributed entity to another in an automated fashion are disclosed. According to one embodiment of the present invention, a computer-implemented method for distributing security metadata comprises receiving at a first service a request for security metadata, the request being received from a process associated with a second service. The method further comprises generating an identifier and security metadata for the second service, the identifier and the security metadata being unique to the second service, and storing the identifier and the security metadata in a first memory accessible to the first service. The identifier and the security metadata are then transmitted to the process associated with the second service and stored in a second memory. The second service is configured to access the security metadata stored in the second memory to encrypt a first communication and decrypt a second communication.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="158.33mm" wi="174.67mm" file="US08627409-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="179.58mm" wi="187.11mm" file="US08627409-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="222.08mm" wi="157.14mm" file="US08627409-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="212.51mm" wi="147.91mm" file="US08627409-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="180.85mm" wi="180.59mm" file="US08627409-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="244.52mm" wi="159.77mm" file="US08627409-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="237.91mm" wi="184.49mm" file="US08627409-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="208.87mm" wi="173.65mm" file="US08627409-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0002" num="0001">Embodiments of the present invention relate generally to information distribution, and more particularly relate to systems and methods for disseminating security metadata.</p>
<p id="p-0003" num="0002">In an enterprise deployment, distributed software applications typically rely on a centralized security service. These applications are known as &#x201c;relying parties&#x201d; because they &#x201c;rely&#x201d; on the security service to carry out various security functions. For example, a relying party may delegate responsibility for user authentication to a centralized Single Sign-On (&#x201c;SSO&#x201d;) server. In this scenario, the SSO server authenticates a user and passes the user's authenticated identity securely to the relying party. The relying party then accepts the authenticated identity from the SSO server and grants application access to the user. Since relying parties can take advantage of centralized security functions, they do not need to implement their own security modules. This simplifies application administration and deployment.</p>
<p id="p-0004" num="0003">Implementing a centralized security service requires two-way trust to be established between relying parties and the security service. In other words, the relying parties must trust that all communications received from the security service are genuine, and vice versa. As known in the art, one way to establish this trust is through the use of security metadata (e.g., passwords, cryptographic keys, etc.). For example, a relying party may encrypt a user authentication request using a symmetric key known only to the relying party and the security service, and send the encrypted request to the security service. Since the relying party is the only other party that knows the key, the security service can trust that the request is genuine. Similarly, the security service may encrypt a response (e.g., authenticated user identity) using the symmetric key, and transmit the encrypted response to the relying party. Since the security service is the only other party that knows the key, the relying party can trust that the response is genuine.</p>
<p id="p-0005" num="0004">In current implementations, security metadata can be distributed to relying parties manually (i.e., through human intervention). For example, an administrator of a relying party may contact an administrator of the security service via phone, email, physical mail, or the like and request security metadata. The administrator of the security service may then provide the security metadata in a disk, USB flash drive, email, or the like. In another (semi) manual approach, the security service may operate a self-service administration page for disseminating security metadata. The administrator of the relying party may login to the page and request security metadata, which is presented via a user interface to the administrator. The administrator may then manually record the presented metadata and insert it into the relying party system.</p>
<p id="p-0006" num="0005">While these manual approaches are functional, they are also problematic for several reasons. First, they may be time-consuming. It may take a long time, for instance, for the administrator of the security service to respond to an email request. Second, these approaches are not particularly secure. Security metadata that is exchanged on a disk or USB drive is prone to theft or loss, and metadata that is sent via email is prone to being intercepted or viewed by unintended third parties. Finally, manual distribution is error-prone. Security metadata is often complex and &#x201c;cryptic.&#x201d; For instance, a 128-bit cryptographic key is represented as a string of 26 or more hexadecimal digits. As such, transferring this data manually can be difficult and result in transcription errors or other mistakes.</p>
<p id="p-0007" num="0006">The dissemination of security metadata can be facilitated, to some extent, through public key infrastructure (PKI). In general, a PKI consists of client software, server software such as a certificate authority, hardware (e.g., smart cards) and operational procedures. PKI can be set up to provide for trusted third party vetting of, and vouching for, user identities. PKI arrangements enable computer users to be authenticated to each other, and to use the information in identity certificates (i.e., each other's public keys) to encrypt and decrypt messages traveling to and fro.</p>
<p id="p-0008" num="0007">PKI is known for its complex deployment requirements and its usability issues are well documented. Some of the notable difficulties include certificate management, trust anchors management, and Information and Service Access control. Also, not all PKI operational procedures are fully automated in a typical deployment environment.</p>
<p id="p-0009" num="0008">Thus, it is desirable to have a fully automated process for disseminating security metadata that overcomes the problems of manual distribution without incurring the complexities of a PKI deployment.</p>
<heading id="h-0002" level="1">BRIEF SUMMARY OF THE INVENTION</heading>
<p id="p-0010" num="0009">Embodiments of the present invention address the foregoing and other such problems by providing a framework for automated dissemination of security metadata.</p>
<p id="p-0011" num="0010">In one set of embodiments, a process transmits a request for security metadata on behalf of a relying party to a management endpoint of a security service. The requesting process may be a process of the relying party itself, or a separate, but associated process (e.g., installer process, registration process, etc.). The request is transmitted via a secure communications protocol, such as Secure Sockets Layer (SSL). When the request is received, a component of the security service authenticates the user that initiated the request (e.g., an administrator) and generates an identifier and security metadata unique to the relying party. This information is stored in a first memory location (e.g., flat file, database, etc.) accessible to the security service. The identifier and security metadata is then transmitted back via the same secure communications protocol (e.g., SSL) to the relying party, where the information is stored in a second memory location (e.g., flat file, database, etc.) accessible to the relying party. In this manner, security metadata is quickly and securely exchanged between a centralized security authority and a partner entity with minimal human intervention.</p>
<p id="p-0012" num="0011">In further embodiments, a centralized management service or directory is employed to facilitate the interoperation of the security service and relying parties. For example, the management service may store the current network address of the security service management endpoint. Thus, relying parties may access the management service and dynamically discover the location of the management endpoint at the time of submitting a security metadata request, rather than storing the location locally. This feature is useful in at least two scenarios. First, if the network address of the security service changes, each individual relying party does not need to be updated with the new address. Second, if multiple security service instances are available, the management service can perform load balancing by directing relying parties to the security service instance with the lightest load.</p>
<p id="p-0013" num="0012">The management service may also be used for other functions, such as storing the network addresses of security service access endpoints (used by relying parties at runtime to request security services), or storing the identifier/security metadata information for each relying party. These functions are further described in the detailed description.</p>
<p id="p-0014" num="0013">According to one embodiment of the present invention, a computer-implemented method for distributing security metadata comprises receiving at a first service a request for security metadata, the request being received from a process associated with a second service. The method further comprises generating an identifier and security metadata for the second service, the identifier and the security metadata being unique to the second service, and storing the identifier and the security metadata in a first memory accessible to the first service. The identifier and the security metadata are then transmitted to the process associated with the second service and stored in a second memory. The second service is configured to access the security metadata stored in the second memory to encrypt a first communication and decrypt a second communication.</p>
<p id="p-0015" num="0014">According to another embodiment of the present invention, the first service is resident on a first server and the process associated with the second service is resident on a second server. The process is configured to determine the location of the first service by querying a management service resident on a third server, where the first service is registered with the management service.</p>
<p id="p-0016" num="0015">According to yet another embodiment of the present invention, a system for distributing security metadata comprises a first data storage device operable to store a plurality of security metadata and a first server in communication with the first data storage device, the first server executing an instance of a first service. The first service is configured to receive a request for security metadata from a process associated with a second service. The first service is further configured to generate an identifier and security metadata for the second service, the identifier and the security metadata being unique to the second service, and store the identifier and the security metadata in the first data storage device. The identifier and the security metadata are then transmitted to the process associated with the second service and stored in memory. The second service is configured to access the security metadata stored in the memory to encrypt a first communication and decrypt a second communication.</p>
<p id="p-0017" num="0016">According to yet another aspect of the present invention, a machine-readable medium for a computer system is disclosed. The machine-readable medium includes instructions which, when executed by a processor, cause the processor to receive a request for security metadata, the request being received from a process associated with an application service. Various embodiments also include instructions that cause the processor to generate an identifier and security metadata for the application service, the identifier and the security metadata being unique to the application service; and store the identifier and the security metadata in a first memory accessible to the computer system. Further instructions cause the processor to transmit the identifier and the security metadata to the process associated with the application service, the process being configured to store the identifier and the security metadata in a second memory. The application service is configured to access the security metadata stored in the second memory to encrypt a first communication and decrypt a second communication.</p>
<p id="p-0018" num="0017">A further understanding of the nature and the advantages of the embodiments disclosed herein may be realized by reference to the remaining portions of the specification and the attached drawings.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0019" num="0018">Various embodiments in accordance with the present invention will be described with reference to the drawings, in which:</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 1</figref> illustrates an exemplary environment for running a relying party.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIGS. 2A and 2B</figref> illustrate the steps performed in authenticating a user of a relying party at runtime.</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 3</figref> illustrates an exemplary environment for registering a relying party in accordance with one embodiment of the present invention.</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 4</figref> illustrates the steps performed in processing a request for security metadata in accordance with one embodiment of the present invention.</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 5</figref> illustrates components of an exemplary system environment that can be used in accordance with one embodiment of the present invention.</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 6</figref> illustrates components of a computerized device that can be used in accordance with one embodiment of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION OF THE INVENTION</heading>
<p id="p-0026" num="0025">In the following description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent, however, to one skilled in the art that the present invention may be practiced without some of these specific details. In other instances, well-known structures and devices are shown in block diagram form.</p>
<p id="p-0027" num="0026">Embodiments of the present invention relate to methods, systems, and machine-readable media for disseminating security metadata from one distributed entity to another in an automated fashion. Specific embodiments are directed (but not limited) to the enterprise software context, where security metadata must be exchanged between a centralized security service and a number of different relying parties. Current methods of manual security metadata distribution are problematic because they can be time-consuming, insecure, and error-prone. Embodiments of the present invention overcome these problems and thus facilitate the deployment and maintenance of distributed entities (e.g., relying parties) that rely on centralized security.</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 1</figref> illustrates an exemplary runtime environment of a relying party in an enterprise deployment. This figure, in conjunction with <figref idref="DRAWINGS">FIGS. 2A and 2B</figref>, is presented to provide an overview on how a relying party typically invokes a centralized security service to satisfy a user request. As shown, runtime environment <b>100</b> includes user clients <b>102</b>, <b>104</b>, <b>105</b>, which send user requests to relying party <b>106</b>. These user requests may include, for example, a login request, or a request to perform a specific application function (e.g., data view, data insert, data delete, etc.). Although only three user clients are shown, one of ordinary skill in the art would appreciate that any number of user clients may be in communication with relying party <b>106</b> at a time.</p>
<p id="p-0029" num="0028">User clients <b>102</b>, <b>104</b>, <b>105</b> are also communicatively connected to security service <b>110</b>. Security service <b>110</b> is configured to perform one or more security-related functions on behalf of relying party <b>106</b>. Such functions may include user authentication, user authorization, or a more generic &#x201c;claims&#x201d; function where security service <b>110</b> can vouch for any assertion (i.e., logical statement). For example, security service <b>110</b> can vouch that a user's driver license number is XXXXX, the user is 21 years or older, the user has a credit limit sufficient to pay for a particular transaction, the user is authorized to carry out a particular action, and the like. Logically, a &#x201c;claims&#x201d; function can subsume an authentication function, which asserts a user's identity, and an authorization function, which asserts that a user is allowed/disallowed to carry out a particular action.</p>
<p id="p-0030" num="0029">To execute these security functions, security service <b>110</b> consults with a user database <b>112</b> and a security metadata database <b>114</b>. As will be described in further detail below, security metadata database <b>114</b> contains the security metadata that is generated for (and distributed to) each relying party. Databases <b>112</b> and <b>114</b> may each be implemented as a single data repository or a collection of data repositories, and may reside on storage that is local or remote to security service <b>110</b>.</p>
<p id="p-0031" num="0030">Relying party <b>106</b> coordinates interoperation with security service <b>110</b> through relying party agent <b>108</b>. Agent <b>108</b> may be implemented as an internal process or thread of relying party <b>106</b>, or as an external process. In various embodiments, agent <b>108</b> is configured to intercept user requests that require security services, and to redirect those requests to security service <b>110</b>. Agent <b>108</b> is also configured to receive any data (e.g., security tokens) received from security service <b>110</b> and process that data to allow or disallow a user request.</p>
<p id="p-0032" num="0031">Environment <b>100</b> also includes a centralized management service <b>116</b> and a management database <b>118</b>. At runtime, relying party <b>106</b> (or agent <b>108</b>) interacts with management service <b>116</b> to discover data that is needed to interoperate with security service <b>110</b>. For example, management service <b>116</b> may have access to the network location of the access endpoint (e.g., security service URL) of security service <b>110</b>. In certain embodiments, management service <b>116</b> may also store the identifier and security metadata for relying party <b>116</b>. Thus, relying party <b>106</b> would need to retrieve this data before requesting security functionality from security service <b>110</b>. In various embodiments, all of the above management data would be stored in management database <b>118</b>. Management database <b>118</b> may be implemented as a single data repository or a collection of data repositories, and may reside on storage that is local or remote to management service <b>116</b>.</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIGS. 2A and 2B</figref> illustrate the steps performed in authenticating a user of a relying party at runtime. Although user authentication is shown, it should be apparent that relying party <b>106</b> may interact with security service <b>110</b> to request any type of security-related function, including but not limited to authentication, authorization, and claims functions. One of ordinary skill in the art would recognize other variations, modifications, and alternatives. At step <b>202</b>, user client <b>102</b>, <b>104</b>, or <b>105</b> transmits a request to relying party <b>106</b>. As described above, the request may be, for instance, a login request. At step <b>204</b>, agent <b>108</b> intercepts the user request and determines whether the user has been previously authenticated. In one set of embodiments, this determination is performed by checking for a security &#x201c;cookie&#x201d; on the user client's computer. In this case, the cookie would exist if the user client had been previously authenticated by security service <b>110</b>.</p>
<p id="p-0034" num="0033">If the security cookie doesn't exist (or has expired), a security configuration file is consulted to determine the network location of security service <b>110</b>, as well as the identifier and security metadata for relying party <b>106</b> (<b>206</b>). In various embodiments, this security configuration file is created when security metadata is initially disseminated from security service <b>110</b> to relying party <b>106</b> (described further below). In an exemplary embodiment, the configuration file contains the relying party (or agent) identifier, the security metadata for the application, and a network address (e.g., URL) of the access endpoint of security service <b>110</b>.</p>
<p id="p-0035" num="0034">In alternative embodiments, the configuration file contains a &#x201c;topology node ID&#x201d; in addition to (or in lieu of) the hard-coded access endpoint address. The topology node ID is used as a reference to a data entry in management service <b>116</b> which stores the current access endpoint address. Thus, the topology node ID is used by application <b>106</b> in certain embodiments to dynamically discover the location of security service <b>110</b> at runtime. If topology node ID is used, the hard-coded access endpoint address in the configuration file may be ignored by relying party <b>106</b>. Alternatively, the hard-coded address may still be used if, for example, management service <b>116</b> is unavailable and cannot be queried.</p>
<p id="p-0036" num="0035">Although the security configuration file is referred to as a &#x201c;file,&#x201d; one of ordinary skill in the art would recognize that the information contained therein (e.g., identifier, security metadata, etc.) may be stored in any type of logical storage format (e.g., flat file, database entry, etc.). Furthermore, the configuration file may be stored in a location local or remote to relying party <b>106</b>. In one set of embodiments, the configuration file may be stored with management service <b>116</b>. This would allow, inter alia, multiple instances of a relying party to share a single identifier and security metadata.</p>
<p id="p-0037" num="0036">At step <b>208</b>, agent <b>108</b> secures (e.g., encrypts) information from the user request (e.g., time of request, resource requested by the user, etc.) using the security metadata retrieved from the configuration file. The security metadata may be, for instance, a symmetric or asymmetric cryptographic key. Many other types of security metadata (such as passwords, etc.) are contemplated and may be used in conjunction with the present invention. The agent then constructs an authentication request. In various embodiments, the authentication request comprises the identifier of relying party <b>106</b> (retrieved from the configuration file), concatenated with the encrypted request information described above.</p>
<p id="p-0038" num="0037">The authentication request is subsequently transmitted to security service <b>110</b> (<b>210</b>). In an embodiment, the request is transmitted directly between relying party <b>106</b> and security service <b>110</b>. Alternatively, the request may be sent to the user client's application (e.g., web browser, document processor, etc.), with a command to redirect the client application to security service <b>110</b>.</p>
<p id="p-0039" num="0038">When the authentication request has been received at security service <b>110</b>, the application identifier is extracted from the request and the identifier is used to determine the corresponding security metadata from security metadata database <b>114</b> (<b>212</b>). The determined security metadata is then used to decrypt the encrypted portion of the request. (<b>214</b>). In various embodiments, security service <b>110</b> may determine an appropriate authentication mechanism (e.g., username/password, PKI certificate, Kerberos token, Security Assertion Markup Language (&#x201c;SAML&#x201d;) token, etc.) based on the information in the encrypted request. Once the mechanism is determined, the security credentials of the user are collected and verified against user database <b>112</b> (<b>216</b>).</p>
<p id="p-0040" num="0039">If the verification is successful, security service <b>110</b> generates a security token signifying the authenticity of the user (<b>218</b>). This token is encrypted using the security metadata corresponding to relying party <b>106</b> and transmitted to agent <b>108</b> (<b>220</b>). As before, this transmission may be sent directly to relying party <b>106</b> or through a redirection of the user client's application.</p>
<p id="p-0041" num="0040">At step <b>222</b>, agent <b>108</b> receives the encrypted token and decrypts the token using the security metadata of relying party <b>106</b>. An indication of the token is then stored on the user client side (e.g., in the form of a security cookie) and the user request is allowed (<b>224</b>).</p>
<p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. 3</figref> illustrates an exemplary environment for registering a relying party in accordance with one embodiment of the present invention. As described herein, &#x201c;registration&#x201d; refers to configuring a relying party to interoperate with a centralized security service (e.g., <b>110</b>). Accordingly, a &#x201c;registration process&#x201d; (e.g., <b>302</b> of <figref idref="DRAWINGS">FIG. 3</figref>) is a process that requests security metadata for a relying party (e.g., <b>116</b>). Registration may occur at the time a relying party is installed; in this case, the registration may be performed by the relying party's installer process. Alternatively, registration may occur after the relying party has been installed, but before the relying party application has been brought online. Referring to <figref idref="DRAWINGS">FIG. 3</figref>, registration process <b>302</b> may be a process that is separate from its associated relying party <b>106</b>, or may be an integral part of party <b>106</b>.</p>
<p id="p-0043" num="0042">As shown in <figref idref="DRAWINGS">FIG. 3</figref>, registration process <b>302</b> is communicatively coupled to security service <b>110</b> and management service <b>116</b>. As will be described in greater detail with respect to <figref idref="DRAWINGS">FIG. 4</figref>, registration process <b>302</b> interacts with these services to request security metadata on behalf of relying party <b>106</b>. Registration environment <b>300</b> also includes user database <b>112</b>, security metadata database <b>114</b>, and management database <b>118</b>. These components are identical to those displayed in the runtime environment of <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. 4</figref> illustrates the steps performed in processing a request for security metadata in accordance with one embodiment of the present invention. At step <b>402</b>, a user initiates registration process <b>302</b> to request metadata for relying party <b>106</b>. This user would typically be an administrator of relying party <b>106</b>. In an alternative embodiment, registration process <b>302</b> may be triggered through a parent process (e.g., installer process of relying party <b>106</b>) or some other automated mechanism (e.g., programmatic workflow rule, etc.). In this case, the requesting &#x201c;user&#x201d; may be the initiator of the parent process, or a generic user account associated with automated infrastructure operations.</p>
<p id="p-0045" num="0044">As described above, security service <b>110</b> may be registered with management service <b>116</b>. In this case, registration process <b>302</b> may consult management service <b>116</b> to dynamically discover the network address of the security service's management endpoint (<b>404</b>). This allows a single, up-to-date copy of this location information to be maintained across the entire deployment. This also allows management service <b>116</b> to load-balance security metadata requests across multiple security service instances. Alternatively, each relying party (or associated registration process) may maintain the network address of the security service's management endpoint in local storage, and consult that locally-stored information to transmit a security metadata request.</p>
<p id="p-0046" num="0045">At step <b>406</b>, registration process <b>302</b> transmits a request for security metadata on behalf of relying party <b>106</b> to security service <b>110</b>. The request may include (but is not limited to) the network address (e.g., URL) of agent <b>108</b>, a human-readable name of agent <b>108</b> or application <b>106</b>, and the requesting user's security credentials (e.g., username/password). In a exemplary embodiment, the request is sent via a secure communications protocol, such as Secure Sockets Layer (SSL). This is to ensure that the content of the request is not modified during transmission. Additionally, the request is encoded in a higher-level management protocol, such as Java Management Extensions (JMX). Of course, any other type of protocol or combination of protocols may be used.</p>
<p id="p-0047" num="0046">At step <b>408</b>, the security service receives the request at its management endpoint and authenticates the provided user security credentials against user database <b>112</b>. In various embodiments, the management endpoint is implemented as a JMX managed bean (MBean). The JMX MBean is further encapsulated within an Oracle Container for J2EE (OC4J) container. In alternative embodiments, other software or hardware implementations are contemplated. One of ordinary skill in the art would recognize many variations, modifications, and alternatives.</p>
<p id="p-0048" num="0047">According to one set of embodiments, security service <b>110</b> uses the security credentials of the requesting user to determine a user role of the user (<b>410</b>). For example, this user role information may be stored in, and determined from, user database <b>112</b>. Alternatively, this user role information may be included in the request sent from registration process <b>302</b>. The user role may then be checked against a set of privileges assigned to the role to determine whether the requesting user has the appropriate privileges to request security metadata. In an exemplary embodiment, an &#x201c;administrator&#x201d; type role will typically possess the appropriate privileges to request security metadata. However, these privileges may be assigned to any role in the system.</p>
<p id="p-0049" num="0048">Once the requesting user has been authenticated (and optionally authorized), the security service generates an identifier and security metadata unique to relying party <b>106</b> (<b>412</b>). In one embodiment, the security metadata is a symmetric cryptographic key, such as an AES key. In this case, the security metadata may be generated using any of the commonly known methods for generating cryptographic keys. However, one of ordinary skill in the art would recognize that the security metadata may be any type of information that is sufficient to establish trust between the relying party and the security service (e.g., a password). In various embodiments, the generated identifier and security metadata may be tied to a piece of data (e.g., name, URL, etc.) associated to relying party <b>106</b>, or to a piece of data associated to agent <b>108</b>. Since there is a one-to-one relationship between relying parties and agents, any identifier that uniquely identifies agent <b>108</b> also uniquely identifies relying party <b>106</b>.</p>
<p id="p-0050" num="0049">At step <b>412</b>, the generated identifier and security metadata are stored in security metadata database <b>114</b>. This allows security service <b>110</b> to determine the appropriate security metadata for a given relying party/agent at runtime. Other information sent in the security metadata request, such as agent URL, agent name, and the like may also be stored in database <b>114</b>. This additional information may be useful if, for example, an administrator of security service <b>110</b> needs to view and modify the entries in the database.</p>
<p id="p-0051" num="0050">Once the unique identifier and security metadata are generated and stored, they are transmitted to registration process <b>302</b> (<b>414</b>). In an exemplary embodiment, this response communication is secured and transmitted via the same protocols as the original security metadata request (e.g., SSL, JMX, etc.).</p>
<p id="p-0052" num="0051">At step <b>416</b>, the identifier and metadata are received at registration process <b>302</b> and stored as a configuration file (or any other type of logical storage format) in a storage location accessible to relying party <b>106</b>. In one embodiment, the received information is stored locally on the same server as relying party <b>106</b>. In other embodiments, the identifier and metadata are also stored with management service <b>116</b>. This arrangement has several advantages. First, it allows for efficient version control, since a master version of security metadata for each relying party can be maintained and updated at the management service. If a system-wide change to, for example, the formatting of security metadata needs to be made, the revision can be performed at management service <b>116</b> and pushed to all relying parties. Second, this arrangement can be used as a backup mechanism, in case a copy of security metadata stored locally at a relying party becomes corrupted. Third, this arrangement allows for load-balancers that automatically balance user requests across multiple instances of a relying party. Since all instances of a given application should share the same security metadata, each instance can access a single, master copy of the metadata through management service <b>116</b> rather than maintaining separate, duplicate copies.</p>
<p id="p-0053" num="0052">It should be appreciated that the specific steps illustrated in <figref idref="DRAWINGS">FIG. 4</figref> provide a particular method of automatically disseminating security metadata according to an embodiment of the present invention. Other sequences of steps may also be performed according to alternative embodiments. For example, alternative embodiments of the present invention may perform the steps outlined above in a different order. Moreover, the individual steps illustrated in <figref idref="DRAWINGS">FIG. 4</figref> may include multiple sub-steps that may be performed in various sequences as appropriate to the individual step. Furthermore, additional steps may be added or removed depending on the particular applications. One of ordinary skill in the art would recognize many variations, modifications, and alternatives.</p>
<p id="p-0054" num="0053">Although the foregoing embodiments have been discussed with respect to distributed software applications, many other uses of the present invention are contemplated. For example, embodiments of the present invention may be used to distribute security metadata between load balancers, network switches, security appliances, and other software and/or hardware-based devices/services. One of ordinary skill in the art would recognize many other uses.</p>
<p id="p-0055" num="0054"><figref idref="DRAWINGS">FIG. 5</figref> is a block diagram illustrating components of an exemplary system environment in which various embodiments of the present invention may be implemented. The system <b>500</b> includes one or more user computers, computing devices, or processing devices <b>512</b>, <b>514</b>, <b>516</b>, <b>518</b>, which are used to operate a relying party client, such as a dedicated client (e.g., Oracle Forms), web browser, or the like. User computers <b>512</b>, <b>514</b>, <b>516</b>, <b>518</b> may be general purpose personal computers (including, merely by way of example, personal computers and/or laptop computers running various versions of Microsoft Windows and/or Apple Macintosh operating systems), cell phones or PDAs (running software such as Microsoft Windows Mobile and being Internet, e-mail, SMS, Blackberry, or other communication protocol enabled), and/or workstation computers running any of a variety of commercially-available UNIX or UNIX-like operating systems (including without limitation, the variety of GNU/Linux operating systems). These user computers <b>512</b>, <b>514</b>, <b>516</b>, <b>518</b> may also have any of a variety of software applications stored therein. Alternatively, user computers <b>512</b>, <b>514</b>, <b>516</b>, <b>518</b> may be any other electronic device, such as a thin-client computer, Internet-enabled gaming system, and/or personal messaging device, capable of communicating via a network (e.g., network <b>510</b> described below) and/or displaying and navigating Web pages or other types of electronic documents. Although exemplary system environment <b>500</b> is shown with four user computers, any number of user computers may be supported.</p>
<p id="p-0056" num="0055">In most embodiments, system environment <b>500</b> includes some type of network <b>510</b>. Network <b>510</b> may be any type of network familiar to those skilled in the art that can support data communications using any of a variety of commercially-available protocols, including without limitation TCP/IP, SNA, IPX, AppleTalk, and the like. Merely by way of example, network <b>510</b> can be a local area network (&#x201c;LAN&#x201d;), such as an Ethernet network, a Token-Ring network and/or the like; a wide-area network; a virtual network, including without limitation a virtual private network (&#x201c;VPN&#x201d;); the Internet; an intranet; an extranet; a public switched telephone network (&#x201c;PSTN&#x201d;); an infra-red network; a wireless network (e.g., a network operating under any of the IEEE 802.11 suite of protocols, the Bluetooth protocol known in the art, and/or any other wireless protocol); and/or any combination of these and/or other networks.</p>
<p id="p-0057" num="0056">System environment <b>500</b> also includes one or more server computers <b>502</b>, <b>504</b>, <b>506</b> which may be general purpose computers, specialized server computers (including, merely by way of example, PC servers, UNIX servers, mid-range servers, mainframe computers rack-mounted servers, etc.), server farms, server clusters, or any other appropriate arrangement and/or combination. In various embodiments, one or more of the servers <b>502</b>, <b>504</b>, <b>506</b> are dedicated to running the relying parties, centralized security service, and centralized management service described in the foregoing disclosure. For example, as showing in <figref idref="DRAWINGS">FIG. 5</figref>, server <b>502</b> may act as an application server configured to execute relying party <b>106</b>. Server <b>504</b> may act as a security server configured to execute security service <b>110</b>. And server <b>506</b> may act as a management server configured to execute management service <b>116</b>.</p>
<p id="p-0058" num="0057">Each server <b>502</b>, <b>504</b>, <b>506</b> may run an operating system including any of those discussed above, as well as any commercially-available server operating systems. Servers <b>502</b>, <b>504</b>, <b>506</b> may also run any of a variety of additional server applications and/or mid-tier applications, including HTTP servers, FTP servers, CGI servers, Java servers, database servers, and the like. Exemplary database servers include without limitation those commercially available from Oracle, Microsoft, Sybase, IBM and the like.</p>
<p id="p-0059" num="0058">System environment <b>500</b> may also include one or more databases <b>520</b>. For instance, databases <b>520</b> may include user database <b>112</b>, security metadata database <b>114</b>, and management database <b>118</b> as described in the foregoing disclosure. The databases <b>520</b> may reside in a variety of locations. By way of example, a database <b>520</b> may reside on a storage medium local to (and/or resident in) one or more of the computers <b>502</b>, <b>504</b>, <b>506</b>, <b>512</b>, <b>514</b>, <b>516</b>, <b>518</b>. Alternatively, it may be remote from any or all of the computers <b>502</b>, <b>504</b>, <b>506</b>, <b>512</b>, <b>514</b>, <b>516</b>, <b>518</b>, and/or in communication (e.g., via network <b>510</b>) with one or more of these. In a particular set of embodiments, databases <b>520</b> may reside in a storage-area network (&#x201c;SAN&#x201d;) familiar to those skilled in the art. Similarly, any necessary files for performing the functions attributed to the computers <b>502</b>, <b>504</b>, <b>506</b>, <b>512</b>, <b>514</b>, <b>516</b>, <b>518</b> may be stored locally on the respective computer and/or remotely, as appropriate. In one set of embodiments, databases <b>520</b> may be relational databases, such as Oracle 10g, that are adapted to store, update, and retrieve data in response to SQL-formatted commands.</p>
<p id="p-0060" num="0059"><figref idref="DRAWINGS">FIG. 6</figref> illustrates an exemplary computer system <b>600</b>, in which various embodiments of the present invention may be implemented. The system <b>600</b> may be used to implement any of the computer systems described above. The computer system <b>600</b> is shown comprising hardware elements that may be electrically coupled via a bus <b>624</b>. The hardware elements may include one or more central processing units (CPUs) <b>602</b>, one or more input devices <b>604</b> (e.g., a mouse, a keyboard, etc.), and one or more output devices <b>606</b> (e.g., a display device, a printer, etc.). The computer system <b>600</b> may also include one or more storage devices <b>608</b>. By way of example, the storage device(s) <b>608</b> may include devices such as disk drives, optical storage devices, solid-state storage device such as a random access memory (&#x201c;RAM&#x201d;) and/or a read-only memory (&#x201c;ROM&#x201d;), which can be programmable, flash-updateable and/or the like.</p>
<p id="p-0061" num="0060">The computer system <b>600</b> may additionally include a computer-readable storage media reader <b>612</b>, a communications system <b>614</b> (e.g., a modem, a network card (wireless or wired), an infra-red communication device, etc.), and working memory <b>618</b>, which may include RAM and ROM devices as described above. In some embodiments, the computer system <b>600</b> may also include a processing acceleration unit <b>616</b>, which can include a digital signal processor DSP, a special-purpose processor, and/or the like.</p>
<p id="p-0062" num="0061">The computer-readable storage media reader <b>612</b> can further be connected to a computer-readable storage medium <b>610</b>, together (and, optionally, in combination with storage device(s) <b>608</b>) comprehensively representing remote, local, fixed, and/or removable storage devices plus storage media for temporarily and/or more permanently containing computer-readable information. The communications system <b>614</b> may permit data to be exchanged with the network and/or any other computer described above with respect to the system environment <b>500</b>.</p>
<p id="p-0063" num="0062">The computer system <b>600</b> may also comprise software elements, shown as being currently located within a working memory <b>618</b>, including an operating system <b>620</b> and/or other code <b>622</b>, such as an application program (which may be a client application, Web browser, mid-tier application, RDBMS, etc.). It should be appreciated that alternate embodiments of a computer system <b>600</b> may have numerous variations from that described above. For example, customized hardware might also be used and/or particular elements might be implemented in hardware, software (including portable software, such as applets), or both. Further, connection to other computing devices such as network input/output devices may be employed.</p>
<p id="p-0064" num="0063">Storage media and computer readable media for containing code, or portions of code, can include any appropriate media known or used in the art, including storage media and communication media, such as but not limited to volatile and non-volatile, removable and non-removable media implemented in any method or technology for storage and/or transmission of information such as computer readable instructions, data structures, program modules, or other data, including RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disk (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, data signals, data transmissions, or any other medium which can be used to store or transmit the desired information and which can be accessed by the computer. Based on the disclosure and teachings provided herein, a person of ordinary skill in the art will appreciate other ways and/or methods to implement the various embodiments.</p>
<p id="p-0065" num="0064">The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense. Many variations of the invention will become apparent to those skilled in the art upon review of the disclosure. The scope of the invention should, therefore, be determined not with reference to the above description, but instead should be determined with reference to the pending claims along with their full scope or equivalents.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A computer-implemented method for distributing security metadata, the method comprising:
<claim-text>receiving at a first service a request to perform a security-related function and to provide security metadata, the request being received from a process associated with a second service, the security metadata comprising a security token;</claim-text>
<claim-text>executing, by the first service, the security-related function on behalf of the second service, wherein the second service relies on the security metadata and results of execution of the security-related function by the first service to handle a user request to the second service;</claim-text>
<claim-text>generating, by the first service, an identifier and the security metadata for the second service based on executing the security-related function, the identifier and the security metadata being unique to the second service;</claim-text>
<claim-text>storing, by the first service, the identifier and the security metadata in a first memory accessible to the first service; and</claim-text>
<claim-text>transmitting, by the first service, the identifier and the security metadata to the process associated with the second service, the process being configured to store the identifier and the security metadata in a second memory, the second service being configured to access the security metadata stored in the second memory to encrypt a first communication and decrypt a second communication.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the security-related function is selected from a group consisting of: an authentication service, an authorization service, and a claims service.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the request for security metadata further includes a location of the second service, a name of the second service, an identity of a requesting user, and a password of the requesting user.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, further comprising:
<claim-text>authenticating the identity of the requesting user, the authenticating comprising verifying the identity and the password against a user database; and</claim-text>
<claim-text>determining whether a user role of the requesting user is authorized to submit the request.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first communication is a request to authenticate a potential user of the second service.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the second communication is a security token authenticating the potential user of the second service.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first service is configured to access the security metadata stored in the first memory to decrypt the first communication and encrypt the second communication.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first service is resident on a first server, wherein the process associated with the second service is resident on a second server, and wherein the process is configured to determine the location of the first service by querying a management service resident on a third server, the first service being registered with the management service.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the second service is resident on a first server, and wherein the second service is configured to access the security metadata stored in the second memory through a management service resident on a second server, the second memory comprising a data file stored in a location accessible to the second server.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the second memory includes a network address of the first service.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the second service and the second memory is resident on a first server,
<claim-text>wherein the second memory includes a reference to a data entry, the data entry being stored on a second server,</claim-text>
<claim-text>wherein the data entry includes a location of the first service, and</claim-text>
<claim-text>wherein the second service is configured to retrieve the reference in the second memory and access the corresponding data entry stored on the second server, thereby determining the location of the first service.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the steps of receiving a request for security metadata and transmitting the identifier and the security metadata are performed using a secure communications protocol.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the secure communications protocol is Secure Sockets Layer (SSL).</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the security metadata includes a symmetric cryptographic key.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the security metadata includes an asymmetric cryptographic key.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. A system for distributing security metadata, comprising:
<claim-text>a first data storage device operable to store a plurality of security metadata; and</claim-text>
<claim-text>a first server in communication with the first data storage device, the first server executing an instance of a first service, the first service configured to:
<claim-text>receive a request to perform a security-related function and to provide security metadata, the request being received from a process associated with a second service, the security metadata comprising a security token;</claim-text>
<claim-text>execute the security-related function on behalf of the second service, wherein the second service relies on the security metadata and results of execution of the security-related function by the first service to handle a user request to the second service;</claim-text>
<claim-text>generate an identifier and security metadata for the second service based on executing the security-related function, the identifier and the security metadata being unique to the second service;</claim-text>
<claim-text>store the identifier and the security metadata in the first data storage device; and</claim-text>
<claim-text>transmit the identifier and the security metadata to the process associated with the second service, the process being configured to store the identifier and the security metadata in memory, the second service being configured to access the security metadata stored in the memory to encrypt a first communication and decrypt a second communication.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The system of <claim-ref idref="CLM-00016">claim 16</claim-ref>, further comprising:
<claim-text>a second data storage device operable to store information about a plurality of services; and</claim-text>
<claim-text>a second server in communication with the second data storage device, the second server executing an instance of a management service, the management service configured to:</claim-text>
<claim-text>receive from the process associated with the second service a request for the location of the first service;</claim-text>
<claim-text>determine the location of the first service by accessing the second data storage device; the first service having been previously registered with the management service; and</claim-text>
<claim-text>transmit the location of the first service to the process.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. A non-transitory machine-readable medium for a computer system, the non-transitory machine-readable medium having stored thereon a series of instructions which, when executed by a processor, cause the processor to distribute security metadata by:
<claim-text>receiving at the computer system a request to perform a security-related function and to provide security metadata, the request being received from a process associated with an application service, the security metadata comprising a security token;</claim-text>
<claim-text>executing the security-related function on behalf of the second service, wherein the second service relies on the security metadata and results of execution of the security-related function by the first service to handle a user request to the second service;</claim-text>
<claim-text>generating an identifier and security metadata for the application service based on executing the security-related function, the identifier and the security metadata being unique to the application service;</claim-text>
<claim-text>storing the identifier and the security metadata in a first memory accessible to the computer system; and</claim-text>
<claim-text>transmitting the identifier and the security metadata to the process associated with the application service, the process being configured to store the identifier and the security metadata in a second memory, the second service being configured to access the security metadata stored in the second memory to encrypt a first communication and decrypt a second communication. </claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
