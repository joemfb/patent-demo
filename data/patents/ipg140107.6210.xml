<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627334-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627334</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13709305</doc-number>
<date>20121210</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<us-term-of-grant>
<disclaimer>
<text>This patent is subject to a terminal disclaimer.</text>
</disclaimer>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>3</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>44</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>46</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>13</main-group>
<subgroup>00</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>719312</main-classification>
<further-classification>719314</further-classification>
</classification-national>
<invention-title id="d2e51">Intranode data communications in a parallel computer</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>4893303</doc-number>
<kind>A</kind>
<name>Nakamura</name>
<date>19900100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6553002</doc-number>
<kind>B1</kind>
<name>Bremer et al.</name>
<date>20030400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6553031</doc-number>
<kind>B1</kind>
<name>Nakamura et al.</name>
<date>20030400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6601089</doc-number>
<kind>B1</kind>
<name>Sistare et al.</name>
<date>20030700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709213</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>6847991</doc-number>
<kind>B1</kind>
<name>Kurapati</name>
<date>20050100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>6993769</doc-number>
<kind>B2</kind>
<name>Simonson et al.</name>
<date>20060100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>7328300</doc-number>
<kind>B2</kind>
<name>Bennett</name>
<date>20080200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>7392352</doc-number>
<kind>B2</kind>
<name>Mithal et al.</name>
<date>20080600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>7552312</doc-number>
<kind>B2</kind>
<name>Archer et al.</name>
<date>20090600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>8286188</doc-number>
<kind>B1</kind>
<name>Brief</name>
<date>20121000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>719312</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2002/0054051</doc-number>
<kind>A1</kind>
<name>Ladd</name>
<date>20020500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2003/0093485</doc-number>
<kind>A1</kind>
<name>Dougall et al.</name>
<date>20030500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2003/0195991</doc-number>
<kind>A1</kind>
<name>Masel et al.</name>
<date>20031000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2005/0289235</doc-number>
<kind>A1</kind>
<name>Suematsu et al.</name>
<date>20051200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>2006/0059257</doc-number>
<kind>A1</kind>
<name>Collard et al.</name>
<date>20060300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>2009/0003344</doc-number>
<kind>A1</kind>
<name>Kumar</name>
<date>20090100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>2009/0006808</doc-number>
<kind>A1</kind>
<name>Blumrich et al.</name>
<date>20090100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00018">
<document-id>
<country>US</country>
<doc-number>2009/0022156</doc-number>
<kind>A1</kind>
<name>Blocksome</name>
<date>20090100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00019">
<document-id>
<country>US</country>
<doc-number>2009/0089670</doc-number>
<kind>A1</kind>
<name>Gooding et al.</name>
<date>20090400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00020">
<document-id>
<country>US</country>
<doc-number>2009/0129277</doc-number>
<kind>A1</kind>
<name>Supalov et al.</name>
<date>20090500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00021">
<document-id>
<country>US</country>
<doc-number>2009/0138892</doc-number>
<kind>A1</kind>
<name>Almasi et al.</name>
<date>20090500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00022">
<document-id>
<country>US</country>
<doc-number>2010/0058356</doc-number>
<kind>A1</kind>
<name>Aho et al.</name>
<date>20100300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00023">
<document-id>
<country>US</country>
<doc-number>2010/0232448</doc-number>
<kind>A1</kind>
<name>Sugumar et al.</name>
<date>20100900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00024">
<document-id>
<country>US</country>
<doc-number>2011/0314255</doc-number>
<kind>A1</kind>
<name>Krishna et al.</name>
<date>20111200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00025">
<document-id>
<country>US</country>
<doc-number>2012/0079035</doc-number>
<kind>A1</kind>
<name>Archer et al.</name>
<date>20120300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00026">
<document-id>
<country>US</country>
<doc-number>2012/0079133</doc-number>
<kind>A1</kind>
<name>Archer et al.</name>
<date>20120300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00027">
<document-id>
<country>US</country>
<doc-number>2012/0117137</doc-number>
<kind>A1</kind>
<name>Blocksome et al.</name>
<date>20120500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00028">
<document-id>
<country>US</country>
<doc-number>2012/0117138</doc-number>
<kind>A1</kind>
<name>Blocksome et al.</name>
<date>20120500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00029">
<document-id>
<country>US</country>
<doc-number>2012/0117211</doc-number>
<kind>A1</kind>
<name>Blocksome et al.</name>
<date>20120500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00030">
<document-id>
<country>US</country>
<doc-number>2012/0117281</doc-number>
<kind>A1</kind>
<name>Blocksome et al.</name>
<date>20120500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00031">
<document-id>
<country>US</country>
<doc-number>2012/0144400</doc-number>
<kind>A1</kind>
<name>Davis et al.</name>
<date>20120600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00032">
<document-id>
<country>US</country>
<doc-number>2012/0144401</doc-number>
<kind>A1</kind>
<name>Faraj</name>
<date>20120600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00033">
<document-id>
<country>US</country>
<doc-number>2012/0151485</doc-number>
<kind>A1</kind>
<name>Archer et al.</name>
<date>20120600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00034">
<document-id>
<country>US</country>
<doc-number>2012/0179736</doc-number>
<kind>A1</kind>
<name>Blocksome et al.</name>
<date>20120700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00035">
<document-id>
<country>US</country>
<doc-number>2012/0179760</doc-number>
<kind>A1</kind>
<name>Blocksome et al.</name>
<date>20120700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00036">
<document-id>
<country>US</country>
<doc-number>2012/0185679</doc-number>
<kind>A1</kind>
<name>Archer et al.</name>
<date>20120700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00037">
<document-id>
<country>US</country>
<doc-number>2012/0185873</doc-number>
<kind>A1</kind>
<name>Archer et al.</name>
<date>20120700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00038">
<document-id>
<country>US</country>
<doc-number>2012/0210094</doc-number>
<kind>A1</kind>
<name>Blocksome et al.</name>
<date>20120800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00039">
<document-id>
<country>US</country>
<doc-number>2012/0254344</doc-number>
<kind>A1</kind>
<name>Archer et al.</name>
<date>20121000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00040">
<othercit>Robinson et al., &#x201c;A Task Migration Implementation of the Message-Passing Interface&#x201d;, May 1996, IEEE, HPDC-5'96, pp. 61-68.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00041">
<othercit>Knudson, B., et al., &#x201c;IBM System Blue Gene Solution: Blue Gene/P Application Development,&#x201d; IBM Redbooks, Aug. 2009, pp. 1-406, Fourth Edition, International Technical Support Organization, Rochester, Minnesota.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00042">
<othercit>Blocksome, M., et al., &#x201c;Optimizing MPI Collectives using Efficient Intra-node Communication Techniques over the BlueGene/P Supercomputer,&#x201d; Computer Science IBM Research Report, Dec. 2010, pp. 1-25, IBM Systems and Technology Group, Rochester, Minnesota.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00043">
<othercit>Knudson, Brant; &#x201c;IBM System Blue Gene Solution: Blue Gene/P Application Development,&#x201d; <i>IBM Redbooks</i>, pp. 1-406, Sep. 2009.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00044">
<othercit>Blocksome, Michael; &#x201c;Optimizing MPI Collectives using Efficient Intra-node Communication Techniques over the BlueGene/P Supercomputer,&#x201d; <i>Computer Science IBM Research Report</i>, Dec. 2010.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00045">
<othercit>Foster et al., Managing Multiple Communication Method in High-Performance Networked Computing Systems. http://www.mcs.anl.gov/nexus, 1997, pp. 1-25.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00046">
<othercit>A Message Passing Interface for Parallel and Distributed Computing, Hairi et al., 1993, pp. 1-8.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00047">
<othercit>Introduction to Parallel Computing and the Message Passing Interface (MPI), Kuiper, 2008, pp. 1-39.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00048">
<othercit>Parallel net DCF A High-Performance Scientific I/O Interface, Li et al., 2003, pp. 1-11.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00049">
<othercit>HPSS MPI-IO: A Standard Parallel Interface to HPSS File System, Loewe, 2001, pp. 1-19.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00050">
<othercit>Notice of Allowance, U.S. Appl. No. 12/959,455, Mar. 1, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00051">
<othercit>Notice of Allowance, U.S. Appl. No. 12/959,539, Mar. 6, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00052">
<othercit>Office Action, U.S. Appl. No. 13/007,860, Mar. 19, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00053">
<othercit>Office Action, U.S. Appl. No. 12/963,671, Mar. 1, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00054">
<othercit>Office Action, U.S. Appl. No. 12/940,198, Feb. 14, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00055">
<othercit>Office Action, U.S. Appl. No. 12/940,282, Feb. 5, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00056">
<othercit>Notice of Allowance, U.S. Appl. No. 13/290,670, Mar. 27, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00057">
<othercit>Office Action, U.S. Appl. No. 13/668,503, Feb. 13, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00058">
<othercit>Office Action, U.S. Appl. No. 13/673,188, Mar. 5, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00059">
<othercit>Office Action, U.S. Appl. No. 13/678,799, Feb. 5, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00060">
<othercit>Office Action, U.S. Appl. No. 13/681,903, Apr. 2, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00061">
<othercit>Office Action, U.S. Appl. No. 13/709,305, Mar. 25, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00062">
<othercit>Office Action, U.S. Appl. No. 13/711,108, Mar. 22, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>5</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>719312</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>719314</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>14</number-of-drawing-sheets>
<number-of-figures>15</number-of-figures>
</figures>
<us-related-documents>
<continuation>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>13290670</doc-number>
<date>20111107</date>
</document-id>
<parent-grant-document>
<document-id>
<country>US</country>
<doc-number>8495654</doc-number>
</document-id>
</parent-grant-document>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>13709305</doc-number>
</document-id>
</child-doc>
</relation>
</continuation>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20130125135</doc-number>
<kind>A1</kind>
<date>20130516</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only" applicant-authority-category="assignee">
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Archer</last-name>
<first-name>Charles J.</first-name>
<address>
<city>Rochester</city>
<state>MN</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Blocksome</last-name>
<first-name>Michael A.</first-name>
<address>
<city>Rochester</city>
<state>MN</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Miller</last-name>
<first-name>Douglas R.</first-name>
<address>
<city>Rochester</city>
<state>MN</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="004" designation="us-only">
<addressbook>
<last-name>Ratterman</last-name>
<first-name>Joseph D.</first-name>
<address>
<city>Seattle</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="005" designation="us-only">
<addressbook>
<last-name>Smith</last-name>
<first-name>Brian E.</first-name>
<address>
<city>Knoxville</city>
<state>TN</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Biggers Kennedy Lenart Spraggins, LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Puente</last-name>
<first-name>Emerson</first-name>
<department>2196</department>
</primary-examiner>
<assistant-examiner>
<last-name>Verdi</last-name>
<first-name>Kimbleann</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Intranode data communications in a parallel computer that includes compute nodes configured to execute processes, where the data communications include: allocating, upon initialization of a first process of a compute node, a region of shared memory; establishing, by the first process, a predefined number of message buffers, each message buffer associated with a process to be initialized on the compute node; sending, to a second process on the same compute node, a data communications message without determining whether the second process has been initialized, including storing the data communications message in the message buffer of the second process; and upon initialization of the second process: retrieving, by the second process, a pointer to the second process's message buffer; and retrieving, by the second process from the second process's message buffer in dependence upon the pointer, the data communications message sent by the first process.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="229.11mm" wi="137.75mm" file="US08627334-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="239.69mm" wi="191.60mm" file="US08627334-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="239.01mm" wi="176.19mm" file="US08627334-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="226.82mm" wi="134.54mm" file="US08627334-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="221.74mm" wi="176.87mm" file="US08627334-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="171.53mm" wi="169.08mm" file="US08627334-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="196.09mm" wi="157.65mm" file="US08627334-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="257.30mm" wi="202.61mm" file="US08627334-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="239.01mm" wi="183.30mm" file="US08627334-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="234.53mm" wi="189.06mm" file="US08627334-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="240.28mm" wi="187.11mm" file="US08627334-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="239.69mm" wi="184.57mm" file="US08627334-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="244.18mm" wi="155.11mm" file="US08627334-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="239.01mm" wi="174.92mm" file="US08627334-20140107-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="245.45mm" wi="162.14mm" file="US08627334-20140107-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATION</heading>
<p id="p-0002" num="0001">This application is a continuation application of and claims priority from U.S. patent application Ser. No. 13/290,670, filed on Nov. 7, 2011.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?GOVINT description="Government Interest" end="lead"?>
<heading id="h-0002" level="1">STATEMENT REGARDING FEDERALLY SPONSORED RESEARCH OR DEVELOPMENT</heading>
<p id="p-0003" num="0002">This invention was made with Government support under Contract No. B554331 awarded by the Department of Energy. The Government has certain rights in this invention.</p>
<?GOVINT description="Government Interest" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0003" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0004" num="0003">1. Field of the Invention</p>
<p id="p-0005" num="0004">The field of the invention is data processing, or, more specifically, methods, apparatus, and products for intranode data communications in a parallel computer.</p>
<p id="p-0006" num="0005">2. Description of Related Art</p>
<p id="p-0007" num="0006">The development of the Electronic Discrete Variable Automatic Computer (&#x2018;EDVAC&#x2019;) computer system of 1948 is often cited as the beginning of the computer era. Since that time, computer systems have evolved into extremely complicated devices. Today's computers are much more sophisticated than early systems such as the EDVAC. Computer systems typically include a combination of hardware and software components, application programs, operating systems, processors, buses, memory, input/output devices, and so on. As advances in semiconductor processing and computer architecture push the performance of the computer higher and higher, more sophisticated computer software has evolved to take advantage of the higher performance of the hardware, resulting in computer systems today that are much more powerful than just a few years ago.</p>
<p id="p-0008" num="0007">Parallel computing is an area of computer technology that has experienced advances. Parallel computing is the simultaneous execution of the same application (split up and specially adapted) on multiple processors in order to obtain results faster. Parallel computing is based on the fact that the process of solving a problem usually can be divided into smaller jobs, which may be carried out simultaneously with some coordination.</p>
<p id="p-0009" num="0008">Parallel computers execute parallel algorithms. A parallel algorithm can be split up to be executed a piece at a time on many different processing devices, and then put back together again at the end to get a data processing result. Some algorithms are easy to divide up into pieces. Splitting up the job of checking all of the numbers from one to a hundred thousand to see which are primes could be done, for example, by assigning a subset of the numbers to each available processor, and then putting the list of positive results back together. In this specification, the multiple processing devices that execute the individual pieces of a parallel program are referred to as &#x2018;compute nodes.&#x2019; A parallel computer is composed of compute nodes and other processing nodes as well, including, for example, input/output (&#x2018;I/O&#x2019;) nodes, and service nodes.</p>
<p id="p-0010" num="0009">Parallel algorithms are valuable because it is faster to perform some kinds of large computing jobs via a parallel algorithm than it is via a serial (non-parallel) algorithm, because of the way modern processors work. It is far more difficult to construct a computer with a single fast processor than one with many slow processors with the same throughput. There are also certain theoretical limits to the potential speed of serial processors. On the other hand, every parallel algorithm has a serial part and so parallel algorithms have a saturation point. After that point adding more processors does not yield any more throughput but only increases the overhead and cost.</p>
<p id="p-0011" num="0010">Parallel algorithms are designed also to optimize one more resource the data communications requirements among the nodes of a parallel computer. There are two ways parallel processors communicate, shared memory or message passing. Shared memory processing needs additional locking for the data and imposes the overhead of additional processor and bus cycles and also serializes some portion of the algorithm.</p>
<p id="p-0012" num="0011">Message passing processing uses high-speed data communications networks and message buffers, but this communication adds transfer overhead on the data communications networks as well as additional memory need for message buffers and latency in the data communications among nodes. Designs of parallel computers use specially designed data communications links so that the communication overhead will be small but it is the parallel algorithm that decides the volume of the traffic.</p>
<p id="p-0013" num="0012">Many data communications network architectures are used for message passing among nodes in parallel computers. Compute nodes may be organized in a network as a &#x2018;torus&#x2019; or &#x2018;mesh,&#x2019; for example. Also, compute nodes may be organized in a network as a tree. A torus network connects the nodes in a three-dimensional mesh with wrap around links. Every node is connected to its six neighbors through this torus network, and each node is addressed by its x,y,z coordinate in the mesh. In a tree network, the nodes typically are connected into a binary tree: each node has a parent and two children (although some nodes may only have zero children or one child, depending on the hardware configuration). In computers that use a torus and a tree network, the two networks typically are implemented independently of one another, with separate routing circuits, separate physical links, and separate message buffers.</p>
<p id="p-0014" num="0013">A torus network lends itself to point to point operations, but a tree network typically is inefficient in point to point communication. A tree network, however, does provide high bandwidth and low latency for certain collective operations, message passing operations where all compute nodes participate simultaneously, such as, for example, an allgather.</p>
<heading id="h-0004" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0015" num="0014">Conventionally in distributed processing systems running parallel applications, all parallel processes must be initialized together. This requires that all processes are available from the very beginning&#x2014;at startup of the parallel application. As such, processes may not be initialized later to expand resources on demand. Further, in many parallel computers, a process must establish a data communications reception buffer upon initialization. Here, two problems are created. First, no other process may send data to an uninitialized process because no reception buffer exists. Second, an asynchronously initialized sending process has to check that a receiving process is initialized before sending data to the process. Such a check is expensive, in terms of time and execution cycles, and does not scale well.</p>
<p id="p-0016" num="0015">To that end, this specification includes methods, apparatus, and products for intranode data communications in a parallel computer. The parallel computer includes a number of compute nodes, with each compute node configured to execute a number of processes. Intranode data communications may be carried out in accordance with embodiments of the present invention by: upon initialization of a first process of a compute node, allocating, by the first process, a region of shared memory; establishing, by the first process within the allocated region of shared memory, a predefined number of message buffers, each message buffer associated with a process to be initialized on the compute node; sending, by the first process to a second process on the same compute node, a data communications message without determining whether the second process has been initialized, including storing the data communications message in the message buffer of the second process; upon initialization of the second process: retrieving, by the second process, a pointer to the second process's message buffer; and retrieving, by the second process from the second process's message buffer in dependence upon the pointer, the data communications message sent by the first process.</p>
<p id="p-0017" num="0016">This specification also sets forth methods, apparatus, and products for speculative intranode data communications in a parallel computer. The parallel computer includes a plurality of compute nodes, with each compute node configured to execute a plurality of processes. Speculative intranode data communications in the parallel computer includes: establishing, by a first process on a compute node, a message buffer for a potential second process on the compute node regardless of whether the potential second process has been initialized; and storing, by the first process, a data communications message in the message buffer for the potential second process regardless of whether the potential second process has been initialized.</p>
<p id="p-0018" num="0017">The foregoing and other objects, features and advantages of the invention will be apparent from the following more particular descriptions of exemplary embodiments of the invention as illustrated in the accompanying drawings wherein like reference numbers generally represent like parts of exemplary embodiments of the invention.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 1</figref> sets forth a block and network diagram of an example parallel computer that performs intranode data communications according to embodiments of the present invention.</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 2</figref> sets forth a block diagram of an example compute node for use in a parallel computer that performs intranode data communications according to embodiments of the present invention.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 3A</figref> illustrates an example of a Point To Point Adapter useful in parallel computers that perform intranode data communications according to embodiments of the present invention.</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 3B</figref> illustrates an example of a Collective Operations Adapter useful in a parallel computer that performs intranode data communications in a parallel computer according to embodiments of the present invention.</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 4</figref> sets forth a line drawing illustrating an example data communications network optimized for point-to-point operations useful in parallel computers that perform intranode data communications in a parallel computer according to embodiments of the present invention.</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 5</figref> illustrates an example data communications network optimized for collective operations by organizing compute nodes in a tree.</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 6</figref> sets forth a block diagram of an example protocol stack useful in parallel computers that perform intranode data communications according to embodiments of the present invention.</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 7</figref> sets forth a functional block diagram of an example PAMI for use in parallel computers that perform intranode data communications according to embodiments of the present invention.</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 8A</figref> sets forth a block diagram of example data communications resources useful in parallel computers that perform intranode data communications according to embodiments of the present invention.</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 8B</figref> sets forth a functional block diagram of an example DMA controller operatively coupled to a network&#x2014;in an architecture where this DMA controller is the only DMA controller on a compute node&#x2014;and an origin endpoint and its target endpoint are both located on the same compute node.</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 9</figref> sets forth a functional block diagram of an example PAMI useful in parallel computers that perform intranode data communications according to embodiments of the present invention in which the example PAMI operates, on behalf of an application, with multiple application messaging modules simultaneously.</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 10</figref> sets forth a functional block diagram of example endpoints useful in parallel computers that process perform intranode data communications in a parallel computer according to embodiments of the present invention.</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 11</figref> sets forth a flow chart illustrating an example method of intranode data communications in a parallel computer according to embodiments of the present invention.</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 12</figref> sets forth a flow chart illustrating a further example method of intranode data communications in a parallel computer according to embodiments of the present invention.</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 13</figref> sets forth a flow chart illustrating a further example method of intranode data communications in a parallel computer according to embodiments of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0006" level="1">DETAILED DESCRIPTION OF EXEMPLARY EMBODIMENTS</heading>
<p id="p-0034" num="0033">Example methods, computers, and computer program products for intranode data communications in a parallel computer according to embodiments of the present invention are described with reference to the accompanying drawings, beginning with <figref idref="DRAWINGS">FIG. 1</figref>. <figref idref="DRAWINGS">FIG. 1</figref> sets forth a block and network diagram of an example parallel computer (<b>100</b>) that carries out intranode data communications according to embodiments of the present invention. The parallel computer (<b>100</b>) in the example of <figref idref="DRAWINGS">FIG. 1</figref> is coupled to non-volatile memory for the computer in the form of data storage device (<b>118</b>), an output device for the computer in the form of printer (<b>120</b>), and an input/output device for the computer in the form of computer terminal (<b>122</b>).</p>
<p id="p-0035" num="0034">The parallel computer (<b>100</b>) in the example of <figref idref="DRAWINGS">FIG. 1</figref> includes a plurality of compute nodes (<b>102</b>). The compute nodes (<b>102</b>) are coupled for data communications by several independent data communications networks including a high speed Ethernet network (<b>174</b>), a Joint Test Action Group (&#x2018;JTAG&#x2019;) network (<b>104</b>), a tree network (<b>106</b>) which is optimized for collective operations, and a torus network (<b>108</b>) which is optimized point to point operations. Tree network (<b>106</b>) is a data communications network that includes data communications links connected to the compute nodes so as to organize the compute nodes as a tree. Each data communications network is implemented with data communications links among the compute nodes (<b>102</b>). The data communications links provide data communications for parallel operations among the compute nodes of the parallel computer.</p>
<p id="p-0036" num="0035">In addition, the compute nodes (<b>102</b>) of parallel computer (<b>100</b>) are organized into at least one operational group (<b>132</b>) of compute nodes for collective parallel operations on parallel computer (<b>100</b>). An operational group of compute nodes is the set of compute nodes upon which a collective parallel operation executes. Collective operations are implemented with data communications among the compute nodes of an operational group. Collective operations are those functions that involve all the compute nodes of an operational group. A collective operation is an operation, a message-passing computer program instruction that is executed simultaneously, that is, at approximately the same time, by all the compute nodes in an operational group of compute nodes. Such an operational group may include all the compute nodes in a parallel computer (<b>100</b>) or a subset all the compute nodes. Collective operations are often built around point to point operations. A collective operation requires that all processes on all compute nodes within an operational group call the same collective operation with matching arguments. A &#x2018;broadcast&#x2019; is an example of a collective operations for moving data among compute nodes of an operational group. A &#x2018;reduce&#x2019; operation is an example of a collective operation that executes arithmetic or logical functions on data distributed among the compute nodes of an operational group. An operational group may be implemented as, for example, an MPI &#x2018;communicator.&#x2019;</p>
<p id="p-0037" num="0036">&#x2018;MPI&#x2019; refers to &#x2018;Message Passing Interface,&#x2019; a prior art applications messaging module or parallel communications library, an application-level messaging module of computer program instructions for data communications on parallel computers. Such an application messaging module is disposed in an application messaging layer in a data communications protocol stack. Examples of prior-art parallel communications libraries that may be improved for use with parallel computers that perform intranode data communications according to embodiments of the present invention include IBM's MPI library, the &#x2018;Parallel Virtual Machine&#x2019; (&#x2018;PVM&#x2019;) library, MPICH, OpenMPI, and LAM/MPI. MPI is promulgated by the MPI Forum, an open group with representatives from many organizations that define and maintain the MPI standard. MPI at the time of this writing is a de facto standard for communication among compute nodes running a parallel program on a distributed memory parallel computer. This specification sometimes uses MPI terminology for ease of explanation, although the use of MPI as such is not a requirement or limitation of the present invention.</p>
<p id="p-0038" num="0037">Most collective operations are variations or combinations of four basic operations: broadcast, gather, scatter, and reduce. In a broadcast operation, all processes specify the same root process, whose buffer contents will be sent. Processes other than the root specify receive buffers. After the operation, all buffers contain the message from the root process.</p>
<p id="p-0039" num="0038">A scatter operation, like the broadcast operation, is also a one-to-many collective operation. All processes specify the same receive count. The send arguments are only significant to the root process, whose buffer actually contains sendcount*N elements of a given datatype, where N is the number of processes in the given group of compute nodes. The send buffer will be divided equally and dispersed from the root to all processes (including the root). Each process is assigned a sequential identifier termed a &#x2018;rank.&#x2019; After the operation, the root has sent sendcount data elements to each process in increasing rank order. Rank 0 (the root process) receives the first sendcount data elements from the send buffer. Rank 1 receives the second sendcount data elements from the send buffer, and so on.</p>
<p id="p-0040" num="0039">A gather operation is a many-to-one collective operation that is a complete reverse of the description of the scatter operation. That is, a gather is a many-to-one collective operation in which elements of a datatype are gathered from the ranked processes into a receive buffer of the root process.</p>
<p id="p-0041" num="0040">A reduce operation is also a many-to-one collective operation that includes an arithmetic or logical function performed on two data elements. All processes specify the same &#x2018;count&#x2019; and the same arithmetic or logical function. After the reduction, all processes have sent count data elements from computer node send buffers to the root process. In a reduction operation, data elements from corresponding send buffer locations are combined pair-wise by arithmetic or logical operations to yield a single corresponding element in the root process's receive buffer. Application specific reduction operations can be defined at runtime. Parallel communications libraries may support predefined operations. MPI, for example, provides the following pre-defined reduction operations:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0041">MPI_MAX maximum</li>
        <li id="ul0002-0002" num="0042">MPI_MIN minimum</li>
        <li id="ul0002-0003" num="0043">MPI_SUM sum</li>
        <li id="ul0002-0004" num="0044">MPI_PROD product</li>
        <li id="ul0002-0005" num="0045">MPI_LAND logical AND</li>
        <li id="ul0002-0006" num="0046">MPI_BAND bitwise AND</li>
        <li id="ul0002-0007" num="0047">MPI_LOR logical OR</li>
        <li id="ul0002-0008" num="0048">MPI_BOR bitwise OR</li>
        <li id="ul0002-0009" num="0049">MPI_LXOR logical exclusive OR</li>
        <li id="ul0002-0010" num="0050">MPI_BXOR bitwise exclusive OR</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0042" num="0051">In addition to compute nodes, the example parallel computer (<b>100</b>) includes input/output (&#x2018;I/O&#x2019;) nodes (<b>110</b>, <b>114</b>) coupled to compute nodes (<b>102</b>) through one of the data communications networks (<b>174</b>). The I/O nodes (<b>110</b>, <b>114</b>) provide I/O services between compute nodes (<b>102</b>) and I/O devices (<b>118</b>, <b>120</b>, <b>122</b>). I/O nodes (<b>110</b>, <b>114</b>) are connected for data communications I/O devices (<b>118</b>, <b>120</b>, <b>122</b>) through local area network (&#x2018;LAN&#x2019;) (<b>130</b>). Computer (<b>100</b>) also includes a service node (<b>116</b>) coupled to the compute nodes through one of the networks (<b>104</b>). Service node (<b>116</b>) provides service common to pluralities of compute nodes, loading programs into the compute nodes, starting program execution on the compute nodes, retrieving results of program operations on the computer nodes, and so on. Service node (<b>116</b>) runs a service application (<b>124</b>) and communicates with users (<b>128</b>) through a service application interface (<b>126</b>) that runs on computer terminal (<b>122</b>).</p>
<p id="p-0043" num="0052">As the term is used here, a parallel active messaging interface or &#x2018;PAMI&#x2019; (<b>218</b>) is a system-level messaging layer in a protocol stack of a parallel computer that is composed of data communications endpoints each of which is specified with data communications parameters for a thread of execution on a compute node of the parallel computer. The PAMI is a &#x2018;parallel&#x2019; interface in that many instances of the PAMI operate in parallel on the compute nodes of a parallel computer. The PAMI is an &#x2018;active messaging interface&#x2019; in that data communications messages in the PAMI are active messages, &#x2018;active&#x2019; in the sense that such messages implement callback functions to advise of message dispatch and instruction completion and so on, thereby reducing the quantity of acknowledgment traffic, and the like, burdening the data communication resources of the PAMI.</p>
<p id="p-0044" num="0053">Each data communications endpoint of a PAMI is implemented as a combination of a client, a context, and a task. A &#x2018;client&#x2019; as the term is used in PAMI operations is a collection of data communications resources dedicated to the exclusive use of an application-level data processing entity, an application or an application messaging module such as an MPI library. A &#x2018;context&#x2019; as the term is used in PAMI operations is composed of a subset of a client's collection of data processing resources, context functions, and a work queue of data transfer instructions to be performed by use of the subset through the context functions operated by an assigned thread of execution. In at least some embodiments, the context's subset of a client's data processing resources is dedicated to the exclusive use of the context. A &#x2018;task&#x2019; as the term is used in PAMI operations refers to a canonical entity, an integer or objection oriented programming object, that represents in a PAMI a process of execution of the parallel application. That is, a task is typically implemented as an identifier of a particular instance of an application executing on a compute node, a compute core on a compute node, or a thread of execution on a multi-threading compute core on a compute node. In the example of <figref idref="DRAWINGS">FIG. 1</figref>, the compute nodes (<b>102</b>), as well as PAMI endpoints on the compute nodes, are coupled for data communications through the PAMI (<b>218</b>) and through data communications resources such as collective network (<b>106</b>) and point-to-point network (<b>108</b>).</p>
<p id="p-0045" num="0054">Conventionally in distributed processing systems running parallel applications, all parallel processes must be initialized together. This requires that all processes are available from the very beginning&#x2014;at startup of the parallel application. As such, processes may not be initialized later to expand resources on demand. Further, in many parallel computers, a process must establish a data communications reception buffer upon initialization. Here, two problems are created. First, no other process may send data to an uninitialized process because no reception buffer exists. Second, an asynchronously initialized sending process has to check that a receiving process is initialized before sending data to the process. Such a check is expensive, in terms of time and execution cycles, and does not scale well.</p>
<p id="p-0046" num="0055">The example parallel computer (<b>100</b>) of <figref idref="DRAWINGS">FIG. 1</figref> is improved to carry out intranode data communications according to embodiments of the present invention. Each compute node (<b>102</b>) in the example of <figref idref="DRAWINGS">FIG. 1</figref> is configured to execute a plurality of processes. Such a process may be a process in PAMI (a PAMI endpoint, for example), a process representing an instance of an application, or other type of process.</p>
<p id="p-0047" num="0056">Upon initialization of a first process (<b>134</b>) of a compute node (<b>102</b>), the first process allocates a region of shared memory (<b>138</b>) and establishes, within the allocated region of shared memory (<b>138</b>), a predefined number of message buffers (<b>140</b>, <b>142</b>, <b>144</b>). In the example of <figref idref="DRAWINGS">FIG. 1</figref>, each message buffer (<b>140</b>, <b>142</b>, <b>144</b>) is associated with a process to be initialized on the compute node. Each message buffer may include a reception FIFO (first-in, first-out) buffer and an injection FIFO buffer for a process. The message buffers may be established without regard to whether the process associated which the message buffer has actually been initialized.</p>
<p id="p-0048" num="0057">The first process (<b>134</b>), after establishing the predefined number of message buffers, may send, to a second process on the same compute node (<b>102</b>), a data communications message without determining whether the second process has been initialized. The first process (<b>134</b>) may send a message to the second process (<b>136</b>) by storing the data communications message (<b>146</b>) in the message buffer (<b>140</b>) of the second process&#x2014;that is, the message buffer associated with the process. In this way, the first process may send data to a second process before (or after) that second process is initialized.</p>
<p id="p-0049" num="0058">Upon initialization of the second process, the second process (<b>136</b>) retrieves, by the second process, a pointer (<b>148</b>) to the second process's message buffer (<b>140</b>) and retrieves the data communications message (<b>146</b>) sent by the first process (<b>134</b>) by using the pointer to locate the second process's message buffer (<b>140</b>).</p>
<p id="p-0050" num="0059">The example parallel computer (<b>100</b>) of <figref idref="DRAWINGS">FIG. 1</figref> may also configured for speculative intranode data communications in accordance with embodiments of the present invention. In the example of <figref idref="DRAWINGS">FIG. 1</figref>, a first process (<b>134</b>) on a compute node (<b>102</b>) establishes a message buffer (<b>140</b>) for a potential second process (<b>136</b>) on the compute node (<b>102</b>) regardless of whether the potential second process has been initialized and stores a data communications message (<b>146</b>) in the message buffer (<b>140</b>) for the potential second process (<b>136</b>) regardless of whether the potential second process has been initialized. The phrase &#x2018;potential&#x2019; is used here to describe a process that may, or may not, be initialized at the present time or in the future. For example, a first process may send a data communications message to a &#x2018;potential&#x2019; process and, at the time of sending, the potential process may be in any one of several execution states: not initialized; in the process of initializing; and initialized and executing. Assuming the potential process has not been fully initialized at the time of sending the data communications message, the potential process may never completely initialize. In this way, the process is said to be a &#x2018;potential&#x2019; process.</p>
<p id="p-0051" num="0060">Given the &#x2018;potential&#x2019; nature of processes, the system of <figref idref="DRAWINGS">FIG. 1</figref> may be configured to ensure delivery of the data communications messages. To ensure completed delivery of data communications in such a system, the first process may be configured to periodically poll, for a predefined amount of time, the second process's message buffer to determine whether the data communications message has been retrieved by the second process. If the data communications message has not been retrieved during the predefined amount of time, the first process may flush the second process's message buffer (overwriting the data communications message) and send the data communications message to another process. Readers of skill in the art will recognize, that polling the second process's message buffer for a predefined amount of time is but one way, among many possible ways, to ensure delivery of a data communications message to an uninitialized process. In another example, processes may be configured to send acknowledgments of receipt of data communications message. In such an example, a first process may be configured to send the data communications message to a second process, wait for acknowledgement from the second process for a predefined amount of time, and send the data communications message to another process if the first process does not receive an acknowledgement from the second process after the predefined amount of time.</p>
<p id="p-0052" num="0061">The arrangement of compute nodes, networks, and I/O devices making up the example parallel computer illustrated in <figref idref="DRAWINGS">FIG. 1</figref> are for explanation only, not for limitation of the present invention. Parallel computers capable of intranode data communications according to embodiments of the present invention may include additional nodes, networks, devices, and architectures, not shown in <figref idref="DRAWINGS">FIG. 1</figref>, as will occur to those of skill in the art. For ease of explanation, the parallel computer in the example of <figref idref="DRAWINGS">FIG. 1</figref> is illustrated with only four processors (<b>614</b>, <b>624</b>) in a compute node. Readers will recognize that compute nodes in parallel computers that perform intranode data communications according to embodiments of the present invention can include any number of processors as may occur to those of skill in the art; each compute node in IBM's BlueGene/Q supercomputer, for example, includes 16 application processors and a management processor. The parallel computer (<b>100</b>) in the example of <figref idref="DRAWINGS">FIG. 1</figref> includes sixteen compute nodes (<b>102</b>); parallel computers that perform intranode data communications according to some embodiments of the present invention include thousands of compute nodes. In addition to Ethernet and JTAG, networks in such data processing systems may support many data communications protocols including for example TCP (Transmission Control Protocol), IP (Internet Protocol), and others as will occur to those of skill in the art. Various embodiments of the present invention may be implemented on a variety of hardware platforms in addition to those illustrated in <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0053" num="0062">Intranode data communications in a parallel computer according to embodiments of the present invention is generally implemented on a parallel computer that includes a plurality of compute nodes. In fact, such computers may include thousands of such compute nodes, with a compute node typically executing at least one instance of a parallel application. Each compute node is in turn itself a computer composed of one or more computer processors, its own computer memory, and its own input/output (&#x2018;I/O&#x2019;) adapters. For further explanation, therefore, <figref idref="DRAWINGS">FIG. 2</figref> sets forth a block diagram of an example compute node (<b>152</b>) for use in a parallel computer that perform intranode data communications according to embodiments of the present invention. The compute node (<b>152</b>) of <figref idref="DRAWINGS">FIG. 2</figref> includes one or more computer processors (<b>164</b>) as well as random access memory (&#x2018;RAM&#x2019;) (<b>156</b>). Each processor (<b>164</b>) can support multiple hardware compute cores (<b>165</b>), and each such core can in turn support multiple threads of execution, hardware threads of execution as well as software threads. Each processor (<b>164</b>) is connected to RAM (<b>156</b>) through a high-speed front side bus (<b>161</b>), bus adapter (<b>194</b>), and a high-speed memory bus (<b>154</b>)&#x2014;and through bus adapter (<b>194</b>) and an extension bus (<b>168</b>) to other components of the compute node. Stored in RAM (<b>156</b>) is an application program (<b>158</b>), a module of computer program instructions that carries out parallel, user-level data processing using parallel algorithms.</p>
<p id="p-0054" num="0063">Also stored RAM (<b>156</b>) is an application messaging module (<b>216</b>), a library of computer program instructions that carry out application-level parallel communications among compute nodes, including point to point operations as well as collective operations. Although the application program can call PAMI routines directly, the application program (<b>158</b>) often executes point-to-point data communications operations by calling software routines in the application messaging module (<b>216</b>), which in turn is improved according to embodiments of the present invention to use PAMI functions to implement such communications. An application messaging module can be developed from scratch to use a PAMI according to embodiments of the present invention, using a traditional programming language such as the C programming language or C++, for example, and using traditional programming methods to write parallel communications routines that send and receive data among PAMI endpoints and compute nodes through data communications networks or shared-memory transfers. In this approach, the application messaging module (<b>216</b>) exposes a traditional interface, such as MPI, to the application program (<b>158</b>) so that the application program can gain the benefits of a PAMI with no need to recode the application. As an alternative to coding from scratch, therefore, existing prior art application messaging modules may be improved to use the PAMI, existing modules that already implement a traditional interface. Examples of prior-art application messaging modules that can be improved to implement intranode data communications in a parallel computer according to embodiments of the present invention include such parallel communications libraries as the traditional &#x2018;Message Passing Interface&#x2019; (&#x2018;MPI&#x2019;) library, the &#x2018;Parallel Virtual Machine&#x2019; (&#x2018;PVM&#x2019;) library, MPICH, and the like.</p>
<p id="p-0055" num="0064">Also represented in RAM in the example of <figref idref="DRAWINGS">FIG. 2</figref> is a PAMI (<b>218</b>). Readers will recognize, however, that the representation of the PAMI in RAM is a convention for ease of explanation rather than a limitation of the present invention, because the PAMI and its components, endpoints, clients, contexts, and so on, have particular associations with and inclusions of hardware data communications resources. In fact, the PAMI can be implemented partly as software or firmware and hardware&#x2014;or even, at least in some embodiments, entirely in hardware.</p>
<p id="p-0056" num="0065">Also represented in RAM (<b>156</b>) in the example of <figref idref="DRAWINGS">FIG. 2</figref> is a segment (<b>227</b>) of shared memory. In typical operation, the operating system (<b>162</b>) in this example compute node assigns portions of address space to each processor (<b>164</b>), and, to the extent that the processors include multiple compute cores (<b>165</b>), treats each compute core as a separate processor with its own assignment of a portion of core memory or RAM (<b>156</b>) for a separate heap, stack, memory variable storage, and so on. The default architecture for such apportionment of memory space is that each processor or compute core operates its assigned portion of memory separately, with no ability to access memory assigned to another processor or compute core. Upon request, however, the operating system grants to one processor or compute core the ability to access a segment of memory that is assigned to another processor or compute core, and such a segment is referred to in this specification as a &#x2018;segment of shared memory.&#x2019;</p>
<p id="p-0057" num="0066">In the example of <figref idref="DRAWINGS">FIG. 2</figref>, each processor or compute core has uniform access to the RAM (<b>156</b>) on the compute node, so that accessing a segment of shared memory is equally fast regardless where the shared segment is located in physical memory. In some embodiments, however, modules of physical memory are dedicated to particular processors, so that a processor may access local memory quickly and remote memory more slowly, a configuration referred to as a Non-Uniform Memory Access or &#x2018;NUMA.&#x2019; In such embodiments, a segment of shared memory can be configured locally for one endpoint and remotely for another endpoint&#x2014;or remotely from both endpoints of a communication. From the perspective of an origin endpoint transmitting data through a segment of shared memory that is configured remotely with respect to the origin endpoint, transmitting data through the segment of shared memory will appear slower that if the segment of shared memory were configured locally with respect to the origin endpoint&#x2014;or if the segment were local to both the origin endpoint and the target endpoint. This is the effect of the architecture represented by the compute node (<b>152</b>) in the example of <figref idref="DRAWINGS">FIG. 2</figref> with all processors and all compute cores coupled through the same bus to the RAM&#x2014;that all accesses to segments of memory shared among processes or processors on the compute node are local&#x2014;and therefore very fast.</p>
<p id="p-0058" num="0067">The example PAMI (<b>218</b>) of the compute node (<b>152</b>) of <figref idref="DRAWINGS">FIG. 2</figref> is also configured to for intranode data communications in accordance with embodiments of the present invention. The PAMI (<b>218</b>) may execute a plurality of processes (<b>134</b>, <b>136</b>)&#x2014;implementations of endpoints in this example. Upon initialization of a first process (<b>134</b>) of the compute node (<b>152</b>), the first process allocates a region of shared memory (<b>227</b>), establishes, within the allocated region of shared memory (<b>227</b>), a predefined number of message buffers (<b>140</b>, <b>142</b>, <b>144</b>), where each message buffer is associated with a process (<b>134</b>, <b>136</b>) to be initialized on the compute node (<b>152</b>). The first process (<b>134</b>) may then send, to a second process (<b>136</b>) on the same compute node (<b>152</b>), a data communications message without determining whether the second process has been initialized. The first process (<b>134</b>) may send the data communications message (<b>146</b>) to the second process (<b>136</b>)&#x2014;whether the second process has been initialized or not&#x2014;by storing the data communications message (<b>146</b>) in the message buffer (<b>140</b>) of the second process. Upon initialization of the second process, the second process (<b>136</b>) is configured to retrieve a pointer (<b>148</b>) to the second process's message buffer and retrieve, from the second process's message buffer (<b>140</b>) in dependence upon the pointer (<b>148</b>), the data communications message (<b>146</b>) sent by the first process (<b>134</b>).</p>
<p id="p-0059" num="0068">Also stored in RAM (<b>156</b>) in the example compute node of <figref idref="DRAWINGS">FIG. 2</figref> is an operating system (<b>162</b>), a module of computer program instructions and routines for an application program's access to other resources of the compute node. It is possible, in some embodiments at least, for an application program, an application messaging module, and a PAMI in a compute node of a parallel computer to run threads of execution with no user login and no security issues because each such thread is entitled to complete access to all resources of the node. The quantity and complexity of duties to be performed by an operating system on a compute node in a parallel computer therefore can be somewhat smaller and less complex than those of an operating system on a serial computer with many threads running simultaneously with various level of authorization for access to resources. In addition, there is no video I/O on the compute node (<b>152</b>) of <figref idref="DRAWINGS">FIG. 2</figref>, another factor that decreases the demands on the operating system. The operating system may therefore be quite lightweight by comparison with operating systems of general purpose computers, a pared down or &#x2018;lightweight&#x2019; version as it were, or an operating system developed specifically for operations on a particular parallel computer. Operating systems that may be improved or simplified for use in a compute node according to embodiments of the present invention include UNIX&#x2122;, Linux&#x2122;, Microsoft XP&#x2122;, AIX&#x2122;, IBM's i5/OS&#x2122;, and others as will occur to those of skill in the art.</p>
<p id="p-0060" num="0069">The example compute node (<b>152</b>) of <figref idref="DRAWINGS">FIG. 2</figref> includes several communications adapters (<b>172</b>, <b>176</b>, <b>180</b>, <b>188</b>) for implementing data communications with other nodes of a parallel computer. Such data communications may be carried out serially through RS-232 connections, through external buses such as USB, through data communications networks such as IP networks, and in other ways as will occur to those of skill in the art. Communications adapters implement the hardware level of data communications through which one computer sends data communications to another computer, directly or through a network. Examples of communications adapters for use in computers that implement intranode data communications according to embodiments of the present invention include modems for wired communications, Ethernet (IEEE 802.3) adapters for wired network communications, and 802.11b adapters for wireless network communications.</p>
<p id="p-0061" num="0070">The data communications adapters in the example of <figref idref="DRAWINGS">FIG. 2</figref> include a Gigabit Ethernet adapter (<b>172</b>) that couples example compute node (<b>152</b>) for data communications to a Gigabit Ethernet (<b>174</b>). Gigabit Ethernet is a network transmission standard, defined in the IEEE 802.3 standard, that provides a data rate of 1 billion bits per second (one gigabit). Gigabit Ethernet is a variant of Ethernet that operates over multimode fiber optic cable, single mode fiber optic cable, or unshielded twisted pair.</p>
<p id="p-0062" num="0071">The data communications adapters in the example of <figref idref="DRAWINGS">FIG. 2</figref> includes a JTAG Slave circuit (<b>176</b>) that couples example compute node (<b>152</b>) for data communications to a JTAG Master circuit (<b>178</b>). JTAG is the usual name for the IEEE 1149.1 standard entitled Standard Test Access Port and Boundary-Scan Architecture for test access ports used for testing printed circuit boards using boundary scan. JTAG is so widely adapted that, at this time, boundary scan is more or less synonymous with JTAG. JTAG is used not only for printed circuit boards, but also for conducting boundary scans of integrated circuits, and is also used as a mechanism for debugging embedded systems. The example compute node of <figref idref="DRAWINGS">FIG. 2</figref> may be all three of these: It typically includes one or more integrated circuits installed on a printed circuit board and may be implemented as an embedded system having its own processor, its own memory, and its own I/O capability. JTAG boundary scans through JTAG Slave (<b>176</b>) may efficiently configure processor registers and memory in compute node (<b>152</b>) for use in intranode data communications according to embodiments of the present invention.</p>
<p id="p-0063" num="0072">The data communications adapters in the example of <figref idref="DRAWINGS">FIG. 2</figref> includes a Point To Point Adapter (<b>180</b>) that couples example compute node (<b>152</b>) for data communications to a data communications network (<b>108</b>) that is optimal for point to point message passing operations such as, for example, a network configured as a three-dimensional torus or mesh. Point To Point Adapter (<b>180</b>) provides data communications in six directions on three communications axes, x, y, and z, through six bidirectional links: +x (<b>181</b>), &#x2212;x (<b>182</b>), +y (<b>183</b>), &#x2212;y (<b>184</b>), +z (<b>185</b>), and &#x2212;z (<b>186</b>). For ease of explanation, the Point To Point Adapter (<b>180</b>) of <figref idref="DRAWINGS">FIG. 2</figref> as illustrated is configured for data communications in three dimensions, x, y, and z, but readers will recognize that Point To Point Adapters optimized for point-to-point operations in intranode data communications in a parallel computer according to embodiments of the present invention may in fact be implemented so as to support communications in two dimensions, four dimensions, five dimensions, and so on.</p>
<p id="p-0064" num="0073">The data communications adapters in the example of <figref idref="DRAWINGS">FIG. 2</figref> includes a Collective Operations Adapter (<b>188</b>) that couples example compute node (<b>152</b>) for data communications to a network (<b>106</b>) that is optimal for collective message passing operations such as, for example, a network configured as a binary tree. Collective Operations Adapter (<b>188</b>) provides data communications through three bidirectional links: two to children nodes (<b>190</b>) and one to a parent node (<b>192</b>).</p>
<p id="p-0065" num="0074">The example compute node (<b>152</b>) includes a number of arithmetic logic units (&#x2018;ALUs&#x2019;). ALUs (<b>166</b>) are components of processors (<b>164</b>), and a separate ALU (<b>170</b>) is dedicated to the exclusive use of collective operations adapter (<b>188</b>) for use in performing the arithmetic and logical functions of reduction operations. Computer program instructions of a reduction routine in an application messaging module (<b>216</b>) or a PAMI (<b>218</b>) may latch an instruction for an arithmetic or logical function into instruction register (<b>169</b>). When the arithmetic or logical function of a reduction operation is a &#x2018;sum&#x2019; or a &#x2018;logical OR,&#x2019; for example, collective operations adapter (<b>188</b>) may execute the arithmetic or logical operation by use of an ALU (<b>166</b>) in a processor (<b>164</b>) or, typically much faster, by use of the dedicated ALU (<b>170</b>).</p>
<p id="p-0066" num="0075">The example compute node (<b>152</b>) of <figref idref="DRAWINGS">FIG. 2</figref> includes a direct memory access (&#x2018;DMA&#x2019;) controller (<b>225</b>), a module of automated computing machinery that implements, through communications with other DMA engines on other compute nodes, or on a same compute node, direct memory access to and from memory on its own compute node as well as memory on other compute nodes. Direct memory access is a way of reading and writing to and from memory of compute nodes with reduced operational burden on computer processors (<b>164</b>); a CPU initiates a DMA transfer, but the CPU does not execute the DMA transfer. A DMA transfer essentially copies a block of memory from one compute node to another, or between RAM segments of applications on the same compute node, from an origin to a target for a PUT operation, from a target to an origin for a GET operation.</p>
<p id="p-0067" num="0076">For further explanation, <figref idref="DRAWINGS">FIG. 3A</figref> illustrates an example of a Point To Point Adapter (<b>180</b>) useful in parallel computers that perform intranode data communications according to embodiments of the present invention. Point To Point Adapter (<b>180</b>) is designed for use in a data communications network optimized for point to point operations, a network that organizes compute nodes in a three-dimensional torus or mesh. Point To Point Adapter (<b>180</b>) in the example of <figref idref="DRAWINGS">FIG. 3A</figref> provides data communication along an x-axis through four unidirectional data communications links, to and from the next node in the &#x2212;x direction (<b>182</b>) and to and from the next node in the +x direction (<b>181</b>). Point To Point Adapter (<b>180</b>) also provides data communication along a y-axis through four unidirectional data communications links, to and from the next node in the &#x2212;y direction (<b>184</b>) and to and from the next node in the +y direction (<b>183</b>). Point To Point Adapter (<b>180</b>) in also provides data communication along a z-axis through four unidirectional data communications links, to and from the next node in the &#x2212;z direction (<b>186</b>) and to and from the next node in the +z direction (<b>185</b>). For ease of explanation, the Point To Point Adapter (<b>180</b>) of <figref idref="DRAWINGS">FIG. 3A</figref> as illustrated is configured for data communications in only three dimensions, x, y, and z, but readers will recognize that Point To Point Adapters optimized for point-to-point operations in a parallel computer that performs intranode data communications according to embodiments of the present invention may in fact be implemented so as to support communications in two dimensions, four dimensions, five dimensions, and so on. Several supercomputers now use five dimensional mesh or torus networks, including, for example, IBM's Blue Gene Q&#x2122;.</p>
<p id="p-0068" num="0077">For further explanation, <figref idref="DRAWINGS">FIG. 3B</figref> illustrates an example of a Collective Operations Adapter (<b>188</b>) useful in a parallel computer that performs intranode data communications according to embodiments of the present invention. Collective Operations Adapter (<b>188</b>) is designed for use in a network optimized for collective operations, a network that organizes compute nodes of a parallel computer in a binary tree. Collective Operations Adapter (<b>188</b>) in the example of <figref idref="DRAWINGS">FIG. 3B</figref> provides data communication to and from two children nodes through four unidirectional data communications links (<b>190</b>). Collective Operations Adapter (<b>188</b>) also provides data communication to and from a parent node through two unidirectional data communications links (<b>192</b>).</p>
<p id="p-0069" num="0078">For further explanation, <figref idref="DRAWINGS">FIG. 4</figref> sets forth a line drawing illustrating an example data communications network (<b>108</b>) optimized for point-to-point operations useful in parallel computers that perform intranode data communications according to embodiments of the present invention. In the example of <figref idref="DRAWINGS">FIG. 4</figref>, dots represent compute nodes (<b>102</b>) of a parallel computer, and the dotted lines between the dots represent data communications links (<b>103</b>) between compute nodes. The data communications links are implemented with point-to-point data communications adapters similar to the one illustrated for example in <figref idref="DRAWINGS">FIG. 3A</figref>, with data communications links on three axis, x, y, and z, and to and fro in six directions +x (<b>181</b>), &#x2212;x (<b>182</b>), +y (<b>183</b>), &#x2212;y (<b>184</b>), +z (<b>185</b>), and &#x2212;z (<b>186</b>). The links and compute nodes are organized by this data communications network optimized for point-to-point operations into a three dimensional mesh (<b>105</b>). The mesh (<b>105</b>) has wrap-around links on each axis that connect the outermost compute nodes in the mesh (<b>105</b>) on opposite sides of the mesh (<b>105</b>). These wrap-around links form a torus (<b>107</b>). Each compute node in the torus has a location in the torus that is uniquely specified by a set of x, y, z coordinates. Readers will note that the wrap-around links in the y and z directions have been omitted for clarity, but are configured in a similar manner to the wrap-around link illustrated in the x direction. For clarity of explanation, the data communications network of <figref idref="DRAWINGS">FIG. 4</figref> is illustrated with only 27 compute nodes, but readers will recognize that a data communications network optimized for point-to-point operations in a parallel computer that performs intranode data communications according to embodiments of the present invention may contain only a few compute nodes or may contain thousands of compute nodes. For ease of explanation, the data communications network of <figref idref="DRAWINGS">FIG. 4</figref> is illustrated with only three dimensions: x, y, and z, but readers will recognize that a data communications network optimized for point-to-point operations may in fact be implemented in two dimensions, four dimensions, five dimensions, and so on. As mentioned, several supercomputers now use five dimensional mesh or torus networks, including IBM's Blue Gene Q&#x2122;.</p>
<p id="p-0070" num="0079">For further explanation, <figref idref="DRAWINGS">FIG. 5</figref> illustrates an example data communications network (<b>106</b>) optimized for collective operations by organizing compute nodes in a tree. The example data communications network of <figref idref="DRAWINGS">FIG. 5</figref> includes data communications links connected to the compute nodes so as to organize the compute nodes as a tree. In the example of <figref idref="DRAWINGS">FIG. 5</figref>, dots represent compute nodes (<b>102</b>) of a parallel computer, and the dotted lines (<b>103</b>) between the dots represent data communications links between compute nodes. The data communications links are implemented with collective operations data communications adapters similar to the one illustrated for example in <figref idref="DRAWINGS">FIG. 3B</figref>, with each node typically providing data communications to and from two children nodes and data communications to and from a parent node, with some exceptions. Nodes in a binary tree may be characterized as a root node (<b>202</b>), branch nodes (<b>204</b>), and leaf nodes (<b>206</b>). The root node (<b>202</b>) has two children but no parent. The leaf nodes (<b>206</b>) each has a parent, but leaf nodes have no children. The branch nodes (<b>204</b>) each has both a parent and two children. The links and compute nodes are thereby organized by this data communications network optimized for collective operations into a binary tree (<b>106</b>). For clarity of explanation, the data communications network of <figref idref="DRAWINGS">FIG. 5</figref> is illustrated with only 31 compute nodes, but readers will recognize that a data communications network optimized for collective operations for use in parallel computers that perform intranode data communications according to embodiments of the present invention may contain only a few compute nodes or hundreds or thousands of compute nodes.</p>
<p id="p-0071" num="0080">In the example of <figref idref="DRAWINGS">FIG. 5</figref>, each node in the tree is assigned a unit identifier referred to as a &#x2018;rank&#x2019; (<b>196</b>). The rank actually identifies an instance of a parallel application that is executing on a compute node. That is, the rank is an application-level identifier. Using the rank to identify a node assumes that only one such instance of an application is executing on each node. A compute node can, however, support multiple processors, each of which can support multiple processing cores&#x2014;so that more than one process or instance of an application can easily be present under execution on any given compute node&#x2014;or in all the compute nodes, for that matter. To the extent that more than one instance of an application executes on a single compute node, the rank identifies the instance of the application as such rather than the compute node. A rank uniquely identifies an application's location in the tree network for use in both point-to-point and collective operations in the tree network. The ranks in this example are assigned as integers beginning with &#x2018;0&#x2019; assigned to the root instance or root node (<b>202</b>), &#x2018;1&#x2019; assigned to the first node in the second layer of the tree, &#x2018;2&#x2019; assigned to the second node in the second layer of the tree, &#x2018;3&#x2019; assigned to the first node in the third layer of the tree, &#x2018;4&#x2019; assigned to the second node in the third layer of the tree, and so on. For ease of illustration, only the ranks of the first three layers of the tree are shown here, but all compute nodes, or rather all application instances, in the tree network are assigned a unique rank. Such rank values can also be assigned as identifiers of application instances as organized in a mesh or torus network.</p>
<p id="p-0072" num="0081">For further explanation, <figref idref="DRAWINGS">FIG. 6</figref> sets forth a block diagram of an example protocol stack useful in parallel computers that perform intranode data communications according to embodiments of the present invention. The example protocol stack of <figref idref="DRAWINGS">FIG. 6</figref> includes a hardware layer (<b>214</b>), a system messaging layer (<b>212</b>), an application messaging layer (<b>210</b>), and an application layer (<b>208</b>). For ease of explanation, the protocol layers in the example stack of <figref idref="DRAWINGS">FIG. 6</figref> are shown connecting an origin compute node (<b>222</b>) and a target compute node (<b>224</b>), although it is worthwhile to point out that in embodiments that effect DMA data transfers, the origin compute node and the target compute node can be the same compute node. The granularity of connection through the system messaging layer (<b>212</b>), which is implemented with a PAMI (<b>218</b>), is finer than merely compute node to compute node&#x2014;because, again, communications among endpoints often is communications among endpoints on the same compute node. For further explanation, recall that the PAMI (<b>218</b>) connects endpoints, connections specified by combinations of clients, contexts, and tasks, each such combination being specific to a thread of execution on a compute node, with each compute node capable of supporting many threads and therefore many endpoints. Every endpoint typically can function as both an origin endpoint or a target endpoint for data transfers through a PAMI, and both the origin endpoint and its target endpoint can be located on the same compute node. So an origin compute node (<b>222</b>) and its target compute node (<b>224</b>) can in fact, and often will, be the same compute node.</p>
<p id="p-0073" num="0082">The application layer (<b>208</b>) provides communications among instances of a parallel application (<b>158</b>) running on the compute nodes (<b>222</b>, <b>224</b>) by invoking functions in an application messaging module (<b>216</b>) installed on each compute node. Communications among instances of the application through messages passed between the instances of the application. Applications may communicate messages invoking function of an application programming interface (&#x2018;API&#x2019;) exposed by the application messaging module (<b>216</b>). In this approach, the application messaging module (<b>216</b>) exposes a traditional interface, such as an API of an MPI library, to the application program (<b>158</b>) so that the application program can gain the benefits of a PAMI, reduced network traffic, callback functions, and so on, with no need to recode the application. Alternatively, if the parallel application is programmed to use PAMI functions, the application can call the PAMI functions directly, without going through the application messaging module.</p>
<p id="p-0074" num="0083">The example protocol stack of <figref idref="DRAWINGS">FIG. 6</figref> includes a system messaging layer (<b>212</b>) implemented here as a PAMI (<b>218</b>). The PAMI provides system-level data communications functions that support messaging in the application layer (<b>208</b>) and the application messaging layer (<b>210</b>). Such system-level functions are typically invoked through an API exposed to the application messaging modules (<b>216</b>) in the application messaging layer (<b>210</b>). Although developers can in fact access a PAMI API directly by coding an application to do so, a PAMI's system-level functions in the system messaging layer (<b>212</b>) in many embodiments are isolated from the application layer (<b>208</b>) by the application messaging layer (<b>210</b>), making the application layer somewhat independent of system specific details. With an application messaging module presenting a standard MPI API to an application, for example, with the application messaging module retooled to use the PAMI to carry out the low-level messaging functions, the application gains the benefits of a PAMI with no need to incur the expense of reprogramming the application to call the PAMI directly. Because, however, some applications will in fact be reprogrammed to call the PAMI directly, all entities in the protocol stack above the PAMI are viewed by PAMI as applications. When PAMI functions are invoked by entities above the PAMI in the stack, the PAMI makes no distinction whether the caller is in the application layer or the application messaging layer, no distinction whether the caller is an application as such or an MPI library function invoked by an application. As far as the PAMI is concerned, any caller of a PAMI function is an application.</p>
<p id="p-0075" num="0084">The protocol stack of <figref idref="DRAWINGS">FIG. 6</figref> includes a hardware layer (<b>214</b>) that defines the physical implementation and the electrical implementation of aspects of the hardware on the compute nodes such as the bus, network cabling, connector types, physical data rates, data transmission encoding and many other factors for communications between the compute nodes (<b>222</b>) on the physical network medium. In parallel computers that perform intranode data communications according to embodiments of the present invention, the hardware layer includes data communications resources (<b>220</b>) such as DMA controllers and network links, including routers, packet switches, and the like.</p>
<p id="p-0076" num="0085">For further explanation, <figref idref="DRAWINGS">FIG. 7</figref> sets forth a functional block diagram of an example PAMI (<b>218</b>) for use in parallel computers that perform intranode data communications according to embodiments of the present invention. The PAMI (<b>218</b>) provides an active messaging layer that supports both point to point communications in a mesh or torus as well as collective operations, gathers, reductions, barriers, and the like in tree networks, for example. The PAMI is a multithreaded parallel communications engine designed to provide low level message passing functions, many of which are one-sided, and abstract such functions for higher level messaging middleware, referred to in this specification as &#x2018;application messaging modules&#x2019; in an application messaging layer. In the example of <figref idref="DRAWINGS">FIG. 7</figref>, the application messaging layer is represented by a generic MPI module (<b>258</b>) for receiving MPI calls (<b>256</b>) to MPI functions (<b>260</b>) in the MPI module (<b>258</b>), appropriate for ease of explanation because some form of MPI is a de facto standard for such messaging middleware. Compute nodes and communications endpoints of a parallel computer (<b>102</b> on <figref idref="DRAWINGS">FIG. 1</figref>) are coupled for data communications through such a PAMI and through data communications resources (<b>294</b>, <b>296</b>, <b>314</b>) that include DMA controllers, network adapters, and data communications networks through which controllers and adapters deliver data communications. The PAMI (<b>218</b>) provides data communications among data communications endpoints, where each endpoint is specified by data communications parameters for a thread of execution on a compute node, including specifications of a client, a context, and a task.</p>
<p id="p-0077" num="0086">The PAMI (<b>218</b>) in this example includes PAMI clients (<b>302</b>, <b>304</b>), tasks (<b>286</b>, <b>298</b>), contexts (<b>290</b>, <b>292</b>, <b>310</b>, <b>312</b>), and endpoints (<b>288</b>, <b>300</b>). A PAMI client is a collection of data communications resources (<b>294</b>, <b>295</b>, <b>314</b>) dedicated to the exclusive use of an application-level data processing entity, an application or an application messaging module such as an MPI library. Data communications resources assigned in collections to PAMI clients are explained in more detail below with reference to <figref idref="DRAWINGS">FIGS. 8A and 8B</figref>. PAMI clients (<b>203</b>, <b>304</b> on <figref idref="DRAWINGS">FIG. 7</figref>) enable higher level middleware, application messaging modules, MPI libraries, and the like, to be developed independently so that each can be used concurrently by an application. Although the application messaging layer in <figref idref="DRAWINGS">FIG. 7</figref> is represented for example by a single generic MPI module (<b>258</b>), in fact, a PAMI, operating multiple clients, can support multiple message passing libraries or application messaging modules simultaneously, a fact that is explained in more detail with reference to <figref idref="DRAWINGS">FIG. 9</figref>. <figref idref="DRAWINGS">FIG. 9</figref> sets forth a functional block diagram of an example PAMI (<b>218</b>) useful in parallel computers that perform intranode data communications according to embodiments of the present invention in which the example PAMI operates, on behalf of an application (<b>158</b>), with multiple application messaging modules (<b>502</b>-<b>510</b>) simultaneously. The application (<b>158</b>) can have multiple messages in transit simultaneously through each of the application messaging modules (<b>502</b>-<b>510</b>). Each context (<b>512</b>-<b>520</b>) carries out, through post and advance functions, data communications for the application on data communications resources in the exclusive possession, in each client, of that context. Each context carries out data communications operations independently and in parallel with other contexts in the same or other clients. In the example <figref idref="DRAWINGS">FIG. 9</figref>, each client (<b>532</b>-<b>540</b>) includes a collection of data communications resources (<b>522</b>-<b>530</b>) dedicated to the exclusive use of an application-level data processing entity, one of the application messaging modules (<b>502</b>-<b>510</b>):
<ul id="ul0003" list-style="none">
    <li id="ul0003-0001" num="0000">
    <ul id="ul0004" list-style="none">
        <li id="ul0004-0001" num="0087">IBM MPI Library (<b>502</b>) operates through context (<b>512</b>) data communications resources (<b>522</b>) dedicated to the use of PAMI client (<b>532</b>),</li>
        <li id="ul0004-0002" num="0088">MPICH Library (<b>504</b>) operates through context (<b>514</b>) data communications resources (<b>524</b>) dedicated to the use of PAMI client (<b>534</b>),</li>
        <li id="ul0004-0003" num="0089">Unified Parallel C (&#x2018;UPC&#x2019;) Library (<b>506</b>) operates through context (<b>516</b>) data communications resources (<b>526</b>) dedicated to the use of PAMI client (<b>536</b>),</li>
        <li id="ul0004-0004" num="0090">Partitioned Global Access Space (&#x2018;PGAS&#x2019;) Runtime Library (<b>508</b>) operates through context (<b>518</b>) data communications resources (<b>528</b>) dedicated to the use of PAMI client (<b>538</b>), and</li>
        <li id="ul0004-0005" num="0091">Aggregate Remote Memory Copy Interface (&#x2018;ARMCI&#x2019;) Library (<b>510</b>) operates through context (<b>520</b>) data communications resources (<b>530</b>) dedicated to the use of PAMI client (<b>540</b>).</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0078" num="0092">Again referring to the example of <figref idref="DRAWINGS">FIG. 7</figref>: The PAMI (<b>218</b>) includes tasks, listed in task lists (<b>286</b>, <b>298</b>) and identified (<b>250</b>) to the application (<b>158</b>). A &#x2018;task&#x2019; as the term is used in PAMI operations is a platform-defined integer datatype that identifies a canonical application process, an instance of a parallel application (<b>158</b>). Very carefully in this specification, the term &#x2018;task&#x2019; is always used to refer only to this PAMI structure, not the traditional use of the computer term &#x2018;task&#x2019; to refer to a process or thread of execution. In this specification, the term &#x2018;process&#x2019; refers to a canonical data processing process, a container for threads in a multithreading environment. In particular in the example of <figref idref="DRAWINGS">FIG. 7</figref>, the application (<b>158</b>) is implemented as a canonical process with multiple threads (<b>251</b>-<b>254</b>) assigned various duties by a leading thread (<b>251</b>) which itself executes an instance of a parallel application program. Each instance of a parallel application is assigned a task; each task so assigned can be an integer value, for example, in a C environment, or a separate task object in a C++ or Java environment. The tasks are components of communications endpoints, but are not themselves communications endpoints; tasks are not addressed directly for data communications in PAMI. This gives a finer grained control than was available in prior message passing art. Each client has its own list (<b>286</b>, <b>298</b>) of tasks for which its contexts provide services; this allows each process to potentially reside simultaneously in two or more different communications domains as will be the case in certain advanced computers using, for example, one type of processor and network in one domain and a completely different processor type and network in another domain, all in the same computer.</p>
<p id="p-0079" num="0093">The PAMI (<b>218</b>) includes contexts (<b>290</b>, <b>292</b>, <b>310</b>, <b>312</b>). A &#x2018;context&#x2019; as the term is used in PAMI operations is composed of a subset of a client's collection of data processing resources, context functions, and a work queue of data transfer instructions to be performed by use of the subset through the context functions operated by an assigned thread of execution. That is, a context represents a partition of the local data communications resources assigned to a PAMI client. Every context within a client has equivalent functionality and semantics. Context functions implement contexts as threading points that applications use to optimize concurrent communications. Communications initiated by a local process, an instance of a parallel application, uses a context object to identify the specific threading point that will be used to issue a particular communication independent of communications occurring in other contexts. In the example of <figref idref="DRAWINGS">FIG. 7</figref>, where the application (<b>158</b>) and the application messaging module (<b>258</b>) are both implemented as canonical processes with multiple threads of execution, each has assigned or mapped particular threads (<b>253</b>, <b>254</b>, <b>262</b>, <b>264</b>) to advance (<b>268</b>, <b>270</b>, <b>276</b>, <b>278</b>) work on the contexts (<b>290</b>, <b>292</b>, <b>310</b>, <b>312</b>), including execution of local callbacks (<b>272</b>, <b>280</b>). In particular, the local event callback functions (<b>272</b>, <b>280</b>) associated with any particular communication are invoked by the thread advancing the context that was used to initiate the communication operation in the first place. Like PAMI tasks, contexts are not used to directly address a communication destination or target, as they are a local resource.</p>
<p id="p-0080" num="0094">Context functions, explained here with regard to references (<b>472</b>-<b>482</b>) on <figref idref="DRAWINGS">FIG. 9</figref>, include functions to create (<b>472</b>) and destroy (<b>474</b>) contexts, functions to lock (<b>476</b>) and unlock (<b>478</b>) access to a context, and functions to post (<b>480</b>) and advance (<b>480</b>) work in a context. For ease of explanation, the context functions (<b>472</b>-<b>482</b>) are illustrated in only one expanded context (<b>512</b>); readers will understand, however, that all PAMI contexts have similar context functions. The create (<b>472</b>) and destroy (<b>474</b>) functions are, in an object-oriented sense, constructors and destructors. In the example embodiments described in this specifications, post (<b>480</b>) and advance (<b>482</b>) functions on a context are critical sections, not thread safe. Applications using such non-reentrant functions must somehow ensure that critical sections are protected from re-entrant use. Applications can use mutual exclusion locks to protect critical sections. The lock (<b>476</b>) and unlock (<b>478</b>) functions in the example of <figref idref="DRAWINGS">FIG. 9</figref> provide and operate such a mutual exclusion lock to protect the critical sections in the post (<b>480</b>) and advance (<b>482</b>) functions. If only a single thread posts or advances work on a context, then that thread need never lock that context. To the extent that progress is driven independently on a context by a single thread of execution, then no mutual exclusion locking of the context itself is required&#x2014;provided that no other thread ever attempts to call a function on such a context. If more than one thread will post or advance work on a context, each such thread must secure a lock before calling a post or an advance function on that context. This is one reason why it is probably a preferred architecture, given sufficient resources, to assign one thread to operate each context. Progress can be driven with advance (<b>482</b>) functions concurrently among multiple contexts by using multiple threads, as desired by an application&#x2014;shown in the example of <figref idref="DRAWINGS">FIG. 7</figref> by threads (<b>253</b>, <b>254</b>, <b>262</b>, <b>264</b>) which advance work concurrently, independently and in parallel, on contexts (<b>290</b>, <b>292</b>, <b>310</b>, <b>312</b>).</p>
<p id="p-0081" num="0095">Posts and advances (<b>480</b>, <b>482</b> on <figref idref="DRAWINGS">FIG. 9</figref>) are functions called on a context, either in a C-type function with a context ID as a parameter, or in object oriented practice where the calling entity possesses a reference to a context or a context object as such and the posts and advances are member methods of a context object. Again referring to <figref idref="DRAWINGS">FIG. 7</figref>: Application-level entities, application programs (<b>158</b>) and application messaging modules (<b>258</b>), post (<b>266</b>, <b>274</b>) data communications instructions, including SENDs, RECEIVEs, PUTs, GETs, and so on, to the work queues (<b>282</b>, <b>284</b>, <b>306</b>, <b>308</b>) in contexts and then call advance functions (<b>268</b>, <b>270</b>, <b>276</b>, <b>278</b>) on the contexts to progress specific data processing and data communications that carry out the instructions. The data processing and data communications effected by the advance functions include specific messages, request to send (&#x2018;RTS&#x2019;) messages, acknowledgments, callback execution, transfers of transfer data or payload data, and so on. Advance functions therefore operate generally by checking a work queue for any new instructions that need to be initiated and checking data communications resources for any incoming message traffic that needs to be administered as well as increases in storage space available for outgoing message traffic, with callbacks and the like. Advance functions also carry out or trigger transfers of transfer data or payload data.</p>
<p id="p-0082" num="0096">In at least some embodiments, a context's subset of a client's data processing resources is dedicated to the exclusive use of the context. In the example of <figref idref="DRAWINGS">FIG. 7</figref>, context (<b>290</b>) has a subset (<b>294</b>) of a client's (<b>302</b>) data processing resources dedicated to the exclusive use of the context (<b>290</b>), and context (<b>292</b>) has a subset (<b>296</b>) of a client's (<b>302</b>) data processing resources dedicated to the exclusive use of the context (<b>292</b>). Advance functions (<b>268</b>, <b>270</b>) called on contexts (<b>290</b>, <b>292</b>) therefore never need to secure a lock on a data communications resource before progressing work on a context&#x2014;because each context (<b>290</b>, <b>292</b>) has exclusive use of dedicated data communications resources. Usage of data communications resources in this example PAMI (<b>218</b>), however, is not thread-safe. When data communications resources are shared among contexts, mutual exclusion locks are needed. In contrast to the exclusive usage of resources by contexts (<b>290</b>, <b>292</b>), contexts (<b>310</b>, <b>312</b>) share access to their client's data communications resource (<b>314</b>) and therefore do not have data communications resources dedicated to exclusive use of a single context. Contexts (<b>310</b>, <b>312</b>) therefore always must secure a mutual exclusion lock on a data communications resource before using the resource to send or receive administrative messages or transfer data.</p>
<p id="p-0083" num="0097">For further explanation, here is an example pseudocode Hello World program for an application using a PAMI:</p>
<p id="p-0084" num="0098">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="14pt" align="left"/>
<colspec colname="2" colwidth="203pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>&#x2003;</entry>
<entry>int main(int argc, char ** argv)</entry>
</row>
<row>
<entry/>
<entry>{ </entry>
</row>
<row>
<entry/>
<entry>&#x2003;PAMI_client_t client;</entry>
</row>
<row>
<entry/>
<entry>&#x2003;PAMI_context_t context;</entry>
</row>
<row>
<entry/>
<entry>&#x2003;PAMI_result_t status = PAMI_ERROR;</entry>
</row>
<row>
<entry/>
<entry>&#x2003;const char *name = &#x2033;PAMI&#x2033;;</entry>
</row>
<row>
<entry/>
<entry>&#x2003;status = PAMI_Client_initialize(name, &#x26;client);</entry>
</row>
<row>
<entry/>
<entry>&#x2003;size_t _n = 1;</entry>
</row>
<row>
<entry/>
<entry>&#x2003;status = PAMI_Context_createv(client, NULL, 0, &#x26;context, _n);</entry>
</row>
<row>
<entry/>
<entry>&#x2003;PAMI_configuration_t configuration;</entry>
</row>
<row>
<entry/>
<entry>&#x2003;configuration.name = PAMI_TASK_ID;</entry>
</row>
<row>
<entry/>
<entry>&#x2003;status = PAMI_Configuration_query(client, &#x26;configuration);</entry>
</row>
<row>
<entry/>
<entry>&#x2003;size_t task_id = configuration.value.intval;</entry>
</row>
<row>
<entry/>
<entry>&#x2003;configuration.name = PAMI_NUM_TASKS;</entry>
</row>
<row>
<entry/>
<entry>&#x2003;status = PAMI_Configuration_query(client, &#x26;configuration);</entry>
</row>
<row>
<entry/>
<entry>&#x2003;size_t num_tasks = configuration.value.intval;</entry>
</row>
<row>
<entry/>
<entry>&#x2003;fprintf (stderr, &#x2033;Hello process %d of %d\n&#x2033;, task_id, num_tasks);</entry>
</row>
<row>
<entry/>
<entry>&#x2003;status = PAMI_Context_destroy(context);</entry>
</row>
<row>
<entry/>
<entry>&#x2003;status = PAMI_Client_finalize(client);</entry>
</row>
<row>
<entry/>
<entry>&#x2003;return 0;</entry>
</row>
<row>
<entry/>
<entry>}</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0085" num="0099">This short program is termed &#x2018;pseudocode&#x2019; because it is an explanation in the form of computer code, not a working model, not an actual program for execution. In this pseudocode example, an application initializes a client and a context for an application named &#x201c;PAMI.&#x201d; PAMI_Client_initialize and PAMI_Context_createv are initialization functions (<b>316</b>) exposed to applications as part of a PAMI's API. These functions, in dependence upon the application name &#x201c;PAMI,&#x201d; pull from a PAMI configuration (<b>318</b>) the information needed to establish a client and a context for the application. The application uses this segment:</p>
<p id="p-0086" num="0100">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21pt" align="left"/>
<colspec colname="2" colwidth="196pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>&#x2003;</entry>
<entry>PAMI_configuration_t configuration;</entry>
</row>
<row>
<entry/>
<entry>configuration.name = PAMI_TASK_ID;</entry>
</row>
<row>
<entry/>
<entry>status = PAMI_Configuration_query(client, &#x26;configuration);</entry>
</row>
<row>
<entry/>
<entry>size_t task_id = configuration.value.intval;</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
to retrieve its task ID and this segment:
</p>
<p id="p-0087" num="0101">
<tables id="TABLE-US-00003" num="00003">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="21pt" align="left"/>
<colspec colname="2" colwidth="196pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>&#x2003;</entry>
<entry>configuration.name = PAMI_NUM_TASKS;</entry>
</row>
<row>
<entry/>
<entry>status = PAMI_Configuration_query(client, &#x26;configuration);</entry>
</row>
<row>
<entry/>
<entry>size_t num_tasks = configuration.value.intval;</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
to retrieve the number of tasks presently configured to carry out parallel communications and process data communications event in the PAMI. The applications prints &#x201c;Hello process task_id of num_tasks,&#x201d; where task_id is the task ID of the subject instance of a parallel application, and num_tasks is the number of instances of the application executing in parallel on compute nodes. Finally, the application destroys the context and terminates the client.
</p>
<p id="p-0088" num="0102">For further explanation of data communications resources assigned in collections to PAMI clients, <figref idref="DRAWINGS">FIG. 8A</figref> sets forth a block diagram of example data communications resources (<b>220</b>) useful in parallel computers that perform intranode data communications according to embodiments of the present invention. The data communications resources of <figref idref="DRAWINGS">FIG. 8A</figref> include a gigabit Ethernet adapter (<b>238</b>), an Infiniband adapter (<b>240</b>), a Fibre Channel adapter (<b>242</b>), a PCI Express adapter (<b>246</b>), a collective operations network configured as a tree (<b>106</b>), shared memory (<b>227</b>), DMA controllers (<b>225</b>, <b>226</b>), and a network (<b>108</b>) configured as a point-to-point torus or mesh like the network described above with reference to <figref idref="DRAWINGS">FIG. 4</figref>. A PAMI is configured with clients, each of which is in turn configured with certain collections of such data communications resources&#x2014;so that, for example, the PAMI client (<b>302</b>) in the PAMI (<b>218</b>) in the example of <figref idref="DRAWINGS">FIG. 7</figref> can have dedicated to its use a collection of data communications resources composed of six segments (<b>227</b>) of shared memory, six Gigabit Ethernet adapters (<b>238</b>), and six Infiniband adapters (<b>240</b>). And the PAMI client (<b>304</b>) can have dedicated to its use six Fibre Channel adapters (<b>242</b>), a DMA controller (<b>225</b>), a torus network (<b>108</b>), and five segments (<b>227</b>) of shared memory. And so on.</p>
<p id="p-0089" num="0103">The DMA controllers (<b>225</b>, <b>226</b>) in the example of <figref idref="DRAWINGS">FIG. 8A</figref> each is configured with DMA control logic in the form of a DMA engine (<b>228</b>, <b>229</b>), an injection FIFO buffer (<b>230</b>), and a receive FIFO buffer (<b>232</b>). The DMA engines (<b>228</b>, <b>229</b>) can be implemented as hardware components, logic networks of a DMA controller, in firmware, as software operating an embedded controller, as various combinations of software, firmware, or hardware, and so on. Each DMA engine (<b>228</b>, <b>229</b>) operates on behalf of endpoints to send and receive DMA transfer data through the network (<b>108</b>). The DMA engines (<b>228</b>, <b>229</b>) operate the injection buffers (<b>230</b>, <b>232</b>) by processing first-in-first-out descriptors (<b>234</b>, <b>236</b>) in the buffers, hence the designation &#x2018;injection FIFO&#x2019; and &#x2018;receive FIFO.&#x2019;</p>
<p id="p-0090" num="0104">For further explanation, here is an example use case, a description of the overall operation of an example PUT DMA transfer using the DMA controllers (<b>225</b>, <b>226</b>) and network (<b>108</b>) in the example of <figref idref="DRAWINGS">FIG. 8A</figref>: An originating application (<b>158</b>), which is typically one instance of a parallel application running on a compute node, places a quantity of transfer data (<b>494</b>) at a location in its RAM (<b>155</b>). The application (<b>158</b>) then calls a post function (<b>480</b>) on a context (<b>512</b>) of an origin endpoint (<b>352</b>), posting a PUT instruction (<b>390</b>) into a work queue (<b>282</b>) of the context (<b>512</b>); the PUT instruction (<b>390</b>) specifies a target endpoint (<b>354</b>) to which the transfer data is to be sent as well as source and destination memory locations. The application then calls an advance function (<b>482</b>) on the context (<b>512</b>). The advance function (<b>482</b>) finds the new PUT instruction in its work queue (<b>282</b>) and inserts a data descriptor (<b>234</b>) into the injection FIFO of the origin DMA controller (<b>225</b>); the data descriptor includes the source and destination memory locations and the specification of the target endpoint. The origin DMA engine (<b>225</b>) then transfers the data descriptor (<b>234</b>) as well as the transfer data (<b>494</b>) through the network (<b>108</b>) to the DMA controller (<b>226</b>) on the target side of the transaction. The target DMA engine (<b>229</b>), upon receiving the data descriptor and the transfer data, places the transfer data (<b>494</b>) into the RAM (<b>156</b>) of the target application at the location specified in the data descriptor and inserts into the target DMA controller's receive FIFO (<b>232</b>) a data descriptor (<b>236</b>) that specifies the target endpoint and the location of the transfer data (<b>494</b>) in RAM (<b>156</b>). The target application (<b>159</b>) or application instance calls an advance function (<b>481</b>) on a context (<b>513</b>) of the target endpoint (<b>354</b>). The advance function (<b>481</b>) checks the communications resources assigned to its context (<b>513</b>) for incoming messages, including checking the receive FIFO (<b>232</b>) of the target DMA controller (<b>226</b>) for data descriptors that specify the target endpoint (<b>354</b>). The advance function (<b>481</b>) finds the data descriptor for the PUT transfer and advises the target application (<b>159</b>) that its transfer data has arrived. A GET-type DMA transfer works in a similar manner, with some differences, including, of course, the fact that transfer data flows in the opposite direction. Similarly, typical SEND transfers also operate similarly, some with rendezvous protocols, some with eager protocols, with data transmitted in packets over the a network through non-DMA network adapters or through DMA controllers.</p>
<p id="p-0091" num="0105">The example of <figref idref="DRAWINGS">FIG. 8A</figref> includes two DMA controllers (<b>225</b>, <b>226</b>). DMA transfers between endpoints on separate compute nodes use two DMA controllers, one on each compute node. Compute nodes can be implemented with multiple DMA controllers so that many or even all DMA transfers even among endpoints on a same compute node can be carried out using two DMA engines. In some embodiments at least, however, a compute node, like the example compute node (<b>152</b>) of <figref idref="DRAWINGS">FIG. 2</figref>, has only one DMA engine, so that that DMA engine can be use to conduct both sides of transfers between endpoints on that compute node. For further explanation of this fact, <figref idref="DRAWINGS">FIG. 8B</figref> sets forth a functional block diagram of an example DMA controller (<b>225</b>) operatively coupled to a network (<b>108</b>)&#x2014;in an architecture where this DMA controller (<b>225</b>) is the only DMA controller on a compute node&#x2014;and an origin endpoint (<b>352</b>) and its target endpoint (<b>354</b>) are both located on the same compute node (<b>152</b>). In the example of <figref idref="DRAWINGS">FIG. 8B</figref>, a single DMA engine (<b>228</b>) operates with two threads of execution (<b>502</b>, <b>504</b>) on behalf of endpoints (<b>352</b>, <b>354</b>) on a same compute node to send and receive DMA transfer data through a segment (<b>227</b>) of shared memory. A transmit thread (<b>502</b>) injects transfer data into the network (<b>108</b>) as specified in data descriptors (<b>234</b>) in an injection FIFO buffer (<b>230</b>), and a receive thread (<b>502</b>) receives transfer data from the network (<b>108</b>) as specified in data descriptors (<b>236</b>) in a receive FIFO buffer (<b>232</b>).</p>
<p id="p-0092" num="0106">The overall operation of an example PUT DMA transfer with the DMA controllers (<b>225</b>) and the network (<b>108</b>) in the example of <figref idref="DRAWINGS">FIG. 8B</figref> is: An originating application (<b>158</b>), that is actually one of multiple instances (<b>158</b>, <b>159</b>) of a parallel application running on a compute node (<b>152</b>) in separate threads of execution, places a quantity of transfer data (<b>494</b>) at a location in its RAM (<b>155</b>). The application (<b>158</b>) then calls a post function (<b>480</b>) on a context (<b>512</b>) of an origin endpoint (<b>352</b>), posting a PUT instruction (<b>390</b>) into a work queue (<b>282</b>) of the context (<b>512</b>); the PUT instruction specifies a target endpoint (<b>354</b>) to which the transfer data is to be sent as well as source and destination memory locations. The application (<b>158</b>) then calls an advance function (<b>482</b>) on the context (<b>512</b>). The advance function (<b>482</b>) finds the new PUT instruction (<b>390</b>) in its work queue (<b>282</b>) and inserts a data descriptor (<b>234</b>) into the injection FIFO of the DMA controller (<b>225</b>); the data descriptor includes the source and destination memory locations and the specification of the target endpoint. The DMA engine (<b>225</b>) then transfers by its transmit and receive threads (<b>502</b>, <b>504</b>) through the network (<b>108</b>) the data descriptor (<b>234</b>) as well as the transfer data (<b>494</b>). The DMA engine (<b>228</b>), upon receiving by its receive thread (<b>504</b>) the data descriptor and the transfer data, places the transfer data (<b>494</b>) into the RAM (<b>156</b>) of the target application and inserts into the DMA controller's receive FIFO (<b>232</b>) a data descriptor (<b>236</b>) that specifies the target endpoint and the location of the transfer data (<b>494</b>) in RAM (<b>156</b>). The target application (<b>159</b>) calls an advance function (<b>481</b>) on a context (<b>513</b>) of the target endpoint (<b>354</b>). The advance function (<b>481</b>) checks the communications resources assigned to its context for incoming messages, including checking the receive FIFO (<b>232</b>) of the DMA controller (<b>225</b>) for data descriptors that specify the target endpoint (<b>354</b>). The advance function (<b>481</b>) finds the data descriptor for the PUT transfer and advises the target application (<b>159</b>) that its transfer data has arrived. Again, a GET-type DMA transfer works in a similar manner, with some differences, including, of course, the fact that transfer data flows in the opposite direction. And typical SEND transfers also operate similarly, some with rendezvous protocols, some with eager protocols, with data transmitted in packets over the a network through non-DMA network adapters or through DMA controllers.</p>
<p id="p-0093" num="0107">By use of an architecture like that illustrated and described with reference to <figref idref="DRAWINGS">FIG. 8B</figref>, a parallel application or an application messaging module that is already programmed to use DMA transfers can gain the benefit of the speed of DMA data transfers among endpoints on the same compute node with no need to reprogram the applications or the application messaging modules to use the network in other modes. In this way, an application or an application messaging module, already programmed for DMA, can use the same DMA calls through a same API for DMA regardless whether subject endpoints are on the same compute node or on separate compute nodes.</p>
<p id="p-0094" num="0108">For further explanation, <figref idref="DRAWINGS">FIG. 10</figref> sets forth a functional block diagram of example endpoints useful in parallel computers that perform intranode data communications according to embodiments of the present invention. In the example of <figref idref="DRAWINGS">FIG. 10</figref>, a PAMI (<b>218</b>) is implemented with instances on two separate compute nodes (<b>152</b>, <b>153</b>) that include four endpoints (<b>338</b>, <b>340</b>, <b>342</b>, <b>344</b>). These endpoints are opaque objects used to address an origin or destination in a process and are constructed from a (client, task, context) tuple. Non-DMA SEND and RECEIVE instructions as well as DMA instructions such as PUT and GET address a destination by use of an endpoint object or endpoint identifier.</p>
<p id="p-0095" num="0109">Each endpoint (<b>338</b>, <b>340</b>, <b>342</b>, <b>344</b>) in the example of <figref idref="DRAWINGS">FIG. 10</figref> is composed of a client (<b>302</b>, <b>303</b>, <b>304</b>, <b>305</b>), a task (<b>332</b>, <b>333</b>, <b>334</b>, <b>336</b>), and a context (<b>290</b>, <b>292</b>, <b>310</b>, <b>312</b>). Using a client a component in the specification of an endpoint disambiguates the task and context identifiers, as these identifiers may be the same for multiple clients. A task is used as a component in the specification of an endpoint to construct an endpoint to address a process accessible through a context. A context in the specification of an endpoint identifies, refers to, or represents the specific context associated with a destination or target task&#x2014;because the context identifies a specific threading point on a task. A context offset identifies which threading point is to process a particular communications operation. Endpoints enable &#x201c;crosstalk&#x201d; which is the act of issuing communication on a local context with a particular context offset that is directed to a destination endpoint with no correspondence to a source context or source context offset.</p>
<p id="p-0096" num="0110">For efficient utilization of storage in an environment where multiple tasks of a client reside on the same physical compute node, an application may choose to write an endpoint table (<b>288</b>, <b>300</b> on <figref idref="DRAWINGS">FIG. 7</figref>) in a segment of shared memory (<b>227</b>, <b>346</b>, <b>348</b>). It is the responsibility of the application to allocate such segments of shared memory and coordinate the initialization and access of any data structures shared between processes. This includes any endpoint objects which are created by one process or instance of an application and read by another process.</p>
<p id="p-0097" num="0111">Endpoints (<b>342</b>, <b>344</b>) on compute node (<b>153</b>) serve respectively two application instances (<b>157</b>, <b>159</b>). The tasks (<b>334</b>, <b>336</b>) in endpoints (<b>342</b>, <b>344</b>) are different. The task (<b>334</b>) in endpoint (<b>342</b>) is identified by the task ID (<b>249</b>) of application (<b>157</b>), and the task (<b>336</b>) in endpoint (<b>344</b>) is identified by the task ID (<b>257</b>) of application (<b>159</b>). The clients (<b>304</b>, <b>305</b>) in endpoints (<b>342</b>, <b>344</b>) are different, separate clients. Client (<b>304</b>) in endpoint (<b>342</b>) associates data communications resources (e.g., <b>294</b>, <b>296</b>, <b>314</b> on <figref idref="DRAWINGS">FIG. 7</figref>) dedicated exclusively to the use of application (<b>157</b>), while client (<b>305</b>) in endpoint (<b>344</b>) associates data communications resources dedicated exclusively to the use of application (<b>159</b>). Contexts (<b>310</b>, <b>312</b>) in endpoints (<b>342</b>, <b>344</b>) are different, separate contexts. Context (<b>310</b>) in endpoint (<b>342</b>) operates on behalf of application (<b>157</b>) a subset of the data communications resources of client (<b>304</b>), and context (<b>312</b>) in endpoint (<b>344</b>) operates on behalf of application (<b>159</b>) a subset of the data communications resources of client (<b>305</b>).</p>
<p id="p-0098" num="0112">Contrasted with the PAMIs (<b>218</b>) on compute node (<b>153</b>), the PAMI (<b>218</b>) on compute node (<b>152</b>) serves only one instance of a parallel application (<b>158</b>) with two endpoints (<b>338</b>, <b>340</b>). The tasks (<b>332</b>, <b>333</b>) in endpoints (<b>338</b>, <b>340</b>) are the same, because they both represent a same instance of a same application (<b>158</b>); both tasks (<b>332</b>,<b>333</b>) therefore are identified, either with a same variable value, references to a same object, or the like, by the task ID (<b>250</b>) of application (<b>158</b>). The clients (<b>302</b>, <b>303</b>) in endpoints (<b>338</b>, <b>340</b>) are optionally either different, separate clients or the same client. If they are different, each associates a separate collection of data communications resources. If they are the same, then each client (<b>302</b>, <b>303</b>) in the PAMI (<b>218</b>) on compute node (<b>152</b>) associates a same set of data communications resources and is identified with a same value, object reference, or the like. Contexts (<b>290</b>, <b>292</b>) in endpoints (<b>338</b>, <b>340</b>) are different, separate contexts. Context (<b>290</b>) in endpoint (<b>338</b>) operates on behalf of application (<b>158</b>) a subset of the data communications resources of client (<b>302</b>) regardless whether clients (<b>302</b>, <b>303</b>) are the same client or different clients, and context (<b>292</b>) in endpoint (<b>340</b>) operates on behalf of application (<b>158</b>) a subset of the data communications resources of client (<b>303</b>) regardless whether clients (<b>302</b>, <b>303</b>) are the same client or different clients. Thus the tasks (<b>332</b>, <b>333</b>) are the same; the clients (<b>302</b>, <b>303</b>) can be the same; and the endpoints (<b>338</b>, <b>340</b>) are distinguished at least by different contexts (<b>290</b>, <b>292</b>), each of which operates on behalf of one of the threads (<b>251</b>-<b>254</b>) of application (<b>158</b>), identified typically by a context offset or a threading point.</p>
<p id="p-0099" num="0113">Endpoints (<b>338</b>, <b>340</b>) being as they are on the same compute node (<b>152</b>) can effect DMA data transfers between endpoints (<b>338</b>, <b>340</b>) through DMA controller (<b>225</b>) and a segment of shared local memory (<b>227</b>). In the absence of such shared memory (<b>227</b>), endpoints (<b>338</b>, <b>340</b>) can effect DMA data transfers through the DMA controller (<b>225</b>) and the network (<b>108</b>), even though both endpoints (<b>338</b>, <b>340</b>) are on the same compute node (<b>152</b>). DMA transfers between endpoint (<b>340</b>) on compute node (<b>152</b>) and endpoint (<b>344</b>) on another compute node (<b>153</b>) go through DMA controllers (<b>225</b>, <b>226</b>) and either a network (<b>108</b>) or a segment of shared remote memory (<b>346</b>). DMA transfers between endpoint (<b>338</b>) on compute node (<b>152</b>) and endpoint (<b>342</b>) on another compute node (<b>153</b>) also go through DMA controllers (<b>225</b>, <b>226</b>) and either a network (<b>108</b>) or a segment of shared remote memory (<b>346</b>). The segment of shared remote memory (<b>346</b>) is a component of a Non-Uniform Memory Access (&#x2018;NUMA&#x2019;) architecture, a segment in a memory module installed anywhere in the architecture of a parallel computer except on a local compute node. The segment of shared remote memory (<b>346</b>) is &#x2018;remote&#x2019; in the sense that it is not installed on a local compute node. A local compute node is &#x2018;local&#x2019; to the endpoints located on that particular compute node. The segment of shared remote memory (<b>346</b>), therefore, is &#x2018;remote&#x2019; with respect to endpoints (<b>338</b>, <b>340</b>) on compute node (<b>158</b>) if it is in a memory module on compute node (<b>153</b>) or anywhere else in the same parallel computer except on compute node (<b>158</b>).</p>
<p id="p-0100" num="0114">Endpoints (<b>342</b>, <b>344</b>) being as they are on the same compute node (<b>153</b>) can effect DMA data transfers between endpoints (<b>342</b>, <b>344</b>) through DMA controller (<b>226</b>) and a segment of shared local memory (<b>348</b>). In the absence of such shared memory (<b>348</b>), endpoints (<b>342</b>, <b>344</b>) can effect DMA data transfers through the DMA controller (<b>226</b>) and the network (<b>108</b>), even though both endpoints (<b>342</b>, <b>344</b>) are on the same compute node (<b>153</b>). DMA transfers between endpoint (<b>344</b>) on compute node (<b>153</b>) and endpoint (<b>340</b>) on another compute node (<b>152</b>) go through DMA controllers (<b>226</b>, <b>225</b>) and either a network (<b>108</b>) or a segment of shared remote memory (<b>346</b>). DMA transfers between endpoint (<b>342</b>) on compute node (<b>153</b>) and endpoint (<b>338</b>) on another compute node (<b>158</b>) go through DMA controllers (<b>226</b>, <b>225</b>) and either a network (<b>108</b>) or a segment of shared remote memory (<b>346</b>). Again, the segment of shared remote memory (<b>346</b>) is &#x2018;remote&#x2019; with respect to endpoints (<b>342</b>, <b>344</b>) on compute node (<b>153</b>) if it is in a memory module on compute node (<b>158</b>) or anywhere else in the same parallel computer except on compute node (<b>153</b>).</p>
<p id="p-0101" num="0115">For further explanation, <figref idref="DRAWINGS">FIG. 11</figref> sets forth a flow chart illustrating an example method of intranode data communications in a parallel computer according to embodiments of the present invention. The method of <figref idref="DRAWINGS">FIG. 11</figref> is carried out in a parallel computer similar to the example parallel computer (<b>100</b>) of <figref idref="DRAWINGS">FIG. 1</figref>. Such a parallel computer (<b>100</b>) includes a plurality of compute nodes and each compute node is configured to execute a plurality of processes.</p>
<p id="p-0102" num="0116">The method of <figref idref="DRAWINGS">FIG. 11</figref> includes allocating (<b>602</b>), by a first process of a compute node upon initialization of the first process of a compute node, a region of shared memory. The first process may be configured to determine from a value stored in a well-known memory address, whether a memory region has been previously allocated. That is the first process checks a flag that indicates whether the shared memory region has already been allocated by another process. If no process has allocated the memory region in shared memory, the first process through one or more atomic operations allocates the memory region (with a malloc system level function call for example) and sets the flag in the well-known memory address.</p>
<p id="p-0103" num="0117">The method of <figref idref="DRAWINGS">FIG. 11</figref> also includes establishing (<b>604</b>), by the first process within the allocated region of shared memory, a predefined number of message buffers. In the method of <figref idref="DRAWINGS">FIG. 11</figref>, each message buffer is associated with a process to be initialized on the compute node. Establishing (<b>604</b>) a message buffer may include establishing a reception or an injection FIFO of predefined size at a predefined offset for each process.</p>
<p id="p-0104" num="0118">The method of <figref idref="DRAWINGS">FIG. 11</figref> also includes sending (<b>606</b>), by the first process to a second process on the same compute node, a data communications message without determining whether the second process has been initialized. In the method of <figref idref="DRAWINGS">FIG. 11</figref>, sending (<b>606</b>) the data communications message to the second process regardless of whether the second process has been initialized, is carried out by storing (<b>608</b>) the data communications message in the message buffer of the second process.</p>
<p id="p-0105" num="0119">The method of <figref idref="DRAWINGS">FIG. 11</figref> also include initializing (<b>610</b>) the second process. Although shown in <figref idref="DRAWINGS">FIG. 11</figref> as occurring after the initialization of the first process, the second process may, in fact, be initialized at any time. Upon the initialization (<b>610</b>) of the second process, the method of <figref idref="DRAWINGS">FIG. 11</figref> continues by retrieving (<b>612</b>), by the second process, a pointer to the second process's message buffer. Retrieving (<b>612</b>) a pointer to the second process's message buffer may be carried out in various ways. The first process, for example, may store the pointer upon establishment of the second process's message buffer in predefined memory location, known to the second process. In another embodiment, the first process may store a pointer to the beginning address of the shared memory region allocated upon the first process's initialization in a memory location well known to all processes. In such an embodiment the pointer, plus an offset corresponding to the second process's identifier, may specify the location of the second process's message buffer. Readers will understand that these are but two ways among many possible ways in which the pointer to the second process's message buffer may be established and retrieved.</p>
<p id="p-0106" num="0120">The method of <figref idref="DRAWINGS">FIG. 11</figref> also includes retrieving (<b>614</b>), by the second process from the second process's message buffer in dependence upon the pointer, the data communications message sent by the first process. Retrieving (<b>614</b>) the data communications message may be carried out by copying the message from the message buffer into the second process's local memory&#x2014;the process's context, for example, in PAMI.</p>
<p id="p-0107" num="0121">Although the method of <figref idref="DRAWINGS">FIG. 11</figref> includes initializing the second process, in some instances, the second process may not initialize. For example, a second process may fail initialization due to a software or hardware related error or may stall during initialization, without ever completing the initialization process. In such examples, the second process will not retrieve the data communications message from the second process's message buffer. To ensure completed delivery of data communications in such a system then, the first process may be configured to periodically poll, for a predefined amount of time, the second process's message buffer to determine whether the data communications message has been retrieved by the second process. If the data communications message has not been retrieved during the predefined amount of time, the first process may flush the second process's message buffer (overwriting the data communications message) and send the data communications message to another process. Readers of skill in the art will recognize, that polling the second process's message buffer for a predefined amount of time is but one way, among many possible ways, to ensure delivery of a data communications message to an uninitialized process. In another example, processes may be configured to send acknowledgments of receipt of data communications message. In such an example, a first process may be configured to send the data communications message to a second process, wait for acknowledgement from the second process for a predefined amount of time, and send the data communications message to another process if the first process does not receive an acknowledgement from the second process after the predefined amount of time.</p>
<p id="p-0108" num="0122">The method of <figref idref="DRAWINGS">FIG. 11</figref> may be implemented in a parallel computer that includes a PAMI (<b>218</b>). In such a parallel computer, the compute nodes may execute a parallel application, and the PAMI may include data communications endpoints, with each endpoint including a specification of data communications parameters for a thread of execution on a compute node, including specifications of a client, a context, and a task. In such and embodiment the endpoints may be coupled for data communications through the PAMI. The processes described in <figref idref="DRAWINGS">FIG. 11</figref> may be implemented in this example embodiment as PAMI endpoints.</p>
<p id="p-0109" num="0123">For further explanation, <figref idref="DRAWINGS">FIG. 12</figref> sets forth a flow chart illustrating an example method of intranode data communications in a parallel computer according to embodiments of the present invention. The method of <figref idref="DRAWINGS">FIG. 12</figref> is carried out in a parallel computer similar to the example parallel computer (<b>100</b>) of <figref idref="DRAWINGS">FIG. 1</figref>. Such a parallel computer (<b>100</b>) includes a plurality of compute nodes and each compute node is configured to execute a plurality of processes. The method of <figref idref="DRAWINGS">FIG. 12</figref> is similar to the method of <figref idref="DRAWINGS">FIG. 11</figref> in that the method of <figref idref="DRAWINGS">FIG. 12</figref> also includes: allocating (<b>602</b>), upon initialization of a first process of a compute node, a region of shared memory; establishing (<b>604</b>) a predefined number of message buffers; sending (<b>606</b>) a data communications message to a second process by storing (<b>608</b>) the message in the message buffer of the second process; and, upon initialization (<b>610</b>) of the second process: retrieving (<b>612</b>) a pointer to the second process's message buffer; and retrieving (<b>614</b>) the data communications message sent by the first process.</p>
<p id="p-0110" num="0124">The method of <figref idref="DRAWINGS">FIG. 12</figref> differs from the method of <figref idref="DRAWINGS">FIG. 11</figref>, however, in that in the method of <figref idref="DRAWINGS">FIG. 12</figref>, establishing (<b>604</b>) a predefined number of message buffers may be carried out in one of a variety of ways. One way of carrying out the establishment (<b>604</b>) of the message buffers in the example of <figref idref="DRAWINGS">FIG. 12</figref> includes establishing (<b>1202</b>) a single message buffer associated with the second process for which the first process intends to send the data communications message and establishing (<b>1204</b>), by each subsequently initialized process intending to send a data communications to an uninitialized process, a message buffer for the uninitialized process. In this way, each process, upon its initialization, may establish a message buffer for any process it intends to send a data communications message. In this way, message buffers are created only for processes that are being sent data.</p>
<p id="p-0111" num="0125">Another way of establishing (<b>604</b>) a predefined number of message buffers depicted in <figref idref="DRAWINGS">FIG. 12</figref> includes establishing (<b>1206</b>) a number of message buffers equal to a maximum number of processes that may simultaneously execute. That is, the first process may establish a message buffer for every process that will eventually be initialized. Consider, for example, that a parallel application is configured to instantiate <b>100</b> parallel processes. When the first process initializes, that process may be configured to establish (<b>1206</b>) a message buffer for the remaining 99 processes to be initialized. In this way, only one process is responsible for establishing message buffers and all other processes, once initialized, may immediately begin sending data to other processes without regard to the initialization state of the other processes.</p>
<p id="p-0112" num="0126">For further explanation, <figref idref="DRAWINGS">FIG. 13</figref> sets forth a flow chart illustrating an example method of intranode data communications in a parallel computer according to embodiments of the present invention. The method of <figref idref="DRAWINGS">FIG. 13</figref> is carried out in a parallel computer similar to the example parallel computer (<b>100</b>) of <figref idref="DRAWINGS">FIG. 1</figref>. Such a parallel computer (<b>100</b>) includes a plurality of compute nodes and each compute node is configured to execute a plurality of processes. The method of <figref idref="DRAWINGS">FIG. 13</figref> is similar to the method of <figref idref="DRAWINGS">FIG. 11</figref> in that the method of <figref idref="DRAWINGS">FIG. 13</figref> also includes: allocating (<b>602</b>), upon initialization of a first process of a compute node, a region of shared memory; establishing (<b>604</b>) a predefined number of message buffers; sending (<b>606</b>) a data communications message to a second process by storing (<b>608</b>) the message in the message buffer of the second process; and, upon initialization (<b>610</b>) of the second process: retrieving (<b>612</b>) a pointer to the second process's message buffer; and retrieving (<b>614</b>) the data communications message sent by the first process.</p>
<p id="p-0113" num="0127">The method of <figref idref="DRAWINGS">FIG. 13</figref> differs from the method of <figref idref="DRAWINGS">FIG. 11</figref>, however, the method of <figref idref="DRAWINGS">FIG. 13</figref> includes requesting (<b>1302</b>), by a process, initialization of an on-demand process to execute a task. An on-demand process is a process initialized at the behest of another process, for a specified time or task. On-demand processes may be thought of accelerators, employed only when necessary and available. In the method of <figref idref="DRAWINGS">FIG. 13</figref>, requesting (<b>1302</b>) initialization of an on-demand process to execute a task includes establishing (<b>1304</b>) a message buffer for the on-demand process and storing (<b>1306</b>) a data communications message intended for the on-demand process in the message buffer. That is, immediately upon request, prior to initialization of the on-demand process, the requesting process may provide data to the on-demand process so that the on-demand process may begin processing that data immediately upon its initialization. The requesting process may implement the request for the on-demand process in various ways. The requesting process may execute a function call through an API in a PAMI, another messaging interface, a root process or other module designated for managing on-demand process execution and resource allocation.</p>
<p id="p-0114" num="0128">The method of <figref idref="DRAWINGS">FIG. 13</figref> also includes initializing (<b>1308</b>) the on-demand process. The module responsible for managing the on-demand process execution and resource allocation&#x2014;such as a PAMI&#x2014;may also be responsible for forking another process to instantiate the on-demand process. Further, the module may provide the on-demand process with a pointer to its message buffer. Initializing (<b>1308</b>) the on-demand process in the example of <figref idref="DRAWINGS">FIG. 13</figref> includes retrieving (<b>1310</b>) the data communications message from the message buffer established for the on-demand process and, upon completion of the task by the on-demand process, releasing (<b>1312</b>), by the on-demand process, the message buffer of the on-demand process. Releasing the message buffer of the on-demand process may be effected in a variety of ways. For example, the module configured to manage on-demand process execution and resources may monitor the state of the on-demand process for the process's exit, may receive a callback from the on-demand process as part of the process's exit and so on as will occur to readers of skill in the art. Once the on-demand process exists, the module responsible for on-demand process execution management may assign the released message buffer to a subsequently requested and initialized on-demand process.</p>
<p id="p-0115" num="0129">In this way, on-demand processes may be brought up and taken down&#x2014;started and stopped&#x2014;efficiently. Other processes may call upon the on-demand process when in need, and without waiting for the on-demand process to be initialized, send the on-demand process data to be processed.</p>
<p id="p-0116" num="0130">As will be appreciated by one skilled in the art, aspects of the present invention may be embodied as a system, method or computer program product. Accordingly, aspects of the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a &#x201c;circuit,&#x201d; &#x201c;module&#x201d; or &#x201c;system.&#x201d; Furthermore, aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium(s) having computer readable program code embodied thereon.</p>
<p id="p-0117" num="0131">Any combination of one or more computer readable medium(s) may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be, for example, but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, or device, or any suitable combination of the foregoing. More specific examples (a non-exhaustive list) of the computer readable storage medium would include the following: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), an optical fiber, a portable compact disc read-only memory (CD-ROM), an optical storage device, a magnetic storage device, or any suitable combination of the foregoing. In the context of this document, a computer readable storage medium may be any tangible medium that can contain, or store a program for use by or in connection with an instruction execution system, apparatus, or device.</p>
<p id="p-0118" num="0132">A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein, for example, in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms, including, but not limited to, electro-magnetic, optical, or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate, propagate, or transport a program for use by or in connection with an instruction execution system, apparatus, or device.</p>
<p id="p-0119" num="0133">Program code embodied on a computer readable medium may be transmitted using any appropriate medium, including but not limited to wireless, wireline, optical fiber cable, RF, etc., or any suitable combination of the foregoing.</p>
<p id="p-0120" num="0134">Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages, including an object oriented programming language such as Java, Smalltalk, C++ or the like and conventional procedural programming languages, such as the &#x201c;C&#x201d; programming language or similar programming languages. The program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).</p>
<p id="p-0121" num="0135">Aspects of the present invention are described above with reference to flowchart illustrations and/or block diagrams of methods, apparatus (systems) and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and/or block diagrams, and combinations of blocks in the flowchart illustrations and/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions/acts specified in the flowchart and/or block diagram block or blocks.</p>
<p id="p-0122" num="0136">These computer program instructions may also be stored in a computer readable medium that can direct a computer, other programmable data processing apparatus, or other devices to function in a particular manner, such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function/act specified in the flowchart and/or block diagram block or blocks.</p>
<p id="p-0123" num="0137">The computer program instructions may also be loaded onto a computer, other programmable data processing apparatus, or other devices to cause a series of operational steps to be performed on the computer, other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions/acts specified in the flowchart and/or block diagram block or blocks.</p>
<p id="p-0124" num="0138">The flowchart and block diagrams in the Figures illustrate the architecture, functionality, and operation of possible implementations of systems, methods and computer program products according to various embodiments of the present invention. In this regard, each block in the flowchart or block diagrams may represent a module, segment, or portion of code, which comprises one or more executable instructions for implementing the specified logical function(s). It should also be noted that, in some alternative implementations, the functions noted in the block may occur out of the order noted in the figures. For example, two blocks shown in succession may, in fact, be executed substantially concurrently, or the blocks may sometimes be executed in the reverse order, depending upon the functionality involved. It will also be noted that each block of the block diagrams and/or flowchart illustration, and combinations of blocks in the block diagrams and/or flowchart illustration, can be implemented by special purpose hardware-based systems that perform the specified functions or acts, or combinations of special purpose hardware and computer instructions.</p>
<p id="p-0125" num="0139">It will be understood from the foregoing description that modifications and changes may be made in various embodiments of the present invention without departing from its true spirit. The descriptions in this specification are for purposes of illustration only and are not to be construed in a limiting sense. The scope of the present invention is limited only by the language of the following claims.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method of intranode data communications in a parallel computer, the parallel computer comprising a plurality of compute nodes, each compute node of the plurality of compute nodes configured to execute a plurality of processes, the method comprising:
<claim-text>upon initialization of a first process of one of the plurality of compute nodes, allocating, by the first process, a region of shared memory;</claim-text>
<claim-text>establishing, by the first process within the allocated region of shared memory, a predefined number of message buffers, each message buffer associated with one of the plurality of processes to be initialized on the one of the plurality of compute nodes;</claim-text>
<claim-text>sending, by the first process to a second process of the one of the plurality of compute nodes, a data communications message without determining whether the second process has been initialized, including storing the data communications message in the message buffer of the second process;</claim-text>
<claim-text>upon initialization of the second process:</claim-text>
<claim-text>retrieving, by the second process, a pointer to the second process's message buffer; and</claim-text>
<claim-text>retrieving, by the second process from the second process's message buffer in dependence upon the pointer, the data communications message sent by the first process, wherein:</claim-text>
<claim-text>the parallel computer comprises a parallel active messaging interface (&#x2018;PAMI&#x2019;) and the plurality of compute nodes execute a parallel application, the PAMI comprises data communications endpoints, each data communications endpoint comprising a specification of data communications parameters for a thread of execution on a compute node of the plurality of compute nodes, including specifications of a client, a context, and a task, the data communications endpoints coupled for data communications through the PAMI;</claim-text>
<claim-text>each process of the plurality of processes comprises one of the data communications endpoints;</claim-text>
<claim-text>each client comprises a collection of data communications resources dedicated to exclusive use of an application-level data processing entity;</claim-text>
<claim-text>each context comprises a subset of the collection of data processing resources of a client, context functions, and a work queue of data transfer instructions to be performed by use of the subset through the context functions operated by an assigned thread of execution;</claim-text>
<claim-text>each task represents a process of execution of the parallel application; and</claim-text>
<claim-text>each context carries out data communications operations independently and in parallel with other contexts.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the establishing, by the first process within the allocated region of shared memory, the predefined number of message buffers further comprises:
<claim-text>establishing a single message buffer associated with the second process for which the first process intends to send the data communications message; and</claim-text>
<claim-text>establishing, by each subsequently initialized process of the plurality of processes intending to send a data communications to an uninitialized process, a message buffer for the uninitialized process.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the establishing, by the first process within the allocated region of shared memory, a predefined number of message buffers further comprises establishing a number of message buffers equal to a maximum number of processes that may simultaneously execute.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>requesting, by a process of the plurality of processes, initialization of an on-demand process to execute a task, including establishing a message buffer for the on-demand process and storing a data communications message intended for the on-demand process in the message buffer;</claim-text>
<claim-text>initializing the on-demand process, including retrieving the data communications message intended for the on-demand process from the message buffer established for the on-demand process; and</claim-text>
<claim-text>upon completion of the task, releasing, by the on-demand process, the message buffer of the on-demand process.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein each context carries out, through post and advance functions, data communications for the parallel application on data communications resources in exclusive possession of that context. </claim-text>
</claim>
</claims>
</us-patent-grant>
