<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627275-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627275</doc-number>
<kind>B1</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13341354</doc-number>
<date>20111230</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>44</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>30</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>717106</main-classification>
<further-classification>707769</further-classification>
</classification-national>
<invention-title id="d2e43">Technique for acquiring data storage metrics</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5425128</doc-number>
<kind>A</kind>
<name>Morrison</name>
<date>19950600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>704243</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>2006/0130038</doc-number>
<kind>A1</kind>
<name>Claussen et al.</name>
<date>20060600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717168</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>2008/0022258</doc-number>
<kind>A1</kind>
<name>Pomponio</name>
<date>20080100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717106</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2009/0070338</doc-number>
<kind>A1</kind>
<name>Spitzig et al.</name>
<date>20090300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707 10</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>2009/0313279</doc-number>
<kind>A1</kind>
<name>Tomaszewski</name>
<date>20091200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707102</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2010/0070489</doc-number>
<kind>A1</kind>
<name>Aymeloglu et al.</name>
<date>20100300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707722</main-classification></classification-national>
</us-citation>
<us-citation>
<nplcit num="00007">
<othercit>&#x201c;SQL Functions,&#x201d; W3schools.com, downloaded from http://www.w3schools.com/sql/sql functions.asp, Feb. 7, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00008">
<othercit>&#x201c;SQL AS,&#x201d; downloaded from http://www.1keydata.com/sql/sql-as.html, Feb. 7, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00009">
<othercit>&#x201c;Understanding SQL Statement Performance,&#x201d; Safari Books Online, Preview.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00010">
<othercit>&#x201c;Perform Arithmetic Operations SQL Server 2005 Tuning,&#x201d; GeeksEngine.com, dowloaded from http://www.geeksengine.com/database/basic-select/arithmetic-operations.php, Feb. 7, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00011">
<othercit>&#x201c;SQL Views, SQL Server 2000,&#x201d; downloaded from http://msdn.microsoft.com/en-us/library/aa214068(v=sql.80).aspx, Feb. 7, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>18</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>707769</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707722</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>717106</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>717168</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>4</number-of-drawing-sheets>
<number-of-figures>4</number-of-figures>
</figures>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Belov</last-name>
<first-name>Alexander</first-name>
<address>
<city>Saint-Petersburg</city>
<country>RU</country>
</address>
</addressbook>
<residence>
<country>RU</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Tylik</last-name>
<first-name>Dmitry</first-name>
<address>
<city>Saint-Petersburg</city>
<country>RU</country>
</address>
</addressbook>
<residence>
<country>RU</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Nekrasova</last-name>
<first-name>Oksana</first-name>
<address>
<city>Saint-Petersburg</city>
<country>RU</country>
</address>
</addressbook>
<residence>
<country>RU</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Belov</last-name>
<first-name>Alexander</first-name>
<address>
<city>Saint-Petersburg</city>
<country>RU</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Tylik</last-name>
<first-name>Dmitry</first-name>
<address>
<city>Saint-Petersburg</city>
<country>RU</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Nekrasova</last-name>
<first-name>Oksana</first-name>
<address>
<city>Saint-Petersburg</city>
<country>RU</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>BainwoodHuang</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>EMC Corporation</orgname>
<role>02</role>
<address>
<city>Hopkinton</city>
<state>MA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Vy</last-name>
<first-name>Hung T</first-name>
<department>2163</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A technique for acquiring information about a data storage system employs compiled software constructs and an uncompiled file external to the compiled software constructs. The uncompiled file stores data inquiry definitions, such as select query and view definitions. The compiled software constructs incorporate the data inquiry definitions from the uncompiled file into database language instructions, which the compiled software constructs send to a database for processing. Results of processing the database language instructions are returned to the compiled software constructs, which return the results to an application program or other client that requested them.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="188.72mm" wi="164.00mm" file="US08627275-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="216.92mm" wi="167.47mm" file="US08627275-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="238.17mm" wi="173.99mm" file="US08627275-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="238.59mm" wi="145.46mm" orientation="landscape" file="US08627275-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="237.32mm" wi="167.47mm" orientation="landscape" file="US08627275-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">FIELD</heading>
<p id="p-0002" num="0001">This invention relates generally to data storage systems and, more particularly, to techniques for obtaining performance metrics from data storage systems.</p>
<heading id="h-0002" level="1">BACKGROUND</heading>
<p id="p-0003" num="0002">Data storage systems conventionally include one or more storage processors connected to a disk array via a high-speed transmission medium, such as optical fiber. An example of a data storage system is the VNX&#xae; platform from EMC Corporation of Hopkinton, Mass.</p>
<p id="p-0004" num="0003">Many data storage systems produce metrics that reflect their performance and workload. Typical metrics include the number of bytes written or read by the data storage system (i.e., the &#x201c;byte count&#x201d;), percent CPU consumption by the storage processor, and timing delays involved in processing reads from a disk array and writes to a disk array. Generally, one or more device drivers of the data storage system monitor and collect metrics, which are stored in a database for access by an application program, such as a program operated by a data storage administrator. Typically, the storage processor includes a software library that contains classes for performing SQL queries of the database. The software library may include a variety of classes, e.g., one class for each metric that the data storage system produces. In operation, the application program sends a command requesting metric information to a class of the software library. The class executes a SQL query on the database, post-processes the query results, and reports the post-processed query results to the application program, where the results may be presented to the data storage administrator.</p>
<heading id="h-0003" level="1">SUMMARY</heading>
<p id="p-0005" num="0004">Unfortunately, the classes within the software library for accessing metrics of the data storage system are difficult to maintain. The class for each metric generally includes one or more SQL queries into the database. The class also includes instructions for post-processing query results, such as to compute statistics and/or to measure changes in the respective metric over time. In some examples, performing these querying and post-processing functions can require thousands of lines of code. The software library is generally provided as compiled code that is run in executable form. Any error in the SQL queries or the post-processing of query results thus requires an examination, debug, and revision of the class, followed by a recompile, generally of the entire software library. Management of these classes has become ever more troublesome as the number of metrics produced by data storage systems has increased.</p>
<p id="p-0006" num="0005">In contrast with the prior approach, in which queries and post-processing are encoded in compiled classes that are difficult to maintain, an improved technique for acquiring information about a data storage system employs one or more compiled software constructs and an uncompiled file external to the compiled software constructs. The compiled software constructs include database language instructions for obtaining data storage information from a database. The uncompiled file, which in some examples is a human-readable file, stores &#x201c;data inquiry definitions,&#x201d; i.e., definitions of queries, views, and/or other database reporting structures. The compiled software constructs access the uncompiled file, incorporate data inquiry definitions into the database language instructions, and send the database language instructions to the database. Results from running the database language instructions on the database are returned to the compiled software constructs, which return the results to an application program or other client that requested them. The data inquiry definitions can be arbitrarily complex, and can be written to perform tasks previously performed as post-processing within the classes. Using this technique, the compiled software constructs can be kept comparatively simple and uniform, with the complex aspects of data selection and post-processing provided externally, in an uncompiled file, which is comparatively easy to maintain.</p>
<p id="p-0007" num="0006">In some examples, a different compiled software construct is provided for each metric or computation based on metrics. In other examples, only a single compiled software construct is provided, which forms a generic template that can be used for any metric or computation based on a metric. In still other examples, multiple compiled software constructs are provided, but not one for each metric. Rather, different compiled software constructs are provided for performing different types of processing, and each type of compiled software construct may be used for multiple metrics or computations.</p>
<p id="p-0008" num="0007">One embodiment of the improvement hereof is directed to a method for obtaining information about a data storage system. The method includes receiving a request for information from a data storage application. The method further includes executing, in response to the request, a compiled software construct to retrieve from a database a set of metrics indicative of performance of the data storage system. The compiled software construct includes a database language instruction, and the database language instruction includes a reference to a data inquiry definition stored in an uncompiled file external to the compiled software construct. In addition, the method includes sending the database language instruction, including the data inquiry definition, to the database, to execute the database language instruction on the database and produce a result. The method still further includes receiving the result of the database language instruction by the compiled software construct and returning information to the data storage application based on the result of the database language instruction.</p>
<p id="p-0009" num="0008">Other embodiments are directed to computerized apparatus and computer program products. Some embodiments involve activity that is performed at a single location, while other embodiments involve activity that is distributed over a computerized environment (e.g., over a network).</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS</heading>
<p id="p-0010" num="0009">The foregoing and other features and advantages will become apparent from the following description of particular embodiments of the invention, as illustrated in the accompanying drawings, in which like reference characters refer to the same parts throughout the different views. In the accompanying drawings,</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 1</figref> is block diagram of an example environment in which an improved technique may be employed for obtaining metric information from data storage systems;</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram of an example data storage system of <figref idref="DRAWINGS">FIG. 1</figref>;</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 3</figref> is an example table of metric values collected in the environment of <figref idref="DRAWINGS">FIG. 1</figref>; and</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 4</figref> is a sequence diagram of an example process for obtaining information about the data storage system of <figref idref="DRAWINGS">FIG. 2</figref>.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION OF THE INVENTION</heading>
<p id="p-0015" num="0014">An improved technique for acquiring information about a data storage system employs one or more compiled software constructs and an uncompiled file external to the compiled software constructs that stores data inquiry definitions. The compiled software constructs access the uncompiled file, incorporate data inquiry definitions into database language instructions, and send the database language instructions to the database. Results from running the database language instructions on the database are returned to the compiled software constructs, which return the results to an application program or other client that requested them.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 1</figref> shows an example environment <b>100</b> in which an improved technique may be applied for obtaining metric information from data storage systems. The environment <b>100</b> includes a computing device <b>112</b>, a network <b>114</b>, and a number of data storage systems <b>120</b>(<b>1</b>), <b>120</b>(<b>2</b>), and <b>120</b>(<b>3</b>). The computing device <b>112</b> is operable by a user <b>110</b>, such as a data storage administrator. Any number of data storage systems may be provided. Each data storage system <b>120</b>(<b>1</b>-<b>3</b>) includes a compiled library <b>130</b>(<b>1</b>-<b>3</b>) and an uncompiled file <b>140</b>(<b>1</b>-<b>3</b>). The uncompiled file <b>140</b>(<b>1</b>-<b>3</b>) stores data inquiry definitions, i.e., definitions of queries, views, and/or other database reporting structures.</p>
<p id="p-0017" num="0016">The computing device <b>112</b> can be any type of computing device capable of running a program that communicates with the data storage systems <b>120</b>(<b>1</b>-<b>3</b>) over the network <b>114</b>. Suitable examples of the computing device <b>112</b> include desktop computers, laptop computers, and workstations, as well as tablet computers, smart phones, and other devices. The network <b>114</b> is typically the Internet, but can be any network, including a cellular telephone network, satellite network, local area network (LAN), wide area networks (WAN), and the like.</p>
<p id="p-0018" num="0017">In typical operation, the user <b>110</b> starts a client program on the computing device <b>112</b> to obtain information about any of the data storage systems <b>120</b>(<b>1</b>-<b>3</b>). For example, the user may operate the client program to view values of metrics, or of calculations based on metrics, from any of the data storage systems <b>120</b>(<b>1</b>-<b>3</b>), including, for example, byte count, CPU utilization, timing latencies, and other metric values and/or calculations. The client program communicates with the data storage systems <b>120</b>(<b>1</b>-<b>3</b>) over the network <b>114</b>. In response to requests from the client program, the data storage systems <b>120</b>(<b>1</b>-<b>3</b>) perform processes to obtain the requested metric values and/or calculations.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 2</figref> shows an example data storage system <b>120</b> in additional detail. The data storage system <b>120</b> is typical of any of the data storage systems <b>120</b>(<b>1</b>-<b>3</b>) of <figref idref="DRAWINGS">FIG. 1</figref>. The data storage system <b>120</b> includes a computing system <b>210</b>, a number of transmission media <b>212</b><i>a</i>-<b>212</b><i>n</i>, and a storage array <b>214</b>. The computing system <b>210</b> may be a high speed computer, such as a server-grade computer, for example. The transmission media <b>212</b><i>a</i>-<b>212</b><i>n </i>may be fiber optic cables, such as Fibre Channel cables. The storage array <b>214</b> is generally a disk array or an array of other non-volatile storage elements. The storage array <b>214</b> may in some examples be implemented as a disk array enclosure (DAE) including link control cards (LLCs) for connecting to the transmission media <b>212</b><i>a</i>-<b>212</b><i>n</i>. The computing system <b>210</b>, transmission media <b>212</b><i>a</i>-<b>212</b><i>n</i>, and storage array <b>214</b> can be provided in a variety of forms, however, according to the requirements of the particular implementation.</p>
<p id="p-0020" num="0019">The computing system <b>210</b> includes a set of processors <b>220</b> (i.e., one or more processors or processing boards), memory <b>222</b>, a network interface <b>240</b>, and a number of Fibre Channel/Serial Attach SCSI (FC/SAS) ports <b>250</b><i>a</i>-<b>250</b><i>n</i>. The FC/SAS ports <b>250</b><i>a</i>-<i>n </i>are connected to the storage array <b>214</b> via the transmission media <b>212</b><i>a</i>-<b>212</b><i>n</i>. The set of processors <b>220</b> and the memory together form a specialized circuit <b>224</b>, for performing various functions and processes as described hereinbelow.</p>
<p id="p-0021" num="0020">The memory <b>222</b> stores various software constructs. These include a compiled library <b>130</b> (i.e., typical of any of the compiled libraries <b>130</b>(<b>1</b>-<b>3</b>) of <figref idref="DRAWINGS">FIG. 1</figref>) and an uncompiled file <b>140</b> (i.e., typical of any of the uncompiled files <b>140</b>(<b>1</b>-<b>3</b>) of <figref idref="DRAWINGS">FIG. 1</figref>). The software constructs in the memory <b>222</b> also include a database <b>230</b>, an administrative server <b>232</b>, and a set of drivers (i.e., one or more drivers) <b>234</b>. The memory <b>220</b> typically includes both volatile and nonvolatile portions.</p>
<p id="p-0022" num="0021">The database <b>230</b> includes one or more tables that store metric values. Each table includes a set of fields and a number of records. Each record stores values for some or all of the fields of the respective table. In some examples, new metric values are collected at regular intervals, such as every five minutes. A new record is written to each table of the database <b>230</b> each time new metric values are collected.</p>
<p id="p-0023" num="0022">The database <b>230</b> is compatible with a database query language, such as Structured Query Language (SQL, including any of its variants), Common Interface Model (CIM) Query Language (CQL), and many others. Also, the database <b>230</b> can be provided in the form of a single database file or as multiple database files.</p>
<p id="p-0024" num="0023">The administrative server <b>232</b> is a server-side application that runs in coordination with the client program operable by the user <b>110</b>. In some examples, the administrative server <b>232</b> is implemented as a web server running a web application, which serves web pages and other content to the client program. In other examples, the administrative server <b>232</b> is the server side of a client-server application. The administrative server <b>232</b> communicates with the compiled library <b>130</b> to obtain metric values from the database <b>230</b>, for presentation to the user <b>110</b>. An example of an administrative server <b>232</b> is the UniSphere&#xae; unified storage management solution by EMC Corporation of Hopkinton, Mass.</p>
<p id="p-0025" num="0024">The driver(s) <b>234</b> include one or more device drivers for managing hardware of the data storage system <b>120</b>. These may include a driver for managing CPU processing and/or a driver for managing I/O requests (i.e., requests for reads and writes of the storage array <b>214</b>). The driver(s) <b>234</b> may also include drivers for managing other functions of the computing system <b>210</b>, which also produce metric values. In some examples, the driver(s) <b>234</b> are implemented as kernel extensions. The driver(s) <b>234</b> collect metric values, which are transferred to the database <b>230</b>.</p>
<p id="p-0026" num="0025">The compiled library <b>130</b> includes a number of compiled software constructs <b>132</b>. In some examples, each compiled software construct <b>132</b> pertains to a different metric or to a different computation (such as a mathematical computation based on metrics or a statistic). In other examples, only a single compiled software construct <b>132</b> is provided, which forms a generic template for accessing any metric or computation. In still other examples, multiple compiled software constructs are provided, with each performing a different type of database processing. Each software construct <b>132</b> includes one or more database language instructions for accessing the database <b>230</b> and extracting particular metric values from one or more tables of the database <b>230</b>. Each database language instruction includes a reference to a data inquiry definition <b>142</b> stored in the uncompiled file <b>140</b>. Each software construct <b>132</b> may further include instructions for post-processing metric values read back from the database <b>230</b>. As will become apparent, however, the amount of post-processing is typically very small compared with conventional techniques.</p>
<p id="p-0027" num="0026">The compiled software constructs <b>132</b> can be written in any suitable programming language. Also, the compiled software constructs <b>132</b> can be provided in a variety of forms, such as functions, subroutines, procedures, entry points into larger code constructs, object classes, or other forms. In one embodiment, the compiled software constructs <b>132</b> are C++ classes compiled using a C++ compiler.</p>
<p id="p-0028" num="0027">The database language instructions within the compiled software constructs <b>132</b> are written in a database language, such as Structured Query Language (SQL), CIM Query Language (CQL), or any of a number of other database languages. Each database language instructions generally includes a SELECT statement having a FROM designator. Other designators may be provided as well. An example database language instruction may take the following form:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0028">SELECT &#x3c;fields&#x3e; FROM &#x3c;source&#x3e; WHERE &#x3c;criteria&#x3e; ORDER BY&#x3c;one of the fields&#x3e; &#x3c;direction&#x3e; LIMIT &#x3c;maximum number of records&#x3e;.
<br/>
The above instruction specifies a select query of the &#x201c;source&#x201d; for data contained in the listed &#x201c;fields.&#x201d; Results are filtered by the &#x201c;criteria,&#x201d; and are ordered by the specified &#x201c;field&#x201d; of the &#x201c;source.&#x201d; Data are presented in the indicated &#x201c;direction&#x201d; (e.g., ascending or descending) and are limited to the &#x201c;maximum number of records.&#x201d; A specific example of a database language instruction having the above form may written into the source code for a compiled software construct <b>132</b> as, for example, a string value prior to compiling. It is understood that the names SELECT and FROM are merely descriptive of the functions associated with the names and can be varied as long as the underlying functions are substantially as described. The fact that these names are language elements of SQL should not be construed as limiting the language of the database language instruction to SQL.
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0029" num="0029">The &#x201c;source&#x201d; in the above example database language instruction is a reference to a data inquiry definition <b>142</b> stored in the uncompiled file <b>140</b>. In some examples, the reference is simply a name of the data inquiry definition or a name associated with a data inquiry definition <b>142</b>. In other examples, the reference is a pointer or some other designation.</p>
<p id="p-0030" num="0030">In contrast with the compiled file <b>130</b>, which once compiled cannot be read by a human, the uncompiled file <b>140</b> is preferably a human-readable file, such as a structured text file. Examples of structured text files include XML (Extensible Markup Language) and JSON (JavaScript Object Notation) files. Although the uncompiled file <b>140</b> can be implemented as other types of files, XML, JSON, and similar file types are preferred because many parsers and validators are available for use with these file types.</p>
<p id="p-0031" num="0031">The uncompiled file <b>140</b> includes a number of data inquiry definitions <b>142</b>. Each data inquiry definition <b>142</b> specifies a particular inquiry into the database <b>230</b>, such as a select query, view, or other database reporting structure. As is known, select queries and views are database elements for inspecting the contents of database tables based on certain criteria. Data inquiry definitions <b>142</b> can store select queries and views in a variety of ways. In some examples, different elements of select queries and views are stored within different tags or parameters of the uncompiled file <b>140</b>. These elements can be gathered together by the compiled software constructs <b>132</b> and assembled into complete select query or view definitions. In other examples, the uncompiled file <b>140</b> stores the data inquiry definitions <b>142</b> as complete database language instructions (e.g., as textual SQL instructions) within a single set of tags or as a single parameter. Examples of data inquiry definitions <b>142</b> will now be described with reference to <figref idref="DRAWINGS">FIG. 3</figref>.</p>
<p id="p-0032" num="0032"><figref idref="DRAWINGS">FIG. 3</figref> shows an example table <b>300</b> of the database <b>230</b>. The example table <b>300</b> has the name &#x201c;SP_performance&#x201d; and stores metric values pertaining to the CPU activity of a storage processor (i.e., the computing system <b>210</b>). The metric values are obtained by the driver(s) <b>234</b> at five-minute intervals and stored as separate records in the table <b>300</b>.</p>
<p id="p-0033" num="0033">The table <b>300</b> has seven fields, including recordID, objectID, and timestamp. The recordID increments for each record and thus may operate as a primary key. The objectID specifies the object, i.e., a portion of the data storage system <b>120</b>, to which the record pertains (e.g., &#x201c;SPA&#x201d; for storage processor A). The timestamp records the date and time when metric values are obtained.</p>
<p id="p-0034" num="0034">Specific metric values are specified in the remaining fields. These include busySystemTicks, busyUserTicks, idleTicks, and waitTicks. BusySystemTicks designates the number of CPU cycles applied to system processes, whereas busyUserTicks designates the number of CPU cycles applied to user processes. IdleTicks designates the number of cycles for which the CPU was idle, while waitTicks designates the number of cycles spent waiting for various processes to complete.</p>
<p id="p-0035" num="0035">Various data inquiry definitions <b>142</b> can be stored in the uncompiled file <b>140</b> for defining select queries and/or views of data stored in the table <b>300</b>. Below is an example data inquiry definition <b>142</b> defining a select query into the table <b>300</b>:</p>
<p id="p-0036" num="0036">&#x3c;busySystemTicks_Delta&#x3e;
<ul id="ul0003" list-style="none">
    <li id="ul0003-0001" num="0000">
    <ul id="ul0004" list-style="none">
        <li id="ul0004-0001" num="0037">SELECT</li>
        <li id="ul0004-0002" num="0038">a.objectID AS objectID,</li>
        <li id="ul0004-0003" num="0039">a.timestamp AS timestamp,</li>
        <li id="ul0004-0004" num="0040">(a.busySystemTicks&#x2212;b.busySystemTicks) AS BUSY_DIFF FROM SP_performance a, SP_performance b WHERE a.recordID==(b.recordID+1) AND a.objectID==b.objectID</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0037" num="0041">&#x3c;/busySystemTicks_Delta&#x3e;</p>
<p id="p-0038" num="0042">The tags &#x3c;busySystemTicks_Delta&#x3e;&#x3c;/busySystemTicks_Delta&#x3e; identify the select query by name. The compiled software constructs <b>132</b> can use this name as a &#x201c;source&#x201d; in connection with a FROM designator in a database language instruction to reference the above select query.</p>
<p id="p-0039" num="0043">The contents of this select query (i.e., the portions between the tags &#x3c;busySystemTicks_Delta&#x3e;&#x3c;/busySystemTicks_Delta&#x3e;) are standard SQL. The purpose of this calculation is to compute the difference in the field busySystemTicks between two adjacent records of the table <b>300</b>. The expression a.recordID represents a first record, and the expression b.recordID represents a second record.</p>
<p id="p-0040" num="0044">The above example of a data inquiry definition <b>142</b> can also be provided in the form of a view. The following view is equivalent to the above select query:</p>
<p id="p-0041" num="0045">&#x3c;busySystemTicks_Delta&#x3e;
<ul id="ul0005" list-style="none">
    <li id="ul0005-0001" num="0000">
    <ul id="ul0006" list-style="none">
        <li id="ul0006-0001" num="0046">CREATE VIEW Busy_System_Ticks_Delta_View AS SELECT</li>
        <li id="ul0006-0002" num="0047">a.objectID AS objectID,</li>
        <li id="ul0006-0003" num="0048">a.timestamp AS timestamp,</li>
        <li id="ul0006-0004" num="0049">(a.busySystemTicks&#x2212;b.busySystemTicks) AS BUSY_DIFF FROM SP_performance a, SP_performance b WHERE a.recordID==(b.recordID+1) AND a.objectID==b.objectID</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0042" num="0050">&#x3c;/busySystemTicks_Delta&#x3e;</p>
<p id="p-0043" num="0051">Unlike the select query, the above-defined view has a name (Busy_System_Ticks_Delta_View). The compiled software constructs <b>132</b> can refer to the view using this name, or, as with the select query, using the name set forth by the tags &#x3c;busySystemTicks_Delta&#x3e;&#x3c;/busySystemTicks_Delta&#x3e;. Note that this view includes a select query in its definition.</p>
<p id="p-0044" num="0052">Another typical example is to calculate a rate of change of a metric over time. For instance, the view defined above can be modified to calculate the rate of change of busySystemTicks between two adjacent records:</p>
<p id="p-0045" num="0053">&#x3c;busySystemTicksRate&#x3e;
<ul id="ul0007" list-style="none">
    <li id="ul0007-0001" num="0000">
    <ul id="ul0008" list-style="none">
        <li id="ul0008-0001" num="0054">CREATE VIEW Busy_System_Ticks_Rate_View AS SELECT</li>
        <li id="ul0008-0002" num="0055">a.objectID AS objectID,</li>
        <li id="ul0008-0003" num="0056">a.timestamp AS timestamp,</li>
        <li id="ul0008-0004" num="0057">((a.busySystemTicks&#x2212;b.busySystemTicks)/(a.timestamp&#x2212;b.timestamp)) AS BUSY_DIFF</li>
        <li id="ul0008-0005" num="0058">FROM SP_performance a, SP_performance b WHERE a.recordID==(b.recordID+1) AND a.objectID==b.objectID</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0046" num="0059">&#x3c;/busySystemTicksRate&#x3e;</p>
<p id="h-0006" num="0000">A compiled software construct <b>132</b> can reference the above view by the name Busy_System_Ticks_Rate_View or by using the name defined by the tags &#x3c;busySystemTicksRate&#x3e;&#x3c;/busySystemTicksRate&#x3e; to access the rate calculating definition.</p>
<p id="p-0047" num="0060">Select queries and views can involve complex processing. For example, the following data inquiry definition <b>142</b> defines a view for obtaining metric values and processing them to compute the percent CPU usage between adjacent records of the table <b>300</b>:</p>
<p id="p-0048" num="0061">&#x3c;CPUUsage&#x3e;
<ul id="ul0009" list-style="none">
    <li id="ul0009-0001" num="0000">
    <ul id="ul0010" list-style="none">
        <li id="ul0010-0001" num="0062">CREATE VIEW CPU_Usage_View AS SELECT</li>
        <li id="ul0010-0002" num="0063">a.objectID AS objectID,</li>
        <li id="ul0010-0003" num="0064">a.timestamp AS timestamp,</li>
        <li id="ul0010-0004" num="0065">((a.busySystemTicks+a.busyUserTicks+a.waitTicks&#x2212;(b.busySystemTicks+b.busyUserTicks+b.waitTicks))*100/(a.busySystem Ticks+a.busyUserTicks+a.idleTicks+a.waitTicks&#x2212;(b.busySystemTicks+b.busyUserTicks+b.idleTicks+b.waitTicks))) AS SP_Percent</li>
        <li id="ul0010-0005" num="0066">FROM SP_performance a, SP_performance b WHERE a.recordID==(b.recordID+1) AND a.objectID==b.objectID</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0049" num="0067">&#x3c;/CPUUsage&#x3e;</p>
<p id="h-0007" num="0000">The processing included in the example above is easily read and modified, as it is human-readable and persists in an uncompiled state.</p>
<p id="p-0050" num="0068">The uncompiled file <b>140</b> may include a large number of data inquiry definitions <b>142</b> of varying levels of complexity. Some of the data inquiry definitions <b>142</b> simply report raw metric values, whereas others perform calculations and/or statistics.</p>
<p id="p-0051" num="0069">Although the data inquiry definitions <b>142</b> can be implemented as select queries or views, and may in some examples include both, it is generally preferred that the data inquiry definitions <b>142</b> use views rather than select queries, as views are typically more flexible. Unlike select queries, views can include other views by name, a feature that allows code to be simpler and more easily debugged and understood. For example, the following sequence of views can be defined:</p>
<p id="p-0052" num="0070">CREATE VIEW v1 AS SELECT . . . FROM tablet, table2 WHERE . . .</p>
<p id="p-0053" num="0071">CREATE VIEW v2 AS SELECT . . . FROM table3, table4 WHERE . . .</p>
<p id="p-0054" num="0072">CREATE VIEW v3 AS SELECT . . . FROM v1, v2 WHERE . . .</p>
<p id="p-0055" num="0073">CREATE VIEW v4 AS SELECT . . . FROM v1, v2 WHERE . . .</p>
<p id="p-0056" num="0074">CREATE VIEW v5 AS SELECT . . . FROM v3, v4 WHERE . . .</p>
<p id="p-0057" num="0075">Each of these view definitions is manageable and relatively easy to understand. In contrast, the equivalent select query for view v5, for example, would be extremely complex, difficult to read, and difficult to debug. Also, the select query would not include modular elements that could be reused in other data inquiry definitions <b>142</b>.</p>
<p id="p-0058" num="0076">It is evident from these examples that the database language instructions for the data inquiry definitions <b>142</b> can be arbitrarily complex. They can include multiple tables, multiple records, and a wide range of mathematical operations. These operations are prone to programming errors and may not work properly in all cases even after they are initially debugged. Providing the data inquiry definitions <b>142</b> outside the compiled library <b>130</b> greatly simplifies software development and maintenance, as any errors can be readily addressed in the uncompiled file <b>140</b>, without having to recompile the library <b>130</b>.</p>
<p id="p-0059" num="0077">Also, providing computations in the data inquiry definitions <b>142</b> allows the uncompiled software constructs <b>132</b> to be kept relatively simple and uniform. Each uncompiled software construct <b>132</b> can be written using a SELECT statement that specifies a data inquiry definition <b>142</b> in its FROM designator. The complexities of selecting metric values and processing them are therefore exported to the uncompiled file <b>140</b>. Further simplifications can be achieved by writing the data inquiry definitions <b>142</b> with views, which are usually easy to read and can be incorporated modularly in the definitions of other views in the uncompiled file <b>140</b>.</p>
<p id="p-0060" num="0078">In some examples, still further simplifications can be achieved by providing only a single compiled software construct <b>132</b> for accessing all of the data inquiry definitions <b>142</b>. Here, the compiled software construct <b>132</b> includes a generic template having one or more database language instructions applicable to any data inquiry definition. Different metrics or computations can be reported through the single compiled software construct <b>132</b>, thus further simplifying the compiled code and reducing the labor and complexity of code maintenance.</p>
<p id="p-0061" num="0079">In other examples, only a small number of compiled software constructs <b>132</b> are provided, e.g., one for each type of processing. For instance, one compiled software construct <b>132</b> can be provided for data inquiry definitions structured as select queries, whereas another compiled software construct <b>132</b> can be provided for data inquiry definitions structured as views.</p>
<p id="p-0062" num="0080"><figref idref="DRAWINGS">FIG. 4</figref> shows a process <b>400</b> for obtaining information about a data storage system <b>120</b>. The process <b>400</b> may be carried out in connection with the computing environment <b>100</b> and is typically performed by the software constructs described in connection with <figref idref="DRAWINGS">FIGS. 1 and 2</figref>, which reside in the memory <b>222</b> of the computing system <b>210</b> and are run by the set of processors <b>220</b>.</p>
<p id="p-0063" num="0081">The process <b>400</b> is conducted among the administrative server <b>232</b>, the compiled library <b>130</b>, the uncompiled file <b>140</b>, and the database <b>230</b>. The process <b>400</b> involves obtaining data inquiry definitions <b>142</b> from the uncompiled file <b>140</b> and using the definitions <b>142</b> in querying the database <b>230</b>.</p>
<p id="p-0064" num="0082">At event <b>410</b>, the administrative server <b>232</b> is started, generally when the computing system <b>210</b> is booted or at a later time at the request of the user <b>110</b>. After starting, at event <b>412</b>, the administrative server <b>232</b> sends an instruction to the compiled library <b>130</b> to obtain all of the data inquiry definitions <b>142</b>. At event <b>414</b>, the compiled library <b>130</b> accesses the uncompiled file <b>140</b>, retrieves the data inquiry definitions <b>142</b>, and, at event <b>416</b>, receives the data inquiry definitions <b>142</b> from the uncompiled file <b>140</b>.</p>
<p id="p-0065" num="0083">At some later time, designated as event <b>418</b>, the administrative server <b>232</b> receives a command that includes a request for metric information. The command is generally received from the client program in response to an action from the user <b>110</b>, such as a request for information about an object of the data storage system <b>120</b>. At event <b>420</b>, the administrative server <b>232</b> sends a request for the particular information to the compiled library <b>130</b>. For example, the administrative server <b>232</b> may identify the metric or object about which information is requested and access a compiled software construct <b>132</b> in the compiled library <b>130</b>. The compiled software construct <b>132</b> may be specific to the metric or object requested, or it may be provided in a more generic form applicable to many metrics or objects. At event <b>422</b>, the compiled software construct <b>132</b> sends a database language instruction to the database <b>230</b>. The database language instruction includes one of the data inquiry definitions <b>142</b> received at event <b>416</b>. For example, the database language instruction sent to the database <b>230</b> may include an SQL instruction of the form,
<ul id="ul0011" list-style="none">
    <li id="ul0011-0001" num="0000">
    <ul id="ul0012" list-style="none">
        <li id="ul0012-0001" num="0084">SELECT &#x3c;fields&#x3e; FROM &#x3c;source&#x3e; WHERE &#x3c;criteria&#x3e; ORDER BY&#x3c;one of the fields&#x3e; &#x3c;direction&#x3e; LIMIT &#x3c;maximum number of records&#x3e;,
<br/>
where the data inquiry definition <b>142</b> is supplied as the &#x201c;source&#x201d; for the FROM designator.
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0066" num="0085">At event <b>424</b>, the database <b>230</b> runs the database language instruction and produces a result including a set of matching records. At event <b>426</b>, the result is sent back to the compiled software construct <b>132</b> within the library <b>130</b>. At event <b>428</b>, the compiled software construct <b>132</b> performs minimal, if any, post-processing on the result. The post-processed result (or simply the result) is sent back to the administrative server <b>232</b> (event <b>430</b>) and then may be sent back to the computing device <b>112</b>, for presentation to the user <b>110</b>.</p>
<p id="p-0067" num="0086">The various acts of the process <b>400</b> may be ordered in any suitable way. Accordingly, embodiments may be constructed in which acts are performed in orders different from those illustrated, which may include performing some acts simultaneously, even though the acts are shown as sequential in the illustrated embodiments.</p>
<p id="p-0068" num="0087">In certain embodiments, the data inquiry definitions <b>142</b> are not retrieved before the user <b>110</b> requests information but rather after. When the compiled library <b>130</b> receives a request for metric information (as in event <b>420</b>), a compiled software construct <b>132</b> retrieves the needed data inquiry definition <b>142</b> from the uncompiled file <b>140</b>, effectively as needed and on demand.</p>
<p id="p-0069" num="0088">An improved technique for acquiring information about a data storage system <b>120</b> has been described that employs one or more compiled software constructs <b>132</b> and an uncompiled file <b>140</b> external to the compiled software constructs <b>132</b> that stores data inquiry definitions <b>142</b>. The data inquiry definitions <b>142</b> can be arbitrarily complex and can be written to perform tasks previously performed within compiled software classes. Using this technique, the compiled software constructs <b>132</b> can be kept comparatively simple and uniform, with the complex aspects of selecting and processing data provided externally, in an uncompiled file <b>140</b>, which is comparatively easy to write and maintain.</p>
<p id="p-0070" num="0089">As used throughout this document, the words &#x201c;comprising,&#x201d; &#x201c;including,&#x201d; and &#x201c;having&#x201d; are intended to set forth certain items, steps, elements, or aspects of something in an open-ended fashion. Although certain embodiments are disclosed herein, it is understood that these are provided by way of example only and the invention is not limited to these particular embodiments.</p>
<p id="p-0071" num="0090">Having described one embodiment, numerous alternative embodiments or variations can be made. For example, the improvement or portions thereof may be embodied as a non-transient computer-readable storage medium, such as a magnetic disk, magnetic tape, compact disk, DVD, optical disk, flash memory, Application Specific Integrated Circuit (ASIC), Field Programmable Gate Array (FPGA), and the like (shown by way of example as medium <b>450</b> in <figref idref="DRAWINGS">FIG. 4</figref>). Multiple computer-readable media may be used. The medium (or media) may be encoded with instructions which, when executed on one or more computers or other processors, perform methods that implement the various processes described herein. Such medium (or media) may be considered an article of manufacture or a machine, and may be transportable from one machine to another.</p>
<p id="p-0072" num="0091">Those skilled in the art will therefore understand that various changes in form and detail may be made to the embodiments disclosed herein without departing from the scope of the invention.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for obtaining information about a data storage system, comprising:
<claim-text>receiving a request for information from a data storage application;</claim-text>
<claim-text>executing, in response to the request, a compiled software construct to retrieve from a database a set of metrics indicative of performance of the data storage system, the compiled software construct including a database language instruction, the database language instruction including a reference to a data inquiry definition stored in an uncompiled file external to the compiled software construct;</claim-text>
<claim-text>sending the database language instruction, including the data inquiry definition, to the database, to execute the database language instruction on the database and produce a result;</claim-text>
<claim-text>receiving the result of the database language instruction by the compiled software construct; and</claim-text>
<claim-text>returning the information to the data storage application based on the result of the database language instruction,</claim-text>
<claim-text>wherein a first field of the database stores metric values of the data storage system and a second field of the database stores time values indicating when respective metric values stored in the first field of the database were obtained,</claim-text>
<claim-text>wherein the data inquiry definition in the uncompiled file includes an arithmetic operation to be applied between a first record and a second record of the database, the first record and the second record of the database each including a value for the first field and a value the second field, and</claim-text>
<claim-text>wherein the arithmetic operation includes:
<claim-text>subtracting a value of the first field in the first record from a value of the first field in the second record to calculate a metric difference value,</claim-text>
<claim-text>subtracting a time value in the second field of the first record from a time value in the second field of the second record to calculate a time difference; and</claim-text>
</claim-text>
<claim-text>dividing the metric difference value by the time difference to calculate a metric rate of change.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method as recited in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the database language instruction of the compiled software construct includes a database language SELECT statement having a database language FROM designator that specifies the reference to the data inquiry definition.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method as recited in <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising:
<claim-text>opening the uncompiled file;</claim-text>
<claim-text>locating the data inquiry definition within the uncompiled file; and</claim-text>
<claim-text>inserting the data inquiry definition from the uncompiled file into the SELECT statement in the compiled software construct.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method as recited in <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the uncompiled file is a structured text file.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method as recited in <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the data inquiry definition in the uncompiled file includes an arithmetic operation to be applied between a first record and a second record of a table of the database, the first record and the second record storing metric values of the data storage system.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method as recited in <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the arithmetic operation includes subtracting a first value of a field in the first record from a second value of the same field in the second record to calculate a metric difference value.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method as recited in <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein a second field of the table of the database stores time values, and the arithmetic operation further includes:
<claim-text>subtracting a time value in the second field of the table of the first record from a time value in the second field of the table of the second record to calculate a time difference; and</claim-text>
<claim-text>dividing the metric difference value by the time difference to calculate a metric rate of change.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method as recited in <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the data inquiry definition in the uncompiled file includes a database language select query definition based on at least one table of the database storing metric values of the data storage system.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method as recited in <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the data inquiry definition in the uncompiled file includes a database language view definition based on at least one table of the database storing metric values of the data storage system.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method as recited in <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the database language view definition includes at least one database language select query definition.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method as recited in <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the database language view definition includes a reference to another database language view definition within the uncompiled file.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. A data storage system, comprising:
<claim-text>a set of processors; and</claim-text>
<claim-text>memory, coupled to the set of processors, the memory constructed and arranged to store instructions executable by the set of processors,</claim-text>
<claim-text>wherein the set of processors executing instructions from the memory forms a specialized circuit constructed and arranged to:
<claim-text>receive a request for information from a data storage application;</claim-text>
<claim-text>execute, in response to the request, a compiled software construct to retrieve from a database a set of metrics indicative of performance of the data storage system, the compiled software construct including a database language instruction, the database language instruction including a reference to a data inquiry definition, wherein to execute the compiled software construct includes to retrieve the data inquiry definition from an uncompiled file external to the compiled software construct;</claim-text>
<claim-text>send the database language instruction, including the data inquiry definition, to the database, to execute the database language instruction on the database and produce a result;</claim-text>
<claim-text>receive the result of the database language instruction by the compiled software construct; and</claim-text>
<claim-text>return the information to the data storage application based on the result of the database language instruction,</claim-text>
</claim-text>
<claim-text>wherein a first field of the database stores metric values of the data storage system and a second field of the database stores time values indicating when respective metric values stored in the first field of the database were obtained,</claim-text>
<claim-text>wherein the data inquiry definition in the uncompiled file includes an arithmetic operation to be applied between a first record and a second record of the database, the first record and the second record of the database each including a value for the first field and a value the second field and</claim-text>
<claim-text>wherein the arithmetic operation includes:
<claim-text>subtracting a value of the first field in the first record from a value of the first field in the second record to calculate a metric difference value,</claim-text>
<claim-text>subtracting a time value in the second field of the first record from a time value in the second field of the second record to calculate a time difference; and</claim-text>
<claim-text>dividing the metric difference value by the time difference to calculate a metric rate of change.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The data storage system as recited in <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the database language instruction of the compiled software construct includes a SELECT statement having a FROM designator that specifies the reference to the data inquiry definition.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The data storage system as recited in <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the data inquiry definition in the uncompiled file includes a database language view definition based on at least one table of the database storing metric values of the data storage system.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The data storage system as recited in <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the database language VIEW definition includes a reference to another database language view definition within the uncompiled file.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. A non-transitory computer readable medium including instructions which, when executed by a set of processors of a computing device, cause the set of processors to perform a method for obtaining information about a data storage system, comprising:
<claim-text>receiving a request for information from a data storage application;</claim-text>
<claim-text>executing, in response to the request, a compiled software construct to retrieve from a database a set of metrics indicative of performance of the data storage system, the compiled software construct including a database language instruction, the database language instruction including a reference to a data inquiry definition, wherein executing includes retrieving the data inquiry definition from an uncompiled file external to the compiled software construct;</claim-text>
<claim-text>sending the database language instruction, including the data inquiry definition, to the database, to execute the SQL instruction on the database and produce a result;</claim-text>
<claim-text>receiving the result of the database language instruction by the compiled software construct; and</claim-text>
<claim-text>returning the information to the data storage application based on the result of the database language instruction,</claim-text>
<claim-text>wherein a first field of the database stores metric values of the data storage system and a second field of the database stores time values indicating when respective metric values stored in the first field of the database were obtained,</claim-text>
<claim-text>wherein the data inquiry definition in the uncompiled file includes an arithmetic operation to be applied between a first record and a second record of the database, the first record and the second record of the database each including a value for the first field and a value the second field and</claim-text>
<claim-text>wherein the arithmetic operation includes:
<claim-text>subtracting a value of the first field in the first record from a value of the first field in the second record to calculate a metric difference value,</claim-text>
<claim-text>subtracting a time value in the second field of the first record from a time value in the second field of the second record to calculate a time difference; and</claim-text>
<claim-text>dividing the metric difference value by the time difference to calculate a metric rate of change.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The non-transitory computer readable medium as recited in <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the compiled software construct includes a compiled C++ class and wherein the uncompiled file is an XML file.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The non-transitory computer readable medium as recited in <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the data inquiry definition in the uncompiled file includes a database language view definition based on at least one table of the database storing metric values of the data storage system.</claim-text>
</claim>
</claims>
</us-patent-grant>
