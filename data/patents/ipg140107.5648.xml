<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08626749-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08626749</doc-number>
<kind>B1</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13090803</doc-number>
<date>20110420</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<us-term-of-grant>
<us-term-extension>41</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>30</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>707722</main-classification>
</classification-national>
<invention-title id="d2e53">System and method of analyzing encrypted data in a database in near real-time</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5963642</doc-number>
<kind>A</kind>
<name>Goldstein</name>
<date>19991000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713193</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6275824</doc-number>
<kind>B1</kind>
<name>O'Flaherty et al.</name>
<date>20010800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>  1  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6792425</doc-number>
<kind>B2</kind>
<name>Yagawa et al.</name>
<date>20040900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>  1  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>7302420</doc-number>
<kind>B2</kind>
<name>Aggarwal et al.</name>
<date>20071100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707688</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>7500111</doc-number>
<kind>B2</kind>
<name>Hacigumus</name>
<date>20090300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>7606788</doc-number>
<kind>B2</kind>
<name>Samar</name>
<date>20091000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>  1  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>7668820</doc-number>
<kind>B2</kind>
<name>Zuleba</name>
<date>20100200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707765</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>7672967</doc-number>
<kind>B2</kind>
<name>Fay</name>
<date>20100300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707999102</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>7685437</doc-number>
<kind>B2</kind>
<name>Hacigumus et al.</name>
<date>20100300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713193</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>7933909</doc-number>
<kind>B2</kind>
<name>Trepetin</name>
<date>20110400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707755</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>7958162</doc-number>
<kind>B2</kind>
<name>Basile</name>
<date>20110600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707804</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>8112422</doc-number>
<kind>B2</kind>
<name>Srivastava et al.</name>
<date>20120200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707737</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2002/0169793</doc-number>
<kind>A1</kind>
<name>Sweeney</name>
<date>20021100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707204</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2003/0046572</doc-number>
<kind>A1</kind>
<name>Newman et al.</name>
<date>20030300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713193</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>2003/0220927</doc-number>
<kind>A1</kind>
<name>Iverson et al.</name>
<date>20031100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707100</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>2004/0243799</doc-number>
<kind>A1</kind>
<name>Hacigumus et al.</name>
<date>20041200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713150</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>2005/0049991</doc-number>
<kind>A1</kind>
<name>Aggarwal et al.</name>
<date>20050300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00018">
<document-id>
<country>US</country>
<doc-number>2005/0147240</doc-number>
<kind>A1</kind>
<name>Agrawal et al.</name>
<date>20050700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>380 28</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00019">
<document-id>
<country>US</country>
<doc-number>2005/0147246</doc-number>
<kind>A1</kind>
<name>Agrawal et al.</name>
<date>20050700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>380 44</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00020">
<document-id>
<country>US</country>
<doc-number>2005/0268094</doc-number>
<kind>A1</kind>
<name>Kohan et al.</name>
<date>20051200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713165</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00021">
<document-id>
<country>US</country>
<doc-number>2005/0283621</doc-number>
<kind>A1</kind>
<name>Sato et al.</name>
<date>20051200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713189</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00022">
<document-id>
<country>US</country>
<doc-number>2006/0020611</doc-number>
<kind>A1</kind>
<name>Gilbert et al.</name>
<date>20060100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707100</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00023">
<document-id>
<country>US</country>
<doc-number>2007/0130106</doc-number>
<kind>A1</kind>
<name>Gadiraju</name>
<date>20070600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  2</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00024">
<document-id>
<country>US</country>
<doc-number>2007/0140479</doc-number>
<kind>A1</kind>
<name>Wang et al.</name>
<date>20070600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>380 30</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00025">
<document-id>
<country>US</country>
<doc-number>2007/0233711</doc-number>
<kind>A1</kind>
<name>Aggarwal et al.</name>
<date>20071000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707100</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00026">
<document-id>
<country>US</country>
<doc-number>2007/0255704</doc-number>
<kind>A1</kind>
<name>Baek et al.</name>
<date>20071100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  6</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00027">
<document-id>
<country>US</country>
<doc-number>2008/0082566</doc-number>
<kind>A1</kind>
<name>Aggarwal et al.</name>
<date>20080400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707102</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00028">
<document-id>
<country>US</country>
<doc-number>2008/0109459</doc-number>
<kind>A1</kind>
<name>Trepetin</name>
<date>20080500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707100</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00029">
<document-id>
<country>US</country>
<doc-number>2008/0114991</doc-number>
<kind>A1</kind>
<name>Jonas</name>
<date>20080500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713193</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00030">
<document-id>
<country>US</country>
<doc-number>2008/0133935</doc-number>
<kind>A1</kind>
<name>Elovici et al.</name>
<date>20080600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713193</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00031">
<document-id>
<country>US</country>
<doc-number>2009/0018820</doc-number>
<kind>A1</kind>
<name>Sato et al.</name>
<date>20090100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>704  9</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00032">
<document-id>
<country>US</country>
<doc-number>2009/0077378</doc-number>
<kind>A1</kind>
<name>Hacigumus et al.</name>
<date>20090300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713165</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00033">
<document-id>
<country>US</country>
<doc-number>2009/0132419</doc-number>
<kind>A1</kind>
<name>Grammer et al.</name>
<date>20090500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>705 50</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00034">
<document-id>
<country>US</country>
<doc-number>2009/0303237</doc-number>
<kind>A1</kind>
<name>Liu et al.</name>
<date>20091200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>345440</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00035">
<document-id>
<country>US</country>
<doc-number>2009/0327296</doc-number>
<kind>A1</kind>
<name>Francis et al.</name>
<date>20091200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  9</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00036">
<document-id>
<country>US</country>
<doc-number>2009/0327748</doc-number>
<kind>A1</kind>
<name>Agrawal et al.</name>
<date>20091200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713189</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00037">
<document-id>
<country>US</country>
<doc-number>2010/0042583</doc-number>
<kind>A1</kind>
<name>Gervais et al.</name>
<date>20100200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  3</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00038">
<document-id>
<country>US</country>
<doc-number>2010/0058476</doc-number>
<kind>A1</kind>
<name>Isoda</name>
<date>20100300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>726 26</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00039">
<document-id>
<country>US</country>
<doc-number>2010/0077006</doc-number>
<kind>A1</kind>
<name>El Emam et al.</name>
<date>20100300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707785</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00040">
<document-id>
<country>US</country>
<doc-number>2010/0114840</doc-number>
<kind>A1</kind>
<name>Srivastava et al.</name>
<date>20100500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707688</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00041">
<document-id>
<country>US</country>
<doc-number>2010/0114920</doc-number>
<kind>A1</kind>
<name>Srivastava et al.</name>
<date>20100500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707757</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00042">
<document-id>
<country>US</country>
<doc-number>2010/0192220</doc-number>
<kind>A1</kind>
<name>Heizmann et al.</name>
<date>20100700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>726 19</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00043">
<document-id>
<country>US</country>
<doc-number>2010/0241641</doc-number>
<kind>A1</kind>
<name>Byun et al.</name>
<date>20100900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707757</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00044">
<document-id>
<country>US</country>
<doc-number>2010/0281069</doc-number>
<kind>A1</kind>
<name>Stephenson et al.</name>
<date>20101100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707803</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00045">
<document-id>
<country>US</country>
<doc-number>2011/0179011</doc-number>
<kind>A1</kind>
<name>Cardno et al.</name>
<date>20110700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707709</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00046">
<document-id>
<country>US</country>
<doc-number>2011/0277037</doc-number>
<kind>A1</kind>
<name>Burke et al.</name>
<date>20111100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>726 26</main-classification></classification-national>
</us-citation>
<us-citation>
<nplcit num="00047">
<othercit>Sweeney, Latanya. Computational Disclosure Control: A Primer on Data Privacy Protection. Cambridge, MA: Massachusetts Institute of Technology, 2001.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00048">
<othercit>Wikipedia. &#x201c;Deterministic Encryption.&#x201d; Jul. 20, 2005.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00049">
<othercit>Wikipedia. &#x201c;Probabilistic Encryption.&#x201d; Sep. 3, 2005.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00050">
<othercit>Agrawal, Rakesh, Alexandre Evfimievski, and Ramakrishnan Srikant. &#x201c;Information Sharing Across Private Databases&#x201d; (Association for Computing Machinery, Special Interest Group on Management of Data, Jun. 9-12, 2003).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00051">
<othercit>Blakley, G.R., and Catherine Meadows. &#x201c;A Database Encryption Scheme which Allows the Computation of Statistics using Encrypted Data&#x201d; (IEEE Symposium on Security and Privacy, Apr. 22-24, 1985).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00052">
<othercit>Menezes, Alfred, Paul C. van Oorschot and Scott A. Vanstone. &#x201c;Chapter 1.&#x201d; Handbook of Applied Cryptography. Aug. 2001. 1-48.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00053">
<othercit>Menezes, Alfred, Paul C. van Oorschot, and Scott A. Vanstone. &#x201c;Chapter 7.&#x201d; Handbook of Applied Cryptography. Aug. 2001. 223-282.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00054">
<othercit>Menezes, Alfred, Paul C. van Oorschot, and Scott A. Vanstone. &#x201c;Chapter 8.&#x201d; Handbook of Applied Cryptography. Aug. 2001. 283-319.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00055">
<othercit>Menezes, Alfred, Paul C. van Oorschot, and Scott A. Vanstone. &#x201c;Chapter 9.&#x201d; Handbook of Applied Cryptography. Aug. 2001. 321-83.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00056">
<othercit>Fagin, Ronald, Moni Naor, and Peter Winkler. &#x201c;Comparing Information without Leaking It.&#x201d; Communications of the ACM, vol. 39 Issue 5 (May 1996): 77-85.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00057">
<othercit>Rivest, Ronald, L. Adleman, and M. L. Dertouzos. &#x201c;On Data Banks and Privacy Homomorphisms.&#x201d; In Foundations of Secure Computation, edited by R.A. DeMillo, 169-177. New York: Academic Press, Dec. 1978.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00058">
<othercit>Song, Dawn Xiaodong, David Wagner, and Adrian Perrig. &#x201c;Practical Techniques for Searches on Encrypted Data&#x201d; (IEEE Symposium on Security and Privacy, May 2000) 44-55.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00059">
<othercit>Domingo-Ferrer, Josep. &#x201c;A Provably Secure Additive and Multiplicative Privacy Homomorphism.&#x201d; In Lecture Notes in Computer Science 2433, edited by AH Chan, 471-483. London: Springer-Verlag, Sep. 2002.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00060">
<othercit>Chaum, David, Claude Crepeau, and Ivan Damgard. &#x201c;Multiparty Unconditionally Secure Protocols&#x201d; (Proceedings of the 20th Symposium on the Theory of Computing, May 1988).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00061">
<othercit>Chaum, David, Ivan Damgard, and Jeroen van de Graaf. &#x201c;Multiparty Computations Ensuring Privacy of Each Party's Input and Correctness of the Result.&#x201d; Lecture Notes in Computer Science, 293 (Aug. 1987): 87-119.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00062">
<othercit>Rivest, Ronald L. and Alan T. Sherman. &#x201c;Randomized Encryption Techniques.&#x201d;Advances in Cryptology: Proceedings of Crypto 82. David Chaum, Ronald L. Rivest, and Alan T. Sherman, eds., Plenum Press (New York) (Aug. 1982), 145-163.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>27</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>15</number-of-drawing-sheets>
<number-of-figures>15</number-of-figures>
</figures>
<us-related-documents>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61326405</doc-number>
<date>20100421</date>
</document-id>
</us-provisional-application>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Trepetin</last-name>
<first-name>Stan</first-name>
<address>
<city>New York</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Reston</last-name>
<first-name>Mark</first-name>
<address>
<city>Hillsborough</city>
<state>NJ</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Trepetin</last-name>
<first-name>Stan</first-name>
<address>
<city>New York</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Reston</last-name>
<first-name>Mark</first-name>
<address>
<city>Hillsborough</city>
<state>NJ</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<last-name>Cittone</last-name>
<first-name>Henry J.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<orgname>Cittone &#x26; Chinta LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<examiners>
<primary-examiner>
<last-name>Bhatia</last-name>
<first-name>Ajay</first-name>
<department>2157</department>
</primary-examiner>
<assistant-examiner>
<last-name>Park</last-name>
<first-name>Grace</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">The present invention relates generally to a system and method of querying an anonymized database. More particularly, the invention provides a method and system for querying an anonymized database without the need to decrypt queried data while it's processed. Even more specifically, the invention provides a method and system of anonymizing a database such that it may be queried efficiently in near real time while still retaining the ability to not decrypt requested data while it's being processed.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="227.67mm" wi="184.23mm" file="US08626749-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="245.11mm" wi="191.09mm" file="US08626749-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="178.22mm" wi="197.02mm" file="US08626749-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="198.97mm" wi="195.41mm" file="US08626749-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="203.62mm" wi="168.66mm" file="US08626749-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="128.86mm" wi="129.12mm" file="US08626749-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="106.43mm" wi="147.91mm" file="US08626749-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="163.75mm" wi="139.70mm" file="US08626749-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="187.11mm" wi="140.04mm" file="US08626749-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="238.51mm" wi="187.45mm" file="US08626749-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="134.45mm" wi="179.58mm" file="US08626749-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="244.18mm" wi="185.17mm" file="US08626749-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="245.11mm" wi="191.09mm" file="US08626749-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="177.63mm" wi="189.48mm" file="US08626749-20140107-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="205.91mm" wi="186.77mm" file="US08626749-20140107-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="239.52mm" wi="189.48mm" file="US08626749-20140107-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">This application claims the benefit of U.S. Provisional Patent Application 61/326,405, filed Apr. 21, 2010, the disclosure of which is hereby incorporated by reference in its entirety.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">FIELD OF THE INVENTION</heading>
<p id="p-0003" num="0002">The present invention relates generally to a system and method of querying an anonymized database. More particularly, the invention provides a method and system for querying an anonymized database without the need to decrypt queried data. Even more specifically, the invention provides a method and system of anonymizing a database such that it may be queried efficiently while still retaining the ability to not decrypt requested data.</p>
<heading id="h-0003" level="1">BACKGROUND</heading>
<p id="p-0004" num="0003">As the amount of digital data created and processed by organizations continues to increase, the need to query and secure those data also grow. Data is thus often encrypted to secure it from improper access. A problem arises when the data is required for use by the proprietor or other legitimate users of the database. In order to perform an operation on encrypted data, it is typically requested from the database, decrypted, and only then can the operation be run, after which the results must be encrypted and returned to the database. The decryption and encryption steps consume vast amounts of processing resources, resulting in significant delays when working with encrypted data.</p>
<p id="p-0005" num="0004">Typical architectures are network-based (e.g., client-server) database architectures. Multiple users, each with their own workstation, are trying to retrieve records from a central database. Typically, because the database is encrypted, the database private key, used for data encryption and decryption purposes, is kept on a network drive shared among the client machines. The client machines load the key from the shared network drive.</p>
<p id="p-0006" num="0005">Some existing methods attempt to address data decryption issues by performing operations on encrypted data directly. However these prior methods suffer from the inability to offer virtually the same performance as users are accustomed to today when running against unencrypted data. In addition, these prior methods do not offer robust analytical capabilities over encrypted data.</p>
<p id="p-0007" num="0006">Thus what is needed is a new encryption system and method capable of querying anonymized electronic databases and obtaining the same results as if performing the queries against the original, unencrypted data all while being done with little actual impact to query speed. As described, our approach considerably differs from typical database operations over encrypted data today. In most of the current schemes, data must be typically decrypted before queries can be run against them. We break with this limitation by permitting queries and analysis over encrypted data.</p>
<heading id="h-0004" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0008" num="0007">According to an exemplary embodiment of the present invention, a method and system which allows the querying of anonymized electronic databases while obtaining the same results as if performing the queries against the original, unencrypted data with little actual impact to query speed is provided.</p>
<p id="p-0009" num="0008">According to another exemplary embodiment of the present invention, a method and system is provided which provides anonymization of data, methods to analyze the anonymized data, and a retrieval mechanism that returns the correct (unciphered) response to a user's query.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. 1</figref> is a depiction of a system and method of identifying 5-element groups and as well as the number of tokens needed to &#x201c;equalize&#x201d; each token's frequency to that of its 5-element group's leader.</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 2</figref> is a depiction of a system and method of creating false rows based on the maximum number of &#x201c;rows needed&#x201d; across all the 5-element groupings created across all the string columns.</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 3</figref> is a depiction of a system and method of identifying 5-element groupings of individual character positions within strings and as well as the number of characters needed to &#x201c;equalize&#x201d; each position's frequency to that of its 5-element group's leader.</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 4</figref> is a depiction of a system and method of creating false rows based on the maximum number of &#x201c;rows needed&#x201d; across all the 5-element groupings of character positions in strings created across all the character positions within a given string column.</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 5</figref> is a depiction of a system and method of beginning to properly create false tokens based on substitution, as required in 5-element groupings for a specific column.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 6</figref> is a depiction of a system and method of the resulting substitutions after tokens have been &#x201c;equalized&#x201d; within their 5-element groupings (e.g. the culmination of <figref idref="DRAWINGS">FIG. 5</figref>).</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 7</figref> is a depiction of a system and method of beginning to properly create false characters based on substitution, as required in 5-element groupings of character positions for a specific column.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 8</figref> is a depiction of a system and method of the resulting substitutions after character positions have been &#x201c;equalized&#x201d; within their 5-element groupings (e.g. the culmination of <figref idref="DRAWINGS">FIG. 7</figref>).</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 9</figref> is a depiction of a system and method of encoding the string lengths of a single &#x201c;true&#x201d; row.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 10</figref> is a depiction of a system and method of constructing a sample X<b>1</b> table, used for JOINing two anonymized tables.</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIGS. 11A-C</figref> are a depiction of a system and method of decoding a small result set on a client machine.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIGS. 12A-B</figref> are a depiction of a system and method of showing how an INNER JOIN can be performed between two anonymized tables involving the X<b>1</b> table (shown in <figref idref="DRAWINGS">FIGS. 11A-C</figref>).</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0006" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0022" num="0021">In order to provide near real-time querying of encrypted databases, modules are provided to perform the necessary hardware and software functions to allow querying of encrypted databases without first decrypting the data. The modules are preferably implemented by software means, but may also be implemented by firmware or a combination of firmware and software. Preferably the database is housed on a server computer which is networked to one or more client computers or devices. When the database is anonymized in accordance with embodiments of the present invention, it does not require that it be decrypted prior to conducting analysis. To the contrary, SELECTs, UPDATEs, and various mathematical computations, can be done on the encrypted data and correct results returned to clients, after which they can be decrypted on the client. Thus, encrypted queries can be performed in near real-time. To accomplish near real time queries, queries are anonymized before being submitted to the server and anonymized results are then decrypted before being presented back to the user.</p>
<p id="p-0023" num="0022">Certain preferred embodiments of the present invention are now described. As a first step, the database must be anonymized. For string values, this method securely anonymizes data at the level of individual characters yet allows for general queries and pattern matching to take place over the anonymized strings. For numbers, this method mathematically transforms values into obfuscated numeric values which will still allow some numerical computations to be done on the server while the rest of the calculations can be completed on the client. Maintaining almost the same speed of query performance is accomplished through the use of indexes. The encoding of strings and numbers involves normal textual and mathematical manipulations, allowing the full use of indexing as on normal, unencrypted databases.</p>
<p id="p-0024" num="0023">The anonymization process works on a single database table at a time. It anonymizes all columns, not just those with &#x201c;sensitive&#x201d; fields such as Social Security Number or Last Name. Anonymizing all columns prevents the table from being subject to re-identification attacks which focus just on non-sensitive fields. String columns are handled differently from numeric column.</p>
<p id="p-0025" num="0024">Now described is the anonymization of strings in accordance with embodiments of the present invention. Every value in a string column is separated into its individual characters. The method deterministically encrypts each character&#x2014;i.e., transforms the same character into the same encoded character every time&#x2014;but in a special way. Simply deterministically anonymizing such characters without any special treatment would immediately subject the anonymized data to a frequency analysis attack.</p>
<p id="p-0026" num="0025">Now described are embodiments of the present invention presented by way of examples, including the worst-case scenario example of an intruder who has access to an unencrypted static copy of the original database. However, the embodiments of the present invention are not limited to protecting data from such an intruder and are able to afford similar or greater protection from other forms of intrusion, including insider threats, and outside threats who lack a copy of the original database. Thus, if an intruder obtained a copy of the original database, she could compute the frequency of any character in it. The frequency of the enciphered character will be the same due to the deterministic nature of the anonymization (transforming the same character into the same encoding every time), leading to fairly straightforward re-identification of characters. This re-identification is obviated by combining a deterministic process with the generation of a significant number of database records which contain appropriately created fake strings. The intruder will be significantly less able to carry out a frequency analysis attack because the randomly created characters will hide the frequencies of the original characters. A further layer of security is added by breaking the anonymized table into many independent &#x201c;groups&#x201d; and coding each character position within each column and each group independently. Such encoding also disrupts the intruder's ability to carry out a frequency analysis attack because across groups and across different character positions, the same characters will have different encodings. Finally, the fake records will also prevent re-identification of original string values when the intruder is observing the number of rows being returned after various queries complete processing. That is, one wants to prevent an intruder from learning identifiers by seeing result set sizes. In result sets of embodiments of the present invention, fake records will be returned intermixed with real records. Thus, simply looking at the number of rows returned will not facilitate re-identification because result set sizes will not reflect accurate row counts related to the original queries.</p>
<p id="p-0027" num="0026">Numeric values are protected by placing their records into the newly created groups, too. A mathematical function with different anonymization parameters for each numeric column and each group will be used to encode each numeric value. The randomization of the numeric values into groups, the fake rows which will also hide the frequency of the numeric values, and the randomness of the parameters used when computing the mathematical function will make it very difficult for an attacker to re-identify any of the numeric values he may see as well.</p>
<p id="p-0028" num="0027">Preferably, anonymization is carried out in a series of steps in accordance with a preferred embodiment of the present invention described herein:</p>
<p id="p-0029" num="0028">Anonymization Step 0 involves identifying the original database (&#x201c;ODB&#x201d; also referring to the original database possessed by the hypothetical intruder) and tables. The ODB typically consists of one or more tables, O<b>1</b> . . . Op. The ODB is transformed into the anonymized database ADB which will consist of the anonymized tables A<b>1</b> . . . Ap. The anonymization process works on each table using various temporary tables for the transformation. The transformation of an exemplary table O<b>1</b> is now described which is converted into an exemplary anonymized table A<b>1</b>.</p>
<p id="p-0030" num="0029">Anonymization Step 1 involves identifying all the alphanumeric symbols that make up the original database. The alphanumeric symbols will be used to anonymize the original database to preserve the data schema so as to not interfere with the operations of database applications. This step in the anonymization process involves asking the ODB owner, or scanning the tables O<b>1</b> . . . Op directly, to identify the symbol sets that make up the various columns in the ODB tables. This set, comprised of, for example, the letters a-z, the letters A-Z, basic punctuation marks, and digits 0-9, is stored in table V<b>1</b>. V<b>1</b> is used to construct the data encoding/decoding keys and for several other purposes as will be described below. The same alphanumeric symbols are used during the anonymization process as the original plaintext symbols so as to not interfere with the current database applications.</p>
<p id="p-0031" num="0030">Anonymization Step 2 sets the number of groups into which the anonymized table will be divided. The more groups the stronger the security as each group gets its own encoding/decoding key. Preferably, the number of initial groups is set to five. The number of groups is preferably automatically expanded to about 30 groups in subsequent Anonymization Steps. That is, the next step in the anonymization process, Anonymization Step 2, sets the number of groups into which O<b>1</b> will be divided. The more groups created the stronger the anonymization is because the rows in each group will get their own encoding key. (The more groups that are created, in fact, the closer the scheme approaches to that of a random pad). In this embodiment of the present invention, it is recommended to set the number of groups to 5 for any table to be anonymized because additional groups, e.g., more security, will automatically be created in subsequent Anonymization Steps. Based on later Anonymization Steps, 5 groups will be doubled to 10 groups as new &#x201c;true&#x201d; groups (i.e. those containing the original data from the ODB) are formed to prevent frequency analysis attacks on strings and characters within groups, as will be shown in Anonymization Steps 5 and 6. The group count of 10 will then be increased to a group count of about 30 as about 20 &#x201c;false&#x201d; groups (i.e. those containing the fake rows the anonymization process introduces) will be added to the table, too. These false groups make it very difficult to carry out a frequency analysis attack on strings and characters on the whole table, as will be shown in Anonymization Steps 7 through 9.</p>
<p id="p-0032" num="0031">In embodiments of the present invention it is also possible to set the initial group number even higher, this generates an even higher final total group count, hence making A<b>1</b> even more secure with minimal loss of performance. Increasing the number of groups in our own testing has, so far, only shown small performance differences.</p>
<p id="p-0033" num="0032">In Anonymization Step 3 anonymizing the first database table by copying it into a temporary table is performed. Besides the original table's columns, the temporary table introduces special columns so that client workstations can properly query the anonymized data after anonymization. Separate the temporary table into the initial number of groups as configured in Anonymization Step 2. That is, in Anonymization Step 3, O<b>1</b> is copied into temporary table B<b>1</b>. Special columns are introduced in B<b>1</b> to allow for client machines to subsequently query the anonymized data. The first column added, GpNum, holds the number of the group to which a given row belongs. Among other things, this column is used to discard rows from result sets that belong to false groups and retain rows that belong to true groups. The second column added, RecInfo, contains the lengths of each string value in that row, encoded as a character within V<b>1</b>. This column is used to trim string values in result sets so that the string values with proper original lengths can be shown to the user after they are returned to the client from the server. The third column added, RowNum, is a counter representing the row number for the row. Among other things, it is used to determine if a numeric value in a result set row was originally an outlier so that its proper outlier value may be restored before it's shown to the user.</p>
<p id="p-0034" num="0033">Next, B<b>1</b> is divided into the initial number of groups (for example, 5) as set in Anonymization Step 2. Substantially the same number of rows in each group in the anonymized table is maintained so that differing group row counts do not assist an intruder in any of his or her re-identification efforts. Hence, the GpNums of B<b>1</b>'s rows are updated to roughly evenly divide them among all possible initial true groups.</p>
<p id="p-0035" num="0034">Table R<b>1</b> is also created in this Anonymization Step. This table is used to process the DELETE command in the scheme. R<b>1</b> will hold the RowNums for those rows that are scheduled for deletion, and any rows in R<b>1</b> will not be incorporated into any application query against the anonymized database because the rows will ultimately be erased.</p>
<p id="p-0036" num="0035">Anonymization Step 4 creates uniform length strings within every string column so that anonymized values can't be guessed due to their lengths. Preferably, a uniform relative length is created for all the values in every string column. Thus, an intruder would not be able to compare his O<b>1</b> copy to A<b>1</b> and identify records in A<b>1</b> due to equal string lengths. To create uniform lengths in each column, the length of its longest string is computed. Then every string value in the column is padded with itself, character by character, in order, wrapping back to the beginning after the end of the string is reached, until the total length equals the identified maximum length. Finally, the RecInfo column for each row in B<b>1</b> is set to indicate it's a &#x201c;true&#x201d; row as these rows are copies of the original O<b>1</b> values.</p>
<p id="p-0037" num="0036">Anonymization Step 5: to make a frequency analysis attack on characters or strings within groups more difficult, rows having the most popular leading characters in a strategically chosen string column are exchanged with rows from randomly chosen groups. Preferably, this involves a potential &#x201c;re-grouping&#x201d; of the rows in B<b>1</b> to prevent a character or string frequency analysis attack within groups. A column having the most popular values within B<b>1</b> is chosen and used as the basis for identifying popular strings that can be moved to other groups. Such a column is used as the basis for segregation because in a frequency analysis attack its values can be more easily recognized. An intruder could try to map its unique values to the same unique values in his O<b>1</b> copy. However, moving the popular and therefore more identifiable values of this column to other groups better hides those values. If no uniquely-valued column exists in B<b>1</b> and the distribution of values in all string columns is equivalent, a random column for segregation purposes is chosen. Within each group, when examining the most uniquely-valued column, rows containing characters in the first position that are significantly more frequent than characters in the first position of other rows are identified. The larger sets of these popular rows are broken into smaller sets and each such smaller set is moved to randomly selected groups. Rows from the random receiving groups are moved into the group currently analyzed. The reason for breaking up sets of rows before moving them is to prevent the popularity of the leading characters in the uniquely-valued column from arising within new groups. At the same time, we keep the number of rows in all groups relatively equal to prevent the insider from guessing which rows have more popular characters based on different group row counts.</p>
<p id="p-0038" num="0037">The following is an exemplary illustration of this Anonymization Step 5. Imagine B<b>1</b> has 200 rows and is comprised of 20 groups, each having 10 rows. The column last_name is the most uniquely identifying column and we are working with group 12. A histogram of the first position of the last_name column of group 12's rows shows that there are 3 T's, 3 H's, 2 R's, 1 W, and 1 F in that character position (representing 10 rows). In this illustration the anonymization process utilizes the median to identify popular characters. In this case, the T's and H's are &#x201c;popular&#x201d; because their frequencies are above the median. The set of 3 rows associated with the T's are broken into random smaller sets, say one having 2 rows and another having 1 row. We pick one random group in 20 into which to move the 2-row set into; say we pick group 17. The GpNum values of the 2-row set are changed to 17. At the same time, the GpNum value of 2 random rows from group 17 is changed to 12, to preserve row counts in groups. Likewise, we randomly pick a group to move the 1-row set into; say group 2. The GpNum value of this row is changed to 2. Also the GpNum value of 1 random row from group 2 is changed to 12. The same random separation and exchange happens with the rows having the leading H's in their last_name column as well.</p>
<p id="p-0039" num="0038">Anonymization Step 6: to make re-identifying characters or strings more difficult within groups, three strategically chosen columns are selected. All the rows found by identifying the most popular leading characters of the three columns are moved to newly created groups to dilute the popularity of string values. This step in the anonymization process is to create new groups for rows having popular string values across several uniquely-valued columns. Like in Anonymization Step 5, an intruder could also identify popular string values by combining several of the most uniquely identifying columns and mapping the implicated identifiers to his O<b>1</b> copy, thereby facilitating the re-identification of the unique anonymized values. Thus, this step identifies columns which contain the most unique values to separate the popular rows from the unpopular ones. The popular rows are then moved out into new groups. As an example, three columns are picked that, when combined, will produce the most unique possible values in B<b>1</b>. Note, if no uniquely-valued columns exist in B<b>1</b> and the distribution of values in all string columns is equivalent, three random columns for segregation purposes are chosen. (In testing, the Last Name, First Name, and Diagnosis columns contained the most such unique values). A combined histogram of the first and second character of each of the three string values across the three columns is built. From every set of high-frequency rows within the groupings, the number of rows equal to the median frequency of the histogram, or the first frequency found above the median, is moved to newly created groups. By removing a substantial chunk of popular rows from a group, we further disable the intruder's ability to identify the frequencies of unique string values within groups because those frequencies have been substantially undercut. At the same time, the newly-created groups contain rows with identical frequency counts of the character groupings just described. They become also essentially indistinguishable from a re-identification perspective because within the receiving groups the frequencies of their key string values are the same.</p>
<p id="p-0040" num="0039">The following is an illustration of this Anonymization Step. Imagine B<b>1</b> has 200 rows and is comprised of 20 groups, having 10 rows in each group. The columns last_name, first_name, and diagnosis are the most uniquely-identifying columns in B<b>1</b>. Suppose we are working with group 8. Table 1 below shows a combined histogram of the 1st and 2nd position of column last_name, the 1st and 2nd position of column first_name, and the 1st and 2nd position of column diagnosis:</p>
<p id="p-0041" num="0040">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="8">
<colspec colname="1" colwidth="35pt" align="center"/>
<colspec colname="2" colwidth="35pt" align="center"/>
<colspec colname="3" colwidth="35pt" align="center"/>
<colspec colname="4" colwidth="35pt" align="center"/>
<colspec colname="5" colwidth="35pt" align="center"/>
<colspec colname="6" colwidth="35pt" align="center"/>
<colspec colname="7" colwidth="21pt" align="center"/>
<colspec colname="8" colwidth="28pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="8" rowsep="1">TABLE 1</entry>
</row>
<row>
<entry namest="1" nameend="8" align="center" rowsep="1"/>
</row>
<row>
<entry>1<sup>st </sup>pos. </entry>
<entry>2<sup>nd </sup>pos.</entry>
<entry>1<sup>st </sup>pos.</entry>
<entry>2<sup>nd </sup>pos.</entry>
<entry>1<sup>st </sup>pos.</entry>
<entry>2<sup>nd </sup>pos.</entry>
<entry/>
<entry/>
</row>
<row>
<entry>last_name </entry>
<entry>last_name</entry>
<entry>first_name</entry>
<entry>first_name</entry>
<entry>diagnosis</entry>
<entry>diagnosis</entry>
<entry>freq.</entry>
<entry>GpNum</entry>
</row>
<row>
<entry namest="1" nameend="8" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>s</entry>
<entry>m</entry>
<entry>j</entry>
<entry>o</entry>
<entry>c</entry>
<entry>a</entry>
<entry>3</entry>
<entry>8</entry>
</row>
<row>
<entry>s</entry>
<entry>m</entry>
<entry>m</entry>
<entry>a</entry>
<entry>d</entry>
<entry>i</entry>
<entry>2</entry>
<entry>8</entry>
</row>
<row>
<entry>j</entry>
<entry>o</entry>
<entry>m</entry>
<entry>i</entry>
<entry>d</entry>
<entry>i</entry>
<entry>2</entry>
<entry>8</entry>
</row>
<row>
<entry>h</entry>
<entry>o</entry>
<entry>s</entry>
<entry>t</entry>
<entry>h</entry>
<entry>i</entry>
<entry>1</entry>
<entry>8</entry>
</row>
<row>
<entry>p</entry>
<entry>o</entry>
<entry>l</entry>
<entry>i</entry>
<entry>c</entry>
<entry>a</entry>
<entry>1</entry>
<entry>8</entry>
</row>
<row>
<entry>f</entry>
<entry>r</entry>
<entry>r</entry>
<entry>o</entry>
<entry>c</entry>
<entry>o</entry>
<entry>1</entry>
<entry>8</entry>
</row>
<row>
<entry namest="1" nameend="8" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0042" num="0041">The median in the frequency column is 1.5 and the first frequency greater than this number is 2. We create a new group to transfer the popular rows to. For example, we create group 24. Therefore, 2 of the 3 rows from group 8 matching the first grouping in the table 1 above have their GpNum values changed to 24 in table 2 below. Similarly, both rows from group 8 matching the second grouping in the table above have their GpNum values changed to 24. Finally, both rows from group 8 matching the third grouping in the table above have their GpNum values changed to 24. Table 2 below shows the histogram of the results after this transformation:</p>
<p id="p-0043" num="0042">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="8">
<colspec colname="1" colwidth="35pt" align="center"/>
<colspec colname="2" colwidth="35pt" align="center"/>
<colspec colname="3" colwidth="35pt" align="center"/>
<colspec colname="4" colwidth="35pt" align="center"/>
<colspec colname="5" colwidth="35pt" align="center"/>
<colspec colname="6" colwidth="35pt" align="center"/>
<colspec colname="7" colwidth="21pt" align="center"/>
<colspec colname="8" colwidth="28pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="8" rowsep="1">TABLE 2</entry>
</row>
<row>
<entry namest="1" nameend="8" align="center" rowsep="1"/>
</row>
<row>
<entry>1<sup>st </sup>pos. </entry>
<entry>2<sup>nd </sup>pos.</entry>
<entry>1<sup>st </sup>pos.</entry>
<entry>2<sup>nd </sup>pos.</entry>
<entry>1<sup>st </sup>pos.</entry>
<entry>2<sup>nd </sup>pos.</entry>
<entry/>
<entry/>
</row>
<row>
<entry>last_name</entry>
<entry>last_name</entry>
<entry>first_name</entry>
<entry>first_name</entry>
<entry>diagnosis</entry>
<entry>diagnosis</entry>
<entry>freq.</entry>
<entry>GpNum</entry>
</row>
<row>
<entry namest="1" nameend="8" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>s</entry>
<entry>m</entry>
<entry>j</entry>
<entry>o</entry>
<entry>c</entry>
<entry>a</entry>
<entry>1</entry>
<entry>&#x2002;8</entry>
</row>
<row>
<entry>s</entry>
<entry>m</entry>
<entry>j</entry>
<entry>o</entry>
<entry>c</entry>
<entry>a</entry>
<entry>2</entry>
<entry>24</entry>
</row>
<row>
<entry>s</entry>
<entry>m</entry>
<entry>m</entry>
<entry>a</entry>
<entry>d</entry>
<entry>i</entry>
<entry>2</entry>
<entry>24</entry>
</row>
<row>
<entry>j</entry>
<entry>o</entry>
<entry>m</entry>
<entry>i</entry>
<entry>d</entry>
<entry>i</entry>
<entry>2</entry>
<entry>24</entry>
</row>
<row>
<entry>h</entry>
<entry>o</entry>
<entry>s</entry>
<entry>t</entry>
<entry>h</entry>
<entry>i</entry>
<entry>1</entry>
<entry>&#x2002;8</entry>
</row>
<row>
<entry>p</entry>
<entry>o</entry>
<entry>l</entry>
<entry>i</entry>
<entry>c</entry>
<entry>a</entry>
<entry>1</entry>
<entry>&#x2002;8</entry>
</row>
<row>
<entry namest="1" nameend="8" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0044" num="0043">Group 8 has become smaller but because we are doing this for all 20 groups in B<b>1</b>, they also shrink, making their sizes not helpful to an intruder from a re-identification perspective. Group 24, in the meantime, now has 6 rows. Within this group, the combined frequencies of the leading characters of the most uniquely-identifying columns in its rows equal, i.e. they are 2. Therefore, re-identifying the string values in this group also becomes very difficult for an intruder.</p>
<p id="p-0045" num="0044">Anonymization Step 7 begins to make frequencies of string values indistinguishable in the temporary table. Start to create false rows which when combined with true rows will make frequencies of different string values indistinguishable within result sets derived from this table. Anonymization Step 7 creates equal frequencies of different full-length string values to further make differentiating full-length string values via a frequency analysis attack very difficult. Referring now to <figref idref="DRAWINGS">FIG. 1</figref>, for each string column in B<b>1</b>, a histogram of full-length string values&#x2014;called tokens from now on&#x2014;is recorded in table E<b>1</b> in order of descending frequency. Grouping tokens into sets of 5, the number of rows needed to be added to each token to make it equal the most frequent token in its 5-group set is also recorded in E<b>1</b>. If there are less than 5 tokens in a token's &#x201c;5-group&#x201d; set (e.g. it's the last grouping in the histogram), then we record just for those tokens how many rows compared to their leader are needed to make their frequencies equal. Next, the &#x201c;rows needed&#x201d; column is aggregated for each column in B<b>1</b>&#x2014;meaning, it is totaled for each column across all of the column's rows in E<b>1</b>. The largest such aggregated &#x201c;rows needed&#x201d; value is found. <figref idref="DRAWINGS">FIG. 1</figref> below shows an example of a small 3-column B<b>1</b> (without the padding of string values for clarity), the associated E<b>1</b> table, and how one identifies the largest aggregated &#x201c;rows needed&#x201d; value.</p>
<p id="p-0046" num="0045">Referring again to <figref idref="DRAWINGS">FIG. 1</figref>, the first_name column has the highest aggregated &#x201c;rows needed&#x201d; value&#x2014;a total of 7 rows needed. Random rows are copied from B<b>1</b> into temporary table C<b>1</b> equaling this value (e.g., 7, in this case). The rows will become some of the &#x201c;false&#x201d; rows of A<b>1</b>. Thus preventing the intruder from surmising which tokens are requested or returned based on result set size. Tokens will be replaced in the columns in C<b>1</b> based on the &#x201c;rows needed&#x201d; parameter to ensure that when tokens in any 5-group set from E<b>1</b> are requested, result sets will return true and false rows whose total number approximately equals, thus interfering with any re-identification attempts. New groups are created in C<b>1</b> so that the row count in each false group is equal roughly to the row count in the original B<b>1</b> groups. We want to maintain group row counts to prevent the intruder from understanding which are the false or true groups due to an unequal number of group rows. The RecInfo values of all the rows added to C<b>1</b> are labeled as &#x201c;false&#x201d; because these will become false rows in A<b>1</b>. <figref idref="DRAWINGS">FIG. 2</figref> continues the example of <figref idref="DRAWINGS">FIG. 1</figref>. (It shows how the 7 random rows are copied from B<b>1</b> into C<b>1</b>. We assume that B<b>1</b> has approximately 3 rows per group, therefore, C<b>1</b> must maintain such row counts in its newly-created false groups, too).</p>
<p id="p-0047" num="0046">Anonymization Step 8: To undermine frequency analysis attacks on individual characters, begin to make frequencies of characters within strings indistinguishable in the temporary table. Begin to create false rows so that when combined with the number of true rows, frequencies of different characters in the same positions become indistinguishable within result sets derived from the anonymized table.</p>
<p id="p-0048" num="0047">In each string column, the same technique as for tokens is applied to individual characters. For each string column, a histogram of frequencies of individual character positions within that column in order of descending frequency is built and stored in table F<b>1</b>. Grouping these positions into disjoint sets of 5, the number of rows needed to be added to each position to make it equal the most frequent position in its group is also recorded in F<b>1</b>. If there are less than 5 positions in the grouping (e.g. the last group in the histogram), the number of rows needed when compared to their leader is computed just for those positions. The values from the &#x201c;rows needed&#x201d; column are aggregated for each position and the maximum aggregated &#x201c;rows needed&#x201d; count is found. <figref idref="DRAWINGS">FIG. 3</figref> illustrates the tasks of this Step. It shows the column first_name taken from a B<b>1</b> table (unpadded for clarity and different from the B<b>1</b> used in <figref idref="DRAWINGS">FIGS. 1 and 2</figref>); the resulting F<b>1</b> table; and how to identify the aggregate maximum number of &#x201c;rows needed&#x201d; value.</p>
<p id="p-0049" num="0048">Still referring to <figref idref="DRAWINGS">FIG. 3</figref>, the highest aggregated &#x201c;rows needed&#x201d; value comes from the second position, i.e., 14 rows are needed. Random rows are copied from B<b>1</b> into temporary table D<b>1</b> equaling the most such rows needed (e.g., 14 here). These rows will become additional &#x201c;false&#x201d; rows in A<b>1</b>. The intent is to considerably undermine re-identification of characters based on result set sizes by making character frequencies within result sets indistinguishable from those of their peers in their 5-group sets. New groups are created in D<b>1</b> so that the row count in each is equal roughly to the row count in the original B<b>1</b> groups to preserve group row counts. The RecInfo values of all the rows added to D<b>1</b> are labeled as &#x201c;false&#x201d;. <figref idref="DRAWINGS">FIG. 4</figref> below continues illustrating the example of <figref idref="DRAWINGS">FIG. 3</figref>. (It shows how <b>14</b> random rows are copied from B<b>1</b> into D<b>1</b>. Note that because B<b>1</b> only has 9 rows, some rows must be (randomly) sampled twice to produce the 14 rows. We assume that B<b>1</b> has approximately 3 rows per group, therefore, D<b>1</b> must maintain such row counts in its newly-created false groups, too).</p>
<p id="p-0050" num="0049">Note, although in this embodiment we focus on creating 5-elements sets to undermine frequency analysis attacks on tokens and character positions, this is a configurable parameter in the embodiments of the present invention. For example, one could create 10-element, 4-element, etc. sets depending on how much security is needed in the ADB.</p>
<p id="p-0051" num="0050">Anonymization Step 9: &#x201c;Equalize&#x201d; the string and character values set up in Anonymization Steps 7 and 8. Among the false rows generated in those two Steps, substitute the needed string and character values to make string and character values almost equal in frequency within their respective 5-element groupings.</p>
<p id="p-0052" num="0051">That is, Anonymization step 9 is the process of &#x201c;equalizing&#x201d; the tokens and positions set up in Anonymization Steps 7 and 8. Using E<b>1</b> and F<b>1</b>, the tokens and positions specified therein will replace other tokens and positions in C<b>1</b> and D<b>1</b>, respectively, guided by the former tables' &#x201c;needed rows&#x201d; columns.</p>
<p id="p-0053" num="0052">In the case of tokens and E<b>1</b>, replacement starts using the top (e.g., most popular) token in E<b>1</b>. As substitutions continue, if all E<b>1</b> tokens are exhausted, yet there are rows in C<b>1</b> that have not yet received substitutions, substitution continues in a round-robin fashion. That is, tokens are equally distributed among the remaining false rows in C<b>1</b>. Every token in E<b>1</b> for the column, starting from the top and moving down one token at a time, is used once. If the bottom of E<b>1</b> is reached once again before C<b>1</b> is exhausted, the process wraps back to the top of E<b>1</b> and begins with the top token again.</p>
<p id="p-0054" num="0053">As an illustration, imagine C<b>1</b> contains 7 rows, based on the example in <figref idref="DRAWINGS">FIGS. 1 and 2</figref>. In the example there, the first_name column had the highest &#x201c;rows needed&#x201d; parameter, resulting in 7 rows in C<b>1</b>. After we create the 7 rows, suppose that, as part of creating false tokens across all of C<b>1</b>, we have now reached the point of processing string column last_name. It only requires 6 rows to be replaced. <figref idref="DRAWINGS">FIG. 5</figref> shows the subset of E<b>1</b> dealing with last_name and the C<b>1</b> table produced from B<b>1</b>. Both tables are the same as in <figref idref="DRAWINGS">FIG. 1</figref>, reproduced here just for convenience.</p>
<p id="p-0055" num="0054">The substitution process starts with the first row in C<b>1</b>. Moving down E<b>1</b> and C<b>1</b>, the last_name column in C<b>1</b> is systematically replaced by 0 Jones's, 1 Smith, 1 Lurie, 2 Jackson's, and 2 Felix's. Because the total number of token replacements via E<b>1</b> is only 6, for C<b>1</b>'s row 7 we go back to the beginning of E<b>1</b>. Row <b>7</b> in C<b>1</b> is replaced with 1 Jones. At this point replacement is stopped because we have substituted for all 7 rows in C<b>1</b>. <figref idref="DRAWINGS">FIG. 6</figref> shows the transformed C<b>1</b>.</p>
<p id="p-0056" num="0055">The same substitution approach is taken for character positions. As an illustration, and continuing with the example from <figref idref="DRAWINGS">FIGS. 3 and 4</figref>, imagine D<b>1</b> has 14 rows, based on the maximum &#x201c;rows needed&#x201d; column of position 2 from that example. We have created the 14 rows, and now, as part of creating the fake positions across all of in D<b>1</b>, we have reached the point of working with the 1st position of column first_name in F<b>1</b>. It has a smaller aggregated &#x201c;rows needed&#x201d; value compared to its position 2. <figref idref="DRAWINGS">FIG. 7</figref> shows a subset of F<b>1</b> with the details of position 1 and the associated D<b>1</b> table. Both are the same as in <figref idref="DRAWINGS">FIGS. 3 and 4</figref>, reproduced here just for convenience.</p>
<p id="p-0057" num="0056">Starting at the top of D<b>1</b> and the top of F<b>1</b>, we systematically replace the first position of the first_name column in D<b>1</b> with the characters in F<b>1</b>. We substitute in 0 J's, 1 R, 1 S, 2 B's, and 2 V's. Because we have only substituted 6 rows, we return to the top of F<b>1</b> and now begin substituting in a round-robin fashion. We substitute in 1 J, 1 R, 1 S, 1 B, and 1 V. Our current total, 11, is still 3 short of the needed 14 rows. We start at the top of E<b>1</b> once more and substitute in 1 J, 1 R, and 1 S, as which point we stop replacement. We have now substituted for all of D<b>1</b>'s rows. <figref idref="DRAWINGS">FIG. 8</figref> shows the transformed D<b>1</b>. Finally, after all the tokens and positions have been substituted in the ways described above, C<b>1</b> and D<b>1</b> are appended to B<b>1</b>.</p>
<p id="p-0058" num="0057">Anonymization Step 10: randomly shuffle the existing groups in the table to further obscure any potential group order. Also create a temporary table which will identify which groups contain false and true rows. That is, this Step randomly shuffles the groups created in B<b>1</b> to further scramble any potential previously-created group ordering. A new table, G<b>1</b>, is created with new group numbers representing the true and false groups (of course, the true rows are maintained in the true groups while the false groups are maintained in the false groups). Also, a temporary table, Y<b>1</b>, is created to just list which group numbers contain true rows and which contain false rows. This table becomes part of the A<b>1</b> table private key, part of the database private key, and is used to discard false rows when result sets involving A<b>1</b> are returned to the client from the server.</p>
<p id="p-0059" num="0058">Anonymization Step 11: begin anonymizing the numeric columns. Each number is converted to a different number through the use of a consistent mathematical function but with specially-chosen randomized parameters. That is, this Step (11) handles O<b>1</b>'s numeric columns. Numeric values are transformed into other numbers using a special monotonic mathematical function. Every numeric column in G<b>1</b> is processed. For every group, three values are obtained: the average of the numeric values for that group, a random number&#x2014;called a random multiplier from now on, and another random number&#x2014;called a random addend from now on. (In our testing for this scheme, we generated a random multiplier in the range of 500,000 to 1,500,000). To encode a numeric value within a group, the average of values in that group is subtracted from the number, the result multiplied by the random multiplier, and to this result the random addend is added. As we will see, such an encoding allows for a various computations like SUM, AVG, subtraction, etc. to be handled to a considerable degree by the server, although requiring some final computations on the client. At the same time, the security of numeric values is maintained because every group will have a random collection of rows. The average of values, a key contributor to the encoding, becomes a pseudo-random number, different from group to group, undermining a frequency analysis attack on the numbers. In addition, the random multiplier and random addend differ from group to group so that the anonymized values have little relationship to each other. One value could have been bigger or smaller than the other in O<b>1</b>, a relationship which the random multiplier and random addend especially help break in G<b>1</b>. The average, random multiplier, and random addend are different for each numeric column as well. All this randomization makes an intruder's ability to re-identify any particular column value, when he sees A<b>1</b>, very difficult. Further, as discussed previously, the number of groups into which O<b>1</b> is divided can always be increased, creating even more challenges to numeric re-identification. The random multiplier, random addend, and average for each group and column are stored in a table which will become part of the private key. It will be used to &#x201c;decrypt&#x201d; the numeric values, or computations involving them, on the client when result sets are returned to the client by the server.</p>
<p id="p-0060" num="0059">Anonymization Step 12: handle the numeric outliers by transforming them into values within the normal range of their groups. The original values are recorded so they can be later restored within results sets on the clients. That is, this anonymization step (12) involves properly managing numeric outliers. Despite the availability of groups and the mathematical function, certain numeric values may be so different from average that even placing them into groups and encoding them via the average, random multiplier, and random addend will still not hide their value. They look extremely different from the groups they are in, if not the entire A<b>1</b> table. To prevent the re-identification of such values, in G<b>1</b>, outliers are transformed to numbers which are within the range of the rest of their respective groups. The original values are recorded in a file to be part of the A<b>1</b> table private key for subsequent restoration within result sets on the client. Before the mathematical function is applied to any numeric value, the number is compared to a number three standard deviations below and three standard deviations above the average of all of the numbers in its group. If the value is at least three standard deviations below or above the average in its group it's considered an outlier and its complete row is recorded in temporary table H<b>1</b>. Its value in G<b>1</b> is transformed into a value randomly selected from the three sigma range within its group. The point of keeping the outlier values in G<b>1</b> rather than removing their rows altogether is to preserve the statistics that the other columns within these rows may support. The columns can support the movement of rows to other groups based on character frequencies, etc., as explained in earlier Anonymization Steps. It also becomes more difficult to identify the next outlier values after the most extreme outlier values are transformed if the transformed outliers could randomly take on those next-largest outlier values. The intruder does not know if the &#x201c;outlier&#x201d; value he sees is the next-largest outlier or the largest outlier made to look like the next-largest outlier. H<b>1</b>, containing the original outlier values and the values that replaced them, becomes part of the A<b>1</b> table private key to be used on the client. Note that after an outlier value is modified it is then encoded in the same way as any other number as described in Anonymization Step 11: the group average is subtracted from it, the result multiplied by the random multiplier for its column and group, and the random addend is added to this result based on the column and group.</p>
<p id="p-0061" num="0060">Anonymization Step 13: create the random encoding/decoding key for the table and use it to permute each character within each string value in the table. This Step involves the construction of the encoding/decoding key for A<b>1</b> that will be used to obfuscate every character in every string column in A<b>1</b>. A sub-key will be constructed for each group and character position in G<b>1</b>. The combination of all the sub-keys is the complete key that becomes part of the A<b>1</b> table private key files that is made available to the client machines. For each string column, for each position, for each group in G<b>1</b>, we randomly select how all characters in that position will be permuted into other characters. That is, we don't just permute actual characters that exist in G<b>1</b> but we create a random permutation of all possible characters, relying on V<b>1</b>, constructed earlier, to supply both the allowed domain and range for the permutation. This is done to make encoding and decoding easier on the client because the A<b>1</b> table private key has more structure and hence more efficient indexing properties. Table 3 below illustrates small portions of two sub-keys, representing how characters &#x201c;a&#x201d; through &#x201c;e&#x201d; for column last_name in position 2 in groups 27 and 45 are permuted in a fictitious G<b>1</b>:</p>
<p id="p-0062" num="0061">
<tables id="TABLE-US-00003" num="00003">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="1" colwidth="49pt" align="center"/>
<colspec colname="2" colwidth="49pt" align="center"/>
<colspec colname="3" colwidth="42pt" align="center"/>
<colspec colname="4" colwidth="28pt" align="center"/>
<colspec colname="5" colwidth="49pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="5" rowsep="1">TABLE 3</entry>
</row>
<row>
<entry namest="1" nameend="5" align="center" rowsep="1"/>
</row>
<row>
<entry>Original char.</entry>
<entry>Permuted char.</entry>
<entry>Column</entry>
<entry>Position</entry>
<entry>Group Num</entry>
</row>
<row>
<entry namest="1" nameend="5" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>a</entry>
<entry>h</entry>
<entry>last_name</entry>
<entry>2</entry>
<entry>27</entry>
</row>
<row>
<entry>b</entry>
<entry>A</entry>
<entry>last_name</entry>
<entry>2</entry>
<entry>27</entry>
</row>
<row>
<entry>c</entry>
<entry>4</entry>
<entry>last_name</entry>
<entry>2</entry>
<entry>27</entry>
</row>
<row>
<entry>d</entry>
<entry>w</entry>
<entry>last_name</entry>
<entry>2</entry>
<entry>27</entry>
</row>
<row>
<entry>e</entry>
<entry>$</entry>
<entry>last_name</entry>
<entry>2</entry>
<entry>27</entry>
</row>
<row>
<entry>a</entry>
<entry>u</entry>
<entry>last_name</entry>
<entry>2</entry>
<entry>45</entry>
</row>
<row>
<entry>b</entry>
<entry>D</entry>
<entry>last_name</entry>
<entry>2</entry>
<entry>45</entry>
</row>
<row>
<entry>c</entry>
<entry>h</entry>
<entry>last_name</entry>
<entry>2</entry>
<entry>45</entry>
</row>
<row>
<entry>d</entry>
<entry>3</entry>
<entry>last_name</entry>
<entry>2</entry>
<entry>45</entry>
</row>
<row>
<entry>e</entry>
<entry>P</entry>
<entry>last_name</entry>
<entry>2</entry>
<entry>45</entry>
</row>
<row>
<entry namest="1" nameend="5" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0063" num="0062">We also create a separate group, i.e., a separate sub-key, for rows which are INSERTed after G<b>1</b>, in the final form of A<b>1</b>, is placed into production. To prevent the intruder's guessing of encodings within existing groups by the introduction of new statistics that might somehow assist in re-identification, we place a new row and its associated statistics into a new group. We also create a random &#x201c;average&#x201d; value, a random multiplier, and a random addend for each numeric column and a new sub-key for each string length column to be stored in the RecInfo column for the new INSERT group. (The encoding of string lengths is discussed below in Anonymization Step 15). Note that isolating newly INSERTed rows in their own group certainly tells the intruder that that group number contains true rows. He can focus his re-identification efforts there. However, the intruder cannot know column values of newly INSERTed rows per our threat model. As mentioned in the very beginning, the intruder can only copy the ODB before the anonymization takes place, not afterwards. His copy of the ODB will not have the newly INSERTed rows and he cannot compare anonymized values of these rows with any original plaintext values. He can try to use published statistics&#x2014;from the Census Bureau, etc.&#x2014;to mount a frequency analysis attack on tokens or character positions. But given the difficulty in re-identifying the ADB when he has a copy of the ODB, as has been (and will continue to be) shown in this note, breaking the security of the anonymized rows without having the original plaintext values makes re-identification even more difficult.</p>
<p id="p-0064" num="0063">Still, it also is possible to re-anonymize the database, i.e. create a new ADB, whenever the database owner wishes. The new ADB re-distributes the rows from the INSERTed group into regular groups so that the intruder will not know which groups contain the new rows or what their anonymized content even is. The frequency of re-anonymization can be tied to how many rows are INSERTed into the ADB within some fixed period. If the number of new INSERTs, say, per month, is high, re-anonymization can be more frequent, for example, possibly every few weeks. If the number of new INSERTs is low, re-anonymization can be less frequent, happening, say, once per quarter. (Please see our Implementation Performance Results discussion at the bottom of this note describing when to re-anonymize the ADB).</p>
<p id="p-0065" num="0064">Next, using the sub-key mappings, each character in G<b>1</b>'s string values is permuted into its encoded form. Finally, all the sub-key mappings are combined into one encoding file to be placed into the A<b>1</b> table private key.</p>
<p id="p-0066" num="0065">Anonymization Step 14: encode the string lengths of every string value by permuting them into a character in the domain of the ODB and store the encodings in the temporary table. In other words, in this Step, we finish string column processing. The length of each string value is recorded in the RecInfo column of its row. Because the lengths are numeric one could encode them just like numbers more generally. However, this would preserve the order of the encodings within a group because the mathematical function is monotonic. Preserving the order could give an intruder more information about which strings belong to which group. He could compare A<b>1</b> with the ordered string lengths he has in his O<b>1</b> copy which could facilitate some of his re-identification efforts. Therefore, more preferably, because one never needs to know the ordering of string lengths during anonymization, the encoding mechanism is the permutation of string lengths into characters in the ODB which are stored in the RecInfo column. Each string column length obtains its own permutation based on the group it's in and the string column it's associated with. Preferably, V<b>1</b> is relied on. A given string length is mapped to the ordered symbol set in V<b>1</b> to first identify the character associated with the length of the string. Then we map this character into V<b>1</b> again to encode the length. As an example, imagine V<b>1</b> is comprised of 62 characters: the lower case characters, the upper case characters, and the digits 0-9, ordered in this specific way within V<b>1</b>. To encode a string length of 4, we find the character the length is associated with: in this case, it's the lower case &#x201c;d&#x201d;, the fourth character from the start of V<b>1</b>. Then we permute &#x201c;d&#x201d; into another character in V<b>1</b>, for example, &#x201c;R&#x201d;. Such permutations, sub-keys just like the regular encoding of characters described in Anonymization Step 13, are combined and stored in the encoding file of A<b>1</b>'s private key. Because strings lengths should, in general, be small, a typical string length should &#x201c;fit&#x201d; within the symbol set of a typical V<b>1</b>. If some string lengths don't &#x201c;fit&#x201d; within V<b>1</b>, we could arbitrarily increase the size of our encoding space to any representation. For example, if we need string lengths of up to 10,000 we could create a permutation matrix mapping each length 1-10000 to a 3-position lower-case character value, for example, &#x201c;dgq&#x201d;. Because we could arbitrarily represent 26<sup>3</sup>, or 17,576 values, using such a representation, using this construction would cover the needed 10,000 character lengths using the symbols in V<b>1</b>. This permutation matrix becomes part of the A<b>1</b> table private key.</p>
<p id="p-0067" num="0066">For each group, for each string column, each string length value is permuted as described above. These encoded lengths are concatenated, separated by specially marked delimiters, and placed as one long string into the RecInfo column. That is, they are appended to the flag indicating whether the row is true or false that is already present in that column. <figref idref="DRAWINGS">FIG. 9</figref> illustrates how a small part of a 2-column G<b>1</b> having a single &#x201c;true&#x201d; row in one group is transformed to contain encoded string lengths. (In the example, we assume the size of V<b>1</b> is 62 characters. V<b>1</b> contains the lower case characters, the upper case characters, and the digits 0-9, ordered in this particular way. The sub-key files are separate just for clarity. Ultimately they are combined into one encoding file). Finally, a new table, A<b>1</b>, which ultimately becomes the anonymized representation of O<b>1</b>, is created which contains everything from G<b>1</b> except for the true/false row indicator in the RecInfo column.</p>
<p id="p-0068" num="0067">Anonymization Step 15: create indices within the anonymized table to improve query performance. The next anonymization Step, 15, is to create indices on the anonymized table to improve query performance. Because simple textual and numeric manipulations are used to encode the plaintext data in A<b>1</b>, many of the indexing functions of the underlying database engine work on the anonymized data. This embodiment creates a non-clustered index on each string column in A<b>1</b> to speed the processing of queries. In addition, because groups play a key role in extracting data, on numeric columns, a multi-column, non-clustered index is constructed with the GpNum column being the leading column in each such index. A single clustered index comprised of, in order, the GpNum, RowNum, and Last Name columns, is also constructed to further enhance query performance. Indices are not created on the RowNum or RecInfo columns. When we tested with indices on these two columns, they appeared to slow down rather than speed up queries. We also create a special index on the R<b>1</b> table. We want to ensure that only unique RowNums are inserted into it. We create a UNIQUE index on R<b>1</b> and also specify that this table should ignore any duplicate RowNums insert attempts, the motivation for which will be explained when we discuss the DELETE command later on. (In the Microsoft SQL Server 2008 environment, which is our testing environment, ignoring duplicate rows means that the index is created with the IGNORE_DUP_KEY=ON parameter). At this point, we are finished with O<b>1</b> and it can be detached and stored for later reference. Table A<b>1</b> is ready to be used by the database application(s).</p>
<p id="p-0069" num="0068">Anonymization Step 16: anonymize the other tables of the original database, following the steps similar to Anonymization Steps 1 through 15. To handle the other tables of the ODB, O<b>2</b> . . . Op, a similar process to the one described in Anonymization Steps 1 through 15 is undertaken. If these tables do not need to be JOINed on any columns to each other or to O<b>1</b>, the anonymization process for these tables becomes a two step process. To speed table anonymization and the loading of the database private key into memory on client computers, some of the encodings used for A<b>1</b> may be used to encode columns in the other Ai. The appropriate number of groups is chosen for tables Oi independently of O<b>1</b> and the anonymization of Oi is done using Oi's data. However, when it comes to choosing the average, random multipliers, and random addends for Oi's numeric columns and the sub-keys for Oi's string columns, the database script checks table A<b>1</b>'s and table Ai's columns. Every Ai column that has an analogous column in A<b>1</b> can use the average, random multipliers, random addends or character encoding for that A<b>1</b> column. Anonymization steps 1 through 15 have already equalized the frequency of tokens and character positions of Ai strings. The shuffling of the values in numeric columns into random groups and the creation of false numeric values&#x2014;when false records were created during string and character &#x201c;equalization&#x201d;&#x2014;masks the numeric values as well. Hence, the average, random multipliers, random addends, and sub-keys&#x2014;the final overlays over the true anonymization performed earlier&#x2014;, can be re-used. If the number of groups in some Ai is greater than the number of groups in A<b>1</b> then new numeric and string encodings will have to be created for those groups. Also, for those Ai columns that have no equivalent in A<b>1</b>, the average, random multipliers, random addends, and sub-keys are chosen independently as described in Anonymization Steps 11 and 13, respectively. Each position and numeric value in each group is encoded either using A<b>1</b>'s private key or Ai's private key. Each table Ai also gets its own Ri table to assist with managing DELETE commands. Indices are also created on the Ai as for A<b>1</b>. If some of Ai's columns use the same encodings as analogous A<b>1</b> columns, the private key files associated with those encodings do not need to be stored on the shared network drive. Clients will rely on A<b>1</b>'s private key files to encode and decode those Ai columns. Otherwise, all the Ai private key files used to encode queries and decode the results targeting the Ai are installed on the shared network drive to be accessed by client machines.</p>
<p id="p-0070" num="0069">If a table Oj must be JOINed on one more or more columns with Oi, which has already been anonymized earlier, a somewhat different procedure is undertaken. Imagine we know which columns will be used for the JOIN prior to anonymizing Oj. The columns used for JOINing Oj must be anonymized in the same way as the corresponding columns in Oi because strings must match when compared. Although our JOIN process can handle multi-column and multi-table JOINs, we'll use the following simpler example to illustrate how JOINs are handled.</p>
<p id="p-0071" num="0070">Now, suppose one wanted to JOIN O<b>2</b> to O<b>1</b> and only one column will be used for JOINing. O<b>2</b> is copied into temporary table B<b>2</b> which will similarly have the new RecInfo, GpNum, and RowNum columns created. The same strings in B<b>2</b> must be padded as they were padded in B<b>1</b> because we may be doing full-length string comparisons during the JOIN. Because the padding mechanism is deterministic&#x2014;i.e., appends the same value over and over, character by character, until the maximum length of the string value is reached&#x2014;tokens that are identical between B<b>2</b>'s and B<b>1</b>'s JOIN columns will be therefore padded the same way.</p>
<p id="p-0072" num="0071">Next the unique plaintext padded values from the JOIN column in B<b>2</b> are recorded in a separate table, X<b>1</b>. Unique X<b>1</b> values are reproduced within X<b>1</b> as many times as there are groups in A<b>1</b>. Such a construction of X<b>1</b> will allow the extraction all potential rows from A<b>1</b> and A<b>2</b> when they are JOINed across their different group encodings in any JOIN query. Obtaining such rows will, in turn, allow one to rebuild the JOIN result set on the client. This is discussed in more depth later on but, essentially, X<b>1</b> acts as a bridge, allowing one to return to the client all relevant rows from A<b>1</b> and all relevant rows from A<b>2</b>. Using these data, the driver then finalizes the presentation of the JOIN result set on the client. <figref idref="DRAWINGS">FIG. 10</figref> illustrates the construction of X<b>1</b>. (It shows how the X<b>1</b> is extracted from a small 3-group padded B<b>2</b> and then how it's expanded based on the associated (and not shown) 4-group A<b>1</b>).</p>
<p id="p-0073" num="0072">How the X<b>1</b> table is used to handle JOINs is discussed later on.</p>
<p id="p-0074" num="0073">Note, if the JOIN column(s) are not known ahead of time and are only later determined, the anonymization steps related to O<b>2</b> can be done when the columns for the JOIN are determined. A re-anonymization of O<b>2</b> will have to be done as follows: O<b>2</b> can be retrieved from archived storage. Alternatively, after O<b>2</b> is constructed it can be decoded and the re-anonymization done on the resulting plaintext table.</p>
<p id="p-0075" num="0074">Next, the same steps as for O<b>1</b> are followed for O<b>2</b>. The same number of groups as for A<b>1</b> is selected to construct A<b>2</b>. The group number must be preserved because we want to preserve the encodings for the column on which the tables are JOINed. All other steps&#x2014;with regard to moving rows to new groups based on character frequencies; grouping string values and individual characters into 5-element groups; etc.&#x2014;are done as before based on O<b>2</b>'s data. The final groups of B<b>2</b> are compared to Y<b>1</b>, the table created earlier indicating which are the true and false groups in A<b>1</b>. The true and false group numbers of B<b>2</b> are converted to, respectively, the true and false group numbers of A<b>1</b> so that the group-based encodings for JOIN purposes can be maintained. Note, even if O<b>2</b> is very small or very large and generates less or more groups compared to O<b>1</b>, respectively, this is acceptable because our driver can still construct a JOIN query to return appropriate rows of the two tables implicated in the JOIN to finalize the presentation of the result set on the client. Once again, for faster processing any other numeric and string columns in O<b>2</b> analogous to those in O<b>1</b> can use the same average, random values (multiplier and addend) and encodings as for each group in O<b>1</b>. For any different columns, the numeric and string columns must be transformed with independently generated average and random values (multiplier and addend) and encodings. In either case, the X<b>1</b> table used for JOINs is encoded using the same encodings as that of its counterpart column in A<b>1</b>. Indices are ultimately created on A<b>2</b> as for A<b>1</b>. Table A<b>2</b> is now ready to be placed into production.</p>
<p id="p-0076" num="0075">If tables O<b>3</b> . . . Op are also candidates for JOIN, their anonymization follows the same steps as just described for O<b>2</b>.</p>
<p id="p-0077" num="0076">Tables A<b>2</b> . . . Ap are now created and can be placed into production.</p>
<p id="p-0078" num="0077">Placement into Production</p>
<p id="p-0079" num="0078">To place this scheme into production, in accordance with embodiments of the present invention, the ADB is made accessible to all the users that need it. A driver is installed on each appropriate client workstation. The application(s) that access the ODB are re-configured to point to our driver instead of the ODBC driver they currently use.</p>
<p id="p-0080" num="0079">The database private key is made available to all clients. The database private key is composed of the Ai table private key files and general database files. The following are the private key files for each specific Ai in the ADB:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0080">1. The V<b>1</b> table, indicating whether a particular group is true or false.</li>
        <li id="ul0002-0002" num="0081">2. The encoding file describing how each character position is encoded for each group in each string column. This file also describes the encoding for each string length &#x201c;column&#x201d; in each group.</li>
        <li id="ul0002-0003" num="0082">3. The file describing the average, random multiplier, and random addend for each numeric column in each group.</li>
        <li id="ul0002-0004" num="0083">4. The H<b>1</b> table, describing the original and modified numeric outlier values in certain rows.</li>
        <li id="ul0002-0005" num="0084">5. The file containing the maximum lengths of each padded string column.</li>
        <li id="ul0002-0006" num="0085">6. The file describing how many rows there are in the entire table.</li>
        <li id="ul0002-0007" num="0086">7. The file describing how many groups there are in the table.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0081" num="0087">The following are the general database files:
<ul id="ul0003" list-style="none">
    <li id="ul0003-0001" num="0000">
    <ul id="ul0004" list-style="none">
        <li id="ul0004-0001" num="0088">1. The V<b>1</b> table, containing the domain of the characters in O<b>1</b> . . . Op.</li>
        <li id="ul0004-0002" num="0089">2. The file describing how many rows the database server can handle within an anonymized subquery whose components are linked by OR statements. (This is further explained in the &#x201c;Constructing Anonymous Queries&#x201d; section).</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0082" num="0090">These nine files must be placed on the shared network drive that all clients access, as discussed in the beginning of this document, from which all clients can obtain them.</p>
<p id="p-0083" num="0091">Encrypted Operations</p>
<p id="h-0007" num="0000">Query Re-Write by the Driver</p>
<p id="p-0084" num="0092">Now described is how the driver constructs the queries for the scheme. The scheme fully operates over encrypted data given the breadth of SQL commands and does not require decryption. Therefore, the driver translates plaintext queries from the database applications into encrypted queries so they can work with the ADB. Now described is how the driver handles such query re-writing and management in general and then how it handles issues specific to specific kinds of SQL queries. As for the almost real-time performance feature of queries through the use of indexing, this is discussed in more detail in the Implementation Performance Results section. The driver loads the private key into memory for faster data encoding and decoding. The driver intercepts and parses each query going from the client application(s) to the server. The driver identifies all the columns where constants are specified (for example, in SET clauses of UPDATE statements, WHERE clauses in SELECT statements, etc). The driver encodes these constants for each group of the table(s) targeted by the query using the table's (or tables') private key; it constructs a large multi-part query. To illustrate, query construction for a single table A<b>1</b> is demonstrated as an example. However it is readily apparent that the driver can readily work with multiple tables. For each A<b>1</b> group, the driver creates a sub-query containing the column(s) which are implicated in the query and it properly encodes the relevant constant(s) for that group. All the sub-queries are appended together using OR statements into larger tuples.</p>
<p id="h-0008" num="0000">Constructing Anonymous Queries</p>
<p id="p-0085" num="0093">Based on our test results, it has been found that the server efficiently processes queries when each of these larger tuples manages a specific number of rows across all of its sub-queries. In our testing, an MS SQL 2008 Server worked efficiently when there were about 260,000 rows processed by each of these larger tuples. The 260,000-row capacity may be server specific. Therefore, it is a configurable parameter, i.e. a file, in the database private key. The driver computes how many sub-queries to place within a larger tuple so that the server efficiently handles anonymized queries. The driver knows the number of rows and the number of groups in A<b>1</b>; they are part of the database private key. Therefore, the driver uses the following formula to compute the optimum number of sub-queries to place into the larger tuples:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>round([260000*number of groups in table]/number of rows in table)<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0086" num="0094">Once the larger tuples are formed, they are combined with UNION statements to produce a large multi-part query. In certain cases, to more easily manage queries, one may preferably invoke a stored procedure on the server. In this example, it is passed as a list of the encoded constants. The stored procedure parses our list and dynamically creates and executes the necessary SQL statements. Note that when string columns are implicated by the application's query, the driver automatically supplies the correct padding to identify the correct strings. As discussed in Anonymization Step 3, every string value is padded by repeatedly appending it to itself, one character one at a time, wrapping back to the beginning of the value until the maximum length of the column is reached. After the padding, the driver is ready to encode the constant(s).</p>
<p id="h-0009" num="0000">Anonymous LIKE Statement Processing</p>
<p id="p-0087" num="0095">If the WHERE clause of a user's query contains a LIKE statement, the proper construction of the encoded LIKE statement depends upon the construction of the plaintext LIKE constant in the query. If the wildchar &#x2018;%&#x2019; is the final character of the plaintext LIKE constant, then the encoding of the constant in the encoded WHERE clause encodes the prefix before the wildchar for each group in A<b>1</b>. But if the plaintext LIKE constant contains wildchars prior to the final character of the constant, then the driver will have to create a multi-component query. Each component will encode a full query to find the rows where the encoded LIKE constant is located at a specific position in the string. The query components will be ORed together to produce the multi-component query that finds all the needed rows satisfying the user's request. In particular, each component query focuses on encoding a LIKE constant that locates the needed constant within different string positions using a moving index across the implicated string column. The first component query, starting at the index of 1, encodes the query so that the LIKE constant is found in the first position of the implicated string column. Continually moving the index to the right by one, each subsequent component query encodes the query so that LIKE constants are found at each successive character position in the implicated string column. Component queries are created until the maximum length of the implicated string column, available from the targeted table's private key, in memory, minus the length of the plaintext LIKE constant, has been reached. The &#x201c;placeholder&#x201d; SQL character &#x201c;_&#x201d; will be used to fill all the positions in the encoded LIKE constant before the index currently being examined. This will force the encoded constant to be found at that particular index position of the encoded string and nowhere else in the implicated string column.</p>
<p id="h-0010" num="0000">Anonymous LIKE Statement Example</p>
<p id="p-0088" num="0096">The following example illustrates the construction of a multi-component query for a non-trivial plaintext LIKE constant. Imagine the driver receives a SELECT statement which includes the WHERE clause &#x201c; . . . WHERE last_name LIKE &#x2018;% ack %&#x2019;&#x201d;. Assume the column last_name has a padded length of 8 characters. The driver will produce a 6-component query. The first component will encode &#x201c;ack&#x201d; for all A<b>1</b> groups for last_name character positions 1, 2, and 3. The encoded LIKE constant will have zero &#x201c;_&#x201d;'s preceding it because the constant for this component query tries to find strings where it is present specifically in the beginning of the string, in position 1. For example, if &#x201c;tr2&#x201d; are the encodings of the characters &#x201c;ack&#x201d; for positions 1, 2, and 3, respectively, the LIKE clause for this component query would be &#x201c; . . . LIKE &#x2018;tr2%&#x2019;&#x201d;. The second component query encodes &#x201c;ack&#x201d; for all A<b>1</b> groups for last_name character positions 2, 3, and 4. The encoded constant has one &#x201c;_&#x201d; preceding it because this encoded LIKE constant aims to find strings where it is specifically found in position 2 in the string of the implicated string column. For example, if &#x201c;f5P&#x201d; is the encoding for the characters &#x201c;ack&#x201d; for positions 2, 3, and 4, respectively, the anonymized LIKE clause for this component query would become &#x201c; . . . LIKE &#x2018;_f5P %&#x2019;&#x201d;. And so on, until the encoding of the sixth query component. That component will encode &#x201c;ack&#x201d; for all A<b>1</b> groups for last_name character positions 6, 7, and 8. The encoded constant has five &#x201c;_&#x201d;'s preceding it because that anonymized LIKE constant tries to find strings where it is found starting at exactly position 6 of the string. For example, if &#x201c;J9a&#x201d; is the encoding for the characters &#x201c;ack&#x201d; for positions 6, 7, and 8, respectively, the anonymized LIKE clause for this component becomes &#x201c; . . . LIKE &#x2018;_J9a&#x2019;&#x201d;. (There are five underscores between the apostrophes in the constant). These six components are ORed together to produce the large multi-part query. Note that the encoded LIKE constants, especially those in the last few component queries, may implicate rows where the constant is found in the encoded padding as opposed to the actual encoded string value. These rows will be discarded on the client. As part of the cleaning of the result set on the client, the driver checks whether the constant found in the string is within the permitted length of the string. The string length is obtained from the RecInfo column. If it's not within the length of the string the row is discarded.</p>
<p id="h-0011" num="0000">Presenting Results to User</p>
<p id="p-0089" num="0097">The large encoded query (or encoded list for the stored procedure) is sent to the server and encoded results, if any, are returned to the client. If any results are returned, the driver first discards any fake rows. It compares their GpNum values with its file in memory describing which groups are false and which are true. In the remaining rows, all the string values are trimmed based on their original lengths as encoded in their RecInfo columns. Next, the encoded strings and numerical values are decoded. As each numerical value is converted to its original value, first, its associated RowNum is compared to the outlier RowNums, also in the database private key in memory. If the RowNum matches the RowNum flagged as having one or more numerical outlier values, the original outlier value(s) is reinstated before the result set is returned to the user. Similarly, towards the end of any result set processing, every outlier value is examined to ensure that if no row was returned containing that outlier value, but the value should have been in the result set, an outlier row is created with its original strings and numeric values in the result set. A similar process is undertaken when an arithmetic query implicates an outlier value. Any arithmetic computation (e.g., SUM, AVG, etc.) result returned by the server is additionally (re)processed on the client to include any outlier value(s) involved in the computation. All the plaintext rows in the result set can finally be returned to the user. It's important to note that the result set comes back to the client as one set of rows which are processed and then returned to the user. The driver does not wait in a loop interacting with the server, obtaining partial result sets and building up the final result set. Our driver could be implemented for such interaction, but currently works with a single query and a single response. <figref idref="DRAWINGS">FIGS. 11A-C</figref> show how a small result set from a SELECT query targeting a simple table is decoded based on the database private key in memory. (Bold characters are used to illustrate the changes happening to implicated row values after each step).</p>
<p id="p-0090" num="0098">Now described are the handling of specific queries:</p>
<p id="p-0091" num="0099">Select</p>
<p id="p-0092" num="0100">A SELECT statement is handled like the general query case described above. However, as will be further described when discussing the DELETE command, only rows which are not in the R<b>1</b> table, which are rows being scheduled for deletion, can be involved in any query. When constructing the SELECT query, the driver therefore appends to it a clause to do an OUTER JOIN with the R<b>1</b> table. From the table resulting from this OUTER JOIN, the query selects only those rows whose RowNums are not in R<b>1</b>. These rows are then returned to the client as the result set.</p>
<p id="p-0093" num="0101">Count</p>
<p id="p-0094" num="0102">A COUNT statement is implemented relatively directly. As in the SELECT statement discussed above, the result set must only include those rows which are not scheduled for deletion. Again, the clause to do an OUTER JOIN with R<b>1</b> is appended to the encoded COUNT query to count only the non-R<b>1</b> rows. Sub-counts of rows for each group, based on the associated SELECT statement with the COUNT clause, are returned along with the group numbers for each sub-count. The client discards the sub-counts of false groups, adds the remaining sub-counts, and presents the final COUNT result to the user.</p>
<p id="p-0095" num="0103">Update</p>
<p id="p-0096" num="0104">An UPDATE statement is handled partly like the general query case. Because the rows implicated by an UPDATE command may cross groups, we use a different &#x201c;SET &#x3c;variables&#x3e;&#x201d; clause for each group to UPDATE the variables in that group using its proper encoding. Consequently, each group gets its own UPDATE command. For each UPDATE, command, the client encodes the constant(s) the user is searching for (e.g., specified in his WHERE clause), and the constant(s) we want to set the column(s&#x2032;) values to. To preserve the padded length of the constants to be inserted, before they are encoded, they are padded with the original string value repeatedly. As explained before, this is done character by character until we've reached the maximum length of the column. Further, because the new constants may have a different length than the string values they replace, we update the RecInfo column for all the affected rows with the new lengths. The driver encrypts the new length of each constant by permuting it into a character in the ODB domain, using the sub-key in the overall encoding file, available in memory, for the associated string length &#x201c;column&#x201d; and group. The client sends to the server a list of UPDATE commands separated by blanks. The server treats each UPDATE command independently. Each UPDATE command updates the implicated rows in a specific group with the new constant(s) and sets the proper RecInfo locations of those rows to the constants' new lengths.</p>
<p id="p-0097" num="0105">An important point to make is that whenever UPDATEs are issued, if rows with outlier values are implicated, this should become known to all client machines. Otherwise, they will continue to rebuild result sets with outdated outlier values. The client issuing the UPDATE to the outlier(s) will update his database private key in memory with the new outlier value(s). Its driver will then copy the outlier file (the H<b>1</b> file, as per Anonymization Step 12) into the shared network drive for all the other clients to access. Thus, before it issues any query, the driver on any client checks the shared network drive to see if the date or time of the outlier file are different compared to the file it has in memory. If date or time is different, the driver uploads the new file into memory before making a query to the ADB.</p>
<p id="p-0098" num="0106">Insert</p>
<p id="p-0099" num="0107">An INSERT statement is handled by working with the last group in A<b>1</b>. For each new row to be INSERTed, all the string values of the row are padded by repeating their values until the maximum lengths of their columns are reached. The padded values are then encoded using the sub-key, within the overall encoding file, for A<b>1</b>'s last group. The numeric values of the row will be converted using the random &#x201c;average&#x201d; value, random multiplier, and random addend for the last group. The true lengths of each string value are mapped into random characters in V<b>1</b> using the sub-key for each string length &#x201c;column&#x201d; for that group. The lengths are also recorded in the RecInfo column. The next sequential RowNum for the row is also created for the row. (In our case, this is done automatically by the server because the RecInfo column is designated as an IDENTITY column in A<b>1</b> in our test database. When a new row is INSERTed, the server automatically assigns the next numeric value to the RowNum value of that row). Because during UPDATE and SELECT commands we UPDATE and SELECT from A<b>1</b>'s last group, the new row is now retrievable from A<b>1</b> if it's implicated by a query.</p>
<p id="p-0100" num="0108">Delete</p>
<p id="p-0101" num="0109">DELETE commands are handled in a special manner. Because we found, during our testing, that straightforward DELETE commands to the ADB were taking 3-4 times longer than one reference standard we compared our performance to&#x2014;the Microsoft JDBC driver, as we will discuss in our Performance section below&#x2014;, we came up with a different solution for row DELETEs. We created the R<b>1</b> table. (Please see Anonymization step 2 for a description of R<b>1</b>). The DELETE command is constructed similar to a generic query. But rather than deleting rows, it constructs INSERT commands for each group, INSERTing the RowNums of the rows to be DELETEd into R<b>1</b>. A scheduler is set up on the server to invoke a stored procedure to actually DELETE the rows in R<b>1</b>. We found when testing, that when the stored procedure tried to delete a large number of rows, other client queries were forced to wait until the command completed (apparently due to table or row lock-outs). We had to break our scheduled DELETE tasks into smaller chunks. Rather than scheduling a DELETE for all rows in R<b>1</b>, our stored procedure was configured to only DELETE 100 rows at a time. The stored procedure was scheduled to run every minute of every day. With such a configuration, actual row erasures had negligible impact on the client's other queries. (See the Performance section for additional information on DELETE command performance). Of course with our scheme, a given customer can schedule more deletions per run, or, conversely, less frequent runs, knowing the performance capabilities of its hardware and software.</p>
<p id="p-0102" num="0110">Note that whenever DELETEs are issued, if rows with outlier values are implicated, this should become known to all client machines. Otherwise, just like for the UPDATE command, clients will continue to build result sets with outdated outlier values. The client issuing the DELETEs to the outlier(s) will remove the value(s) from his database private key. Then he will copy this file (i.e. the H<b>1</b> file) into the shared network drive with the other database private key files for all other client machines to access. Before any query, each client driver checks to see if the outlier file on the shared network drive is more recent compared to the file it has in memory. If so, the driver uploads the new outlier file before making new queries to the ADB.</p>
<p id="p-0103" num="0111">Join</p>
<p id="p-0104" num="0112">Various JOINs can be started on the server and completed on the client. This uses the Xi tables created in Anonymization Step 16. When JOINing Ai to Aj, Ai is first JOINed with the Xi table and then the Xi table is JOINed with Aj. The results of both JOINs, modified to extract only those set of columns requested by the user, are sent to the client. The client will then restore the proper JOIN result set and present it to the application. For illustration, we focus on retrieving the rows of A<b>1</b> when it's INNER JOINed with A<b>2</b> over a single column. But other kinds of JOINs (e.g. LEFT, SELF, etc), including multi-column and multi-table JOINs can be similarly done using such a scheme. Suppose the column name is l_name and we want to merge the tables intake and discharge. The JOIN we discuss is: &#x201c;SELECT a.* FROM intake AS a JOIN discharge AS b ON a.l_name=b.l_name&#x201d;. We first describe the mechanics how our driver implements the JOIN and then show an example to clarify the points. We obviously cannot do a JOIN of the two implicated tables directly on the server due to different group encodings in the ADB. Imagine l_name &#x201c;Jones&#x201d; is in group 5 of A<b>1</b> and in group 7 of A<b>2</b> but does not exist in group 5 of A<b>2</b>. A JOIN involving equality comparisons between A<b>1</b> and A<b>2</b> would fail to produce results for &#x201c;Jones&#x201d; because, due to different encodings, its versions in A<b>1</b> group 5 and A<b>2</b> group 7 could not be directly equated. Currently our driver implements JOINs via a stored procedure on the server but this can also be ported to the JAVA (programming language) code in our driver. Upon getting a JOIN request from the application, the driver sends the tables and column implicated to the stored procedure. The stored procedure combines the results of two special types of queries in one table, J<b>1</b>, which it returns to the client. The driver will restore the correct JOIN result set for the user on the client via J<b>1</b>. The first component of J<b>1</b> is the selection of rows from A<b>1</b> when it is JOINed (i.e., based on equality or other comparison as specified in the user's query) to the encoded X<b>1</b>. Because X<b>1</b> encodes all values of A<b>2</b> encoded as for every group in A<b>1</b>, all possible A<b>1</b> rows that can link to A<b>2</b> rows on that column are selected, regardless of encoding. The second component of J<b>1</b> will select the rows from X<b>1</b> which are JOINed to the rows of A<b>2</b> (again based on the comparison as specified by the user's query), GROUPed BY the frequency with which they occur in X<b>1</b>. Because X<b>1</b> encodes all values of A<b>2</b>, we are basically merging A<b>2</b> with itself. The intent is, for each group, to identify for each A<b>2</b> token how many times it is implicated in the JOIN. This frequency is used to reproduce the correct number of times the rows from the first part of J<b>1</b> are found in the result set, as will be shown below. Both J<b>1</b> components are returned the client in one combined result set.</p>
<p id="p-0105" num="0113">The driver handles the returned J<b>1</b> via a loop. First, all the rows in both components of J<b>1</b> are stripped of false rows. Next, the column implicated in the JOIN is fully decoded in both the first and second components of J<b>1</b> so we can compare strings without the interfering group encodings. Next, for each row of the second part of J<b>1</b> (i.e., the A<b>2</b>-implicated rows of the JOIN), every row in the first part in J<b>1</b> (i.e., the A<b>1</b>-implicated rows) is checked. When there is a match of rows based on the requested comparison, each row in J<b>1</b>'s first part is reproduced in the result set as many times as the frequency count for the row from the second part specifies. The effect of this step is to reproduce every row in A<b>1</b> exactly as many times necessary as if we did the INNER JOIN directly on the server for the implicated column. And when done for all rows from both components in J<b>1</b>, the result is the one requested by the user: we pick just the rows of A<b>1</b> when it forms a cross-product with A<b>2</b> on the implicated column. <figref idref="DRAWINGS">FIGS. 12A and 12B</figref> illustrate the INNER JOIN process over tables intake, discharge, and X<b>1</b>. (In the example shown in <figref idref="DRAWINGS">FIGS. 12A and 12B</figref>, we do not show how the values in the l_name column were originally encoded but that once decoded they can be readily JOINed. Also, the padded string length for l_name is 6 alphanumeric characters. Further, only the true rows are shown in the intake and discharge tables for a simpler presentation. Finally, for easier visualization, the bold italicized rows shown in the intake, discharge, and X<b>1</b> tables are the ones implicated in the JOIN with X<b>1</b> in either J<b>1</b>'s first or second component). The result table obtained can now be fully decoded and returned to the application.</p>
<p id="p-0106" num="0114">Mathematical Functions</p>
<p id="p-0107" num="0115">With regard to mathematical calculations, some calculations can be performed on the server with intermediate results transferred to the client for additional computations and final presentation to the user. For other mathematical computations, complete rows, or at least the numeric values of the implicated columns, must be returned to the client and the full calculation be performed on the client. In all cases, the R<b>1</b> table is used to avoid computing with rows that are scheduled for deletion. The sections below explain how different computations are managed.</p>
<p id="p-0108" num="0116">Comparison Functions</p>
<p id="p-0109" num="0117">Comparisons such as &#x2018;&#x3e;&#x2019;, &#x2018;&#x3c;=&#x2019;, etc. involving numbers can be done on the server. Because the encoded numbers are ordered within each group, we can select from each group exactly which rows satisfy the comparison. By specifying a different comparison constant for each group, the same procedure to create the multi-part query as for the general query case is done here, with each query component seeking the rows which satisfy the comparison in its group. The single large query therefore obtains all the rows satisfying the comparison function in the table.</p>
<p id="p-0110" num="0118">Aggregate Functions</p>
<p id="p-0111" num="0119">MIN and MAX functions can be partially performed on the server and completed on the client. Just like the Comparison Functions above, due to the monotonicity of the mathematical function, the server can find the MIN or MAX value(s) within each group, returning them to the client. The driver can decode the sub-group MIN/MAX values and return the overall MIN or MAX across all the groups to the user.</p>
<p id="p-0112" num="0120">The SUM computation can be started on the server and completed on the client. As an illustration, consider doing a SUM for just one group, to understand the general case. Imagine that the user wants to compute a SUM of a column, and a total of 3 rows from the same group are implicated. The original implicated numeric values are A, B, C; the user needs A+B+C. We add the encoded values for A, B, and C on the server and remove the average and random multiplier factors on the client. Suppose A, B, and C are in group 12 and are encoded as follows:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>((<i>A&#x2212;&#x394;</i>12)*RM12)+RA12<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>((<i>B&#x2212;&#x394;</i>12)*RM12)+RA12<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>((<i>C&#x2212;&#x394;</i>12)*RM12)+RA12<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0113" num="0121">Here &#x394;<b>12</b> is the average of the implicated column for group 12 while RM<b>12</b> and RA<b>12</b> are, respectively, the random multipliers and random addends for the implicated column for group 12. If we add these encodings on the server, we get:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>((<i>A&#x2212;&#x394;</i>12)*RM12)+RA12+((<i>B&#x2212;&#x394;</i>12)*RM12)+RA12+((<i>C&#x2212;&#x394;</i>12)*RM12)+RA12=<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>[(<i>A&#x2212;&#x394;</i>12)+(<i>B&#x2212;&#x394;</i>12)+(<i>C&#x2212;&#x394;</i>12)]*RM12+3*RA12=<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>[(<i>A+B+C</i>)&#x2212;3*&#x394;12]*RM12+3*RA12<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0114" num="0122">We return this value to the client. We also need to return the number of rows implicated to the client, in this case 3. The driver subtracts from the returned result &#x3c;number of rows implicated&#x3e;*[random addend for group] (i.e. 3*RA<b>12</b>, in this example). The random addend it has in its database private key in memory. This result is divided by RM<b>12</b>, which it also has in memory. To this result the driver adds &#x3c;number of rows implicated&#x3e;*[avg of column for group] (i.e. 3*&#x394;<b>12</b>, in this example. Note, the driver has &#x394;<b>12</b> for the implicated column in memory as well). The end result is the required SUM. For a more general multi-group SUM, the group-specific SUMs along with their row counts are returned to the client just as in the example above, decoded, and added together to provide the requested multi-group SUM to the application.</p>
<p id="p-0115" num="0123">The computation for AVG can be done similarly to SUM. We compute the SUM for each group as above, combine each of the partial results on the client to produce a total sum, and divide this value by the total number of rows selected, which should be returned for each group. This is the desired average.</p>
<p id="p-0116" num="0124">Other Functions</p>
<p id="p-0117" num="0125">Although other mathematical functions can be partially performed on the server they mostly have to be done on the client. For trigonometric functions (SIN, COSINE, etc), the rows implicated need to be returned so that the trigonometric functions can be computed on the client. Logarithmic functions have to be computed on the client as well. Exponential functions can be partially computed on the server, but administratively it's easier to do the full computation on the client. Since the random addend for the group, now exponentiated, was added to the original numeric value, it will have to be removed by dividing the exponentiated value from the server by the exponentiated random addend. The random multiplier, a multiplier, would have to be removed on the client by dividing this result by the exponentiated random multiplier. Because the average for the group, now exponentiated, was subtracted from the original numeric value, it will also have to be removed by multiplying the previous result (which removed the exponentiated random multiplier) by the exponentiated average. Given these complex corrections, it's easier to perform the entire calculation on the client. Various other functions (e.g., STDEV (Standard Deviation), POWER, etc.) must be computed on the client as well.</p>
<p id="p-0118" num="0126">Ordering Functions</p>
<p id="p-0119" num="0127">GROUP BY and ORDER BY Statements</p>
<p id="p-0120" num="0128">The GROUP BY and ORDER BY functions can be initially done on the server but mostly will be handled on the client. The GROUP BY function can aggregate data within a group. If only a single group's rows are implicated, the client can simply decode and return the GROUP BY results collected by the server to the user. If the aggregation of variables is done across groups, the server must return the results GROUPed BY within individual groups because of different encodings across groups. The client will decode the data, synthesize values across groups, and present the aggregate results to the user. A similar approach is used for the ORDER BY function. If numeric values must be ORDERed BY and they are just contained within one group, sorting them can be readily done on the server just as described in the Comparison Functions section above. If numeric values must be ORDERed BY and multiple groups are implicated, then all the affected rows will have to be returned to the client, decoded, and ordered in DESCENDING, etc. order and presented to the user. Numeric order is not preserved across groups. Finally, all affected rows will also have to be returned to the client when doing ORDER BY involving string comparisons. Because lexical order is not preserved after original plaintext characters are randomly permuted into other characters, all the implicated rows will have to be returned to the client. The driver will decode the rows, alphabetize the strings as requested, and present the ordered rows to the user.</p>
<p id="p-0121" num="0129">Performing Secure String Comparisons</p>
<p id="p-0122" num="0130">However, outside of the ORDER BY clause, doing direct string comparisons&#x2014;e.g., when explicitly requested by the user in his WHERE clause&#x2014;, is possible on the server. The driver constructs SQL requests to extract the necessary strings plus false SQL requests to extract strings which are purposefully NOT &#x201c;greater than&#x201d;, NOT &#x201c;less than&#x201d;, etc. compared to the user's comparison string. The former SQL requests provide the needed result set rows while the latter SQL requests undermine the intruder's re-identification efforts. Although lexical order is not preserved on strings, the driver does know which strings are &#x201c;&#x3e;&#x201d;, &#x201c;&#x3c;&#x201d;, etc. compared to the user's comparison constant(s). Our anonymized query is constructed to specifically ask for those strings. Due to the sheer volume, the driver doesn't itemize all possible strings meeting the user's criteria. Instead, the driver only specifies the individual characters in the first character position of the string that satisfies the user's request. The driver constructs a LIKE statement containing all the needed first position characters which, collectively, locates a superset of all strings that are in the user's requested range. From this result set the driver selects the specific rows needed by the user. For example, if the user asks for all rows &#x201c; . . . WHERE last_name&#x3e;&#x2018;williams&#x2019;&#x201d;, the first letter in the comparison string is &#x201c;w&#x201d;. The range is the lower case letters; therefore, on the server we must find those rows where last_name starts with individual letters from &#x201c;w&#x201d; though &#x201c;z&#x201d;. Each of these letters in the range enters a LIKE clause so that the correct rows can be located in the targeted anonymized table. The driver also adds to the LIKE clause several false characters, opposite of what the user asked for, to retrieve fake, unnecessary rows as well. Given the WHERE clause just mentioned, the driver will ask for last_names that begin with, say, &#x201c;d&#x201d;, &#x201c;e&#x201d; and &#x201c;k&#x201d; to be returned, too.</p>
<p id="p-0123" num="0131">From a security perspective, the intruder, who sees how many parts comprise our LIKE statement, will not be able to tell which string the user originally asked for. First, we are asking for character positions, not strings, so the most the intruder can surmise is that we are looking for &#x201c;&#x3e;=&#x2018;w&#x2019;&#x201d; rather than &#x201c;&#x3e;&#x2018;williams&#x2019;&#x201d;. Second, the mere fact that we send a particular number of characters in our encoded LIKE statement does not tell the intruder if the encoded query represents a simple comparison such as &#x201c;&#x3e;=&#x2018;w&#x2019;&#x201d; or a more complex one such as &#x201c;&#x3e;=&#x2018;c&#x2019; AND &#x3c;=&#x2018;f&#x2019;&#x201d;. In both cases, in the domain of lower-case characters, both requests will produce an equivalent 4-component query (not including the fake character requests). Hence, the intruder cannot say what the user really asked for from the database. Third, the intruder also cannot guess which characters we are looking for because of the addition of false characters. The total number of characters in our LIKE statement will probably be larger than the total number of characters arising just from the range of first characters that we are specifying in the LIKE clause. The intruder can count the characters in the LIKE clause and find the letter that is this many positions from the end of the range or the letter that is this many positions from the beginning of the range. But he will be unable to discern the first letter in the user's original comparison constant because he cannot compute the right offset to be used due the inclusion of the fake characters in the LIKE clause. Finally, the intruder will also not be able to surmise which characters we seek because he will be unable to tell the range we are working with, further weakening re-identification efforts. Lower case and upper case characters are both encoded through random permutations in V<b>1</b>. Simply looking at an encoding does not reveal the case of the original plaintext character. Seeing an &#x201c;h&#x201d; as an encoding of a plaintext character does not reveal to the intruder whether the encoded query represents &#x201c;&#x3e;=&#x2018;s&#x2019;&#x201d; or &#x201c;&#x3e;=&#x2018;S&#x2019;&#x201d;.</p>
<heading id="h-0012" level="1">String Comparison Example</heading>
<p id="p-0124" num="0132">The following example is an illustration of how a string comparison query is constructed.</p>
<p id="p-0125" num="0133">Consider the request &#x201c;SELECT * from patient WHERE last_name &#x3e;&#x2018;smith&#x2019;&#x201d;. We focus on the first character of the constant &#x201c;smith&#x201d;, the letter &#x201c;s&#x201d;. For each group in &#x201c;patient&#x201d; (i.e., now it's in the form of the anonymized table A<b>1</b>), we construct a LIKE statement to find strings beginning with &#x201c;s&#x201d;. The driver appends one character at a time to the clause until it reaches the end of the range of the domain. The range in this case is &#x201c;s&#x201d; through &#x201c;z&#x201d;. To understand the construction of the entire query, let's just focus on encoding one group, say group 23. In group 23, these 8 characters are encoded as, respectively, a, 6, d, w, U, p, Q, s. They enter our anonymized LIKE statement. We also find 0-10 &#x201c;fake&#x201d; characters preceding &#x201c;s&#x201d;, say, a total 4 characters. Imagine these characters are q, e, g, b, and they are encoded as, respectively, y, 3, 9, L in group 23. These characters are also added to our LIKE clause. The encoded subquery for group 23 in A<b>1</b> becomes: &#x201c;SELECT * from patient WHERE last_name LIKE &#x2018;[a6dwUpQsy39L]%&#x2019;. A similar encoded subquery will have to be constructed for all the other groups in A<b>1</b>. All the subqueries are combined into one large query as in the general query case described above and sent to the server. Upon return, in addition to deleting all the false rows, all the unasked-for rows are deleted by the client, too. In the case of group 23, these would relate to the encoded characters y, 3, 9, L. The client would have to delete the unasked-for rows from the other groups using their encodings as well. Lastly, the last_name values in all the remaining rows are decoded. They are compared to the original comparison string &#x201c;smith&#x201d; to find just the last_name values which are &#x201c;&#x3e;&#x2018;smith&#x2019;&#x201d;. These rows are then fully decoded and returned to the user.</p>
<p id="p-0126" num="0134">Performance of String Comparison</p>
<p id="p-0127" num="0135">Because we return more rows to the client than necessary, this method appears a bit slower than if we could issue string comparisons more directly. However, the majority of these rows will have to be returned anyway because they are implicated in the user's query. Any slower performance of this approach therefore mostly arises due the additional rows being retrieved from the fake character requests in the LIKE clause. However, as our Implementation Performance Results section below shows, the overall performance of our scheme on various commands (e.g. SELECT, UPDATE, DELETE, etc.) is good and that includes the use of LIKE constants in WHERE clauses. Therefore, delays to retrieve the fake rows for this approach should be manageable as well.</p>
<p id="p-0128" num="0136">Programming Constructs</p>
<p id="p-0129" num="0137">In addition to general queries, programming constructs such as STORED PROCEDUREs, VIEWs, and similar functions on the server called by clients' database application(s) can be &#x201c;anonymized&#x201d; on the server as well so that they can also work with the anonymized data. Whether the database script of the construct has to be changed on the server, however, depends on its complexity. A simple construct performing very basic queries may require no changes and our driver can call it directly. A simple construct expecting arguments also may require no changes. For example, if the construct takes arguments and targets a single table, our driver can simply create a long query containing as many subqueries as there are groups in the resulting anonymized table. Each subquery will call the construct once using encrypted constant(s) for a particular group in the anonymized table. These subqueries can be linked together via UNION statements so that the client ultimately receives the full set of result rows. Certainly complex constructs may require changes to the database script so that various queries can properly deal with the anonymized data.</p>
<p id="p-0130" num="0138">In embodiments of the present invention, the anonymization process is a relatively infrequently-run process, perhaps happening quarterly or semi-annually. It must be done once to create the ADB. If no new rows are subsequently INSERTed, the owner of the ODB may wish to re-anonymize the ODB several times a year, much as if changing an application or network password. Although statistics are secure and are not changing, good security practice dictates that periodically changing the secret preserves its secrecy. Malicious observers are noticing information about queries and encodings in the ADB, which improves their attempts at re-identification of these essentially static data over time. If rows are INSERTed regularly, the ODB owner may want to re-anonymize the data perhaps once per month or more frequently to create more secure statistics. The ODB must be available for the re-anonymization; alternatively, the ADB can be decrypted and the resulting plaintext database re-anonymized. After every re-anonymization, the new database private key must be placed on the shared network drive. Other clients will access this database private key so that they can properly work with the newly-anonymized tables.</p>
<p id="p-0131" num="0139">In the foregoing exemplary embodiments, we have described various computations over strings as requiring the decryption of results on the client machine before further analysis and aggregation can be completed on the client so that final results can be presented to the user. In fact, should it ever become necessary to analyze encrypted string data on the client, this can also readily be done due to the structure of our table private key for any Ai. Our key (the encoding file) is built on the database in Anonymization Step 13 wherein every character position in V<b>1</b> is permuted into some other position in V<b>1</b>. This permutation is stored in a consistent, ordered fashion in the Ai table private key. For example, for every permutation of lower case characters, we store in our table private key, in alphabetical order, first how the letter &#x201c;a&#x201d; is permuted, then how the letter &#x201c;b&#x201d; is permuted, and so on, until how the letter &#x201c;z&#x201d; is permuted. Furthermore, because each representation of the next character position in a column in a given group is merely appended to the bottom of the table private key as the key is being constructed, and the size of V<b>1</b> obviously does not change during each position permutation, the driver knows at any given time the offset in the Ai table private key where the permutation for a given character position for a given column for a given group begins. This unique structure of the Ai table private key allows the driver to quickly examine the encoded characters of strings returned in result sets and determine their equality or lexical order despite the fact that their character permutations are completely random and regardless of whether the strings are actually in the same or different groups. Therefore, GROUP BY, ORDER BY, and JOIN&#x2014;rather than decrypting data on the client to complete analysis and aggregation, as they are described to at least partly do in the foregoing embodiments&#x2014;these statements can readily be coded within the driver to examine encrypted data on the client. They could be readily re-programmed to work as follows: first, they properly construct the result set to be presented to the user from the result set sent by the server while it's still in encrypted form. Then they decrypt the restructured result set and then they immediately present the decrypted result set to the user. There is no need for these commands to do further work on the result set after it's decrypted because all cleanup (post processing) is done on the encrypted result set sent from the server. Our testing in our &#x201c;Implementation Performance Results&#x201d; section below was not done when such commands were coded to work with encrypted data but rather when they are coded to decrypt results as soon as possible on the client.</p>
<p id="p-0132" num="0140">Also, we can readily encrypt our queries and result sets by encrypting the channel between clients (or some intermediary gateway) and the database server. A scheme such as SSL, IPSEC, etc. can be implemented to protect against known-plaintext attacks and similar kinds of attacks in the literature, if needed.</p>
<p id="p-0133" num="0141">Now described are various working examples of embodiments of the present invention:</p>
<heading id="h-0013" level="1">EXAMPLE 1</heading>
<heading id="h-0014" level="1">Anonymization Process</heading>
<p id="p-0134" num="0142">First, the anonymization technique takes some time to convert the ODB to the ABD. Converting a single table, O<b>1</b>, consisting of a hundred or a thousand rows into an anonymized table A<b>1</b> made up of, respectively, approximately 300 or 3000 rows (i.e., two thirds of the rows are added false rows) and comprised of 30 groups (10 true groups and 20 false groups) takes about several minutes. If we start with an O<b>1</b> containing 1,000,000 rows and wish to create a 30-group anonymized A<b>1</b> table, A<b>1</b> will have close to 3,000,000 rows and the anonymization can take about 5.5 hours to complete. If we wish to convert a 1,000,000-row O<b>1</b> into a 120-group A<b>1</b> table (still having about 3,000,000 rows but being a more secure table), the process takes about 7 hours to complete. Much of the time is spent by the database server running the database scripts. Much of this work can be ported to a JAVA (programming language) program to considerably improve performance. Moving the character encoding process, for example, from a database script to a JAVA (programming language) program changed the time required for this step from 3+ hours to 10 minutes.</p>
<heading id="h-0015" level="1">EXAMPLE 2</heading>
<heading id="h-0016" level="1">Query Performance</heading>
<p id="p-0135" num="0143">The performance of various important queries in our scheme was good. We first examined in more depth our driver's performance compared to one standard, the Microsoft JDBC driver (MS driver from now on). We then compared the performance of our driver operating on two analogous A<b>1</b> tables, with one being more secure than the other because it was divided into more groups. With the exception of a couple of references in this paragraph to the MS driver and the R<b>1</b>O table&#x2014;both related to our comparison with the MS driver&#x2014;the text herein describes our testing environment for both the MS driver comparison and the more-secure table comparison. Our testing was done on the MS SQL 2008 Server. The performance times pertaining to our driver below include the discarding of any false rows and the decoding, and string value trimming, of the result set by the driver to only present the proper plaintext values to the user. Note, as part of the creation of the ADB for our testing purposes, we did not employ the random addend for each numeric column as per Anonymization Step 11. We only used the average and random multiplier to encode a numeric column as described in that Step, and our statistics below reflect the usage of this pair only. However, because the random addend is only added to a number to encode it, it's incorporation to produce anonymous queries, as will be described below, and decode the result sets coming back should have minimal if any impact on the statistics below. The CPU of any computer should almost instantly handle the appropriate computations to incorporate the addend. For the purposes of our comparison with the MS driver, we compared retrieval times of the MS driver on an O<b>1</b> table with 1,000,000 rows to that of our driver on the resulting A<b>1</b> table of about 3,000,000 rows divided into 120 groups. Although we have recommended using a total of 30 groups for anonymization purposes earlier we wanted to examine the performance of an even more secure table to gauge any performance impact. Because in a real production environment at any given time a small portion of rows from the ODB is always deleted, we wanted to engage our DELETE mechanism so we could mirror and thus test our scheme's performance in an &#x201c;equivalent&#x201d; environment. Our DELETE mechanism is implemented by storing the RowNums to be DELETEd in R<b>1</b>. A number of our queries are implemented to also check the R<b>1</b> table before retrieving or computing over the implicated rows to avoid processing any DELETEd rows. For most of the queries below, we purposefully DELETEd about 50,000 rows from the O<b>1</b> table and an equivalent amount from the A<b>1</b> table. (That is, for the A<b>1</b> table we INSERTed the RowNums of the rows to be DELETEd into R<b>1</b>). For the purposes of our comparison with the MS driver, we used an equivalent R<b>1</b>, called R<b>1</b>O from now on, for the O<b>1</b> tables to hold the row numbers to be DELETEd for these tables. We similarly checked against R<b>1</b>O when performing various queries against the O<b>1</b> tables to avoid processing any DELETEd rows.</p>
<p id="p-0136" num="0144">Our driver's performance results compared to the MS driver are summarized in Tables 4 and 5 below, the latter illustrating our performance comparison results for the JOIN command. The illustrations are followed by a discussion.</p>
<p id="p-0137" num="0145">
<tables id="TABLE-US-00004" num="00004">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="161pt" align="center"/>
<colspec colname="2" colwidth="21pt" align="center"/>
<colspec colname="3" colwidth="77pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="3" rowsep="1">TABLE 4</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry>Our Driver</entry>
<entry/>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="84pt" align="center"/>
<colspec colname="2" colwidth="77pt" align="center"/>
<colspec colname="3" colwidth="21pt" align="center"/>
<colspec colname="4" colwidth="77pt" align="center"/>
<tbody valign="top">
<row>
<entry>Table: about </entry>
<entry>Num of </entry>
<entry/>
<entry/>
</row>
<row>
<entry>3,000,000</entry>
<entry>Groups:</entry>
<entry/>
<entry/>
</row>
<row>
<entry>rows</entry>
<entry>about 120</entry>
<entry/>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="6">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="center"/>
<colspec colname="3" colwidth="35pt" align="center"/>
<colspec colname="4" colwidth="42pt" align="left"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="77pt" align="center"/>
<tbody valign="top">
<row>
<entry/>
<entry>Anonymized </entry>
<entry>True </entry>
<entry/>
<entry/>
<entry>Microsoft Driver</entry>
</row>
<row>
<entry/>
<entry>Result Set</entry>
<entry>Result</entry>
<entry/>
<entry/>
<entry>Table:</entry>
</row>
<row>
<entry/>
<entry>(total true</entry>
<entry>Set </entry>
<entry/>
<entry/>
<entry>1,000,000 rows</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="7">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="center"/>
<colspec colname="3" colwidth="35pt" align="center"/>
<colspec colname="4" colwidth="42pt" align="left"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="35pt" align="center"/>
<colspec colname="7" colwidth="42pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>and false </entry>
<entry>(total true</entry>
<entry/>
<entry/>
<entry>True </entry>
<entry/>
</row>
<row>
<entry/>
<entry>rows </entry>
<entry>rows</entry>
<entry/>
<entry/>
<entry>Result</entry>
<entry/>
</row>
<row>
<entry>Command</entry>
<entry>returned)</entry>
<entry>extracted)</entry>
<entry>Speed</entry>
<entry/>
<entry>Set</entry>
<entry>Speed</entry>
</row>
<row>
<entry namest="1" nameend="7" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="9">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="21pt" align="right"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="21pt" align="center"/>
<colspec colname="7" colwidth="35pt" align="char" char="."/>
<colspec colname="8" colwidth="21pt" align="right"/>
<colspec colname="9" colwidth="21pt" align="left"/>
<tbody valign="top">
<row>
<entry>SELECT </entry>
<entry>~51,500</entry>
<entry>~47,500</entry>
<entry>~1</entry>
<entry>min.,</entry>
<entry><img id="CUSTOM-CHARACTER-00001" he="2.12mm" wi="2.46mm" file="US08626749-20140107-P00001.TIF" alt="custom character" img-content="character" img-format="tif"/> </entry>
<entry>~47,500</entry>
<entry>3+ </entry>
<entry>min.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="8">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="21pt" align="right"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="21pt" align="left"/>
<colspec colname="7" colwidth="35pt" align="char" char="."/>
<colspec colname="8" colwidth="42pt" align="center"/>
<tbody valign="top">
<row>
<entry>(large </entry>
<entry/>
<entry/>
<entry>50 </entry>
<entry>sec.</entry>
<entry/>
<entry/>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="7">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="42pt" align="center"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="35pt" align="char" char="."/>
<colspec colname="7" colwidth="42pt" align="center"/>
<tbody valign="top">
<row>
<entry>request)</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="9">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="21pt" align="right"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="21pt" align="center"/>
<colspec colname="7" colwidth="35pt" align="char" char="."/>
<colspec colname="8" colwidth="21pt" align="right"/>
<colspec colname="9" colwidth="21pt" align="left"/>
<tbody valign="top">
<row>
<entry>SELECT </entry>
<entry>~780</entry>
<entry>2</entry>
<entry>2-3 </entry>
<entry>sec.</entry>
<entry><img id="CUSTOM-CHARACTER-00002" he="2.12mm" wi="2.46mm" file="US08626749-20140107-P00002.TIF" alt="custom character" img-content="character" img-format="tif"/> </entry>
<entry>2</entry>
<entry>2-3 </entry>
<entry>sec.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="7">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="42pt" align="center"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="35pt" align="char" char="."/>
<colspec colname="7" colwidth="42pt" align="center"/>
<tbody valign="top">
<row>
<entry>(small</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
<row>
<entry>request)</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="9">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="21pt" align="right"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="21pt" align="center"/>
<colspec colname="7" colwidth="35pt" align="char" char="."/>
<colspec colname="8" colwidth="21pt" align="right"/>
<colspec colname="9" colwidth="21pt" align="left"/>
<tbody valign="top">
<row>
<entry>numeric &#x201c;&#x3e;&#x201d;</entry>
<entry>~1,840</entry>
<entry>~930</entry>
<entry>~5</entry>
<entry>sec.</entry>
<entry><img id="CUSTOM-CHARACTER-00003" he="2.12mm" wi="2.46mm" file="US08626749-20140107-P00003.TIF" alt="custom character" img-content="character" img-format="tif"/> </entry>
<entry>~930</entry>
<entry>~5 </entry>
<entry>sec.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="7">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="42pt" align="center"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="35pt" align="char" char="."/>
<colspec colname="7" colwidth="42pt" align="center"/>
<tbody valign="top">
<row>
<entry>comparison</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
<row>
<entry>(larger</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
<row>
<entry>request)</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="9">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="21pt" align="right"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="21pt" align="center"/>
<colspec colname="7" colwidth="35pt" align="char" char="."/>
<colspec colname="8" colwidth="21pt" align="right"/>
<colspec colname="9" colwidth="21pt" align="left"/>
<tbody valign="top">
<row>
<entry>numeric &#x201c;&#x3e;&#x201d;</entry>
<entry>~5</entry>
<entry>3</entry>
<entry>2-3 </entry>
<entry>sec.</entry>
<entry><img id="CUSTOM-CHARACTER-00004" he="2.12mm" wi="2.46mm" file="US08626749-20140107-P00004.TIF" alt="custom character" img-content="character" img-format="tif"/> </entry>
<entry>~3</entry>
<entry>2-3 </entry>
<entry>sec.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="7">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="42pt" align="center"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="35pt" align="char" char="."/>
<colspec colname="7" colwidth="42pt" align="center"/>
<tbody valign="top">
<row>
<entry>comparison</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
<row>
<entry>(small</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
<row>
<entry>request)</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="9">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="21pt" align="right"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="21pt" align="center"/>
<colspec colname="7" colwidth="35pt" align="char" char="."/>
<colspec colname="8" colwidth="21pt" align="right"/>
<colspec colname="9" colwidth="21pt" align="left"/>
<tbody valign="top">
<row>
<entry>DELETE </entry>
<entry>~101,800</entry>
<entry>~95,400</entry>
<entry>~8 </entry>
<entry>sec.</entry>
<entry><img id="CUSTOM-CHARACTER-00005" he="2.12mm" wi="2.46mm" file="US08626749-20140107-P00005.TIF" alt="custom character" img-content="character" img-format="tif"/> </entry>
<entry>~95,400</entry>
<entry>~7 </entry>
<entry>sec.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="7">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="42pt" align="center"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="35pt" align="char" char="."/>
<colspec colname="7" colwidth="42pt" align="center"/>
<tbody valign="top">
<row>
<entry>(large</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
<row>
<entry>request)</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="9">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="21pt" align="right"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="21pt" align="center"/>
<colspec colname="7" colwidth="35pt" align="char" char="."/>
<colspec colname="8" colwidth="21pt" align="right"/>
<colspec colname="9" colwidth="21pt" align="left"/>
<tbody valign="top">
<row>
<entry>DELETE</entry>
<entry>~780</entry>
<entry>2</entry>
<entry>2-3 </entry>
<entry>sec.</entry>
<entry><img id="CUSTOM-CHARACTER-00006" he="2.12mm" wi="2.46mm" file="US08626749-20140107-P00006.TIF" alt="custom character" img-content="character" img-format="tif"/> </entry>
<entry>2</entry>
<entry>2-3 </entry>
<entry>sec.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="7">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="42pt" align="center"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="35pt" align="char" char="."/>
<colspec colname="7" colwidth="42pt" align="center"/>
<tbody valign="top">
<row>
<entry>(small</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
<row>
<entry>request)</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="9">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="21pt" align="right"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="21pt" align="center"/>
<colspec colname="7" colwidth="35pt" align="char" char="."/>
<colspec colname="8" colwidth="21pt" align="right"/>
<colspec colname="9" colwidth="21pt" align="left"/>
<tbody valign="top">
<row>
<entry>COUNT </entry>
<entry>~107,200</entry>
<entry>~94,800</entry>
<entry>4-5 </entry>
<entry>sec.</entry>
<entry><img id="CUSTOM-CHARACTER-00007" he="2.12mm" wi="2.46mm" file="US08626749-20140107-P00007.TIF" alt="custom character" img-content="character" img-format="tif"/> </entry>
<entry>~94,800</entry>
<entry>~4 </entry>
<entry>sec.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="7">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="42pt" align="center"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="35pt" align="char" char="."/>
<colspec colname="7" colwidth="42pt" align="center"/>
<tbody valign="top">
<row>
<entry>(large</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
<row>
<entry>request)</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="9">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="21pt" align="right"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="21pt" align="center"/>
<colspec colname="7" colwidth="35pt" align="char" char="."/>
<colspec colname="8" colwidth="21pt" align="right"/>
<colspec colname="9" colwidth="21pt" align="left"/>
<tbody valign="top">
<row>
<entry>COUNT</entry>
<entry>~780</entry>
<entry>2</entry>
<entry>2-3 </entry>
<entry>sec.</entry>
<entry><img id="CUSTOM-CHARACTER-00008" he="2.12mm" wi="2.46mm" file="US08626749-20140107-P00006.TIF" alt="custom character" img-content="character" img-format="tif"/> </entry>
<entry>2</entry>
<entry>~2 </entry>
<entry>sec.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="7">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="42pt" align="center"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="35pt" align="char" char="."/>
<colspec colname="7" colwidth="42pt" align="center"/>
<tbody valign="top">
<row>
<entry>(small</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
<row>
<entry>request)</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="9">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="21pt" align="right"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="21pt" align="center"/>
<colspec colname="7" colwidth="35pt" align="char" char="."/>
<colspec colname="8" colwidth="21pt" align="right"/>
<colspec colname="9" colwidth="21pt" align="left"/>
<tbody valign="top">
<row>
<entry>UPDATE</entry>
<entry>~107,200</entry>
<entry>~95,000</entry>
<entry>~39 </entry>
<entry>sec.</entry>
<entry><img id="CUSTOM-CHARACTER-00009" he="2.12mm" wi="2.46mm" file="US08626749-20140107-P00008.TIF" alt="custom character" img-content="character" img-format="tif"/> </entry>
<entry>~95,000</entry>
<entry>~15 </entry>
<entry>sec.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="7">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="42pt" align="center"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="35pt" align="char" char="."/>
<colspec colname="7" colwidth="42pt" align="center"/>
<tbody valign="top">
<row>
<entry>(large</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
<row>
<entry>request)</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="9">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="21pt" align="right"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="21pt" align="center"/>
<colspec colname="7" colwidth="35pt" align="char" char="."/>
<colspec colname="8" colwidth="21pt" align="right"/>
<colspec colname="9" colwidth="21pt" align="left"/>
<tbody valign="top">
<row>
<entry>UPDATE</entry>
<entry>~1,530</entry>
<entry>2</entry>
<entry>~5 </entry>
<entry>sec.</entry>
<entry><img id="CUSTOM-CHARACTER-00010" he="2.12mm" wi="2.46mm" file="US08626749-20140107-P00009.TIF" alt="custom character" img-content="character" img-format="tif"/> </entry>
<entry>2</entry>
<entry>~2 </entry>
<entry>sec.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="7">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="left"/>
<colspec colname="3" colwidth="35pt" align="left"/>
<colspec colname="4" colwidth="42pt" align="left"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="35pt" align="left"/>
<colspec colname="7" colwidth="42pt" align="left"/>
<tbody valign="top">
<row>
<entry>(small</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
<row>
<entry>request)</entry>
</row>
<row>
<entry namest="1" nameend="7" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0138" num="0146">For the JOIN discussion below&#x2014;part of our comparison with the MS driver&#x2014;, our O<b>1</b> was only 100,000 rows not 1,000,000 rows as above for the main MS driver comparison testing. For the JOIN comparison we only DELETEd about 5,000 rows from the O<b>1</b> table and an equivalent amount from the A<b>1</b> table. As we will see in the JOIN discussion below we tested JOINing O<b>1</b> to O<b>2</b> with JOINing A<b>1</b> to A<b>2</b>. O<b>2</b> had a size of 20 rows while A<b>2</b> had a size of about 60 rows. Our performance results for the JOIN command are summarized in Table 5:</p>
<p id="p-0139" num="0147">
<tables id="TABLE-US-00005" num="00005">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="182pt" align="center"/>
<colspec colname="2" colwidth="21pt" align="left"/>
<colspec colname="3" colwidth="77pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="3" rowsep="1">TABLE 5</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry>Our Driver</entry>
<entry/>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="98pt" align="center"/>
<colspec colname="2" colwidth="84pt" align="center"/>
<colspec colname="3" colwidth="21pt" align="left"/>
<colspec colname="4" colwidth="77pt" align="center"/>
<tbody valign="top">
<row>
<entry>Table A1: about 300,000 rows</entry>
<entry/>
<entry/>
<entry>Microsoft Driver</entry>
</row>
<row>
<entry>Table A2: about 60 rows</entry>
<entry>Num. of Groups: about 120</entry>
<entry/>
<entry>Table O1: 100,000 rows</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="5">
<colspec colname="1" colwidth="35pt" align="left"/>
<colspec colname="2" colwidth="63pt" align="center"/>
<colspec colname="3" colwidth="84pt" align="center"/>
<colspec colname="4" colwidth="21pt" align="left"/>
<colspec colname="5" colwidth="77pt" align="center"/>
<tbody valign="top">
<row>
<entry/>
<entry>Anonymized Result</entry>
<entry>Num. of Groups: about 30</entry>
<entry/>
<entry>Table O2: 20 rows</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="7">
<colspec colname="1" colwidth="35pt" align="left"/>
<colspec colname="2" colwidth="63pt" align="center"/>
<colspec colname="3" colwidth="56pt" align="center"/>
<colspec colname="4" colwidth="28pt" align="left"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="35pt" align="center"/>
<colspec colname="7" colwidth="42pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Set (true + false rows</entry>
<entry>True Result Set</entry>
<entry/>
<entry/>
<entry>True </entry>
<entry/>
</row>
<row>
<entry/>
<entry>and row frequency</entry>
<entry>(total true rows</entry>
<entry/>
<entry/>
<entry>Result</entry>
<entry/>
</row>
<row>
<entry>Command</entry>
<entry>counts returned)</entry>
<entry>extracted)</entry>
<entry>Speed</entry>
<entry/>
<entry>Set</entry>
<entry>Speed</entry>
</row>
<row>
<entry namest="1" nameend="7" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="7">
<colspec colname="1" colwidth="35pt" align="center"/>
<colspec colname="2" colwidth="63pt" align="center"/>
<colspec colname="3" colwidth="56pt" align="center"/>
<colspec colname="4" colwidth="28pt" align="center"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="35pt" align="center"/>
<colspec colname="7" colwidth="42pt" align="center"/>
<tbody valign="top">
<row>
<entry>JOIN</entry>
<entry>~52,600</entry>
<entry>~76,000</entry>
<entry>&#x3c;2.5</entry>
<entry><img id="CUSTOM-CHARACTER-00011" he="2.12mm" wi="3.13mm" file="US08626749-20140107-P00010.TIF" alt="custom character" img-content="character" img-format="tif"/> </entry>
<entry>~76,000</entry>
<entry>almost 5</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="6">
<colspec colname="1" colwidth="98pt" align="left"/>
<colspec colname="2" colwidth="56pt" align="left"/>
<colspec colname="3" colwidth="28pt" align="center"/>
<colspec colname="4" colwidth="21pt" align="left"/>
<colspec colname="5" colwidth="35pt" align="left"/>
<colspec colname="6" colwidth="42pt" align="center"/>
<tbody valign="top">
<row>
<entry/>
<entry/>
<entry>min.</entry>
<entry/>
<entry/>
<entry>min.</entry>
</row>
<row>
<entry namest="1" nameend="6" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0140" num="0148">We now elaborate on results shown in Tables 4 and 5s.</p>
<p id="p-0141" num="0149">SELECT Statement</p>
<p id="p-0142" num="0150">With regard to completing SELECT commands, our driver was equally fast compared to the MS driver when result sets were small. It was considerably faster than the MS driver when result sets were large. When retrieving a small result set from O<b>1</b> (2 individual rows via a SELECT statement), the MS driver took 2-3 seconds. Retrieving an identical small result set (which contained 2 true rows and about 780 true and false rows in total) from A<b>1</b> using our driver also took 2-3 seconds. When retrieving a large result set with tens of thousands of rows or more, the MS driver took about a third or more time compared to our driver. Retrieving a result set with about 47,500 rows took the MS driver a little over three minutes to finish. An equivalent result set containing 51,500 true and false rows (and the same about 47,500 true rows) took our driver about a minute and fifty seconds to complete. We suppose that the printing of the results to the screen&#x2014;in which the MS driver preserves the full length of each column and therefore winds up printing many blanks before the field separator, while we only print the true length of each field followed by its separator&#x2014;, may be one reason why our driver performed faster than the MS driver. It may also be the way the MS driver extracts rows from the database (e.g. apparently using a cursor to fetch rows in a specific way from the database before returning for additional rows). The MS driver source code was not available to us so we could not confirm the reason for its slower performance.</p>
<p id="p-0143" num="0151">JOIN Statement</p>
<p id="p-0144" num="0152">Our driver executed the JOIN command considerably faster than the MS driver as well. This was not only due to the possible printing and database query management issues discussed above. We also send less information to the client from the server and therefore optimize communication performance. Because we GROUP frequencies of, for example, the A<b>2</b> table rows rather than sending back each row which is implicated, we reduce the overhead of the communications. For example, imagine we are JOINing A<b>1</b> to A<b>2</b> on field last_name and want to only select A<b>1</b>'s rows. Table A<b>2</b> has 10 rows with the same last name in group 32 which will be implicated in the JOIN. For group 32, we send back one row with that last_name value along with a frequency count of 10; we don't return the other 9 rows, as discussed under JOIN command processing earlier. Because this is done across many tokens in A<b>2</b>, we potentially considerably reduce the amount of data we return (of course, this depends on the size of the JOIN result set). To assess JOIN performance, we tried JOINing an O<b>1</b> table with 100,000 rows with an O<b>2</b> table of 20 rows on a single column and just SELECTing the rows from O<b>1</b>. The MS driver took almost 5 minutes to complete, and a total of about 76,000 rows were involved. We tried JOINing the associated A<b>1</b> table of about 300,000 rows broken into 120 groups with the associated A<b>2</b> table of about 60 rows, again SELECTing just the A<b>1</b> rows. Our driver took a little under 2.5 minutes to finish. (A total of about 52,600 true and false rows, including the frequencies with which certain rows must be reproduced were involved).</p>
<p id="p-0145" num="0153">Comparison Statement (&#x201c;&#x3e;&#x201d;)</p>
<p id="p-0146" num="0154">The performance of the &#x201c;&#x3e;&#x201d; comparison was the same between our driver and the MS driver. A retrieval of a small result set&#x2014;3 rows&#x2014;using the &#x201c;&#x3e;&#x201d; comparison on a numeric column took both the MS driver and our driver about 2-3 seconds to finish. (Our driver retrieved the same 3 rows and about 5 true and false records in total). A retrieval of a larger result set&#x2014;about 930 records&#x2014;using the &#x201c;&#x3e;&#x201d; comparison took both the MS driver and our driver about 5 seconds to complete. (Our driver extracted the same approximately 930 records from within a result set of approximately 1,840 true and false records).</p>
<p id="p-0147" num="0155">DELETE Statement</p>
<p id="p-0148" num="0156">Our DELETE performance was quite close compared to the MS driver. Because we DELETE by INSERTing RowNums into R<b>1</b>, to make a meaningful comparison, we compared our ability to INSERT rows into R<b>1</b> with the MS driver's ability to INSERT rows into the R<b>1</b>O table. Our DELETE statistics measure the time to INSERT the implicated rows into R<b>1</b>, or R<b>1</b>O, as opposed to actually erasing those records from their respective tables. A DELETE for a small number of rows, 2 rows, took 2-3 seconds using the MS driver as well as our driver. (Two rows and about 780 true and false rows in total were DELETEd by our driver). A DELETE command to erase about 95,400 rows from O<b>1</b> took the MS driver about 7 seconds to finish. Our equivalent DELETE command on the A<b>1</b> table (about 95,400 true rows and about 101,800 true and false rows in total were involved) took about 8 seconds to finish.</p>
<p id="p-0149" num="0157">COUNT Statement</p>
<p id="p-0150" num="0158">When issuing COUNT commands, our driver's performance was also quite close to the MS driver. When the number of rows implicated was few (2 rows), the MS driver retrieved a COUNT result in 2 seconds. Our performance on small result sets (e.g., the some 2 rows and a total of about 780 true and false rows were involved) was 2-3 seconds. When the number of rows implicated was large, about 94,800, the MS driver retrieved a COUNT result in 4 seconds, whereas we finished an equivalent retrieval in 4-5 seconds. Our driver worked with a total of about 107,200 true and false rows to retrieve the approximately 94,800 true rows.</p>
<p id="p-0151" num="0159">UPDATE Statement</p>
<p id="p-0152" num="0160">The performance of our driver on the UPDATE command was about two and a half times slower compared to the MS driver. An UPDATE command to alter a single column value implicating a small number of rows (2 rows) took about 2 seconds via the MS driver while it took about 5 seconds via our driver. (Our driver processed about 1,530 true and false rows to UPDATE the 2 true rows). When working with large result sets, an UPDATE command to alter a single column value implicating approximately 95,000 rows took, on average, 15 seconds with the MS driver. With our driver it took, on average, about 39 seconds to finish. Our driver processed about 107,200 true and false rows to UPDATE the approximately 95,000 true rows.</p>
<p id="p-0153" num="0161">In general, when we are slower than the MS driver, we suspect that our poorer performance is due to our need to involve more rows and more columns in our queries. Our queries implicate more sometimes many more (false) rows which the MS driver does not have to deal with. In the case of the UPDATE command, we also have to update the length field in the RecInfo column in addition to updating the implicated column value. The extra update takes approximately half of the time compared to the overall UPDATE elapsed time.</p>
<heading id="h-0017" level="1">EXAMPLE 3</heading>
<heading id="h-0018" level="1">Query Performance Over More Secure Tables</heading>
<p id="p-0154" num="0162">With regard to query performance when the security of tables is increased, in our testing, increasing the number of groups into which an anonymized table is divided did not affect by much the time for queries to complete. We tested an O<b>1</b> containing 1,000,000 rows and the resulting A<b>1</b> containing about 3,000,000 rows divided into 30 groups (10 groups were true and 20 groups were false) as we normally recommend. We then improved security further by dividing an A<b>1</b> generated from a very similar O<b>1</b> (and also having roughly 3,000,000 rows) into 120 groups (40 groups were true and 80 groups were false). We tested the performance of SELECT, COUNT, DELETE, UPDATE, and mathematical comparison functions of the two A<b>1</b>'s. Our testing process was described in the section above, &#x201c;Query Performance&#x201d;. The 120-group A<b>1</b> was, on average, slower by a couple of seconds, if that much, on various queries compared to the 30-group A<b>1</b>. <figref idref="DRAWINGS">FIG. 20</figref> below highlights the performance comparison between the two A<b>1</b>'s:</p>
<p id="p-0155" num="0163">
<tables id="TABLE-US-00006" num="00006">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="175pt" align="center"/>
<colspec colname="2" colwidth="119pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="2" rowsep="1">TABLE 6</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry>A1 Table (30 groups)</entry>
<entry>A1 Table (120 groups)</entry>
</row>
<row>
<entry>Size: about 3,000,000 rows</entry>
<entry>Size: about 3,000,000 rows</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="8">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="center"/>
<colspec colname="3" colwidth="35pt" align="left"/>
<colspec colname="4" colwidth="42pt" align="left"/>
<colspec colname="5" colwidth="14pt" align="center"/>
<colspec colname="6" colwidth="42pt" align="center"/>
<colspec colname="7" colwidth="35pt" align="center"/>
<colspec colname="8" colwidth="42pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Anonymized</entry>
<entry/>
<entry/>
<entry/>
<entry>Anonymized</entry>
<entry>Total</entry>
<entry/>
</row>
<row>
<entry/>
<entry>Result Set </entry>
<entry>True </entry>
<entry/>
<entry/>
<entry>Result </entry>
<entry>Result </entry>
<entry/>
</row>
<row>
<entry/>
<entry>(total </entry>
<entry>Result</entry>
<entry/>
<entry/>
<entry>Set (total </entry>
<entry>Set</entry>
<entry/>
</row>
<row>
<entry/>
<entry>true and </entry>
<entry>Set (total </entry>
<entry/>
<entry/>
<entry>true and</entry>
<entry>(total </entry>
<entry/>
</row>
<row>
<entry/>
<entry>false rows </entry>
<entry>true rows</entry>
<entry/>
<entry/>
<entry>false rows</entry>
<entry>true rows</entry>
<entry/>
</row>
<row>
<entry>Command</entry>
<entry>returned)</entry>
<entry>extracted)</entry>
<entry>Speed</entry>
<entry/>
<entry>returned)</entry>
<entry>extracted)</entry>
<entry>Speed</entry>
</row>
<row>
<entry namest="1" nameend="8" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="10">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="21pt" align="right"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="14pt" align="center"/>
<colspec colname="7" colwidth="42pt" align="char" char="."/>
<colspec colname="8" colwidth="35pt" align="char" char="."/>
<colspec colname="9" colwidth="21pt" align="right"/>
<colspec colname="10" colwidth="21pt" align="left"/>
<tbody valign="top">
<row>
<entry>SELECT</entry>
<entry>~54,100</entry>
<entry>~47,500</entry>
<entry>~1 </entry>
<entry>min.,</entry>
<entry><img id="CUSTOM-CHARACTER-00012" he="2.12mm" wi="2.46mm" file="US08626749-20140107-P00011.TIF" alt="custom character" img-content="character" img-format="tif"/> </entry>
<entry>~51,500</entry>
<entry>~47,500</entry>
<entry>~1 </entry>
<entry>min.,</entry>
</row>
<row>
<entry>(large result</entry>
<entry/>
<entry/>
<entry>44 </entry>
<entry>sec.</entry>
<entry/>
<entry/>
<entry/>
<entry>50 </entry>
<entry>sec.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="8">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="42pt" align="center"/>
<colspec colname="5" colwidth="14pt" align="center"/>
<colspec colname="6" colwidth="42pt" align="char" char="."/>
<colspec colname="7" colwidth="35pt" align="char" char="."/>
<colspec colname="8" colwidth="42pt" align="center"/>
<tbody valign="top">
<row>
<entry>set)</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="10">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="21pt" align="right"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="14pt" align="center"/>
<colspec colname="7" colwidth="42pt" align="char" char="."/>
<colspec colname="8" colwidth="35pt" align="char" char="."/>
<colspec colname="9" colwidth="21pt" align="right"/>
<colspec colname="10" colwidth="21pt" align="left"/>
<tbody valign="top">
<row>
<entry>SELECT</entry>
<entry>~5,500</entry>
<entry>1</entry>
<entry>1-2 </entry>
<entry>sec.</entry>
<entry><img id="CUSTOM-CHARACTER-00013" he="2.12mm" wi="2.46mm" file="US08626749-20140107-P00012.TIF" alt="custom character" img-content="character" img-format="tif"/> </entry>
<entry>~780</entry>
<entry>2</entry>
<entry>2-3 </entry>
<entry>sec.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="8">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="42pt" align="center"/>
<colspec colname="5" colwidth="14pt" align="center"/>
<colspec colname="6" colwidth="42pt" align="char" char="."/>
<colspec colname="7" colwidth="35pt" align="char" char="."/>
<colspec colname="8" colwidth="42pt" align="center"/>
<tbody valign="top">
<row>
<entry>(small result</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
<row>
<entry>set)</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="10">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="21pt" align="right"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="14pt" align="center"/>
<colspec colname="7" colwidth="42pt" align="char" char="."/>
<colspec colname="8" colwidth="35pt" align="char" char="."/>
<colspec colname="9" colwidth="21pt" align="right"/>
<colspec colname="10" colwidth="21pt" align="left"/>
<tbody valign="top">
<row>
<entry>numeric &#x201c;&#x3e;&#x201d;</entry>
<entry>~2,100</entry>
<entry>~930</entry>
<entry>~4 </entry>
<entry>sec.</entry>
<entry><img id="CUSTOM-CHARACTER-00014" he="2.12mm" wi="2.46mm" file="US08626749-20140107-P00013.TIF" alt="custom character" img-content="character" img-format="tif"/> </entry>
<entry>~1,840</entry>
<entry>~930</entry>
<entry>~5 </entry>
<entry>sec.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="8">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="42pt" align="center"/>
<colspec colname="5" colwidth="14pt" align="center"/>
<colspec colname="6" colwidth="42pt" align="char" char="."/>
<colspec colname="7" colwidth="35pt" align="char" char="."/>
<colspec colname="8" colwidth="42pt" align="center"/>
<tbody valign="top">
<row>
<entry>comparison</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
<row>
<entry>(larger result</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
<row>
<entry>set)</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="10">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="21pt" align="right"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="14pt" align="center"/>
<colspec colname="7" colwidth="42pt" align="char" char="."/>
<colspec colname="8" colwidth="35pt" align="char" char="."/>
<colspec colname="9" colwidth="21pt" align="right"/>
<colspec colname="10" colwidth="21pt" align="left"/>
<tbody valign="top">
<row>
<entry>numeric &#x201c;&#x3e;&#x201d;</entry>
<entry>~5</entry>
<entry>3</entry>
<entry>~2 </entry>
<entry>sec.</entry>
<entry><img id="CUSTOM-CHARACTER-00015" he="2.12mm" wi="2.46mm" file="US08626749-20140107-P00014.TIF" alt="custom character" img-content="character" img-format="tif"/> </entry>
<entry>~5</entry>
<entry>3</entry>
<entry>2-3 </entry>
<entry>sec.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="8">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="42pt" align="center"/>
<colspec colname="5" colwidth="14pt" align="center"/>
<colspec colname="6" colwidth="42pt" align="char" char="."/>
<colspec colname="7" colwidth="35pt" align="char" char="."/>
<colspec colname="8" colwidth="42pt" align="center"/>
<tbody valign="top">
<row>
<entry>comparison</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
<row>
<entry>(small result</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
<row>
<entry>set)</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="10">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="21pt" align="right"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="14pt" align="center"/>
<colspec colname="7" colwidth="42pt" align="char" char="."/>
<colspec colname="8" colwidth="35pt" align="char" char="."/>
<colspec colname="9" colwidth="21pt" align="right"/>
<colspec colname="10" colwidth="21pt" align="left"/>
<tbody valign="top">
<row>
<entry>DELETE</entry>
<entry>~114,800</entry>
<entry>~94,800</entry>
<entry>~8 </entry>
<entry>sec.</entry>
<entry><img id="CUSTOM-CHARACTER-00016" he="2.12mm" wi="2.46mm" file="US08626749-20140107-P00015.TIF" alt="custom character" img-content="character" img-format="tif"/> </entry>
<entry>~101,800</entry>
<entry>~95,400</entry>
<entry>~8 </entry>
<entry>sec.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="8">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="42pt" align="center"/>
<colspec colname="5" colwidth="14pt" align="center"/>
<colspec colname="6" colwidth="42pt" align="char" char="."/>
<colspec colname="7" colwidth="35pt" align="char" char="."/>
<colspec colname="8" colwidth="42pt" align="center"/>
<tbody valign="top">
<row>
<entry>(large result</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
<row>
<entry>set)</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="10">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="21pt" align="right"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="14pt" align="center"/>
<colspec colname="7" colwidth="42pt" align="char" char="."/>
<colspec colname="8" colwidth="35pt" align="char" char="."/>
<colspec colname="9" colwidth="21pt" align="right"/>
<colspec colname="10" colwidth="21pt" align="left"/>
<tbody valign="top">
<row>
<entry>DELETE</entry>
<entry>~5,470</entry>
<entry>1</entry>
<entry>~2 </entry>
<entry>sec.</entry>
<entry><img id="CUSTOM-CHARACTER-00017" he="2.12mm" wi="2.46mm" file="US08626749-20140107-P00016.TIF" alt="custom character" img-content="character" img-format="tif"/> </entry>
<entry>~780</entry>
<entry>2</entry>
<entry>2-3 </entry>
<entry>sec.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="8">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="42pt" align="center"/>
<colspec colname="5" colwidth="14pt" align="center"/>
<colspec colname="6" colwidth="42pt" align="char" char="."/>
<colspec colname="7" colwidth="35pt" align="char" char="."/>
<colspec colname="8" colwidth="42pt" align="center"/>
<tbody valign="top">
<row>
<entry>(small result</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
<row>
<entry>set)</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="10">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="21pt" align="right"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="14pt" align="center"/>
<colspec colname="7" colwidth="42pt" align="char" char="."/>
<colspec colname="8" colwidth="35pt" align="char" char="."/>
<colspec colname="9" colwidth="21pt" align="right"/>
<colspec colname="10" colwidth="21pt" align="left"/>
<tbody valign="top">
<row>
<entry>COUNT</entry>
<entry>~115,300</entry>
<entry>~95,500</entry>
<entry>3-4 </entry>
<entry>sec.</entry>
<entry><img id="CUSTOM-CHARACTER-00018" he="2.12mm" wi="2.46mm" file="US08626749-20140107-P00017.TIF" alt="custom character" img-content="character" img-format="tif"/> </entry>
<entry>~107,200</entry>
<entry>~94,800</entry>
<entry>4-5 </entry>
<entry>sec.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="8">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="42pt" align="center"/>
<colspec colname="5" colwidth="14pt" align="center"/>
<colspec colname="6" colwidth="42pt" align="char" char="."/>
<colspec colname="7" colwidth="35pt" align="char" char="."/>
<colspec colname="8" colwidth="42pt" align="center"/>
<tbody valign="top">
<row>
<entry>(large result</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
<row>
<entry>set)</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="10">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="21pt" align="right"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="14pt" align="center"/>
<colspec colname="7" colwidth="42pt" align="char" char="."/>
<colspec colname="8" colwidth="35pt" align="char" char="."/>
<colspec colname="9" colwidth="21pt" align="right"/>
<colspec colname="10" colwidth="21pt" align="left"/>
<tbody valign="top">
<row>
<entry>COUNT</entry>
<entry>~5,470</entry>
<entry>1</entry>
<entry>1-2 </entry>
<entry>sec.</entry>
<entry><img id="CUSTOM-CHARACTER-00019" he="2.12mm" wi="2.46mm" file="US08626749-20140107-P00018.TIF" alt="custom character" img-content="character" img-format="tif"/> </entry>
<entry>~780</entry>
<entry>2</entry>
<entry>2-3 </entry>
<entry>sec.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="8">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="42pt" align="center"/>
<colspec colname="5" colwidth="14pt" align="center"/>
<colspec colname="6" colwidth="42pt" align="char" char="."/>
<colspec colname="7" colwidth="35pt" align="char" char="."/>
<colspec colname="8" colwidth="42pt" align="center"/>
<tbody valign="top">
<row>
<entry>(small result</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
<row>
<entry>set)</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="10">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="21pt" align="right"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="14pt" align="center"/>
<colspec colname="7" colwidth="42pt" align="char" char="."/>
<colspec colname="8" colwidth="35pt" align="char" char="."/>
<colspec colname="9" colwidth="21pt" align="right"/>
<colspec colname="10" colwidth="21pt" align="left"/>
<tbody valign="top">
<row>
<entry>UPDATE</entry>
<entry>~114,800</entry>
<entry>~94,800</entry>
<entry>~30 </entry>
<entry>sec.</entry>
<entry><img id="CUSTOM-CHARACTER-00020" he="2.12mm" wi="2.46mm" file="US08626749-20140107-P00019.TIF" alt="custom character" img-content="character" img-format="tif"/> </entry>
<entry>~107,200</entry>
<entry>~95,000</entry>
<entry>~39 </entry>
<entry>sec.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="8">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="42pt" align="center"/>
<colspec colname="5" colwidth="14pt" align="center"/>
<colspec colname="6" colwidth="42pt" align="char" char="."/>
<colspec colname="7" colwidth="35pt" align="char" char="."/>
<colspec colname="8" colwidth="42pt" align="center"/>
<tbody valign="top">
<row>
<entry>(large result</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
<row>
<entry>set)</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="10">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="char" char="."/>
<colspec colname="3" colwidth="35pt" align="char" char="."/>
<colspec colname="4" colwidth="21pt" align="right"/>
<colspec colname="5" colwidth="21pt" align="left"/>
<colspec colname="6" colwidth="14pt" align="center"/>
<colspec colname="7" colwidth="42pt" align="char" char="."/>
<colspec colname="8" colwidth="35pt" align="char" char="."/>
<colspec colname="9" colwidth="21pt" align="right"/>
<colspec colname="10" colwidth="21pt" align="left"/>
<tbody valign="top">
<row>
<entry>UPDATE</entry>
<entry>~5,470</entry>
<entry>1</entry>
<entry>2-3 </entry>
<entry>sec.</entry>
<entry><img id="CUSTOM-CHARACTER-00021" he="2.12mm" wi="2.46mm" file="US08626749-20140107-P00020.TIF" alt="custom character" img-content="character" img-format="tif"/> </entry>
<entry>~1,530</entry>
<entry>2</entry>
<entry>~5 </entry>
<entry>sec.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="7">
<colspec colname="1" colwidth="42pt" align="left"/>
<colspec colname="2" colwidth="42pt" align="center"/>
<colspec colname="3" colwidth="35pt" align="center"/>
<colspec colname="4" colwidth="56pt" align="left"/>
<colspec colname="5" colwidth="42pt" align="left"/>
<colspec colname="6" colwidth="35pt" align="left"/>
<colspec colname="7" colwidth="42pt" align="left"/>
<tbody valign="top">
<row>
<entry>(small result</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
<row>
<entry>set)</entry>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
<entry/>
</row>
<row>
<entry namest="1" nameend="7" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<heading id="h-0019" level="1">EXAMPLE 4</heading>
<heading id="h-0020" level="1">Database Private Key Issues</heading>
<p id="p-0156" num="0164">One potential drawback of our scheme is the loading of the database private key into memory. When we tested with an A<b>1</b> of 3,000,000 rows and 120 groups, the loading of the various components of the private key could take 7 seconds. However, this delay only happens during the establishment of the session between the application and the database. The establishment of the session happens infrequently; therefore, the 7-second delay should also be infrequently experienced by the user. Our code to load the private key is placed in the initialization routines of the driver because we need the private key early in our processing. These routines are invoked when the session between the application and the database is created. (For example, this may happen when the user opens his application by double clicking on it in his Windows Desktop). The application will not close the session until the application is closed. Otherwise it has to pay the penalty of going through its own initialization routines again to open a new session with the database. Until the session is closed, therefore, the user will not experience the 7-second delay from the loading of the database private key into memory. The delay may be considered part of application initialization and we believe it should not significantly affect the user's experience. There will probably be other initialization delays which the user will have to bear as his application loads, and our 7-second delay may, in fact, be considered one such delay. However, if this becomes problematic, a separate daemon can be built which will start when the user boots his machine, or the first time that the user starts the application. The daemon will load and manage the database private key, communicate with our driver when it requests the key (e.g. for data encoding and decoding), and not close until a truly terminal event, e.g., a machine shut down. Under such a scenario, the 7-second delay is suffered by the user infrequently or, probably, rarely because the daemon should, practically speaking, rarely be closed.</p>
<p id="p-0157" num="0165">A related issue when loading the database private key is memory capacity. In earlier designs of our scheme, we experimented with loading millions of records representing our database private key into memory from disk as we tried to keep track of more metadata related to our anonymized table(s). Because there were so many rows to load, occasionally the driver on our test machine, a laptop with 2 GB or RAM, would hang with error messages such as &#x201c;out of heap space&#x201d;. It is possible that if there are many private key files for many tables to load&#x2014;i.e., one, two, or more million rows placed into memory&#x2014;, the driver may similarly hang on client machines. There are three possible solutions to this problem. One is to purchase more memory for the hanging client workstations. Two is to allocate more overall memory to our driver on the hanging machines. When we increased our internal JAVA (programming language) heap size on our test machine, through a re-configuration of the JAVA (programming language) Virtual Machine, we alleviated the problem. The third solution is to again create a daemon which will manage the database private key for all client workstations. This daemon can be placed on a separate machine which has a large memory. It will communicate with all the clients, or just those that hang, if that is better, when they need access to the database private key.</p>
<heading id="h-0021" level="1">EXAMPLE 5</heading>
<p id="p-0158" num="0166">This Example analyzes why an initial group count of 5 is chosen in Anonymization Step 3. A final total group count of about 30, produced from an initial group count of 5, as explained in Anonymization Step 3, makes it exceedingly difficult to break the string encodings that will be contained in A<b>1</b>. To understand why, we must first understand how the intruder attempts to break our scheme. Let's recall that we anonymize numeric columns by using a monotonic function which preserves the ordering of numbers within every group across all numeric columns. The intruder can use his O<b>1</b> copy, chose a numeric column M<b>0</b> he likes, sort it in descending order, and extract the highest values from the column. Then he locates the corresponding column M<b>1</b> in A<b>1</b>, and launches a matching process to relate his highest values in M<b>0</b> with the highest values in M<b>1</b>. As M<b>1</b> is broken into groups, the intruder uses a loop operation to examine every group he sees in M<b>1</b>. O<b>1</b>'s highest values had to have been distributed within A<b>1</b> somehow, and this matching process attempts to locate them.</p>
<p id="p-0159" num="0167">As he links the two ordered sets of M<b>0</b> and a particular group within M<b>1</b>, the intruder extends the hypothetical links of numbers into links of strings. What we mean is: suppose the intruder has identified a row in M<b>1</b> that he thinks matches one of his highest numeric values in M<b>0</b>. He now makes a hypothetical assumption that the decryption of the field s<b>1</b> from some string column S<b>1</b> from A<b>1</b> (restricted to the row of matching numbers) has value s<b>0</b> which is a field in the corresponding column S<b>0</b> from O<b>1</b> (restricted to the row of matching numbers). He propagates s<b>0</b> as a decoding key onto all characters within the group that match by position and value to the characters of s<b>1</b>. If he is able to completely replace all of A<b>1</b>'s character strings in that group without conflicts (i.e. no interference with decoding attempts based on prior numerical matches), the intruder has found a potential way to decode the group. By going through the matching process and bringing in more decoding rules (i.e. more s<b>0</b>'s), the intruder either completes the decoding of the entire group, or must revisit his previous assumptions and make new matching assumptions for steps he previously completed. If his initial selection of the set of highest numbers in M<b>0</b> and group in M<b>1</b> are large enough he will likely succeed, though it will cost him an enormous amount of time as we calculate below. The remaining highest numeric values from O<b>1</b> can be used to try and decode another group in A<b>1</b>, until all groups in the table are so decoded. Given this approach, we suggest the following heuristic approach to find the number of groups into which A<b>1</b> should be divided. The output of these calculations is an estimate of the maximum time it takes for the intruder to successfully decode one group.
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>Upper bound, in seconds, on time to &#x201c;break&#x201d; one group=[(1% of total # of rows in <i>O</i>1)*(total # of groups in <i>A</i>1)*(1% of total # of rows in <i>A</i>1 group)<sup>3</sup>*(total # of rows per group in <i>A</i>1)*(total # of characters to be decoded per row in <i>A</i>1 group expressed as # of general operations to be carried out on a computer)*(total # of assembly statements required to handle one general operation on a computer)]/[(total # of assembly statements performed by intruder's computer per second)*(# of computers employed by intruder)]<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0160" num="0168">The intuition for these terms stems from our description of the intruder's approach above:</p>
<p id="p-0161" num="0169">The factor (1% of total # of rows in O<b>1</b>) arises because the intruder wants to focus on the top (e.g., 1%) of the numeric values in O<b>1</b>'s numeric column. These are the &#x201c;extreme&#x201d; values which allow her to match the most &#x201c;extreme&#x201d; (i.e., highest) values in A<b>1</b>'s numeric column, leading to more certainty in the matching of values.</p>
<p id="p-0162" num="0170">The factor (total # of groups in A<b>1</b>) arises because, in the worst case, the intruder may need to decode every possible group in A<b>1</b> until he reaches the last group where decoding finally succeeds.</p>
<p id="p-0163" num="0171">The factor (1% of total # of rows in A<b>1</b>)<sup>3 </sup>arises because the intruder has to, in the worst case, complete a nested-loop three levels deep as he tries to decode A<b>1</b>'s string column. First, the intruder has to loop through all possible numbers, call them Ps, in the highest numerical values of A<b>1</b>'s group. He is trying to match them with the highest numbers in O<b>1</b>'s group. Given an initial &#x201c;seed&#x201d;, i.e. a possibly matching P, the intruder tries every other number in his list, we can call them Qs, one by one. He tries to decode the remaining strings in A<b>1</b>'s group using the associated strings from O<b>1</b> which match the Qs. Imagine he gets closer to the end of the list of Qs and fails. That is, he finds he cannot impose a decoding scheme on A<b>1</b>'s group using the O<b>1</b> string matched to the current Q record due to decoding conflicts (e.g., the characters he's trying to decode have already been decoded via a match with a previous Q record). He has to back up one position, to (n&#x2212;1), and try the n-th decoding (the decoding for the current Q record), as the (n&#x2212;1)-th decoding. He has achieved success until now, therefore, he can remove the decoding of the previous O<b>1</b> string and attempt to decode using the current O<b>1</b> string. In the worst case, he will have to go down to almost the end of the list of Qs, then be forced to retrace his steps back to the beginning of the list, and attempt to traverse the (almost) complete list again, trying to find a proper decoding for A<b>1</b>'s string column in the group.</p>
<p id="p-0164" num="0172">The factor (total # of rows per group in A<b>1</b>) arises because for every numerical match, the intruder will have to decode at most the entire string column within A<b>1</b>'s group using the value from O<b>1</b>'s string column. As explained before, during anonymization, we try to maintain the same number of rows per group in every Ai table.</p>
<p id="p-0165" num="0173">The factor (total # of characters to be decoded per row in A<b>1</b> group expressed as # of general operations to be carried out on a computer) arises because for each string replacement attempt, the CPU has to replace, e.g. using SUBSTRING or other pattern matching operations; a specific number of characters in the string. For example, it could be the maximum string length for the column.</p>
<p id="p-0166" num="0174">The factor (total # of assembly statements required to handle one general operation on a computer) arises because a general operation to replace one character within some higher level language (in which the intruder's program presumably would be written) would take more assembly instructions to actually carry out on a computer.</p>
<p id="p-0167" num="0175">The factor (total # of assembly statements performed by intruder's computer per second) arises because we need to incorporate how long it will take the intruder's computer to replace one character during the decoding attempt.</p>
<p id="p-0168" num="0176">The factor (# of computers employed by intruder) arises because the intruder can use more than one CPU and have them work in parallel trying to decrypt the group. The main loop in our &#x201c;algorithm&#x201d; above (and alluded to in step 1 above), can be broken up so that different computers are trying to successfully replace strings in their own range of the highest numeric values in O<b>1</b>.</p>
<p id="p-0169" num="0177">As an illustration of a possible computation of the upper bound, imagine the following values exist for a given installation of our scheme at a customer site:
<ul id="ul0005" list-style="none">
    <li id="ul0005-0001" num="0000">
    <ul id="ul0006" list-style="none">
        <li id="ul0006-0001" num="0178">(1% of total # of rows in O<b>1</b>)=10,000 (i.e., assume an O<b>1</b> of 1,000,000 rows)</li>
        <li id="ul0006-0002" num="0179">(total # of groups in A<b>1</b>)=30 (i.e., imagine the resulting A<b>1</b> is divided into 30 groups)</li>
        <li id="ul0006-0003" num="0180">(total # of rows per group in A<b>1</b>)=100,000 (i.e., assume an A<b>1</b> of approximately 3,000,000 and a group count of 30)</li>
        <li id="ul0006-0004" num="0181">(1% of total # of rows in A<b>1</b>)<sup>3</sup>=(1000)<sup>3 </sup>(i.e., assume an A<b>1</b> of approximately 3,000,000 rows and a group count of 30. Therefore, the row count per group is 100,000, and 1% of this is 1000)</li>
        <li id="ul0006-0005" num="0182">(total # of characters to be decoded per row in A<b>1</b> group)=10 (i.e., assume we are working with column Last Name which has a maximum length of 10 characters. In the worst case, all of these characters would have to be decoded when decoding a row)</li>
        <li id="ul0006-0006" num="0183">(total # of assembly statements required to handle one general operation on a computer)=10</li>
        <li id="ul0006-0007" num="0184">(total # of assembly statements performed by intruder's computer per second)=3,000,000,000 (i.e., a CPU operating at 3.0 GHz)</li>
        <li id="ul0006-0008" num="0185">(# of computers employed by intruder)=1</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0170" num="0186">Therefore, upper bound on the time to break one group, in seconds, is:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>[(10000)*(30)*(1000)<sup>3</sup>*(100000)*(10)*(10)]/[(3000000000)*(1)]=1,000,000,000,000 seconds &#x2dc;31,700 years<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0171" num="0187">Although this is a very high number, it's important to point out that this upper bound estimates the effort to decode one group. The intruder will have to apply similar logic, using his remaining highest values in his 10,000 original O<b>1</b> values, to decode the other groups. Only then has he successfully decoded the full table. The upper bound to decode the entire table would therefore be significantly higher than the estimate above. But even decoding the complete table does not mean that the intruder has decoded the original table. Since we add false rows to A<b>1</b> as part of anonymization, the intruder may obtain a successful decoding on the false groups. Some or many false groups would be decoded via the approach above because false groups are made to mimic true rows and true groups. The intruder cannot definitively say he's decoded the original values because he may have decoded fake values. That is why the final group count of about 30, and an initial group count of 5, is useful for near any table. The upper bound on the time to break the entire table is extremely high. And even if he achieves &#x201c;success,&#x201d; the intruder still can't be sure he's decoded the true rows.</p>
<p id="p-0172" num="0188">
<tables id="TABLE-US-00007" num="00007">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<tbody valign="top">
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>GLOSSARY</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="63pt" align="left"/>
<colspec colname="2" colwidth="154pt" align="left"/>
<tbody valign="top">
<row>
<entry>Term</entry>
<entry>Definition</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
<row>
<entry>ODB</entry>
<entry>The original unencrypted database.</entry>
</row>
<row>
<entry>O1 . . . Op, </entry>
<entry>O1 . . . Op are the original unencrypted</entry>
</row>
<row>
<entry>Oi, Oj</entry>
<entry>tables making up the ODB: O1 through</entry>
</row>
<row>
<entry/>
<entry>Op. Oi and Oj are the more generic</entry>
</row>
<row>
<entry/>
<entry>descriptions of these tables. That is, </entry>
</row>
<row>
<entry/>
<entry>i, j = 1 . . . p.</entry>
</row>
<row>
<entry>ADB</entry>
<entry>The anonymized database into which</entry>
</row>
<row>
<entry/>
<entry>the ODB is converted.</entry>
</row>
<row>
<entry>A1 . . . Ap, </entry>
<entry>A1 . . . Ap are the anonymized tables</entry>
</row>
<row>
<entry>A2, Ai, Aj</entry>
<entry>making up the ADB, into which tables</entry>
</row>
<row>
<entry/>
<entry>O1 through Op are converted. A2, and</entry>
</row>
<row>
<entry/>
<entry>more generally, Ai and Aj are the same</entry>
</row>
<row>
<entry/>
<entry>as tables A1 . . . Ap. That is, in the case of</entry>
</row>
<row>
<entry/>
<entry>Ai and Aj, i, j = 1 . . . p.</entry>
</row>
<row>
<entry>V1</entry>
<entry>Table to hold all possible alphanumeric</entry>
</row>
<row>
<entry/>
<entry>symbols making up tables O1 . . . Op. </entry>
</row>
<row>
<entry/>
<entry>The overall goal of V1 is to maintain the</entry>
</row>
<row>
<entry/>
<entry>data schema of the ODB in the ADB so</entry>
</row>
<row>
<entry/>
<entry>that existing database applications</entry>
</row>
<row>
<entry/>
<entry>continue to work. V1 is used for</entry>
</row>
<row>
<entry/>
<entry>constructing the private</entry>
</row>
<row>
<entry/>
<entry>encoding/decoding key for each Ai,</entry>
</row>
<row>
<entry/>
<entry>including the key to encode/decode</entry>
</row>
<row>
<entry/>
<entry>string value lengths for each Ai.</entry>
</row>
<row>
<entry>B1</entry>
<entry>The first temporary table into which O1</entry>
</row>
<row>
<entry/>
<entry>is converted as its being anonymized.</entry>
</row>
<row>
<entry>GpNum</entry>
<entry>New column introduced into every</entry>
</row>
<row>
<entry/>
<entry>table A1 through Ap as tables O1</entry>
</row>
<row>
<entry/>
<entry>through Op are anonymized. GpNum</entry>
</row>
<row>
<entry/>
<entry>holds the number of the group to</entry>
</row>
<row>
<entry/>
<entry>which a given row belongs. Used to</entry>
</row>
<row>
<entry/>
<entry>discard rows from result sets that</entry>
</row>
<row>
<entry/>
<entry>belong to &#x201c;false&#x201d; groups (i.e. which</entry>
</row>
<row>
<entry/>
<entry>contain fake records) and retain rows</entry>
</row>
<row>
<entry/>
<entry>that belong to &#x201c;true&#x201d; groups (i.e.</entry>
</row>
<row>
<entry/>
<entry>containing the original ODB data).</entry>
</row>
<row>
<entry>RecInfo</entry>
<entry>New column introduced into every</entry>
</row>
<row>
<entry/>
<entry>table A1 through Ap as tables O1</entry>
</row>
<row>
<entry/>
<entry>through Op are anonymized. RecInfo</entry>
</row>
<row>
<entry/>
<entry>contains the lengths of each string</entry>
</row>
<row>
<entry/>
<entry>value in that row, permuted to be</entry>
</row>
<row>
<entry/>
<entry>represented as a character within the</entry>
</row>
<row>
<entry/>
<entry>list of V1 symbols. Used to trim string</entry>
</row>
<row>
<entry/>
<entry>values in results sets so that the proper</entry>
</row>
<row>
<entry/>
<entry>string values can be returned to the</entry>
</row>
<row>
<entry/>
<entry>user.</entry>
</row>
<row>
<entry>RowNum</entry>
<entry>New column introduced into every</entry>
</row>
<row>
<entry/>
<entry>table A1 through Ap as tables O1</entry>
</row>
<row>
<entry/>
<entry>through Op are anonymized. RowNum</entry>
</row>
<row>
<entry/>
<entry>is the row number for the row. Used to</entry>
</row>
<row>
<entry/>
<entry>determine if a numeric value in a result</entry>
</row>
<row>
<entry/>
<entry>set row was originally an outlier so that</entry>
</row>
<row>
<entry/>
<entry>its proper outlier value can be restored</entry>
</row>
<row>
<entry/>
<entry>before it's returned to the user.</entry>
</row>
<row>
<entry>R1, Ri</entry>
<entry>R1 is a table used for DELETE command</entry>
</row>
<row>
<entry/>
<entry>processing. It holds the RowNums for</entry>
</row>
<row>
<entry/>
<entry>those rows that are scheduled for</entry>
</row>
<row>
<entry/>
<entry>deletion. If any rows in R1 are</entry>
</row>
<row>
<entry/>
<entry>implicated in any query they will not be</entry>
</row>
<row>
<entry/>
<entry>processed because the rows are</entry>
</row>
<row>
<entry/>
<entry>ultimately scheduled to be erased. Ri is</entry>
</row>
<row>
<entry/>
<entry>just like R1 but for the other Ai tables;</entry>
</row>
<row>
<entry/>
<entry>that is, i = 2 . . . p. Ri is used to handle the</entry>
</row>
<row>
<entry/>
<entry>processing of the DELETE command for</entry>
</row>
<row>
<entry/>
<entry>each Ai. Ri holds the RowNums of rows</entry>
</row>
<row>
<entry/>
<entry>that are scheduled for deletion. If any</entry>
</row>
<row>
<entry/>
<entry>rows in Ri are implicated in any Ai</entry>
</row>
<row>
<entry/>
<entry>query they will not be processed</entry>
</row>
<row>
<entry/>
<entry>because they are scheduled to be</entry>
</row>
<row>
<entry/>
<entry>erased.</entry>
</row>
<row>
<entry>E1</entry>
<entry>Temporary table used to foil re-</entry>
</row>
<row>
<entry/>
<entry>identification attempts via token</entry>
</row>
<row>
<entry/>
<entry>frequency analysis attacks. E1 contains</entry>
</row>
<row>
<entry/>
<entry>a histogram of tokens in every string</entry>
</row>
<row>
<entry/>
<entry>column in B1. In every column in the</entry>
</row>
<row>
<entry/>
<entry>histogram, tokens are combined into</entry>
</row>
<row>
<entry/>
<entry>disjoint sets of 5. E1 records the</entry>
</row>
<row>
<entry/>
<entry>number of rows needed for each token</entry>
</row>
<row>
<entry/>
<entry>to equal the frequency of the leader in</entry>
</row>
<row>
<entry/>
<entry>its 5-element group. Used in</entry>
</row>
<row>
<entry/>
<entry>conjunction with the C1 table.</entry>
</row>
<row>
<entry>C1</entry>
<entry>Temporary table used with E1; it</entry>
</row>
<row>
<entry/>
<entry>contains &#x201c;false&#x201d; rows randomly</entry>
</row>
<row>
<entry/>
<entry>selected from B1. Tokens will be</entry>
</row>
<row>
<entry/>
<entry>replaced in the columns in C1 based on</entry>
</row>
<row>
<entry/>
<entry>their &#x201c;rows needed&#x201d; parameter in E1.</entry>
</row>
<row>
<entry/>
<entry>The purpose of this replacement is to</entry>
</row>
<row>
<entry/>
<entry>ensure that result sets involving string</entry>
</row>
<row>
<entry/>
<entry>tokens in any 5-group set will return</entry>
</row>
<row>
<entry/>
<entry>true and false rows whose total</entry>
</row>
<row>
<entry/>
<entry>number approximately equals, which</entry>
</row>
<row>
<entry/>
<entry>considerably undermines re-</entry>
</row>
<row>
<entry/>
<entry>identification efforts.</entry>
</row>
<row>
<entry>Aggregated </entry>
<entry>Used in the context of E1 and F1. The</entry>
</row>
<row>
<entry>&#x201c;rows</entry>
<entry>total number of &#x201c;rows needed&#x201d; for a</entry>
</row>
<row>
<entry>needed&#x201d; </entry>
<entry>given column or position in,</entry>
</row>
<row>
<entry>value</entry>
<entry>respectively, E1 or F1. This number</entry>
</row>
<row>
<entry/>
<entry>represents the total number of rows</entry>
</row>
<row>
<entry/>
<entry>needed within a column or position for</entry>
</row>
<row>
<entry/>
<entry>all, respectively, tokens or positions in</entry>
</row>
<row>
<entry/>
<entry>their 5-element groups to equal the</entry>
</row>
<row>
<entry/>
<entry>frequency of their leaders of their 5-</entry>
</row>
<row>
<entry/>
<entry>element groups.</entry>
</row>
<row>
<entry>F1</entry>
<entry>Temporary table used to foil re-</entry>
</row>
<row>
<entry/>
<entry>identification attempts from character</entry>
</row>
<row>
<entry/>
<entry>frequency analysis attacks. It contains a</entry>
</row>
<row>
<entry/>
<entry>histogram of every character position</entry>
</row>
<row>
<entry/>
<entry>of every string column in B1. For every</entry>
</row>
<row>
<entry/>
<entry>position in every column in the</entry>
</row>
<row>
<entry/>
<entry>histogram, its character values are</entry>
</row>
<row>
<entry/>
<entry>grouped into disjoint sets of 5. F1</entry>
</row>
<row>
<entry/>
<entry>records the number of rows needed for</entry>
</row>
<row>
<entry/>
<entry>each position to equal the frequency of</entry>
</row>
<row>
<entry/>
<entry>the leader in its 5-element group. Used</entry>
</row>
<row>
<entry/>
<entry>in conjunction with the D1 table.</entry>
</row>
<row>
<entry>D1</entry>
<entry>Temporary table used with F1; it</entry>
</row>
<row>
<entry/>
<entry>contains &#x201c;false&#x201d; rows randomly</entry>
</row>
<row>
<entry/>
<entry>selected from B1. Character positions</entry>
</row>
<row>
<entry/>
<entry>will be replaced in the columns in D1</entry>
</row>
<row>
<entry/>
<entry>based on their &#x201c;rows needed&#x201d;</entry>
</row>
<row>
<entry/>
<entry>parameter in F1 to ensure that result</entry>
</row>
<row>
<entry/>
<entry>sets involving character positions in any</entry>
</row>
<row>
<entry/>
<entry>5-group set will return true and false</entry>
</row>
<row>
<entry/>
<entry>rows whose total number</entry>
</row>
<row>
<entry/>
<entry>approximately equals, which</entry>
</row>
<row>
<entry/>
<entry>significantly undermines re-</entry>
</row>
<row>
<entry/>
<entry>identification efforts.</entry>
</row>
<row>
<entry>G1</entry>
<entry>Temporary table, a copy of B1. Used to</entry>
</row>
<row>
<entry/>
<entry>reorder the groups in B1 to further</entry>
</row>
<row>
<entry/>
<entry>obscure any potential insecure</entry>
</row>
<row>
<entry/>
<entry>groupings of rows.</entry>
</row>
<row>
<entry>Y1</entry>
<entry>Temporary table, a copy of G1. This</entry>
</row>
<row>
<entry/>
<entry>table, listing which GpNums are true</entry>
</row>
<row>
<entry/>
<entry>and false in A1, will become part of the</entry>
</row>
<row>
<entry/>
<entry>database private key. It will be used to</entry>
</row>
<row>
<entry/>
<entry>discard rows from false groups in</entry>
</row>
<row>
<entry/>
<entry>results sets when they are returned</entry>
</row>
<row>
<entry/>
<entry>from the server to the client.</entry>
</row>
<row>
<entry>H1</entry>
<entry>A table containing the original outlier</entry>
</row>
<row>
<entry/>
<entry>values and the values that replaced</entry>
</row>
<row>
<entry/>
<entry>them. This table will become part of</entry>
</row>
<row>
<entry/>
<entry>the database private key for A1 to</entry>
</row>
<row>
<entry/>
<entry>properly restore outlier values on the</entry>
</row>
<row>
<entry/>
<entry>client when results sets from the server</entry>
</row>
<row>
<entry/>
<entry>involving A1 contain masked outlier</entry>
</row>
<row>
<entry/>
<entry>values.</entry>
</row>
<row>
<entry>X1, Xi</entry>
<entry>X1 is a table used for JOINing A1 with</entry>
</row>
<row>
<entry/>
<entry>A2 on a single column. X1 contains all</entry>
</row>
<row>
<entry/>
<entry>the unique values within that single</entry>
</row>
<row>
<entry/>
<entry>column in A2 replicated and encoded</entry>
</row>
<row>
<entry/>
<entry>as many times as there are groups in</entry>
</row>
<row>
<entry/>
<entry>A1. It will be used in conjunction with</entry>
</row>
<row>
<entry/>
<entry>the J1 construct to restore the result</entry>
</row>
<row>
<entry/>
<entry>set of the JOIN command on the client.</entry>
</row>
<row>
<entry/>
<entry>Similarly, Xi is a table used for JOINing</entry>
</row>
<row>
<entry/>
<entry>Ai with Aj on a single column more</entry>
</row>
<row>
<entry/>
<entry>generally. Xi contains all the unique</entry>
</row>
<row>
<entry/>
<entry>values within the implicated column in</entry>
</row>
<row>
<entry/>
<entry>Aj replicated and encoded as many</entry>
</row>
<row>
<entry/>
<entry>times as there are groups in Ai. Like X1,</entry>
</row>
<row>
<entry/>
<entry>Xi is used to restore the JOIN result set</entry>
</row>
<row>
<entry/>
<entry>on the client.</entry>
</row>
<row>
<entry>B2, Bi</entry>
<entry>B2, and more generally, Bi, is the same</entry>
</row>
<row>
<entry/>
<entry>as table B1 but used for anonymizing</entry>
</row>
<row>
<entry/>
<entry>table O2 or (more generally) table Oi.</entry>
</row>
<row>
<entry>Database </entry>
<entry>A set of nine files to be made available</entry>
</row>
<row>
<entry>Private</entry>
<entry>to client machines so they can interact</entry>
</row>
<row>
<entry>Key</entry>
<entry>with the ADB. The database private key</entry>
</row>
<row>
<entry/>
<entry>is composed of the Ai table private key</entry>
</row>
<row>
<entry/>
<entry>files and general database files. The</entry>
</row>
<row>
<entry/>
<entry>following are the Ai table private key</entry>
</row>
<row>
<entry/>
<entry>files:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="63pt" align="left"/>
<colspec colname="2" colwidth="28pt" align="left"/>
<colspec colname="3" colwidth="126pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>1.</entry>
<entry>The Y1 table, indicating</entry>
</row>
<row>
<entry/>
<entry/>
<entry>whether a particular group is</entry>
</row>
<row>
<entry/>
<entry/>
<entry>true or false.</entry>
</row>
<row>
<entry/>
<entry>2.</entry>
<entry>The file describing how each</entry>
</row>
<row>
<entry/>
<entry/>
<entry>character position is encoded</entry>
</row>
<row>
<entry/>
<entry/>
<entry>for each group in each string</entry>
</row>
<row>
<entry/>
<entry/>
<entry>column. This file also describes</entry>
</row>
<row>
<entry/>
<entry/>
<entry>the encoding for each string</entry>
</row>
<row>
<entry/>
<entry/>
<entry>length &#x201c;column&#x201d; in each group.</entry>
</row>
<row>
<entry/>
<entry>3.</entry>
<entry>The file describing the average,</entry>
</row>
<row>
<entry/>
<entry/>
<entry>random multiplier, and random</entry>
</row>
<row>
<entry/>
<entry/>
<entry>addend for each numeric</entry>
</row>
<row>
<entry/>
<entry/>
<entry>column in each group.</entry>
</row>
<row>
<entry/>
<entry>4.</entry>
<entry>The H1 table, describing the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>original and modified numeric</entry>
</row>
<row>
<entry/>
<entry/>
<entry>outlier values in certain rows.</entry>
</row>
<row>
<entry/>
<entry>5. </entry>
<entry>The file containing the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>maximum lengths of each</entry>
</row>
<row>
<entry/>
<entry/>
<entry>padded string column.</entry>
</row>
<row>
<entry/>
<entry>6.</entry>
<entry>The file describing how many</entry>
</row>
<row>
<entry/>
<entry/>
<entry>rows there are in the table.</entry>
</row>
<row>
<entry/>
<entry>7. </entry>
<entry>The file describing how many</entry>
</row>
<row>
<entry/>
<entry/>
<entry>groups there are in the table.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="63pt" align="left"/>
<colspec colname="2" colwidth="154pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>The following are the general </entry>
</row>
<row>
<entry/>
<entry>database files:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="63pt" align="left"/>
<colspec colname="2" colwidth="28pt" align="left"/>
<colspec colname="3" colwidth="126pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>1.</entry>
<entry>The V1 table, containing the</entry>
</row>
<row>
<entry/>
<entry/>
<entry>domain of the characters in</entry>
</row>
<row>
<entry/>
<entry/>
<entry>O1 . . . Op.</entry>
</row>
<row>
<entry/>
<entry>2.</entry>
<entry>The file describing how many</entry>
</row>
<row>
<entry/>
<entry/>
<entry>rows the database server can</entry>
</row>
<row>
<entry/>
<entry/>
<entry>handle within an anonymized</entry>
</row>
<row>
<entry/>
<entry/>
<entry>subquery whose components</entry>
</row>
<row>
<entry/>
<entry/>
<entry>are linked by OR statements.</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="1" colwidth="63pt" align="left"/>
<colspec colname="2" colwidth="154pt" align="left"/>
<tbody valign="top">
<row>
<entry>J1</entry>
<entry>A temporary table used when JOINing</entry>
</row>
<row>
<entry/>
<entry>two tables in the ADB. It contains the</entry>
</row>
<row>
<entry/>
<entry>results of the first table JOINed to table</entry>
</row>
<row>
<entry/>
<entry>X1 combined with the results of X1</entry>
</row>
<row>
<entry/>
<entry>JOINed to the second table. J1 is used</entry>
</row>
<row>
<entry/>
<entry>to restore the result set of the JOIN on</entry>
</row>
<row>
<entry/>
<entry>the client.</entry>
</row>
<row>
<entry>R1O</entry>
<entry>Just like the R1 table for the A1.</entry>
</row>
<row>
<entry/>
<entry>R1O is just a reference to a table</entry>
</row>
<row>
<entry/>
<entry>associated with O1. It's used for</entry>
</row>
<row>
<entry/>
<entry>comparing the performance of the</entry>
</row>
<row>
<entry/>
<entry>DELETE command on an A1 table with</entry>
</row>
<row>
<entry/>
<entry>an O1 table. R1O holds those O1 row</entry>
</row>
<row>
<entry/>
<entry>numbers that are scheduled for</entry>
</row>
<row>
<entry/>
<entry>deletion. If any rows in R1O are</entry>
</row>
<row>
<entry/>
<entry>implicated in any O1 query they will not</entry>
</row>
<row>
<entry/>
<entry>be processed because they will</entry>
</row>
<row>
<entry/>
<entry>ultimately (in theory, because we never</entry>
</row>
<row>
<entry/>
<entry>actually deleted any O1 rows in testing)</entry>
</row>
<row>
<entry/>
<entry>be erased.</entry>
</row>
<row>
<entry namest="1" nameend="2" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0173" num="0189">While the invention has been described in connection with what is presently considered to be the most practical and preferred embodiments, it is to be understood that the invention is not to be limited to the disclosed embodiments but, on the contrary, is intended to cover various modifications and equivalent arrangements included within the spirit and scope of the appended claims.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>The invention claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A computer-implemented method of anonymizing a database and querying it comprising:
<claim-text>(a) anonymizing a database on a server computer,</claim-text>
<claim-text>(b) hosting said database on a server computer,</claim-text>
<claim-text>(c) generating a query on a client computer,</claim-text>
<claim-text>(d) encrypting the query on the client computer to form an encrypted query,</claim-text>
<claim-text>(e) transmitting the encrypted query to the server computer,</claim-text>
<claim-text>(f) operating on the encrypted query at the server computer to produce an encrypted result,</claim-text>
<claim-text>(g) returning the encrypted result to the client computer,</claim-text>
<claim-text>(h) post processing the encrypted result on the client computer, without decryption, to produce a post processed encrypted result,</claim-text>
<claim-text>(i) decrypting the post processed encrypted result at the client computer to produce a decrypted result and presenting the decrypted result to the user;
<claim-text>wherein anonymizing the database is accomplished by forming two or more groups within at least one table, wherein each group is associated with an anonymization key and wherein at least two of said two or more groups overlap.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the database is anonymized by a method which works on a single database table at a time.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the database is anonymized by a method which anonymizes all columns of a table.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the database is anonymized by a method which combines a deterministic process with the generation of database records which contain appropriately created fake values, wherein the number of said database records is determined by constructing mutually exclusive n-element groupings for lists of elements in the original database ordered by frequency of said elements and then creating the fake rows based on the n-element groupings which create the most fake rows.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the database is anonymized by a method wherein a mathematical function with different anonymization parameters for each numeric column and each group is used to encode each numeric value.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. A computer-implemented method of anonymizing a database and querying it comprising the steps of:
<claim-text>(a) anonymizing a database on a server computer,</claim-text>
<claim-text>(b) hosting said database on a server computer,</claim-text>
<claim-text>(c) generating a query on a client computer,</claim-text>
<claim-text>(d) encrypting the query on the client computer to form an encrypted query,</claim-text>
<claim-text>(e) transmitting the encrypted query to the server computer,</claim-text>
<claim-text>(f) operating on the encrypted query at the server computer to produce an encrypted result,</claim-text>
<claim-text>(g) returning the encrypted result to the client computer,</claim-text>
<claim-text>(h) decrypting the encrypted result at the client computer to produce a decrypted result, and</claim-text>
<claim-text>(i) post processing the decrypted result at the client computer to produce a result and presenting the result to a user;
<claim-text>wherein anonymizing the database is accomplished by forming two or more groups within at least one table and wherein each group is associated with an anonymization key and wherein at least two of said two or more groups overlap.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref> wherein the groups comprise subsets of rows from the at least one table.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00007">claim 7</claim-ref> wherein the groups are broken into subgroups for further anonymization.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref> wherein the anonymization key comprises subkeys.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref> wherein the table comprises zero or more false rows.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref> wherein the table is divided into one or more element groups comprising elements obtained from columns or character positions within string columns.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref> wherein each element comprises false and real rows with the proviso that each element within an element group comprises the same number of total rows.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref> wherein indices are constructed over encrypted data.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref> wherein step (a) comprises:
<claim-text>a. transforming a numeric value monotonically using a unique set of random parameters for each group to produce a result, and</claim-text>
<claim-text>b. storing the result in place of the numeric value in the table.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref> wherein step (a) further comprises: creating extra tables comprising joinable elements wherein the extra tables facilitate one or more JOIN operations on two or more columns from two or more original tables.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. A computer-implemented apparatus for performing computations on encrypted data and querying encrypted data, comprising: (1) a computer system; (2) logic, performed by the computer system, for (a) anonymizing a database on a server computer, (b) hosting said database on a server computer, (c) generating a query on a client computer, (d) encrypting the query on the client computer to form an encrypted query, (e) transmitting the encrypted query to the server computer, (f) operating on the encrypted query at the server computer to produce an encrypted result, (g) returning the encrypted result to the client computer, (h) post processing the encrypted result on the client computer, without decryption, to produce a post processed encrypted result, (i) decrypting the post processed encrypted result at the client computer to produce a decrypted result and presenting the decrypted result to the user; wherein anonymizing the database is accomplished by forming two or more groups within at least one table, wherein each group is associated with an anonymization key and wherein at least two of said two or more groups overlap.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. An article of manufacture comprising a program storage device embodying instructions for a computer-implemented method for performing computations on encrypted data and querying encrypted data, the logic comprising: (a) anonymizing a database on a server computer, (b) generating a query on a client computer, (c) encrypting the query on the client computer to form an encrypted query, (d) transmitting the encrypted query to the server computer, (e) operating on the encrypted query at the server computer to produce an encrypted result, (f) returning the encrypted result to the client computer, (g) decrypting the encrypted result at the client computer to produce a decrypted result, and (h) post processing the decrypted result at the client computer to produce a result and presenting the result to a user; wherein anonymizing the database is accomplished by forming two or more groups within at least one table and wherein each group is associated with an anonymization key; and wherein at least two of said two or more groups overlap.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. A client-server database system comprising:
<claim-text>(a) at least one client computer,</claim-text>
<claim-text>(b) at least one server computer, and</claim-text>
<claim-text>(c) a network connecting the client computer and the server computer,</claim-text>
<claim-text>(d) wherein the server computer hosts an anonymized database, the anonymized database is operated upon by the server computer to produce an encrypted results set in response to an encrypted query from the client computer, the encrypted results set is sent from the server to the client computer, the encrypted result is post processed on the client computer, without decryption, to produce a post processed encrypted results set, and the post processed encrypted results set is decrypted by the client computer to produce a decrypted result to be presented to a user, wherein the anonymized database is anonymized by forming two or more groups within at least one table and wherein each group is associated with an anonymization key; and wherein at least two of said two or more groups overlap.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The system of <claim-ref idref="CLM-00018">claim 18</claim-ref> wherein the groups comprise subsets of rows from the at least one table.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The system of <claim-ref idref="CLM-00018">claim 18</claim-ref> wherein the anonymization key comprises subkeys.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The system of <claim-ref idref="CLM-00018">claim 18</claim-ref> wherein the table comprises zero or more false rows.</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. The system of <claim-ref idref="CLM-00018">claim 18</claim-ref> wherein the table is divided into one or more element groups comprising elements obtained from columns or character positions within string columns.</claim-text>
</claim>
<claim id="CLM-00023" num="00023">
<claim-text>23. The system of <claim-ref idref="CLM-00022">claim 22</claim-ref> wherein each element comprises false and real rows with the proviso that each element within an element group comprises the same number of total rows.</claim-text>
</claim>
<claim id="CLM-00024" num="00024">
<claim-text>24. The system of <claim-ref idref="CLM-00018">claim 18</claim-ref> wherein indices are constructed over encrypted data.</claim-text>
</claim>
<claim id="CLM-00025" num="00025">
<claim-text>25. The system of <claim-ref idref="CLM-00018">claim 18</claim-ref> wherein the anonymized database is anonymized by:
<claim-text>transforming a numeric value monotonically using a unique set of random parameters for each group to produce a result, and</claim-text>
<claim-text>storing the result in place of the numeric value in the table.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00026" num="00026">
<claim-text>26. The system of <claim-ref idref="CLM-00018">claim 18</claim-ref> wherein the groups are broken into subgroups for further anonymization.</claim-text>
</claim>
<claim id="CLM-00027" num="00027">
<claim-text>27. The system of <claim-ref idref="CLM-00018">claim 18</claim-ref> wherein the anonymized database is anonymized by: creating extra tables comprising joinable elements wherein the extra tables facilitate one or more JOIN operations on two or more columns from two or more original tables.</claim-text>
</claim>
</claims>
</us-patent-grant>
