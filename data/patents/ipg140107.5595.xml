<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08626695-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08626695</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12901721</doc-number>
<date>20101011</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>604</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>N</subclass>
<main-group>5</main-group>
<subgroup>02</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>706 48</main-classification>
</classification-national>
<invention-title id="d2e53">Optimum layer-swapping schedules for BDDs with four variables</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>7506278</doc-number>
<kind>B1</kind>
<name>Rjimati et al.</name>
<date>20090300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>716104</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>8161268</doc-number>
<kind>B2</kind>
<name>Faraj</name>
<date>20120400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712 30</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>2002/0174405</doc-number>
<kind>A1</kind>
<name>Janssen</name>
<date>20021100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2004/0103378</doc-number>
<kind>A1</kind>
<name>Jain</name>
<date>20040500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>2005/0229124</doc-number>
<kind>A1</kind>
<name>Farkash et al.</name>
<date>20051000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>716  5</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2010/0050145</doc-number>
<kind>A1</kind>
<name>Baumgartner</name>
<date>20100200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2011/0078104</doc-number>
<kind>A1</kind>
<name>Honkola</name>
<date>20110300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00008">
<othercit>Sun, Z. et al. &#x201c;Medical Image Compression Based on Ordered Binary Decision Diagrams.&#x201d; Education Technology and Computer Science, 2009. ETCS'09. First International Workshop on. vol. 1. IEEE, 2009.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00009">
<othercit>Definition of &#x201c;iteration&#x201d;. The American Heritage College Dictionary, Fourth Edition. 2004. pp. 737-738.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00010">
<othercit>Definition of &#x201c;iterate&#x201d;. Microsoft Computer Dictionary, Fifth Edition. 2002. p. 292.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00011">
<othercit>Hett, A. et al. &#x201c;MORE: an alternative implementation of BDD packages by multi-operand synthesis.&#x201d; Proceedings of the conference on European design automation. IEEE Computer Society Press, 1996.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00012">
<othercit>Stornetta, A.L. &#x201c;Implementation of an efficient parallel BDD package.&#x201d; Thesis, University of California, 1995.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00013">
<othercit>European Search Report for EP Application No. 11184742.2, Jan. 23, 2012.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00014">
<othercit>Brudaru, Octav et al., &#x201c;Optimizing Variable Ordering of BDDs with Double Hybridized Embryonic Genetic Algorithm,&#x201d; <i>12th International Symposium on Symbolic and Numeric Algorithms for Scientific Computing</i>, IEEE, pp. 167-173, Sep. 23, 2010.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00015">
<othercit>Stergiou, Stergios et al., Dynamically Resizable Binary Decision Diagrams, <i>Proceedings of the 20th Symposium on Great Lakes Symposium on VLSI, GLSVLSI 10</i>, pp. 185-188, May 2010.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00016">
<othercit>Stergiou, Stergios, &#x201c;Implicit Permutation Enumeration Networks and Binary Decision Diagrams Reordering,&#x201d; <i>Design Automation Conference </i>(<i>DAC</i>), <i>48th ACM/EDAC/IEEE</i>, pp. 615-620, Jun. 2011.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00017">
<othercit>European Search Report for EP Application No. 11184514.5, Feb. 1, 2012.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00018">
<othercit>European Search Report for EP Application No. 11184752.1, Feb. 24, 2012.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00019">
<othercit>European Search Report for EP Application No. 11184523.6, Feb. 1, 2012.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00020">
<othercit>Office Action for U.S. Appl. No. 12/901,685, Apr. 4, 2012.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00021">
<othercit>Milvang-Jensen, Kim et al., &#x201c;BDDNOW: A Parallel BDD Package,&#x201d; in <i>Formal Methods in Computer-Aided Design</i>, v. 1522, pp. 501-507, Jan. 1, 1998.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00022">
<othercit>Fey, Gorchwin et al., &#x201c;Minimizing the Number of Paths in BODs: Theory and Algorihtm.&#x201d; <i>IEEE Transactions on Computer-Aided Design of Integrated circuits and systems</i>. vol. 25, No. 1, http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&#x26;arnumber=1564299, Jan. 2006 Downloaded Jun. 27, 2012.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00023">
<othercit>Jacobi, Ricardo et al. &#x201c;Incremental Reduction of Binary Decision Diagrams.&#x201d; Circuits and Systems, 1991. <i>IEEE International Symposium</i>, http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&#x26;arnumber=176226, Nov. 14, 1991 Downloaded Mar. 27, 2012.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00024">
<othercit>Campos, S. et al., &#x201c;Timing Analysis of Industrial Real time Systems&#x201d; <i>IEEE</i>, http://ieeexplore. ieee.org/stamp/stamp.jsp?tp=&#x26;arnumber=515482, 1995 Downloaded Mar. 27, 2012.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00025">
<othercit>European Search Report for EP Application No. 11184512.9, Feb. 6, 2012.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00026">
<othercit>Mingquan, Wang et al., &#x201c;BDD Minimization Based on Genetic Tabu Hybrid Strategy,&#x201d; <i>IEEE</i>, v. 2, pp. 870-873, Oct. 24, 2005.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00027">
<othercit>Panda, Shipra et al., &#x201c;Who are the Variables in Your Neighborhood,&#x201d; <i>International Conference on Computer-Aided Design </i>(<i>ICCAD</i>), <i>IEEE</i>, pp. 74-77, Nov. 5, 1995.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00028">
<othercit>European Search Report for EP Application No. 11184753.9, Jul. 19, 2012.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00029">
<othercit>European search report for EP Application No. 11184731.5, Jul. 16, 2012.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00030">
<othercit>Bryant, Randal E et al., &#x201c;Ordered binary decision diagrams in electronic design automation, Foundations, Applications and Innovations,&#x201d; <i>Logic Synthesis and Verification</i>, Jan. 1, 2002.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00031">
<othercit>Jain, J. et al., &#x201c;A survey of techniques for formal verification of combinational circuits&#x201d;, Proceedings of 1997 IEEE International Conference on Computer Design: <i>VLSI in Computers and Processors</i>, Oct. 1997.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00032">
<othercit>Lu, Yuan et al: &#x201c;Efficient variable ordering using aBDD based sampling&#x201d;, Proceedings of the 37th Conference on Design Automation , <i>DAC '00</i>, Jan. 2000.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00033">
<othercit>Meinel, C. et al., &#x201c;Speeding Up Variable Reordering of OBDDs&#x201d;, <i>1997 IEEE International Conference on Computer design: VLSI in computers and Processors</i>, ICCD '97, Oct. 1997.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00034">
<othercit>Narayan, A. et al., &#x201c;Partitioned ROBDDs&#x2014;a Compact, Canonical and Efficiently Manipulable Representation for Boolean Functions&#x201d;, 1996 IEEE/ACM International Conference on Computer-Aided Design, 1996. <i>ICCAD-96 Digest of Technical Papers</i>, Nov. 1996.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00035">
<othercit>Yeh, F-M. et al: &#x201c;Variable ordering for ordered binary decision diagrams by a divide-and-conquer approach&#x201d;, <i>IEE Proceedings: Computers and Digital Techniques</i>, IEE, GB, vol. 144, No. 5, Sep. 23, 1997.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00036">
<othercit>U.S. Appl. No. 12/901,685, filed Oct. 11, 2010, Stergiou.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00037">
<othercit>U.S. Appl. No. 12/901,779, filed Oct. 11, 2010, Stergiou.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00038">
<othercit>U.S. Appl. No. 12/901,857, filed Oct. 11, 2010, Stergiou.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00039">
<othercit>U.S. Appl. No. 12/901,957, filed Oct. 11, 2010, Stergiou.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00040">
<othercit>U.S. Appl. No. 12/901,983, filed Oct. 11, 2010, Stergiou.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00041">
<othercit>U.S. Appl. No. 12/902,037, filed Oct. 11, 2010, Stergiou.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00042">
<othercit>Knuth, D., &#x201c;The art of computer programming,&#x201d; vol. 4, 2009.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00043">
<othercit>Rudell, R., &#x201c;Dynamic variable ordering for ordered binary decision diagrams,&#x201d; <i>Proceedings of IEEE/ACM International Conference on Computer-Aided Design</i>, pp. 42-47, 1993.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00044">
<othercit>Friedman, S. J. et al., &#x201c;Finding the optimal variable ordering for binary decision diagrams,&#x201d; <i>IEEE Transactions on Computers</i>, No. 39, pp. 710-713, 1990.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00045">
<othercit>Fujita, M. et al., &#x201c;On variable ordering of binary decision diagrams for the application of multi-level logic synthesis,&#x201d; <i>Proceedings of the European Conference on Design Automation</i>, pp. 50-54, Feb. 1991.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00046">
<othercit>Ishiura, N. et al. &#x201c;Minimization of binary decision diagrams based on exchange of variables,&#x201d; <i>International Conference on Computer-Aided Design</i>, pp. 472-475, 1991.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00047">
<othercit>Nevo, Z. et al., &#x201c;Distributed Dynamic BDD Reordering&#x201d;, <i>DAC</i>, 2006.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00048">
<othercit>Higuchi, Hiroyuki et al. &#x201c;Lazy Group Sifting for Efficient Symbolic State Traversal of FSMs&#x201d;, IEEE, 1999.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00049">
<othercit>Kunkle, Daniel et al. &#x201c;Parallel Disk-Based Computation for Large, Monolithic Binary Decision Diagrams&#x201d;, PASCO, Jul. 2010.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00050">
<othercit>Lee, Insup et al., &#x201c;Fast Parallel Deterministic and Randomized Algorithms for Model Checking&#x201d;, University of Pennsylvania Department of Computer and Information Science Technical Report No. MS-CIS-93-09, Jan. 1993.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00051">
<othercit>Snape, Jamie, &#x201c;Loopless Functional Algorithms&#x201d;, Computing Laboratory, University of Oxford, Oxford, UK, Thesis submitted for MS, 2005.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00052">
<othercit>Sun, Ziguang et al., &#x201c;Medical Image Compression Based on Ordered Binary Decision Diagrams&#x201d;, First International Workshop on Education Technology and Computer Science, 2009.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00053">
<othercit>Notice of Allowance for U.S. Appl. No. 12/901,779, Mar. 27, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00054">
<othercit>Office Action for U.S. Appl. No. 12/901,983, Jan. 16, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00055">
<othercit>Office Action for U.S. Appl. No. 12/901,957, Mar. 25, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00056">
<othercit>Office Action for U.S. Appl. No. 12/902,037, Mar. 21, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00057">
<othercit>Felt, Eric et al., Dynamic Variable Reordering for BDD Minimization, <i>Proceedings European Design Automation Conference</i>, 1993.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00058">
<othercit>Office Action for European Patent Application No. 11 184 753.9-1951, Apr. 9, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>37</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>706 14</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>706 48</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>40</number-of-drawing-sheets>
<number-of-figures>48</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20120089556</doc-number>
<kind>A1</kind>
<date>20120412</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Stergiou</last-name>
<first-name>Stergios</first-name>
<address>
<city>East Palo Alto</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Jain</last-name>
<first-name>Jawahar</first-name>
<address>
<city>Los Altos</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Stergiou</last-name>
<first-name>Stergios</first-name>
<address>
<city>East Palo Alto</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Jain</last-name>
<first-name>Jawahar</first-name>
<address>
<city>Los Altos</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Baker Botts L.L.P.</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Fujitsu Limited</orgname>
<role>03</role>
<address>
<city>Kawasaki-shi</city>
<country>JP</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Gaffin</last-name>
<first-name>Jeffrey A</first-name>
<department>2129</department>
</primary-examiner>
<assistant-examiner>
<last-name>Buss</last-name>
<first-name>Benjamin</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">One embodiment accesses a binary decision diagram (BDD) representing a function having 4 variables, variables 1, 2, 3, and 4, wherein the BDD comprises 4 layers, layers 1, 2, 3, and 4, corresponding to the 4 variables, respectively; determines an optimum variable order of the BDD by performing at most 19 layer swaps during at most 13 iterations, wherein each of 6 iterations of the at most 13 iterations comprises: determines a first size of the layers 1 and 2 and a first size of the layers 3 and 4; swaps the layers 1 and 2 and the layers 3 and 4 concurrently; determines a second size of the layers 1 and 2 and a second size of the layers 3 and 4; and determines 1 variable order among 4 variable orders obtained during the iteration that yields a smallest size among the 4 variable orders obtained during the iteration.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="228.35mm" wi="120.31mm" file="US08626695-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="261.45mm" wi="176.19mm" orientation="landscape" file="US08626695-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="203.12mm" wi="161.46mm" file="US08626695-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="265.26mm" wi="178.82mm" orientation="landscape" file="US08626695-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="254.42mm" wi="130.05mm" file="US08626695-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="254.42mm" wi="131.40mm" orientation="landscape" file="US08626695-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="178.82mm" wi="144.86mm" orientation="landscape" file="US08626695-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="225.55mm" wi="166.62mm" orientation="landscape" file="US08626695-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="249.94mm" wi="151.21mm" file="US08626695-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="249.94mm" wi="185.17mm" file="US08626695-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="232.58mm" wi="119.21mm" file="US08626695-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="237.07mm" wi="175.60mm" file="US08626695-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="239.69mm" wi="172.38mm" file="US08626695-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="242.23mm" wi="173.06mm" file="US08626695-20140107-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="233.26mm" wi="174.33mm" file="US08626695-20140107-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="231.99mm" wi="171.11mm" file="US08626695-20140107-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00016" num="00016">
<img id="EMI-D00016" he="228.09mm" wi="184.57mm" file="US08626695-20140107-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00017" num="00017">
<img id="EMI-D00017" he="227.50mm" wi="171.11mm" file="US08626695-20140107-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00018" num="00018">
<img id="EMI-D00018" he="233.93mm" wi="169.16mm" file="US08626695-20140107-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00019" num="00019">
<img id="EMI-D00019" he="231.99mm" wi="170.43mm" file="US08626695-20140107-D00019.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00020" num="00020">
<img id="EMI-D00020" he="233.26mm" wi="167.89mm" file="US08626695-20140107-D00020.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00021" num="00021">
<img id="EMI-D00021" he="232.58mm" wi="166.62mm" file="US08626695-20140107-D00021.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00022" num="00022">
<img id="EMI-D00022" he="235.20mm" wi="187.79mm" file="US08626695-20140107-D00022.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00023" num="00023">
<img id="EMI-D00023" he="232.58mm" wi="169.84mm" file="US08626695-20140107-D00023.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00024" num="00024">
<img id="EMI-D00024" he="231.99mm" wi="179.41mm" file="US08626695-20140107-D00024.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00025" num="00025">
<img id="EMI-D00025" he="230.04mm" wi="170.43mm" file="US08626695-20140107-D00025.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00026" num="00026">
<img id="EMI-D00026" he="227.50mm" wi="165.35mm" file="US08626695-20140107-D00026.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00027" num="00027">
<img id="EMI-D00027" he="233.26mm" wi="174.33mm" file="US08626695-20140107-D00027.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00028" num="00028">
<img id="EMI-D00028" he="233.93mm" wi="173.06mm" file="US08626695-20140107-D00028.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00029" num="00029">
<img id="EMI-D00029" he="230.72mm" wi="171.70mm" file="US08626695-20140107-D00029.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00030" num="00030">
<img id="EMI-D00030" he="235.20mm" wi="171.11mm" file="US08626695-20140107-D00030.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00031" num="00031">
<img id="EMI-D00031" he="230.04mm" wi="172.38mm" file="US08626695-20140107-D00031.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00032" num="00032">
<img id="EMI-D00032" he="233.93mm" wi="173.65mm" file="US08626695-20140107-D00032.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00033" num="00033">
<img id="EMI-D00033" he="227.50mm" wi="174.92mm" file="US08626695-20140107-D00033.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00034" num="00034">
<img id="EMI-D00034" he="230.04mm" wi="165.35mm" file="US08626695-20140107-D00034.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00035" num="00035">
<img id="EMI-D00035" he="217.25mm" wi="165.95mm" file="US08626695-20140107-D00035.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00036" num="00036">
<img id="EMI-D00036" he="249.26mm" wi="170.43mm" file="US08626695-20140107-D00036.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00037" num="00037">
<img id="EMI-D00037" he="214.04mm" wi="166.62mm" file="US08626695-20140107-D00037.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00038" num="00038">
<img id="EMI-D00038" he="221.74mm" wi="175.60mm" orientation="landscape" file="US08626695-20140107-D00038.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00039" num="00039">
<img id="EMI-D00039" he="246.04mm" wi="171.70mm" file="US08626695-20140107-D00039.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00040" num="00040">
<img id="EMI-D00040" he="140.97mm" wi="105.07mm" file="US08626695-20140107-D00040.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">TECHNICAL FIELD</heading>
<p id="p-0002" num="0001">This disclosure generally relates to binary decision diagrams (BDDs).</p>
<heading id="h-0002" level="1">BACKGROUND</heading>
<p id="p-0003" num="0002">A Binary Decision Diagram (BDD) is a data structure that may be used to represent a Boolean function. A Reduced Ordered Binary Decision Diagram (ROBDD) is an optimized Binary Decision Diagram (BDD) that has no redundant nodes and isomorphic sub-trees and that the variables appear in the same order along each path from root to a terminal node. The size of a BDD is determined by both the Boolean function it represents and the order of the variables of the function. Consequently, variable ordering exposes a critical optimization problem as the size of a BDD often varies greatly as its variable order changes.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0004" num="0003"><figref idref="DRAWINGS">FIG. 1</figref> (prior art) illustrates a BDD that represents a Boolean function that has four variables.</p>
<p id="p-0005" num="0004"><figref idref="DRAWINGS">FIG. 2</figref> (prior art) illustrates an optimized BDD that represents a Boolean function that has four variables.</p>
<p id="p-0006" num="0005"><figref idref="DRAWINGS">FIGS. 3-4</figref> (prior art) illustrate two BDDs representing the same Boolean function but with different variable orders.</p>
<p id="p-0007" num="0006"><figref idref="DRAWINGS">FIG. 5</figref> (prior art) illustrates an example BDD variable reordering process as applied to a BDD representing a function having four variables.</p>
<p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. 6</figref> (prior art) illustrates the Plain Changes Algorithm as applied to BDDs representing functions having two, three, and four variables respectively.</p>
<p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. 7</figref> (prior art) illustrates the Sifting Algorithm as applied to a BDD representing a function having eight variables.</p>
<p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. 8</figref> (prior art) illustrates the Window Algorithm as applied to a BDD representing a function having eight variables.</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 9</figref> illustrates an example of the maximal parallelization concept as applied to a BDD having eight layers.</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 10</figref> illustrates an example of the implicit enumeration concept as applied to a BDD having six layers.</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 11A</figref> illustrates an example of the Parallel Permutation Algorithm.</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 11B</figref> illustrates the Parallel Permutation Algorithm as applied to a BDD having six layers corresponding to six variables.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIGS. 12A-12B</figref> illustrate an example optimum layer-swapping schedule for a BDD having four layers corresponding to four variables.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIGS. 12C-12Z</figref> illustrate additional example optimum layer-swapping schedules for a BDD having four layers corresponding to four variables.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 13A</figref> illustrates an example of the pair-wise grouping of BDD variables.</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 13B</figref> illustrates the pair-wise grouping of four variables.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 14A</figref> illustrates an example of the recursive separation of BDD variables.</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 14B</figref> illustrates the recursive separation of eight variables.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 15A</figref> illustrates an example of the Parallel Window Algorithm</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 15B</figref> illustrates the Parallel Window Algorithm as applied to a BDD having twelve layers corresponding to twelve variables.</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 16</figref> illustrates an example of the Window Algorithm with maximal parallelization as applied to a BDD having six layers corresponding to six variables.</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 17A</figref> illustrates an example of the Parallel Sifting Algorithm.</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 17B</figref> illustrates the Parallel Sifting Algorithm as applied to a BDD having nine layers corresponding to nine variables.</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 18</figref> illustrates an example computing device.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DESCRIPTION OF EXAMPLE EMBODIMENTS</heading>
<p id="p-0027" num="0026">A Binary Decision Diagram (BDD) is a data structure that may be used to represent a Boolean function. A BDD may be graphically represented as a rooted, directed, and acyclic graph having one or more internal decision nodes and two terminal nodes. Each decision node represents a different variable of the Boolean function, and is typically denoted as a circle in the graph. The two terminal nodes, a 0 terminal node and a 1 terminal node, are typically denoted as a square each in the graph. Each decision node has two edges, a 0 edge, typically denoted as a dash line or a dotted line in the graph, and a 1 edge, typically denoted as a solid line in the graph. Each edge may be connected to another decision node or to one of the terminal nodes.</p>
<p id="p-0028" num="0027">Each path in the graph may by formed by one or more decision nodes and their associated edges, and eventually leads to either the 0 terminal node or the 1 terminal node. The decision nodes that form a particular path each represent a different variable of the Boolean function. That is, along a single path, no two decision nodes represent the same variable. A path that leads to the 0 terminal node indicates that the Boolean function evaluates to FALSE for the values assigned to the variables represented by the decision nodes on the path, and a path that leads to the 1 terminal node indicates that the Boolean function evaluates to TRUE for the values assigned to the variables represented by the decision nodes on the path.</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 1</figref> illustrates an example BDD <b>100</b> that represents a Boolean function having four variables: x<sub>1</sub>, x<sub>2</sub>, x<sub>3 </sub>and x<sub>4</sub>. Since the Boolean function represented by BDD <b>100</b> has four variables, BDD <b>100</b> has at most four decision-node layers, layers 1-4. That is, there are at most four layers in BDD <b>100</b> that each have at least one decision node. More specifically, in <figref idref="DRAWINGS">FIG. 1</figref>, the decision node that represents variable x<sub>1 </sub>is at layer 1 of BDD <b>100</b>; the decision nodes that represent variable x<sub>2 </sub>are at layer 2 of BDD <b>100</b>; the decision nodes that represent variable x<sub>3 </sub>are at layer 3 of BDD <b>100</b>; and the decision nodes that represent variable x<sub>4 </sub>are at layer 4 of BDD <b>100</b>. Each path in BDD <b>100</b>, formed by the decision nodes and their associated edges, leads to either the 0 terminal node or the 1 terminal node, indicating that the Boolean function evaluates to FALSE or TRUE, respectively. Note that for readability, the 0 terminal node and the 1 terminal node are duplicated multiple times in <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0030" num="0029">BDD <b>100</b>, in fact, is not the most optimized representation of the Boolean function as some of the nodes in BDD <b>100</b> are redundant and portions of BDD <b>100</b> are isomorphic. For example, consider paths <b>102</b> and <b>104</b>, both of which end at the 0 terminal node. By examining the decision nodes on paths <b>102</b> and <b>104</b>, it may be determined that as long as decision node <b>152</b>, which represents variable x<sub>3</sub>, branches along its 1 edge, the Boolean function evaluates to FALSE, regardless of along which branch decision node <b>154</b>, which represents variable x<sub>4</sub>, proceeds. Thus, decision node <b>154</b> may be replaced by the 0 terminal node. Similarly, paths <b>112</b>, <b>114</b>, <b>116</b>, and <b>118</b> all end at the 1 terminal node. By examining the decision nodes on these four paths, it may be determined that as long as decision node <b>162</b>, which represents variable x<sub>2</sub>, branches along its 1 edge, the Boolean function evaluates to TRUE, regardless of along which branches decision node <b>164</b>, which represents variable x<sub>3</sub>, and decision nodes <b>166</b> and <b>168</b>, which represent variable x<sub>4</sub>, proceed. Thus, decision nodes <b>164</b>, <b>166</b>, and <b>168</b> may be replaced by the 1 terminal node. As another example, consider decision nodes <b>172</b> and <b>174</b>, which both represent variable x<sub>4</sub>. Decision node <b>172</b> and decision node <b>184</b> both have their 0 edge leading to the 0 terminal node and their 1 edge leading to the 1 terminal node. Therefore, they are duplicates or isomorphic of each other. Thus, one of them may be removed from BDD <b>100</b>. <figref idref="DRAWINGS">FIG. 2</figref> illustrates an example BDD <b>200</b> representing the same Boolean function as repressed by BDD <b>100</b>, but is more optimized than BDD <b>100</b> because it uses less number of nodes to represent the same Boolean function as a result of removing the redundant decision nodes and the isomorphic portions of BDD <b>100</b>.</p>
<p id="p-0031" num="0030">A BDD whose redundant decision nodes and isomorphic sub-graphs have been removed and whose decision nodes appear in the same order from the root to the terminal nodes along all the paths in the BDD is referred to as a reduced ordered binary decision diagram (ROBDD). The advantage of a ROBDD is that it is canonical for a particular function and variable order, which makes it useful in various types of practical applications, such as in functional equivalence checking and functional technology mapping.</p>
<p id="p-0032" num="0031">A ROBDD has two important properties. First, the ROBDD is ordered. That is, there is a fixed order &#x3c0;{1, . . . , n}&#x2192;{x<sub>1</sub>, . . . , x<sub>n</sub>} such that for any non-terminal node v, index(low(v))=&#x3c0;(k) with k&#x3e;&#x3c0;<sup>&#x2212;1 </sup>(index(v)) and index(high(v))=&#x3c0;(q) with q&#x3e;&#x3c0;<sup>&#x2212;1 </sup>(index(v)) hold if low(v) and high(v) are also non-terminal nodes. Second, the ROBDD is reduced. That is, there exists no non-terminal node v&#x3b5;V with low(v)=high(v) and there are no two non-terminal nodes v and v&#x2032; such that the sub-BDDs rooted by v and v&#x2032; are isomorphic. Note that a non-terminal node is a decision node. For example, in <figref idref="DRAWINGS">FIG. 2</figref>, BDD <b>200</b> has 4 layers as it represents a Boolean function having 4 variables. Since BDD <b>200</b> is ordered, each layer contains the decision nodes that correspond to a particular variable. For example, layer 2 contains the decision nodes corresponding to variable x<sub>2 </sub>only, and does not contain any decision node corresponding to another variable (e.g., x<sub>1 </sub>or x<sub>3 </sub>or x<sub>4</sub>).</p>
<p id="p-0033" num="0032">A Boolean function, &#x192;(x<sub>1</sub>, . . . , x<sub>n</sub>) may be partitioned into two or more Boolean functions, &#x192;<sub>1</sub>(x<sub>1</sub>, . . . , x<sub>n</sub>) to &#x192;<sub>m</sub>(x<sub>1</sub>, . . . , x<sub>n</sub>). Each of the Boolean functions &#x192;<sub>1 </sub>to &#x192;<sub>m </sub>may be considered a partition of the original Boolean function &#x192;. If each of the Boolean functions &#x192;<sub>1 </sub>to &#x192;<sub>m </sub>is represented by a BDD, then the BDD that represents the original Boolean function &#x192; may be obtained by logically OR'ing all the BDDs that represent the partitions of &#x192; (i.e., &#x192;<sub>1 </sub>to &#x192;<sub>m</sub>). In particular embodiments, each of the BDDs that represent the Boolean functions &#x192;<sub>1 </sub>to &#x192;<sub>m </sub>may be a ROBDD and may be referred to as a partitioned reduced ordered binary decision diagram (POBDD) with respect to the BDD that represents the original Boolean function &#x192;.</p>
<p id="h-0005" num="0000">BDD Variable Order</p>
<p id="p-0034" num="0033">The size of a BDD is determined by both the Boolean function it represents and the chosen order of the variables of the function. The size of a BDD is the sum of the sizes of all of its individual layers. In particular embodiments, the size of a BDD may be expressed in terms of the number of decision nodes in the BDD. Similarly, the size of a layer of a BDD may be expressed in terms of the number of decision nodes at that layer.</p>
<p id="p-0035" num="0034">Given a Boolean function, &#x192;(x<sub>1</sub>, . . . , x<sub>n</sub>), represented by a BDD, depending upon the ordering of the variables, x<sub>1</sub>, . . . , x<sub>n</sub>, the number of nodes in the graph is linear in the best case and exponential in the worst case, in terms of n. For example, for Boolean function &#x192;(x<sub>1</sub>, . . . , x<sub>2n</sub>)=x<sub>1</sub>x<sub>2</sub>+x<sub>3</sub>x<sub>4</sub>+ . . . +x<sub>2n&#x2212;1</sub>x<sub>2</sub>, using the variable order x<sub>1</sub>&#x3c;x<sub>3</sub>&#x3c; . . . &#x3c;x<sub>2n&#x2212;1</sub>&#x3c;x<sub>2</sub>&#x3c;x<sub>4</sub>&#x3c; . . . &#x3c;x<sub>2n</sub>, the BDD needs 2<sup>n+1 </sup>nodes to represent the Boolean function, as illustrated in <figref idref="DRAWINGS">FIG. 3</figref>. On the other hand, using the variable order x<sub>1</sub>&#x3c;x<sub>2</sub>&#x3c;x<sub>3</sub>&#x3c;x<sub>4</sub>&#x3c; . . . &#x3c;x<sub>2n&#x2212;1</sub>&#x3c;x<sub>2n</sub>, the BDD only needs 2n nodes to represent the same Boolean function, as illustrated in <figref idref="DRAWINGS">FIG. 4</figref>. As this example illustrates, variable ordering exposes a critical optimization problem for BDDs as the size of a BDD often varies greatly as its variable order changes.</p>
<p id="p-0036" num="0035">Given a particular layer of a BDD, when a first variable (e.g., x<sub>1</sub>) is positioned at that layer, the layer may have one size. When a second variable (e.g., x<sub>2</sub>) is positioned at that same layer, the layer may have another, different size. In addition, given a particular layer (e.g., layer 3) of a BDD with a particular variable (e.g., x<sub>3</sub>) positioned at that layer, the size of the layer in connection with the variable depends on the specific variables positioned at layers above (e.g., layers 1 and 2) and below (e.g., layer 4) that particular layer. Thus, for example, if variable x<sub>3 </sub>is positioned at layer 3, when variables x<sub>1 </sub>and x<sub>2 </sub>are positioned at layers 1 and 2 and variable x<sub>4 </sub>is positioned at layer 4, layer 3 in connection with variable x<sub>3 </sub>may have one size. But when variables x<sub>4 </sub>and x<sub>1 </sub>are positioned at layers 1 and 2 and variable x<sub>2 </sub>is positioned at layer 4, layer 3 in connection with variable x<sub>3 </sub>may have another, different size, even though variable x<sub>3 </sub>remains at layer 3.</p>
<p id="p-0037" num="0036">There has been some amount of research concerning BDD variable ordering. The goal of BDD variable ordering is, in general, to find an optimum or substantially optimal ordering of the function variables such that the number of BDD nodes needed is minimized, thus reducing the size of the BDD representing the function. In general, in order to find the optimum variable order of a BDD where the size of the BDD is minimum, it may be necessary to test many if not all possible order permutations of the variables of the BDD so that the order permutation of the variables where the size of the BDD is the smallest may be found. This order permutation yields the optimum variable order for the BDD. Note that each specific order permutation of the variables indicates a different variable order of the BDD. In practice, however, finding all possible order permutations of the variables of a BDD, and thus finding all possible variable orders of the BDD, may be very expensive in terms of time and resources it requires since, for a BDD that represents a function of n variables, there are n! (n factorial, where n!=1&#xd7;2&#xd7; . . . &#xd7;n) possible order permutations of the variables.</p>
<p id="p-0038" num="0037">To test different order permutations of the variables of a BDD, the variables of the BDD may be reordered using a suitable reordering algorithm. In their simplest form, reordering algorithms transform the current order permutation of variables of a BDD to another, different order permutation. The ending order permutation of the BDD may be, for example, specified by a person (e.g., according to some design specification or performance criteria) or determined based on the application in which the BDD is used. The majority of the research on BDD variable reordering algorithms or processes exploits the following property: two consecutive layers of a BDD can be efficiently swapped without affecting the rest of the BDD. By swapping two layers of the BDD, the order of the two corresponding variables at those two layers are also swapped, thus reordering two of the variables of the BDD with each swap. Variable reordering algorithms, therefore, transform a given BDD by applying local swaps until some target objective is reached.</p>
<p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. 5</figref> illustrates an example variable reordering process for BDDs. This is one of the most commonly used reordering algorithms, where it moves each variable to its correct final position by repeatedly performing swaps of two consecutive layers of a BDD. To simplify the discussion, the reordering algorithm is illustrated using a BDD <b>500</b> that represents a function having 4 variables, although the same algorithm may be applied to BDDs representing functions having any number of variables. Hereafter, in the figures, horizontal lines represent BDD layers, and vertical lines represent layer swaps. Since there are 4 variables, BDD <b>500</b> illustrates 4 horizontal lines corresponding to layers 1-4. Initially, BDD <b>500</b> has a first variable order, where variable 1 is at layer 1, variable 2 is at layer 2, variable 3 is at layer 3, and variable 4 is at layer 4. Suppose it is desirable to reorder the 4 variables of BDD <b>500</b> to achieve a second variable order, which is different from the initial first variable order, where variable 1 is at layer 4, variable 2 is at layer 3, variable 3 is at layer 2, and variable 4 is at layer 1.</p>
<p id="p-0040" num="0039">To move variable 1 to layer 4, the reordering algorithm may first swap layers 1 and 2 (i.e., swap <b>501</b>). After swap <b>501</b>, variable 2 is at layer 1, and variable 1 is at layer 2. Next, layers 2 and 3 are swapped (i.e., swap <b>502</b>), after which variable 3 is at layer 2, and variable 1 is at layer 3. Finally, layers 3 and 4 are swapped (i.e., swap <b>503</b>). At this point, variable 1 is at layer 4, its desired position, and variable 4 is at layer 3. To move variable 2 to layer 3 (note that due to swap <b>501</b>, variable 2 is currently at layer 1), layers 1 and 2 again are swapped (i.e., swap <b>504</b>), after which variable 3 is at layer 1, and variable 2 is at layer 2. Next, layers 3 and 4 are swapped (i.e., swap <b>505</b>). At this point, variable 2 is at layer 3, its desired position, and variable 4 is at layer 2. To move variable 3 to layer 2 (note that variable 3 is currently at layer 1), layers 1 and 2 are swapped (i.e., swap <b>506</b>). At this point, variable 3 is at layer 2, and variable 4 is at layer 1. The desired second variable order has been achieved for BDD <b>500</b>, and the reordering algorithm may end.</p>
<p id="p-0041" num="0040">As <figref idref="DRAWINGS">FIG. 5</figref> illustrated, it takes a total of 6 layer swaps to reorder the 4 variables of BDD <b>500</b> from the first variable order to the second variable order (i.e., to transform the BDD from the first variable order permutation to the second variable order permutation). Recall that two consecutive layers of a BDD can be swapped without affecting the rest of the BDD. Consequently, disjoint pairs of consecutive layers may be swapped concurrently since the swapping of one pair of consecutive layers does not affect any other layers and thus any other pairs of consecutive layers. A pair of consecutive layers in a BDD is any two layers that are next to each other (e.g., layers i and i+1 for 1&#x2266;i&#x2266;n&#x2212;1). Two disjoint pairs of consecutive layers are two pairs of consecutive layers that do not share any common layer. (e.g., layers i and i+1 as one pair and layers i+2 and i+3 as another pair).</p>
<p id="p-0042" num="0041">In <figref idref="DRAWINGS">FIG. 5</figref>, swap <b>503</b> between layers 3 and 4 is immediately followed by swap <b>504</b> between layers 1 and 2. Layers 3 and 4 and layers 1 and 2 are two disjoint pairs of consecutive layers as the two pairs of layers do not share any common layer. Therefore, swaps <b>503</b> and <b>504</b> may be performed concurrently (i.e. in parallel) since the two swaps do not affect each other (i.e., the two swaps do not depend on each other's results). On the other hand, swap <b>501</b> between layers 1 and 2 is immediately followed by swap <b>502</b> between layers 2 and 3. Layers 1 and 2 and layers 2 and 3 are not two disjoint pairs of consecutive layers as the two pairs share a common layer, layer 2. Therefore, swaps <b>501</b> and <b>502</b> cannot be performed concurrently since swap <b>502</b> requires the result of swap <b>501</b> before it can be performed.</p>
<p id="h-0006" num="0000">Variable Reordering Algorithms</p>
<p id="p-0043" num="0042">A variable order of a BDD indicates which variable of the function represented by the BDD is positioned at which layer of the BDD. An optimum variable order of a BDD is a particular ordering of the variables of the function represented by the BDD where the size of the BDD is minimum among all possible order permutations of the variables of the BDD. In general, a BDD may have one or more optimum variable orders. Given a BDD that represents a function having n variables, there are different algorithms or processes that may be used to find its optimum variable order or optimum variable orders.</p>
<p id="p-0044" num="0043">Plain Changes Algorithm</p>
<p id="p-0045" num="0044">A commonly used algorithm for determining the optimum variable order of a BDD is based on the transposition network algorithm named &#x201c;plain changes&#x201d;. This is an exact algorithm because the algorithm is able to determine the exact optimum variable order for a given BDD (i.e., the variable order of the BDD that results in the BDD having the smallest size). With the Plain Changes Algorithm, all possible order permutations of the variables of a BDD are obtained, thereby detecting the one variable order where the BDD is of minimum size, and this one variable order is considered the optimum variable order of the BDD. For a BDD representing a function of n variables, the Plain Changes Algorithm requires that n!&#x2212;1 swaps between two consecutive layers of the BDD to be performed in order to cover all possible n! order permutations of the variables. Note that a BDD always has an initial variable order; therefore, one order permutation of the variables is already obtained without requiring any layer swaps. Thereafter, the n variables of the BDD may be reordered using a suitable reordering algorithm to achieve the optimum variable order.</p>
<p id="p-0046" num="0045"><figref idref="DRAWINGS">FIG. 6</figref> illustrates the Plain Changes Algorithm, in terms of the layer swaps performed, applied to BDDs representing functions having two, three, and four variables, respectively. In <figref idref="DRAWINGS">FIG. 6</figref>, a BDD <b>610</b> has 2 layers corresponding to 2 variables (i.e., n=2). There are 2 (i.e., 2!) possible order permutations of the 2 variables for BDD <b>610</b>, and it takes 1 layer swap to obtain the 2 possible order permutations of the 2 variables. To determine the optimum variable order for BDD <b>610</b>, the size of BDD <b>610</b> having the initial, first variable order is determined and recorded. The two layers are swapped to obtain the second possible variable order. The size of BDD <b>610</b> having the second variable order is also determined and recorded. The two sizes are then compared, and the variable order resulting in the smaller size is selected as the optimum variable order of BDD <b>610</b>.</p>
<p id="p-0047" num="0046">A BDD <b>620</b> has 3 layers corresponding to 3 variables (i.e., n=3). There are 6 (i.e., 3!) possible order permutations of the 3 variables for BDD <b>620</b>, and it takes 5 layer swaps to obtain the 6 possible order permutations of the 3 variables. To determine the optimum variable order for BDD <b>620</b>, 6 sizes of BDD <b>620</b> corresponding to the 6 different variable orders are individually determined and recorded. The 6 sizes of are then compared, and the variable order resulting in the smallest size is selected as the optimum variable order of BDD <b>620</b>.</p>
<p id="p-0048" num="0047">A BDD <b>630</b> has 4 layers corresponding to 4 variables (i.e., n=4). There are 24 (i.e., 4!) possible order permutations of the 4 variables for BDD <b>630</b>. A process similar to those described in connection with BDDs <b>610</b> and <b>620</b> may be applied to BDD <b>630</b> to determine the optimum variable order for BDD <b>630</b>. In this case, there are 24 sizes of BDD <b>630</b> corresponding to the 24 different variable orders, and the variable order resulting in the smallest size is selected as the optimum variable order of BDD <b>630</b>.</p>
<p id="p-0049" num="0048">The Plain Changes Algorithm works inductively by constructing the layer swap sequence for n variables from the layer swap sequence for n&#x2212;1 variables. For n variables, layer swaps (1, 2), (2, 3), . . . , (n&#x2212;1, n) and (n&#x2212;1, n), (n&#x2212;2, n&#x2212;1), . . . , (1, 2) are alternatingly added in between layer swaps from the sequence of layer swaps for n&#x2212;1 variables. Thus, the layer swap sequence for 3 variables is constructed from the layer swap sequence for 2 variables. Swap <b>623</b> of BDD <b>620</b> between layers 1 and 2 corresponds to swap <b>611</b> of BDD <b>610</b>. And in BDD <b>620</b>, swaps between layers 1 and 2 (i.e., swap <b>621</b>) and between layers 2 and 3 (i.e., swap <b>622</b>) are added before swap <b>621</b>; and swaps between layers 2 and 3 (i.e., swap <b>624</b>) and between layers 1 and 2 (i.e., swap <b>625</b>) are added after swap <b>621</b>. Similarly, the layer swap sequence for 4 variables is constructed from the layer swap sequence for 3 variables. Swaps <b>631</b>, <b>632</b>, <b>633</b>, <b>634</b>, and <b>635</b> of BDD <b>630</b> correspond to swaps <b>621</b>, <b>622</b>, <b>623</b>, <b>624</b>, and <b>625</b> of BDD <b>620</b>, respectively. And in BDD <b>630</b>, swaps between layers 1 and 2, between layers 2 and 3, and between layers 3 and 4 and swaps between layers 3 and 4, between layers 2 and 3, and between layers 1 and 2 are alternatingly added in between swaps <b>631</b>, <b>632</b>, <b>633</b>, <b>634</b>, and <b>635</b>.</p>
<p id="p-0050" num="0049">As illustrated in <figref idref="DRAWINGS">FIG. 6</figref>, since most of the layers swaps performed depend on the layer swap that immediately precedes them, the Plain Changes Algorithm cannot be parallelized efficiently.</p>
<p id="p-0051" num="0050">Sifting Algorithm</p>
<p id="p-0052" num="0051">There are heuristic algorithms for determining a substantially optimal variable order of a BDD. Heuristic algorithms may not always be able to determine one optimum variable order of a BDD where the size of the BDD is at its smallest, but they are able to determine a substantially optimal variable order for the BDD where the size of the BDD is sufficiently small, such as below a desired threshold. A widely used heuristic algorithm is the Sifting Algorithm. It works by finding the optimum location for each variable of a BDD independently. Each variable of the BDD is moved (sifted) to the end layer that is closer to the initial layer where the variable is positioned. The variable is then moved to the opposite end layer of the BDD. Each time the variable is moved to a new layer, the size of the layer (e.g., in terms of the number of decision nodes on that layer) where the variable is currently positioned is determined and recorded. Thus, by moving the variable from one end layer to the other end layer of the BDD, the sizes of all the layers with the variable at these layers are determined. The layer that has the smallest size is considered the optimum layer (i.e., location) for the variable. Thereafter, the variable is moved to its optimum layer, which locally minimizes with size of the BDD with respect to the variable.</p>
<p id="p-0053" num="0052"><figref idref="DRAWINGS">FIG. 7</figref> illustrates the sifting process as applied to one of the variables, variable 5, of a BDD <b>700</b> representing a function having eight variables. BDD <b>700</b> therefore has eight layers. Initially, variable 5 is at layer 5. The two end layers of BDD <b>700</b> are layer 1 and layer 8, since BDD <b>700</b> has a total of 8 layers. Layer <b>8</b> is closer to layer 5. Therefore, variable 5 is moved downward first, one layer at a time, until it is at layer 8. Then variable 5 is moved upward, again one layer at a time, until it is at layer 1. Note that to move variable 5 from one layer to another, adjacent layer, the two layers are swapped. For example, to move variable 5 from layer 5 to layer 6, layers 5 and 6 are swapped. It takes 10 layer swaps for variable 5 to traverse first down to layer 8 and then up to layer 1. By doing so, the size of each layer with variable 5 positioned at it may be determined, and the layer having the smallest size is selected as the optimum layer for variable 5. Suppose the optimum layer for variable 5 is layer 4. Then, variable 5 is moved from layer 1 back down to layer 4, which takes another 3 layer swaps.</p>
<p id="p-0054" num="0053">The same process may be applied to each variable in turn to determine the optimum location for that variable. Each variable may be selected in turn based on the number of decision nodes that depend on it initially. For example, the algorithm may begin with the variable that initially has the largest number of decision nodes depending on it, determine the optimum position in the BDD (i.e., the layer) for this first variable using the above process, and move the first variable to its optimum layer. Then, the algorithm may repeat the process for another variable that initially has the second largest number of decision nodes depending on it, and move this second variable to its optimum layer. And so on, until all the variables have been moved to their respective optimum layers, or until the total size of the BDD is smaller than a desired or predefined threshold, or until further adjustment of the variable positions no longer significantly reduces the total size of the BDD (e.g., the difference in sizes of the BDD between two consecutive variable position adjustments is less than a predefined threshold). The Sifting Algorithm is also not parallelizable because each layer swap required for the sifting of a given variable depends on the one that immediately precedes it.</p>
<p id="p-0055" num="0054">Window Algorithm</p>
<p id="p-0056" num="0055">Another heuristic algorithm is the Window Algorithm. In generally, the Window Algorithm cannot detect the globally optimum variable order for BDDs, but has the desirable property of fast execution times. For a BDD that represents a function having n variables, a &#x201c;window&#x201d; of size k is used, where 2&#x2266;k&#x3c;n. The algorithm iteratively and sequentially detects the optimum ordering of layers [<b>1</b> . . . k], [<b>2</b> . . . k+1], [<b>3</b> . . . k+2] . . . [n&#x2212;k+1 . . . n]. That is, for each window, the optimum ordering of the k consecutive layers within the window is determined, and the k consecutive layers within the window are reordered according to their optimum ordering. This may be done using the Plain Changes Algorithm described above in connection with <figref idref="DRAWINGS">FIG. 6</figref>. The process is iteratively and sequentially applied to each window (e.g., repeatedly using the Plain Changes Algorithm) until the total size of the BDD is smaller than a desired or predefined threshold, or until further adjustments of the variables within a window no longer significantly reduces the total size of the BDD, or until no further size improvement is possible.</p>
<p id="p-0057" num="0056"><figref idref="DRAWINGS">FIG. 8</figref> illustrates the Window Algorithm as applied to a BDD <b>800</b> representing a function having eight variables. BDD <b>800</b> therefore has eight layers. In this example, the window size k is chosen to be 3. Thus, first, layers 1 to 3 are reordered according to their optimum ordering (e.g., using the Plain Changes Algorithm). Second, layers 2 to 4 are reordered according to their optimum ordering. And so on. When the window moves down to layers 6 to 8, if necessary, the window may restart from layer 1 again. As the Window Algorithm utilizes the Plain Changes Algorithm as a subset, it is typically not parallelizable.</p>
<p id="h-0007" num="0000">Parallel Variable Reordering Algorithms</p>
<p id="p-0058" num="0057">Although there are several existing variable reordering algorithms that determine the optimum or the substantially optimal variable order for a BDD and reorder the variables of the BDD according to its optimum or substantially optimal variable order, none of them can be parallelized efficiently, as <figref idref="DRAWINGS">FIGS. 6-8</figref> illustrate. On the other hand, reordering the variables of a BDD according to its optimum or substantially optimal variable order may be very expensive (e.g., in terms of time and human or machine resources), especially when the number of the variables of the BDD is sufficiently large. For example, as the Plain Changes Algorithm illustrates, for a BDD that represents a function having n variables, it takes a total of n!&#x2212;1 layer swaps to determine its optimum variable order. In practical applications, a BDD often has hundreds or thousands of layers.</p>
<p id="p-0059" num="0058">Various embodiments of the present disclosure therefore provide several variable reordering algorithms for BDDs that significantly improve upon the existing algorithms by efficiently parallelizing the reordering process. There are two main concepts underlining the design of the parallel variable reordering algorithms described in the various embodiments. The first concept may be termed &#x201c;maximal parallelization&#x201d;. For any given BDD having n layers, performing a local swap between two consecutive layers (e.g., layer j and layer j+1) does not alter or affect the other layers (i.e., layers 1 to j&#x2212;1 and layers j+2 to n) of the BDD. This property can be applied recursively. In particular embodiments, all layer swaps that do not depend on each other may be executed concurrently.</p>
<p id="p-0060" num="0059">For example, consider <figref idref="DRAWINGS">FIG. 9</figref> that illustrates a BDD <b>900</b> having eight layers. The eight layers may be grouped into several disjoint pairs of consecutive layers. In particular embodiments, according to one type of grouping, layers 1 and 2 may be paired up; layers 3 and 4 may be paired up; layers 5 and 6 may be paired up; and layers 7 and 8 may be paired up. According to this first type of grouping, the 8 layers of BDD <b>900</b> may be grouped into 4 disjoint pairs of consecutive layers. Two pairs of consecutive layers are considered &#x201c;disjoint&#x201d; if they do not share any common layer. For example, the pair with layers 1 and 2 and the pair with layers 3 and 4 do not share any common layer between them. Swapping layers 1 and 2 do not affect layers 3 to 8. Similarly, swapping layers 3 and 4 do not affect layers 1 to 2 and 5 to 8. And so on. Consequently, the 4 disjoint pairs of consecutive layers may be swapped concurrently as there is no interdependency among the individual pairs. Alternatively, according to another type of grouping, layers 2 and 3 may be paired up; layers 4 and 5 may be paired up; and layers 6 and 7 may be paired up. According to this second type of grouping, the 8 layers of BDD <b>900</b> may be grouped into 3 disjoint pairs of consecutive layers. Again, swapping layers 2 and 3 do not affect layers 1 and 4 to 8. Swapping layers 4 and 5 do not affect layers 1 to 3 and 6 to 8. And so on. Consequently, the 3 disjoint pairs of consecutive layers may be swapped concurrently as there is no interdependency among the individual pairs.</p>
<p id="p-0061" num="0060">To generalize, given any BDD having n layers corresponding to n variables, where n may be any odd or even integer greater than or equal to 3, there are at least two ways to group the n layers into disjoint pairs of consecutive layers. For example, if n=4, then the 4 layers may be grouped as {1, 2} and {3, 4}. On the other hand, if n=5, then one way to group the 5 layers may be {1, 2} and {3, 4}; another way to group the 5 layers may be {1, 2} and {4, 5}; and a third way to group the 5 layers may be {2, 3} and {4, 5}. According to the first type of grouping, each pair includes an odd layer, j<sub>odd</sub>, and an even layer, j<sub>even</sub>, where j<sub>even</sub>=j<sub>odd</sub>+1, for 1&#x2266;j<sub>odd</sub>&#x2266;n&#x2212;1. All the pairs thus grouped may be referred to as &#x201c;odd-grouping pairs&#x201d; or &#x201c;first-grouping pairs&#x201d; and may be swapped concurrently. According to the second type of grouping, each pair includes an even layer, j<sub>even</sub>, and an odd layer, j<sub>odd</sub>, where j<sub>odd</sub>=j<sub>even</sub>+1, for 2&#x2266;j<sub>even</sub>&#x2266;n&#x2212;1. All the pairs thus grouped may be referred to as &#x201c;even-grouping pairs&#x201d; or &#x201c;second-grouping pairs&#x201d; and again may be swapped concurrently. In particular embodiments, all the first-grouping pairs obtained according to the first type of grouping and all the second-grouping pairs obtained according to the second type of grouping may be iteratively and alternatingly swapped.</p>
<p id="p-0062" num="0061">For example, in <figref idref="DRAWINGS">FIG. 9</figref>, during the first iteration, t=1, all the odd-grouping pairs (i.e., the first-grouping pairs) are swapped in parallel (i.e., concurrently). During the second iteration, t=2, all the even-grouping pairs (i.e., the second-grouping pairs) are swapped in parallel. During the third iteration, t=2, all the odd-grouping pairs are again swapped in parallel. The process may continue, alternating between swapping all the odd-grouping pairs and all the even-grouping pairs, until a desired result is achieved.</p>
<p id="p-0063" num="0062">To generalize, in particular embodiments, the process swaps all the odd-grouping pairs concurrently during each odd iteration (e.g., iterations 1, 3, 5, . . . ), and swaps all the even-grouping pairs concurrently during each even iteration (e.g., iterations 2, 4, 6, . . . ). Alternatively, in other embodiments, the process may swap all the even-grouping pairs concurrently during each odd iteration, and swap all the odd-grouping pairs concurrently during each even iteration.</p>
<p id="p-0064" num="0063">The second concept may be termed &#x201c;implicit enumeration of permutations&#x201d;. Consider <figref idref="DRAWINGS">FIG. 10</figref> that illustrates a BDD <b>1000</b> having six layers. Suppose these six layers are grouped into three disjoint pairs of consecutive layers: layers 1 and 2, layers 3 and 4, and layers 5 and 6. The three disjoint pairs of consecutive layers may be swapped sequentially or concurrently. If, before the three layer swaps, the variable order of BDD <b>1000</b> is {1, 2, 3, 4, 5, 6} (i.e., variable 1 is at layer 1; variable 2 is at layer 2; variable 3 is at layer 3; and so on), then after the three layer swaps, the variable order of BDD <b>1000</b> becomes {2, 1, 4, 3, 6, 5} (i.e., variable 2 is at layer 1; variable 1 is at layer 2; variable 4 is at layer 3; variable 3 is at layer 4; variable 6 is at layer 5; and variable 5 is at layer 6).</p>
<p id="p-0065" num="0064">Particular embodiments make the following observation: since the execution of each of these layer swaps does not affect the structure, and thus the size, of the rest of BDD <b>1000</b>, the size of any permutation obtained by executing any subset of these swaps can be calculated without explicitly generating the corresponding complete variable order for the entire BDD. For example, with BDD <b>1000</b>, before the 3 layer swaps, the sizes of the 6 layers may be individually determined, with variable 1 at layer 1, variable 2 at layer 2, variable 3 at layer 3, variable 4 at layer 4, variable 5 at layer 5, and variable 6 at layer 6. After the 3 swaps, the sizes of the 6 layers may be individually determined again, but with variable 2 at layer 1, variable 1 at layer 2, variable 4 at layer 3, variable 3 at layer 4, variable 6 at layer 5, and variable 5 at layer 6. Thus, for each disjoint pair of consecutive layers, there are two sizes: the size before the two layers are swapped and the size after the two layers are swapped. For the 6 layers of BDD <b>1000</b>, there are 3 disjoint pairs of consecutive layers.</p>
<p id="p-0066" num="0065">More specifically, for layers 1 and 2, before layers 1 and 2 are swapped, the size of layers 1 and 2 with variables 1 and 2 may be determined. After layers 1 and 2 are swapped, the size of layers 1 and 2 with variables 2 and 1 may be determined. Similarly, for layers 3 and 4, before layers 3 and 4 are swapped, the size of layers 3 and 4 with variables 3 and 4 may be determined. After layers 3 and 4 are swapped, the size of layers 3 and 4 with variables 4 and 3 may be determined. And for layers 5 and 6, before layers 5 and 6 are swapped, the size of layers 5 and 6 with variables 5 and 6 may be determined. After layers 5 and 6 are swapped, the size of layers 5 and 6 with variables 6 and 5 may be determined.</p>
<p id="p-0067" num="0066">Different combinations of the sizes of the 3 disjoint pairs of consecutive layers may yield sizes of different variable orders for BDD <b>1000</b> without explicitly generating the corresponding variable orders. For example, to implicitly determine the size of variable order {1, 2, 4, 3, 5, 6} (i.e., variable 1 is at layer 1; variable 2 is at layer 2; variable 4 is at layer 3; variable 3 is at layer 4; variable 5 is at layer 5; and variable 6 is at layer 6), particular embodiments may compute the sum of: (1) the size of layers 1 and 2 with variables 1 and 2 respectively (obtained before swapping layers 1 and 2); (2) the size of layers 3 and 4 with variables 4 and 3 respectively (obtained after swapping layers 3 and 4); and (3) the size of the layers 5 and 6 with variables 5 and 6 respectively (obtained before swapping layers 5 and 6). All three sizes have been determined either before or after the 3 layer swaps. As another example, to implicitly determine the size of variable order {2, 1, 3, 4, 6, 5}, particular embodiments may compute the sum of (1) the size of layers 1 and 2 with variables 2 and 1 respectively (obtained after swapping layers 1 and 2); (2) the size of layers 3 and 4 with variables 3 and 4 respectively (obtained before swapping layers 3 and 4); and (3) the size of the layers 5 and 6 with variables 6 and 5 respectively (obtained after swapping layers 5 and 6).</p>
<p id="p-0068" num="0067">In the case of BDD <b>1000</b>, by combining the sizes of the 3 disjoint pairs of consecutive layers obtained before and after the layer swaps, the sizes of 7 additional variable orders may be computed with 3 layer swaps with respect to the 3 disjoint pairs of consecutive layers. Note that since BDD <b>1000</b> initially has variable order {1, 2, 3, 4, 5, 6}, the size of this variable order is already known and does not need to be computed. <figref idref="DRAWINGS">FIG. 10</figref> illustrates all eight different variable orders of BDD <b>1000</b> whose sizes may be determined by combining the different sizes of the 3 disjoint pairs of consecutive layers obtained before and after the 3 swaps. For 6 variables (i.e., 3 disjoint pairs of consecutive layers), there are 8 unique combinations (note that one of the variable orders, {1, 2, 3, 4, 5, 6}, is the initial order before the layer swap). To generalize, given any BDD having n layers corresponding to n variables, if k layer swaps are executed in parallel (i.e., there are k disjoint pairs of consecutive layers), then the sizes of 2<sup>k</sup>&#x2212;1 variable orders can be implicitly computed. Note that there is &#x201c;&#x2212;1&#x201d; because the size of the initial variable order of the BDD before the layer swaps can be obtained directly without requiring any implicit computation. In general, however, given k disjoint pairs of consecutive layers, the sizes of 2<sup>k </sup>different variable orders may be determined by swapping the k disjoint pairs of consecutive layers.</p>
<p id="p-0069" num="0068">The parallel variable reordering algorithms for BDDs described in the various embodiments rely on the concepts of maximal parallelization and implicit enumeration of permutations. Existing variable reordering algorithms for BDDs are not parallelizable because most of the executed swaps are interdependent. Particular embodiments, therefore, attempt to structure the layer-swapping process so that the interdependency between the pairs of consecutive layers that need to be swapped is minimized (e.g., by forming disjoint pairs of consecutive layers), thus increasing the possibility of swapping multiple pairs of consecutive layers in parallel.</p>
<p id="p-0070" num="0069">Parallel Permutation Algorithm</p>
<p id="p-0071" num="0070">Particular embodiments observe that a schedule of swaps where the depth of the swap network is minimized is desirable. Suppose a given BDD having n layers corresponding to n variables initially has a first variable order, and it is desirable to reorder the n variables of the BDD according to a different second variable order. The second variable order may be obtained by any suitable means (e.g., specified by a person, or determined according to design specification requirements or application criteria). Particular embodiments observe that applying a given permutation (i.e., variable order) to the current variable permutation is equivalent to the problem of sorting, if the total order imposed on the variable identifiers is defined by the desired final permutation.</p>
<p id="p-0072" num="0071">In particular embodiments, assume the first variable order of the BDD (i.e., the variable order the BDD currently has) is the identity permutation; that is, each variable i is at layer i for 1&#x2266;i&#x2266;n. The desired, second variable order is defined as &#x3c0;(i); that is, each variable i is at layer &#x3c0;(i) for 1&#x2266;i&#x2266;n. The goal is to reorder the n variables of the BDD so that the BDD eventually has the second variable order. <figref idref="DRAWINGS">FIG. 11A</figref> illustrates an example of the Parallel Permutation Algorithm, which reorders the n variables of a BDD initially having a first variable order according to a second variable order. <figref idref="DRAWINGS">FIG. 11B</figref> illustrate the Parallel Permutation Algorithm as applied to a BDD <b>1100</b> having six layers corresponding to six variables. The steps illustrated in <figref idref="DRAWINGS">FIG. 11A</figref> are described using BDD <b>1100</b> as an example.</p>
<p id="p-0073" num="0072">As described above in connection with <figref idref="DRAWINGS">FIG. 9</figref>, given any BDD having n layers corresponding to n variables, there are two ways to group the n layers into disjoint pairs of consecutive layers. First, the n layers may be grouped into odd-grouping pairs (also referred to as first-grouping pairs), where each pair includes an odd layer followed by an even layer. Second, the n layers may be grouped into even-grouping pairs (also referred to as second-grouping pairs), where each pair includes an even layer followed by an odd layer. All the odd-grouping pairs may be swapped concurrently as they are disjoint from each other (i.e., they do not share any common layer). Similarly, all the even-grouping pairs may be swapped concurrently as they are also disjoint from each other. The Parallel Permutation Algorithm takes advantage of this property.</p>
<p id="p-0074" num="0073">In particular embodiments, the n layers of the BDD are iteratively and alternatingly grouped into odd-grouping pairs and even-grouping pairs, and each pair of layers is swapped if the current order of the two layers during the current iteration differs from the order specified by the second variable order. More specifically, using BDD <b>1100</b> having six layers corresponding to six variables in <figref idref="DRAWINGS">FIG. 11B</figref> as an example. BDD <b>1100</b> initially has a first variable order, which is the identity permutation, {1, 2, 3, 4, 5, 6} (i.e., each variable i is at layer for 1&#x2266;i&#x2266;6). Suppose the desired second variable order is {6, 3, 4, 5, 1, 2} (i.e., variable 6 at layer 1, variable 3 at layer 2, variable 4 at layer 3, and so on, which means &#x3c0;(6)&#x3c;&#x3c0;(3)&#x3c;&#x3c0;(4)&#x3c;&#x3c0;(5)&#x3c;&#x3c0;(1)&#x3c;&#x3c0;(2)).</p>
<p id="p-0075" num="0074">In particular embodiments, during the first iteration (i.e., t=1), the 6 layers of BDD <b>1100</b> is grouped into 3 odd-grouping pairs: layers 1 and 2, layers 3 and 4, and layers 5 and 6, as illustrated in step <b>1101</b> of <figref idref="DRAWINGS">FIG. 11A</figref>. These are disjoint pairs of consecutive layers as they do not share any common layer among the pairs. Therefore, the 3 odd-grouping pairs may be swapped concurrently, as illustrated in step <b>1102</b> of <figref idref="DRAWINGS">FIG. 11A</figref>. For layers 1 and 2, variable 1 is currently at layer 1 and variable 2 is currently at layer 2. Thus, the current order of the two variables at layers 1 and 2 is {1, 2}, which already agrees with the order specified by the second variable order for variables 1 and 2 (i.e., variable 1 before variable 2, which means &#x3c0;(1)&#x3c;&#x3c0;(2)). Therefore, there is no need to swap layers 1 and 2 during this iteration. Similarly, for layers 3 and 4, variable 3 is currently at layer 3 and variable 4 is currently at layer 4. Thus, the current order of the two variables at layers 3 and 4 is {3, 4}, which already agrees with the order specified by the second variable order for variables 3 and 4 (i.e., &#x3c0;(3)&#x3c;&#x3c0;(4)). Therefore, there is also no need to swap layers 3 and 4 during this iteration. On the other hand, for layers 5 and 6, variable 5 is currently at layer 5 and variable 6 is currently at layer 6. The current order of the two variables at layers 5 and 6 is {5, 6}, which differs from the order specified by the second variable order for variables 5 and 6 (i.e., &#x3c0;(5)&#x3e;&#x3c0;(6)). Therefore, layers 5 and 6 are swapped during this iteration, after which variable 6 is at layer 5 and variable 5 is at layer 6. Since there is only one layer swap needed during the first iteration, there is no need for parallelization. However, if multiple layer swaps are needed during an iteration, they may be performed in parallel, since the grouping of the layers ensures that the resulting pairs of consecutive layers are disjoint.</p>
<p id="p-0076" num="0075">After each iteration, the process determines whether the second variable order has been achieved, as illustrated in step <b>1103</b> of <figref idref="DRAWINGS">FIG. 11A</figref>. If so, the process may end with success. Otherwise, the process continues to the next iteration. For BDD <b>1100</b>, after the first iteration, the variable order becomes {1, 2, 3, 4, 6, 5}. Thus, the desired second variable order has not been achieved, and another iteration is needed.</p>
<p id="p-0077" num="0076">In particular embodiments, during the second iteration (i.e., t=2), the 6 layers of BDD <b>1100</b> is grouped into 2 even-grouping pairs: layers 2 and 3, and layers 4 and 5, as illustrated in step <b>1104</b> of <figref idref="DRAWINGS">FIG. 11A</figref>. Again, these are disjoint pairs of consecutive layers as they do not share any common layer among the pairs. Therefore, the 2 even-grouping pairs may be swapped concurrently, as illustrated in step <b>1105</b> of <figref idref="DRAWINGS">FIG. 11A</figref>. For layers 2 and 3, variable 2 is currently at layer 2 and variable 3 is currently at layer 3. The current order of the two variables at layers 2 and 3 is {2, 3}, which differs from the order specified by the second variable order for variables 2 and 3 (i.e., &#x3c0;(2)&#x3e;&#x3c0;(3)). Therefore, layers 2 and 3 are swapped during this iteration, after which variable 3 is at layer 2 and variable 2 is at layer 3. Similarly, for layers 4 and 5, variable 4 is currently at layer 4 and variable 6 is currently at layer 5. The current order of the two variables at layers 4 and 5 is {4, 6}, which differs from the order specified by the second variable order for variables 4 and 6 (i.e., &#x3c0;(4)&#x3e;&#x3c0;(6)). Therefore, layers 4 and 5 are swapped during this iteration, after which variable 6 is at layer 4 and variable 4 is at layer 5. Since two layer swaps are needed during this iteration, in particular embodiments, they may be performed in parallel.</p>
<p id="p-0078" num="0077">Again, after each iteration, the process determines whether the second variable order has been achieved, as illustrated in step <b>1106</b> of <figref idref="DRAWINGS">FIG. 11A</figref>. If so, the process may end with success. Otherwise, the process continues to the next iteration. For BDD <b>1100</b>, after the second iteration, the variable order becomes {1, 3, 2, 6, 4, 5}. Thus, the desired second variable order has not been achieved, and another iteration is needed. The steps performed during the third and the fifth iteration is similar to those of the first iteration, and the steps performed during the fourth and the sixth iteration is similar to those of the second iteration.</p>
<p id="p-0079" num="0078">As illustrated in <figref idref="DRAWINGS">FIG. 11B</figref>, for BDD <b>1100</b>, it takes a total of 6 iterations to reorder the 6 variables before the second variable ordering is achieved. During each odd iteration (i.e., iterations 1, 3, 5), the 6 layers of BDD <b>1100</b> are grouped into odd-grouping disjoint pairs of consecutive layers. During each even iteration (i.e., iterations 2, 4, 6), the 6 layers are grouped into even-grouping disjoint pairs of consecutive layers. During the third iteration (i.e., t=3), layers 1 and 2 and layers 3 and 4 are swapped concurrently. During the fourth iteration (i.e., t=4), layers 2 and 3 and layers 4 and 5 are swapped concurrently. During the fifth iteration (i.e., t=5), layers 1 and 2, layers 3 and 4, and layers 5 and 6 are swapped concurrently. During the sixth iteration (i.e., t=6), layers 4 and 5 are swapped.</p>
<p id="p-0080" num="0079">However, BDD <b>1100</b> is one example of the Parallel Permutation Algorithm. Alternatively, during each odd iteration, the 6 layers may be grouped into even-grouping disjoint pairs of consecutive layers, while during each even iteration, the 6 layers may be grouped into odd-grouping disjoint pairs of consecutive layers. The algorithm is able to achieve its goal as long as the grouping of the layers alternates between successive iterations. During each iteration, the pairs of layers are either swapped or not swapped depending on whether the orders of the variables currently at the layers differ from or agree with the orders of the corresponding variables specified by the desired second variable order.</p>
<p id="p-0081" num="0080">To generalize, given a BDD having n layers corresponding to n variables, and the BDD initially has a first variable order where each variable i is at layer i for 1&#x2266;i&#x2266;n, and given a second variable order of the BDD defined as &#x3c0;(i) where each variable i is at layer &#x3c0;(i) for 1&#x2266;i&#x2266;n, to reorder the n variables of the BDD according to the second variable order, in particular embodiments, the Parallel Permutation Algorithm performs an iterative process. During each odd iterations, the n layers are grouped into a first type of disjoint pairs of consecutive layers according to a first grouping scheme. During each even iterations, the n layers are grouped into a second type of disjoint pairs of consecutive layers according to a second grouping scheme. During each iteration, a pair of consecutive layers is swapped only if the order of the two variables currently at the two layers differs from the order of the two variables specified by the second variable order. That is, for two consecutive layers j<sub>1 </sub>and j<sub>2</sub>, during a particular iteration, suppose variable i<sub>1 </sub>is currently at layer j<sub>1 </sub>and variable i<sub>2 </sub>is currently at layer j<sub>2</sub>. Then, layers j<sub>1 </sub>and j<sub>2 </sub>are swapped during this iteration only if &#x3c0;(i<sub>1</sub>)&#x3e;&#x3c0;(i<sub>2</sub>). In particular embodiments, all the layer swaps performed during each iteration are done in parallel (i.e., concurrently).</p>
<p id="p-0082" num="0081">Particular embodiments observe that for any BDD having n layers corresponding to n variables and the BDD initially has a first variable order, using the Parallel Permutation Algorithm, it takes at most n iterations (each iteration may also be referred to as a &#x201c;level&#x201d;) of layer swaps to reorder the n variables of the BDD to achieve a second variable order. In addition, it takes at most</p>
<p id="p-0083" num="0082">
<maths id="MATH-US-00001" num="00001">
<math overflow="scroll">
<mrow>
  <mo>&#x2003;</mo>
  <mrow>
    <mo>(</mo>
    <mtable>
      <mtr>
        <mtd>
          <mi>n</mi>
        </mtd>
      </mtr>
      <mtr>
        <mtd>
          <mn>2</mn>
        </mtd>
      </mtr>
    </mtable>
    <mo>)</mo>
  </mrow>
</mrow>
</math>
</maths>
<br/>
(i.e., &#x201c;n choose 2&#x201d;, which equals
</p>
<p id="p-0084" num="0083">
<maths id="MATH-US-00002" num="00002">
<math overflow="scroll">
<mrow>
  <mfrac>
    <mrow>
      <mi>n</mi>
      <mo>&#x2061;</mo>
      <mrow>
        <mo>(</mo>
        <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mn>1</mn>
        </mrow>
        <mo>)</mo>
      </mrow>
    </mrow>
    <mn>2</mn>
  </mfrac>
  <mo>)</mo>
</mrow>
</math>
</maths>
<br/>
layer swaps during the n iterations. The Parallel Permutation Algorithm is parallelly optimum as there exists no other layer-swapping schedule that can achieve any permutation in less than n iterations. In comparison, the existing variable reordering algorithms also require at most
</p>
<p id="p-0085" num="0084">
<maths id="MATH-US-00003" num="00003">
<math overflow="scroll">
<mrow>
  <mo>&#x2003;</mo>
  <mrow>
    <mo>(</mo>
    <mtable>
      <mtr>
        <mtd>
          <mi>n</mi>
        </mtd>
      </mtr>
      <mtr>
        <mtd>
          <mn>2</mn>
        </mtd>
      </mtr>
    </mtable>
    <mo>)</mo>
  </mrow>
</mrow>
</math>
</maths>
<br/>
layer swaps but may require as many as
</p>
<p id="p-0086" num="0085">
<maths id="MATH-US-00004" num="00004">
<math overflow="scroll">
<mrow>
  <mo>&#x2003;</mo>
  <mrow>
    <mo>(</mo>
    <mtable>
      <mtr>
        <mtd>
          <mi>n</mi>
        </mtd>
      </mtr>
      <mtr>
        <mtd>
          <mn>2</mn>
        </mtd>
      </mtr>
    </mtable>
    <mo>)</mo>
  </mrow>
</mrow>
</math>
</maths>
<br/>
iterations.
</p>
<p id="p-0087" num="0086">The Parallel Permutation Algorithm described above in connection with <figref idref="DRAWINGS">FIG. 11A</figref> may be used for transforming permutations between different partitions of BDDs and particularly of ROBDDs. In practical applications, a BDD, or more commonly, a ROBDD often has thousands, even millions of nodes. Therefore, storing such large BDDs or ROBDDs may require a great amount of storage space. To address this problem, often, a large BDD or ROBDD may be partitioned into two or more sub-BDDs, and each sub-BDD is in effect a BDD by itself. The original BDD may be obtained by logically OR'ing the sub-BDDs. To further reduce the need for storage space, the variables of each sub-BDD may be reordered according to the optimum or substantially optimal variable order of that particular sub-BDD. The sub-BDDs are then stored thus. However, since each sub-BDD is in effect a BDD by itself, the optimum or substantially optimal variable order of one sub-BDD may differ from the optimum or substantially optimal variable order of another sub-BDD.</p>
<p id="p-0088" num="0087">When operations need to be performed in connection with the BDD, the sub-BDDs may be combined together to form the original BDD. Alternatively, the operations may be performed in connection with the individual sub-BDDs. In either case, when performing these operations, all the sub-BDDs involved need to have the same variable order. If there are a total of m sub-BDDs, where m&#x2267;2, all having different variable orders, then the variables of m&#x2212;1 sub-BDDs may need to be reordered.</p>
<p id="p-0089" num="0088">In particular embodiments, suppose there are two BDDs, a first BDD and a second BDD, each having n layers corresponding to n variables. The first BDD currently has a first variable order. The second BDD currently has a second variable order, which differs from the first variable order of the first BDD. Further suppose that the first BDD and the second BDD are two partitions (i.e., two sub-BDDs) of a third BDD (i.e., the first BDD and the second BDD together form the third BDD). When needed, the n variables of the first BDD may be reordered according to the second variable order of the second BDD using the Parallel Permutation Algorithm described above in connection with <figref idref="DRAWINGS">FIG. 11A</figref>. Alternatively, the n variables of the second BDD may be reordered according to the first variable order of the first BDD using the Parallel Permutation Algorithm. In either case, after the variable reordering, the first BDD and the second BDD both have the same variable order. Thereafter, they may be combined to form the third BDD or operations may be performed in connection with the first BDD and the second BDD individually. The process may be applied similarly where a BDD is partitioned into three or more sub-BDDs. One sub-BDD is selected as the sub-BDD having the desired variable order. The variables of each of the other sub-BDDs are reordered according to the variable order of the selected sub-BDD using the Parallel Permutation Algorithm.</p>
<p id="p-0090" num="0089">Optimum Layer-Swapping Schedules for BDDs with Four Variables</p>
<p id="p-0091" num="0090">As <figref idref="DRAWINGS">FIG. 9</figref> illustrates, given any BDD having n layers corresponding to variables, the maximum parallelization that can be achieved is n/2, as at most n/2 layer swaps can be executed in parallel during each iteration. Therefore, it is desirable to place as many as n/2 layer swaps during each iteration (i.e., at each level). While this is possible for the case of the permutation algorithm, it is not always possible when at the same time, the process needs to respect the semantics of an exact or heuristic algorithm.</p>
<p id="p-0092" num="0091">In the case of exact reordering, in particular embodiments, it is desirable to determine a swapping schedule that requires less than n!&#x2212;1 iterations to perform n!&#x2212;1 layer swaps (e.g., as with the case of the Plain Changes Algorithm) in order to go through all the possible variable permutations to determine the optimum variable order. Particular embodiments may determine the swapping schedule based on the implicit permutations concept described above.</p>
<p id="p-0093" num="0092">Particular embodiments may consider a BDD having 4 layers corresponding to 4 variables and determine the optimum layer-swapping schedule for such a BDD. Note that for BDDs having 2 or 3 layers corresponding to 2 or 3 variables, no two swaps can be executed in parallel as, for example, <figref idref="DRAWINGS">FIG. 6</figref> illustrates.</p>
<p id="p-0094" num="0093"><figref idref="DRAWINGS">FIGS. 12A-12B</figref> illustrate an example optimum layer-swapping schedule for a BDD <b>1200</b> having four layers corresponding to four variables. There are a total of 19 layer swaps performed during 13 iterations. Note that all layer swaps that belong to the same iteration can be performed in parallel. Thus, during the first iteration (i.e., at the first level) layers 1 and 2 and layers 3 and 4 are swapped concurrently. During the second iteration, layers 2 and 3 are swapped. During the third iteration, layers 1 and 2 and layers 3 and 4 are swapped concurrently. An so on. For example, suppose the initial variable order of BDD <b>1200</b> is {1, 2, 3, 4}. The variable orders before and after each iteration are indicated with BDD <b>1200</b> in <figref idref="DRAWINGS">FIG. 12B</figref>. After going through the 13 iterations of layer swaps, the end variable order of BDD <b>1200</b> is {2, 3, 4, 1}. During the 13 iterations, the 4 variables are moved between the 4 layers.</p>
<p id="p-0095" num="0094">For 4 variables, there are a total of 24 (i.e., 4!) possible variable orders. To determine the optimum variable order, the sizes of the 24 possible variable orders need to be determined so that the variable order with the smallest size may be selected. However, based on the implicit enumeration concept, the 24 possible variable orders do not need to be explicitly generated in order to determine the 24 sizes of the 24 variable orders.</p>
<p id="p-0096" num="0095">Using BDD <b>1200</b> as an example, suppose the initial variable order of BDD <b>1200</b> is {1, 2, 3, 4}. The size, s<sub>1,2</sub><sup>1,2</sup>, of layers 1 and 2 with variables 1 and 2, respectively, may be determined, and the size, s<sub>3,4</sub><sup>3,4</sup>, of layers 3 and 4 with variables 3 and 4, respectively, may be determined. During the first iteration (i.e., t=1), layers 1 and 2 and layers 3 and 4 are swapped in parallel. After the first iteration, the variable order of BDD <b>1200</b> is {2, 1, 4, 3}. The size, s<sub>1,2</sub><sup>2,1</sup>, of layers 1 and 2 with variables 2 and 1, respectively, may be determined, and the size, s<sub>3,4</sub><sup>4,3</sup>, of layers 3 and 4 with variables 4 and 3, respectively, may be determined. After the first iteration, the sizes of 4 variable orders may be computed: (1) the size of variable order {1, 2, 3, 4} is the sum of s<sub>1,2</sub><sup>1,2 </sup>and s<sub>3,4</sub><sup>3,4 </sup>(note that since {1, 2, 3, 4} is the initial variable order of BDD <b>1200</b>, the size of this variable order is in fact the initial size of BDD <b>1200</b>, which is known without requiring any layer swap); (2) the size of variable order {2, 1, 3, 4} is the sum of s<sub>1,2</sub><sup>2,1 </sup>and s<sub>3,4</sub><sup>3,4</sup>; (3) the size of variable order {1, 2, 4, 3} is the sum of s<sub>1,2</sub><sup>2,1 </sup>and s<sub>3,4</sub><sup>4,3</sup>; and (4) the size of variable order {2, 1, 4, 3} is the sum of s<sub>1,2</sub><sup>2,1 </sup>and s<sub>3,4</sub><sup>4,3</sup>. In practice, however, it may not be necessary to explicitly compute all 4 sizes of the 4 variable orders obtained in connection with the first iteration. Particular embodiments may select the smaller of sizes s<sub>1,2</sub><sup>1,2 </sup>and s<sub>1,2</sub><sup>2,1 </sup>for layers 1 and 2 and select the smaller of sizes s<sub>3,4</sub><sup>3,4 </sup>and s<sub>3,4</sub><sup>4,3 </sup>for layers 3 and 4 to determine the variable order that yields the smallest size for the 4 variable orders obtained in connection with the first iteration and record the variable order that yields the smallest size thus far for comparison during subsequent iterations.</p>
<p id="p-0097" num="0096">During the second iteration (i.e., t=2), layers 2 and 3 are swapped. After the second iteration, the variable order is {2, 4, 1, 3}. The purpose of the second iteration is to position the 4 variables for another iteration where layers 1 and 2 and layers 3 and 4 may be swapped concurrently and the sizes of more variable orders may be computed based on the implicit permutations concept, similar to the process described with the first iteration.</p>
<p id="p-0098" num="0097">Before the third iteration, the size, s<sub>1,2</sub><sup>2,4</sup>, of layers 1 and 2 with variables 2 and 4, respectively, may be determined, and the size, s<sub>3,4</sub><sup>1,3</sup>, of layers 3 and 4 with variables 1 and 3, respectively, may be determined. During the third iteration (i.e., t=3), layers 1 and 2 and layers 3 and 4 are swapped in parallel. After the third iteration, the variable order of BDD <b>1200</b> is {4, 2 3, 1}. The size, s<sub>1,2</sub><sup>4,2</sup>, of layers 1 and 2 with variables 4 and 2, respectively, may be determined, and the size, s<sub>3,4</sub><sup>3,1</sup>, of layers 3 and 4 with variables 3 and 1, respectively, may be determined. After the third iteration, the sizes of another 4 variable orders may be computed: (1) the size of variable order {2, 4, 1, 3} is the sum of s<sub>1,2</sub><sup>2,4 </sup>and s<sub>3,4</sub><sup>1,3</sup>; (2) the size of variable order {2, 4, 3, 1} is the sum of s<sub>1,2</sub><sup>2,4 </sup>and s<sub>3,4</sub><sup>3,1</sup>; (3) the size of variable order {4, 2, 1, 3} is the sum of s<sub>1,2</sub><sup>4,2 </sup>and s<sub>3,4</sub><sup>1,3</sup>; and (4) the size of variable order {4, 2, 3, 1} is the sum of s<sub>1,2</sub><sup>4,2 </sup>and s<sub>3,4</sub><sup>3,1</sup>. Again, in practice, it may not be necessary to explicitly compute all 4 sizes of the 4 variable orders obtained in connection with the third iteration. Particular embodiments may select the smaller of sizes s<sub>1,2</sub><sup>2,4 </sup>and s<sub>1,2</sub><sup>4,2 </sup>for layers 1 and 2 and select the smaller of sizes s<sub>3,4</sub><sup>1,3 </sup>and s<sub>3,4</sub><sup>3,1 </sup>for layers 3 and 4 to determine the variable order that yields the smallest size for these 4 variable orders obtained in connection with the third iteration. The smallest size for the 4 variable orders obtained in connection with the third iteration may be compared with the smallest size for the 4 variables orders obtained in connection with the first iteration. The variable order from the first or the third iteration that yields the smallest size thus far may be recorded for comparison during subsequent iterations.</p>
<p id="p-0099" num="0098">During the fourth iteration (i.e., t=4), layers 2 and 3 are swapped. During the fifth iteration (i.e., t=5), layers 1 and 2 are swapped. After the fifth iteration, the variable order is {4, 3, 2, 1}. The purpose of the fourth and the fifth iteration is to position the 4 variables for another iteration where layers 1 and 2 and layers 3 and 4 may be swapped concurrently and the sizes of more variable orders may be computed based on the implicit permutations concept, similar to the process described with the first and the third iteration.</p>
<p id="p-0100" num="0099">Examining BDD <b>1200</b>, there are four more iterations (i.e., the sixth iteration, the ninth iteration, the eleventh iteration, and the thirteenth iteration) during which layers 1 and 2 and layers 3 and 4 are swapped concurrently. During each of these iterations, the sizes of four unique variable orders may be computed based on the implicit enumeration concept, similar as the first and the third iteration. Examining BDD <b>1200</b>, there are a total of 6 iterations (i.e., the first, the third, the sixth, the ninth, the eleventh, and the thirteenth iterations) during which layers 1 and 2 and layers 3 and 4 are swapped concurrently. Each of these 6 iterations provide sizes of 4 variable orders based on the implicit enumeration concept. Thus, these 6 iterations may be referred to as enumeration or permutation iterations. The other iterations in between these 6 enumeration iterations (e.g., the second, the fourth, the fifth, the seventh, the eighth, the tenth, and the twelfth iteration) reposition the variables for the subsequent enumeration iterations.</p>
<p id="p-0101" num="0100">In particular embodiments, after each enumeration iteration, the variable order that yields the smallest size among the 4 variable orders obtained in connection with that enumeration iteration is selected, and its size (i.e., the smallest of the sizes of the 4 variable orders obtained in connection with that enumeration iteration) is compared with the smallest size of the variable order obtained and recorded during the previous iterations, and the variable order that yields the smaller size is recorded as the variable order that yields the smallest size thus far. Therefore, at the end of the thirteenth iteration, the variable order selected as the result of again comparing the smallest size of the 4 variable orders obtained in connection with the thirteenth iteration and the smallest size determined and recorded during the previous iterations is the optimum variable order for BDD <b>1200</b>, as it yields the smallest size among all 24 possible variable orders.</p>
<p id="p-0102" num="0101">Comparing the optimum layer-swapping schedule illustrated in <figref idref="DRAWINGS">FIGS. 12A-12B</figref> with, for example, the Plain Changes Algorithm as applied to a BDD having 4 layers corresponding to 4 variables. To obtain all possible variable permutations for the 4 variables, the Plain Changes Algorithm requires 23 layer swaps packed in either 23 iterations without parallelization or 18 iterations with full parallelization, where as the layer-swapping schedule illustrated in <figref idref="DRAWINGS">FIGS. 12A-12B</figref> only requires 13 iterations with 19 layer swaps. Obviously, the layer-swapping schedule illustrated in <figref idref="DRAWINGS">FIGS. 12A-12B</figref> improves upon the Plain Changes Algorithm as it requires less number of iterations and layer swaps, and thus less time to complete.</p>
<p id="p-0103" num="0102"><figref idref="DRAWINGS">FIGS. 12A-12B</figref> illustrate one example of the optimum layer-swapping schedule that requires 19 layer swaps performed during 13 iterations to determine the optimum variable order for a BDD having 4 variables. There are about 60 different optimum layer-swapping schedules that each determine the optimum variable order for a BDD having 4 variables using 19 layers swaps performed during 13 iterations. Similarly to the layer-swapping schedule illustrated in <figref idref="DRAWINGS">FIGS. 12A-12B</figref>, each of the optimum layer-swapping schedules includes 6 enumeration iterations, during which layers 1 and 2 and layers 3 and 4 are swapped in parallel. For each of the 6 enumeration iterations, the sizes of 4 variable orders may be computed based on the implicit enumeration concept. Iterations in between the enumeration iterations reposition the variables. <figref idref="DRAWINGS">FIG. 12C</figref> illustrates the other examples of the optimum layer-swapping schedule. Again, each of these optimum layer-swapping schedules may be used to determine the optimum variable order of a BDD having 4 variables based on the implicit enumeration concept, and the process is similar to that described in connection with <figref idref="DRAWINGS">FIGS. 12A-12B</figref>.</p>
<p id="p-0104" num="0103">Pair-Wise Grouping of BDD Variables</p>
<p id="p-0105" num="0104">Assume n=2k (i.e., n is even). There exists</p>
<p id="p-0106" num="0105">
<maths id="MATH-US-00005" num="00005">
<math overflow="scroll">
<mfrac>
  <mrow>
    <mi>n</mi>
    <mo>!</mo>
  </mrow>
  <msup>
    <mn>2</mn>
    <mi>k</mi>
  </msup>
</mfrac>
</math>
</maths>
<br/>
ways to separate a set of n numbers, {1, . . . , n}, into
</p>
<p id="p-0107" num="0106">
<maths id="MATH-US-00006" num="00006">
<math overflow="scroll">
<mfrac>
  <mrow>
    <mi>n</mi>
    <mo>!</mo>
  </mrow>
  <msup>
    <mn>2</mn>
    <mi>k</mi>
  </msup>
</mfrac>
</math>
</maths>
<br/>
groups of k ordered sets of two elements (i.e., there are two elements in each set, and there are k sets in each group). Each particular group may be referred to as a particular separation of the n variables. For example, for the case of n=4 (i.e., k=2), there exists 6 ways to separate {1, 2, 3, 4} into 6 unique groups of 2 ordered sets of two elements. The following illustrates the 4 variables separated into 6 unique groups of 2 ordered sets of 2 variables:
</p>
<p id="p-0108" num="0107">group 1: {1, 2} {3, 4}</p>
<p id="p-0109" num="0108">group 2: {1, 3} {2, 4}</p>
<p id="p-0110" num="0109">group 3: {1, 4} {2, 3}</p>
<p id="p-0111" num="0110">group 4: {2, 3} {1, 4}</p>
<p id="p-0112" num="0111">group 5: {2, 4} {1, 3}</p>
<p id="p-0113" num="0112">group 6: {3, 4} {1, 2}</p>
<p id="p-0114" num="0113">Note that within each group of k sets of two elements, each element only appears once. For example, within each of the 6 types of separation above, if a number appears in the first set, then it does not appear in the second set. Conversely, if a number appears in the second set, then it does not appear in the first set. In particular embodiments, applying this concept to BDD variables, an element is equivalent to a variable. Each two-variable set includes two of the variables of a BDD, and each group includes k ordered sets). Within each two-variable set, the order of the two variables is irrelevant (e.g., {1, 2} is considered the same as {2, 1}). However, for each k ordered sets of two variables, the order matters. Thus, [{1, 2} {3, 4}] is not considered the same as [{3, 4} {1, 2}]. Therefore, there exists</p>
<p id="p-0115" num="0114">
<maths id="MATH-US-00007" num="00007">
<math overflow="scroll">
<mfrac>
  <mrow>
    <mi>n</mi>
    <mo>!</mo>
  </mrow>
  <msup>
    <mn>2</mn>
    <mi>k</mi>
  </msup>
</mfrac>
</math>
</maths>
<br/>
ways to order the separations themselves. Since each group consists of k ordered sets of two variables, and two variables may be referred to as a pair of variables, this method of separating the BDD variables may be referred to as &#x201c;pair-wise grouping&#x201d; of the BDD variables.
</p>
<p id="p-0116" num="0115">For the case of a BDD having 6 variables (i.e., n=6 and k=3), there exist 90 ways to separate the 6 variables into 3 ordered sets of two variables each (i.e., 90 unique groups). The following illustrates a few example groups of the pair-wise separation of the 6 variables:</p>
<p id="p-0117" num="0116">group 1: {1, 2} {3, 4} {5, 6}</p>
<p id="p-0118" num="0117">group 2: {1, 3} {2, 4} {5, 6}</p>
<p id="p-0119" num="0118">group 3: {2, 4} {1, 3} {5, 6}</p>
<p id="p-0120" num="0119">group 4: {2, 5} {1, 6} {3, 4}</p>
<p id="p-0121" num="0120">group 5: {3, 4} {1, 5} {2, 6}</p>
<p id="p-0122" num="0121">group 6: {3, 6} {1, 2} {4, 5}</p>
<p id="p-0123" num="0122">group 7: {4,5} {2,3} {1,6}</p>
<p id="p-0124" num="0123">group 8: {4, 6} {1, 5} {2, 3}</p>
<p id="p-0125" num="0124">group 9: {5, 6} {1, 2} {3, 4}</p>
<p id="p-0126" num="0125">In particular embodiments, suppose each group of the k ordered sets of two variables is considered a particular variable order of the BDD. For example, in the case of 4 variables, group 1 provides variable order {1, 2, 3, 4} (i.e., variables 1, 2, 3, 4 are at layers 1, 2, 3, 4, respectively). Group 2 provides variable order {1, 3, 2, 4} (i.e., variables 1, 3, 2, 4 are at layers 1, 2, 3, 4, respectively). Group 3 provides variable order {1, 4, 2, 3} (i.e., variables 1, 4, 2, 3 are at layers 1, 2, 3, 4, respectively). And so on. In the case of 6 variables, group 1 provides variable order {1, 2, 3, 4, 5, 6} (i.e., variables 1, 2, 3, 4, 5, 6 are at layers 1, 2, 3, 4, 5, 6, respectively). Group 3 provides variable order {2, 4, 1, 3, 5, 6} (i.e., variables 2, 4, 1, 3, 5, 6 are at layers 1, 2, 3, 4, 5, 6, respectively). Group 5 provides variable order {3, 4, 1, 5, 2, 6} (i.e., variables 3, 4, 1, 5, 2, 6 are at layers 1, 2, 3, 4, 5, 6, respectively). And so on.</p>
<p id="p-0127" num="0126">Using the case of 4 variables as an example, the BDD has 4 layers. Layers 1 and 2 and layers 3 and 4 form two disjoint pairs of consecutive layers. Therefore, layers 1 and 2 and layers 3 and 4 may be swapped concurrently, as described above in connection with <figref idref="DRAWINGS">FIG. 9</figref>. Considering group 1 of the 4-variable case, [{1, 2,} {3, 4}], which may provide variable order {1, 2, 3, 4}. If layers 1 and 2 and layers 3 and 4 are swapped, then after the layer swapping, the variable order becomes {2, 1, 4, 3}. Using the concept of implicit enumeration as described above in connection with <figref idref="DRAWINGS">FIG. 10</figref>, if the sizes of layers 1 and 2 are determined before and after layers 1 and 2 are swapped, and the sizes of layers 3 and 4 are determined before and after layers 3 and 4 are swapped, then the sizes of 4 variable orders (i.e., {1, 2, 3, 4}, {2, 1, 3, 4}, {1, 2, 4, 3}, and {2, 1, 4, 3}) may be computed by combining of the sizes of layers 1 and 2 and the sizes of layers 3 and 4. The same process may be applied to each of the other 5 groups. For example, for group 2 of the 4-variable case, [{1, 3} {2, 4}], before the layer swapping, the variable order provided by group 2 is {1, 3, 2, 4}. After the layer swapping, the variable order becomes {3, 1, 4, 2}. Again, if the sizes of layers 1 and 2 are determined before and after layers 1 and 2 are swapped, and the sizes of layers 3 and 4 are determined before and after layers 3 and 4 are swapped, then the sizes of 4 variable orders (i.e., {1, 3, 2, 4}, {3, 1, 2, 4}, {1, 3, 4, 2}, and {3, 1, 4, 2}) may be computed. Thus, each unique group may provide the sizes of four different variable orders by swapping layers 1 and 2 and layers 3 and 4. With 6 unique groups, the sizes of all 24 variable orders of a BDD having 4 variables may be computed. The variable order having the smallest size is the optimum variable order of the BDD.</p>
<p id="p-0128" num="0127">Consider the case of 6 variables, where the BDD has 6 layers. Layers 1 and 2, layers 3 and 4, and layers 5 and 6 form three disjoint pairs of consecutive layers. Therefore, layers 1 and 2, layers 3 and 4, and layers 5 and 6 may be swapped concurrently. Each group may provide a different variable order. For example, group 7 of the 6-variable case provides variable order {4, 5, 2, 3, 1, 6}.</p>
<p id="p-0129" num="0128">If the sizes of layers 1 and 2 are determined before and after layers 1 and 2 are swapped, the sizes of layers 3 and 4 are determined before and after layers 3 and 4 are swapped, and the sizes of layers 5 and 6 are determined before and after layers 5 and 6 are swapped then the sizes of 8 variable orders of the BDD may be computed by combining of the sizes of layers 1 and 2, the sizes of layers 3 and 4, and the sizes of layers 5 and 6 based on the implicit enumeration concept. In fact, each of the 90 unique groups may provide the sizes of 8 different variable orders by swapping layers 1 and 2, layers 3 and 4, and layers 5 and 6, thus providing the sizes of all 270 possible variable orders of a BDD having 6 variables. Again, the variable order having the smallest size is the optimum variable order of the BDD.</p>
<p id="p-0130" num="0129">The process may be similarly applied to a BDD having n layers corresponding to n variables, where n is any integer, even or odd, that is greater than or equal to 3. When n is odd, there may be a set in each group that has only 1 variable, instead of 2 variables. For example, if n=5 (i.e., an odd number), then some example groups of the pair-wise separation of the 5 variables may be:</p>
<p id="p-0131" num="0130">group 1: {1, 2} {3, 4} {5}</p>
<p id="p-0132" num="0131">group 2: {1, 3} {4, 5} {2}</p>
<p id="p-0133" num="0132">group 3: {2, 4} {1, 5} {3}</p>
<p id="p-0134" num="0133">group 4: {1, 5} {3, 4} {2}</p>
<p id="p-0135" num="0134">Because the variable sets in each group are ordered (i.e., the order of the sets in each group is relevant to the variable reordering algorithms), in particular embodiments, when n is odd so that there is one set in each group that has only one variable, the relative position of this one-variable set, with respect to the other two-variable sets, in each group is relevant and should be the same among all the groups. For example, the one-variable set may be the last set in all the groups, or the first set in all the groups, or the second set in all the groups, and so on. In other words, it is irrelevant which position (e.g., first, second, third, or last) the one-variable set is actually placed, in relation to the other two-variable sets, in each group, but it is necessary that the one-variable set is placed at the same position in relation to the other two-variable sets in all the groups.</p>
<p id="p-0136" num="0135">To generalize, in particular embodiments, the n variables may be separated into</p>
<p id="p-0137" num="0136">
<maths id="MATH-US-00008" num="00008">
<math overflow="scroll">
<mfrac>
  <mrow>
    <mi>n</mi>
    <mo>!</mo>
  </mrow>
  <msup>
    <mn>2</mn>
    <mrow>
      <mo>&#x230a;</mo>
      <mrow>
        <mi>n</mi>
        <mo>/</mo>
        <mn>2</mn>
      </mrow>
      <mo>&#x230b;</mo>
    </mrow>
  </msup>
</mfrac>
</math>
</maths>
<br/>
unique groups, where each group consists of
</p>
<p id="p-0138" num="0137">
<maths id="MATH-US-00009" num="00009">
<math overflow="scroll">
<mrow>
  <mo>&#x2308;</mo>
  <mfrac>
    <mi>n</mi>
    <mn>2</mn>
  </mfrac>
  <mo>&#x2309;</mo>
</mrow>
</math>
</maths>
<br/>
ordered sets. When n is even, all the sets in each group each have two variables. When n is odd, all the sets except one set in each group each have two variables, and one set in each group has one variable. Each group may provide the sizes of 2<sup>&#x2514;n/2&#x2518;</sup>, different variable orders of the BDD based on the implicit enumeration concept (i.e., by concurrently swapping
</p>
<p id="p-0139" num="0138">
<maths id="MATH-US-00010" num="00010">
<math overflow="scroll">
<mrow>
  <mo>&#x230a;</mo>
  <mfrac>
    <mi>n</mi>
    <mn>2</mn>
  </mfrac>
  <mo>&#x230b;</mo>
</mrow>
</math>
</maths>
<br/>
disjoint pairs of consecutive layers, determining the sizes of the disjoint pairs of consecutive layers, and combining these sizes). Finally, the variable order having the smallest size among all possible variable orders is the optimum variable order of the BDD
</p>
<p id="p-0140" num="0139">In particular embodiments, once the</p>
<p id="p-0141" num="0140">
<maths id="MATH-US-00011" num="00011">
<math overflow="scroll">
<mfrac>
  <mrow>
    <mi>n</mi>
    <mo>!</mo>
  </mrow>
  <msup>
    <mn>2</mn>
    <mrow>
      <mo>&#x230a;</mo>
      <mrow>
        <mi>n</mi>
        <mo>/</mo>
        <mn>2</mn>
      </mrow>
      <mo>&#x230b;</mo>
    </mrow>
  </msup>
</mfrac>
</math>
</maths>
<br/>
unique groups of the
</p>
<p id="p-0142" num="0141">
<maths id="MATH-US-00012" num="00012">
<math overflow="scroll">
<mrow>
  <mo>&#x2308;</mo>
  <mfrac>
    <mi>n</mi>
    <mn>2</mn>
  </mfrac>
  <mo>&#x2309;</mo>
</mrow>
</math>
</maths>
<br/>
ordered sets of two variables or one variable are formed, for each group, the variable order that yields the smallest size among the 2<sup>&#x2514;n/2&#x2518;</sup> different variable orders provided by that group may be determined. This variable order is the locally optimum variable order within that group. Then the
</p>
<p id="p-0143" num="0142">
<maths id="MATH-US-00013" num="00013">
<math overflow="scroll">
<mfrac>
  <mrow>
    <mi>n</mi>
    <mo>!</mo>
  </mrow>
  <msup>
    <mn>2</mn>
    <mrow>
      <mo>&#x230a;</mo>
      <mrow>
        <mi>n</mi>
        <mo>/</mo>
        <mn>2</mn>
      </mrow>
      <mo>&#x230b;</mo>
    </mrow>
  </msup>
</mfrac>
</math>
</maths>
<br/>
locally optimum variable orders from the
</p>
<p id="p-0144" num="0143">
<maths id="MATH-US-00014" num="00014">
<math overflow="scroll">
<mfrac>
  <mrow>
    <mi>n</mi>
    <mo>!</mo>
  </mrow>
  <msup>
    <mn>2</mn>
    <mrow>
      <mo>&#x230a;</mo>
      <mrow>
        <mi>n</mi>
        <mo>/</mo>
        <mn>2</mn>
      </mrow>
      <mo>&#x230b;</mo>
    </mrow>
  </msup>
</mfrac>
</math>
</maths>
<br/>
groups may be compared to select the variable order that yields the smallest size for the BDD. This is the optimum variable order of the BDD. <figref idref="DRAWINGS">FIG. 13A</figref> illustrates an example of the pair-wise group of the BDD variables.
</p>
<p id="p-0145" num="0144">In particular embodiments, once the</p>
<p id="p-0146" num="0145">
<maths id="MATH-US-00015" num="00015">
<math overflow="scroll">
<mfrac>
  <mrow>
    <mi>n</mi>
    <mo>!</mo>
  </mrow>
  <msup>
    <mn>2</mn>
    <mrow>
      <mo>&#x230a;</mo>
      <mrow>
        <mi>n</mi>
        <mo>/</mo>
        <mn>2</mn>
      </mrow>
      <mo>&#x230b;</mo>
    </mrow>
  </msup>
</mfrac>
</math>
</maths>
<br/>
unique groups of the
</p>
<p id="p-0147" num="0146">
<maths id="MATH-US-00016" num="00016">
<math overflow="scroll">
<mrow>
  <mo>&#x2308;</mo>
  <mfrac>
    <mi>n</mi>
    <mn>2</mn>
  </mfrac>
  <mo>&#x2309;</mo>
</mrow>
</math>
</maths>
<br/>
ordered sets of two variables or one variable are formed, for each group, it is desirable to determine the locally optimum variable order within that group as efficiently as possible. In the case of a BDD having 4 variables, suppose the 6 groups resulted from separating the 4 variable are as follows:
</p>
<p id="p-0148" num="0147">group 1: {1, 2} {3, 4}</p>
<p id="p-0149" num="0148">group 2: {2, 4} {1, 3}</p>
<p id="p-0150" num="0149">group 3: {3, 4} {2, 1}</p>
<p id="p-0151" num="0150">group 4: {4, 1} {2, 3}</p>
<p id="p-0152" num="0151">group 5: {1,3} {4,2}</p>
<p id="p-0153" num="0152">group 6: {3, 2} {1, 4}</p>
<p id="p-0154" num="0153">Note that since within each set of two variables, the order of the two variables is irrelevant, [{4, 1,} {2, 3}] and [{1, 4} {2, 3}] are considered the same group, not two unique groups. Again, each two sets of two variables together may provide a different variable order. The optimum layer-swapping schedules described above in connection with <figref idref="DRAWINGS">FIGS. 12A-12B</figref> may be used to determine the sizes of the different variable orders obtained from the 6 groups efficient. If the 4 variables are separated into the above 6 groups, then the layer-swapping schedule illustrated in <figref idref="DRAWINGS">FIGS. 12A-12B</figref> may be used to determine the sizes of the 24 possible variable orders based on the implicit enumeration concept.</p>
<p id="p-0155" num="0154">In <figref idref="DRAWINGS">FIG. 13B</figref>, the layer-swapping schedule for the four variables is the same as that illustrated in <figref idref="DRAWINGS">FIG. 12B</figref>. However, only the variable orders corresponding to the above 6 groups are marked. As <figref idref="DRAWINGS">FIG. 13B</figref> suggests, the 6 unique groups or 2 ordered sets of 2 variables, as illustrated above, correspond to the 6 variable orders before the 6 iterations during which both layers 1 and 2 and layers 3 and 4 are swapped. In the more general case of n variables separated into</p>
<p id="p-0156" num="0155">
<maths id="MATH-US-00017" num="00017">
<math overflow="scroll">
<mfrac>
  <mrow>
    <mi>n</mi>
    <mo>!</mo>
  </mrow>
  <msup>
    <mn>2</mn>
    <mrow>
      <mo>&#x230a;</mo>
      <mrow>
        <mi>n</mi>
        <mo>/</mo>
        <mn>2</mn>
      </mrow>
      <mo>&#x230b;</mo>
    </mrow>
  </msup>
</mfrac>
</math>
</maths>
<br/>
groups (i.e., separations) of
</p>
<p id="p-0157" num="0156">
<maths id="MATH-US-00018" num="00018">
<math overflow="scroll">
<mrow>
  <mo>&#x2308;</mo>
  <mfrac>
    <mi>n</mi>
    <mn>2</mn>
  </mfrac>
  <mo>&#x2309;</mo>
</mrow>
</math>
</maths>
<br/>
ordered sets of two variables or one variable, in particular embodiments, each unique group corresponds to an iteration of the exact layer-swapping schedule during which all layer swaps (1,2), (3,4), . . . , (n&#x2212;1, n) are executed. In between these iterations, particular embodiments utilize the Parallel Permutation Algorithm in order to connect the two variable orders corresponding to two groups. For example, the variable order derived from the first of the two groups may be considered the initial variable order and the variable order derived from the second of the two groups may be considered the ending variable order in connection with the Parallel Permutation Algorithm. In particular embodiments, at most n iterations of layer swaps may need to be performed between two groups.
</p>
<p id="p-0158" num="0157"><figref idref="DRAWINGS">FIG. 13B</figref> thus illustrates the 6 separation stages and the parallel permutation stages for the above particular separation ordering. Each separation stage corresponds to a particular group of n/2 ordered sets of two variables. The 6 separation stages are marked as S<sub>1 </sub>to S<sub>6</sub>. The 5 parallel permutation stages in between the separation stages are marked as P<sub>1 </sub>to P<sub>5</sub>. Each separation stage corresponds to a single layer-swapping iteration. However, each of the linking parallel permutation stages may contain from 1 to 4 layer-swapping iterations for the case of 4 variables. Thus, the optimization goal is to detect a separation ordering that minimizes the number of iterations required by the parallel permutation stages, as this corresponds to a parallelly optimum layer-swapping schedule. As described above, the layer-swapping schedule illustrated in <figref idref="DRAWINGS">FIGS. 12A-12B</figref> is the optimum schedule for BDDs with 4 variables. Thus, in particular embodiments, this schedule may be applied to BDDs with 4 variables to determine the separation ordering that minimizes the number of iterations required by the parallel permutation stages.</p>
<p id="p-0159" num="0158">In particular embodiments, this optimization may be performed offline, once for each specific value of n. Particular embodiments may use an exhaustive approach to detect the optimum separation orderings. Nevertheless, if n is large enough such that an exhaustive approach is not applicable or practical, then alternatively, particular embodiments may start with any separation order and subsequently independently move each separation to the left or to the right until its locally optimum position is detected. Each parallel permutation stage requires at most n iterations. Therefore, each separation ordering corresponds to a layer-swapping schedule that spans at most</p>
<p id="p-0160" num="0159">
<maths id="MATH-US-00019" num="00019">
<math overflow="scroll">
<mrow>
  <mrow>
    <mo>(</mo>
    <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
    </mrow>
    <mo>)</mo>
  </mrow>
  <mo>&#xd7;</mo>
  <mfrac>
    <mrow>
      <mi>n</mi>
      <mo>!</mo>
    </mrow>
    <msup>
      <mn>2</mn>
      <mrow>
        <mi>n</mi>
        <mo>/</mo>
        <mn>2</mn>
      </mrow>
    </msup>
  </mfrac>
  <mo>&#x2062;</mo>
  <mstyle>
    <mspace width="0.8em" height="0.8ex"/>
  </mstyle>
  <mo>&#x2062;</mo>
  <mrow>
    <mo>(</mo>
    <mrow>
      <mrow>
        <mi>i</mi>
        <mo>.</mo>
        <mi>e</mi>
        <mo>.</mo>
      </mrow>
      <mo>,</mo>
      <mstyle>
        <mspace width="0.8em" height="0.8ex"/>
      </mstyle>
      <mo>&#x2062;</mo>
      <mfrac>
        <mrow>
          <mrow>
            <mo>(</mo>
            <mrow>
              <mi>n</mi>
              <mo>+</mo>
              <mn>1</mn>
            </mrow>
            <mo>)</mo>
          </mrow>
          <mo>!</mo>
        </mrow>
        <msup>
          <mn>2</mn>
          <mrow>
            <mo>&#x230a;</mo>
            <mrow>
              <mi>n</mi>
              <mo>/</mo>
              <mn>2</mn>
            </mrow>
            <mo>&#x230b;</mo>
          </mrow>
        </msup>
      </mfrac>
    </mrow>
    <mo>)</mo>
  </mrow>
</mrow>
</math>
</maths>
<br/>
iterations. As the Plain Changes Algorithm requires n!&#x2212;1 iterations, or at least n!&#x2212;(n&#x2212;1)! iterations in the parallel case, the process illustrated in <figref idref="DRAWINGS">FIG. 13A</figref> requires exponentially fewer layer-swapping iterations and thus layer swaps. In practice, the optimum separation ordering in fact requires significantly fewer iterations than
</p>
<p id="p-0161" num="0160">
<maths id="MATH-US-00020" num="00020">
<math overflow="scroll">
<mfrac>
  <mrow>
    <mrow>
      <mo>(</mo>
      <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
      </mrow>
      <mo>)</mo>
    </mrow>
    <mo>!</mo>
  </mrow>
  <msup>
    <mn>2</mn>
    <mrow>
      <mo>&#x230a;</mo>
      <mrow>
        <mi>n</mi>
        <mo>/</mo>
        <mn>2</mn>
      </mrow>
      <mo>&#x230b;</mo>
    </mrow>
  </msup>
</mfrac>
</math>
</maths>
<br/>
as may be seen from the example cases.
</p>
<p id="p-0162" num="0161">Recursive Separation of BDD Variables</p>
<p id="p-0163" num="0162">In particular embodiments, given any BDD having n, where n is any integer, even or odd, that is greater than or equal to 3, the n variables may be separated into</p>
<p id="p-0164" num="0163">
<maths id="MATH-US-00021" num="00021">
<math overflow="scroll">
<mfrac>
  <mrow>
    <mi>n</mi>
    <mo>!</mo>
  </mrow>
  <msup>
    <mn>2</mn>
    <mrow>
      <mo>&#x230a;</mo>
      <mrow>
        <mi>n</mi>
        <mo>/</mo>
        <mn>2</mn>
      </mrow>
      <mo>&#x230b;</mo>
    </mrow>
  </msup>
</mfrac>
</math>
</maths>
<br/>
unique groups, each consisting of
</p>
<p id="p-0165" num="0164">
<maths id="MATH-US-00022" num="00022">
<math overflow="scroll">
<mrow>
  <mo>&#x2308;</mo>
  <mfrac>
    <mi>n</mi>
    <mn>2</mn>
  </mfrac>
  <mo>&#x2309;</mo>
</mrow>
</math>
</maths>
<br/>
ordered sets. Again, when n is even, all the sets in each group each have two of the n variables. When n is odd, all the sets except one set in each group each have two of the n variables, and one set in each group has one of the n variables. Again, the variable order within each set is irrelevant, while set order within each group is relevant. In particular embodiments, in the more specific case where n is a power of 2 (i.e., n may is repeatedly divisible by 2), the n variables may be separated into the
</p>
<p id="p-0166" num="0165">
<maths id="MATH-US-00023" num="00023">
<math overflow="scroll">
<mfrac>
  <mrow>
    <mi>n</mi>
    <mo>!</mo>
  </mrow>
  <msup>
    <mn>2</mn>
    <mrow>
      <mi>n</mi>
      <mo>/</mo>
      <mn>2</mn>
    </mrow>
  </msup>
</mfrac>
</math>
</maths>
<br/>
groups of n/2 ordered sets of 2 variables using a recursive algorithm. More specifically, given a set of n variables, during the first iteration, particular embodiments may separate the set into unique groups of 2 ordered sets of variables, where each set has n/2 variables. During the second iteration, particular embodiments may further separate each individual set within each individual group into 2 more ordered sets of variables, thus forming additional groups of 4 ordered sets of variables, where each set has n/4 variables. And so on. During each iteration, the new groups constructed by separating the individual sets from the existing groups replace the existing groups obtained from the previous iteration. The recursive process may continue until each set within each group has n/2 ordered sets of 2 variables.
</p>
<p id="p-0167" num="0166">Note that since the optimum variable order of a BDD having 4 variables may be determined efficiently using, for example, the optimum layer-swapping schedules described in <figref idref="DRAWINGS">FIGS. 12A-12C</figref>, in practice, the recursive process may continue until each set within each group has 4 variables. Then, the process described above in connection with <figref idref="DRAWINGS">FIGS. 12A-12C</figref> may be used to determine a locally optimum variable order for each set of 4 variables.</p>
<p id="p-0168" num="0167"><figref idref="DRAWINGS">FIG. 14A</figref> illustrates an example of the recursive process used to separate n variables. <figref idref="DRAWINGS">FIG. 14B</figref> illustrates the recursive process as applied to 8 variables. Using n=8 as an example. During the first iteration, the 8 variables may be separated into a number of unique groups, where each group consists of 2 ordered sets, and each set consists of 4 variables. For example, after the first iterations, some of the groups may be:</p>
<p id="p-0169" num="0168">group 1: {1, 2, 3, 4} {5, 6, 7, 8}</p>
<p id="p-0170" num="0169">group 2: {1, 2, 3, 5} {4, 6, 7, 8}</p>
<p id="p-0171" num="0170">group 3: {1, 2, 3, 6} {4, 5, 7, 8}</p>
<p id="p-0172" num="0171">. . . .</p>
<p id="p-0173" num="0172">There are two many groups to list all in this disclosure. During the second iteration, within each group, each set of 4 variables are again separated into a number of unique groups, where each group consists of 2 ordered sets, and each set consists of 2 variables. For example, after the second iterations, set {1, 2, 3, 4} may form 6 groups of 2 sets of 2 variables. Similarly set {5, 6, 7, 8} may form another 6 groups of 2 sets of 2 variables each. Set {1, 2, 3, 5} may form yet another 6 groups of 2 sets of 2 variables each. And so on.</p>
<p id="p-0174" num="0173">After the second iteration, each set within each group has 2 variables. Thus, the recursion may end. If n is a number greater than 8, then more iterations are needed. After the last iteration, in <figref idref="DRAWINGS">FIG. 14B</figref>, the sets of variables along each row form a unique group of 4 ordered sets of 2 variables, and each group may provide a unique variable order for a BDD of 8 variables. The optimum variable order of the BDD may be determined using a process similar to that described in connection with <figref idref="DRAWINGS">FIG. 13A</figref>. More specifically, particular embodiments may determine a locally optimum variable order within each group using the implicit enumeration concept, and then determine the optimum variable order for the BDD by selecting the locally optimum variable order that yields the smallest size among all the locally optimum variables corresponding to all the groups.</p>
<p id="p-0175" num="0174">To summarize, in particular embodiments, given a set of n variables, where n may be any integer, odd or even, that is greater than 2, the existing set may be separated into two new sets of variables, with one set having</p>
<p id="p-0176" num="0175">
<maths id="MATH-US-00024" num="00024">
<math overflow="scroll">
<mrow>
  <mo>&#x230a;</mo>
  <mfrac>
    <mi>n</mi>
    <mn>2</mn>
  </mfrac>
  <mo>&#x230b;</mo>
</mrow>
</math>
</maths>
<br/>
of the n variables and the other set having
</p>
<p id="p-0177" num="0176">
<maths id="MATH-US-00025" num="00025">
<math overflow="scroll">
<mrow>
  <mo>&#x2308;</mo>
  <mfrac>
    <mi>n</mi>
    <mn>2</mn>
  </mfrac>
  <mo>&#x2309;</mo>
</mrow>
</math>
</maths>
<br/>
of the n variables. Each of the n variables belongs to either one or the other, but not both, of the two new sets. Note that when n is even, the two new sets have the same number of variables. When n is odd, the two new sets differ by one variable. This method of separating an existing set of variables into two new sets of variables may be similarly applied to each set of variables in each group during each iteration of the recursive process illustrated in <figref idref="DRAWINGS">FIG. 14A</figref>.
</p>
<p id="p-0178" num="0177">In general, to separate n variables into two ordered sets, each having either</p>
<p id="p-0179" num="0178">
<maths id="MATH-US-00026" num="00026">
<math overflow="scroll">
<mrow>
  <mrow>
    <mo>&#x230a;</mo>
    <mfrac>
      <mi>n</mi>
      <mn>2</mn>
    </mfrac>
    <mo>&#x230b;</mo>
  </mrow>
  <mo>&#x2062;</mo>
  <mstyle>
    <mspace width="0.8em" height="0.8ex"/>
  </mstyle>
  <mo>&#x2062;</mo>
  <mi>or</mi>
  <mo>&#x2062;</mo>
  <mrow>
    <mstyle>
      <mspace width="0.6em" height="0.6ex"/>
    </mstyle>
    <mo>&#x2062;</mo>
    <mstyle>
      <mspace width="0.3em" height="0.3ex"/>
    </mstyle>
  </mrow>
  <mo>&#x2062;</mo>
  <mrow>
    <mo>&#x2308;</mo>
    <mfrac>
      <mi>n</mi>
      <mn>2</mn>
    </mfrac>
    <mo>&#x2309;</mo>
  </mrow>
</mrow>
</math>
</maths>
<br/>
variables, there exist
</p>
<p id="p-0180" num="0179">
<maths id="MATH-US-00027" num="00027">
<math overflow="scroll">
<mrow>
  <mrow>
    <mo>(</mo>
    <mtable>
      <mtr>
        <mtd>
          <mi>n</mi>
        </mtd>
      </mtr>
      <mtr>
        <mtd>
          <mrow>
            <mi>n</mi>
            <mo>/</mo>
            <mn>2</mn>
          </mrow>
        </mtd>
      </mtr>
    </mtable>
    <mo>)</mo>
  </mrow>
  <mo>=</mo>
  <mfrac>
    <mrow>
      <mi>n</mi>
      <mo>!</mo>
    </mrow>
    <msup>
      <mrow>
        <mrow>
          <mo>(</mo>
          <mfrac>
            <mi>n</mi>
            <mn>2</mn>
          </mfrac>
          <mo>)</mo>
        </mrow>
        <mo>!</mo>
      </mrow>
      <mn>2</mn>
    </msup>
  </mfrac>
</mrow>
</math>
</maths>
<br/>
unique groups (i.e., there are
</p>
<p id="p-0181" num="0180">
<maths id="MATH-US-00028" num="00028">
<math overflow="scroll">
<mfrac>
  <mrow>
    <mi>n</mi>
    <mo>!</mo>
  </mrow>
  <msup>
    <mrow>
      <mrow>
        <mo>(</mo>
        <mfrac>
          <mi>n</mi>
          <mn>2</mn>
        </mfrac>
        <mo>)</mo>
      </mrow>
      <mo>!</mo>
    </mrow>
    <mn>2</mn>
  </msup>
</mfrac>
</math>
</maths>
<br/>
different ways to separate the n variables thus), each consisting of 2 ordered sets of
</p>
<p id="p-0182" num="0181">
<maths id="MATH-US-00029" num="00029">
<math overflow="scroll">
<mrow>
  <mrow>
    <mo>&#x230a;</mo>
    <mfrac>
      <mi>n</mi>
      <mn>2</mn>
    </mfrac>
    <mo>&#x230b;</mo>
  </mrow>
  <mo>&#x2062;</mo>
  <mstyle>
    <mspace width="0.8em" height="0.8ex"/>
  </mstyle>
  <mo>&#x2062;</mo>
  <mi>or</mi>
  <mo>&#x2062;</mo>
  <mrow>
    <mstyle>
      <mspace width="0.6em" height="0.6ex"/>
    </mstyle>
    <mo>&#x2062;</mo>
    <mstyle>
      <mspace width="0.3em" height="0.3ex"/>
    </mstyle>
  </mrow>
  <mo>&#x2062;</mo>
  <mrow>
    <mo>&#x2308;</mo>
    <mfrac>
      <mi>n</mi>
      <mn>2</mn>
    </mfrac>
    <mo>&#x2309;</mo>
  </mrow>
</mrow>
</math>
</maths>
<br/>
variables. The recursion continues until the n variables are separated into multiple unique groups (i.e. separation), where each group includes
</p>
<p id="p-0183" num="0182">
<maths id="MATH-US-00030" num="00030">
<math overflow="scroll">
<mrow>
  <mo>&#x2308;</mo>
  <mfrac>
    <mi>n</mi>
    <mn>2</mn>
  </mfrac>
  <mo>&#x2309;</mo>
</mrow>
</math>
</maths>
<br/>
ordered sets of 2 variables or 1 variable. That is, the algorithm is recursively executed on each subset of
</p>
<p id="p-0184" num="0183">
<maths id="MATH-US-00031" num="00031">
<math overflow="scroll">
<mrow>
  <mrow>
    <mo>&#x230a;</mo>
    <mfrac>
      <mi>n</mi>
      <mn>2</mn>
    </mfrac>
    <mo>&#x230b;</mo>
  </mrow>
  <mo>&#x2062;</mo>
  <mstyle>
    <mspace width="0.8em" height="0.8ex"/>
  </mstyle>
  <mo>&#x2062;</mo>
  <mi>or</mi>
  <mo>&#x2062;</mo>
  <mrow>
    <mstyle>
      <mspace width="0.6em" height="0.6ex"/>
    </mstyle>
    <mo>&#x2062;</mo>
    <mstyle>
      <mspace width="0.3em" height="0.3ex"/>
    </mstyle>
  </mrow>
  <mo>&#x2062;</mo>
  <mrow>
    <mo>&#x2308;</mo>
    <mfrac>
      <mi>n</mi>
      <mn>2</mn>
    </mfrac>
    <mo>&#x2309;</mo>
  </mrow>
</mrow>
</math>
</maths>
<br/>
variables until each subset has 2 variables or 1 variable. Within each group, each variable appears only once in one of the sets.
</p>
<p id="p-0185" num="0184">As described above, the optimum variable order of a BDD having 4 variables may be determined using, for example, any of the algorithms illustrated in <figref idref="DRAWINGS">FIGS. 12A-12Z</figref>. Thus, in particular embodiments, the recursion to separate n variables may continue until each set in each group has 4 variables or less. Then the locally optimum variable order of each set in each group may be determined using, for example, any of the algorithms illustrated in <figref idref="DRAWINGS">FIGS. 12A-12Z</figref>. For each group, its locally optimum variable order may be determined using the locally optimum variable orders of the individual sets in that group. Then for the BDD, its optimum variable order may be determined using the locally optimum variable orders of the individual groups.</p>
<p id="p-0186" num="0185">For the case of n=5 (i.e., 5 variables), based on the method of separating n variables described above, in particular embodiments, the 5 variables may be separated into groups of 2 ordered sets, where within each group, one set has 2 variables and one set has 3 variables. The optimum variable order of 5 variables may then be determined using such groups. However, in particular embodiments, experiments suggest that it may be more efficient to separate the 5 variables into groups of 2 ordered sets, where within each group, one set has 4 variables and one set has 1 variable. The locally optimum variable order of each 4-variable set in each group may be determined using, for example, any of the algorithms illustrated in <figref idref="DRAWINGS">FIGS. 12A-12Z</figref>. For each group, its locally optimum variable order may be determined using the locally optimum variable order of the 4-variable set in that group. The optimum variable order for the case of 5 variables may be determined using the locally optimum variable orders of the individual groups.</p>
<p id="p-0187" num="0186">In particular embodiments, the recursion to separate n variables may continue until each set in each group has 5 variables or less. Then the locally optimum variable order for each 4-variable set in each group may be determined using, for example, any of the algorithms illustrated in <figref idref="DRAWINGS">FIGS. 12A-12Z</figref>. The locally optimum variable order of each 5-variable set in each group may be determined using the method described above for the 5-variable case. For each group, its locally optimum variable order may be determined using the locally optimum variable orders of the individual sets in that group. Then for the BDD, its optimum variable order may be determined using the locally optimum variable orders of the individual groups.</p>
<p id="p-0188" num="0187">In particular embodiments, the concept may be further generalized as the following. The recursion to separate n variables may continue until each set in each group has k variables or less, where 1&#x2266;k&#x3c;n. In particular embodiments, k may be predefined (e.g., k may be 2, 3, 4, or 5). The locally optimum variable order of each set in each group may be determined using any appropriate algorithm. The locally optimum variable order of each group may be determined using the locally optimum variable orders of the individual sets in that group. And the optimum variable of the BDD may be determined using the locally optimum variable orders of the individual groups.</p>
<p id="p-0189" num="0188">In particular embodiments, the separation stages are ordered and linked with parallel permutation stages in a similar fashion as described above in connection with <figref idref="DRAWINGS">FIGS. 13A-13B</figref> for the four-variable case. It may be shown that the required iterations are obtained by the recursion</p>
<p id="p-0190" num="0189">
<maths id="MATH-US-00032" num="00032">
<math overflow="scroll">
<mrow>
  <mrow>
    <mrow>
      <mi>L</mi>
      <mo>&#x2061;</mo>
      <mrow>
        <mo>(</mo>
        <mi>n</mi>
        <mo>)</mo>
      </mrow>
    </mrow>
    <mo>&#x2264;</mo>
    <mrow>
      <mrow>
        <mo>(</mo>
        <mtable>
          <mtr>
            <mtd>
              <mi>n</mi>
            </mtd>
          </mtr>
          <mtr>
            <mtd>
              <mrow>
                <mi>n</mi>
                <mo>/</mo>
                <mn>2</mn>
              </mrow>
            </mtd>
          </mtr>
        </mtable>
        <mo>)</mo>
      </mrow>
      <mo>&#xd7;</mo>
      <mrow>
        <mo>(</mo>
        <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mrow>
            <mi>L</mi>
            <mo>&#x2061;</mo>
            <mrow>
              <mo>(</mo>
              <mrow>
                <mi>n</mi>
                <mo>/</mo>
                <mn>2</mn>
              </mrow>
              <mo>)</mo>
            </mrow>
          </mrow>
        </mrow>
        <mo>)</mo>
      </mrow>
    </mrow>
    <mo>&#x2264;</mo>
    <msup>
      <mn>4</mn>
      <mi>n</mi>
    </msup>
  </mrow>
  <mo>,</mo>
</mrow>
</math>
</maths>
<br/>
which is an improvement upon the required iterations of the existing exact algorithm.
</p>
<p id="p-0191" num="0190">Comparing this recursive algorithm for separating the n variables with the non-recursive algorithm described above in connection with <figref idref="DRAWINGS">FIGS. 13A-13B</figref>, the recursive algorithm requires at most 4<sup>n </sup>iterations of layer swapping to determine the optimum variable order for a BDD having n variables, while the non-recursive algorithm requires at most</p>
<p id="p-0192" num="0191">
<maths id="MATH-US-00033" num="00033">
<math overflow="scroll">
<mfrac>
  <mrow>
    <mrow>
      <mo>(</mo>
      <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
      </mrow>
      <mo>)</mo>
    </mrow>
    <mo>!</mo>
  </mrow>
  <msup>
    <mn>2</mn>
    <mrow>
      <mi>n</mi>
      <mo>/</mo>
      <mn>2</mn>
    </mrow>
  </msup>
</mfrac>
</math>
</maths>
<br/>
iterations of layer swapping to determine the optimum variable order for a BDD having n variables. For n greater than 4, the recursive algorithm is more efficient.
</p>
<p id="p-0193" num="0192">Parallel Window Algorithm</p>
<p id="p-0194" num="0193">The Window Algorithm described in connection with <figref idref="DRAWINGS">FIG. 8</figref> provides that, for a BDD that represents a function having n variables, a &#x201c;window&#x201d; of size k may be selected, where 2&#x2266;k&#x3c;n. The algorithm iteratively and sequentially detects the optimum ordering of layers [1 . . . k], [2 . . . k+1], [3 . . . k+2] . . . [n&#x2212;k+1 . . . n]. The existing Window Algorithm uses the Plain Changes Algorithm to reorder the variables within each window according to its local optimum order.</p>
<p id="p-0195" num="0194">In particular embodiments, the existing Window Algorithm may be improved with parallelization. Particular embodiments select a window size of k (e.g., k=4). A window then consists of k consecutive layers. Then, within each window, the locally optimum variable order for the k variables at the k consecutive layers may be determined, and the k variables may be reordered according to its locally optimum variable order or locally substantial optimum variable order using any suitable BDD variable reordering algorithm. Further more, multiple disjoint windows of k consecutive layers may be processed in parallel. Two windows are disjoint if they do not share a common layer.</p>
<p id="p-0196" num="0195">In particular embodiments, for a BDD having n layers corresponding to n variables, with a window of size k (e.g., k=4), during each iteration, the n layers may be grouped into at most</p>
<p id="p-0197" num="0196">
<maths id="MATH-US-00034" num="00034">
<math overflow="scroll">
<mrow>
  <mrow>
    <mo>&#x230a;</mo>
    <mfrac>
      <mi>n</mi>
      <mi>k</mi>
    </mfrac>
    <mo>&#x230b;</mo>
  </mrow>
  <mo>&#x2062;</mo>
  <mstyle>
    <mspace width="0.8em" height="0.8ex"/>
  </mstyle>
</mrow>
</math>
</maths>
<br/>
disjoint windows (e.g., if k=4, then window 1 includes layers 1 to 4; window 2 includes layers 5 to 8; window 3 includes layers 9 to 12; and so on). The
</p>
<p id="p-0198" num="0197">
<maths id="MATH-US-00035" num="00035">
<math overflow="scroll">
<mrow>
  <mrow>
    <mo>&#x230a;</mo>
    <mfrac>
      <mi>n</mi>
      <mi>k</mi>
    </mfrac>
    <mo>&#x230b;</mo>
  </mrow>
  <mo>&#x2062;</mo>
  <mstyle>
    <mspace width="0.6em" height="0.6ex"/>
  </mstyle>
</mrow>
</math>
</maths>
<br/>
disjoint windows may be reordered in parallel, each using a suitable BDD variable reordering algorithm (e.g., the Plain Changes Algorithm or any of the algorithms described above that determines the optimum variable order for a set of variables). For example, if k=4, then to find a local optimum variable order for each window, a variable reordering algorithm based the Optimum Layer-Swapping Schedule for BDDs with four variables may be used.
</p>
<p id="p-0199" num="0198">Between different iterations, the n layers may be grouped differently. In particular embodiments, for example, if n is divisible by 4, then during the first iteration, the windows are: layers {1 . . . 4}, layers {5 . . . 8}, . . . , layers {n&#x2212;3 . . . n}. During the second iteration, the windows are: layers {2 . . . 5}, layers {6 . . . 9}, . . . , layers {n&#x2212;6 . . . n&#x2212;3}. During the third iteration, the windows are: layers {3 . . . 6}, layers {7 . . . 10}, . . . , layers {n&#x2212;5 . . . n&#x2212;2}. During the fourth iteration, the windows are: layers {4 . . . 7}, layers {8 . . . 11} layers {n&#x2212;4 . . . n&#x2212;1}. The windows of the fifth, sixth, seventh, and eighth iterations are the same as the windows of the first, second, third, and fourth iterations, and so on. The process may continue until convergence (e.g., until the total size of the BDD is smaller than a desired or predefined threshold, or until further adjustment of the variable positions no longer significantly reduces the total size of the BDD).</p>
<p id="p-0200" num="0199"><figref idref="DRAWINGS">FIG. 15A</figref> illustrates an example of the Parallel Window Reordering Algorithm. <figref idref="DRAWINGS">FIG. 15B</figref> illustrates the Parallel Window Reordering Algorithm using an example window of size 4 as applied to an example BDD <b>1500</b> having twelve layers corresponding to twelve variables. The steps of <figref idref="DRAWINGS">FIG. 15A</figref> is described using BDD <b>1500</b> as an example. During the first iteration (i.e., t=1), the twelve layers are separated into three disjoint sets of four consecutive layers, as illustrated in step <b>1502</b> of <figref idref="DRAWINGS">FIG. 15A</figref>. Thus, the windows are: layers {1 . . . 4}, layers {5 . . . 8}, and layers {9 . . . 12}. The three windows may be reordered in parallel, as illustrated in step <b>1504</b> of <figref idref="DRAWINGS">FIG. 15A</figref>, each using the Optimum Reordering Algorithm for BDDs with four variables or any other suitable variable reordering algorithms. After all the windows have been reordered, the current size of BDD <b>1500</b> is determined. If the current size of BDD <b>1500</b> is less than a desired threshold, then the process may end, as illustrated in step <b>1506</b> of <figref idref="DRAWINGS">FIG. 15A</figref>. Otherwise, another iteration may be performed. For example, during the second iteration (i.e., t=2), the twelve layers are separated into two disjoint sets of four consecutive layers. Thus, the windows are: layers {2 . . . 5}, and layers {6 . . . 9}. The two windows may be similarly reordered in parallel. During the third iteration (i.e., t=3), the windows are: layers {3 . . . 6}, and layers {7 . . . 10}, and the two windows may be similarly reordered in parallel. During the fourth iteration (i.e., t=4), the windows are: layers {4 . . . 7}, and layers {8 . . . 11}, and the two windows may be similarly reordered in parallel. During fifth iteration, the grouping may move back up starting from layer 1 again, similar as during the first iteration. And so on, until a desired variable order is obtained (e.g., the size of the BDD is sufficient small).</p>
<p id="p-0201" num="0200">In particular embodiments, during each iteration, the n layers of a BDD are separated into multiple disjoint sets of k consecutive layers. However, the disjoint sets of k consecutive layers constructed during each iteration differ from the disjoint sets of k consecutive layers constructed during a previous iteration that immediately precedes the current iteration. As a result, the n layers are separated and grouped differently during each iterations, as illustrated in <figref idref="DRAWINGS">FIG. 15B</figref>.</p>
<p id="p-0202" num="0201">In practical applications, windows of size 4 or less are most commonly used. However, the above process illustrated in <figref idref="DRAWINGS">FIG. 15B</figref> may be extended to apply to windows of any size (e.g., size k). In the general case, with a window size of k, particular embodiments may apply the corresponding exact reordering algorithm on layers [a&#xd7;k+1+b, (a+1)&#xd7;k+b], alternating between iterating on a where (a+1)&#xd7;k+b&#x2267;n and on b where b&#x3b5;[0, k&#x2212;1]. Swaps may again be performed until convergence.</p>
<p id="p-0203" num="0202">Window Algorithm Using Maximal Parallelization</p>
<p id="p-0204" num="0203">In addition to reorder the variables within multiple windows in parallel, as described above in connection with <figref idref="DRAWINGS">FIG. 15B</figref>, within each window, the reordering of the k variables at the k consecutive layers may utilize the maximum parallelization concept as described above in connection with <figref idref="DRAWINGS">FIG. 9</figref>.</p>
<p id="p-0205" num="0204"><figref idref="DRAWINGS">FIG. 16</figref> illustrates an example of reordering the variables at the k consecutive layers within a single window, using an example window size of 6. In particular embodiments, during each odd iteration, the k layers are grouped into odd-grouping disjoint pairs of consecutive layers and during each even iteration, the k layers are grouped into even-grouping disjoint pairs of consecutive layers, or vice versa. During each iteration, all the disjoint pairs of consecutive layers are swapped concurrently. This algorithm maintains the structure of the Windowing Algorithm. For a given k, the algorithm performs all layer swaps required to move its k inputs in the inverse permutation. Note the structural similarity with the Parallel Permutation Algorithm. In this case, however, all layer swaps are unconditionally executed during each iteration. Moreover, during each iteration, the sizes of all implicitly discovered permutations are computed. The permutation of the smallest size is kept (e.g., recorded). After the completion of all layer swaps on the k layers, the Parallel Permutation Algorithm may be utilized to return the k layers to the permutation of the smallest size. Again, particular embodiments may repeat the process, where the layers are grouped differently during different iterations, until the BDD has reached a desired size.</p>
<p id="p-0206" num="0205">Parallel Sifting Algorithm</p>
<p id="p-0207" num="0206">The main disadvantage of the Sifting Algorithm described above in connection with <figref idref="DRAWINGS">FIG. 7</figref> is that it is inherently sequential. The variables of a BDD are ordered according to the sizes of the layers on which they reside. To alleviate this disadvantage of the Sifting Algorithm, particular embodiments concurrently sift (i.e., moves) k variables, instead of sifting one variable at a time. However, each of the k variables may be sifted in the manner similar to that described in <figref idref="DRAWINGS">FIG. 7</figref>. In particular embodiments, given a BDD having n layers corresponding to n variables, the n variables may be moved to their optimum layers using an iterative process. During each iteration, the k variables at the k layers that currently have the largest sizes during the current iteration may be sifted to their locally optimum layers (i.e., positions). For each set of k variables, sifting is performed on the k variables concurrently. For example, the k variables at the k largest layers are sifted concurrently first, followed by the k variables at the second k largest layers, and so on. After each iteration of concurrent layer swaps, the size of all implicitly the generated permutations is computed. When sifting has been performed for all the variables in a set, the Parallel Permutation Algorithm is utilized to return the ordering to the one that is locally minimum. The algorithm continues for all sets of variables and may be repeated until convergence.</p>
<p id="p-0208" num="0207"><figref idref="DRAWINGS">FIG. 17A</figref> illustrates an example of the Parallel Sifting Algorithm. In particular embodiments, during the first iteration, k layers that currently have the largest sizes among the n layers of a BDD are selected, as illustrated in step <b>1702</b> of <figref idref="DRAWINGS">FIG. 17A</figref>. The k variables currently positioned at the selected k layers are sifted concurrently during this iteration. The k variables are moved to their respective locally optimum layers in parallel, as illustrated in step <b>1704</b> of <figref idref="DRAWINGS">FIG. 17B</figref>. To do so, each of the k variables may be sifted to its locally optima layer using the process described above in connection with <figref idref="DRAWINGS">FIG. 7</figref>. For example, each variable may be moved through the n layers in order to determine the layer that currently yields the smallest size among the n layers with the variable. This layer is the locally optimum layer of the variable during the current iteration. However, particular embodiments sift the k variables in parallel. After all k variables are positioned at their locally optimum layer, the current size of the BDD is determined. If the current size of the BDD is less than a desired threshold, then the process may end, as illustrated in step <b>1706</b> of <figref idref="DRAWINGS">FIG. 17A</figref>. Otherwise, another iteration may be repeated, which consists of performing steps <b>1702</b> and <b>1704</b> again.</p>
<p id="p-0209" num="0208"><figref idref="DRAWINGS">FIG. 17B</figref> illustrates the Parallel Sifting Algorithm as applied to an example BDD <b>1700</b> where three variables are sifted in parallel. Suppose there are 9 variables and variables 2, 5, and 8 are the three variables at the three layers that currently have the largest sizes. Variable 2, 5, and 8 may be moved to their locally optimum positions using concurrent layer swapping in an iterative process. During each iteration variables 2, 5, and 8 may be sifted in parallel, as long as swapping the pairs of consecutive layers do not affect each other. More specifically, variable 2 may traverse upward until it reaches layer 1, and then downward until it reaches layer 9, which is the last layer of BDD <b>1700</b>. Variable 5 may traverse upward first until it reaches layer 1, and then traverse downward until it reaches layer 9. Variable 8 traverses downward until it reaches layer 9, and then upward until it reaches layer 1. Although some of the variables may take more iterations to traverse through all the layers, and during some of the iterations, sifting one variable may affect sifting another variable (e.g., during the sixth iteration, variable 2 cannot be sifted because sifting variable 8 interferes with sifting variable 2), during most of the iterations, the three variables may be effectively parallelized (i.e., sifted concurrently by concurrently swapping three disjoint pairs of consecutive layers).</p>
<p id="p-0210" num="0209">As each variable traverses among the 9 layers, when the variable is at each layer, the size of that layer may be determined. Thus, for variable 2, there are 9 sizes determined when variable 2 is at the 9 layers respectively. The layer that has the smallest size among the 9 sizes is the locally optimum layer for variable 2. Similarly, for variable 5, there are again 9 sizes determined when variable 5 is at the 9 layers respectively. The layer that has the smallest size among the second 9 sizes is the locally optimum layer for variable 5. Thus, for a given variable, the layer that yields the smallest size among all the layers when the variable is position at each of the layers is the locally optimum layer for that variable during the current iteration.</p>
<p id="p-0211" num="0210">If the size of the BDD is not sufficiently small, then another three variables positioned at the three layers that currently have the largest sizes may be selected. The three variables may be moved to their locally optimum positions using the same process as described above with variables 2, 5, and 8.</p>
<p id="p-0212" num="0211">BDDs have many practical applications, and the various algorithms disclosed in the present disclosure may be used with BDDs of any applications. For example, in the field of integrated circuit (IC) design, an IC may be used to implement a function, which may be represented by a BDD. Sometimes, a property that an IC design needs to satisfy may be represented by a BDD, which may then be used in connection with formally verifying the design of the circuit. In the field of healthcare, BDDs may be used to represent data collected by medical sensors. In the field of formal verification, BDDs may be used to model transition relations or reachable state spaces along with their respective properties. In the context of hardware and software systems, formal verification is the act of proving or disproving the correctness of intended algorithms underlying a system with respect to a certain formal specification or property, using formal methods of mathematics. The verification of these hardware and software systems is done by providing a formal proof on an abstract mathematical model of a system, the correspondence between the mathematical model and the nature of the system being otherwise known by construction. Examples of mathematical objects often used to model systems are: finite state machines, labeled transition systems, Petri nets, timed automata, hybrid automata, process algebra, formal semantics of programming languages such as operational semantics, denotation semantics, axiomatic semantics and Hoare logic.</p>
<p id="p-0213" num="0212">A BDD, or more specifically, the data that form the BDD, may be stored in a computer-readable non-transitory storage medium. When the variables of the BDD are reordered using any of the algorithms described in this disclosure, the data are transformed as embodied by the computer-readable non-transitory storage medium.</p>
<p id="p-0214" num="0213">In particular embodiments, any set of integers may be represented as a Boolean function, and the Boolean function may be represented by a BDD. Given a set of integers, particular embodiments may determine the minimum number of bits required to represent the largest integer in the set. This number of bits is the number of variables of the Boolean function. Then, for each integer in the set, the Boolean function evaluates to TRUE, and for any integer not in the set, the Boolean function evaluates to FALSE.</p>
<p id="p-0215" num="0214">For example, consider a set of integers, {1, 3, 5, 6}. The largest integer in the set is 6, which requires 3 bits. Thus, the Boolean function used to represent this set of integers requires 3 variables, x<sub>1</sub>, x<sub>2</sub>, and x<sub>3</sub>. The following table illustrates the values of the 3 variables and the Boolean function as they are used to represent {1, 3, 5, 6}:</p>
<p id="p-0216" num="0215">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="84pt" align="center"/>
<colspec colname="2" colwidth="35pt" align="center"/>
<colspec colname="3" colwidth="98pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
<row>
<entry/>
<entry>Binary</entry>
<entry/>
</row>
<row>
<entry>Decimal</entry>
<entry>Value</entry>
</row>
<row>
<entry>Value</entry>
<entry>x<sub>1</sub>, x<sub>2</sub>, x<sub>3</sub></entry>
<entry>f(x<sub>1</sub>, x<sub>2</sub>, x<sub>3</sub>)</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>0</entry>
<entry>0 0 0</entry>
<entry>0</entry>
</row>
<row>
<entry>1</entry>
<entry>0 0 1</entry>
<entry>1</entry>
</row>
<row>
<entry>2</entry>
<entry>0 1 0</entry>
<entry>0</entry>
</row>
<row>
<entry>3</entry>
<entry>0 1 1</entry>
<entry>1</entry>
</row>
<row>
<entry>4</entry>
<entry>1 0 0</entry>
<entry>0</entry>
</row>
<row>
<entry>5</entry>
<entry>1 0 1</entry>
<entry>1</entry>
</row>
<row>
<entry>6</entry>
<entry>1 1 0</entry>
<entry>1</entry>
</row>
<row>
<entry>7</entry>
<entry>1 1 1</entry>
<entry>0</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0217" num="0216">Particular embodiments may be implemented on one or more computer systems. <figref idref="DRAWINGS">FIG. 18</figref> illustrates an example computer system <b>1800</b>. In particular embodiments, one or more computer systems <b>1800</b> perform one or more steps of one or more methods described or illustrated herein. In particular embodiments, one or more computer systems <b>1800</b> provide functionality described or illustrated herein. In particular embodiments, software running on one or more computer systems <b>1800</b> performs one or more steps of one or more methods described or illustrated herein or provides functionality described or illustrated herein. Particular embodiments include one or more portions of one or more computer systems <b>1800</b>.</p>
<p id="p-0218" num="0217">This disclosure contemplates any suitable number of computer systems <b>1800</b>. This disclosure contemplates computer system <b>1800</b> taking any suitable physical form. As example and not by way of limitation, computer system <b>1800</b> may be an embedded computer system, a system-on-chip (SOC), a single-board computer system (SBC) (such as, for example, a computer-on-module (COM) or system-on-module (SOM)), a desktop computer system, a laptop or notebook computer system, an interactive kiosk, a mainframe, a mesh of computer systems, a mobile telephone, a personal digital assistant (PDA), a server, or a combination of two or more of these. Where appropriate, computer system <b>1800</b> may include one or more computer systems <b>1800</b>; be unitary or distributed; span multiple locations; span multiple machines; or reside in a cloud, which may include one or more cloud components in one or more networks. Where appropriate, one or more computer systems <b>1800</b> may perform without substantial spatial or temporal limitation one or more steps of one or more methods described or illustrated herein. As an example and not by way of limitation, one or more computer systems <b>1800</b> may perform in real time or in batch mode one or more steps of one or more methods described or illustrated herein. One or more computer systems <b>1800</b> may perform at different times or at different locations one or more steps of one or more methods described or illustrated herein, where appropriate.</p>
<p id="p-0219" num="0218">In particular embodiments, computer system <b>1800</b> includes a processor <b>1802</b>, memory <b>1804</b>, storage <b>1806</b>, an input/output (I/O) interface <b>1808</b>, a communication interface <b>1810</b>, and a bus <b>1812</b>. Although this disclosure describes and illustrates a particular computer system having a particular number of particular components in a particular arrangement, this disclosure contemplates any suitable computer system having any suitable number of any suitable components in any suitable arrangement.</p>
<p id="p-0220" num="0219">In particular embodiments, processor <b>1802</b> includes hardware for executing instructions, such as those making up a computer program. As an example and not by way of limitation, to execute instructions, processor <b>1802</b> may retrieve (or fetch) the instructions from an internal register, an internal cache, memory <b>1804</b>, or storage <b>1806</b>; decode and execute them; and then write one or more results to an internal register, an internal cache, memory <b>1804</b>, or storage <b>1806</b>. In particular embodiments, processor <b>1802</b> may include one or more internal caches for data, instructions, or addresses. The present disclosure contemplates processor <b>1802</b> including any suitable number of any suitable internal caches, where appropriate. As an example and not by way of limitation, processor <b>1802</b> may include one or more instruction caches, one or more data caches, and one or more translation lookaside buffers (TLBs). Instructions in the instruction caches may be copies of instructions in memory <b>1804</b> or storage <b>1806</b>, and the instruction caches may speed up retrieval of those instructions by processor <b>1802</b>. Data in the data caches may be copies of data in memory <b>1804</b> or storage <b>1806</b> for instructions executing at processor <b>1802</b> to operate on; the results of previous instructions executed at processor <b>1802</b> for access by subsequent instructions executing at processor <b>1802</b> or for writing to memory <b>1804</b> or storage <b>1806</b>; or other suitable data. The data caches may speed up read or write operations by processor <b>1802</b>. The TLBs may speed up virtual-address translation for processor <b>1802</b>. In particular embodiments, processor <b>1802</b> may include one or more internal registers for data, instructions, or addresses. The present disclosure contemplates processor <b>1802</b> including any suitable number of any suitable internal registers, where appropriate. Where appropriate, processor <b>1802</b> may include one or more arithmetic logic units (ALUs); be a multi-core processor; or include one or more processors <b>1802</b>. Although this disclosure describes and illustrates a particular processor, this disclosure contemplates any suitable processor.</p>
<p id="p-0221" num="0220">In particular embodiments, memory <b>1804</b> includes main memory for storing instructions for processor <b>1802</b> to execute or data for processor <b>1802</b> to operate on. As an example and not by way of limitation, computer system <b>1800</b> may load instructions from storage <b>1806</b> or another source (such as, for example, another computer system <b>1800</b>) to memory <b>1804</b>. Processor <b>1802</b> may then load the instructions from memory <b>1804</b> to an internal register or internal cache. To execute the instructions, processor <b>1802</b> may retrieve the instructions from the internal register or internal cache and decode them. During or after execution of the instructions, processor <b>1802</b> may write one or more results (which may be intermediate or final results) to the internal register or internal cache. Processor <b>1802</b> may then write one or more of those results to memory <b>1804</b>. In particular embodiments, processor <b>1802</b> executes only instructions in one or more internal registers or internal caches or in memory <b>1804</b> (as opposed to storage <b>1806</b> or elsewhere) and operates only on data in one or more internal registers or internal caches or in memory <b>1804</b> (as opposed to storage <b>1806</b> or elsewhere). One or more memory buses (which may each include an address bus and a data bus) may couple processor <b>1802</b> to memory <b>1804</b>. Bus <b>1812</b> may include one or more memory buses, as described below. In particular embodiments, one or more memory management units (MMUs) reside between processor <b>1802</b> and memory <b>1804</b> and facilitate accesses to memory <b>1804</b> requested by processor <b>1802</b>. In particular embodiments, memory <b>1804</b> includes random access memory (RAM). This RAM may be volatile memory, where appropriate Where appropriate, this RAM may be dynamic RAM (DRAM) or static RAM (SRAM). Moreover, where appropriate, this RAM may be single-ported or multi-ported RAM. The present disclosure contemplates any suitable RAM. Memory <b>1804</b> may include one or more memories <b>1804</b>, where appropriate. Although this disclosure describes and illustrates particular memory, this disclosure contemplates any suitable memory.</p>
<p id="p-0222" num="0221">In particular embodiments, storage <b>1806</b> includes mass storage for data or instructions. As an example and not by way of limitation, storage <b>1806</b> may include an HDD, a floppy disk drive, flash memory, an optical disc, a magneto-optical disc, magnetic tape, or a Universal Serial Bus (USB) drive or a combination of two or more of these. Storage <b>1806</b> may include removable or non-removable (or fixed) media, where appropriate. Storage <b>1806</b> may be internal or external to computer system <b>1800</b>, where appropriate. In particular embodiments, storage <b>1806</b> is non-volatile, solid-state memory. In particular embodiments, storage <b>1806</b> includes read-only memory (ROM). Where appropriate, this ROM may be mask-programmed ROM, programmable ROM (PROM), erasable PROM (EPROM), electrically erasable PROM (EEPROM), electrically alterable ROM (EAROM), or flash memory or a combination of two or more of these. This disclosure contemplates mass storage <b>1806</b> taking any suitable physical form. Storage <b>1806</b> may include one or more storage control units facilitating communication between processor <b>1802</b> and storage <b>1806</b>, where appropriate. Where appropriate, storage <b>1806</b> may include one or more storages <b>1806</b>. Although this disclosure describes and illustrates particular storage, this disclosure contemplates any suitable storage.</p>
<p id="p-0223" num="0222">In particular embodiments, I/O interface <b>1808</b> includes hardware, software, or both providing one or more interfaces for communication between computer system <b>1800</b> and one or more I/O devices. Computer system <b>1800</b> may include one or more of these I/O devices, where appropriate. One or more of these I/O devices may enable communication between a person and computer system <b>1800</b>. As an example and not by way of limitation, an I/O device may include a keyboard, keypad, microphone, monitor, mouse, printer, scanner, speaker, still camera, stylus, tablet, touch screen, trackball, video camera, another suitable I/O device or a combination of two or more of these. An I/O device may include one or more sensors. This disclosure contemplates any suitable I/O devices and any suitable I/O interfaces <b>1808</b> for them. Where appropriate, I/O interface <b>1808</b> may include one or more device or software drivers enabling processor <b>1802</b> to drive one or more of these I/O devices. I/O interface <b>1808</b> may include one or more I/O interfaces <b>1808</b>, where appropriate. Although this disclosure describes and illustrates a particular I/O interface, this disclosure contemplates any suitable I/O interface.</p>
<p id="p-0224" num="0223">In particular embodiments, communication interface <b>1810</b> includes hardware, software, or both providing one or more interfaces for communication (such as, for example, packet-based communication) between computer system <b>1800</b> and one or more other computer systems <b>1800</b> or one or more networks. As an example and not by way of limitation, communication interface <b>1810</b> may include a network interface controller (NIC) or network adapter for communicating with an Ethernet or other wire-based network or a wireless NIC (WNIC) or wireless adapter for communicating with a wireless network, such as a WI-FI network. This disclosure contemplates any suitable network and any suitable communication interface <b>1810</b> for it. As an example and not by way of limitation, computer system <b>1800</b> may communicate with an ad hoc network, a personal area network (PAN), a local area network (LAN), a wide area network (WAN), a metropolitan area network (MAN), or one or more portions of the Internet or a combination of two or more of these. One or more portions of one or more of these networks may be wired or wireless. As an example, computer system <b>1800</b> may communicate with a wireless PAN (WPAN) (such as, for example, a BLUETOOTH WPAN), a WI-FI network, a WI-MAX network, a cellular telephone network (such as, for example, a Global System for Mobile Communications (GSM) network), or other suitable wireless network or a combination of two or more of these. Computer system <b>1800</b> may include any suitable communication interface <b>1810</b> for any of these networks, where appropriate. Communication interface <b>1810</b> may include one or more communication interfaces <b>1810</b>, where appropriate. Although this disclosure describes and illustrates a particular communication interface, this disclosure contemplates any suitable communication interface.</p>
<p id="p-0225" num="0224">In particular embodiments, bus <b>1812</b> includes hardware, software, or both coupling components of computer system <b>1800</b> to each other. As an example and not by way of limitation, bus <b>1812</b> may include an Accelerated Graphics Port (AGP) or other graphics bus, an Enhanced Industry Standard Architecture (EISA) bus, a front-side bus (FSB), a HYPERTRANSPORT (HT) interconnect, an Industry Standard Architecture (ISA) bus, an INFINIBAND interconnect, a low-pin-count (LPC) bus, a memory bus, a Micro Channel Architecture (MCA) bus, a Peripheral Component Interconnect (PCI) bus, a PCI-Express (PCI-X) bus, a serial advanced technology attachment (SATA) bus, a Video Electronics Standards Association local (VLB) bus, or another suitable bus or a combination of two or more of these. Bus <b>1812</b> may include one or more buses <b>1812</b>, where appropriate. Although this disclosure describes and illustrates a particular bus, this disclosure contemplates any suitable bus or interconnect.</p>
<p id="p-0226" num="0225">Herein, reference to a computer-readable storage medium encompasses one or more non-transitory, tangible computer-readable storage media possessing structure. As an example and not by way of limitation, a computer-readable storage medium may include a semiconductor-based or other integrated circuit (IC) (such, as for example, a field-programmable gate array (FPGA) or an application-specific IC (ASIC)), a hard disk, an HDD, a hybrid hard drive (HHD), an optical disc, an optical disc drive (ODD), a magneto-optical disc, a magneto-optical drive, a floppy disk, a floppy disk drive (FDD), magnetic tape, a holographic storage medium, a solid-state drive (SSD), a RAM-drive, a SECURE DIGITAL card, a SECURE DIGITAL drive, or another suitable computer-readable storage medium or a combination of two or more of these, where appropriate. Herein, reference to a computer-readable storage medium excludes any medium that is not eligible for patent protection under 35 U.S.C. &#xa7;101. Herein, reference to a computer-readable storage medium excludes transitory forms of signal transmission (such as a propagating electrical or electromagnetic signal per se) to the extent that they are not eligible for patent protection under 35 U.S.C. &#xa7;101. A computer-readable non-transitory storage medium may be volatile, non-volatile, or a combination of volatile and non-volatile, where appropriate.</p>
<p id="p-0227" num="0226">This disclosure contemplates one or more computer-readable storage media implementing any suitable storage. In particular embodiments, a computer-readable storage medium implements one or more portions of processor <b>1802</b> (such as, for example, one or more internal registers or caches), one or more portions of memory <b>1804</b>, one or more portions of storage <b>1806</b>, or a combination of these, where appropriate. In particular embodiments, a computer-readable storage medium implements RAM or ROM. In particular embodiments, a computer-readable storage medium implements volatile or persistent memory. In particular embodiments, one or more computer-readable storage media embody software. Herein, reference to software may encompass one or more applications, bytecode, one or more computer programs, one or more executables, one or more instructions, logic, machine code, one or more scripts, or source code, and vice versa, where appropriate. In particular embodiments, software includes one or more application programming interfaces (APIs). This disclosure contemplates any suitable software written or otherwise expressed in any suitable programming language or combination of programming languages. In particular embodiments, software is expressed as source code or object code. In particular embodiments, software is expressed in a higher-level programming language, such as, for example, C, Perl, or a suitable extension thereof. In particular embodiments, software is expressed in a lower-level programming language, such as assembly language (or machine code). In particular embodiments, software is expressed in JAVA. In particular embodiments, software is expressed in Hyper Text Markup Language (HTML), Extensible Markup Language (XML), or other suitable markup language.</p>
<p id="p-0228" num="0227">The present disclosure encompasses all changes, substitutions, variations, alterations, and modifications to the example embodiments herein that a person having ordinary skill in the art would comprehend. Similarly, where appropriate, the appended claims encompass all changes, substitutions, variations, alterations, and modifications to the example embodiments herein that a person having ordinary skill in the art would comprehend.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-math idrefs="MATH-US-00001" nb-file="US08626695-20140107-M00001.NB">
<img id="EMI-M00001" he="7.45mm" wi="76.20mm" file="US08626695-20140107-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00002" nb-file="US08626695-20140107-M00002.NB">
<img id="EMI-M00002" he="6.35mm" wi="76.20mm" file="US08626695-20140107-M00002.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00003" nb-file="US08626695-20140107-M00003.NB">
<img id="EMI-M00003" he="7.45mm" wi="76.20mm" file="US08626695-20140107-M00003.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00004" nb-file="US08626695-20140107-M00004.NB">
<img id="EMI-M00004" he="7.45mm" wi="76.20mm" file="US08626695-20140107-M00004.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00005" nb-file="US08626695-20140107-M00005.NB">
<img id="EMI-M00005" he="6.01mm" wi="76.20mm" file="US08626695-20140107-M00005.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00006" nb-file="US08626695-20140107-M00006.NB">
<img id="EMI-M00006" he="6.01mm" wi="76.20mm" file="US08626695-20140107-M00006.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00007" nb-file="US08626695-20140107-M00007.NB">
<img id="EMI-M00007" he="6.01mm" wi="76.20mm" file="US08626695-20140107-M00007.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00008" nb-file="US08626695-20140107-M00008.NB">
<img id="EMI-M00008" he="6.01mm" wi="76.20mm" file="US08626695-20140107-M00008.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00009" nb-file="US08626695-20140107-M00009.NB">
<img id="EMI-M00009" he="5.67mm" wi="76.20mm" file="US08626695-20140107-M00009.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00010" nb-file="US08626695-20140107-M00010.NB">
<img id="EMI-M00010" he="5.67mm" wi="76.20mm" file="US08626695-20140107-M00010.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00011" nb-file="US08626695-20140107-M00011.NB">
<img id="EMI-M00011" he="6.01mm" wi="76.20mm" file="US08626695-20140107-M00011.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00012" nb-file="US08626695-20140107-M00012.NB">
<img id="EMI-M00012" he="5.67mm" wi="76.20mm" file="US08626695-20140107-M00012.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00013" nb-file="US08626695-20140107-M00013.NB">
<img id="EMI-M00013" he="6.01mm" wi="76.20mm" file="US08626695-20140107-M00013.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00014" nb-file="US08626695-20140107-M00014.NB">
<img id="EMI-M00014" he="6.01mm" wi="76.20mm" file="US08626695-20140107-M00014.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00015" nb-file="US08626695-20140107-M00015.NB">
<img id="EMI-M00015" he="6.01mm" wi="76.20mm" file="US08626695-20140107-M00015.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00016" nb-file="US08626695-20140107-M00016.NB">
<img id="EMI-M00016" he="5.67mm" wi="76.20mm" file="US08626695-20140107-M00016.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00017" nb-file="US08626695-20140107-M00017.NB">
<img id="EMI-M00017" he="6.01mm" wi="76.20mm" file="US08626695-20140107-M00017.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00018" nb-file="US08626695-20140107-M00018.NB">
<img id="EMI-M00018" he="5.67mm" wi="76.20mm" file="US08626695-20140107-M00018.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00019" nb-file="US08626695-20140107-M00019.NB">
<img id="EMI-M00019" he="6.35mm" wi="76.20mm" file="US08626695-20140107-M00019.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00020" nb-file="US08626695-20140107-M00020.NB">
<img id="EMI-M00020" he="6.01mm" wi="76.20mm" file="US08626695-20140107-M00020.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00021" nb-file="US08626695-20140107-M00021.NB">
<img id="EMI-M00021" he="6.01mm" wi="76.20mm" file="US08626695-20140107-M00021.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00022" nb-file="US08626695-20140107-M00022.NB">
<img id="EMI-M00022" he="5.67mm" wi="76.20mm" file="US08626695-20140107-M00022.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00023" nb-file="US08626695-20140107-M00023.NB">
<img id="EMI-M00023" he="6.01mm" wi="76.20mm" file="US08626695-20140107-M00023.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00024" nb-file="US08626695-20140107-M00024.NB">
<img id="EMI-M00024" he="5.67mm" wi="76.20mm" file="US08626695-20140107-M00024.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00025" nb-file="US08626695-20140107-M00025.NB">
<img id="EMI-M00025" he="5.67mm" wi="76.20mm" file="US08626695-20140107-M00025.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00026" nb-file="US08626695-20140107-M00026.NB">
<img id="EMI-M00026" he="5.67mm" wi="76.20mm" file="US08626695-20140107-M00026.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00027" nb-file="US08626695-20140107-M00027.NB">
<img id="EMI-M00027" he="9.57mm" wi="76.20mm" file="US08626695-20140107-M00027.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00028" nb-file="US08626695-20140107-M00028.NB">
<img id="EMI-M00028" he="9.14mm" wi="76.20mm" file="US08626695-20140107-M00028.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00029" nb-file="US08626695-20140107-M00029.NB">
<img id="EMI-M00029" he="5.67mm" wi="76.20mm" file="US08626695-20140107-M00029.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00030" nb-file="US08626695-20140107-M00030.NB">
<img id="EMI-M00030" he="5.67mm" wi="76.20mm" file="US08626695-20140107-M00030.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00031" nb-file="US08626695-20140107-M00031.NB">
<img id="EMI-M00031" he="5.67mm" wi="76.20mm" file="US08626695-20140107-M00031.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00032" nb-file="US08626695-20140107-M00032.NB">
<img id="EMI-M00032" he="7.45mm" wi="76.20mm" file="US08626695-20140107-M00032.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00033" nb-file="US08626695-20140107-M00033.NB">
<img id="EMI-M00033" he="6.01mm" wi="76.20mm" file="US08626695-20140107-M00033.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00034" nb-file="US08626695-20140107-M00034.NB">
<img id="EMI-M00034" he="5.67mm" wi="76.20mm" file="US08626695-20140107-M00034.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00035" nb-file="US08626695-20140107-M00035.NB">
<img id="EMI-M00035" he="5.67mm" wi="76.20mm" file="US08626695-20140107-M00035.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method comprising: by one or more computing devices,
<claim-text>accessing a binary decision diagram (BDD) representing a function having 4 variables, variables 1, 2, 3, and 4, wherein the BDD comprises 4 layers, layers 1, 2, 3, and 4, corresponding to the 4 variables, respectively;</claim-text>
<claim-text>determining an optimum variable order of the BDD by performing at least 6 and at most 13 iterations of layer swapping, the 13 iterations including at most 19 layer swaps altogether, wherein each of 6 iterations of the at least 6 and at most 13 iterations comprises:
<claim-text>determining a first size of the layers 1 and 2 and a first size of the layers 3 and 4;</claim-text>
<claim-text>swapping the layers 1 and 2 and the layers 3 and 4 concurrently;</claim-text>
<claim-text>determining a second size of the layers 1 and 2 and a second size of the layers 3 and 4; and</claim-text>
<claim-text>determining 1 variable order among 4 variable orders obtained during the iteration that yields a smallest size among the 4 variable orders obtained during the iteration.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>recording an initial variable order of the BDD as a current optimum variable order of the BDD; and</claim-text>
<claim-text>recording a size of the initial variable order of the BDD as a size of the current optimum variable order of the BDD.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein during each of the 6 iterations of the at least 6 and at most 13 iterations, determining the 1 variable order among the 4 variable orders obtained during the iteration that yields the smallest size among the 4 variable orders obtained during the iteration comprises:
<claim-text>selecting a smaller size between the first size and the second size of the layers 1 and 2, and a smaller size between the first size and the second size of the layers 3 and 4;</claim-text>
<claim-text>constructing the 1 variable order comprising a first two of the 4 variables at the layers 1 and 2, respectively, that correspond to the smaller size between the first size and the second size of the layers 1 and 2, and a second two of the 4 variables at the layers 3 and 4, respectively, that correspond to the smaller size between the first size and the second size of the layers 3 and 4; and</claim-text>
<claim-text>computing a size of the 1 variable order as a sum of the smaller size between the first size and the second size of the layers 1 and 2 and the smaller size between the first size and the second size of the layers 3 and 4.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein each of 6 iterations of the at least 6 and at most 13 iterations further comprises:
<claim-text>comparing the size of the 1 variable order with size of the current optimum variable order; and</claim-text>
<claim-text>if the size of the 1 variable order is smaller than the size of the current optimum variable order, then:
<claim-text>recording the 1 variable order as the current optimum variable order; and</claim-text>
<claim-text>recording the size of the 1 variable order as the size of the current optimum variable order.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, further comprising outputting the current optimum variable order as the optimum variable order of the BDD after the at least 6 and at most 13 iterations.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein determining the optimum variable order of the BDD by performing the at least 6 and at most 13 iterations of layer swapping, the 13 iterations including at most 19 layer swaps altogether wherein each of 6 iterations of the at least 6 and at most 13 iterations comprises determining a first size of the layers 1 and 2 and a first size of the layers 3 and 4, swapping the layers 1 and 2 and the layers 3 and 4 concurrently, determining a second size of the layers 1 and 2 and a second size of the layers 3 and 4, determining 1 variable order among 4 variable orders obtained during the iteration that yields a smallest size among the 4 variable orders obtained during the iteration comprises:
<claim-text>swapping the layers 1 and 2 and the layers 3 and 4 concurrently;</claim-text>
<claim-text>computing 4 sizes of a first 4 variable orders of 24 variable orders of the BDD;</claim-text>
<claim-text>swapping the layers 2 and 3;</claim-text>
<claim-text>swapping the layers 1 and 2 and the layers 3 and 4 concurrently;</claim-text>
<claim-text>computing 4 sizes of a second 4 variable orders of the 24 variable orders of the BDD;</claim-text>
<claim-text>swapping the layers 2 and 3;</claim-text>
<claim-text>swapping the layers 1 and 2;</claim-text>
<claim-text>swapping the layers 1 and 2 and the layers 3 and 4 concurrently;</claim-text>
<claim-text>computing 4 sizes of a third 4 variable orders of the 24 variable orders of the BDD;</claim-text>
<claim-text>swapping the layers 2 and 3;</claim-text>
<claim-text>swapping the layers 3 and 4;</claim-text>
<claim-text>swapping the layers 1 and 2 and the layers 3 and 4 concurrently;</claim-text>
<claim-text>computing 4 sizes of a fourth 4 variable orders of the 24 variable orders of the BDD;</claim-text>
<claim-text>swapping the layers 2 and 3;</claim-text>
<claim-text>swapping the layers 1 and 2 and the layers 3 and 4 concurrently;</claim-text>
<claim-text>computing 4 sizes of a fifth 4 variable orders of the 24 variable orders of the BDD;</claim-text>
<claim-text>swapping the layers 2 and 3;</claim-text>
<claim-text>swapping the layers 1 and 2 and the layers 3 and 4 concurrently; and</claim-text>
<claim-text>computing 4 sizes of a sixth 4 variable orders of the 24 variable orders of the BDD.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising reordering the 4 variables of the BDD according to the optimum variable order of the BDD.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein:
<claim-text>the BDD is data embodied by a computer-readable non-transitory storage medium; and</claim-text>
<claim-text>reordering the 4 variables of the BDD according to the optimum variable order transforms one or more data of the BDD as embodied by the computer-readable non-transitory storage medium.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the function represented by the BDD represents data collected by a medical sensor.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein a design of an electronic circuit embodies the function represented by the BDD.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the function represented by the BDD defines a property of an electronic circuit that the electronic circuit should satisfy.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the function represented by the BDD defines one or more transition relations or one or more reachable state spaces used in a formal verification of a system.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. A system comprising:
<claim-text>a memory comprising instructions executable by one or more processors; and</claim-text>
<claim-text>the one or more processors coupled to the memory and operable to execute the instructions, the one or more processors being operable when executing the instructions to:
<claim-text>access a binary decision diagram (BDD) representing a function having 4 variables, variables 1, 2, 3, and 4, wherein the BDD comprises 4 layers, layers 1, 2, 3, and 4, corresponding to the 4 variables, respectively;</claim-text>
<claim-text>determine an optimum variable order of the BDD by performing at least 6 and at most 13 iterations of layer swapping, the 13 iterations including at most 19 layer swaps altogether, wherein each of 6 iterations of the at least 6 and at most 13 iterations comprises:
<claim-text>determine a first size of the layers 1 and 2 and a first size of the layers 3 and 4;</claim-text>
<claim-text>swap the layers 1 and 2 and the layers 3 and 4 concurrently;</claim-text>
<claim-text>determine a second size of the layers 1 and 2 and a second size of the layers 3 and 4; and</claim-text>
<claim-text>determine 1 variable order among 4 variable orders obtained during the iteration that yields a smallest size among the 4 variable orders obtained during the iteration.</claim-text>
</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The system of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the one or more processors are further operable when executing the instructions to:
<claim-text>record an initial variable order of the BDD as a current optimum variable order of the BDD; and</claim-text>
<claim-text>record a size of the initial variable order of the BDD as a size of the current optimum variable order of the BDD.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The system of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein during each of the 6 iterations of the at least 6 and at most 13 iterations, determining the 1 variable order among the 4 variable orders obtained during the iteration that yields the smallest size among the 4 variable orders obtained during the iteration comprises:
<claim-text>select a smaller size between the first size and the second size of the layers 1 and 2, and a smaller size between the first size and the second size of the layers 3 and 4;</claim-text>
<claim-text>construct the 1 variable order comprising a first two of the 4 variables at the layers 1 and 2, respectively, that correspond to the smaller size between the first size and the second size of the layers 1 and 2, and a second two of the 4 variables at the layers 3 and 4, respectively, that correspond to the smaller size between the first size and the second size of the layers 3 and 4; and</claim-text>
<claim-text>compute a size of the 1 variable order as a sum of the smaller size between the first size and the second size of the layers 1 and 2 and the smaller size between the first size and the second size of the layers 3 and 4.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The system of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein each of 6 iterations of the at least 6 and at most 13 iterations further comprises:
<claim-text>compare the size of the 1 variable order with size of the current optimum variable order; and</claim-text>
<claim-text>if the size of the 1 variable order is smaller than the size of the current optimum variable order, then:
<claim-text>record the 1 variable order as the current optimum variable order; and</claim-text>
<claim-text>record the size of the 1 variable order as the size of the current optimum variable order.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The system of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the one or more processors are further operable when executing the instructions to output the current optimum variable order as the optimum variable order of the BDD after the at least 6 and at most 13 iterations.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The system of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein determining the optimum variable order of the BDD by performing the at least 6 and at most 13 iterations of layer swapping, the 13 iterations including at most 19 layer swaps altogether wherein each of 6 iterations of the at least 6 and at most 13 iterations comprises determining a first size of the layers 1 and 2 and a first size of the layers 3 and 4, swapping the layers 1 and 2 and the layers 3 and 4 concurrently, determining a second size of the layers 1 and 2 and a second size of the layers 3 and 4, determining 1 variable order among 4 variable orders obtained during the iteration that yields a smallest size among the 4 variable orders obtained during the iteration comprises:
<claim-text>swap the layers 1 and 2 and the layers 3 and 4 concurrently;</claim-text>
<claim-text>compute 4 sizes of a first 4 variable orders of 24 variable orders of the BDD;</claim-text>
<claim-text>swap the layers 2 and 3;</claim-text>
<claim-text>swap the layers 1 and 2 and the layers 3 and 4 concurrently;</claim-text>
<claim-text>compute 4 sizes of a second 4 variable orders of the 24 variable orders of the BDD;</claim-text>
<claim-text>swap the layers 2 and 3;</claim-text>
<claim-text>swap the layers 1 and 2;</claim-text>
<claim-text>swap the layers 1 and 2 and the layers 3 and 4 concurrently;</claim-text>
<claim-text>compute 4 sizes of a third 4 variable orders of the 24 variable orders of the BDD;</claim-text>
<claim-text>swap the layers 2 and 3;</claim-text>
<claim-text>swap the layers 3 and 4;</claim-text>
<claim-text>swap the layers 1 and 2 and the layers 3 and 4 concurrently;</claim-text>
<claim-text>compute 4 sizes of a fourth 4 variable orders of the 24 variable orders of the BDD;</claim-text>
<claim-text>swap the layers 2 and 3;</claim-text>
<claim-text>swap the layers 1 and 2 and the layers 3 and 4 concurrently;</claim-text>
<claim-text>compute 4 sizes of a fifth 4 variable orders of the 24 variable orders of the BDD;</claim-text>
<claim-text>swap the layers 2 and 3;</claim-text>
<claim-text>swap the layers 1 and 2 and the layers 3 and 4 concurrently; and</claim-text>
<claim-text>compute 4 sizes of a sixth 4 variable orders of the 24 variable orders of the BDD.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The system of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the one or more processors are further operable when executing the instructions to reorder the 4 variables of the BDD according to the optimum variable order of the BDD.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The system of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein:
<claim-text>the BDD is data embodied by a computer-readable non-transitory storage medium; and</claim-text>
<claim-text>reordering the 4 variables of the BDD according to the optimum variable order transforms one or more data of the BDD as embodied by the computer-readable non-transitory storage medium.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The system of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the function represented by the BDD represents data collected by a medical sensor.</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. The system of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein a design of an electronic circuit embodies the function represented by the BDD.</claim-text>
</claim>
<claim id="CLM-00023" num="00023">
<claim-text>23. The system of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the function represented by the BDD defines a property of an electronic circuit that the electronic circuit should satisfy.</claim-text>
</claim>
<claim id="CLM-00024" num="00024">
<claim-text>24. The system of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the function represented by the BDD defines one or more transition relations or one or more reachable state spaces used in a formal verification of a system.</claim-text>
</claim>
<claim id="CLM-00025" num="00025">
<claim-text>25. One or more computer-readable non-transitory storage media embodying software operable when executed by one or more computer systems to:
<claim-text>access a binary decision diagram (BDD) representing a function having 4 variables, variables 1, 2, 3, and 4, wherein the BDD comprises 4 layers, layers 1, 2, 3, and 4, corresponding to the 4 variables, respectively;</claim-text>
<claim-text>determine an optimum variable order of the BDD by performing at least 6 and at most 13 iterations of layer swapping, the 13 iterations including at most 19 layer swaps altogether, wherein each of 6 iterations of the at least 6 and at most 13 iterations comprises:
<claim-text>determine a first size of the layers 1 and 2 and a first size of the layers 3 and 4;</claim-text>
<claim-text>swap the layers 1 and 2 and the layers 3 and 4 concurrently;</claim-text>
<claim-text>determine a second size of the layers 1 and 2 and a second size of the layers 3 and 4; and</claim-text>
<claim-text>determine 1 variable order among 4 variable orders obtained during the iteration that yields a smallest size among the 4 variable orders obtained during the iteration.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00026" num="00026">
<claim-text>26. The media of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein the software is further operable when executed by the one or more computer systems to:
<claim-text>record an initial variable order of the BDD as a current optimum variable order of the BDD; and</claim-text>
<claim-text>record a size of the initial variable order of the BDD as a size of the current optimum variable order of the BDD.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00027" num="00027">
<claim-text>27. The media of <claim-ref idref="CLM-00026">claim 26</claim-ref>, wherein during each of the 6 iterations of the at least 6 and at most 13 iterations, determining the 1 variable order among the 4 variable orders obtained during the iteration that yields the smallest size among the 4 variable orders obtained during the iteration comprises:
<claim-text>select a smaller size between the first size and the second size of the layers 1 and 2, and a smaller size between the first size and the second size of the layers 3 and 4;</claim-text>
<claim-text>construct the 1 variable order comprising a first two of the 4 variables at the layers 1 and 2, respectively, that correspond to the smaller size between the first size and the second size of the layers 1 and 2, and a second two of the 4 variables at the layers 3 and 4, respectively, that correspond to the smaller size between the first size and the second size of the layers 3 and 4; and</claim-text>
<claim-text>compute a size of the 1 variable order as a sum of the smaller size between the first size and the second size of the layers 1 and 2 and the smaller size between the first size and the second size of the layers 3 and 4.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00028" num="00028">
<claim-text>28. The media of <claim-ref idref="CLM-00027">claim 27</claim-ref>, wherein each of 6 iterations of the at least 6 and at most 13 iterations further comprises:
<claim-text>compare the size of the 1 variable order with size of the current optimum variable order; and</claim-text>
<claim-text>if the size of the 1 variable order is smaller than the size of the current optimum variable order, then:
<claim-text>record the 1 variable order as the current optimum variable order; and</claim-text>
<claim-text>record the size of the 1 variable order as the size of the current optimum variable order.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00029" num="00029">
<claim-text>29. The media of <claim-ref idref="CLM-00028">claim 28</claim-ref>, wherein the software is further operable when executed by the one or more computer systems to output the current optimum variable order as the optimum variable order of the BDD after the at least 6 and at most 13 iterations.</claim-text>
</claim>
<claim id="CLM-00030" num="00030">
<claim-text>30. The media of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein determining the optimum variable order of the BDD by performing the least 6 and at most 13 iterations of layer swapping, the 13 iterations including at most 19 layer swaps altogether wherein each of 6 iterations of the at least 6 and at most 13 iterations comprises determining a first size of the layers 1 and 2 and a first size of the layers 3 and 4, swapping the layers 1 and 2 and the layers 3 and 4 concurrently, determining a second size of the layers 1 and 2 and a second size of the layers 3 and 4, determining 1 variable order among 4 variable orders obtained during the iteration that yields a smallest size among the 4 variable orders obtained during the iteration comprises:
<claim-text>swap the layers 1 and 2 and the layers 3 and 4 concurrently;</claim-text>
<claim-text>compute 4 sizes of a first 4 variable orders of 24 variable orders of the BDD;</claim-text>
<claim-text>swap the layers 2 and 3;</claim-text>
<claim-text>swap the layers 1 and 2 and the layers 3 and 4 concurrently;</claim-text>
<claim-text>compute 4 sizes of a second 4 variable orders of the 24 variable orders of the BDD;</claim-text>
<claim-text>swap the layers 2 and 3;</claim-text>
<claim-text>swap the layers 1 and 2;</claim-text>
<claim-text>swap the layers 1 and 2 and the layers 3 and 4 concurrently;</claim-text>
<claim-text>compute 4 sizes of a third 4 variable orders of the 24 variable orders of the BDD;</claim-text>
<claim-text>swap the layers 2 and 3;</claim-text>
<claim-text>swap the layers 3 and 4;</claim-text>
<claim-text>swap the layers 1 and 2 and the layers 3 and 4 concurrently;</claim-text>
<claim-text>compute 4 sizes of a fourth 4 variable orders of the 24 variable orders of the BDD;</claim-text>
<claim-text>swap the layers 2 and 3;</claim-text>
<claim-text>swap the layers 1 and 2 and the layers 3 and 4 concurrently;</claim-text>
<claim-text>compute 4 sizes of a fifth 4 variable orders of the 24 variable orders of the BDD;</claim-text>
<claim-text>swap the layers 2 and 3;</claim-text>
<claim-text>swap the layers 1 and 2 and the layers 3 and 4 concurrently; and</claim-text>
<claim-text>compute 4 sizes of a sixth 4 variable orders of the 24 variable orders of the BDD.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00031" num="00031">
<claim-text>31. The media of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein the software is further operable when executed by the one or more computer systems to reorder the 4 variables of the BDD according to the optimum variable order of the BDD.</claim-text>
</claim>
<claim id="CLM-00032" num="00032">
<claim-text>32. The media of <claim-ref idref="CLM-00031">claim 31</claim-ref>, wherein:
<claim-text>the BDD is data embodied by a computer-readable non-transitory storage medium; and</claim-text>
<claim-text>reordering the 4 variables of the BDD according to the optimum variable order transforms one or more data of the BDD as embodied by the computer-readable non-transitory storage medium.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00033" num="00033">
<claim-text>33. The media of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein the function represented by the BDD represents data collected by a medical sensor.</claim-text>
</claim>
<claim id="CLM-00034" num="00034">
<claim-text>34. The media of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein a design of an electronic circuit embodies the function represented by the BDD.</claim-text>
</claim>
<claim id="CLM-00035" num="00035">
<claim-text>35. The media of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein the function represented by the BDD defines a property of an electronic circuit that the electronic circuit should satisfy.</claim-text>
</claim>
<claim id="CLM-00036" num="00036">
<claim-text>36. The media of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein the function represented by the BDD defines one or more transition relations or one or more reachable state spaces used in a formal verification of a system.</claim-text>
</claim>
<claim id="CLM-00037" num="00037">
<claim-text>37. A system comprising:
<claim-text>means for accessing a binary decision diagram (BDD) representing a function having 4 variables, variables 1, 2, 3, and 4, wherein the BDD comprises 4 layers, layers 1, 2, 3, and 4, corresponding to the 4 variables, respectively;</claim-text>
<claim-text>means for determining an optimum variable order of the BDD by performing at least 6 and at most 13 iterations of layer swapping, the 13 iterations including at most 19 layer swaps altogether, wherein each of 6 iterations of the at least 6 and at most 13 iterations comprises:
<claim-text>means for determining a first size of the layers 1 and 2 and a first size of the layers 3 and 4;</claim-text>
<claim-text>means for swapping the layers 1 and 2 and the layers 3 and 4 concurrently;</claim-text>
<claim-text>means for determining a second size of the layers 1 and 2 and a second size of the layers 3 and 4; and</claim-text>
<claim-text>means for determining 1 variable order among 4 variable orders obtained during the iteration that yields a smallest size among the 4 variable orders obtained during the iteration. </claim-text>
</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
