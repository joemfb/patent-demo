<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08626986-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08626986</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12828241</doc-number>
<date>20100630</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>431</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>13</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>711103</main-classification>
<further-classification>711165</further-classification>
<further-classification>711170</further-classification>
</classification-national>
<invention-title id="d2e53">Pre-emptive garbage collection of memory blocks</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>7451265</doc-number>
<kind>B2</kind>
<name>Traister et al.</name>
<date>20081100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>2002/0099904</doc-number>
<kind>A1</kind>
<name>Conley</name>
<date>20020700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>2003/0110343</doc-number>
<kind>A1</kind>
<name>Hagiwara</name>
<date>20030600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2006/0155922</doc-number>
<kind>A1</kind>
<name>Gorobets et al.</name>
<date>20060700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>2006/0161728</doc-number>
<kind>A1</kind>
<name>Bennett et al.</name>
<date>20060700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711103</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2006/0184719</doc-number>
<kind>A1</kind>
<name>Sinclair</name>
<date>20060800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711103</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2008/0082736</doc-number>
<kind>A1</kind>
<name>Chow et al.</name>
<date>20080400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2008/0155301</doc-number>
<kind>A1</kind>
<name>Ahvenainen et al.</name>
<date>20080600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2008/0172431</doc-number>
<kind>A1</kind>
<name>Stephens et al.</name>
<date>20080700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707206</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2008/0209109</doc-number>
<kind>A1</kind>
<name>Lasser</name>
<date>20080800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2008/0279005</doc-number>
<kind>A1</kind>
<name>France</name>
<date>20081100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2008/0288717</doc-number>
<kind>A1</kind>
<name>Torabi</name>
<date>20081100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2009/0006720</doc-number>
<kind>A1</kind>
<name>Traister</name>
<date>20090100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2012/0005406</doc-number>
<kind>A1</kind>
<name>Hutchison et al.</name>
<date>20120100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711103</main-classification></classification-national>
</us-citation>
<us-citation>
<nplcit num="00015">
<othercit>International Search Report and Written Opinion issued in corresponding PCT/US2011/041647 dated Jan. 16, 2012 (14 pgs).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00016">
<othercit>Annex to Form PCT.ISA/206 Communication Relating to the Results of the Partial International Search issued in corresponding PCT Appln. No. PCT/US2011/041647 dated Oct. 20, 2011 (2 pgs).</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>18</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>711  5</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711100</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711103</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711154</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711165</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711170-173</main-classification>
<additional-info>unstructured</additional-info>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711E12001</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711E12008</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>36523001</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>10</number-of-drawing-sheets>
<number-of-figures>14</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20120005405</doc-number>
<kind>A1</kind>
<date>20120105</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Wu</last-name>
<first-name>William</first-name>
<address>
<city>Cupertino</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Traister</last-name>
<first-name>Shai</first-name>
<address>
<city>Sunnyvale</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Huang</last-name>
<first-name>Jianmin</first-name>
<address>
<city>Sunnyvale</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="004" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Hutchison</last-name>
<first-name>Neil David</first-name>
<address>
<city>Campbell</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="005" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Sprouse</last-name>
<first-name>Steven</first-name>
<address>
<city>San Jose</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Wu</last-name>
<first-name>William</first-name>
<address>
<city>Cupertino</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Traister</last-name>
<first-name>Shai</first-name>
<address>
<city>Sunnyvale</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Huang</last-name>
<first-name>Jianmin</first-name>
<address>
<city>Sunnyvale</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="004" designation="us-only">
<addressbook>
<last-name>Hutchison</last-name>
<first-name>Neil David</first-name>
<address>
<city>Campbell</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="005" designation="us-only">
<addressbook>
<last-name>Sprouse</last-name>
<first-name>Steven</first-name>
<address>
<city>San Jose</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Brinks Gilson &#x26; Lione</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>SanDisk Technologies Inc.</orgname>
<role>02</role>
<address>
<city>Plano</city>
<state>TX</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Thai</last-name>
<first-name>Tuan</first-name>
<department>2185</department>
</primary-examiner>
<assistant-examiner>
<last-name>Li</last-name>
<first-name>Zhuo</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A method and system pre-emptively perform garbage collection operations of a forced amount on update blocks in a memory device. The amount of garbage collection needed by a certain data write is monitored and adjusted to match the forced amount if necessary. Update blocks may be selected on the basis of their recent usage or the amount of garbage collection required. Another method and system may store control information about update blocks in a temporary storage area so that a greater number of update blocks are utilized. The sequential write performance measured by the Speed Class test may be optimized by using this method and system.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="95.50mm" wi="177.04mm" file="US08626986-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="219.46mm" wi="141.90mm" file="US08626986-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="203.37mm" wi="197.78mm" file="US08626986-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="245.28mm" wi="181.69mm" file="US08626986-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="236.90mm" wi="155.87mm" file="US08626986-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="245.28mm" wi="189.40mm" file="US08626986-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="239.69mm" wi="197.78mm" file="US08626986-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="213.87mm" wi="182.37mm" file="US08626986-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="142.58mm" wi="193.55mm" file="US08626986-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="249.51mm" wi="147.49mm" file="US08626986-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="257.22mm" wi="168.40mm" file="US08626986-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">TECHNICAL FIELD</heading>
<p id="p-0002" num="0001">This application relates generally to memory devices. More specifically, this application relates to garbage collection of blocks in reprogrammable non-volatile semiconductor flash memory.</p>
<heading id="h-0002" level="1">BACKGROUND</heading>
<p id="p-0003" num="0002">Non-volatile memory systems, such as flash memory, have been widely adopted for use in consumer products. Flash memory may be found in different forms, for example in the form of a portable memory card that can be carried between host devices or as a solid state disk (SSD) embedded in a host device. When writing data to a conventional flash memory system, a host typically writes data to, and reads data from, addresses within a logical address space of the memory system. The memory system then commonly maps data between the logical address space and the physical blocks or metablocks of the memory, where data is stored in fixed logical groups corresponding to ranges in the logical address space. Generally, each fixed logical group is stored in a separate physical block of the memory system. The memory system keeps track of how the logical address space is mapped into the physical memory but the host is unaware of this. The host keeps track of the addresses of its data files within the logical address space but the memory system generally operates without knowledge of this mapping.</p>
<p id="p-0004" num="0003">A drawback of memory systems that operate in a logical address space is fragmentation. Data written by a host file system may often be fragmented in logical address space, where many fixed logical groups are only partially updated with new data. The fragmentation may occur as a result of cumulative fragmentation of free space by the host file system, and possibly even as a result of inherent fragmentation of individual files by the host file system. Data previously written may become obsolete due to deletion and cause further fragmentation. The fragmented logical groups will need to be rewritten in full in a different physical block. Rewriting the fragmented logical groups may involve copying unrelated data from the prior location of the logical group, a process known as garbage collection. As fragmentation increases, the transfer speed of a memory system may decrease.</p>
<p id="p-0005" num="0004">To provide a measure of memory system metrics, tests may be applied to the memory system to gauge the write performance of the memory system. For example, memory systems may have transfer speed specifications that can be rated by protocols such as the Speed Class specification from the SD Association, for example. The Speed Class specification includes Speed Classes 2, 4, and 6, which denote the guaranteed minimum transfer speeds for memory systems of 2, 4, and 6 MB/s, respectively. A Speed Class test run on a memory systems measures metrics such as the sequential write performance of an addressable unit (Pw), the time for a file allocation table (FAT) write (Tfw), and the rolling average of time for multiple FAT writes (Tfw(avg)). The Speed Class test run may also measure the performance of the memory system with fragmentation (Pc), which includes the corresponding read performance measurements. Garbage collection activity occurring during a Speed Class test can adversely affect the test results.</p>
<heading id="h-0003" level="1">SUMMARY</heading>
<p id="p-0006" num="0005">In order to address the problems noted above, a method and system for controlling garbage collection in a memory device is disclosed.</p>
<p id="p-0007" num="0006">According to a first aspect of the invention, a method is disclosed for optimizing performance of a memory device including a controller. The method includes receiving incoming data for writing to a logical addressable unit, determining an amount of garbage collection to be performed for a garbage collection operation, and initiating the garbage collection operation to carry out a predetermined threshold if the determined amount of garbage collection is less than the predetermined threshold. The method further includes writing the incoming data to at least one physical metablock corresponding to the logical addressable unit. In this way, the controller may perform garbage collection pre-emptively, even if garbage collection is not currently necessary. A system is also disclosed including a plurality of memory blocks and a memory controller that implements this method.</p>
<p id="p-0008" num="0007">According to another aspect, a method of determining a mode of operation when to perform a garbage collection operation in a memory device is disclosed including a controller that determines which mode of operation to perform the garbage collection operation, and perform the garbage collection operation, performing the garbage collection operation in the determined mode. Memory devices may have different modes of operation. The memory devices may perform garbage collection more efficiently in one mode than in another mode. The controller may analyze which mode of operation more efficiently performs the garbage collection by analyzing at least one indicator of garbage collection performance (such as a maximum amount of garbage collection in the mode of operation). Depending on the analysis, the controller may perform the garbage collection in the determined mode. For example, the controller may pre-emptively garbage collection in the determined mode in order to perform garbage collection efficiently. A system is also disclosed including a plurality of memory blocks and a memory controller that implements this method.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram of a host connected with a memory system having non-volatile memory.</p>
<p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. 2</figref> illustrates an example physical memory organization of the system of <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 3</figref> shows an expanded view of a portion of the physical memory of <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 4</figref> illustrates the alignment of logical addressable units and physical metablocks.</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 5</figref> illustrates the possible states of physical metablocks following the writing of data to the memory system.</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 6</figref> is a flow diagram illustrating a method of optimizing performance of the memory device involving pre-emptive garbage collection of memory blocks.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 7</figref> illustrates a first example of memory blocks undergoing optimization of performance according to the method of <figref idref="DRAWINGS">FIG. 6</figref>.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 8</figref> illustrates a second example of memory blocks undergoing optimization of performance according to the method of <figref idref="DRAWINGS">FIG. 6</figref>.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 9</figref> illustrates a third example of memory blocks undergoing optimization of performance according to the method of <figref idref="DRAWINGS">FIG. 6</figref>.</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 10</figref> illustrates a fourth example of memory blocks undergoing optimization of performance according to the method of <figref idref="DRAWINGS">FIG. 6</figref>.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 11</figref> is a flow diagram illustrating the alternative method of optimizing performance of the memory device involving the state machine of <figref idref="DRAWINGS">FIG. 12</figref>.</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 12</figref> illustrates a state machine related to an alternative method of <figref idref="DRAWINGS">FIG. 11</figref> for optimizing performance of a memory device.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 13</figref> is a flow diagram illustrating a method of optimizing performance of the memory device involving copying of control information to a random access memory.</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 14</figref> is a flow diagram illustrating a method of optimizing performance of the memory device involving monitoring of amounts of garbage collection.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE PRESENTLY PREFERRED EMBODIMENTS</heading>
<p id="p-0023" num="0022">A flash memory system suitable for use in implementing aspects of the invention is shown in <figref idref="DRAWINGS">FIGS. 1-3</figref>. A host system <b>100</b> of <figref idref="DRAWINGS">FIG. 1</figref> stores data into and retrieves data from a flash memory <b>102</b>. The flash memory may be embedded within the host, such as in the form of a solid state disk (SSD) drive installed in a personal computer. Alternatively, the memory <b>102</b> may be in the form of a card that is removably connected to the host through mating parts <b>104</b> and <b>106</b> of a mechanical and electrical connector as illustrated in <figref idref="DRAWINGS">FIG. 1</figref>. A flash memory configured for use as an internal or embedded SSD drive may look similar to the schematic of <figref idref="DRAWINGS">FIG. 1</figref>, with the primary difference being the location of the memory system <b>102</b> internal to the host. SSD drives may be in the form of discrete modules that are drop-in replacements for rotating magnetic disk drives.</p>
<p id="p-0024" num="0023">One example of a commercially available SSD drive is a 32 gigabyte SSD produced by SanDisk Corporation. Examples of commercially available removable flash memory cards include the CompactFlash (CF), the MultiMediaCard (MMC), Secure Digital (SD), miniSD, Memory Stick, SmartMedia, TransFlash, and microSD cards. Although each of these cards has a unique mechanical and/or electrical interface according to its standardized specifications, the flash memory system included in each is similar. These cards are all available from SanDisk Corporation, assignee of the present application. SanDisk also provides a line of flash drives under its Cruzer trademark, which are hand held memory systems in small packages that have a Universal Serial Bus (USB) plug for connecting with a host by plugging into the host's USB receptacle. Each of these memory cards and flash drives includes controllers that interface with the host and control operation of the flash memory within them.</p>
<p id="p-0025" num="0024">Host systems that may use SSDs, memory cards and flash drives are many and varied. They include personal computers (PCs), such as desktop or laptop and other portable computers, cellular telephones, personal digital assistants (PDAs), digital still cameras, digital movie cameras and portable audio players. For portable memory card applications, a host may include a built-in receptacle for one or more types of memory cards or flash drives, or a host may require adapters into which a memory card is plugged. The memory system usually contains its own memory controller and drivers but there are also some memory-only systems that are instead controlled by software executed by the host to which the memory is connected. In some memory systems containing the controller, especially those embedded within a host, the memory, controller and drivers are often formed on a single integrated circuit chip.</p>
<p id="p-0026" num="0025">The host system <b>100</b> of <figref idref="DRAWINGS">FIG. 1</figref> may be viewed as having two major parts, insofar as the memory <b>102</b> is concerned, made up of a combination of circuitry and software. They are an applications portion <b>108</b> and a driver portion <b>110</b> that interfaces with the memory <b>102</b>. In a PC, for example, the applications portion <b>108</b> can include a processor (such as a microprocessor) or other type of controller running word processing, graphics, control or other popular application software. In a camera, cellular telephone or other host system that is primarily dedicated to performing a single set of functions, the applications portion <b>108</b> includes a processor or other type of controller running software that operates the camera to take and store pictures, the cellular telephone to make and receive calls, and the like.</p>
<p id="p-0027" num="0026">The memory system <b>102</b> of <figref idref="DRAWINGS">FIG. 1</figref> includes flash memory <b>112</b>, and circuits <b>114</b> that both interface with the host to which the card is connected for passing data back and forth and control the memory <b>112</b>. The controller <b>114</b> typically converts between logical addresses of data used by the host <b>100</b> and physical addresses of the memory <b>112</b> during data programming and reading. The controller <b>114</b> may comprise a processor, a microcontroller, an application specific integrated circuit (ASIC), a field programmable gate array, a logical digital circuit, or other now known or later developed logical processing capability.</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 2</figref> conceptually illustrates an organization of the flash memory cell array <b>112</b> (<figref idref="DRAWINGS">FIG. 1</figref>) that is used as an example in further descriptions below. The flash memory cell array <b>112</b> may include multiple memory cell arrays which are each separately controlled by a single or multiple memory controllers <b>114</b>. Four planes or sub-arrays <b>202</b>, <b>204</b>, <b>206</b>, and <b>208</b> of memory cells may be on a single integrated memory cell chip, on two chips (two of the planes on each chip) or on four separate chips. The specific arrangement is not important to the discussion below. Of course, other numbers of planes, such as 1, 2, 8, 16 or more may exist in a system. The planes are individually divided into groups of memory cells that form the minimum unit of erase, hereinafter referred to as blocks. Blocks of memory cells are shown in <figref idref="DRAWINGS">FIG. 2</figref> by rectangles, such as blocks <b>210</b>, <b>212</b>, <b>214</b>, and <b>216</b>, located in respective planes <b>202</b>, <b>204</b>, <b>206</b>, and <b>208</b>. There can be dozens or hundreds of blocks in each plane.</p>
<p id="p-0029" num="0028">As mentioned above, the block of memory cells is the unit of erase, the smallest number of memory cells that are physically erasable together. For increased parallelism, however, the blocks are operated in larger metablock units. One block from each plane is logically linked together to form a metablock. The four blocks <b>210</b>, <b>212</b>, <b>214</b>, and <b>216</b> are shown to form one metablock <b>218</b>. All of the cells within a metablock are typically erased together. The blocks used to form a metablock need not be restricted to the same relative locations within their respective planes, as is shown in a second metablock <b>220</b> made up of blocks <b>222</b>, <b>224</b>, <b>226</b>, and <b>228</b>. Although it is usually preferable to extend the metablocks across all of the planes, for high system performance, the memory system can be operated with the ability to dynamically form metablocks of any or all of one, two or three blocks in different planes. This allows the size of the metablock to be more closely matched with the amount of data available for storage in one programming operation.</p>
<p id="p-0030" num="0029">The individual blocks are in turn divided for operational purposes into pages of memory cells, as illustrated in <figref idref="DRAWINGS">FIG. 3</figref>. The memory cells of each of the blocks <b>210</b>, <b>212</b>, <b>214</b>, and <b>216</b>, for example, are each divided into eight pages P<b>0</b>-P<b>7</b>. Alternatively, there may be 16, 32 or more pages of memory cells within each block. The page is the unit of data programming and reading within a block, containing the minimum amount of data that are programmed or read at one time. However, in order to increase the memory system operational parallelism, such pages within two or more blocks may be logically linked into metapages. A metapage <b>302</b> is illustrated in <figref idref="DRAWINGS">FIG. 3</figref>, being formed of one physical page from each of the four blocks <b>210</b>, <b>212</b>, <b>214</b>, and <b>216</b>. The metapage <b>302</b>, for example, includes the page P<b>2</b> in each of the four blocks but the pages of a metapage need not necessarily have the same relative position within each of the blocks. A metapage is the maximum unit of programming.</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 4</figref> illustrates the alignment of logical addressable units and physical metablocks in a memory with three bits per cell (D3 memory). For example, the memory may be a 32 nm or 43 nm D3 flash memory by SanDisk Corporation with a total capacity of 2-32 GB. <figref idref="DRAWINGS">FIG. 4</figref> is intended to illustrate the misalignment between the logical addressable units and physical metablocks and does not necessarily imply that addressable unit writes are performed in the order shown in the figure.</p>
<p id="p-0032" num="0031">In one example, the logical addressable unit size of a Secure Digital (SD) memory is 4 MB, as shown by units <b>402</b>, <b>404</b>, and <b>406</b>. However, the physical metablock size in a D3 memory is 3 MB, as shown by metablocks <b>408</b>, <b>410</b>, <b>412</b>, and <b>414</b>. In <figref idref="DRAWINGS">FIG. 4</figref>, the dotted lines denote sizes of 1 MB each. Therefore, one or both of the boundaries of the logical addressable units do not align with the physical metablock boundaries. Because of this misalignment, if data is written to a particular logical addressable unit, the data is physically written to two metablocks, as shown in <figref idref="DRAWINGS">FIG. 5</figref>, resulting in unused space in one or both of the metablocks (the cross-hatched regions in <figref idref="DRAWINGS">FIG. 5</figref> indicate space in the metablocks that are written with data and the empty regions indicate unused space). The unused space could cause the sequential write performance Pw of the memory system to be non-optimal if multiple garbage collection operations are needed to recover the unused space. The present example of the logical addressable unit size of 4 MB and of the physical metablock size of 3 MB is merely for illustration purposes. Other values are contemplated.</p>
<p id="p-0033" num="0032">In particular, first, if data is written to addressable unit <b>402</b>, all of metablock <b>408</b> and 1 MB of metablock <b>410</b> are written with the incoming data, and is referred to as a Type A addressable unit <b>502</b> in <figref idref="DRAWINGS">FIG. 5</figref>. Metablock <b>408</b> is full and closed, while metablock <b>410</b> has 2 MB of unused space. Second, if data is written to addressable unit <b>404</b>, 2 MB of metablock <b>410</b> and 2 MB of metablock <b>412</b> are written with the incoming data. Addressable unit <b>404</b> is referred to as a Type B addressable unit <b>504</b>. In this case, metablocks <b>410</b> and <b>412</b> are not full and each metablock has 1 MB of unused space. Finally, if data is written to addressable unit <b>406</b>, 1 MB of metablock <b>412</b> and all of metablock <b>414</b> are written with the incoming data. Addressable unit <b>406</b> is referred to as a Type C addressable unit <b>506</b>. Metablock <b>412</b> has 2 MB of unused space and metablock <b>414</b> is full and closed in this case.</p>
<p id="p-0034" num="0033">A metablock that has incoming data written to it may also be referred to as an update block. If no unused update blocks are available when incoming data is to be written, one or more garbage collection operations are necessary to create update blocks for storing of the incoming data. As detailed further below, the open update block as a result of a Type A or Type C write would need 2 MB of future garbage collection. A Type B write would result in two open update blocks that each would need 1 MB of future garbage collection. In the case of a Type B write, if only one update block is to be created, then only 1 MB of future garbage collection is needed. Therefore, on average, any of the write types would result in garbage collection of up to 2 MB.</p>
<p id="p-0035" num="0034">However, in some situations, a garbage collection operation of greater than 2 MB may be needed to create an unused update block in a D3 memory. The first situation occurs when all the open update blocks have 1 MB of data each. If a Type B write occurs, then two unused update blocks are needed to write the incoming data. Accordingly, two garbage collections of 2 MB each would be necessary for a total of 4 MB of garbage collection. The second situation occurs when there is one open update block with 2 MB of data and the remaining open update blocks have 1 MB of data each. Again, if a Type B write occurs, then two unused update blocks are needed to write the incoming data. In this case, a minimum of two garbage collections of 1 MB and 2 MB, respectively, would be necessary, for a total of 3 MB of garbage collection.</p>
<p id="p-0036" num="0035">During a Speed Class Operation, for each write of an addressable unit, writes of the incoming data are written to the recording units making up the addressable unit. In a conventional memory system, a garbage collection operation is triggered when an update block is full. However, if a garbage collection operation occurs during a measurement segment of the Speed Class Operation, the Pw metric (sequential write performance of an addressable unit) may be negatively affected and the desired minimum transfer speed indicated by the Speed Class specification may not be met. The worst case scenario, as discussed above, would require two garbage collection operations of 2 MB each, for a total of 4 MB. A 4 MB garbage collection operation in a D3 memory would negatively affect the Pw metric.</p>
<p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. 6</figref> is a flow diagram illustrating a method <b>600</b> of optimizing performance of the memory device involving pre-emptive garbage collection of memory blocks. To avoid the worst case scenario described above, the method <b>600</b> performs pre-emptive garbage collection operations of a predetermined amount when there is a write of incoming data (such as each time there is a write of incoming data). In a D3 memory, the amount of pre-emptive garbage collection may be 2 MB, for example. The method <b>600</b> allows the memory device to meet the budget for performing work, such as a garbage collection operation, during a Speed Operation. The method <b>600</b> may be performed as a busy time process (such as operating during host commands) or idle time process (such as operating in between host commands). The memory controller <b>114</b> in the memory system <b>102</b> may implement the method <b>600</b>, for example. Each of the steps described in <figref idref="DRAWINGS">FIG. 6</figref> for the method <b>600</b> may be performed alone or in combination with other steps.</p>
<p id="p-0038" num="0037">At step <b>602</b>, incoming data to be written to a logical addressable unit is received by the memory device. Any type of data, including FAT and non-FAT data, may be written to the memory. The method <b>600</b> may not necessarily know whether a Speed Class Operation has begun but instead may operate at all times. At step <b>604</b>, the amount of garbage collection needed due to the data write is determined. As detailed above, if no unused update blocks are available at the time of a data write, one or more open update blocks undergo a garbage collection operation to create unused update blocks. If an unused update block is available, it is possible that no amount of garbage collection is needed at step <b>604</b>.</p>
<p id="p-0039" num="0038">The amount of garbage collection determined at step <b>602</b> is compared to a predetermined threshold at step <b>606</b>. The threshold may be 2 MB as for a D3 memory, for example, or may be another amount. The 2 MB threshold may be selected for a D3 memory such that the sequential write performance Pw of the memory is not negatively affected during a Speed Class Operation. If the amount of garbage collection is less than or equal to the threshold at step <b>606</b>, then one or more blocks are selected based on an algorithm at step <b>608</b> for a garbage collection operation. Alternatively, step <b>606</b> may determine whether the amount of garbage collection is less than or equal to a first threshold and greater than or equal to a second threshold. If so, one or more blocks may be selected based on an algorithm at step <b>608</b> for a garbage collection operation.</p>
<p id="p-0040" num="0039">One or more algorithms may be used to select the block at step <b>608</b>. One example algorithm may include a least work to do (or least amount to copy) algorithm. The least work to do algorithm may analyze the data in one or more update blocks to determine the update block with the least amount of data to consolidate. The least work to do algorithm may examine a write pointer in the update block resource as an indicator of an amount of space needed to fill the update block. Another example algorithm may include a least recently used (LRU) algorithm to select the least recently used update blocks. The LRU algorithm may keep track of what blocks were used when in order to select the one or more least recently used update blocks. Still another example algorithm may include a most recently used (MRU) algorithm to select the most recently used update blocks. The MRU algorithm may keep track of what blocks were used when in order to select the one or more most recently used update blocks.</p>
<p id="p-0041" num="0040">The threshold amount of garbage collection (such as the threshold in step <b>606</b>) is forced by the method <b>600</b> even if the amount determined at step <b>604</b> is less than the threshold amount. The situation where the determined amount of garbage collection is less than the threshold may occur when the memory device is in a steady state, e.g., when all of the update blocks in the memory device are the result of data writes. At step <b>610</b>, the garbage collection operation of the forced threshold amount is performed by copying data from other blocks to the update blocks selected at step <b>608</b>. One or more unused update blocks are created as a result of the garbage collection operation. Finally, at step <b>612</b>, the incoming data is written to the created unused update blocks and the method <b>600</b> is complete.</p>
<p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. 7</figref> shows an example of update blocks undergoing the method <b>600</b> shown in <figref idref="DRAWINGS">FIG. 6</figref> when the memory device is in a steady state. The top row of update blocks <b>702</b>-<b>708</b> shows open update blocks prior to a Type C data write, and the bottom row of update blocks <b>710</b>-<b>718</b> shows the update blocks following the Type C data write. In the top row, update blocks <b>702</b> and <b>704</b> are the results of a previous Type B data write, update block <b>706</b> is a result of a previous Type C data write, and update block <b>708</b> is a result of a previous Type A data write.</p>
<p id="p-0043" num="0042">A Type C write of incoming data requires two update blocks to store the data, as discussed above. For a Type C write to a D3 memory, one update block is entirely filled with 3 MB of data and a second update block is filled with 1 MB of data and remains open. Update block <b>718</b> in the bottom row of <figref idref="DRAWINGS">FIG. 7</figref>, for example, shows the open update block after a Type C write. If no unused update blocks are available at the time of the data write, update block <b>702</b> is selected for garbage collection because it is the least recently used open update block. Update block <b>702</b> undergoes 1 MB of garbage collection, resulting in an intact update block <b>710</b> following the write. However, because a threshold amount (2 MB) of garbage collection is forced when using the method <b>600</b>, update block <b>704</b> is also selected for a garbage collection operation. Update block <b>704</b> undergoes 1 MB of pre-emptive garbage collection and results in an intact update block <b>712</b> following the write. Update blocks <b>714</b> and <b>716</b> remain in the same state with the same data as update block <b>706</b> and <b>708</b>, respectively, following the write.</p>
<p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. 8</figref> shows another example of update blocks undergoing the method <b>600</b> shown in <figref idref="DRAWINGS">FIG. 6</figref> when the memory device is in a steady state. Similar to <figref idref="DRAWINGS">FIG. 7</figref>, the top row of update blocks <b>802</b>-<b>806</b> shows open update blocks prior to a Type C data write, and the bottom row of update blocks <b>808</b>-<b>814</b> shows the update blocks following the Type C data write. In the top row, update block <b>802</b> is a result of a previous Type B data write, and update blocks <b>804</b> and <b>806</b> are the results of previous Type C data writes.</p>
<p id="p-0045" num="0044">In the example depicted in <figref idref="DRAWINGS">FIG. 8</figref>, a Type C write of incoming data for a D3 memory entirely fills one update block with 3 MB of data and a second update block with 1 MB of data. The second update block, for example, update block <b>814</b>, remains open following the data write. If unused update blocks are available at the time of the data write, then no garbage collection would be needed in a conventional memory device for creating update blocks for the data write. However, according to the method <b>600</b>, update blocks <b>802</b> and <b>804</b> are selected for pre-emptive garbage collection because they are the least recently used update blocks. Each update block <b>802</b> and <b>804</b> undergoes 1 MB of garbage collection. Accordingly, update block <b>802</b> results in an intact update block <b>808</b> following the data write. Another 1 MB is garbage collected from update block <b>804</b>, resulting in update block <b>810</b>. Update block <b>810</b> remains open because there is still 1 MB of space available. Update block <b>812</b> remains in the same state with the same data as update block <b>806</b> following the write. In this example, update blocks <b>802</b> and <b>804</b> are both pre-emptively garbage collected by the method <b>600</b> because no amount of garbage collection is necessarily required. For example, block <b>804</b> is only partially garbage collected.</p>
<p id="p-0046" num="0045"><figref idref="DRAWINGS">FIG. 9</figref> shows a further example of update blocks undergoing the method <b>600</b> shown in <figref idref="DRAWINGS">FIG. 6</figref> when the memory device is in a steady state. The top row of update blocks <b>902</b>-<b>906</b> shows open update blocks prior to a Type C data write, and the bottom row of update blocks <b>908</b>-<b>914</b> shows the update blocks following the Type C data write. In the top row, update blocks <b>902</b> and <b>906</b> are a result of a previous Type C data write, and update block <b>904</b> is a result of a previous Type A data write.</p>
<p id="p-0047" num="0046">A Type C write of incoming data for a D3 memory entirely fills one update block with 3 MB of data and a second update block with 1 MB of data. The second update block, for example, update block <b>914</b>, remains open following the Type C data write. If unused update blocks are available, then no garbage collection would be required in a conventional memory device for creating unused update blocks for the data write. However, update block <b>902</b> is selected for garbage collection according to the method <b>600</b> because it is the least recently used update block. Update block <b>902</b> undergoes 2 MB of garbage collection, resulting in an intact update block <b>908</b> following the data write. Update blocks <b>910</b> and <b>912</b> remain the same with the same data as update blocks <b>904</b> and <b>906</b>, respectively, following the data write. Update block <b>902</b> is pre-emptively garbage collected in this example because no amount of garbage collection is required by the Type C write.</p>
<p id="p-0048" num="0047">Referring back to <figref idref="DRAWINGS">FIG. 6</figref>, if the amount of garbage collection determined at step <b>604</b> is greater than the threshold at step <b>606</b>, the method <b>600</b> continues to step <b>614</b>. At step <b>614</b>, one or more alternate update blocks (that are not necessarily the least recently used update blocks) are selected for a garbage collection operation. This situation occurs when the memory device is in an initial condition state, e.g., when the update blocks in the memory device are not all a result of data writes. The least recently used update block, if selected, may need to undergo more than the threshold amount of garbage collection, resulting in a negative effect on a Speed Class Operation. By selecting alternate update blocks, the necessary garbage collection may still be performed without adversely affecting the sequential write performance measurement of the Speed Class Operation.</p>
<p id="p-0049" num="0048">The alternate update block that is selected at step <b>614</b> is dependent on the type of data write at step <b>602</b>. If a Type A or Type C write occurs, then an open update block with the least amount of required garbage collection is selected for a garbage collection operation at step <b>614</b>. If the selected open update block does not require more than the threshold amount of garbage collection at step <b>616</b>, then the garbage collection operation is performed at step <b>610</b> by copying data from other blocks to the selected open update block. The incoming data is then written at step <b>612</b> to the created unused update blocks. However, if the selected open update block requires more than the threshold amount of garbage collection at step <b>616</b>, then the incoming data is written to a non-volatile storage area at step <b>618</b>, such as to a binary cache or random access memory. A garbage collection operation of the threshold amount is still performed at step <b>620</b>. For example, the data may be written to buffer random access memory (BRAM). The data may be maintained in BRAM until the garbage collection completes the process of freeing an update block.</p>
<p id="p-0050" num="0049">If a Type B write occurs at step <b>602</b>, then one or more alternate open update blocks are selected for a garbage collection operation at step <b>614</b>. If there are no unused update blocks, then one or more open update blocks are selected at step <b>614</b>. For example, a first open update block may be selected during the write of the first 2 MB, and a second open update block may be selected when writing the second 2 MB. As another example, the multiple update blocks may be selected at the same time. If the total amount of data needed to garbage collect the two selected update blocks is greater than the threshold amount at step <b>616</b>, then the incoming data is written to a temporary storage area at step <b>618</b>. A garbage collection of the threshold amount is still performed at step <b>620</b>. However, if the total amount of data needed to garbage collect the two selected update blocks is less than or equal to the threshold amount at step <b>616</b>, then garbage collection operation is performed at step <b>610</b>. In this case, the selected update block with less than or equal to half of the threshold amount is garbage collected first, followed by a garbage collection operation on the other selected update block. The incoming data is written to the created unused update blocks at step <b>612</b>.</p>
<p id="p-0051" num="0050"><figref idref="DRAWINGS">FIG. 10</figref> shows an example of update blocks undergoing the method <b>600</b> shown in <figref idref="DRAWINGS">FIG. 6</figref> when the memory device is in an initial condition state. The top row of update blocks <b>1002</b>-<b>1006</b> shows open update blocks prior to a Type B data write, and the bottom row of update blocks <b>1008</b>-<b>1014</b> shows the update blocks following the Type B data write. In the top row, update block <b>1002</b> is a result of a previous Type C data write. Update block <b>1004</b> is filled with 1.5 MB of data and update block <b>1006</b> is filled with 2.5 MB of data. Accordingly, update block <b>1004</b> would need 1.5 MB of future garbage collection and update block <b>1006</b> would need 0.5 MB of future garbage collection.</p>
<p id="p-0052" num="0051">A Type B write of incoming data for a D3 memory would fill two update blocks with 2 MB of data each, leaving both update blocks open with 1 MB of available space following the data write. Update blocks <b>1014</b> and <b>1016</b>, for example, show the resulting open update blocks following a Type B write in this case. Because a Type B write results in two open update blocks, two currently open update blocks need to be garbage collected in order to create two unused update blocks. In this example, if the two least recently used open update blocks are selected, more than the threshold amount of 2 MB would be garbage collected. In particular, update block <b>1002</b> would undergo 2 MB of garbage collection and update block <b>1004</b> would undergo 1.5 MB of garbage collection, resulting in a total of 3.5 MB of garbage collection.</p>
<p id="p-0053" num="0052">Because the amount of garbage collection exceeds the threshold, alternate update blocks are selected for garbage collection instead of the least recently used update blocks. In this example, update blocks <b>1004</b> and <b>1006</b> are selected for garbage collection, with update block <b>1006</b> being garbage collected first because it is the block with less than or equal to half the threshold, e.g., 0.5 MB, and the garbage collection of update block <b>1006</b> results in the intact update block <b>1012</b> following the data write. Update block <b>1004</b> undergoes garbage collection with an amount of 1.5 MB, resulting in the intact update block <b>1010</b> following the data write. Update block <b>1008</b> remains the same as update block <b>1002</b> following the data write. By selecting alternate update blocks in this scenario rather than the least recently used update blocks, the threshold amount of garbage collection is still pre-emptively performed.</p>
<p id="p-0054" num="0053"><figref idref="DRAWINGS">FIG. 11</figref> is a flow diagram illustrating an alternative method <b>1100</b> of optimizing performance of the memory device involving the state machine of <figref idref="DRAWINGS">FIG. 12</figref>. The method <b>1100</b> describes an alternative algorithm for selecting an open update block for garbage collection, instead of selecting the least recently used update block for garbage collection, such as discussed above with respect to step <b>608</b> of the method <b>600</b> of <figref idref="DRAWINGS">FIG. 6</figref>. The method <b>1100</b> may be used when the memory device is in a steady state, e.g., when all of the update blocks in the memory device are the result of data writes. The method <b>1100</b> allows the memory device to meet the budget for performing work, such as a garbage collection operation, during a Speed Class operation. The method <b>1100</b> may be performed as a busy time process or idle time process. The memory controller <b>114</b> in the memory system <b>102</b> may implement the method <b>1100</b>, for example. Each of the steps described in <figref idref="DRAWINGS">FIG. 11</figref> for the method <b>1100</b> may be performed alone or in combination with other steps.</p>
<p id="p-0055" num="0054">In the method <b>1100</b>, two update blocks are always selected for garbage collection operations. The two update blocks are in one of two states, State A or State B, as shown in <figref idref="DRAWINGS">FIG. 12</figref>. In State A, update block <b>1202</b> is unused and update block <b>1204</b> is an open update block as a result of a prior Type A or Type C data write. Update block <b>1202</b> contains no data and does not require future garbage collection, while update block <b>1204</b> has 1 MB of data and would require 2 MB of future garbage collection. State B includes update blocks <b>1206</b> and <b>1208</b>, which are open update blocks as a result of a prior Type B data write. Each update block <b>1206</b> and <b>1208</b> contains 2 MB of data and would require 1 MB of future garbage collection. A memory device may utilize the method <b>1100</b> once two update blocks are found in either State A or State B. The alternate update block selection of described in steps <b>614</b>-<b>618</b> of the method <b>600</b> may be utilized when the memory device is in an initial condition state in order to achieve the steady state needed to use the method <b>1100</b>.</p>
<p id="p-0056" num="0055">Transitioning between and within State A and State B requires 2 MB of garbage collection in a D3 memory. Because 2 MB of garbage collection is always performed in order to transition between and within the states, the garbage collection budget is met and a Speed Class Operation is not negatively affected. At step <b>1102</b> of the method <b>1100</b>, incoming data to be written to a logical addressable unit is received by the memory device. Any type of data, including FAT and non-FAT data, may be written to the memory. The method <b>1100</b> does not know whether a Speed Class Operation has begun but instead may operate at all times.</p>
<p id="p-0057" num="0056">At step <b>1104</b>, it is determined whether the two selected update blocks are in State A or State B, as described in <figref idref="DRAWINGS">FIG. 12</figref>. If the update blocks are in State A, then the method <b>1100</b> continues to step <b>1106</b> where it is determined what type of data write occurring at step <b>1102</b>. If the data write is a Type A or Type C data write, then the update blocks <b>1202</b> and <b>1204</b> are garbage collected at step <b>1110</b> such that the update blocks remain in State A. In particular, the update blocks <b>1202</b> and <b>1204</b> remain in State A because a Type A or Type C data write results in an open update block containing 1 MB of data and 2 MB of available space. However, if the type of data write at step <b>1106</b> is a Type B write, then the update blocks <b>1202</b> and <b>1204</b> undergo garbage collection at step <b>1112</b> such that the update blocks transition to State B and the update blocks become update blocks <b>1206</b> and <b>1208</b>. In this case, the update blocks <b>1202</b> and <b>1204</b> transition to State B because the Type B data write results in two open update blocks each containing 2 MB of data and 1 MB of available space. In steps <b>1110</b> and <b>1112</b>, the incoming data to be written is also stored in one or more update blocks.</p>
<p id="p-0058" num="0057">On the other hand, at step <b>1104</b>, if it is determined that the two selected update blocks are in State B, then the method <b>1100</b> continues to step <b>1108</b>. At step <b>1108</b>, it is determined what type of data write has occurred at step <b>1102</b>. If the data write is a Type A or Type C data write, then the update blocks <b>1206</b> and <b>1208</b> are garbage collected at step <b>1114</b> such that the update blocks transition to State A and become update blocks <b>1202</b> and <b>1204</b>. In particular, the update blocks <b>1206</b> and <b>1208</b> transition to State A because a Type A or Type C data write results in an open update block containing 1 MB of data and 2 MB of available space. However, if the type of data write at step <b>1108</b> is a Type B write, then the update blocks <b>1206</b> and <b>1208</b> are garbage collected at step <b>1116</b> such that the update blocks remain in State B. In this case, the update blocks <b>1206</b> and <b>1208</b> remain in State B because the Type B data write results in two open update blocks each containing 2 MB of data and 1 MB of available space. As before, in both steps <b>1114</b> and <b>1116</b>, the incoming data to be written is stored in one or more update blocks.</p>
<p id="p-0059" num="0058"><figref idref="DRAWINGS">FIG. 13</figref> is a flow diagram illustrating a method <b>1300</b> of optimizing performance of the memory device involving copying of at least a part of the data related to garbage collection to a volatile memory. In one embodiment, some or all of control information for an update block may be copied to a random access memory or other type of volatile memory. In another embodiment, some or all of the fragmented data subject to garbage collection may be copied to a random access memory or other type of volatile memory. The copied fragmented data may thereafter be copied into a non-volatile memory. In still another embodiment, some or all of the control information and some or all of the fragmented data subject to garbage collection may be copied to a random access memory or other type of volatile memory.</p>
<p id="p-0060" num="0059">Using volatile memory, such as the random access memory, to temporarily store a part of the information, such as the control information, may improve the performance of the memory device during a Speed Class Operation. The method <b>1300</b> may be performed as a busy time process or idle time process. The memory controller <b>114</b> may implement the method <b>1300</b>, for example. Each of the steps described in <figref idref="DRAWINGS">FIG. 13</figref> for the method <b>1300</b> may be performed alone or in combination.</p>
<p id="p-0061" num="0060">At step <b>1302</b>, incoming data to be written to a logical addressable unit is received by the memory device. At step <b>1304</b>, the quantity of the incoming data that has been received is compared to a threshold. Detection of the quantity of data may be restricted to when the start of the data is received in lengths of recording units. When data to be written to a logical addressable unit is received in lengths of recording units, a Speed Class Operation may have been started. If an addressable unit has a length of 4 MB, the recording unit has a length of 16 kB, for example. If the quantity of data detected at step <b>1304</b> is below the threshold, then the method <b>1300</b> returns to step <b>1302</b> to receive more incoming data.</p>
<p id="p-0062" num="0061">However, if the quantity of data is at or above the threshold at step <b>1304</b>, then the method <b>1300</b> continues to step <b>1306</b>. The threshold may be 80% of the logical addressable unit, or may be another quantity or percentage. The incoming data is written to the physical blocks of the memory device at step <b>1306</b>. At step <b>1308</b>, garbage collection of any open update blocks in the memory device is performed. Any amount of garbage collection may be performed at step <b>1308</b> as necessary without negatively affecting the Speed Class Operation. There is no negative effect on the Speed Class Operation because the first addressable unit write of a Speed Class Operation is not used to measure the sequential write performance Pw.</p>
<p id="p-0063" num="0062">In one embodiment, following the garbage collection operation performed at step <b>1308</b>, the write type of the next data to be written is identified, as shown at step <b>1310</b>. The write type, either Type A, B, or C, as described previously, may be determined by examining the logical starting address of the addressable unit being written.</p>
<p id="p-0064" num="0063">In one embodiment, some or part of the data related to garbage collection may be automatically written to a volatile memory. In an alternate embodiment, some or part of the data related to garbage collection may be written to a volatile memory depending on one or more characteristics of the garbage collection. For example, the determination whether to write a part of the data related to garbage collection may be dependent on the write type. In particular, control information about an update block may be stored in either a random access memory or a flash memory depending on the identified write type. As another example, the determination whether to write a part of the data related to garbage collection may be dependent on whether the write fills the update block. Specifically, a determination is made whether to write a part of the information to a volatile memory. For example, the determination may be based on analyzing the next incoming data. In particular, at step <b>1312</b>, it is determined whether the identified write type of the next incoming data will fill an update block and create an intact block. If the write type of the next incoming data will completely fill the update block, then a part of the information is stored in volatile memory, such as the control information is stored in a random access memory (RAM) at step <b>1316</b>. The control information may include mapping information of the logical addressable unit to a physical metablock or other information. Examples of control information include, but are not limited to logical group, metablock number, write pointer, and page tag.</p>
<p id="p-0065" num="0064">By storing the control information in a RAM instead of the flash memory, the maximum number of usable update blocks in the memory device may be extended, resulting in a reduction of forced garbage collection operations due to lack of resources. However, if the write type of the next incoming data will not completely fill the update block at step <b>1312</b>, then the control information for the logical addressable unit is stored in the flash memory at step <b>1314</b>.</p>
<p id="p-0066" num="0065">If the control information is stored in a RAM, a power cycle flag or other indicator corresponding to the logical addressable unit may be set in the flash memory. By using a power cycle flag, if a loss of power to the memory device occurs before the update block with the control information stored in the RAM is closed, then recovery of the control information may occur upon re-initialization of the memory device. After re-initialization begins, if the power cycle flag is set, then the control information may be reconstructed (even though the control information previously stored in RAM is lost). One manner in which to reconstruct the control information is by using the free update block list, which is a list of the update blocks that are free. In particular, the free update block list may be used to determine the update blocks that are free, and at least a part of the data associated with those free update blocks may be analyzed. For example, the header information may be analyzed (such as the header information in the first page), so that the data contained in the update block may be determined. Once the data contained in the update block is determined, the control information may be constructed. The reconstructed control information for this update block may be subsequently stored in flash memory following the garbage collection of another update block after re-initialization of the memory device. Or, the reconstructed control information for this update block may again be stored in volatile memory (such as RAM).</p>
<p id="p-0067" num="0066"><figref idref="DRAWINGS">FIG. 14</figref> illustrates a flow diagram to select which mode of operation to perform garbage collection (such as a pre-emptive garbage collection). A particular memory device may perform garbage collection differently in different modes of operation. One mode of operation may be more efficient to perform garbage collection than another mode of operation. For example, a 32 nanometer flash memory may operate in a first mode of operation (such as garbage collection in a busy period) and operate in a second mode of operation (such as garbage collection during a write of the logical addressable unit). The amount of garbage collection for the 32 nanometer flash memory that may be performed in the first mode of operation may differ from the amount of garbage collection that may be performed for the second mode of operation. As another example, a 70 nanometer flash memory may perform garbage collection differently in a first mode of operation (such as garbage collection in a busy period) than in the second mode of operation (such as garbage collection during a write of the logical addressable unit).</p>
<p id="p-0068" num="0067">Previously, garbage collection was performed when it was necessary to be performed due to memory constraints. In contrast, garbage collection may be performed in a selected mode of operation when the flash memory is more efficient to perform the garbage collection, such as illustrated in <figref idref="DRAWINGS">FIG. 14</figref>. As discussed above, garbage collection may be pre-emptively performed (such as discussed with respect to <figref idref="DRAWINGS">FIG. 6</figref>). In pre-emptively performing garbage collection, the flash memory may determine the mode of operation where it is better (or best) to perform the garbage collection. For example, the flash memory may determine that garbage collection is more efficient if performed during a busy period. If so, the flash memory may perform pre-emptive garbage collection during the busy period. As another example, the flash memory may determine that garbage collection is more efficient if performed during a write of the logical addressable unit. If so, the flash memory may perform pre-emptive garbage collection during a write of the logical addressable unit.</p>
<p id="p-0069" num="0068"><figref idref="DRAWINGS">FIG. 14</figref> is a flow diagram illustrating a method <b>1400</b> that shows a specific example of selecting which mode to perform garbage collection, namely optimizing performance of the memory device by monitoring amounts of garbage collection. The memory may determine which mode to perform garbage collection based on one or more indicators, such as indicators based on maximum amounts of garbage collection in different periods of operation. In particular, the method <b>1400</b> monitors the maximum amount of garbage collection in a single busy period of the memory device and the maximum amount of garbage collection copied during a write of a logical addressable unit. By using the method <b>1400</b>, the maximum amount of garbage collection in a busy period may be pre-emptively performed, even if it is not required. The method <b>1400</b> may be performed as a busy time process or idle time process. The memory controller <b>114</b> may implement the method <b>1400</b>, for example. Each of the steps described in <figref idref="DRAWINGS">FIG. 14</figref> for the method <b>1400</b> may be performed alone or in combination.</p>
<p id="p-0070" num="0069">At step <b>1402</b>, incoming data to be written to a logical addressable unit is received by the memory device. Two parameters are accessed at step <b>1404</b> after the incoming data is received. The first parameter is the maximum amount of garbage collection that can be performed in a single busy period of the memory device. A busy period may comprise the duration of a read of data from the memory device or a write of data to the memory device. The second parameter is the maximum of garbage collection that can be performed during a write of the logical addressable unit. It is possible that the two parameters may be equal, but it is more likely that the second parameter will be higher than the first parameter. The two parameters may be stored in a RAM. As shown in <figref idref="DRAWINGS">FIG. 14</figref>, the two parameters are compared to one another to determine which mode the memory device is more efficient at garbage collection. In an alternate embodiment, the memory device may include a different indicator to indicate which mode is more efficient for garbage collection. For example, the memory device may include a garbage_collection_mode_flag that indicates which mode is more efficient at garbage collection. In this way, the memory device does not need to determine which mode is the more efficient (such as by accessing the maximum amounts), and may simply access the flag to determine the more efficient mode.</p>
<p id="p-0071" num="0070">At step <b>1406</b>, if the second parameter is higher than the first parameter, then the method <b>1400</b> continues to step <b>1408</b>. At step <b>1408</b>, garbage collection of the update block is initiated up to the amount of the second parameter. The garbage collection operation is performed through steps <b>1408</b> and <b>1410</b> until the amount of garbage collection reaches the amount of the second parameter. If the second parameter is not higher than the first parameter at step <b>1406</b>, then garbage collection of the update block is initiated up to the amount of the first parameter at step <b>1412</b>. In this case, the garbage collection operation is performed through steps <b>1412</b> and <b>1414</b> until the amount of garbage collection reaches the amount of the first parameter. The amount of data copied during a garbage collection operation during a write to a single logical addressable unit is maximized when using the method <b>1400</b>. In particular, even if the logical addressable unit is completely written to the update block, then garbage collection continues on the update block until the maximum amount according the first or second parameter is reached.</p>
<p id="p-0072" num="0071">It is intended that the foregoing detailed description be regarded as illustrative rather than limiting, and that it be understood that it is the following claims, including all equivalents, that are intended to define the spirit and scope of this invention.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>We claim:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method of garbage collection in a memory device, the method comprising:
<claim-text>with a controller in the memory device:
<claim-text>receiving incoming data to write to a logical addressable unit;</claim-text>
<claim-text>determining an amount of garbage collection to be performed for a garbage collection operation;</claim-text>
<claim-text>if the determined amount of garbage collection is less than a predetermined threshold, initiating the garbage collection operation to carry out the predetermined threshold;</claim-text>
<claim-text>selecting a least recently used update block for the garbage collection operation;</claim-text>
<claim-text>if the determined amount of garbage collection for the least recently used update block is more than the predetermined threshold:
<claim-text>selecting an alternate update block for the garbage collection operation instead of the selected least recently used update block;
<claim-text>(A) if the determined amount of garbage collection for the alternate update block is more than the predetermined threshold:</claim-text>
<claim-text>&#x2003;(1) writing the incoming data to a temporary storage space; and</claim-text>
<claim-text>&#x2003;(2) copying a first quantity of data from an intact block to the alternate update block, where the first quantity of data is equal to the predetermined threshold; and</claim-text>
<claim-text>(B) if the determined amount of garbage collection for the alternate update block is less than the predetermined threshold, copying a second quantity of data from the alternate update block to an open update block, where the second quantity of data is less than the predetermined threshold; and</claim-text>
</claim-text>
</claim-text>
<claim-text>writing the incoming data to at least one physical metablock corresponding to the logical addressable unit.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, where initiating the garbage collection operation comprises:
<claim-text>selecting a least recently used update block for the garbage collection operation; and</claim-text>
<claim-text>copying a quantity of data equal to the predetermined threshold from an intact block to the least recently used update block, where the predetermined threshold comprises the determined amount of garbage collection.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, where:
<claim-text>a size of the logical addressable unit is four megabytes;</claim-text>
<claim-text>a size of the physical metablock is three megabytes; and</claim-text>
<claim-text>the predetermined threshold comprises two megabytes.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, where initiating the garbage collection operation comprises:
<claim-text>selecting a first least recently used update block for the garbage collection operation;</claim-text>
<claim-text>copying a first quantity of data from the first least recently used update block to a first open update block, where the first quantity of data is less than the predetermined threshold;</claim-text>
<claim-text>selecting a second least recently used update block for the garbage collection operation; and</claim-text>
<claim-text>copying a second quantity of data from another intact block to the second least recently used update block, where the second quantity of data is equal to the first quantity of data subtracted from the predetermined threshold;</claim-text>
<claim-text>where the predetermined threshold comprises the determined amount of garbage collection.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, where:
<claim-text>a size of the logical addressable unit is four megabytes;</claim-text>
<claim-text>a size of the physical metablock is three megabytes;</claim-text>
<claim-text>the first quantity of data comprises one megabyte; and</claim-text>
<claim-text>the predetermined threshold comprises two megabytes.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, where:
<claim-text>a size of the logical addressable unit is four megabytes;</claim-text>
<claim-text>a size of the physical metablock is three megabytes; and</claim-text>
<claim-text>the predetermined threshold comprises two megabytes.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, where the temporary storage space comprises a binary cache.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>with the controller in the memory device:
<claim-text>copying the incoming data from the temporary storage space to an open update block.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, where initiating the garbage collection operation is performed each time there is a write of the incoming data.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, where the predetermined threshold comprises a first threshold;
<claim-text>further comprising determining whether the amount of the garbage collection is greater than a second threshold; and</claim-text>
<claim-text>where the garbage collection operation is initiated if the amount of the garbage collection is less than the first threshold and greater than the second threshold.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. A memory device comprising:
<claim-text>a memory; and</claim-text>
<claim-text>a controller in communication with the memory, the controller configured to:
<claim-text>receive incoming data to write to a logical addressable unit; determine an amount of garbage collection to be performed for a garbage collection operation;</claim-text>
<claim-text>if the determined amount of garbage collection is less than a predetermined threshold, initiate the garbage collection operation to carry out the predetermined threshold;</claim-text>
<claim-text>select a least recently used update block for the garbage collection operation;</claim-text>
<claim-text>if the determined amount of garbage collection for the least recently used update block is more than the predetermined threshold:
<claim-text>select an alternate update block for the garbage collection operation instead of the selected least recently used update block;
<claim-text>(A) if the determined amount of garbage collection for the alternate update block is more than the predetermined threshold:</claim-text>
<claim-text>&#x2003;(1) write the incoming data to a temporary storage space; and</claim-text>
<claim-text>&#x2003;(2) copy a first quantity of data from an intact block to the alternate update block, where the first quantity of data is equal to the predetermined threshold; and</claim-text>
<claim-text>(B) if the determined amount of garbage collection for the alternate update block is less than the predetermined threshold, copy a second quantity of data from the alternate update block to an open update block, where the second quantity of data is less than the predetermined threshold; and</claim-text>
</claim-text>
</claim-text>
<claim-text>write the incoming data to at least one physical metablock corresponding to the logical addressable unit.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The memory device of <claim-ref idref="CLM-00011">claim 11</claim-ref>, where the controller is configured to initiate the garbage collection operation by:
<claim-text>selecting a least recently used update block for the garbage collection operation; and</claim-text>
<claim-text>copying a quantity of data equal to the predetermined threshold from an intact block to the least recently used update block, where the predetermined threshold comprises the determined amount of garbage collection.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The memory device of <claim-ref idref="CLM-00011">claim 11</claim-ref>, where the controller is configured to initiate the garbage collection operation by:
<claim-text>selecting a first least recently used update block for the garbage collection operation;</claim-text>
<claim-text>copying a first quantity of data from the first least recently used update block to a first open update block, where the first quantity of data is less than the predetermined threshold;</claim-text>
<claim-text>selecting a second least recently used update block for the garbage collection operation; and</claim-text>
<claim-text>copying a second quantity of data from another intact block to the second least recently used update block, where the second quantity of data is equal to the first quantity of data subtracted from the predetermined threshold, and</claim-text>
<claim-text>where the predetermined threshold comprises the determined amount of garbage collection.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The memory device of <claim-ref idref="CLM-00013">claim 13</claim-ref>, where:
<claim-text>a size of the logical addressable unit is four megabytes;</claim-text>
<claim-text>a size of the physical metablock is three megabytes;</claim-text>
<claim-text>the first quantity of data comprises one megabyte; and</claim-text>
<claim-text>the predetermined threshold comprises two megabytes.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The memory device of <claim-ref idref="CLM-00011">claim 11</claim-ref>, where:
<claim-text>a size of the logical addressable unit is four megabytes;</claim-text>
<claim-text>a size of the physical metablock is three megabytes; and</claim-text>
<claim-text>the predetermined threshold comprises two megabytes.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The memory device of <claim-ref idref="CLM-00011">claim 11</claim-ref>, where:
<claim-text>a size of the logical addressable unit is four megabytes;</claim-text>
<claim-text>a size of the physical metablock is three megabytes; and</claim-text>
<claim-text>the predetermined threshold comprises two megabytes.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The memory device of <claim-ref idref="CLM-00011">claim 11</claim-ref>, where the temporary storage space comprises a binary cache.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The memory device of <claim-ref idref="CLM-00011">claim 11</claim-ref>, where the controller is further configured to:
<claim-text>copy the incoming data from the temporary storage space to an open update block. </claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
