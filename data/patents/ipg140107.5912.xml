<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627021-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627021</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13222399</doc-number>
<date>20110831</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<us-term-of-grant>
<us-term-extension>148</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>12</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>711154</main-classification>
<further-classification>711137</further-classification>
<further-classification>710110</further-classification>
</classification-national>
<invention-title id="d2e53">Method and apparatus for load-based prefetch access</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5649231</doc-number>
<kind>A</kind>
<name>Kitano</name>
<date>19970700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6049891</doc-number>
<kind>A</kind>
<name>Inamoto</name>
<date>20000400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714  612</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6212611</doc-number>
<kind>B1</kind>
<name>Nizar et al.</name>
<date>20010400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6496877</doc-number>
<kind>B1</kind>
<name>Greenberg et al.</name>
<date>20021200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>6526462</doc-number>
<kind>B1</kind>
<name>Elabd</name>
<date>20030200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>6611392</doc-number>
<kind>B1</kind>
<name>Hasebe</name>
<date>20030800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>360 53</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2002/0194441</doc-number>
<kind>A1</kind>
<name>Chauvel et al.</name>
<date>20021200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2003/0188077</doc-number>
<kind>A1</kind>
<name>Watts et al.</name>
<date>20031000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710313</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2004/0006671</doc-number>
<kind>A1</kind>
<name>Handgen et al.</name>
<date>20040100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2005/0102560</doc-number>
<kind>A1</kind>
<name>Taketoshi et al.</name>
<date>20050500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714 14</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2005/0257005</doc-number>
<kind>A1</kind>
<name>Jeddeloh</name>
<date>20051100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2006/0248237</doc-number>
<kind>A1</kind>
<name>Ido et al.</name>
<date>20061100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>710  6</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2008/0140941</doc-number>
<kind>A1</kind>
<name>Dasgupta et al.</name>
<date>20080600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711137</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2009/0132733</doc-number>
<kind>A1</kind>
<name>Codrescu et al.</name>
<date>20090500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>2009/0307691</doc-number>
<kind>A1</kind>
<name>Moscibroda et al.</name>
<date>20091200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>2011/0161587</doc-number>
<kind>A1</kind>
<name>Guthrie et al.</name>
<date>20110600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711122</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00017">
<document-id>
<country>EP</country>
<doc-number>0374337</doc-number>
<kind>A1</kind>
<date>19900600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00018">
<othercit>International Search Report and Written Opinion&#x2014;PCT/US2012/053559&#x2014;ISA/EPO&#x2014;Jan. 7, 2013.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>68</number-of-claims>
<us-exemplary-claim>14</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>711154</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711137</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>710110</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>7</number-of-drawing-sheets>
<number-of-figures>7</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20130054853</doc-number>
<kind>A1</kind>
<date>20130228</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Wang</last-name>
<first-name>Feng</first-name>
<address>
<city>San Diego</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Kim</last-name>
<first-name>Jonghae</first-name>
<address>
<city>San Diego</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Wang</last-name>
<first-name>Feng</first-name>
<address>
<city>San Diego</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Kim</last-name>
<first-name>Jonghae</first-name>
<address>
<city>San Diego</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<last-name>Talpalatsky</last-name>
<first-name>Sam</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Pauley</last-name>
<first-name>Nicholas J.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="03" rep-type="attorney">
<addressbook>
<last-name>Agusta</last-name>
<first-name>Joseph</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>QUALCOMM Incorporated</orgname>
<role>02</role>
<address>
<city>San Diego</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Farrokh</last-name>
<first-name>Hashem</first-name>
<department>2188</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A load state of a slave memory is detected and provided to a master device. The master device communicates prefetch access requests to the slave memory based, at least in part, on the detected load state. Optionally, the master device communicates prefetch requests to the slave memory according to a schedule based, at least in part, on the detected load state.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="207.09mm" wi="145.88mm" file="US08627021-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="223.77mm" wi="162.81mm" file="US08627021-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="241.98mm" wi="154.94mm" orientation="landscape" file="US08627021-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="226.57mm" wi="144.86mm" file="US08627021-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="223.44mm" wi="146.13mm" file="US08627021-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="238.51mm" wi="163.75mm" file="US08627021-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="240.11mm" wi="164.34mm" orientation="landscape" file="US08627021-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="160.61mm" wi="136.06mm" file="US08627021-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">FIELD OF DISCLOSURE</heading>
<p id="p-0002" num="0001">This disclosure relates to slave device access management and, more particularly, to prefetch access management.</p>
<heading id="h-0002" level="1">BACKGROUND</heading>
<p id="p-0003" num="0002">In a conventional master-slave memory circuit having a bus system, bus masters access the memory through bus arbitration schemes that must guarantee low latency or meet bandwidth requirements. Related Art <figref idref="DRAWINGS">FIG. 1</figref> shows an example <b>100</b> of such a system, having master devices <b>102</b>-<b>1</b>, <b>102</b>-<b>2</b> . . . <b>102</b>-N (collectively <b>102</b>) connected to bus masters interfacing to the bus interconnect <b>104</b>. Various traffic patterns along available paths <b>106</b> may be determined by bus arbiters such as <b>108</b>. One or more memories <b>112</b> couple to respective memory controllers <b>110</b>, which couple to slave devices interfacing to the bus <b>104</b>. In these conventional designs, efficiency of accesses to the memories <b>112</b> heavily depends on the traffic patterns determined by the bus arbiters <b>108</b>, as well as address request patterns, and the design of the memory controller and memory itself Further, in conventional arrangements, memories <b>112</b> may not be fully utilized due to temporal load unbalance. During times of heavy bus utilization, for example, the bus <b>104</b> may form a process flow bottleneck that delays memory access for some access requests by the bus masters. Further, during times of light bus utilization, the memories <b>112</b> may be under-utilized, and result in memory access capacity being wasted.</p>
<p id="p-0004" num="0003"><figref idref="DRAWINGS">FIG. 2</figref> shows a computer simulation <b>200</b> of memory accesses to a conventional master-slave, for example the memory formed by the <figref idref="DRAWINGS">FIG. 1</figref> memory <b>112</b> and its memory controller <b>110</b> in the <figref idref="DRAWINGS">FIG. 1</figref> depicted bus system <b>100</b>. The computer simulation <b>200</b> is over a time interval TT along a time axis <b>202</b>, marked according to contiguous equally spaced sampling intervals. At each of the sampling intervals is a vertical bar, having a height representing the quantity of memory requests carried out by the above-described slave memory over that sampling interval. It will be understood that the total of the accesses over the TT interval accomplishes, in terms of an amount of data transferred, a given benchmark task. For convenience in referring to <figref idref="DRAWINGS">FIG. 2</figref>, periods of predominantly read requests are filled in black and periods of predominantly write requests are marked by cross-hatching.</p>
<p id="p-0005" num="0004">The temporal load imbalance shown by the <figref idref="DRAWINGS">FIG. 2</figref> simulation is significant. Over time intervals LT<b>1</b>, LT<b>2</b> and LT<b>3</b>, the average number of read accesses per subinterval is low. Contrasting sharply, packed into the much shorter time periods HT<b>1</b>, HT<b>2</b>, and HT<b>3</b> are write accesses arriving at the slave memory at a rate multiple times the read access density over LT<b>1</b>, LT<b>2</b> and LT<b>3</b>. Stated differently, for approximately 90% of the TT interval used to perform the given benchmark task, the slave memory is handling only &#x2155; the access density that it may be capable of handling. Further, if the access density during the HT<b>1</b>, HT<b>2</b>, and HT<b>3</b> high load intervals is high enough to cause degradation in system performance then, for the small percentage of the time the memory is not severely under-utilized it is, instead, over loaded.</p>
<heading id="h-0003" level="1">SUMMARY</heading>
<p id="p-0006" num="0005">Exemplary embodiments of the invention are directed to systems and methods providing master-slave access according to a slave load state of the slave memory.</p>
<p id="p-0007" num="0006">According to one or more exemplary embodiments a method may include detecting a load state of a slave memory, and communicating a prefetch access request from a master to the slave memory in accordance with the detected load state.</p>
<p id="p-0008" num="0007">In one aspect, detecting a load state of the slave memory may include generating a load state data at the slave memory and transmitting the load state data to the master device.</p>
<p id="p-0009" num="0008">In another aspect an access request may include an associated access command and, according to one or more exemplary embodiments, one method may further include placing the associated access commands in a slave memory command queue for execution by the slave memory and, in one aspect, detecting the slave load state may be based, at least in part, on a quantity of access commands in the command queue.</p>
<p id="p-0010" num="0009">One or more of the exemplary embodiments may include a master-slave memory apparatus having means for detecting a slave load state of a slave memory, and means for communicating a prefetch access request from the master device to the slave memory based, at least in part, on the detected slave load state.</p>
<p id="p-0011" num="0010">According to one or more exemplary embodiments, a computer product may have a computer readable medium comprising instructions that, when read and executed by a processor, cause the processor to perform operations for controlling master-slave memory accessing and, in one aspect, the instructions may comprise instructions that cause a processor to detect a slave load state of a slave memory, and communicate a prefetch access request from the master device to the slave memory based, at least in part, on the detected slave load state.</p>
<p id="p-0012" num="0011">According to one exemplary embodiment, a master device may receive a slave memory load data indicating the slave memory having one of a heavy load or a light load, may schedule transmission of master-slave prefetch commands to the slave memory based, at least in part, on the slave memory load indicated by the received slave load data.</p>
<p id="p-0013" num="0012">As will be appreciated by persons of ordinary skill in the art from this disclosure, example benefits may include balancing of memory loading over time, reduction in memory congestion and concomitant reduction in memory latency. These and benefits, may also provide performance improvement to master devices having tight memory access latency requirements. Further benefits may include, but are not limited to, reduced power consumption resulting from an increase in a time that the memory is powered down, thus saving power.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0014" num="0013">The accompanying drawings are presented to aid in the description of embodiments of the invention and are provided solely for illustration of the embodiments and not limitation thereof.</p>
<p id="p-0015" num="0014">Related Art <figref idref="DRAWINGS">FIG. 1</figref> shows a conventional master-slave bus memory system.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 2</figref> is a computer simulation showing a per unit time memory access density of a slave memory of a conventional master-slave bus memory system.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 3</figref> shows a functional schematic of one load based prefetch system according to one exemplary embodiment.</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 4</figref> shows a functional schematic of one shared buffer aspect of one load based prefetch system according to one exemplary embodiment.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 5</figref> is a block flow diagram of one example process for one load based prefetch request generation and transmission according to one exemplary embodiment.</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 6</figref> shows a computer simulation of a per-unit-time interval density of receiving master device access requests at a slave memory provided by one load based prefetch access according to one exemplary embodiment.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 7</figref> illustrates an exemplary wireless communication system in which one or more embodiments of the disclosure may be advantageously employed.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0022" num="0021">Aspects of the invention are disclosed in the following description and related drawings directed to specific embodiments of the invention. Alternate embodiments may be devised without departing from the scope of the invention. Additionally, well-known elements of the invention will not be described in detail or will be omitted so as not to obscure the relevant details of the invention.</p>
<p id="p-0023" num="0022">The word &#x201c;exemplary&#x201d; is used herein to mean &#x201c;serving as an example, instance, or illustration.&#x201d; Any embodiment described herein as &#x201c;exemplary&#x201d; is not necessarily to be construed as preferred or advantageous over other embodiments. Likewise, the term &#x201c;embodiments of the invention&#x201d; does not require that all embodiments of the invention include the discussed feature, advantage or mode of operation.</p>
<p id="p-0024" num="0023">The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of embodiments of the invention. As used herein, the singular forms &#x201c;a&#x201d;, &#x201c;an&#x201d; and &#x201c;the&#x201d; are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms &#x201c;comprises&#x201d;, &#x201c;comprising,&#x201d;, &#x201c;includes&#x201d; and/or &#x201c;including&#x201d;, when used herein, specify the presence of stated features, integers, steps, operations, elements, and/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, elements, components, and/or groups thereof.</p>
<p id="p-0025" num="0024">Further, many embodiments are described in terms of sequences of actions to be performed by, for example, elements of a computing device. It will be recognized that various actions described herein can be performed by specific circuits (e.g., application specific integrated circuits (ASICs)), by program instructions being executed by one or more processors, or by a combination of both. Additionally, these sequence of actions described herein can be considered to be embodied entirely within any form of computer readable storage medium having stored therein a corresponding set of computer instructions that upon execution would cause an associated processor to perform the functionality described herein. Thus, the various aspects of the invention may be embodied in a number of different forms, all of which have been contemplated to be within the scope of the claimed subject matter. In addition, for each of the embodiments described herein, the corresponding form of any such embodiments may be described herein as, for example, &#x201c;logic configured to&#x201d; perform the described action.</p>
<p id="p-0026" num="0025">One example embodiment includes a master device coupled to a slave memory, the slave memory having means to detect its own, i.e., slave load state and to transmit the slave load state to the master device. The master device may, in response, generate and transmit access requests to the slave device based, at least in part, on the slave load state. In one aspect, master device may schedule transmission of access requests to the slave memory based, at least in part, on the load state of the slave memory.</p>
<p id="p-0027" num="0026">In one aspect the slave memory may transmit, upon its determination of having a light load state, a prefetch send request to the master device. As will be appreciated, this aspect may provide substantial load balancing over time by permitting the master devices to exploit for purposes of prefetch otherwise under-utilized memory capacity. In a corresponding aspect the slave memory may transmit to the master device, upon its determination of having a heavy load state, a prefetch postpone or delay request. In one aspect, the master device may respond to the prefetch postpone or delay request by postponing its sending of prefetch, and other high latency-tolerant access requests to the slave memory, while not postponing sending low latency-tolerant access requests.</p>
<p id="p-0028" num="0027">As will be further appreciated, this aspect may provide a load more even or balanced over time by permitting the master devices to move the scheduling of prefetch access requests, which due to their high latency-tolerance can tolerate such scheduling change, for the benefit of low latency-tolerant access requests. This aspect may provide an increase in the percentage of time in which the slave memory can handle low latency-tolerant access requests.</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 3</figref> is a functional block diagram <b>300</b> of one load based prefetch access system according to one or more exemplary embodiments. The <figref idref="DRAWINGS">FIG. 3</figref> functional block diagram <b>300</b> shows, in the depicted combination with other devices, a plurality of N master devices, labeled <b>302</b>-<b>1</b>, <b>302</b>-<b>2</b>, <b>302</b>-<b>3</b> . . . <b>302</b>-N (generically referenced as <b>302</b>), each of which may be coupled through a respective master interconnect device, labeled <b>304</b>-<b>1</b>, <b>304</b>-<b>2</b>, <b>304</b>-<b>3</b> . . . <b>304</b>-N (generically references as <b>304</b>), respectively, to an interconnect <b>306</b>. Each of the master devices <b>302</b> may include, or have access to, a prefetch buffer such as the examples labeled <b>308</b>-<b>1</b>, <b>308</b>-<b>2</b>, <b>308</b>-<b>3</b> . . . <b>308</b>-N (generically referenced as <b>308</b>). With respect to the structure and control of the prefetch buffers <b>308</b>, it will be understood that unless explicitly stated otherwise, these may be implemented using conventional buffer structure and control.</p>
<p id="p-0030" num="0029">It will be understood that a &#x201c;master device&#x201d; is any device that can issue an interconnect request, and a &#x201c;slave device&#x201d; is any device that responds to an interconnect request. Further, the master devices <b>302</b> may be any type of processing entity, for example a microprocessor or other digital signal processor (DSP) embodied by, for example, an ASIC. Also, in the context of a master-slave prefetching, the &#x201c;master device&#x201d; may be any processing entity that can issue an interconnect request and is capable of executing applications or other processing tasks that involve prefetching from a slave memory to a prefetching buffer.</p>
<p id="p-0031" num="0030">It will be understood that &#x201c;interconnect,&#x201d; in the context of the interconnect <b>306</b>, means logic that routes access requests, access data, and other transaction data from any of the master interconnect devices <b>304</b>, to any slave interconnect device, e.g., the slave interconnect device <b>316</b> described at later sections. Any physical media may used for the interconnect <b>306</b>, for example, wire, cable, optical fiber, wireless, or any combination of the same. The interconnect <b>306</b> may include, for example, point-to-point switching connections (not shown), controlled by a bus arbiter (not shown). Alternatively the interconnect <b>306</b> may include multiple direct links (not shown). Further, the interconnect <b>306</b> may include a shared bus, channel, or link. Except where otherwise explicitly stated, or where made clear from the context to be otherwise, the interconnect <b>306</b> is not necessarily particular to the embodiments.</p>
<p id="p-0032" num="0031">Referring still to <figref idref="DRAWINGS">FIG. 3</figref>, the functional block diagram <b>300</b> shows a load based prefetch access system including a slave memory <b>310</b>, which in this example is a logical block that may comprise, for example, a memory <b>312</b> coupled to a slave memory control/load detecting device (MCL) <b>314</b> that in turn may be coupled to the interconnect <b>306</b> via a slave interconnect device <b>316</b>. It will be understood that the &#x201c;slave memory&#x201d; <b>310</b> is a functional block representing the collected functions of the MCL <b>314</b>, the slave interconnect device <b>316</b>, and the memory <b>312</b>, as seen from the master devices <b>302</b>. It will be understood that the label &#x201c;slave memory&#x201d; is an arbitrary term, not intended to limit the scope of structure or methods practicing the example embodiments. For example, functions of the MCL <b>314</b>, the slave interconnect device <b>316</b>, and the memory <b>312</b> may be implemented in a manner having a segmentation of hardware not necessarily corresponding to the <figref idref="DRAWINGS">FIG. 3</figref> logical block segmentation.</p>
<p id="p-0033" num="0032">It will be understood that the MCL <b>314</b> may be transparent to the master devices <b>302</b>, and may be configured to carry out on the memory <b>312</b> the access requests received from the master devices <b>302</b>. Examples of such carrying out of access requests by the MCL <b>314</b> include, but are not necessarily limited to, generating appropriate memory <b>312</b> control signals (e.g., read and write enable and clock pulses), presenting to the memory <b>312</b> properly timed address signals and write data, receiving read data from the memory <b>312</b> and sending that data back to the originating master device <b>302</b>.</p>
<p id="p-0034" num="0033">With continuing reference to <figref idref="DRAWINGS">FIG. 3</figref>, in accordance with one or more example embodiments the MCL <b>314</b> may include or may have access to a command queue <b>318</b> for queuing access commands within or otherwise associated with the access requests, to carry out on the memory <b>312</b>. In one aspect the MCL <b>314</b> may also have a queue <b>320</b> that may, for example, contain the scheduled command.</p>
<p id="p-0035" num="0034">In accordance with one or more example embodiments, one or both of the MCL <b>314</b> and the slave interconnect device <b>316</b> may be configured to detect a loading level of the MCL <b>314</b>. In one aspect, one or both of the MCL <b>314</b> and the slave interconnect device <b>316</b> may be configured to detect a loading level of the MCL <b>314</b> based on a quantity of access commands waiting in the command queue <b>318</b>. In another aspect, one or both of the MCL <b>314</b> and the slave interconnect device <b>316</b> may be configured to detect a loading level by, for example, detecting (not explicitly shown in <figref idref="DRAWINGS">FIG. 3</figref>) an average number of access requests the MCL <b>314</b> is receiving per unit time. In one aspect, one or both of the MCL <b>314</b> and the slave interconnect device <b>316</b> may be configured to generate, based on the detected load level, a corresponding load status data (hereinafter referenced by the arbitrary name &#x201c;LDST&#x201d;).</p>
<p id="p-0036" num="0035">Referring still to <figref idref="DRAWINGS">FIG. 3</figref>, in one aspect, one or both of the MCL <b>314</b> and the slave interconnect device <b>316</b> may be configured to maintain the LDST locally in, for example, a load status register or equivalent, such as the slave load status register <b>322</b>. In another related aspect, one or both of the MCL <b>314</b> and the slave interconnect device <b>316</b> may be configured to report, for example in response to an updating of its value, the locally maintained LDST to one or more of the master devices <b>302</b>. In still another aspect, one or more of the master devices <b>302</b> may be configured to query the slave memory <b>310</b> for the value of LDST it maintains locally in its slave load status register <b>322</b>. For example, one or more of the master devices <b>302</b> may be configured to send a load status update instruction (not shown in <figref idref="DRAWINGS">FIG. 3</figref>) to the slave memory <b>310</b>, in response to which the slave memory <b>310</b> may send the, for example, an updated LDST content of the slave load status register <b>322</b>.</p>
<p id="p-0037" num="0036">It will also be understood that the <figref idref="DRAWINGS">FIG. 3</figref> functional block diagram <b>300</b> shows a single slave interconnect device <b>316</b>, but this is not intended to limit the scope of any of the embodiments. For example, the depicted coupling link <b>332</b> of the slave memory <b>310</b> may encompass another interconnect (not shown) coupled by a bridge (not shown) to a slave interconnect device at the position shown for the slave interconnect device <b>316</b>. In such a case, an updated LDST may be maintained anywhere from which it may be seen by the master devices <b>302</b> as being associated with the slave memory <b>310</b>. As another illustration, the MCL <b>314</b> may encompass a portion of a multi-memory slave memory controller (not shown) that controls a plurality of separately addressed memory devices (not shown), one of which may be the memory <b>312</b>. In such a case, a separate LDST may be maintained for each of the memory devices. Likewise, only one slave memory <b>310</b> is shown, to introduce concepts without obfuscation by details not necessary to practicing according to the exemplary embodiments. Persons of ordinary skill in the art will be able, from this disclosure, to understand the same concepts as applied to any of the master devices <b>302</b> sending access requests to any one of a plurality of slave memories (not shown) that may be connected to the interconnect <b>306</b>. For example, each of a plurality of slave memories may generate and transmit to one or more of the master devices <b>302</b> its own respective LDST, using any of the various means described in reference to the slave memory <b>310</b>. One or more of the master devices <b>302</b> may then store or otherwise have access to this plurality of LDSTs, and then generate, schedule and/or transmit prefetch access requests to such slave memories, based on the corresponding LDSTs, as described in reference to the example slave memory <b>310</b>.</p>
<p id="p-0038" num="0037">Referring still to <figref idref="DRAWINGS">FIG. 3</figref>, an example load based prefetch system according to the functional block diagram <b>300</b> may, in one aspect, have one or more of the master devices <b>302</b> configured to locally store or maintain an updated copy, or other indicator of the LDST. For purposes of this description, this copy or other indicator of LDST maintained in one or more of the master devices <b>302</b> will be referenced herein as &#x201c;M-LDST&#x201d; to distinguish, for example, from the LDST stored local in the slave load status register <b>322</b> of the slave memory <b>310</b>. In one example, the master devices <b>302</b>-<b>1</b>, <b>302</b>-<b>2</b>, <b>302</b>-<b>3</b> . . . <b>302</b>-N may maintain the M-LDST for the slave memory <b>310</b> in a readily accessible local register or memory location, such as the depicted slave load monitor registers <b>330</b>-<b>1</b>, <b>330</b>-<b>2</b>, <b>330</b>-<b>3</b> . . . <b>330</b>-N (generically referenced as <b>330</b>). It will be understood that the slave load monitor registers <b>330</b> are functional blocks, not representative of any specific hardware or any specific register allocation scheme.</p>
<p id="p-0039" num="0038">With respect to updating the M-LDST stored in, for example, the slave load monitor registers <b>330</b> of the master devices <b>302</b>, various structures and methods will be apparent to persons of ordinary skill in the art upon reading this disclosure. For example, a load based prefetch system as shown by the functional block diagram <b>300</b> may be configured to update M-LDST values stored in the master device <b>302</b> internal slave load monitor registers <b>330</b> based on the slave memory <b>310</b> updating the LDST in the slave load status register <b>322</b>. As one further example, the slave memory <b>310</b> may be configured to detect an updating of the LDST in the slave load status register <b>322</b> by counting the number of requests in the command queue <b>318</b>, and may sample this number for a particular time interval and compare the sampled number to a predetermined light load/high load value. The particular time interval, or the predetermined light load/high load value, or both, may be either programmed or fixed. In one aspect, the slave memory <b>310</b> may be configured to send to one or more of the master devices <b>302</b> a &#x201c;light slave load&#x201d; notification, in response to an updating of the LDST value in the slave load status register <b>322</b>. In another aspect, the slave memory <b>310</b> may be configured to send an LDST updating packet (not shown in <figref idref="DRAWINGS">FIG. 3</figref>) to the master devices <b>302</b> regardless of the level of the LDST. Various methods and arrangements for sending such a &#x201c;light slave load&#x201d; notification, or sending an LDST updating packet will become apparent, based on this disclosure, to persons of ordinary skill in the art. For example, in response to a read access request from a master device <b>302</b>, the MCL <b>314</b> may append the LDST to the data it reads from the memory <b>312</b> and sends back to that master device <b>302</b>. The master device <b>302</b> may then update the M-LDST in its slave load monitor register <b>330</b>. As another example, the MCL <b>314</b> may include the LDST in an acknowledgment it sends to an originating master device <b>302</b> when carrying out a write access request on the memory <b>312</b>. These are only examples; other structures and/or processes to maintain an updated M-LDST in the slave load monitor register <b>330</b> may become apparent to persons of ordinary skill from this disclosure, or from practicing according to its exemplary embodiments.</p>
<p id="p-0040" num="0039">In the <figref idref="DRAWINGS">FIG. 3</figref> example load based prefetch system shown by the functional block diagram <b>300</b>, according to various exemplary embodiments, one or more of the master devices <b>302</b> may be configured to generate, schedule and/or transmit prefetch access requests to the slave memory <b>310</b> based, at least in part, on the load state of the slave memory <b>310</b>. In one aspect, one or more of the master devices <b>302</b> may be configured so that, when executing a thread for which prefetch access requests to the slave memory <b>310</b> are desired, the master device <b>302</b> generation or transmission of the prefetch access request is dependent, at least in part, on its locally stored M-LDST for that slave memory <b>310</b>. In another aspect, one or more of the master devices <b>302</b> may be configured so that when executing a thread for which prefetch access requests to the slave memory <b>310</b> may be appropriate, the generation or transmission of the prefetch access requests is dependent, at least in part, on receiving an updated LDST from the slave memory <b>310</b> indicating a light load. In another aspect, one or more of the master devices <b>302</b> may be configured so that when executing a thread for which prefetch access requests to the slave memory <b>310</b> may be appropriate, the master device may send a request for updated LDST to the slave memory <b>310</b> and, depending on the updated LDST that the master device <b>302</b> receives, the prefetch access request may, or may not be sent.</p>
<p id="p-0041" num="0040">Referring still to <figref idref="DRAWINGS">FIG. 3</figref>, it will be understood that the examples identified above are not intended to, and do not limit the scope of structures or methods contemplated by the exemplary embodiments by which master devices may generate, schedule and/or transmit prefetch access requests to the slave memory <b>310</b> based, at least in part, on load state. To illustrate, according to one aspect a master device <b>302</b> may be configured to generate prefetch access requests and, prior to transmission to the slave memory <b>310</b>, load the prefetch access request into a queue (not shown in <figref idref="DRAWINGS">FIG. 3</figref>) or other buffer (not shown in <figref idref="DRAWINGS">FIG. 3</figref>) local to the master device. Further to this aspect, a master device <b>302</b> may be configured to make transmission of the prefetch access request, from the queue or other buffer to the slave memory <b>310</b> conditional, at least in part, on the slave load state of the slave memory.</p>
<p id="p-0042" num="0041">It will be appreciated by persons of ordinary skill in the art that, among various other benefits and advantages provided by load-based prefetch access system or method according to the exemplary embodiments, there may be a significant decrease in prefetch latency and therefore a corresponding significant increase in prefetch performance. It will be understood by such persons that a result of this increase in prefetch performance may be that an internal buffer capacity of one or more of the master devices <b>302</b>, for example of internal buffers (not explicitly shown in <figref idref="DRAWINGS">FIG. 3</figref>) conventionally used for prefetch buffering may become a constraint. In one aspect, to remove potential for such a constraint, a shared buffer may be used. <figref idref="DRAWINGS">FIG. 4</figref> shows a functional schematic <b>400</b> of one load based prefetch system according to one exemplary embodiment that includes, as one example of such a shared buffer, the shared buffer <b>440</b>. It will be understood by persons of ordinary skill in the art, from reading this disclosure, determining which of the master devices <b>302</b> may benefit from such a shared buffer <b>440</b>, and determining the capacity of the shared buffer <b>440</b> will be substantially application-specific. Such persons, however, having view of this disclosure, will be readily able to configure such a shared buffer to perform in a manner commensurate with the exemplary embodiments and, therefore, further detailed description is omitted.</p>
<p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. 5</figref> shows a block flow diagram <b>500</b> of one example of a master device performing one or more of a generating, scheduling or transmitting prefetch access requests, based at least in part on a slave load, in a process according to one or more exemplary embodiments. To assist in understanding concepts shown by the block flow diagram <b>500</b>, example operations may be referenced to particular blocks of the <figref idref="DRAWINGS">FIG. 3</figref> functional block diagram <b>300</b>. It will be understood, however, that the described allocation of operations according to the block flow diagram <b>500</b> to blocks of the FIG. functional block diagram <b>300</b> describes only one example of such allocation for practicing a process as shown by the <figref idref="DRAWINGS">FIG. 5</figref> block flow diagram <b>500</b>, and is not intended as limiting the scope of any of the exemplary embodiments or any aspect thereof.</p>
<p id="p-0044" num="0043">Referring to <figref idref="DRAWINGS">FIG. 5</figref>, one example process according to the <figref idref="DRAWINGS">FIG. 5</figref> block flow diagram <b>500</b> may begin at an arbitrary starting state <b>502</b> that may be assumed, for purposes of example, as an idle state of a master device, e.g., a master device <b>302</b> of <figref idref="DRAWINGS">FIG. 3</figref>, or may be execution of a thread not pertaining to prefetch access requests. Next, for example in response to an event such as an input (not shown) at a user command interface (not shown), a process according to the block flow diagram <b>500</b> may go to <b>504</b> to execute a thread utilizing (including performing prefetch access of) a slave memory, for example the <figref idref="DRAWINGS">FIG. 3</figref> slave memory <b>310</b>.</p>
<p id="p-0045" num="0044">Referring to <figref idref="DRAWINGS">FIG. 5</figref>, in one aspect a transition from the arbitrary starting state <b>502</b> to executing the thread at <b>504</b> may include initializing (not shown) the indicators of the load status of the slave device(s) with which the thread will interact, e.g., setting the <figref idref="DRAWINGS">FIG. 3</figref> master device(s) <b>302</b> internal slave load monitor register <b>330</b> corresponding to the slave memory <b>310</b> to a default M-LDST, and/or setting the LDST in the slave load status register <b>322</b> to a default value. The default value of LDST and M-LDST may, for example, indicate a heavy slave load or may indicate a light slave load. In another aspect, transition from the arbitrary starting state <b>502</b> to executing the thread at <b>504</b> may include the master device sending a load status query (not shown) to the slave device(s) with which the thread will interact. For example, the <figref idref="DRAWINGS">FIG. 3</figref> master device <b>302</b> may send a query to the slave interconnect device <b>316</b> to report the LDST content of the slave load status register <b>322</b>, and then the master device <b>302</b> may, upon receiving the updated LDST, update the M-LDST value in its slave load monitor register <b>330</b>. In another aspect, the previously described &#x201c;initialization&#x201d; in transitioning from the arbitrary start state <b>502</b> to executing the thread may be omitted and, instead, be performed by a first updating at <b>506</b> of the slave device's local indicator of load status and/or the master device's locally stored indicator of the slave memory load status, as described in greater detail below.</p>
<p id="p-0046" num="0045">Referring still to <figref idref="DRAWINGS">FIG. 5</figref>, in one aspect, concurrent with executing the thread at <b>504</b> there may be at <b>506</b> one or more updates of the slave device's local indicator of load status and/or the master device's locally stored indicator of the slave memory load status. For example, referring to <figref idref="DRAWINGS">FIG. 3</figref>, in the course of the master device <b>302</b> sending data read requests to the slave memory <b>310</b> and receiving read data results, or the master device <b>302</b> sending data write access to the slave memory <b>310</b> and receiving write confirmation, the LDST content of the slave load status register <b>322</b> slave memory and the M-LDST content of the master device's slave load monitor register <b>330</b> may be updated. In one example slave load indicator updating at <b>506</b>, according to one aspect, at <b>5062</b> the slave memory may generate a response to master device access request, for example data read from the slave memory, then goes to <b>5064</b> to transmit to the master device the response generated at <b>5062</b>, appended with or otherwise including an updated value of its local slave load indicator. Continuing with the example, at <b>5066</b> the master device may receive the response having the updated slave device load status and updates the master device's locally stored slave device load status indicator.</p>
<p id="p-0047" num="0046">Referring to <figref idref="DRAWINGS">FIG. 3</figref>, one example of the slave load indicator updating at <b>506</b> may include the slave memory <b>310</b> sending to the slave interconnect device <b>316</b> a response to a master device <b>302</b> access request, followed by the slave interconnect device <b>316</b> appending or otherwise including the LDST value from the slave load status register <b>322</b> and sending this to the master device <b>302</b>. The master device <b>302</b> may then receive the response having the updated LDST, and then update the M-LDST in its slave load monitor register <b>330</b> accordingly.</p>
<p id="p-0048" num="0047">Continuing with <figref idref="DRAWINGS">FIG. 5</figref>, in one example process according to the block flow diagram <b>500</b> at <b>508</b> a prefetch condition may be determined and met, in one aspect, on the load state of a slave device, for example the slave memory <b>310</b>. Stated differently, in one aspect a prefetch may be a default or background process that monitors or otherwise detects a slave device load state and, when a given load condition is detected, a prefetch is performed. In another aspect, a prefetch access request condition may be met at <b>508</b> using a triggering or initiation of a prefetch in accordance with conventional prefetch processes, combined with configuring the actual generation and/or transmission of the prefetch access request to be dependent, entirely or in part as provided by the various aspects, on the load state of the slave memory. Further to this aspect, with respect to such conventional prefetch access request conditions that may be met at <b>508</b>, conventional process(es) for generating the conditions, and type(s) of prefetch that may relate to the condition, persons of ordinary skill in the art may readily select and arrange these, in combination with the present disclosure, to practice according to the exemplary embodiments. Further detailed description of such conventional prefetching is therefore omitted.</p>
<p id="p-0049" num="0048">With continuing reference to the <figref idref="DRAWINGS">FIG. 5</figref> block flow diagram <b>500</b>, the meeting of the prefetch condition at <b>508</b> is shown as being prior, with respect to the flow direction, to the master device determining the load status of the slave memory, which is described below in reference to blocks <b>510</b> and <b>512</b>. It will be understood, though, that <b>508</b> shows only example sequence position, relative to the functions represented by blocks <b>510</b> and <b>512</b>, for meeting a prefetch condition, and therefore block <b>508</b> may be placed at alternative positions within the block flow diagram <b>500</b>. For example, as will be appreciated by persons of ordinary skill in the art from this disclosure, a block (not shown) representing a meeting of a prefetch condition may be placed to be dependent on the determining the load status of the slave memory.</p>
<p id="p-0050" num="0049">Referring to <figref idref="DRAWINGS">FIG. 5</figref>, it will be assumed that in one example process according to the block flow diagram <b>500</b>, the meeting of the prefetch condition at <b>508</b> may be an event associated with execution of the thread, whereupon the process may go to <b>510</b> to determine the slave load state. It will be understood that prefetch conditions or events that may embody or implement meeting a prefetch condition at <b>508</b> encompass, for example and without limitation, conventional hardware based prefetch conditions or triggers, for example a hardware logic (not shown) detecting a miss on a cache block (not shown), as well as conventional software prefetch conditions or triggers, for a example a prefetch instruction inserted in a program. As another illustration of hardware based prefetch conditions that may embody or implement meeting a prefetch condition at <b>508</b>, prefetch hardware logic (not shown) may be included in, or associated with a master device, and such logic may be configured to determine the prefetch address and when to initiate the prefetch. It will be understood that these are only examples, and are not intended as any limitation on the scope of any of the exemplary embodiments, or on any aspect of any embodiment. Further, persons of ordinary skill in the art will readily understand, from reading this disclosure with the knowledge that such persons possess of the various types, objectives, selection guidelines and design tools for prefetching, and the available structures and methods for implementing such designs, how to select from among, design, implement, and use various prefetchings for practicing according to the exemplary embodiments. For this reason, it will be readily understood by such persons, further detailed description of the specific prefetching conditions that may be met at <b>508</b> is not necessary and, therefore, is omitted.</p>
<p id="p-0051" num="0050">With continuing reference to <figref idref="DRAWINGS">FIG. 5</figref>, according to one aspect, determining the slave load state at <b>510</b> may include comparing a parameter indicative of load state against a &#x201c;heavy load&#x201d; threshold (not explicitly shown). Referring to <figref idref="DRAWINGS">FIG. 3</figref>, this determining of the slave load state at <b>510</b> may be performed by, for example, one of the master devices <b>302</b> comparing the M-LDST value in its slave load monitor register <b>330</b> to a given threshold (not shown). It will be understood that this is only one example, and that various alternative determinations of the slave load status will be apparent, from this disclosure, to persons of ordinary skill in the art. Referring still to <figref idref="DRAWINGS">FIG. 5</figref>, after determining the slave load process at <b>510</b>, one example process according to the block flow diagram <b>500</b> may go the decision block <b>512</b>. In one aspect, if the slave load status was determined at <b>510</b> as a &#x201c;heavy load&#x201d; state the process may, as shown by the decision block <b>512</b>, return to <b>504</b> and continue executing the thread at <b>504</b> and, in one aspect, updating the slave load status at <b>506</b>. If, however, the slave load status was determined at <b>510</b> as a &#x201c;light load&#x201d; an example process according to the block flow diagram <b>500</b>, in accordance with the decision block <b>512</b>, go to <b>514</b> to perform a prefetch access. It will be appreciated that execution of the prefetch access at <b>514</b> may provide a lower average latency, due to the exemplary embodiments' feature of transmitting, and executing prefetch access requests during light loading of the slave memory. It will also be appreciated that the execution of the prefetch access at <b>514</b>, being conditional on the slave memory having a light load state, may provide substantial temporal balancing of the load on the slave memory. As shown by <figref idref="DRAWINGS">FIG. 5</figref>, in one process according to the block flow diagram <b>500</b>, after performing the prefetch at <b>514</b> the process may return to executing the thread at <b>504</b> and, concurrently, updating the slave load status as shown at <b>506</b>.</p>
<p id="p-0052" num="0051">Referring still to <figref idref="DRAWINGS">FIG. 5</figref> and its block flow diagram <b>500</b>, it will be understood performing a prefetch by meeting a prefetch condition such as shown at <b>508</b>, and then performing the prefetch subject to determining the slave memory is at a &#x201c;light load&#x201d; state, is only one example of a load-based prefetch according to the exemplary embodiments. For example, in one aspect, the slave memory may be configured to check its load status and, if a &#x201c;light load&#x201d; is detected, to send a &#x201c;light slave load&#x201d; notification to one or more master devices. As also described, in a related aspect one or more of the master devices may be configured to respond to receiving a &#x201c;light slave load&#x201d; notification by performing a prefetch. Referring to <figref idref="DRAWINGS">FIG. 5</figref>, the block flow diagram <b>500</b> shows one example of such a load-based prefetch the master device receiving at <b>516</b> a &#x201c;light slave load&#x201d; notification from the slave device and, in response, going to <b>514</b> and performing a prefetch. It will be understood that going from block <b>516</b> to <b>514</b> may not necessarily be unconditional and, instead, may be conditional on various factors, for example the state of execution at <b>504</b> of the thread. Such conditions and factors, though, are readily identified by persons of ordinary skill in the art, and therefore are omitted from <figref idref="DRAWINGS">FIG. 5</figref>.</p>
<p id="p-0053" num="0052">Continuing to refer to <figref idref="DRAWINGS">FIG. 5</figref>, another example aspect according to the exemplary embodiments for load based prefetch access is shown by the block flow diagram <b>500</b>. More particularly, as previously described, the slave memory may be configured to check its load status and, if a &#x201c;heavy load&#x201d; is detected, to send a &#x201c;heavy slave load&#x201d; notification to one or more master devices. As also described, in a related aspect one or more of the master devices may be configured to respond to receiving a &#x201c;heavy slave load&#x201d; notification by delaying, or postponing performing a prefetch. The block flow diagram <b>500</b> shows one example at <b>518</b> of the master device receiving a &#x201c;heavy slave load&#x201d; notification. In one aspect, upon receiving the &#x201c;heavy slave load&#x201d; notification at, for example <b>518</b>, a prefetch may be delayed, cancelled, or otherwise re-scheduled. The <figref idref="DRAWINGS">FIG. 5</figref> block flow diagram <b>500</b> represents by flow line <b>520</b> returning to the state <b>504</b> of executing the thread, various alternative actions such as, without limitation, delaying, canceling, or otherwise re-scheduling the prefetch.</p>
<p id="p-0054" num="0053">It will be appreciated that this feature by which a slave memory may send to a master device a &#x201c;heavy slave load&#x201d; notification effectively provides for the slave memory to send the master device a prefetch delay or prefetch postpone request. It will also be readily understood and appreciated by persons of ordinary skill in the art that the above-described aspects of a slave device configured to send to a master device a load status notification, such as the example &#x201c;light slave load&#x201d; or &#x201c;heavy slave load&#x201d; notification described above, effectively provide a feature by which a slave memory may control a master device scheduling of prefetch access requests. Stated differently, features according to the exemplary embodiments such as the &#x201c;light slave load&#x201d; or &#x201c;heavy slave load&#x201d; notification may effectively provide for the slave memory to send &#x201c;prefetch request scheduling data&#x201d; to the master devices.</p>
<p id="p-0055" num="0054"><figref idref="DRAWINGS">FIG. 6</figref> is a computer simulation showing a system of master devices <b>302</b> and a slave memory <b>310</b> as depicted at <figref idref="DRAWINGS">FIG. 3</figref>, operating according to methods of the exemplary embodiments. It may be assumed that the <figref idref="DRAWINGS">FIG. 6</figref> computer simulation is of a method and/or apparatus according to the exemplary embodiments performing the same given benchmark task used for the <figref idref="DRAWINGS">FIG. 2</figref> simulation. The periods of predominantly read accesses are, like in <figref idref="DRAWINGS">FIG. 2</figref>, indicated in black and the periods of predominantly write accesses are indicated cross-hatching.</p>
<p id="p-0056" num="0055">It is immediately seen that the <figref idref="DRAWINGS">FIG. 6</figref> access density is essentially constant, having an access density slightly higher during intervals NHT<b>1</b>, NHT<b>2</b>, and NHT<b>3</b> that is approximately 13,000 accesses per sub-interval, which is only slightly greater than the approximately 11,000 average for accesses per sub-interval exhibited during the slightly lighter access density sub-intervals NLT<b>1</b>, NLT<b>2</b> and NLT<b>3</b>.</p>
<p id="p-0057" num="0056">Among additional benefits of load based prefetch access features of the exemplary embodiments, are seen in the <figref idref="DRAWINGS">FIG. 6</figref> simulation, is an increased data transfer rate for master-slave transactions to reduce by at least one-half the time required for a given task. This is readily seen by the total interval NTT on the <figref idref="DRAWINGS">FIG. 6</figref> simulation <b>600</b> for performing the benchmark task being approximately one-half the TT interval that the <figref idref="DRAWINGS">FIG. 2</figref> simulation <b>200</b> of a conventional master-slave system.</p>
<p id="p-0058" num="0057">It will be understood that the labeling of &#x201c;master&#x201d; and &#x201c;slave&#x201d; used in this description may be only for purposes of a given transaction. For example, it is contemplated that one or more of the master devices <b>302</b> and another device (not shown) coupled to the interconnect <b>306</b> as a slave device, may each be a microprocessor having a local memory. It is contemplated that in such an arrangement each microprocessor may be respectively configured to perform a described master slave-transaction, and each may be reconfigured to perform a reversal of their respective roles.</p>
<p id="p-0059" num="0058"><figref idref="DRAWINGS">FIG. 7</figref> illustrates an exemplary wireless communication system <b>700</b> in which one or more embodiments of the disclosure may be advantageously employed. For purposes of illustration, <figref idref="DRAWINGS">FIG. 7</figref> shows three remote units <b>720</b>, <b>730</b>, and <b>750</b> and two base stations <b>740</b>. It will be recognized that conventional wireless communication systems may have many more remote units and base stations. The remote units <b>720</b>, <b>730</b>, and <b>750</b> include semiconductor devices <b>725</b>, <b>735</b> and <b>755</b> which are among embodiments of the disclosure as discussed further below. <figref idref="DRAWINGS">FIG. 7</figref> shows forward link signals <b>780</b> from the base stations <b>740</b> and the remote units <b>720</b>, <b>730</b>, and <b>750</b> and reverse link signals <b>790</b> from the remote units <b>720</b>, <b>730</b>, and <b>750</b> to the base stations <b>740</b>.</p>
<p id="p-0060" num="0059">In <figref idref="DRAWINGS">FIG. 7</figref>, the remote unit <b>720</b> is shown as a mobile telephone, the remote unit <b>730</b> is shown as a portable computer, and the remote unit <b>750</b> is shown as a fixed location remote unit in a wireless local loop system. For example, the remote units may be mobile phones, hand-held personal communication systems (PCS) units, portable data units such as personal data assistants, navigation devices (such as GPS enabled devices), set top boxes, music players, video players, entertainment units, fixed location data units such as meter reading equipment, or any other device that stores or retrieves data or computer instructions, or any combination thereof. Although <figref idref="DRAWINGS">FIG. 7</figref> illustrates remote units according to the teachings of the disclosure, the disclosure is not limited to these exemplary illustrated units. The disclosed device may be suitably employed in any device which includes a semiconductor device with an on-chip voltage regulator.</p>
<p id="p-0061" num="0060">Those of skill in the art will appreciate that information and signals may be represented using any of a variety of different technologies and techniques. For example, data, instructions, commands, information, signals, bits, symbols, and chips that may be referenced throughout the above description may be represented by voltages, currents, electromagnetic waves, magnetic fields or particles, optical fields or particles, or any combination thereof.</p>
<p id="p-0062" num="0061">Further, those of skill in the art will appreciate that the various illustrative logical blocks, modules, circuits, and algorithm steps described in connection with the embodiments disclosed herein may be implemented as electronic hardware, computer software, or combinations of both. To clearly illustrate this interchangeability of hardware and software, various illustrative components, blocks, modules, circuits, and steps have been described above generally in terms of their functionality. Whether such functionality is implemented as hardware or software depends upon the particular application and design constraints imposed on the overall system. Skilled artisans may implement the described functionality in varying ways for each particular application, but such implementation decisions should not be interpreted as causing a departure from the scope of the present invention.</p>
<p id="p-0063" num="0062">The methods, sequences and/or algorithms described in connection with the embodiments disclosed herein may be embodied directly in hardware, in a software module executed by a processor, or in a combination of the two. A software module may reside in RAM memory, flash memory, ROM memory, EPROM memory, EEPROM memory, registers, hard disk, a removable disk, a CD-ROM, or any other form of storage medium known in the art. An exemplary storage medium is coupled to the processor such that the processor can read information from, and write information to, the storage medium. In the alternative, the storage medium may be integral to the processor.</p>
<p id="p-0064" num="0063">Accordingly, an embodiment of the invention can include a computer readable media embodying a method for performing access request based on slave memory load. Accordingly, the invention is not limited to illustrated examples and any means for performing the functionality described herein are included in embodiments of the invention.</p>
<p id="p-0065" num="0064">While the foregoing disclosure shows illustrative embodiments of the invention, it should be noted that various changes and modifications could be made herein without departing from the scope of the invention as defined by the appended claims. The functions, steps and/or actions of the method claims in accordance with the embodiments of the invention described herein need not be performed in any particular order. Furthermore, although elements of the invention may be described or claimed in the singular, the plural is contemplated unless limitation to the singular is explicitly stated.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for controlling master-slave memory accessing, comprising:
<claim-text>executing a thread, wherein the executing includes a master device sending access requests through an interconnect to a slave memory;</claim-text>
<claim-text>detecting at the slave memory, during the executing of the thread, a slave load state of the slave memory and generating a slave load status data indicating a result of the detecting;</claim-text>
<claim-text>communicating the slave load status data from the slave memory, through the interconnect, to the master device; and</claim-text>
<claim-text>based at least in part on the slave load status data indicating a given load condition, communicating an access request from the master device, through the interconnect, to the slave memory.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said access request is a prefetch access request, and wherein communicating the access request includes:
<claim-text>generating at the master device a prefetch access request;</claim-text>
<claim-text>loading the prefetch request into a prefetch buffer local to the master device; and</claim-text>
<claim-text>conditional on the slave load state indicated by the slave load status data received at the master device, transmitting the prefetch access request from the prefetch buffer, through the interconnect and to the slave memory.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said access request is a prefetch access request, and wherein communicating the access request includes scheduling a communicating of at least one prefetch access request based, at least in part, on the slave load status data.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>communicating a read access request, associated with the thread, from the master device to the slave memory;</claim-text>
<claim-text>retrieving at the slave memory a read result corresponding to the read access request, and communicating the read result from the slave memory, through the interconnect, to the master device,
<claim-text>wherein communicating the slave load status data from the slave memory comprises communicating the slave load status data with the read result with.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the access request is a prefetch access request, wherein detecting the slave load state includes detecting at the slave memory a heavy slave load state, and generating, as a resulting slave load status data, a heavy slave load notification, and
<claim-text>wherein communicating the access request includes delaying communicating the access request in response to the master device receiving the heavy slave load notification.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein detecting the slave load state includes determining at the slave memory whether a load status meets a light load threshold, and generating, as a resulting slave load status data, a light slave load notification,
<claim-text>and wherein communicating the access request includes communicating at least one prefetch access request to the slave memory in response to the master device receiving the light slave load notification.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said access request includes an associated access command, wherein said method further comprises the slave memory placing said associated access command in a slave memory command queue for execution by the slave memory, and wherein the slave load status data is based, at least in part, on a quantity of access commands in the slave memory command queue.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein detecting the slave load state of the slave memory includes determining a quantity of access commands received at the slave memory over an interval, and generating the resulting load status data to indicate the determined quantity.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising storing, in a slave load monitor register local to the master device, the slave load status data received from the slave memory, wherein the communicating an access request is based, at least in part, on the slave load status data stored in the slave load monitor register.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, further comprising initializing, in association with a start of the thread, the slave load monitor register to a default value.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, further comprising sending, in association with a start of the thread executing a thread, a load status query to the slave memory, wherein communicating the slave load status data includes the slave memory communicating the slave load status data from the slave memory to the master device in response to the slave memory receiving the slave load status query.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>storing, in a slave load status register local to the slave memory a result of detecting;</claim-text>
<claim-text>repeating the detecting the slave state; and</claim-text>
<claim-text>based on the repeating, updating the slave load status register with the result of the repeating.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method of <claim-ref idref="CLM-00012">claim 12</claim-ref>, further comprising sending, in association with a start of the thread, a load status query from the master device to the slave memory, wherein communicating the slave load status data includes communicating a current updated slave load status data from the slave load status register to the master device.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. A method for controlling a scheduling, from a slave memory, a master device prefetching, comprising:
<claim-text>detecting at the slave memory a load level of the slave memory;</claim-text>
<claim-text>comparing, at the slave memory, a result of the detecting to a given load threshold;</claim-text>
<claim-text>generating at the slave memory a prefetch scheduling data based on a result of the comparing; and</claim-text>
<claim-text>communicating the prefetch scheduling data through an interconnect to the master device.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the given load threshold is a given light load threshold, and wherein the detecting the light load level comprises detecting a quantity of given access commands received at the slave memory over an interval, and the generating comprises generating, in response to the comparing indicating said quantity being less than the given light load threshold, a prefetch send request as the prefetch scheduling data.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The method of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein detecting the load level comprises detecting a quantity of given access commands received at the slave memory over an interval, and the generating comprises generating, in response to the comparing indicating said quantity being greater than a given heavy load threshold, a prefetch delay request as the prefetch scheduling data.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The method of <claim-ref idref="CLM-00014">claim 14</claim-ref>, further comprising:
<claim-text>storing the prefetch scheduling data in a slave load status register local to the slave memory;</claim-text>
<claim-text>repeating the detecting the slave state and, based on the repeating, updating the slave load status register with the result of the repeating;</claim-text>
<claim-text>repeating, in association with at least one repeating the detecting, the comparing; and</claim-text>
<claim-text>conditional upon a result of the comparing, communicating another prefetch scheduling data from the slave memory, through the interconnect, to the master device.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. A master-slave memory apparatus, comprising:
<claim-text>a master device configured to execute a thread, wherein the executing includes sending access requests to a slave memory;</claim-text>
<claim-text>means within the slave memory for detecting, during the executing the thread, a slave load state of the memory and generating a slave load status data indicating a result of the detecting;</claim-text>
<claim-text>means for communicating the slave load status data from the slave memory, through an interconnect, to the master device; and</claim-text>
<claim-text>means for communicating a prefetch access request from the master device to which the slave load status data was communicated, through the interconnect, to the slave memory based, at least in part, on the slave load status data.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The master-slave memory apparatus of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein detecting the slave load state comprises detecting a heavy load state and generating as the resulting slave load status data, a heavy slave load notification, and wherein said means for communicating a prefetch access request is configured to delay the communicating in response to receiving the heavy slave load notification.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The master-slave memory apparatus of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the apparatus is integrated in at least one semiconductor die.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The master-slave memory apparatus of <claim-ref idref="CLM-00018">claim 18</claim-ref>, further comprising a unit, selected from the group consisting of a set top box, music player, video player, entertainment unit, navigation device, communications device, personal digital assistant (PDA), fixed location data unit, and a computer, into which the master-slave memory apparatus is integrated.</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. The master-slave memory apparatus of <claim-ref idref="CLM-00018">claim 18</claim-ref>, further comprising means for sending from the master device to the slave memory a load status query,
<claim-text>wherein the means for communicating the slave load status data is configured to communicate the slave load status data in response to receiving the slave load status query.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00023" num="00023">
<claim-text>23. An apparatus for controlling a master device prefetch access request scheduling, from a slave memory, comprising:
<claim-text>means for detecting at the slave memory a load level of the slave memory;</claim-text>
<claim-text>means for comparing, at the slave memory, a result of the detecting to a given load threshold;</claim-text>
<claim-text>means for generating at the slave memory a prefetch scheduling data based on a result of the comparing; and</claim-text>
<claim-text>means for communicating the prefetch scheduling data through an interconnect to the master device.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00024" num="00024">
<claim-text>24. The apparatus of <claim-ref idref="CLM-00023">claim 23</claim-ref>, wherein the given load threshold is a given light load threshold, wherein the means for detecting the light load level is configured to detect a quantity of given access commands received at the slave memory over an interval, and wherein the means for generating a prefetch scheduling data is configured to generate, in response to the comparing indicating said quantity being less than the given light load threshold, a prefetch send request as the prefetch scheduling data.</claim-text>
</claim>
<claim id="CLM-00025" num="00025">
<claim-text>25. The apparatus of <claim-ref idref="CLM-00023">claim 23</claim-ref>, wherein the means for detecting the load level is configured to detect a quantity of given access commands received at the slave memory over an interval, and
<claim-text>wherein the means for generating the prefetch scheduling data is configured to generate, in response to the comparing indicating said quantity being greater than a given heavy load threshold, a prefetch delay request as the prefetch scheduling data.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00026" num="00026">
<claim-text>26. The apparatus of <claim-ref idref="CLM-00023">claim 23</claim-ref>, wherein the apparatus is integrated in at least one semiconductor die.</claim-text>
</claim>
<claim id="CLM-00027" num="00027">
<claim-text>27. The apparatus of <claim-ref idref="CLM-00023">claim 23</claim-ref>, further comprising a unit, selected from group consisting of a set top box, music player, video player, entertainment unit, navigation device, communications device, personal digital assistant (PDA), fixed location data unit, and a computer, into which the apparatus is integrated.</claim-text>
</claim>
<claim id="CLM-00028" num="00028">
<claim-text>28. The apparatus of <claim-ref idref="CLM-00023">claim 23</claim-ref>, wherein the means for detecting the slave state is configured to repeat the detecting the slave state and, based on the repeat, update a slave load status data local to the slave memory,
<claim-text>wherein the means for comparing is configured to repeat the comparing in association with at least one repeat of the detecting, and</claim-text>
<claim-text>wherein the means for communicating the prefetch scheduling data is configured to communicate, conditional upon a result of the repeat comparing, another prefetch scheduling data from the slave memory, through the interconnect, to the master device.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00029" num="00029">
<claim-text>29. A computer product having a non-transitory computer readable storage medium comprising instructions that, when read and executed by a processor, cause the processor to perform operations for controlling master-slave memory accessing, the instructions comprising:
<claim-text>instructions that cause the processor to execute a thread, wherein the executing includes the master device sending access requests through an interconnect to a slave memory;</claim-text>
<claim-text>instructions that cause the processor to detect at a slave memory, while executing the thread, a slave load state of the slave memory and generate a slave load status data indicating a result of the detecting;</claim-text>
<claim-text>instructions that cause the processor to communicate the slave load status data from the slave memory, through the interconnect, to the master device; and</claim-text>
<claim-text>instructions that cause the processor to communicate, based at least in part on the slave load status data indicating a given load condition, an access request from the master device to which the slave load status data was communicated, through the interconnect, to the slave memory.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00030" num="00030">
<claim-text>30. The computer product of <claim-ref idref="CLM-00029">claim 29</claim-ref>, wherein said access request is a prefetch access request, and wherein the instructions that cause the processor to communicate the prefetch access request include
<claim-text>instructions that cause the processor to generate a prefetch access request;</claim-text>
<claim-text>instructions that cause the processor to load the prefetch request into a prefetch buffer local to the master device; and</claim-text>
<claim-text>instructions that cause the processor to transmit, conditional upon the slave load condition indicated by the load status data received at the master device, the prefetch access request from the prefetch buffer, through the interconnect and to the slave memory.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00031" num="00031">
<claim-text>31. The computer product of <claim-ref idref="CLM-00029">claim 29</claim-ref>, wherein said access request is a prefetch access request, and wherein the instructions that cause the processor to communicate the prefetch access request include instructions that cause the processor to schedule said communicating of the prefetch access request based, at least in part, on the detected slave load status data.</claim-text>
</claim>
<claim id="CLM-00032" num="00032">
<claim-text>32. The computer product of <claim-ref idref="CLM-00029">claim 29</claim-ref>, wherein the computer readable medium further comprises:
<claim-text>instructions that cause the processor to communicate, in association with the thread, a read access request from the master device to the slave memory; and</claim-text>
<claim-text>instructions that cause the processor to retrieve from the slave memory a read result corresponding to the read access request, and to communicate the read result from the slave memory, through the interconnect, to the master device,</claim-text>
<claim-text>wherein the instructions that cause the processor to communicate the read result with the load status data to the master device.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00033" num="00033">
<claim-text>33. The computer product of <claim-ref idref="CLM-00029">claim 29</claim-ref>, wherein the access request is a prefetch access request, wherein the instructions that cause the processor to detect the slave load state include instructions that cause the processor to detect a heavy load state and generate, as a resulting slave load status data, a heavy slave load notification, and wherein the instructions that cause the processor to communicate the prefetch access request include instructions that cause the processor to delay the communicating in response to the master device receiving the heavy slave load notification.</claim-text>
</claim>
<claim id="CLM-00034" num="00034">
<claim-text>34. The computer product of <claim-ref idref="CLM-00029">claim 29</claim-ref>, wherein the instructions that cause the processor to detect the slave load state include instructions that cause the processor to determine at the slave memory whether a load status meets a light load threshold and, in response said determining, to generate a light slave load notification, and wherein the instructions that cause the processor to communicate the access request include instructions that cause the processor to communicate the access request in response to receiving the light slave load notification.</claim-text>
</claim>
<claim id="CLM-00035" num="00035">
<claim-text>35. The computer product of <claim-ref idref="CLM-00029">claim 29</claim-ref>, wherein the non-transitory computer readable storage medium further comprises instructions that cause the processor to place an access command associated with an access request received from the master device in a command queue of the slave memory for execution by the slave memory, and to detect the slave load status based, at least in part, on a quantity of access commands in the slave memory command queue.</claim-text>
</claim>
<claim id="CLM-00036" num="00036">
<claim-text>36. The computer program product of <claim-ref idref="CLM-00029">claim 29</claim-ref>, wherein the non-transitory computer readable storage medium further comprises instructions that cause the processor to store, in a slave load monitor register local to the master device, the slave load status data received from the slave memory,
<claim-text>wherein the instructions that cause processor to communicate an access request include instructions that cause the processor to communicate the access request based, at least in part, on the slave load status data stored in the slave load monitor register.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00037" num="00037">
<claim-text>37. The computer program product of <claim-ref idref="CLM-00036">claim 36</claim-ref>, wherein the non-transitory computer readable storage medium further comprises:
<claim-text>instructions that cause the processor to initialize, in association with a start of the thread, the slave load monitor register to a default value.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00038" num="00038">
<claim-text>38. The computer program product of <claim-ref idref="CLM-00036">claim 36</claim-ref>, wherein the non-transitory computer readable storage medium further comprises:
<claim-text>instructions that cause the processor to send, in association with a start of the thread, a load status query from the master device to the slave memory,</claim-text>
<claim-text>wherein the instructions that cause the processor to communicate the slave load status data include instructions that cause the processor to communicate, from the slave memory to the master device, the slave load status data in response to receiving the slave load status query.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00039" num="00039">
<claim-text>39. The computer program product of <claim-ref idref="CLM-00029">claim 29</claim-ref>, wherein the non-transitory computer readable storage medium further comprises:
<claim-text>instructions that cause the processor to store a result of detecting the slave load state, in a slave load status register local to the slave memory;</claim-text>
<claim-text>instructions that cause the processor to repeat the detecting the slave state and, based on the repeat, to update the slave load status register with the result of the repeating.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00040" num="00040">
<claim-text>40. The computer program product of <claim-ref idref="CLM-00039">claim 39</claim-ref> wherein the non-transitory computer readable storage medium further comprises:
<claim-text>instructions that cause the processor to send, in association with a start of the thread, a load status query from the master device to the slave memory,</claim-text>
<claim-text>wherein the instructions that cause the processor to communicate the slave load status data from the slave memory to the master device include instructions that cause the processor to communicate, in response to the slave memory receiving the load status query, a current updated slave load status data from the slave load status register to the master device.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00041" num="00041">
<claim-text>41. A computer product having a non-transitory computer readable storage medium comprising instructions that, when read and executed by a processor, cause the processor to perform operations for controlling a scheduling, from a slave memory, of a master device prefetching, the instructions comprising:
<claim-text>instructions that cause the processor to detect at the slave memory a load level of the slave memory;</claim-text>
<claim-text>instructions that cause the processor to compare, at the slave memory, a result of the detecting to a given load threshold;</claim-text>
<claim-text>instructions that cause the processor to generate at the slave memory a prefetch scheduling data based on a result of the compare; and</claim-text>
<claim-text>instructions that cause the processor to communicate the prefetch scheduling data, though an interconnect, to the master device.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00042" num="00042">
<claim-text>42. The computer product of <claim-ref idref="CLM-00041">claim 41</claim-ref>, wherein the given load threshold is a given light load threshold, wherein the instructions that cause the processor to detect the light load level include instructions that cause the processor to detect a quantity of given access commands received at the slave memory over an interval, and wherein the instructions that cause the processor to generate include instructions that cause the processor to generate, in response to the compare indicating said quantity being less than the given light load threshold, a prefetch send request as the prefetch scheduling data.</claim-text>
</claim>
<claim id="CLM-00043" num="00043">
<claim-text>43. The computer product of <claim-ref idref="CLM-00041">claim 41</claim-ref>, wherein the instructions that cause the processor to detect the load level include instructions that cause the processor to detect a quantity of given access commands received at the slave memory over an interval, and to compare the quantity to the given heavy load threshold.</claim-text>
</claim>
<claim id="CLM-00044" num="00044">
<claim-text>44. The computer program product of <claim-ref idref="CLM-00041">claim 41</claim-ref> wherein the non-transitory computer readable storage medium further comprises:
<claim-text>instructions that cause the processor to store the prefetch scheduling data in a slave load status register local to the slave memory;</claim-text>
<claim-text>instructions that cause the processor to repeat the detecting the slave state and, based on the repeat, to update the slave load status register with a result of the repeating;</claim-text>
<claim-text>instructions that cause the processor to repeat the compare, in association with at least one repeat of the detecting; and</claim-text>
<claim-text>instructions that cause the processor to communicate, conditional upon a result of the comparing, another prefetch scheduling data from the slave memory, through the interconnect, to the master device.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00045" num="00045">
<claim-text>45. A method for controlling master-slave memory accessing, comprising:
<claim-text>step of executing a thread at a master device, wherein the executing includes the master device sending access requests through an interconnect to a slave memory;</claim-text>
<claim-text>step of detecting at a slave memory, during the executing the thread, a slave load state of the slave memory and generating a slave load status data indicating a result of the detecting;</claim-text>
<claim-text>step of communicating the slave load status data from the slave memory, through the interconnect, to the master device; and</claim-text>
<claim-text>step of communicating, based at least in part on the slave load status data indicating a given load condition, an access request from the master device to which the slave load status data was communicated, through the interconnect, to the slave memory.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00046" num="00046">
<claim-text>46. The method of <claim-ref idref="CLM-00045">claim 45</claim-ref>, wherein communicating the access request includes scheduling a communicating a prefetch access request based, at least in part, on the detected slave load state, wherein the method further comprises:
<claim-text>step of communicating a read access request, associated with the thread, from the master device to the slave memory; and</claim-text>
<claim-text>step of retrieving at the slave memory a read result corresponding to the read access request, and communicating the read result from the slave memory, through the interconnect, to the master device,</claim-text>
<claim-text>wherein communicating the slave load status data from the slave memory, through the interconnect, to the master device includes communicating the slave load status data with the read result with.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00047" num="00047">
<claim-text>47. The method of <claim-ref idref="CLM-00045">claim 45</claim-ref>, further comprising step storing, in a slave load monitor register local to the master device, the slave load status data received from the slave memory, wherein the communicating an access request is based, at least in part, on the slave load status data stored in the slave load monitor register.</claim-text>
</claim>
<claim id="CLM-00048" num="00048">
<claim-text>48. The method of <claim-ref idref="CLM-00047">claim 47</claim-ref>, further comprising:
<claim-text>step of initializing, in association with a start of the thread, the slave load monitor register to a default value.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00049" num="00049">
<claim-text>49. The method of <claim-ref idref="CLM-00047">claim 47</claim-ref>, further comprising:
<claim-text>step of sending, in association with a start of the thread, a load status query from the master device to the slave memory,</claim-text>
<claim-text>wherein communicating the slave load status data includes communicating the slave load status data from the slave memory to the master device, in response to the slave memory receiving the slave load status query.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00050" num="00050">
<claim-text>50. A method for controlling a scheduling, from a slave memory, a master device prefetching, comprising:
<claim-text>step of detecting at the slave memory a load level of the slave memory;</claim-text>
<claim-text>step of comparing, at the slave memory, a result of the detecting to a given load threshold;</claim-text>
<claim-text>step of generating at the slave memory a prefetch scheduling data based on a result of the comparing; and</claim-text>
<claim-text>step of communicating the prefetch scheduling data through an interconnect to the master device.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00051" num="00051">
<claim-text>51. The method of <claim-ref idref="CLM-00050">claim 50</claim-ref>, wherein the given load threshold is a given light load threshold, wherein detecting the light load level comprises detecting a quantity of given access commands received at the slave memory over an interval, and wherein the generating comprises generating, in response to the comparing indicating said quantity being less than the given light load threshold, a prefetch request as the prefetch scheduling data.</claim-text>
</claim>
<claim id="CLM-00052" num="00052">
<claim-text>52. A method for controlling master-slave memory accessing, comprising:
<claim-text>detecting a slave load state of a slave memory; and</claim-text>
<claim-text>communicating an access request from a master device to the slave memory based, at least in part, on the detected slave load state,</claim-text>
<claim-text>wherein said access request includes an associated access command, wherein said method further comprises placing said associated access command in a slave memory command queue for execution by the slave memory,</claim-text>
<claim-text>wherein the slave load state is based, at least in part, on a quantity of access commands in the slave memory command queue, and</claim-text>
<claim-text>wherein detecting the slave load state of the slave memory includes a quantity of access commands received at the slave memory over an interval.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00053" num="00053">
<claim-text>53. A method for controlling a master device accessing of a given slave memory, comprising:
<claim-text>receiving at the master device a given slave load state of the given slave memory;</claim-text>
<claim-text>communicating a prefetch access request from the master device to the given slave memory based, at least in part, on the given slave load state; and</claim-text>
<claim-text>detecting the load level at the slave memory, wherein the prefetch scheduling data is based on the detected load level,</claim-text>
<claim-text>wherein detecting the load level comprises detecting a light load level based on a given light load threshold, and wherein generating the prefetch scheduling data generates, in response to detecting the light load level, the prefetch scheduling data at a prefetch request value.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00054" num="00054">
<claim-text>54. The method of <claim-ref idref="CLM-00053">claim 53</claim-ref>, wherein detecting the light load level comprises detecting a quantity of given access commands received at the slave memory over an interval, and comparing the quantity to the given light load threshold.</claim-text>
</claim>
<claim id="CLM-00055" num="00055">
<claim-text>55. A method for controlling a master device accessing of a given slave memory, comprising:
<claim-text>receiving at the master device a given slave load state of the given slave memory;</claim-text>
<claim-text>communicating a prefetch access request from the master device to the given slave memory based, at least in part, on the given slave load state; and</claim-text>
<claim-text>detecting the load level at the slave memory,</claim-text>
<claim-text>wherein the prefetch scheduling data is based on the detected load level,</claim-text>
<claim-text>wherein detecting the load level comprises detecting a heavy slave load level based on a given heavy load threshold, and</claim-text>
<claim-text>wherein generating the prefetch scheduling data generates, in response to detecting the heavy slave load level, the prefetch scheduling data as a prefetch postpone request.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00056" num="00056">
<claim-text>56. The method of <claim-ref idref="CLM-00055">claim 55</claim-ref>, wherein detecting the heavy slave load level comprises detecting a quantity of given access commands received at the slave memory over an interval, and comparing the quantity to the given heavy load threshold.</claim-text>
</claim>
<claim id="CLM-00057" num="00057">
<claim-text>57. An apparatus for controlling a master device prefetch access request scheduling, from a slave memory, comprising:
<claim-text>means for generating a prefetch scheduling data based on a load level at the slave memory;</claim-text>
<claim-text>means for communicating the prefetch scheduling data to the master device; and</claim-text>
<claim-text>means for detecting the load level at the slave memory,</claim-text>
<claim-text>wherein generating the prefetch scheduling data is based on the detected load level,</claim-text>
<claim-text>wherein detecting the load level comprises detecting a light load level based on a given light load threshold, and</claim-text>
<claim-text>wherein the means for generating a prefetch scheduling data generates, in response to detecting the light load level, the prefetch scheduling data at a prefetch request value.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00058" num="00058">
<claim-text>58. The apparatus of <claim-ref idref="CLM-00057">claim 57</claim-ref>, wherein detecting the light load level comprises detecting a quantity of given access commands received at the slave memory over an interval, and comparing the quantity to the given light load threshold.</claim-text>
</claim>
<claim id="CLM-00059" num="00059">
<claim-text>59. The apparatus of <claim-ref idref="CLM-00057">claim 57</claim-ref>, wherein the apparatus is integrated in at least one semiconductor die.</claim-text>
</claim>
<claim id="CLM-00060" num="00060">
<claim-text>60. The apparatus of <claim-ref idref="CLM-00057">claim 57</claim-ref>, further comprising a unit, selected from the group consisting of a set top box, music player, video player, entertainment unit, navigation device, communications device, personal digital assistant (PDA), fixed location data unit, and a computer, into which the apparatus is integrated.</claim-text>
</claim>
<claim id="CLM-00061" num="00061">
<claim-text>61. An apparatus for controlling a master device prefetch access request scheduling, from a slave memory, comprising:
<claim-text>means for generating a prefetch scheduling data based on a load level at the slave memory;</claim-text>
<claim-text>means for communicating the prefetch scheduling data to the master device; and</claim-text>
<claim-text>means for detecting the load level at the slave memory,</claim-text>
<claim-text>wherein generating the prefetch scheduling data is based on the detected load level,</claim-text>
<claim-text>wherein detecting the load level comprises detecting a heavy load level based on a given heavy load threshold, and</claim-text>
<claim-text>wherein generating the prefetch scheduling data generates, in response to detecting the heavy load level, the prefetch scheduling data as a prefetch postpone request.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00062" num="00062">
<claim-text>62. The apparatus of <claim-ref idref="CLM-00061">claim 61</claim-ref>, wherein detecting the heavy load level comprises detecting a quantity of given access commands received at the slave memory over an interval, and comparing the quantity to the given heavy load threshold.</claim-text>
</claim>
<claim id="CLM-00063" num="00063">
<claim-text>63. The apparatus of <claim-ref idref="CLM-00061">claim 61</claim-ref>, wherein the apparatus is integrated in at least one semiconductor die.</claim-text>
</claim>
<claim id="CLM-00064" num="00064">
<claim-text>64. The apparatus of <claim-ref idref="CLM-00061">claim 61</claim-ref>, further comprising a unit, selected from the group consisting of a set top box, music player, video player, entertainment unit, navigation device, communications device, personal digital assistant (PDA), fixed location data unit, and a computer, into which the apparatus is integrated.</claim-text>
</claim>
<claim id="CLM-00065" num="00065">
<claim-text>65. An apparatus for controlling a master device prefetch access request scheduling, from a slave memory, comprising:
<claim-text>means for generating a prefetch scheduling data based on a load level at the slave memory;</claim-text>
<claim-text>means for communicating the prefetch scheduling data to the master device; and</claim-text>
<claim-text>means for detecting the load level at the slave memory, wherein generating the prefetch scheduling data is based on the detected load level,</claim-text>
<claim-text>wherein detecting the load level comprises detecting a heavy load level based on a given heavy load threshold, and wherein generating the prefetch scheduling data generates, in response to detecting the heavy load level, the prefetch scheduling data as a prefetch postpone request.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00066" num="00066">
<claim-text>66. The apparatus of <claim-ref idref="CLM-00065">claim 65</claim-ref>, wherein detecting the heavy load level comprises detecting a quantity of given access commands received at the slave memory over an interval, and comparing the quantity to the given heavy load threshold.</claim-text>
</claim>
<claim id="CLM-00067" num="00067">
<claim-text>67. The apparatus of <claim-ref idref="CLM-00065">claim 65</claim-ref>, wherein the apparatus is integrated in at least one semiconductor die.</claim-text>
</claim>
<claim id="CLM-00068" num="00068">
<claim-text>68. The apparatus of <claim-ref idref="CLM-00065">claim 65</claim-ref>, further comprising a unit, selected from the group consisting of a set top box, music player, video player, entertainment unit, navigation device, communications device, personal digital assistant (PDA), fixed location data unit, and a computer, into which the apparatus is integrated. </claim-text>
</claim>
</claims>
</us-patent-grant>
