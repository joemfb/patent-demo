<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627246-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627246</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13006060</doc-number>
<date>20110113</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<us-term-of-grant>
<us-term-extension>258</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>50</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>716100</main-classification>
<further-classification>716104</further-classification>
<further-classification>716106</further-classification>
<further-classification>716110</further-classification>
<further-classification>716111</further-classification>
</classification-national>
<invention-title id="d2e53">Implementation of factor graphs</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>4649515</doc-number>
<kind>A</kind>
<name>Thompson</name>
<date>19870300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5243688</doc-number>
<kind>A</kind>
<name>Pechanek</name>
<date>19930900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>5745382</doc-number>
<kind>A</kind>
<name>Vilim</name>
<date>19980400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>5959871</doc-number>
<kind>A</kind>
<name>Pierzchala</name>
<date>19990900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>6185331</doc-number>
<kind>B1</kind>
<name>Shi</name>
<date>20010200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>6763340</doc-number>
<kind>B1</kind>
<name>Burns</name>
<date>20040700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>6771197</doc-number>
<kind>B1</kind>
<name>Yedidia</name>
<date>20040800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>7769798</doc-number>
<kind>B2</kind>
<name>Banihashemi</name>
<date>20100800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>7814402</doc-number>
<kind>B2</kind>
<name>Gaudet</name>
<date>20101000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2004/0030414</doc-number>
<kind>A1</kind>
<name>Koza</name>
<date>20040200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2005/0240647</doc-number>
<kind>A1</kind>
<name>Banihashemi</name>
<date>20051000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2007/0276270</doc-number>
<kind>A1</kind>
<name>Tran</name>
<date>20071100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2008/0033897</doc-number>
<kind>A1</kind>
<name>Lloyd</name>
<date>20080200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2009/0100313</doc-number>
<kind>A1</kind>
<name>Gross</name>
<date>20090400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>2009/0144218</doc-number>
<kind>A1</kind>
<name>Bonawitz</name>
<date>20090600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>2009/0217232</doc-number>
<kind>A1</kind>
<name>Beerel et al.</name>
<date>20090800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>716 18</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>2009/0307639</doc-number>
<kind>A1</kind>
<name>Chapman et al.</name>
<date>20091200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00018">
<document-id>
<country>US</country>
<doc-number>2009/0313596</doc-number>
<kind>A1</kind>
<name>Lippmann et al.</name>
<date>20091200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00019">
<document-id>
<country>US</country>
<doc-number>2010/0223225</doc-number>
<kind>A1</kind>
<name>Vigoda</name>
<date>20100900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00020">
<document-id>
<country>US</country>
<doc-number>2011/0072406</doc-number>
<kind>A1</kind>
<name>Chaudhry et al.</name>
<date>20110300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>716120</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00021">
<document-id>
<country>WO</country>
<doc-number>WO2010/101933</doc-number>
<date>20100900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00022">
<document-id>
<country>WO</country>
<doc-number>WO2010/101944</doc-number>
<date>20100900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00023">
<document-id>
<country>WO</country>
<doc-number>WO2010/259256</doc-number>
<date>20110300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00024">
<othercit>Kschischang, Factor Graphs and the Sum-Product Algorithm, IEEE Trans. Info. Theory, 47(2), 2001.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00025">
<othercit>LeCun, Loss Functions for Discriminative Training of Energy Based Models, in Proc. of the 10-th International Workshop on Artificial Intelligence and Statistics, 2005.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00026">
<othercit>Loeliger, Some Remarks on Factor Graphs, Brest 2003.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00027">
<othercit>Loeliger, An Introduction to Factor Graphs, IEEE Signal Processing Magazine, pp. 28-41, Jan. 2004.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00028">
<othercit>Luckenbill, Building Bayesian Networks with Analog Subthreshold CMOS Circuits, Yale University, 2002.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00029">
<othercit>Mansinghka, Stochastic Digital Circuits for Probabilistic Inference, MIT, Cambridge, Nov. 2008.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00030">
<othercit>Mansinghka, Natively Probabilistic Computation, MIT Ph.D. 2009.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00031">
<othercit>Rapley, Stochastic Iterative Decoding on Factor Graphs, Proc. 3rd Int. Symp. on Turbo Codes and Related Topics, pp. 507-510, 2003.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00032">
<othercit>Tehrani, Survey of Stochastic Computation on Factor Graphs, ISMVL '07 Proceedings of the 37th International Symposium on Multiple-Valued Logic 2007.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00033">
<othercit>Tehrani, Tracking Forecast Memories in Stochastic Decoders, IEEE ICASSP 2009.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>22</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>716100-104</main-classification>
<additional-info>unstructured</additional-info>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>716110-113</main-classification>
<additional-info>unstructured</additional-info>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>15</number-of-drawing-sheets>
<number-of-figures>20</number-of-figures>
</figures>
<us-related-documents>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61306842</doc-number>
<date>20100222</date>
</document-id>
</us-provisional-application>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61294740</doc-number>
<date>20100113</date>
</document-id>
</us-provisional-application>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20120159408</doc-number>
<kind>A1</kind>
<date>20120621</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Hershey</last-name>
<first-name>Shawn</first-name>
<address>
<city>Jamaica Plain</city>
<state>MA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Vigoda</last-name>
<first-name>Benjamin</first-name>
<address>
<city>Winchester</city>
<state>MA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Hershey</last-name>
<first-name>Shawn</first-name>
<address>
<city>Jamaica Plain</city>
<state>MA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Vigoda</last-name>
<first-name>Benjamin</first-name>
<address>
<city>Winchester</city>
<state>MA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Occhiuti &#x26; Rohlicek LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Analog Devices, Inc.</orgname>
<role>02</role>
<address>
<city>Norwood</city>
<state>MA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Dinh</last-name>
<first-name>Paul</first-name>
<department>2825</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">The process of implementing a belief propagation network in software and/or hardware can begin with a factor-graph-designer who designs a factor graph that implements that network. A development system provides a user with a way to specify a factor graph at a high or abstract level, and then solve the factor graph, or make an instance of the factor graph in software and/or hardware based on the specification. Factor graphs enable designers to create a graphical model of complicated belief propagation networks such as Markov chains, hidden Markov models, and Bayesian networks.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="184.57mm" wi="207.60mm" file="US08627246-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="238.68mm" wi="193.80mm" file="US08627246-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="258.91mm" wi="200.83mm" orientation="landscape" file="US08627246-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="276.52mm" wi="197.44mm" file="US08627246-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="271.70mm" wi="191.94mm" file="US08627246-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="271.10mm" wi="185.50mm" orientation="landscape" file="US08627246-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="250.61mm" wi="180.59mm" orientation="landscape" file="US08627246-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="247.23mm" wi="204.81mm" file="US08627246-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="239.35mm" wi="179.07mm" orientation="landscape" file="US08627246-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="214.55mm" wi="208.45mm" file="US08627246-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="275.34mm" wi="201.76mm" file="US08627246-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="144.27mm" wi="158.33mm" file="US08627246-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="236.22mm" wi="205.99mm" file="US08627246-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="265.01mm" wi="204.13mm" file="US08627246-20140107-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="261.28mm" wi="194.99mm" orientation="landscape" file="US08627246-20140107-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="234.10mm" wi="200.15mm" orientation="landscape" file="US08627246-20140107-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">This application claims benefit of U.S. Provisional Application Ser. No. 61/294,740, filed Jan. 13, 2010, titled &#x201c;IMPLEMENTATION OF FACTOR GRAPH CIRCUITRY&#x201d; and U.S. Provisional Application Ser. No. 61/306,842, filed Feb. 22, 2010, titled &#x201c;FACTOR GRAPH MODELER,&#x201d; the contents of which are incorporated herein by reference.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?GOVINT description="Government Interest" end="lead"?>
<heading id="h-0002" level="1">STATEMENT AS TO FEDERALLY SPONSORED RESEARCH</heading>
<p id="p-0003" num="0002">This invention was made with government support under FA 8750-07-C-0231 awarded by Defense Advanced Research Projects Agency (DARPA). The government has certain rights in the invention.</p>
<?GOVINT description="Government Interest" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0003" level="1">BACKGROUND</heading>
<p id="p-0004" num="0003">This disclosure relates to factor graphs, and in particular, to the design and implementation of factor graphs in software and/or hardware.</p>
<p id="p-0005" num="0004">At a high level, circuitry representing a belief propagation network can be represented as a factor graph having nodes connected by edges. Factor graphs are a powerful tool for describing statistical models such as hidden Markov models, Markov random fields, Kalman filters, and Bayes nets.</p>
<p id="p-0006" num="0005">Given a set of n discrete random variables a<sub>1</sub>, a<sub>2</sub>, . . . , a<sub>n </sub>the joint probability distribution is expressed as p(a<sub>1</sub>, a<sub>2</sub>, . . . , a<sub>n</sub>). Suppose that the joint probability distribution factors in the following sense: there exist subsets S<sub>1</sub>, . . . , S<sub>k</sub><u style="single">&#x2282;</u>{1, 2, . . . , n} where S<sub>j</sub>={s<sub>1</sub><sup>j</sup>, . . . , s<sub>t(j)</sub><sup>j</sup>}, such that p(a<sub>n</sub>, . . . , a<sub>n</sub>)=&#x3a0;<sub>j=1</sub><sup>k</sup>&#x192;<sub>j</sub>(a<sub>s</sub><sub><sub2>1</sub2></sub><sub><sup2>j </sup2></sub>. . . , a<sub>s</sub><sub><sub2>t(j)</sub2></sub><sub><sup2>j</sup2></sub>). For example, if the a<sub>i </sub>form a Markov chain, then the joint probability can be factored as p(a<sub>1</sub>, . . . , a<sub>n</sub>)=p(a<sub>1</sub>)&#x3a0;p(a<sub>j+1</sub>|a<sub>j</sub>)=&#x192;<sub>0</sub>(a<sub>1</sub>)&#x3a0;&#x192;<sub>j</sub>(a<sub>j</sub>, a<sub>j+1</sub>)</p>
<p id="p-0007" num="0006">The factors above are normalized, in the sense that as the a<sub>i </sub>vary, the probabilities sum to one. The factors can be defined more generally such that they are only required to be proportional to the joint probability. So, we call the &#x192;<sub>i </sub>a collection of factors of p( ) if</p>
<p id="p-0008" num="0007">
<maths id="MATH-US-00001" num="00001">
<math overflow="scroll">
<mrow>
  <mrow>
    <mi>p</mi>
    <mo>&#x2061;</mo>
    <mrow>
      <mo>(</mo>
      <mrow>
        <msub>
          <mi>a</mi>
          <mn>1</mn>
        </msub>
        <mo>,</mo>
        <msub>
          <mi>a</mi>
          <mn>2</mn>
        </msub>
        <mo>,</mo>
        <mi>&#x2026;</mi>
        <mo>&#x2062;</mo>
        <mstyle>
          <mspace width="0.8em" height="0.8ex"/>
        </mstyle>
        <mo>,</mo>
        <msub>
          <mi>a</mi>
          <mi>n</mi>
        </msub>
      </mrow>
      <mo>)</mo>
    </mrow>
  </mrow>
  <mo>&#x221d;</mo>
  <mrow>
    <munderover>
      <mo>&#x220f;</mo>
      <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
      </mrow>
      <mi>k</mi>
    </munderover>
    <mo>&#x2062;</mo>
    <mrow>
      <msub>
        <mi>f</mi>
        <mi>i</mi>
      </msub>
      <mo>&#x2061;</mo>
      <mrow>
        <mo>(</mo>
        <mrow>
          <msub>
            <mi>a</mi>
            <msubsup>
              <mi>s</mi>
              <mn>1</mn>
              <mi>j</mi>
            </msubsup>
          </msub>
          <mo>,</mo>
          <msub>
            <mi>a</mi>
            <msubsup>
              <mi>s</mi>
              <mn>2</mn>
              <mi>j</mi>
            </msubsup>
          </msub>
          <mo>,</mo>
          <mi>&#x2026;</mi>
          <mo>&#x2062;</mo>
          <mstyle>
            <mspace width="0.8em" height="0.8ex"/>
          </mstyle>
          <mo>,</mo>
          <msubsup>
            <mi>s</mi>
            <mrow>
              <mi>t</mi>
              <mo>&#x2061;</mo>
              <mrow>
                <mo>(</mo>
                <mi>j</mi>
                <mo>)</mo>
              </mrow>
            </mrow>
            <mi>j</mi>
          </msubsup>
        </mrow>
        <mo>)</mo>
      </mrow>
    </mrow>
  </mrow>
</mrow>
</math>
</maths>
</p>
<p id="p-0009" num="0008">The product of the factors then differs from the joint probability only by multiplication by a normalizing constant.</p>
<p id="p-0010" num="0009">When a probability distribution can be expressed as a product of small factors (i.e. |S<sub>j</sub>| is small for all j) it is possible to invoke a host of powerful tools for modeling and inference.</p>
<p id="p-0011" num="0010">Given a factored representation of a joint probability distribution, it is possible to describe the structure of the factors as a graph. Each variable a<sub>i </sub>and each function &#x192;<sub>j </sub>can be represented by a node in the graph. An undirected edge can be placed between node a<sub>i </sub>and node &#x192;<sub>j </sub>if and only if the variable a<sub>i </sub>is an argument in the function &#x192;<sub>j</sub>. These two types of nodes are referred to as function nodes (which in some contexts may also be referred to as factors or factor nodes) and variable nodes (which may also be referred to as equals nodes or equals processors in some contexts). Because all edges lie between the two disjoint classes of nodes, the resulting graph is bipartite. This graph is called a factor graph.</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 1</figref> is a graphical representation of a factor graph of the Markov chain expressed above in Equation 1, where &#x192;<sub>j</sub>(a<sub>j</sub>, a<sub>j+1</sub>)=p(a<sub>J+1</sub>|a<sub>j</sub>). It is clear from the figure that the bipartite factor graph includes two groups of nodes (i.e., a<sub>1 </sub>. . . a<sub>4 </sub>and &#x192;<sub>0 </sub>. . . &#x192;<sub>3</sub>).</p>
<p id="p-0013" num="0012">Referring to <figref idref="DRAWINGS">FIG. 2</figref>, a factor graph of the more complex hidden Markov model (HMM) is illustrated. The factor graph of the HMM can be constructed by extending the Markov chain example of <figref idref="DRAWINGS">FIG. 1</figref>. In particular, an HMM contains a Markov chain transiting from state a<sub>i </sub>to a<sub>1+1</sub>. Each state has an observation b<sub>i </sub>associated with it. Given a<sub>i</sub>, then b<sub>i </sub>is conditionally independent of all other variables. This probability can be incorporated by using a factor g<sub>i</sub>(a<sub>i</sub>)=P(b<sub>i</sub>|a<sub>i</sub>).</p>
<p id="p-0014" num="0013">The product of the factors is:</p>
<p id="p-0015" num="0014">
<maths id="MATH-US-00002" num="00002">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mrow>
          <mrow>
            <msub>
              <mi>f</mi>
              <mn>0</mn>
            </msub>
            <mo>(</mo>
            <mrow>
              <munderover>
                <mo>&#x220f;</mo>
                <mrow>
                  <mi>j</mi>
                  <mo>=</mo>
                  <mn>1</mn>
                </mrow>
                <mrow>
                  <mi>n</mi>
                  <mo>-</mo>
                  <mn>1</mn>
                </mrow>
              </munderover>
              <mo>&#x2062;</mo>
              <mrow>
                <msub>
                  <mi>f</mi>
                  <mi>j</mi>
                </msub>
                <mo>&#x2061;</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <msub>
                      <mi>a</mi>
                      <mi>j</mi>
                    </msub>
                    <mo>,</mo>
                    <msub>
                      <mi>a</mi>
                      <mrow>
                        <mi>j</mi>
                        <mo>+</mo>
                        <mn>1</mn>
                      </mrow>
                    </msub>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </mrow>
            </mrow>
            <mo>)</mo>
          </mrow>
          <mo>&#x2062;</mo>
          <mrow>
            <munderover>
              <mo>&#x220f;</mo>
              <mrow>
                <mi>j</mi>
                <mo>=</mo>
                <mn>1</mn>
              </mrow>
              <mi>n</mi>
            </munderover>
            <mo>&#x2062;</mo>
            <mrow>
              <msub>
                <mi>g</mi>
                <mi>j</mi>
              </msub>
              <mo>&#x2061;</mo>
              <mrow>
                <mo>(</mo>
                <msub>
                  <mi>a</mi>
                  <mi>j</mi>
                </msub>
                <mo>)</mo>
              </mrow>
            </mrow>
          </mrow>
        </mrow>
        <mo>=</mo>
        <mi/>
        <mo>&#x2062;</mo>
        <mrow>
          <mrow>
            <mi>Pr</mi>
            <mo>&#x2061;</mo>
            <mrow>
              <mo>(</mo>
              <msub>
                <mi>a</mi>
                <mn>1</mn>
              </msub>
              <mo>)</mo>
            </mrow>
          </mrow>
          <mo>&#x2062;</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <munderover>
                <mo>&#x220f;</mo>
                <mrow>
                  <mi>j</mi>
                  <mo>=</mo>
                  <mn>1</mn>
                </mrow>
                <mrow>
                  <mi>n</mi>
                  <mo>-</mo>
                  <mn>1</mn>
                </mrow>
              </munderover>
              <mo>&#x2062;</mo>
              <mrow>
                <mi>Pr</mi>
                <mo>&#x2061;</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <msub>
                      <mi>a</mi>
                      <mrow>
                        <mi>j</mi>
                        <mo>+</mo>
                        <mn>1</mn>
                      </mrow>
                    </msub>
                    <mo>&#x2758;</mo>
                    <msub>
                      <mi>a</mi>
                      <mi>j</mi>
                    </msub>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </mrow>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <mi/>
        <mo>&#x2062;</mo>
        <mrow>
          <munderover>
            <mo>&#x220f;</mo>
            <mrow>
              <mi>j</mi>
              <mo>=</mo>
              <mn>1</mn>
            </mrow>
            <mi>n</mi>
          </munderover>
          <mo>&#x2062;</mo>
          <mrow>
            <mi>Pr</mi>
            <mo>&#x2061;</mo>
            <mrow>
              <mo>(</mo>
              <mrow>
                <msub>
                  <mi>b</mi>
                  <mi>j</mi>
                </msub>
                <mo>&#x2758;</mo>
                <msub>
                  <mi>a</mi>
                  <mi>j</mi>
                </msub>
              </mrow>
              <mo>)</mo>
            </mrow>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <mo>=</mo>
        <mi/>
        <mo>&#x2062;</mo>
        <mrow>
          <mi>Pr</mi>
          <mo>&#x2061;</mo>
          <mrow>
            <mo>(</mo>
            <mrow>
              <msub>
                <mi>a</mi>
                <mn>1</mn>
              </msub>
              <mo>,</mo>
              <mi>&#x2026;</mi>
              <mo>&#x2062;</mo>
              <mstyle>
                <mspace width="0.8em" height="0.8ex"/>
              </mstyle>
              <mo>,</mo>
              <msub>
                <mi>a</mi>
                <mi>n</mi>
              </msub>
              <mo>,</mo>
              <msub>
                <mi>b</mi>
                <mn>1</mn>
              </msub>
              <mo>,</mo>
              <mi>&#x2026;</mi>
              <mo>&#x2062;</mo>
              <mstyle>
                <mspace width="0.8em" height="0.8ex"/>
              </mstyle>
              <mo>,</mo>
              <msub>
                <mi>b</mi>
                <mi>n</mi>
              </msub>
            </mrow>
            <mo>)</mo>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
</p>
<p id="p-0016" num="0015">Since the b<sub>i </sub>are observed, then Pr(b<sub>1</sub>, . . . , b<sub>n</sub>) is a constant. Therefore,</p>
<p id="p-0017" num="0016">
<maths id="MATH-US-00003" num="00003">
<math overflow="scroll">
<mrow>
  <mrow>
    <mo>&#x221d;</mo>
    <mfrac>
      <mtable>
        <mtr>
          <mtd>
            <mrow>
              <mi>Pr</mi>
              <mo>&#x2061;</mo>
              <mrow>
                <mo>(</mo>
                <mrow>
                  <msub>
                    <mi>a</mi>
                    <mn>1</mn>
                  </msub>
                  <mo>,</mo>
                  <mi>&#x2026;</mi>
                  <mo>&#x2062;</mo>
                  <mstyle>
                    <mspace width="0.8em" height="0.8ex"/>
                  </mstyle>
                  <mo>,</mo>
                  <msub>
                    <mi>a</mi>
                    <mi>n</mi>
                  </msub>
                  <mo>,</mo>
                  <msub>
                    <mi>b</mi>
                    <mn>1</mn>
                  </msub>
                  <mo>,</mo>
                  <mi>&#x2026;</mi>
                  <mo>&#x2062;</mo>
                  <mstyle>
                    <mspace width="0.8em" height="0.8ex"/>
                  </mstyle>
                  <mo>,</mo>
                  <msub>
                    <mi>b</mi>
                    <mi>n</mi>
                  </msub>
                </mrow>
                <mo>)</mo>
              </mrow>
            </mrow>
          </mtd>
        </mtr>
        <mtr>
          <mtd>
            <mrow>
              <mi>Pr</mi>
              <mo>&#x2061;</mo>
              <mrow>
                <mo>(</mo>
                <mrow>
                  <msub>
                    <mi>a</mi>
                    <mn>1</mn>
                  </msub>
                  <mo>,</mo>
                  <mi>&#x2026;</mi>
                  <mo>&#x2062;</mo>
                  <mstyle>
                    <mspace width="0.8em" height="0.8ex"/>
                  </mstyle>
                  <mo>,</mo>
                  <msub>
                    <mi>a</mi>
                    <mi>n</mi>
                  </msub>
                  <mo>,</mo>
                  <msub>
                    <mi>b</mi>
                    <mn>1</mn>
                  </msub>
                  <mo>,</mo>
                  <mi>&#x2026;</mi>
                  <mo>&#x2062;</mo>
                  <mstyle>
                    <mspace width="0.8em" height="0.8ex"/>
                  </mstyle>
                  <mo>,</mo>
                  <msub>
                    <mi>b</mi>
                    <mi>n</mi>
                  </msub>
                </mrow>
                <mo>)</mo>
              </mrow>
            </mrow>
          </mtd>
        </mtr>
      </mtable>
      <mrow>
        <mi>Pr</mi>
        <mo>&#x2061;</mo>
        <mrow>
          <mo>(</mo>
          <mrow>
            <msub>
              <mi>b</mi>
              <mn>1</mn>
            </msub>
            <mo>,</mo>
            <mi>&#x2026;</mi>
            <mo>&#x2062;</mo>
            <mstyle>
              <mspace width="0.8em" height="0.8ex"/>
            </mstyle>
            <mo>,</mo>
            <msub>
              <mi>b</mi>
              <mi>n</mi>
            </msub>
          </mrow>
          <mo>)</mo>
        </mrow>
      </mrow>
    </mfrac>
  </mrow>
  <mo>=</mo>
  <mrow>
    <mi>Pr</mi>
    <mo>&#x2061;</mo>
    <mrow>
      <mo>(</mo>
      <mrow>
        <msub>
          <mi>a</mi>
          <mn>1</mn>
        </msub>
        <mo>,</mo>
        <mi>&#x2026;</mi>
        <mo>&#x2062;</mo>
        <mstyle>
          <mspace width="0.8em" height="0.8ex"/>
        </mstyle>
        <mo>,</mo>
        <mrow>
          <msub>
            <mi>a</mi>
            <mi>n</mi>
          </msub>
          <mo>&#x2758;</mo>
          <msub>
            <mi>b</mi>
            <mn>1</mn>
          </msub>
        </mrow>
        <mo>,</mo>
        <mi>&#x2026;</mi>
        <mo>&#x2062;</mo>
        <mstyle>
          <mspace width="0.8em" height="0.8ex"/>
        </mstyle>
        <mo>,</mo>
        <msub>
          <mi>b</mi>
          <mi>n</mi>
        </msub>
      </mrow>
      <mo>)</mo>
    </mrow>
  </mrow>
</mrow>
</math>
</maths>
<br/>
as desired.
</p>
<p id="p-0018" num="0017">Note that the variables b<sub>i </sub>need not appear explicitly in the factor graph. Their effects can be incorporated into the g<sub>i </sub>factors.</p>
<p id="p-0019" num="0018">Generalizing from a Markov chain to an HMM illustrates a very powerful feature of factor graphs. In particular, complicated mathematical models are often composed of simpler parts. When these models are expressed as factor graphs, simpler factor graphs can be used to construct more complicated factor graphs.</p>
<p id="p-0020" num="0019">In some hardware implementations, the variable (equals) nodes of the factor graphs are implemented by equals processors, which output the sum of their inputs, and the factor nodes of the factor graphs are implemented by XOR processors, which output the XOR of their inputs. Both kinds of processors can include both analog and digital circuitry.</p>
<p id="p-0021" num="0020">When designing circuitry for realizing a belief propagation network, it is common to first work with a logical representation of the network (e.g., a factor graph), rather than the actual circuit elements themselves.</p>
<p id="p-0022" num="0021">Once the logical design of the network has been settled on, there remains the task of translating that logical design into an actual physical circuit. This typically involves having a hardware architect create a representation of the physical structure in a hardware descriptor language. A floor-planner uses this representation to determine where to place the circuit elements. The output of the floor planner and the representation of the physical design are then provided to a fabrication machine, which creates a physical template to be used in manufacturing the physical circuit corresponding to the logical design.</p>
<heading id="h-0004" level="1">SUMMARY</heading>
<p id="p-0023" num="0022">In one aspect, the invention features a method for generating a hardware description of a belief propagation network. Such a method includes receiving an initial representation of a belief propagation network having factor graph that includes nodes connected by edges; receiving a specification indicating that that a hardware element is to realize at least two nodes of the factor graph; generating empty nodes for receiving information representative of hardware modules for physically realizing the nodes; and on the basis of the initial representation and the specification, generating a hardware representation of an electronic circuit for implementing the factor graph.</p>
<p id="p-0024" num="0023">In some practices of the invention, generating a hardware representation includes generating a hardware descriptor language representation of the specification. Other practices include generating a hardware representation by generating a VERILOG representation of the specification.</p>
<p id="p-0025" num="0024">Alternative practices also include receiving a specification of hardware to be placed in the nodes.</p>
<p id="p-0026" num="0025">Other practices include those in which receiving the specification includes receiving a specification of factor nodes to be implemented by a particular XOR-processor, and those in which wherein receiving the specification includes receiving a specification of variable nodes to be implemented by a particular equals-processor.</p>
<p id="p-0027" num="0026">Additional practices include specifying additional hardware elements to enable the hardware element to realize at least two nodes of the factor graph. These can be carried out by, for example, specifying at least one switch, or by specifying at least one memory element.</p>
<p id="p-0028" num="0027">Yet other practices of the invention include providing the hardware representation to a hardware simulator for simulation of the belief propagation network, or providing it to a floor planner for generating a floor plan of an integrated circuit for implementing the belief propagation network.</p>
<p id="p-0029" num="0028">In another aspect, the invention features a manufacture having encoded thereon functional material, the functional material including instructions that, when executed by a data processing system, cause the system to receive an initial representation of a belief propagation network having factor graph that includes nodes connected by edges; receive a specification indicating that that a hardware element is to realize at least two nodes of the factor graph; generate empty nodes for receiving information representative of hardware modules for physically realizing the nodes; and on the basis of the initial representation and the specification, generate a hardware representation of an electronic circuit for implementing the factor graph.</p>
<p id="p-0030" num="0029">In another aspect, a method is used for implementing a belief propagator. Such a method includes defining a plurality of factor graph objects that collectively model a factor graph having nodes connected by edges, wherein messages are passed between nodes along the edges; specifying an active solver to execute belief propagation on the factor graph model; and causing the objects to associated themselves with the particular solver.</p>
<p id="p-0031" num="0030">Some practices further include causing a factor graph object to define a variable as a boundary variable.</p>
<p id="p-0032" num="0031">Other practices further include specifying a new solver to execute belief propagation on the factor graph model without altering the factor graph model.</p>
<p id="p-0033" num="0032">Yet other practices include receiving instructions to define discrete variables with a finite domain and an arbitrary set of dimensions.</p>
<p id="p-0034" num="0033">Among the other practices are those that include using operator overloading to cause a variable to appear as a matrix to the active solver, those that include determining whether a coefficient table is to be provided to the active solver, and if so, generating the table, those that include identifying a constraint function (e.g., factors representing hard or probabilistic (soft) constraints) and a set of variable nodes,</p>
<p id="p-0035" num="0034">Another practice includes determining that a coefficient table exists for the constraint function, and those that include determining that a function node is to be hand-coded, and determining that no coefficient table needs to be provided to the active solver.</p>
<p id="p-0036" num="0035">In another aspect, the invention features a computer-readable medium having encoded thereon software for implementing a belief propagator, the software included instructions for causing execution of any combination of the foregoing methods.</p>
<p id="p-0037" num="0036">In yet another aspect, the invention features a data processing system configured to execute software for implementing a belief propagator, the software including instructions for causing execution of any combination of the foregoing methods.</p>
<p id="p-0038" num="0037">These and other features of the invention will be apparent from the following detailed description and the figures.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0005" level="1">DESCRIPTION OF THE FIGURES</heading>
<p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. 1</figref> shows a factor graph of a Markov chain;</p>
<p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. 2</figref> shows a factor graph of a hidden Markov model;</p>
<p id="p-0041" num="0040"><figref idref="DRAWINGS">FIG. 3</figref> shows a detailed view of modules of a development system;</p>
<p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. 4</figref> shows the class structure of an embodiment of DMPL;</p>
<p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. 5</figref> shows a factor graph of a 4-bit XOR decomposed into two 3-bit XORs;</p>
<p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. 6</figref> shows a nested factor graph using two 4-bit XORs to create a 6-bit code;</p>
<p id="p-0045" num="0044"><figref idref="DRAWINGS">FIG. 7</figref> shows a nested factor graph of a 4-bit XOR created from two nested 3-bit XORs;</p>
<p id="p-0046" num="0045"><figref idref="DRAWINGS">FIG. 8</figref> shows a foundry for manufacture of articles such as ASICs having belief propagation networks embodied therein;</p>
<p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. 9</figref> shows the use of a FADL translator for generating an article encoding a physical design of a belief propagation network from an article encoding a logical design thereof;</p>
<p id="p-0048" num="0047"><figref idref="DRAWINGS">FIG. 10</figref> shows a factor graph representative of a belief propagation network;</p>
<p id="p-0049" num="0048"><figref idref="DRAWINGS">FIG. 11</figref> shows a bi-adjacency matrix encoding hardware constraints on the factor graph of <figref idref="DRAWINGS">FIG. 10</figref>;</p>
<p id="p-0050" num="0049"><figref idref="DRAWINGS">FIG. 12</figref> shows a high level diagram of a physical circuit corresponding to the matrix in <figref idref="DRAWINGS">FIG. 11</figref>;</p>
<p id="p-0051" num="0050"><figref idref="DRAWINGS">FIG. 13</figref> is a flow chart of a procedure for generating an article encoding a physical design of a belief propagation network based on an article in which is encoded a logical design of the belief propagation network;</p>
<p id="p-0052" num="0051"><figref idref="DRAWINGS">FIGS. 14 and 16</figref> show example FADL representation for implementing the factor graphs shown in <figref idref="DRAWINGS">FIGS. 15 and 17</figref> respectively;</p>
<p id="p-0053" num="0052"><figref idref="DRAWINGS">FIGS. 15 and 17</figref> are factor graphs implemented by the example FADL representation shown in <figref idref="DRAWINGS">FIGS. 14 and 16</figref> respectively;</p>
<p id="p-0054" num="0053"><figref idref="DRAWINGS">FIG. 18</figref> shows an object-oriented programming environment for implementing a FADL translator;</p>
<p id="p-0055" num="0054"><figref idref="DRAWINGS">FIG. 19</figref> shows classes and class relationships when the HDL representation of <figref idref="DRAWINGS">FIG. 18</figref> is a VERILOG representation; and</p>
<p id="p-0056" num="0055"><figref idref="DRAWINGS">FIG. 20</figref> shows classes and class relationships for the factor graph builder in <figref idref="DRAWINGS">FIG. 18</figref>.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0006" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0057" num="0056">The process of implementing a belief propagation network in software and/or hardware can begin with a factor-graph-designer who designs a factor graph that implements that network. As is described above, factor graphs enable designers to create a graphical model of complicated belief propagation networks such as Markov chains, hidden Markov models, Bayesian networks, etc. Properly designed factor graphs enable the efficient computation of marginal distributions.</p>
<p id="p-0058" num="0057">Using conventional techniques, factor graph designers may face significant challenges in transforming factor graphs into properly designed hardware (e.g., an ASIC hardware representation of a factor graph) or software. For instance, factor-graph-designers have not had simulation tools to ensure that a final hardware device will comply with a factor graph design. Additionally, generating satisfactory hardware layouts can be difficult and problems in the generated layouts may not be discovered until the relatively late integrated circuit development cycle. Problems discovered at late stages can be extremely costly in both time and money.</p>
<p id="p-0059" num="0058">The following description relates to a development system that aids development tasks including one or more of the prototyping, specification, simulation, fabrication of hardware, and compiling and execution of software code for belief propagation networks using factor graphs.</p>
<p id="p-0060" num="0059">Referring to <figref idref="DRAWINGS">FIG. 3</figref>, embodiments of a factor graph development system <b>1000</b> support one or more of the development paths shown in the figure. For example, in an example of using the development system to design a hardware implementation, a factor-graph-designer <b>1002</b> interfaces with a computer <b>1004</b> to design and implement a factor graph. For example, in a software synthesis case, the factor-graph-designer <b>1002</b> specifies a factor graph by providing input <b>1012</b> to a factor graph modeler using a syntax of a Distributed Mathematical Programming Language (DMPL) <b>1006</b>. As another example, in a hardware synthesis case, the specification of the factor graph <b>1008</b> is passed to a Factor Graph ASIC Description Language (FADL) module <b>1010</b> where, based on input <b>1012</b> from the factor-graph-designer <b>1002</b>, a hardware definition language (HDL) (e.g., VERILOG) representation of the factor graph <b>1014</b> is generated. The HDL representation of the factor graph <b>1014</b> can then be passed to a device fabrication process <b>1016</b> through which a device <b>1042</b> that implements the factor graph is ultimately fabricated.</p>
<p id="p-0061" num="0060">In an example use of the development system for a software implementation, the factor-graph-designer <b>1002</b> provides user input <b>1012</b> to a computer <b>1004</b> to specify a factor graph. The user input <b>1012</b> utilizes &#x2018;clients&#x2019; <b>2018</b> which in some examples implement classes of functions. For example, the clients can include the FactorGraph, Variable, and Factor classes. The result of the factor-graph-designer's <b>1002</b> use of the clients <b>2018</b> is a problem specification <b>2020</b>. The problem specification <b>2020</b> can represent the nodes present in the specified factor graph, the edges present in the specified graph, and how the nodes and edges are interconnected.</p>
<p id="p-0062" num="0061">The problem specification <b>2020</b> is passed to a model creation module <b>2022</b> where a model <b>1008</b> of the factor graph is created. The model <b>1008</b> is an object that can be used to produce a number of different results. In particular, the model can be used to solve the factor graph within the DMPL environment <b>1006</b>, compile an executable file <b>2032</b> that solves the factor graph independent of any programming environment, or the model can be passed to FADL <b>1010</b> where it may be used to generate a hardware implementation of the factor graph.</p>
<p id="p-0063" num="0062">To solve the factor graph within DMPL <b>1006</b>, the model of the factor graph <b>1008</b> is passed to the solver module <b>2024</b>. In some examples, the solver module <b>2024</b> implements a belief propagation algorithm (e.g., the Sum-Product algorithm) to generate results <b>2034</b> (e.g., marginal distributions at the nodes of the factor graph). The factor-graph-designer <b>1002</b> may compare the results of the solver module <b>2024</b> to the results produced by FADL <b>1010</b> (e.g., the hardware device results or the simulation results) for the purpose of verifying that the factor graph design is correct.</p>
<p id="p-0064" num="0063">In some examples, it may be desirable to solve the factor graph outside of the DMPL environment <b>1006</b>. In such situations, the factor graph model <b>1008</b> may be passed to a compiler <b>2026</b> that compiles the model <b>1008</b>, for instance including the solver algorithm, into a machine executable file <b>2032</b>. The file may be run at a later time to solve the factor graph and produce results <b>2034</b>.</p>
<p id="p-0065" num="0064">In other examples, the model <b>1008</b> may be passed to the FADL module <b>1010</b>. In addition to the factor graph model, the FADL module <b>1010</b> may accept input <b>1012</b> from the factor-graph designer <b>1002</b>. For example, adjacency matrices, inputs and outputs, and sub-lists may be provided by the user (the inputs to FADL are discussed further in Section 3 below). The inputs to the FADL module <b>1010</b> are then passed to an HDL transcription module <b>2028</b> that generates an HDL representation (e.g., in VERILOG) of the factor graph <b>1014</b>. The factor-graph-designer <b>1002</b> may pass the HDL representation of the factor graph <b>1014</b> to an HDL simulation module <b>2030</b> (e.g., SPECTER). The HDL simulation module <b>2030</b> can execute the HDL representation of the factor graph <b>1014</b>, producing results <b>2034</b>. The results of the HDL simulation module <b>2030</b> can be compared to the results of the DMPL solver <b>2024</b> for the purpose of verifying that the HDL representation of the factor graph <b>1014</b> will generate the desired factor graph results <b>2034</b>.</p>
<p id="p-0066" num="0065">The HDL representation of the factor graph <b>1014</b> can also be passed to a floor planner <b>2036</b>, for example, in a device fabrication process <b>1016</b> (referred in some instances below as an ASIC &#x201c;foundry&#x201d;, without intending to limit the meaning, for instance, only to a physical fabrication step). The floor plan developed by the floor planner <b>2036</b> can be passed to a layout module <b>2038</b>, which determines the placement of integrated circuit components on the integrated circuit device <b>1042</b>. The result of the layout module <b>2038</b> can be passed to a fabrication module <b>2040</b> which can use the layout to create one or more integrated circuit devices <b>1042</b>. The integrated circuit devices <b>1042</b> can be used to solve the factor graph, generating results <b>2034</b>. The results of the integrated circuit devices <b>1042</b> should be the same as those of the HDL simulation <b>2030</b>, DMPL solver <b>2024</b>, and compiled executable <b>2032</b>.</p>
<p id="h-0007" num="0000">1 DMPL</p>
<p id="p-0067" num="0066">DMPL is an example of a modeling tool that provides a concise way for a factor-graph-designer to describe factor graphs with only a few lines of code. DMPL enables the rapid prototyping of algorithms that can be described with factor graphs and solved with belief propagation algorithms (e.g., the Sum-Product algorithm).</p>
<p id="p-0068" num="0067">DMPL provides factor-graph-designers with &#x2018;clients&#x2019; and &#x2018;solvers.&#x2019; Factor-graph-designers specify factor graphs using the clients and then pass the specified factor graphs to the solvers which perform belief propagation on the factor graphs to solve real world problems.</p>
<p id="p-0069" num="0068">One embodiment of DMPL is implemented using MATLAB classes and operator-overloading. The reader should understand, however, that while the described embodiment is implemented in MATLAB, a number of other programming languages could be used to implement an equivalent application.</p>
<p id="p-0070" num="0069">Referring to <figref idref="DRAWINGS">FIG. 4</figref>, the class structure of such a modeling tool is shown. As shown, the selected solver being used for the model, i.e. the &#x201c;active solver,&#x201d; is a C++ solver. However, one could also select the Java Solver <b>3018</b> in <figref idref="DRAWINGS">FIG. 4</figref>, or any other solver to be the active solver.</p>
<p id="h-0008" num="0000">1.1 Clients</p>
<p id="p-0071" num="0070">DMPL includes classes of functions called &#x2018;clients&#x2019; that provide a user interface that hides unnecessary implementation details from the user. The clients represent the main components of factor graphs and provide the user with the tools to construct a factor graph. In some examples, DMPL includes three clients: FactorGraph, Variable, and Factor.</p>
<p id="h-0009" num="0000">1.1.1 FactorGraph Client</p>
<p id="p-0072" num="0071">The FactorGraph client can be used to instantiate the initial factor graph structure as follows:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>FG=FactorGraph( );<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0073" num="0072">The instantiated factor graph is the foundation on which the user can build a factor graph by adding nodes (variables and factors) and edges.</p>
<p id="p-0074" num="0073">Referring to <figref idref="DRAWINGS">FIG. 4</figref>, internally, the FactorGraph <b>3004</b> constructor assigns the currently active solver to the FactorGraph <b>3004</b> instance and retrieves a new unique factor graph ID to represent this graph from the solver. Additionally, the constructor creates a CombinationTableFactory <b>3008</b> instance. The CombinationTableFactory <b>3008</b> is responsible for generating coefficient tables, which are discussed further below.</p>
<p id="p-0075" num="0074">In some examples, the user may pass variables as arguments to the constructor. In such cases, the factor graph object associates these variables with the factor graph and informs the solver that they are boundary variables.</p>
<p id="h-0010" num="0000">1.1.2 Variable Client</p>
<p id="p-0076" num="0075">The Variable client of the DMPL modeler allows users to define discrete variables with a finite domain and an arbitrary set of dimensions for the factor graph.</p>
<p id="p-0077" num="0076">In some examples, the DMPL modeler internally uses operator overloading to make it appear as though variables are matrices. Referring to <figref idref="DRAWINGS">FIG. 4</figref>, the class diagram shows a VariableBase <b>3002</b> base class that is extended by the Variable <b>3006</b> class and by the Bit <b>3010</b> class. VariableBase <b>3002</b> provides most of the implementation and Variable <b>3006</b> and Bit <b>3010</b> simply provide specific mechanisms to set priors and retrieve beliefs.</p>
<p id="p-0078" num="0077">For example, the Variable <b>3006</b> class can be specified with a first argument as the domain and the remaining arguments as the size of an arbitrary number of dimensions, as shown below:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>v=</i>Variable({2,4+<i>i,{</i>5,6}},3,4);<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0079" num="0078">The foregoing command creates a 3&#xd7;4 matrix of discrete variables with three elements in its domain named v. The domain is specified as a cell array of any legal type (e.g., any legal MATLAB type). The modeler provides some shorthand mechanisms for specifying domains, such as a single vector, where each number is a single domain item.</p>
<p id="p-0080" num="0079">The Variable <b>3006</b> constructor does not create a true MATLAB matrix. Instead, the Variable <b>3006</b> constructor creates a Variable <b>3006</b> instance. The modeler VariableBase <b>3002</b> code retrieves 3*4=12 variable identifiers from the solver to uniquely identify each variable in the matrix, stores these variable identifiers as a true MATLAB matrix, and informs the solver of the domain length for each of these variables.</p>
<p id="p-0081" num="0080">Because Variable <b>3006</b> is a class instance and not a matrix, methods and properties can be invoked on it. For example, the following code calls the &#x201c;getter&#x201d; on the &#x201c;Beliefs&#x201d; property of the variable v.</p>
<p id="p-0082" num="0081">
<maths id="MATH-US-00004" num="00004">
<math overflow="scroll">
  <mrow>
    <mi>v</mi>
    <mo>.</mo>
    <mi>Beliefs</mi>
  </mrow>
</math>
</maths>
<maths id="MATH-US-00004-2" num="00004.2">
<math overflow="scroll">
  <mrow>
    <mrow>
      <mi>ans</mi>
      <mo>&#x2061;</mo>
      <mrow>
        <mo>(</mo>
        <mrow>
          <mo>:</mo>
          <mrow>
            <mo>,</mo>
            <mrow>
              <mo>:</mo>
              <mrow>
                <mo>,</mo>
                <mn>1</mn>
              </mrow>
            </mrow>
          </mrow>
        </mrow>
        <mo>)</mo>
      </mrow>
    </mrow>
    <mo>=</mo>
    <mtable>
      <mtr>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
      </mtr>
      <mtr>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
      </mtr>
      <mtr>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
      </mtr>
    </mtable>
  </mrow>
</math>
</maths>
<maths id="MATH-US-00004-3" num="00004.3">
<math overflow="scroll">
  <mrow>
    <mrow>
      <mi>ans</mi>
      <mo>&#x2061;</mo>
      <mrow>
        <mo>(</mo>
        <mrow>
          <mo>:</mo>
          <mrow>
            <mo>,</mo>
            <mrow>
              <mo>:</mo>
              <mrow>
                <mo>,</mo>
                <mn>2</mn>
              </mrow>
            </mrow>
          </mrow>
        </mrow>
        <mo>)</mo>
      </mrow>
    </mrow>
    <mo>=</mo>
    <mtable>
      <mtr>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
      </mtr>
      <mtr>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
      </mtr>
      <mtr>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
      </mtr>
    </mtable>
  </mrow>
</math>
</maths>
<maths id="MATH-US-00004-4" num="00004.4">
<math overflow="scroll">
  <mrow>
    <mrow>
      <mi>ans</mi>
      <mo>&#x2061;</mo>
      <mrow>
        <mo>(</mo>
        <mrow>
          <mo>:</mo>
          <mrow>
            <mo>,</mo>
            <mrow>
              <mo>:</mo>
              <mrow>
                <mo>,</mo>
                <mn>3</mn>
              </mrow>
            </mrow>
          </mrow>
        </mrow>
        <mo>)</mo>
      </mrow>
    </mrow>
    <mo>=</mo>
    <mtable>
      <mtr>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
      </mtr>
      <mtr>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
      </mtr>
      <mtr>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
        <mtd>
          <mn>0.3333</mn>
        </mtd>
      </mtr>
    </mtable>
  </mrow>
</math>
</maths>
</p>
<p id="p-0083" num="0082">In the preceding example, a third dimension is added to specify the three probabilities (one for each domain item), so that 3*4*3 values are returned. Internally, the VariableBase <b>3002</b> code converts the 3*4 matrix of variable identifiers to a 12&#xd7;1 vector of Variable identifiers and asks the solvers for the &#x201c;Beliefs&#x201d; of these Variable <b>3006</b> identifiers. Upon receiving these results, it reshapes them into the correct size matrix and returns the matrix.</p>
<p id="p-0084" num="0083">The following example demonstrates the implementation of MATLAB slices:</p>
<p id="p-0085" num="0084">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="168pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>&#x2002;v(1:2,1).Priors = [.4 .4 .2; .2 .4 .4];</entry>
</row>
<row>
<entry/>
<entry>&#x2002;v(1:2,1).Beliefs</entry>
</row>
<row>
<entry/>
<entry>ans =</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="63pt" align="left"/>
<colspec colname="1" colwidth="154pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>0.4000 0.4000 0.2000</entry>
</row>
<row>
<entry/>
<entry>0.2000 0.4000 0.4000</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0086" num="0085">The preceding example retrieves the first and second rows of the first column of Variables, assigns priors, and observes the new &#x201c;Beliefs.&#x201d; Again, the subscripting operator is overloaded, the slice parameters are caught, the variable identifiers are retrieved from the internal Variable identifier matrix, and the solver is invoked to set the priors on the appropriate variables (two in this case). In the second line, the solver is used to retrieve beliefs on the same set of variables.</p>
<p id="p-0087" num="0086">The following example illustrates how variables and sub matrices can be concatenated.</p>
<p id="p-0088" num="0087">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>vnew = [v(1:2,1) v(2:3,3)]</entry>
</row>
<row>
<entry/>
<entry>vnew =</entry>
</row>
<row>
<entry/>
<entry>&#x2002;Variable handle</entry>
</row>
<row>
<entry/>
<entry>&#x2002;Properties:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Beliefs: [2x2x3 double]</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>V: [2x2 struct]</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Solver: [1x1 CSolver]</entry>
</row>
<row>
<entry/>
<entry>Domain: {[2] [4.0000 + 1.0000i] {1x2 cell}}</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0089" num="0088">The subscripting returns new Variable classes representing matrices of Variables, and the VariableBase and Variable classes override the &#x201c;horzcat&#x201d; and &#x201c;vertcat&#x201d; operators so that Variables can be concatenated vertically and horizontally.</p>
<p id="p-0090" num="0089">Transpose is implemented via the same operator overloading mechanism.</p>
<p id="p-0091" num="0090">
<tables id="TABLE-US-00003" num="00003">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>v = v&#x2032;</entry>
</row>
<row>
<entry/>
<entry>v =</entry>
</row>
<row>
<entry/>
<entry>&#x2003;Variable handle</entry>
</row>
<row>
<entry/>
<entry>&#x2003;Properties:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Beliefs: [4x3x3 double]</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>V: [4x3 struct]</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Solver: [1x1 CSolver]</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Domain: {[2] [4.0000 + 1.0000i] {1x2 cell}}</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0092" num="0091">DMPL ensures that matrices of variables only contain variables with the same domains. As such, the user can retrieve the single Domain associated with a Variable Matrix as follows:</p>
<p id="p-0093" num="0092">
<tables id="TABLE-US-00004" num="00004">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="168pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>v.Domain</entry>
</row>
<row>
<entry/>
<entry>ans =</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="63pt" align="left"/>
<colspec colname="1" colwidth="154pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>[2] [4.0000 + 1.0000i] {1x2 cell}</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0094" num="0093">DMPL may also support reshaping via function overloading as follows:</p>
<p id="p-0095" num="0094">
<tables id="TABLE-US-00005" num="00005">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>v = reshape(v,6,2)</entry>
</row>
<row>
<entry/>
<entry>v =</entry>
</row>
<row>
<entry/>
<entry>&#x2002;Variable handle</entry>
</row>
<row>
<entry/>
<entry>&#x2002;Properties:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Beliefs: [6x2x3 double]</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>V: [6x2 struct]</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Solver: [1x1 CSolver]</entry>
</row>
<row>
<entry/>
<entry>Domain: {[2] [4.0000 + 1.0000i] {1x2 cell}}</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0096" num="0095">The other class in the Variable <b>3006</b> class hierarchy is the Bit <b>3010</b> class. Bit objects can be instantiated as follows:</p>
<p id="p-0097" num="0096">
<tables id="TABLE-US-00006" num="00006">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="63pt" align="left"/>
<colspec colname="1" colwidth="154pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>b = Bit(2,3);</entry>
</row>
<row>
<entry/>
<entry>b</entry>
</row>
<row>
<entry/>
<entry>b =</entry>
</row>
<row>
<entry/>
<entry>&#x2002;Bit handle</entry>
</row>
<row>
<entry/>
<entry>&#x2002;Properties:</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="77pt" align="left"/>
<colspec colname="1" colwidth="140pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Beliefs: [2x3 double]</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="91pt" align="left"/>
<colspec colname="1" colwidth="126pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>V: [2x3 struct]</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="77pt" align="left"/>
<colspec colname="1" colwidth="140pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>Solver: [1x1 CSolver]</entry>
</row>
<row>
<entry/>
<entry>Domain: {[1] [0]}</entry>
</row>
<row>
<entry/>
<entry>Values: [2x3 double]</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0098" num="0097">A Bit is implemented as a VariableBase with a domain of {1,0}. The &#x201c;Beliefs&#x201d; and &#x201c;Priors&#x201d; methods have also been modified to take single arguments per element in the matrix since probabilities are normalized. All priors and beliefs are interpreted as the probability of 1. Probability of 0 can be inferred as (1&#x2014;probability of 1).</p>
<p id="h-0011" num="0000">1.1.3 Factor Client</p>
<p id="p-0099" num="0098">The Factor client can be used to create the factor nodes of the factor graph. For example, the user may define a function that returns a probability based on some input states. The factors can then be added to the factor graph as follows:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>FG.addFactor(@function,inputState1,inputState2);<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0100" num="0099">The user specifies factor graph factor nodes and associates variables with a factor graph by calling the &#x201c;addFactor&#x201d; method on a &#x201c;FactorGraph&#x201d; class instance. The &#x201c;addFactor&#x201d; method carries out numerous functions in the DMPL modeler, including automatically associating variable nodes with the factor graph, and determining that a coefficient table is not needed, for example, when such a table has already been generated for a given constraint function and set of variable domains, or when a factor node is to be hand-coded. If a coefficient table is in fact necessary, the &#x201c;addFactor&#x201d; attends to its creation.</p>
<p id="p-0101" num="0100">Users are allowed to specify their own constraint functions. However, the DMPL modeler provides a several commonly used constraint fuctions. One such constraint function is &#x201c;xorDelta&#x201d;, which is shown below:</p>
<p id="p-0102" num="0101">
<tables id="TABLE-US-00007" num="00007">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>function valid = xorDelta(varargin)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>total = 0;</entry>
</row>
<row>
<entry/>
<entry>for i = 1:length(varargin)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="70pt" align="left"/>
<colspec colname="1" colwidth="147pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>total = total+sum(varargin{i});</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
<row>
<entry/>
<entry>valid = mod(total,2) == 0;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0103" num="0102">This &#x201c;xorDelta&#x201d; constraint function accepts a variable argument list of numbers and vectors. For each argument, it calls sum (to sum the elements of a vector) and adds this to the total. Finally it returns mod(total,2)=0. The net effect is that &#x201c;xorDelta&#x201d; returns &#x201c;1&#x201d; if its arguments contain an even number of 1's and returns &#x201c;0&#x201d; if its arguments contain an odd number of 1's.</p>
<p id="p-0104" num="0103">The following two examples show different ways to add a function given the flexibility of the &#x201c;xorDelta&#x201d; constraint function.</p>
<p id="p-0105" num="0104">
<tables id="TABLE-US-00008" num="00008">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="168pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>b = Bit(3,1);</entry>
</row>
<row>
<entry/>
<entry>fg.addFactor(@xorDelta,b);</entry>
</row>
<row>
<entry/>
<entry>B = Bit(3,1);</entry>
</row>
<row>
<entry/>
<entry>fg.addFunc(@xorDelta,b(1),b(2),b(3));</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0106" num="0105">Going back to the UML diagram, each factor graph instance contains a CombinationTableFactory <b>3008</b>. In another embodiment, a FactorGraph definition can share a single CombinationTableFactory <b>3008</b> so as to avoid generating tables when an identical constraint function and domain list are specified. This CombinationTableFactory <b>3008</b> is used to retrieve or generate the coefficient table as necessary and to pass the coefficient table to the solver.</p>
<p id="p-0107" num="0106">The modeler can retrieve the constraint function string (in this case &#x201c;xorDelta&#x201d;) from the first argument. It asks the solver if it has implemented a version of this constraint function. If it has, the DMPL modeler will simply pass it the variable list and tell it to instantiate that factor node with the variable list that was passed. This can be used to avoid costly coefficient table generation.</p>
<p id="p-0108" num="0107">Assuming the solver has not implemented a factor node specifically for this MATLAB function, the factor graph will pass the constraint function and the variable argument list to the CombinationTableFactory <b>3008</b> which is responsible for retrieving (or generating) the necessary coefficient table.</p>
<p id="p-0109" num="0108">The FunctionEntryDictionary <b>3012</b> is a mapping from function names (&#x201c;xorDelta&#x201d;) to a list of coefficient tables contained in the FunctionEntry <b>3016</b> class instance. There is no one-to-one mapping between coefficient tables and function entries because &#x201c;xorDelta&#x201d;, and other constraint functions, can be called with different argument lists. Argument lists that contain different domains will likely result in different coefficient tables.</p>
<p id="p-0110" num="0109">The next step is to scan through the FunctionEntry <b>3016</b> that was retrieved for the function name (if it exists), and to try to match the given argument list to a domain list in the FunctionEntry array. To &#x201c;match&#x201d; means that the variable argument list contains a set of variables with the same dimensions and domains as the array item being examined. In the case of a match, the existing coefficient table is returned and the solver is instructed to instantiate a factor node with that table. Another optimization only passes the coefficient table to the solver once, and, in future cases, refers to it by identifier. Another embodiment could throw out the tables once it has been generated and associated to an identifier in the solver, since the solver would then be holding onto the table as well.</p>
<p id="p-0111" num="0110">Efforts to avoid unnecessary creation of a coefficient table are useful because, when generating the table from scratch, if there are m arguments with n items in their domains, the time to generate the coefficient table is O(m<sup>n</sup>).</p>
<p id="p-0112" num="0111">Since any zero entries in the coefficient table can be skipped during belief propagation, it is useful to compress the coefficient table by removing all entries for which the constraint function returned zeros. As a result, if the user adds the three-bit XOR factor nodes, the cost of building the coefficient table is incurred only once.</p>
<p id="p-0113" num="0112">To actually build the coefficient table, the modeler enumerates all combinations of the variables that were specified in the &#x201c;addGraph&#x201d; call and calls the constraint function with each of these combinations. The modeler then saves the indices of the domains in one table and the results of the constraint function in another matching vector. It then ensures that the order of the variables, when calling the constraint function, match the order of the variables passed to the &#x201c;addFactor&#x201d; call.</p>
<p id="p-0114" num="0113">Finally, the user can specify constants, rather than variables, as arguments to the &#x201c;addFactor&#x201d; call. In these cases, the DMPL modeler simplifies the implementation by creating a &#x201c;Variable&#x201d; with a single domain item matching that constant.</p>
<p id="h-0012" num="0000">1.2 Models</p>
<p id="p-0115" num="0114">A model is a representation of a factor graph that includes the nodes and the information indicating the interconnections between the nodes. DMPL applies belief propagation algorithms to the model for the purpose of solving the factor graph represented by the model. The model is kept separate from the solver because a user (e.g., a factor-graph-designer) may want to solve the factor graph specified in the model using two different solvers. In some cases switching solvers would require an undesired and possibly time consuming regeneration of the model.</p>
<p id="h-0013" num="0000">1.3 Solvers</p>
<p id="p-0116" num="0115">All created DMPL objects associate themselves with the currently selected DMPL solver using the getSolver( ) function. The solvers execute a belief propagation algorithm such as the Sum Product, Min Sum, and Gibbs algorithms. The user may choose to associate objects with a different a pre-existing solver to use or the user may define a custom solver. The desired solver can be selected using the setSolver( ) function. For example, the Min Sum solver algorithm could be selected as follows:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>setSolver(MinSumSolver( );<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0117" num="0116">A DMPL solver can be used to solve a factor graph object as follows:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>FactorGraph.solve;<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0118" num="0117">The belief propagation algorithms executed by the solvers are iterative message-passing algorithms where messages pass along the edges of the factor graph. A &#x201c;message&#x201d; can be viewed as an un-normalized probability distribution. Different solvers include different message update rules and different message update orders.</p>
<p id="p-0119" num="0118">For example, the Sum Product algorithm generalizes a number of algorithms, including the &#x201c;forward-backward&#x201d; algorithm of HMMs, and the BCJR algorithm of coding theory. It always gives the exact answer (upon convergence), when the underlying factor graph is a tree. Although it is not an exact algorithm for general graphs, belief propagation has been found to give excellent results for a wide variety of factor graphs, and runs particularly fast on sparse factor graphs (i.e. factor graphs of low node and factor degree).</p>
<p id="h-0014" num="0000">1.4 Nested Graphs</p>
<p id="p-0120" num="0119">The modeler retrieves the variable identifiers for the variables specified in the &#x201c;addGraph&#x201d; call and the graph identifier for the factor graph to be nested. It then makes a call to &#x201c;addGraph.&#x201d; Some embodiments include error checking to ensure the ordering and dimensionality of the Boundary Variables match.</p>
<p id="h-0015" num="0000">1.5 Debugging</p>
<p id="p-0121" num="0120">The user can retrieve Priors and Beliefs and can run single iterations and re-examine Beliefs. With some modification, the user can probe the connectivity of the graph, for example by entering instructions such as:</p>
<p id="p-0122" num="0121">
<tables id="TABLE-US-00009" num="00009">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="21pt" align="left"/>
<colspec colname="1" colwidth="196pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>List_of_connected_functions = v.ConnectedFunctions;</entry>
</row>
<row>
<entry/>
<entry>f = fg.addFunc(&#x3c;args&#x3e;);</entry>
</row>
<row>
<entry/>
<entry>list_of_connected_variables = f.ConnectedVariables;</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
1.6 Python Modeler
</p>
<p id="p-0123" num="0122">Because of the separation between modeler and solver, it is possible to create modelers in other languages that can share solvers. One example is a Python solver that provides many of the same features as the MATLAB DMPL modeler. The Python modeler can be extended to support matrix operations and to use operator overloading in a similar way.</p>
<p id="h-0016" num="0000">1.7 Custom Scheduling</p>
<p id="p-0124" num="0123">In some embodiments, the modeler permits a user to specify a message-passing schedule. In such embodiments, edges can be specified as by the pairs (Factor,Variable) or (Variable, Factor). A schedule can be specified as a list of edges. The Python modeler implements such a specification by using the &#x201c;setSchedule&#x201d; method, which takes a list of tuples of variables and factors. The modeler converts these variables and functions to their variable identifiers and function identifiers, and makes a call to &#x201c;setSchedule&#x201d; on the solver.</p>
<p id="p-0125" num="0124">The MATLAB embodiment of DMPL can also be readily modified to allow a user to specify a cell array of 2&#xd7;1 cell arrays containing the pairs of functions and variables to accomplish the same goal. The existing MATLAB DMPL modeler does not return function instances with the &#x201c;addFactor&#x201d; call, but could easily be extended to do so.</p>
<p id="h-0017" num="0000">1.8 Examples</p>
<p id="p-0126" num="0125">The following section illustrates the use of DMPL to specify and solve factor graphs for some exemplary belief propagation problems.</p>
<p id="h-0018" num="0000">1.8.1 Hidden Markov Model</p>
<p id="p-0127" num="0126">To illustrate how DMPL can be used to create and solve a simple factor graph, an example is presented. The example is the common Rainy/Sunny hidden Markov Model (HMM).</p>
<p id="p-0128" num="0127">In the problem, two friends who live far apart, Alice and Bob, have a daily phone conversation during which Bob mentions what he has been doing during the day. Alice knows that Bob's activity on a given day depends solely on the weather on that day, and knows some general trends about the evolution of weather in Bob's area.</p>
<p id="p-0129" num="0128">Alice believes she can model the weather in Bob's area as a Markov chain with two states &#x2018;Sunny&#x2019; and &#x2018;Rainy&#x2019;. She remembers hearing that on the first day of last week it was quite likely (70% chance) that it was sunny in Bob's town. She also knows that a sunny day follows another sunny day with 80% chance, while a sunny day succeeds a rainy day with 50% chance.</p>
<p id="p-0130" num="0129">She knows Bob pretty well, and knows that Bob only ever does one of three things: stay inside to read a book, go for a walk, or cook. She knows that if it is sunny, Bob will go for a walk with 70% probability, cook with 20% probability, and stay inside with 10% probability. Conversely, if it is rainy, Bob will go for a walk with 20% probability, cook with 40% probability, and stay inside with 40% probability.</p>
<p id="p-0131" num="0130">Bob told Alice that he went for a walk on Monday, Tuesday, and Thursday, cooked on Wednesday and Friday, and read a book on Saturday and Sunday.</p>
<p id="p-0132" num="0131">Alice wants to know what the most likely weather is for every day of last week. The above naturally defines an HMM which can easily be modeled within DMPL.</p>
<p id="p-0133" num="0132">The first step to solving this problem in DMPL is to create a factor graph using the FactorGraph( ) command.
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>HMM=FactorGraph( );<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0134" num="0133">Next, the variables of the factor graph are defined. In this example there are seven variables, MondayWeather . . . to SundayWeather. The command to create a variable is Variable(domain,dimensions). The domain includes the two distinct values &#x2018;Sunny&#x2019; and &#x2018;Rainy&#x2019;. For now, dimensions are not specified.</p>
<p id="p-0135" num="0134">
<tables id="TABLE-US-00010" num="00010">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="49pt" align="left"/>
<colspec colname="1" colwidth="168pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>Domain={&#x2018;sunny&#x2019;,&#x2018;rainy&#x2019;};</entry>
</row>
<row>
<entry/>
<entry>MondayWeather=Variable(Domain);</entry>
</row>
<row>
<entry/>
<entry>TuesdayWeather=Variable(Domain);</entry>
</row>
<row>
<entry/>
<entry>WednesdayWeather=Variable(Domain);</entry>
</row>
<row>
<entry/>
<entry>ThursdayWeather=Variable(Domain);</entry>
</row>
<row>
<entry/>
<entry>FridayWeather=Variable(Domain);</entry>
</row>
<row>
<entry/>
<entry>SaturdayWeather=Variable(Domain);</entry>
</row>
<row>
<entry/>
<entry>SundayWeather=Variable(Domain);</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0136" num="0135">Next, the different factors of the factor graph are added. First, the factors corresponding to the Markov Chain structure are added. This can be done with the command addFactor( ), which is a method of the previously defined factor graph. The command has syntax addFactor(funchandle,arguments), where funchandle is the handle of a function (e.g., a regular MATLAB function) which can be specified by the user, and the arguments are the variables involved in the factor being defined (in the same order as the inputs of the function). The number of inputs of the function referred to by the function handle has to be equal to the number of arguments of addFactor( ). The function for the example can be defined as:</p>
<p id="p-0137" num="0136">
<tables id="TABLE-US-00011" num="00011">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>function [probability]=MC_transition_Tutorial(state1,state2)</entry>
</row>
<row>
<entry/>
<entry>switch state1</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>case &#x2018;sunny&#x2019;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>if state2==&#x2018;sunny&#x2019;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>probability=0.8;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>else</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>probability=0.2;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>case &#x2018;rainy&#x2019;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>probability =0.5;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0138" num="0137">Next, the factors are added to the factor graph using the addFactor( )method</p>
<p id="p-0139" num="0138">
<tables id="TABLE-US-00012" num="00012">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>HMM.addFactor(@MC_transition_Tutorial,MondayWeather,TuesdayWeather);</entry>
</row>
<row>
<entry>HMM.addFactor(@MC_transition_Tutorial,TuesdayWeather,WednesdayWeather);</entry>
</row>
<row>
<entry>HMM.addFactor(@MC_transition_Tutorial,WednesdayWeather,ThursdayWeather);</entry>
</row>
<row>
<entry>HMM.addFactor(@MC_transition_Tutorial,ThursdayWeather,FridayWeather);</entry>
</row>
<row>
<entry>HMM.addFactor(@MC_transition_Tutorial,FridayWeather,SaturdayWeather);</entry>
</row>
<row>
<entry>HMM.addFactor(@MC_transition_Tutorial,SaturdayWeather,SundayWeather);</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0140" num="0139">The factors corresponding to the observations of each day are then added. When using an addFactor( ) command, the arguments need not be all random variables; some can be declared as constants. Thus, the addFactor( ) function can also be used to add observation factors as follows:</p>
<p id="p-0141" num="0140">
<tables id="TABLE-US-00013" num="00013">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>function [probability]=observation_function_Tutorial(state,observation)</entry>
</row>
<row>
<entry>switch state</entry>
</row>
<row>
<entry>&#x2003;case &#x2018;sunny&#x2019;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="245pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>switch observation</entry>
</row>
<row>
<entry/>
<entry>&#x2003;case &#x2018;walk&#x2019;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="231pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>probability=0.7;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="245pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x2003;case &#x2018;book&#x2019;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="231pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>probability=0.1;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="245pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x2003;case &#x2018;cook&#x2019;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="231pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>probability=0.2;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="245pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259pt" align="left"/>
<tbody valign="top">
<row>
<entry>&#x2003;case &#x2018;rainy&#x2019;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="245pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>switch observation</entry>
</row>
<row>
<entry/>
<entry>&#x2003;case &#x2018;walk&#x2019;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="231pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>probability=0.2;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="245pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x2003;case &#x2018;book&#x2019;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="231pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>probability=0.4;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="245pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>&#x2003;case &#x2018;cook&#x2019;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="231pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>probability=0.4;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="245pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259pt" align="left"/>
<tbody valign="top">
<row>
<entry>end</entry>
</row>
<row>
<entry>HMM.addFactor(@observation_function_Tutorial,MondayWeather,&#x2018;walk&#x2019;);</entry>
</row>
<row>
<entry>HMM.addFactor(@observation_function_Tutorial,TuesdayWeather,&#x2018;walk&#x2019;);</entry>
</row>
<row>
<entry>HMM.addFactor(@observation_function_Tutorial,WednesdayWeather,&#x2018;cook&#x2019;);</entry>
</row>
<row>
<entry>HMM.addFactor(@observation_function_Tutorial,ThursdayWeather,&#x2018;walk&#x2019;);</entry>
</row>
<row>
<entry>HMM.addFactor(@observation_function_Tutorial,FridayWeather,&#x2018;cook&#x2019;);</entry>
</row>
<row>
<entry>HMM.addFactor(@observation_function_Tutorial,SaturdayWeather,&#x2018;book&#x2019;);</entry>
</row>
<row>
<entry>HMM.addFactor(@observation_function_Tutorial,SundayWeather,&#x2018;book&#x2019;);</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0142" num="0141">Though the functions themselves depend on two variables, each factor only depends on one random variable (the other argument being set as a constant during the addFactor( ) call). This in effect creates a factor connected only to one variable of the factor graph.</p>
<p id="p-0143" num="0142">Finally, the prior probabilities for the MondayWeather variable are added using the input method. For a vector of probabilities (i.e. nonnegative numbers which sums up to one), the method Variable.Input adds a single factor, which depends on this variable only, with values equal to those given by the vector.</p>
<p id="p-0144" num="0143">For this example, the input method is used as follows:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>MondayWeather.Input=[0.7 0.3];<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0145" num="0144">The factor graph can then be solved using the solve( ) iterate( ) and NumIterations( ) factor graph methods as is illustrated in the following example code. First, the number of iterations is chosen and then the solver is run for that many iterations.
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>HMM.NumIterations=20;<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>HMM.solve;<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0146" num="0145">In some examples, the solve command executes the Sum-Product algorithm using a flooding schedule. A flooding schedule can be described as first computing all equals nodes, then computing all function nodes, and repeating for a specified number of iterations.</p>
<p id="p-0147" num="0146">After the solver has finished running, the resulting marginal distribution of each variable can be accessed using the Belief command as follows:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>TuesdayWeather.Belief<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0148" num="0147">The Belief command can return a vector of probabilities of the same length as the total size of the domain (i.e. the product of its dimensions), including the probability of each domain variable.</p>
<p id="h-0019" num="0000">1.8.2 Four Bit XOR</p>
<p id="p-0149" num="0148">The following is a more complex example that includes defining a factor graph with 4 variables tied through a 4-bit XOR, with prior probabilities.</p>
<p id="p-0150" num="0149">Given a set of four random variables (B<sub>1</sub>, B<sub>2</sub>, B<sub>3</sub>, B<sub>4</sub>) taking values 0 or 1. The joint probability distribution is given by:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>P</i>(<i>B</i><sub>1</sub><i>,B</i><sub>2</sub><i>,B</i><sub>3</sub><i>,B</i><sub>4</sub>)=&#x3b4;<sub>(B</sub><sub><sub2>1</sub2></sub><sub>+B</sub><sub><sub2>2</sub2></sub><sub>+B</sub><sub><sub2>3</sub2></sub><sub>+B</sub><sub><sub2>4</sub2></sub><sub>=0(mod </sub>2))<i>P</i>(<i>B</i><sub>1</sub>)<i>P</i>(<i>B</i><sub>2</sub>)<i>P</i>(<i>B</i><sub>3</sub>)<i>P</i>(<i>B</i><sub>4</sub>)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
where the delta function &#x3b4;( ) is equal to 1 if the underlying constraint is satisfied, and 0 otherwise (this ensures that illegal assignments have probability zero). The P(B<sub>i</sub>) are single variable factors which help model which values of B<sub>i </sub>are more likely to be taken (Typically, the factor will represent an observation of O<sub>i </sub>of variable B<sub>i</sub>, and the factor P(B<sub>i</sub>) is set equal to the normalized function P(O<sub>i</sub>|B<sub>1</sub>). For this example, P(B<sub>1</sub>=1)=P(B<sub>2</sub>=1)=P(B<sub>3</sub>=1)=0.8 and P(B<sub>4</sub>&#x2212;1)=0.5.
</p>
<p id="p-0151" num="0150">The factor graph for this example can be built in two different ways. The first directly uses a 4-bit XOR, and uses mostly tools seen in the previous example. The second introduces the Bit kind of random variable, and how to use an intermediate variable to reduce the degree of a factor graph with parity checks (i.e. XOR function).</p>
<p id="p-0152" num="0151">The first way of building the factor graph uses an inefficient N-bit XOR function defined as follows:</p>
<p id="p-0153" num="0152">
<tables id="TABLE-US-00014" num="00014">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>function [valid]=BadNBitXorDelta_Tutorial(variables)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>valid=mod(sum(variables),2)==0;</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
Based on the previous example, the sequence of instructions used is:
</p>
<p id="p-0154" num="0153">
<tables id="TABLE-US-00015" num="00015">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>FourBitXor=FactorGraph( );</entry>
</row>
<row>
<entry>Domain=[0;1];</entry>
</row>
<row>
<entry>B1=Variable(Domain);</entry>
</row>
<row>
<entry>B2=Variable(Domain);</entry>
</row>
<row>
<entry>B3=Variable(Domain);</entry>
</row>
<row>
<entry>B4=Variable(Domain);</entry>
</row>
<row>
<entry>FourBitXor.addFactor(@BadNBitXorDelta_Tutorial,[B1,B2,B3,B4]);</entry>
</row>
<row>
<entry>B1.Input=[0.2 0.8];</entry>
</row>
<row>
<entry>B2.Input=[0.2 0.8];</entry>
</row>
<row>
<entry>B3.Input=[0.2 0.8];</entry>
</row>
<row>
<entry>B4.Input=[0.5 0.5];</entry>
</row>
<row>
<entry>FourBitXor.NumIterations=30;</entry>
</row>
<row>
<entry>FourBitXor.solve;</entry>
</row>
<row>
<entry>disp(B1.Value);</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0155" num="0154">Note that the Variable method &#x2018;Value&#x2019; returns the most likely assignment of that random variable.</p>
<p id="p-0156" num="0155">The second version of the 4-bit XOR uses Bit variables to represent the random variables. Furthermore, it will decompose the 4 bit XOR into two 3-bit XORs. It can be proven that
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>B</i><sub>1</sub><i>+B</i><sub>2</sub><i>+B</i><sub>3</sub><i>+B</i><sub>4</sub>=0(mod 2)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>is equivalent to<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>B</i><sub>1</sub><i>+B</i><sub>2</sub><i>+C=</i>0(mod 2)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>B</i><sub>3</sub><i>+B</i><sub>4</sub><i>+C=</i>0(mod 2)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
for an internal bit C. Furthermore, any N-bit XOR can be reduced to a tree of 3-bit XORs, with depth log(N). The complexity of running a belief propagation algorithm is exponential in the degree of factors. Thus, using this technique leads to dramatic speed improvements.
</p>
<p id="p-0157" num="0156">Referring to <figref idref="DRAWINGS">FIG. 5</figref>, a factor graph of a 4-bit XOR decomposed into two 3-bit XORs is illustrated. This factor graph can be defined as follows:</p>
<p id="p-0158" num="0157">
<tables id="TABLE-US-00016" num="00016">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>function valid = XorDeltaTutorial(x,y,z)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>valid = bitXor(bitXor(x,y),z);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>end</entry>
</row>
<row>
<entry/>
<entry>XorGraph = FactorGraph( );</entry>
</row>
<row>
<entry/>
<entry>b = Bit(4,1);</entry>
</row>
<row>
<entry/>
<entry>c = Bit( );</entry>
</row>
<row>
<entry/>
<entry>XorGraph.addFactor(@XorDeltaTutorial,b(1),b(2),c);</entry>
</row>
<row>
<entry/>
<entry>XorGraph.addFactor(@XorDeltaTutorial,b(3),b(4),c);</entry>
</row>
<row>
<entry/>
<entry>b.Input = [ .8 .8 .8 .5];</entry>
</row>
<row>
<entry/>
<entry>XorGraph.NumIterations = 2;</entry>
</row>
<row>
<entry/>
<entry>XorGraph.solve( );</entry>
</row>
<row>
<entry/>
<entry>disp(b.Belief);</entry>
</row>
<row>
<entry/>
<entry>disp(b.Value);</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
1.8.3 Nesting Factor Graphs
</p>
<p id="p-0159" num="0158">As was previously mentioned, in some examples it is useful to re-use previously created factor graphs as building blocks for larger factor graphs. For example, two 4-bit XORs from the previous example can be used to create a 6-bit code as shown in the factor graph of <figref idref="DRAWINGS">FIG. 6</figref>.</p>
<p id="p-0160" num="0159">In order to specify a nested factor graph, DMPL provides a way to replicate multiple copies of a factor graph and nest these instances in a containing factor graph. A nested factor graph can be seen as a special factor function between a set of variables (&#x2018;connector variables&#x2019;), which, when &#x2018;zoomed in,&#x2019; is in fact another factor graph, with factors involving both the connector variables, and other &#x2018;internal variables.&#x2019;</p>
<p id="p-0161" num="0160">In the second version of the XOR tutorial, a 4-bit XOR connected to 4 variables was created, by also creating an extra Bit C. Nested factor graphs enable the use of such a 4-bit XOR to create potentially many different sets of 4 bits, overlapping or not, by replicating the factor graph as needed.</p>
<p id="p-0162" num="0161">A nestable factor graph is created by specifying first a set of &#x2018;connector&#x2019; random variables, and invoking the command FactorGraph(S).</p>
<p id="p-0163" num="0162"><figref idref="DRAWINGS">FIG. 7</figref> illustrates a factor graph that includes nested factor graphs. The following code creates specifies the factor graph illustrated in <figref idref="DRAWINGS">FIG. 7</figref>:</p>
<p id="p-0164" num="0163">
<tables id="TABLE-US-00017" num="00017">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>%Define 4 bit Xor from two 3 bit Xors</entry>
</row>
<row>
<entry>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</entry>
</row>
<row>
<entry>b = Bit(4,1);</entry>
</row>
<row>
<entry>XorGraph = FactorGraph(b);</entry>
</row>
<row>
<entry>c = Bit( );</entry>
</row>
<row>
<entry>XorGraph.addFactor(@XorDeltaTutorial,b(1),b(2),c);</entry>
</row>
<row>
<entry>XorGraph.addFactor(@XorDeltaTutorial,b(3),b(4),c);</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0165" num="0164"><figref idref="DRAWINGS">FIG. 14</figref> illustrates the factor graph specified by the preceding code.</p>
<p id="h-0020" num="0000">2 Hardware implementation of DMPL Factor Graphs</p>
<p id="p-0166" num="0165">Referring again to <figref idref="DRAWINGS">FIG. 3</figref>, in some embodiments of the development system <b>1000</b>, a factor graph model formed as the output of a software development module, in particular as the output of the DMPL module <b>1006</b>, may be provides as input to a hardware synthesis and/or simulation component. As described fully in Section 3, in one embodiment, a FADL module <b>1010</b> is used as part of the process of simulating and/or fabricating factor graph hardware. For example, a DMPL FactorGraph object can be created in the software development environment and used to instantiate a FADL object as follows:</p>
<p id="p-0167" num="0166">
<tables id="TABLE-US-00018" num="00018">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>#Create the graph, bits, and function</entry>
</row>
<row>
<entry>setSolver(MinSumSolver( ))</entry>
</row>
<row>
<entry>factorGraph = FactorGraph( )</entry>
</row>
<row>
<entry>bits = [Bit( ),Bit( ),Bit( )]</entry>
</row>
<row>
<entry>f = factorGraph.addFunc(xorDelta,*bits)</entry>
</row>
<row>
<entry>##################################################################</entry>
</row>
<row>
<entry># Create the FADL object from the DMPL factor graph.</entry>
</row>
<row>
<entry>#################################################################</entry>
</row>
<row>
<entry>fadl = FADL(factorGraph=factorGraph,priors=bits,beliefs=bits,\</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="245pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>numIterations=numIterations,differential=differential)</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
<br/>
3 FADL
</p>
<p id="p-0168" num="0167">The FADL module <b>1010</b>, shown in <figref idref="DRAWINGS">FIG. 3</figref>, is an example of a software module that provides a way of taking an input specification for a factor graph, either directly from a user <b>1002</b>, or as the output of a software development module, such as DMPL <b>1006</b>, which is described above, and provides output that is used to drive a device fabrication process <b>1016</b>, or a hardware simulation <b>2030</b>.</p>
<p id="p-0169" num="0168">A physical circuit that implements the factor graphs does not have nodes and edges. Instead, it has physical circuit elements, such as transistors, diodes, resistors, and capacitors. These elements occupy a semiconductor substrate with conducting traces providing pathways between one element and another. The process of actually building the physical circuit generally includes translating the factor graph into a pattern of circuit elements and connecting traces on a semiconductor substrate.</p>
<p id="p-0170" num="0169">In an effort to reduce power consumption and area of the overall physical circuit, it is often preferable for certain circuit elements to implement more than one node on the factor graph. Because the same circuit elements are carrying out different functions at different cycles, it becomes necessary to provide switches and memory elements to orchestrate the activities of the circuit elements. The switches selectively switch circuit elements in and out of the circuit as the need arises, thus enabling it to change its role during operation of the network. The memory elements provide a place to temporarily hold values when the circuit element changes its role.</p>
<p id="p-0171" num="0170">The existence of switches and memory elements, and the timing issues associated with determining how the switches should be set at any instant, creates a massive bookkeeping problem that greatly exacerbates the difficulty of translating a factor graph into a particular layout of hardware elements.</p>
<p id="p-0172" num="0171"><figref idref="DRAWINGS">FIG. 8</figref> shows a semiconductor foundry <b>10</b> for the manufacture of an ASIC (application specific integrated circuit) having a belief propagation network. The foundry <b>10</b> includes a semiconductor processing device that takes articles <b>12</b>, such as semiconductor wafers, and transforms them into ASICs <b>14</b> having imprinted thereon circuitry for implementing a belief propagation network. The circuitry for implementing a belief propagation network includes transistors and diodes, as well as resistive and reactive (e.g. capacitors) linear circuit elements arranged to form digital and/or analog circuits.</p>
<p id="p-0173" num="0172">To enable the foundry <b>10</b> to actually lay down circuit elements and connections on a semiconductor substrate, it is useful to provide the foundry <b>10</b> with information on where to place the circuit elements so that they cooperate in a satisfactory manner. The information on where to place circuit elements is provided to the foundry <b>10</b> by a hardware architect <b>18</b> who receives, from the factor-graph designer (not shown), an initial representation <b>20</b> of a belief propagation network. This initial representation specifies nodes and edges of a factor graph, together with any hardware constraints to be imposed on the belief propagation network.</p>
<p id="p-0174" num="0173">Upon receiving the initial representation <b>20</b>, the hardware architect <b>18</b> creates an HDL representation <b>24</b> of the factor graph and its associated constraints using a hardware descriptor language (&#x201c;HDL&#x201d;) such as VERILOG. This HDL representation <b>24</b> would include empty nodes (i.e. nodes that do not necessarily specify any hardware within them, and can thus serve as placeholders), the interconnection between nodes, and the placement of switches and memory elements needed to enable circuit elements to serve more than one function. If necessary, the task of filling in the nodes, and thereby specifying what is in the nodes themselves, is carried out by the hardware architect <b>18</b>. If the contents of the nodes already exist, then no further human intervention is needed.</p>
<p id="p-0175" num="0174">This HDL representation <b>24</b> is in the form of VERILOG code. The resulting VERILOG code can then be provided to a hardware simulator <b>23</b>, such as SPECTER, or used as a basis for fabricating an actual circuit on a semiconductor substrate at the foundry <b>10</b>, as described below.</p>
<p id="p-0176" num="0175">The task as described thus far involves two separate stages: (1) a first stage that results in creation of an initial representation of a factor graph, which would include a specification of nodes, edges, and constraints on what hardware is to be used for which nodes; and (2) a second stage in which the initial representation is used to create an HDL representation that includes details on what hardware elements are to be in the nodes. These two stages have been described as being carried out by two separate entities. In practice, nothing precludes a single entity or person from performing both.</p>
<p id="p-0177" num="0176">The next step in the descent from the initial design of the factor graph into the manufacture of integrated circuits would be to provide the HDL representation <b>24</b> to a floor planner <b>22</b> for translation into a floor plan <b>16</b>. This floor plan <b>16</b> would include details such as where on the substrate the physical circuit elements should go, what the paths of the wires connecting them should be, and what regions of the semiconductor substrate should be doped to actually form the various circuit elements.</p>
<p id="p-0178" num="0177">Because the floor planner <b>22</b> is tied to a particular foundry <b>10</b>, it is able to provide the floor plan to that particular foundry <b>10</b>. The foundry <b>10</b> then uses this floor plan <b>16</b> as a basis for physically transforming tangible articles <b>12</b>, such as semiconductor wafers, into a finished product <b>14</b>. Thus, it can be said that the hardware architect <b>18</b>, who generates the HDL representation <b>24</b> and the floor planner <b>22</b>, which generates the floor plan <b>16</b>, all participate in the transformation of the article <b>12</b>.</p>
<p id="p-0179" num="0178">Note that although the floor planner <b>22</b> could in principle be a fully automated device, in many cases, the floor planning process also requires the assistance of a human to perform some layout and routing of electronic structures.</p>
<p id="p-0180" num="0179">The translation from an initial representation <b>20</b> of a belief propagation network to a corresponding HDL representation <b>24</b> is to some extent hampered by cognitive limitations of even the most skilled hardware architect <b>18</b>. For large factor graphs with numerous constraints, the task can be painstaking and slow. Inevitably, errors arise in translation. These errors further delay transformation of the article <b>12</b>.</p>
<p id="p-0181" num="0180">In many cases, it is possible to exploit the properties of the factor graph itself to partially automate the process of translation from the initial representation <b>20</b> of a belief propagation network into an HDL representation <b>24</b>. In such an implementation, shown in <figref idref="DRAWINGS">FIG. 9</figref>, a factor-graph designer <b>26</b> provides an initial representation <b>28</b> of the factor graph using a factor graph ASIC description language (&#x201c;FADL&#x201d;). A FADL translator <b>30</b> then carries out method steps, which are described in detail below, to translate this FADL representation <b>20</b> into an HDL representation <b>32</b> of the belief propagation network. In some embodiments, the FADL translator <b>30</b> is a compiler, whereas in others it is an interpreter.</p>
<p id="p-0182" num="0181">The HDL representation <b>32</b> specifies the interconnections between nodes of the factor graph, as well as any switches or memory elements that are needed to comply with the constraints. It also includes nodes for receiving hardware that is to be specified by the hardware architect <b>18</b>.</p>
<p id="p-0183" num="0182">If the logic gates have already been made and the automatically HDL representation <b>32</b> is sufficient, the HDL representation <b>32</b> can be provided directly to the floor planner <b>22</b>. Alternatively, the HDL representation <b>32</b> is provided to the hardware architect <b>18</b>. As suggested above, the hardware architect <b>18</b> then writes HDL code for whatever is to fill the nodes. He then proceeds as described in connection with <figref idref="DRAWINGS">FIG. 8</figref>. In this way, the steps carried out by the FADL translator <b>30</b> assist the foundry <b>10</b> in transforming a tangible article <b>12</b> from a first state, in which it lacks an ASIC for implementing a belief propagation network, into a second state in which such an ASIC is present.</p>
<p id="p-0184" num="0183">Because of the FADL translator <b>30</b>, the hardware architect <b>18</b> no longer has to determine what switches and memory elements are needed, where they should be placed, and when they should be enabled to enforce the constraints set forth in the FADL representation <b>20</b>. This difficult and error-prone task would already have been carried out by the FADL translator <b>30</b>. Instead, the hardware architect <b>18</b> proceeds directly with specifying what hardware elements are to be placed in the nodes left empty by the FADL translator <b>30</b>.</p>
<p id="p-0185" num="0184">The following description sets forth an implementation of a FADL translator <b>30</b> for automatically transforming a FADL representation <b>20</b> of a belief propagation network into an HDL representation of that network. The particular implementation described herein makes use of the PYTHON programming language. Because factor graphs are represented internally as connectivity matrices, considerable use is made of PYTHON's NumPy extension for working with the large matrices. However, other programming environments, such as MATLAB, or a combination having MATLAB as a front end and Java or C++ as a back end, can also be used. Other implementations are summarized in Appendix 1 and Appendix 2, attached hereto.</p>
<p id="p-0186" num="0185"><figref idref="DRAWINGS">FIG. 10</figref> shows an exemplary factor graph having eight variable nodes and four function nodes. A suitable representation of such a factor graph is:</p>
<p id="p-0187" num="0186">
<maths id="MATH-US-00005" num="00005">
<math overflow="scroll">
<mrow>
  <mi>A</mi>
  <mo>=</mo>
  <mrow>
    <mi>numpy</mi>
    <mo>.</mo>
    <mrow>
      <mi>array</mi>
      <mo>&#x2061;</mo>
      <mrow>
        <mo>(</mo>
        <mrow>
          <mo>[</mo>
          <mrow>
            <mrow>
              <mo>[</mo>
              <mrow>
                <mn>1</mn>
                <mo>,</mo>
                <mn>0</mn>
                <mo>,</mo>
                <mn>1</mn>
                <mo>,</mo>
                <mn>0</mn>
                <mo>,</mo>
                <mn>1</mn>
                <mo>,</mo>
                <mn>0</mn>
                <mo>,</mo>
                <mn>0</mn>
                <mo>,</mo>
                <mn>0</mn>
                <mo>,</mo>
              </mrow>
              <mo>]</mo>
            </mrow>
            <mo>,</mo>
            <mrow>
              <mi>\[</mi>
              <mo>&#x2062;</mo>
              <mrow>
                <mn>1</mn>
                <mo>,</mo>
                <mn>0</mn>
                <mo>,</mo>
                <mn>0</mn>
                <mo>,</mo>
                <mn>1</mn>
                <mo>,</mo>
                <mn>0</mn>
                <mo>,</mo>
                <mn>1</mn>
                <mo>,</mo>
                <mn>0</mn>
                <mo>,</mo>
                <mn>0</mn>
              </mrow>
              <mo>]</mo>
            </mrow>
            <mo>,</mo>
            <mrow>
              <mi>\[</mi>
              <mo>&#x2062;</mo>
              <mrow>
                <mn>0</mn>
                <mo>,</mo>
                <mn>1</mn>
                <mo>,</mo>
                <mn>1</mn>
                <mo>,</mo>
                <mn>0</mn>
                <mo>,</mo>
                <mn>0</mn>
                <mo>,</mo>
                <mn>0</mn>
                <mo>,</mo>
                <mn>1</mn>
                <mo>,</mo>
                <mn>0</mn>
              </mrow>
              <mo>]</mo>
            </mrow>
            <mo>,</mo>
            <mrow>
              <mi>\[</mi>
              <mo>&#x2062;</mo>
              <mrow>
                <mn>0</mn>
                <mo>,</mo>
                <mn>1</mn>
                <mo>,</mo>
                <mn>0</mn>
                <mo>,</mo>
                <mn>1</mn>
                <mo>,</mo>
                <mn>0</mn>
                <mo>,</mo>
                <mn>0</mn>
                <mo>,</mo>
                <mn>0</mn>
                <mo>,</mo>
                <mn>1</mn>
              </mrow>
              <mo>]</mo>
            </mrow>
          </mrow>
          <mo>]</mo>
        </mrow>
        <mo>)</mo>
      </mrow>
    </mrow>
  </mrow>
</mrow>
</math>
</maths>
</p>
<p id="p-0188" num="0187">In the above representation, each row corresponds to a function node and each column corresponds to a variable node. A &#x201c;1&#x201d; at the intersection of a particular row and column indicates the existence of an edge that connects the corresponding function node and variable node. Thus, the above matrix is often referred to as a &#x201c;connectivity&#x201d;, or &#x201c;biadjacency&#x201d; matrix for the factor graph.</p>
<p id="p-0189" num="0188">The function nodes and variable nodes referred to above will be referred to as &#x201c;logical nodes.&#x201d; These logical nodes are distinct from the &#x201c;physical nodes&#x201d; that actually contain the circuitry for implementing the logical nodes. It is possible, with the judicious placement of switches and memory elements, for one physical node to carry out the function of several logical nodes. This time-sharing of physical nodes to play the role of multiple logical nodes reduces the circuit's overall footprint and power consumption.</p>
<p id="p-0190" num="0189">In the example of <figref idref="DRAWINGS">FIG. 10</figref>, one constraint might be to require that whatever hardware is used to implement function node X<b>0</b> also be used to implement function node X<b>1</b>, and that whatever hardware is used to implement function node X<b>2</b> should also be used to implement function node X<b>3</b>. The resulting physical circuit would thus have hardware elements shared among four function nodes. Since the same circuitry can often be used to implement different functions, these functions can be different from each other.</p>
<p id="p-0191" num="0190">In some cases, circuitry will need some reconfiguration to implement different function nodes. Thus, there may be embodiments in which the circuitry in a particular physical node is reconfigured whenever it is called upon to stop executing the function of a one logical node and begin executing the function of another logical node. In such cases, the physical node can have an additional input to enable a controller to specify the proper configuration of the circuitry within that node.</p>
<p id="p-0192" num="0191">In some belief propagation networks, XOR processors implement function nodes and equals processors implement variable nodes. The following discussion assumes a belief propagation network of this type. However, the representations described below are general and do not require any particular implementation of a variable or function node. In general, a factor graph can have different types of function nodes.</p>
<p id="p-0193" num="0192">The foregoing constraint on function nodes is represented as a list of sub-lists in which each of the sub-lists corresponds to a physical XOR, and in which the elements of a sub-list define the logical XORs implemented by a particular physical XOR. An example of such a constraint appears as follows:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>physXors=[[0,1],[2,3]]<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0194" num="0193">In the above expression, the first sub list &#x201c;[0, 1]&#x201d; corresponds to the first physical node. The elements <b>0</b> and <b>1</b> indicate that logical nodes <b>0</b> and <b>1</b> are to be implemented by circuitry contained in the first physical node. Similarly, the second sub list indicates that logical nodes <b>2</b> and <b>3</b> are to be implemented by circuitry in the second physical node. In some implementations, the logical nodes can be identified in the above expression by edges uniquely associated with those nodes.</p>
<p id="p-0195" num="0194">Constraints in the number of equals-processors are also represented as a list of sub-lists. For example, a belief propagation network in which equals-nodes <b>4</b> and <b>5</b> and equals-nodes <b>6</b> and <b>7</b> share hardware and the remaining nodes have their own dedicated circuits could be represented by the following constraint, also in the form of a list of sub-lists:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>physEquals=[[0],[1],[2],[3],[4,5],[6,7]]<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0196" num="0195"><figref idref="DRAWINGS">FIG. 11</figref> shows an adjacency matrix corresponding to the two constraints described above. A machine-readable representation of such a matrix is provided to the FADL translator <b>30</b> to be used in connection with generating the corresponding hardware description language representation <b>32</b>. A physical realization of such an adjacency matrix has switches for enabling physical XOR <b>1</b> to switch between being connected to equals-nodes <b>3</b> and <b>4</b>, and for enabling physical XOR <b>2</b> to switch between being connected to equals-nodes <b>3</b> and <b>4</b>.</p>
<p id="p-0197" num="0196">To determine the correct configuration of switches, the FADL translator <b>30</b> recognizes: that each row in <figref idref="DRAWINGS">FIG. 11</figref> corresponds to a logical XOR node, that each column corresponds to a logical equals node, that the physical equals-processor used to implement a particular logical equals node is at the top of the column corresponding to that logical equals node, and that and that the physical XOR-processor for implementing a corresponding logical XOR node is listed in the right-most column of the matrix.</p>
<p id="p-0198" num="0197">For example, according to <figref idref="DRAWINGS">FIG. 11</figref>, logical equals node <b>1</b> and <b>0</b> are both implemented by circuitry in physical equals node <b>5</b>; logical equals node <b>4</b> is implemented by circuitry in physical equals node <b>4</b>, and logical XOR nodes <b>1</b> and <b>2</b> are implemented by circuitry in physical XOR node <b>1</b>.</p>
<p id="p-0199" num="0198">Using the machine-readable representation of the adjacency matrix, the FADL translator <b>30</b> recognizes: that physical equals-processors <b>1</b> and <b>5</b> only need to connect to physical XOR-processor <b>1</b>; that physical equals-processors <b>2</b> and <b>6</b> only need to connect to physical XOR-processor <b>2</b>; and that physical equal processor <b>3</b> and <b>4</b> must be able to connect to both of the physical XOR-processors. Based on the foregoing observations, the FADL translator <b>30</b> specifies, in the HDL representation <b>32</b>, that switches must be placed to selectively connect physical equals-processors <b>3</b> and <b>4</b> to either one of the two physical XOR-processors <b>1</b> and <b>2</b>.</p>
<p id="p-0200" num="0199">A suitable VERILOG description of the foregoing factor graph can include VERILOG modules corresponding to the two kinds of nodes present in the factor graph. These modules would be provided by the hardware architect <b>18</b> to specify the specific circuitry within those nodes. However, the FADL translator <b>30</b> would automatically generate the wires connecting the nodes and the switches for directing data flow in a manner consistent with both the hardware constraints and the logical design of the factor graph. For the factor graph shown in <figref idref="DRAWINGS">FIG. 10</figref> subject to the above-mentioned hardware constraints, an abstraction of a resulting physical circuit appears as shown in <figref idref="DRAWINGS">FIG. 12</figref>.</p>
<p id="p-0201" num="0200">In <figref idref="DRAWINGS">FIG. 12</figref>, a physical circuit <b>40</b> for realizing the adjacency matrix in <figref idref="DRAWINGS">FIG. 11</figref> includes two XOR-processors <b>42</b><i>a</i>, <b>42</b><i>b</i>, each of which has three inputs <b>44</b>, and six equals-processors <b>46</b><i>a</i>-<i>f</i>. Some of the equals-processors <b>46</b><i>a</i>-<i>b</i>, <b>46</b><i>e</i>-<i>f </i>are connected to only one input of one of the XOR-processors. The remaining equals-processors <b>46</b><i>c</i>-<i>d </i>are connectable to either one of the XOR-processors by switches <b>48</b><i>a</i>-<i>d. </i></p>
<p id="p-0202" num="0201">Since a particular physical equals-processor may be shared by multiple logical equals-processors, it is useful to provide some sort of memory <b>50</b><i>a</i>-<i>b </i>for storing values to be used during a particular cycle of the belief propagation network. In the illustrated embodiment, these memories <b>50</b><i>a</i>-<i>b </i>are associated with the equals-processors. It is also useful to provide switches <b>52</b> so that a particular equals-processor can switch between memories, thereby enabling it to play the role of one logical equals-processor during one cycle and another logical equals-processor during another cycle. Alternatively, an output enable signal can be provided to whichever memory is to be used during a particular cycle. In general, an equals-processor needs one memory for each non-zero entry in the adjacency matrix of <figref idref="DRAWINGS">FIG. 11</figref>.</p>
<p id="p-0203" num="0202">In addition to the adjacency matrix of <figref idref="DRAWINGS">FIG. 11</figref>, the factor-graph designer <b>26</b> also provides information specifying inputs and outputs at each cycle of the belief propagation network. In cases in which the belief propagation network includes multiple nodes that are realized by the same physical circuitry, there will often be multiple physical cycles required to implement one cycle of the belief propagation network. This arises because a particular physical circuit, although it can function as more than one node, cannot function as more than one node at the same time. These physical cycles will be referred to herein as &#x201c;sub-cycles.&#x201d;</p>
<p id="p-0204" num="0203">factor-graph designer <b>26</b> specifies inputs by providing a list of sub-lists. Each sub-list corresponds to the inputs to be provided at the beginning of a particular cycle. The entries of a sub-list corresponding to a particular cycle specify the equals-nodes that are to be provided with inputs at the beginning of that cycle. This results in the specification of which input memories are to be enabled at the beginning of each sub-cycle within that cycle so that data in those memories will be available during that sub-cycle.</p>
<p id="p-0205" num="0204">Similarly, for specifying outputs, the factor-graph designer <b>26</b> provides another list of sub-lists, with the list having as many sub-lists as there are cycles. The elements of a sub-list corresponding to a particular cycle specify those outputs that are to be read at the beginning of that cycle.</p>
<p id="p-0206" num="0205">Having defined the hardware configuration, the FADL translator <b>30</b> then generates sequencing information, which is stored in a ROM on the ASIC, where it is conveniently available for inspection by a finite state machine during operation of the belief propagation network. Such sequencing information includes information about which switches are closed and which memory elements are to be active when the machine is in a particular state. Alternatively, the sequencing information can be generated by hand when it is more efficient to do so.</p>
<p id="p-0207" num="0206">The sequencing information to be written in ROM is generated by the FADL translator <b>30</b> on the basis of information provided by the factor-graph designer <b>26</b>. In one practice, the factor-graph designer <b>26</b> provides the FADL translator <b>30</b> with a list of sub-lists. Each sub-list corresponding to a particular cycle. The number of sub-lists thus corresponds to the number of cycles. The elements of each sub-list specify the logical function nodes that are to be updated when the machine is in the cycle corresponding to that sub-list. For example, the following state specification:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>updatelist((0,3),(1,2))<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
specifies that when the machine is in the first cycle, logical function nodes <b>0</b> and <b>3</b> are to be updated, and when the machine is in the second cycle, logical function nodes <b>1</b> and <b>2</b> are to be updated. It is unnecessary for the factor-graph designer <b>26</b> to specify physical function nodes because the FADL translator <b>30</b> recognizes how to translate from a logical node to a corresponding physical node. Using the adjacency matrix, the FADL translator <b>30</b> specifies, for each sub-cycle, the state of each switch, input enable, and output enable corresponding to that sub-cycle.
</p>
<p id="p-0208" num="0207">In an alternative practice, the factor-graph designer <b>26</b> provides a list of edges that are to be active during a particular sub-cycle. This implementation can likewise be carried out by having the factor-graph designer <b>26</b> provide a list of sub-lists, with each sub-list specifying those edges that are active during a particular sub-cycle.</p>
<p id="p-0209" num="0208">Referring now to <figref idref="DRAWINGS">FIG. 13</figref>, a method for operating a semiconductor foundry <b>10</b> or a hardware-simulator includes receiving a representation of a belief propagation network (steps <b>62</b>). In response, empty nodes are generated. (step <b>66</b>). The actual hardware to be placed into these empty nodes is specified in a later step.</p>
<p id="p-0210" num="0209">Also generated is information concerning connections between the nodes (step <b>68</b>), as well as information concerning placement of switches or memory elements required to satisfy the hardware constraints (step <b>70</b>, <b>72</b>), and input and output circuitry (step <b>74</b>). Then, sequencing information governing the activities of the various circuit elements during operation of the belief propagation network is generated (step <b>80</b>).</p>
<p id="p-0211" num="0210">A partially-completed HDL representation of a belief propagation network's physical realization is then provided to the hardware architect, who specifies the hardware contained in the empty nodes (step <b>76</b>). The now completed HDL representation is provided to a floor-planner (step <b>78</b>), which generates a plan showing the layout of the actual semiconductor chip. This layout is then provided to the foundry (step <b>83</b>) to be used in connection with fabrication of ASICs.</p>
<p id="p-0212" num="0211">Alternatively, the completed HDL representation is provided to a hardware simulator for testing and debugging.</p>
<p id="p-0213" num="0212"><figref idref="DRAWINGS">FIG. 7</figref> shows typical FADL representation <b>20</b> in PYTHON to be provided to the FADL translator <b>30</b> for generating an HDL representation of a 3-bit XOR as shown in <figref idref="DRAWINGS">FIG. 15</figref>.</p>
<p id="p-0214" num="0213">The first two instructions <b>90</b> import the FADL module, which includes the &#x201c;FADLgenVerilog&#x201d; code for generating the VERILOG representation of the factor graph. The module &#x201c;numpy&#x201d; is a PYTHON module having numerous functions for matrix manipulation, one of which is used to represent a bi-adjacency matrix, as shown in matrix assignment <b>92</b>. According to PYTHON syntax, [[1,1,1]] creates a list having a sub-list with three elements, all of which are 1's. The &#x201c;np.array&#x201d; function converts this into a two-dimensional numpy array. Matrices that are too large to conveniently include in code can also be read from an external file.</p>
<p id="p-0215" num="0214">The next few instructions specify the hardware constraints and sequencing information.</p>
<p id="p-0216" num="0215">The &#x201c;edgeGroups&#x201d; constraint <b>94</b> avoids needless memory allocation when many elements of the adjacency matrix are zero. The &#x201c;edgeGroups&#x201d; constraint <b>94</b> assigns all non-zero elements of the matrix to a single memory group. The argument &#x201c;A.nonzero( )&#x201d; is a function that returns a tuple of lists in which the first element contains the indices of the first dimension and the second element contains the indices of the second dimension. Calling &#x201c;*&#x201d; on a tuple unpacks it. The &#x201c;zip&#x201d; function takes two lists and returns a list of tuples. Thus, the &#x201c;edgegroup&#x201d; instruction <b>94</b> converts from the &#x201c;nonzero( )&#x201d; function output format to the &#x201c;edgeGroup&#x201d; input format.</p>
<p id="p-0217" num="0216">As discussed earlier, the &#x201c;physXors&#x201d; constraint <b>96</b> is a list of sub-lists specifying which physical XORs serve as which logical XORs. This constraint makes it possible to avoid having a full parallel factor graph, which would consume considerable area and power.</p>
<p id="p-0218" num="0217">In some cases, it is useful to group physical XORs into modules. The &#x201c;xorGroups&#x201d; constraint <b>98</b> allows such grouping to be carried out. The data structure expected by &#x201c;xorGroups&#x201d; is a list of sub-lists, with each sub-list representing an XOR group. The elements in each of the sub-lists are the physical XOR indices, i.e. the indices used to identify the physical XORs in the &#x201c;physXors&#x201d; list of sub-lists. The FADL FADL translator ensures that only one XOR group refers to a particular physical XOR.</p>
<p id="p-0219" num="0218">The &#x201c;bitMemGroups&#x201d; constraint <b>100</b> specifies the memories that contain prior probabilities used as inputs when implementing belief propagation on a factor graph. Like the XORs, these memories are grouped into memory groups. The format for grouping these memories is another list of sub-lists. The FADL translator <b>30</b> ensures that each input memory is referred to by only one memory group.</p>
<p id="p-0220" num="0219">The &#x201c;updateGroups&#x201d; constraint <b>102</b> is another list of sub-lists in which each list represents a state in a sequence of states. The elements of each sub-list specify the XORs that are to be updated concurrently. The FADL translator <b>30</b> ensures that each constraint is referred to only once in a particular state, and that no physical XOR updates two constraints at the same time.</p>
<p id="p-0221" num="0220">The &#x201c;directory&#x201d; assignment <b>104</b> specifies the directory into which VERILOG files generated by the translator <b>30</b> are to be placed.</p>
<p id="p-0222" num="0221">The next step is to assign existing VERILOG files to certain nodes. This step arises because the FADL translator describes connectivity between nodes, but not what is in the actual nodes. Although any node can be implemented by specifying appropriate hardware, the most useful ones for belief propagation networks are those listed in the &#x201c;customModules&#x201d; assignment <b>106</b>. These are &#x201c;Xor2x1,&#x201d; which performs an XOR operation, &#x201c;MemCell,&#x201d; which stores a value associated with an edge of the factor graph, &#x201c;Cntrl,&#x201d; which schedules memory enable instructions, and &#x201c;FactorGraphTestBench,&#x201d; which reads data from files, loads the &#x201c;FactorGraph&#x201d; module, and saves results to other files. The FADL translator <b>30</b> provides default versions of these modules for convenience in specifying the contents of each node. However, new ones can be provided on an as-needed basis.</p>
<p id="p-0223" num="0222">In many instances, the HDL representation <b>24</b> is used as a basis for simulation of the factor graph in operation. The FADL translator <b>30</b> automatically generates a run script for running a simulation. The &#x201c;additionalModules&#x201d; instruction <b>108</b> provides a way to enter strings to be used in generating this run script. The strings listed in the example of <figref idref="DRAWINGS">FIG. 14</figref> are referred to by a default &#x201c;cntrl&#x201d; module specified in the &#x201c;customModules&#x201d; assignment <b>106</b>.</p>
<p id="p-0224" num="0223">The next few instructions specify parameters to be used during the simulation. The value of &#x201c;numIterations&#x201d; <b>110</b> controls how long the simulation will last, and the value of &#x201c;debug&#x201d; <b>112</b> controls whether or not intermediate data generated during the simulation is saved.</p>
<p id="p-0225" num="0224">The last instruction generates VERILOG code using values that have been specified earlier. The resulting VERILOG code is saved in the specified directory and available for use by a hardware simulator <b>23</b> or for transmission to a floor planner <b>22</b>.</p>
<p id="p-0226" num="0225"><figref idref="DRAWINGS">FIG. 16</figref> shows a more complex example in which a FADL representation <b>20</b> provided to the FADL translator <b>30</b> represents the factor graph shown in <figref idref="DRAWINGS">FIG. 17</figref>. The resulting FADL representation <b>20</b> is similar to that shown in <figref idref="DRAWINGS">FIG. 14</figref>, with the exception of a larger number of iterations, and in the specification of the adjacency matrix, &#x201c;physXors&#x201d;, &#x201c;bitMemGroups&#x201d; and &#x201c;updateGroups.&#x201d;</p>
<p id="p-0227" num="0226">The FADL translator <b>30</b> is implemented in an object-oriented programming environment, shown in <figref idref="DRAWINGS">FIG. 11</figref>, by defining classes for each of the factor graph modules (e.g. switches, XORs, XOR groups, memory groups, and memory cells). These classes are collected in a factor graph builder module <b>84</b>. A FADL module <b>86</b> includes functions for instantiating objects defined by the various classes available in the factor graph builder module <b>84</b>. An HDL module <b>88</b> includes classes that are specific to a particular HDL. By swapping different HDL modules in and out, one can use the same FADL module <b>86</b> and factor graph builder module <b>84</b> to generate hardware representations in different hardware descriptor languages, including VERILOG, SPICE, and Java, among others. In the particular embodiment in which the HDL module <b>88</b> is a VERILOG module, the classes and their relationships are as shown in <figref idref="DRAWINGS">FIG. 19</figref>.</p>
<p id="p-0228" num="0227"><figref idref="DRAWINGS">FIG. 20</figref> shows the classes and their relationships in the factor graph builder module <b>84</b>. Each class that has a &#x201c;module&#x201d; suffix inherits properties from a corresponding class in the HDL module <b>88</b>. The class &#x201c;FactorGraphBuilder&#x201d; shown in <figref idref="DRAWINGS">FIG. 20</figref> is the class that creates the factor graph module.</p>
<p id="h-0021" num="0000">4 Implementations</p>
<p id="p-0229" num="0228">It should be understood that in some examples, modules, for instance the modules shown in <figref idref="DRAWINGS">FIG. 3</figref>, are implemented in software, with instructions stored on tangible computer-readable media being used to cause one or more data processing systems to implement and operate components as described above. In some examples, modules may be implemented, at least in part, using hardware, which may accelerate their execution speed. Users may provide their input through a variety of interfaces, including graphical user interfaces (GUIs), which provide output, such as representations of the factor graphs or their specifications or outputs of execution of the developed factor graphs.</p>
<p id="p-0230" num="0229">As introduced above, different embodiments of development systems can include subsets of the features and capabilities described above. In particular, it should be noted that the DMPL and FADL components have utility one their own, as well as in combination.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-math idrefs="MATH-US-00001" nb-file="US08627246-20140107-M00001.NB">
<img id="EMI-M00001" he="9.14mm" wi="76.20mm" file="US08627246-20140107-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00002" nb-file="US08627246-20140107-M00002.NB">
<img id="EMI-M00002" he="22.27mm" wi="76.20mm" file="US08627246-20140107-M00002.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00003" nb-file="US08627246-20140107-M00003.NB">
<img id="EMI-M00003" he="10.58mm" wi="76.20mm" file="US08627246-20140107-M00003.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00004 MATH-US-00004-2 MATH-US-00004-3 MATH-US-00004-4" nb-file="US08627246-20140107-M00004.NB">
<img id="EMI-M00004" he="41.99mm" wi="76.20mm" file="US08627246-20140107-M00004.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00005" nb-file="US08627246-20140107-M00005.NB">
<img id="EMI-M00005" he="7.45mm" wi="76.20mm" file="US08627246-20140107-M00005.TIF" alt="embedded image " img-content="math" img-format="tif"/>
</us-math>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A computer-implemented method for generating a hardware description of a belief propagation network, said method comprising:
<claim-text>receiving an initial representation of a belief propagation network representing a graphical model for performing inference having a factor graph that includes a first class of nodes representing variables and a second class of nodes representing constraints between variables, the nodes being connected by edges;</claim-text>
<claim-text>receiving a specification indicating that that a hardware element is to be used to implement at least two nodes of said factor graph;</claim-text>
<claim-text>generating empty nodes for receiving information representative of hardware modules each having one or more hardware elements for physically implementing said nodes; and</claim-text>
<claim-text>on the basis of said initial representation and said specification, generating, by using a computer, a hardware representation of an electronic circuit for implementing said factor graph.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein generating a hardware representation comprises generating a hardware descriptor language representation of said specification.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein generating a hardware representation comprises generating a VERILOG representation of said specification.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising receiving a specification of hardware to be placed in said nodes.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein receiving said specification comprises receiving a specification of function nodes to be implemented by a particular XOR-processor.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein receiving said specification comprises receiving a specification of variable nodes to be implemented by a particular equals-processor.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising specifying additional hardware elements to enable said hardware element to realize at least two nodes of said factor graph.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein specifying additional hardware elements comprises specifying at least one switch.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein specifying additional hardware elements comprises specifying at least one memory element.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising providing said hardware representation to a hardware simulator for simulation of said belief propagation network.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising providing said hardware representation to a floor planner for generating a floor plan of an integrated circuit for implementing said belief propagation network.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. A non-transitory machine readable medium having instructions encoded thereon, said instructions, when executed by a data processing system, cause the system to
<claim-text>receive an initial representation of a belief propagation network representing a graphical model for performing inference having a factor graph that includes a first class of nodes representing variables and a second class of nodes representing constraints between variables, the nodes being connected by edges;</claim-text>
<claim-text>receive a specification indicating that that a hardware element is to be used to implement at least two nodes of said factor graph;</claim-text>
<claim-text>generate empty nodes for receiving information representative of hardware modules each having one or more hardware elements for physically implementing said nodes; and</claim-text>
<claim-text>on the basis of said initial representation and said specification, generate a hardware representation of an electronic circuit for implementing said factor graph.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The non-transitory machine readable medium of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein said instructions, when executed by the data processing system, further cause the system to generate a hardware representation comprise instructions for causing said data processing system to generate a hardware descriptor language representation of said specification.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The non-transitory machine readable medium of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said instructions, when executed by the data processing system, cause the system to generate a VERILOG representation of said specification.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The non-transitory machine readable medium of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein said instructions, when executed by the data processing system, further cause the system to receive a specification of hardware to be placed in said nodes.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The non-transitory machine readable medium of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein said instructions, when executed by the data processing system, cause the system to receive said specification comprise instructions for receiving a specification of function nodes to be implemented by a particular XOR-processor.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The non-transitory machine readable medium of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein said instructions, when executed by the data processing system, cause the system to receive a specification of variable nodes to be implemented by a particular equals-processor.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The non-transitory machine readable medium of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein said instructions, when executed by the data processing system, cause the system to specify additional hardware elements to enable said hardware element to realize at least two nodes of said factor graph.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The non-transitory machine readable medium of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein said instructions, when executed by the data processing system, cause the system to specify at least one switch.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The non-transitory machine readable medium of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein said instructions, when executed by the data processing system, cause the system to specify at least one memory element.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The non-transitory machine readable medium of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein said instructions, when executed by the data processing system, cause the system to provide said hardware representation to a hardware simulator for simulation of said belief propagation network.</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. The non-transitory machine readable medium of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein said instructions, when executed by the data processing system, cause the system to provide said hardware representation to a floor planner for generating a floor plan of an integrated circuit for implementing said belief propagation network. </claim-text>
</claim>
</claims>
</us-patent-grant>
