<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08626745-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08626745</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13110981</doc-number>
<date>20110519</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<us-term-of-grant>
<us-term-extension>5</us-term-extension>
<disclaimer>
<text>This patent is subject to a terminal disclaimer.</text>
</disclaimer>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>7</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>30</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>707715</main-classification>
<further-classification>707721</further-classification>
<further-classification>707745</further-classification>
</classification-national>
<invention-title id="d2e55">Multi-query optimization</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5560007</doc-number>
<kind>A</kind>
<name>Thai</name>
<date>19960900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>  1  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5899988</doc-number>
<kind>A</kind>
<name>Depledge et al.</name>
<date>19990500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6421662</doc-number>
<kind>B1</kind>
<name>Karten</name>
<date>20020700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>  1  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6466931</doc-number>
<kind>B1</kind>
<name>Attaluri et al.</name>
<date>20021000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>  1  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>6564212</doc-number>
<kind>B2</kind>
<name>Koskas</name>
<date>20030500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>7127467</doc-number>
<kind>B2</kind>
<name>Yalamanchi et al.</name>
<date>20061000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>7752197</doc-number>
<kind>B2</kind>
<name>Dettinger et al.</name>
<date>20100700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2004/0054666</doc-number>
<kind>A1</kind>
<name>Lapir et al.</name>
<date>20040300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  3</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2004/0068489</doc-number>
<kind>A1</kind>
<name>Dettinger et al.</name>
<date>20040400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  3</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2004/0193656</doc-number>
<kind>A1</kind>
<name>Pizzo et al.</name>
<date>20040900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707201</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2005/0154710</doc-number>
<kind>A1</kind>
<name>Ruhlow et al.</name>
<date>20050700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  3</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2005/0216518</doc-number>
<kind>A1</kind>
<name>Hu et al.</name>
<date>20050900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2009/0171890</doc-number>
<kind>A1</kind>
<name>Johnson et al.</name>
<date>20090700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  2</main-classification></classification-national>
</us-citation>
<us-citation>
<nplcit num="00014">
<othercit>Gupta et al. &#x201c;Performance Comparison of Property Map and Bitmap Indexing&#x201d; Proceedings of the 5th ACM international workshop on Data Warehousing and OLAP. [online], 2002 [retrieved on Sep. 13, 2012]. Retrieved from the Internet:&#x3c; URL: http://delivery.acm.org/10.1145/590000/583900/p65-gupta.pdf&#x3e;. pp. 65-71.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00015">
<othercit>Grommon-Litton, J. &#x201c;Heuristic Design Algorithms and Evaluation Methods for Property Maps,&#x201d; Masters Thesis, ECECS Dept., University of Cincinnati, Cincinnati, OH, Nov. 2000 [retrieved on Sep. 19, 2012]. Retrieved from the Internet:&#x3c; URL: http://etd.ohiolink.edu/send-pdf.cgi/LITTON%20JENNIFER%20GROMMON.pdf?ucin981488752&#x3e;. 74 pages.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00016">
<othercit>Gupta, A. &#x201c;Performance Comparison of Property Map Indexing and Bitmap Indexing for Data Warehousing,&#x201d; MS Thesis, ECECS Dept., University of Cincinnati, Cincinnati, OH, 2002 [retrieved on Sep. 19, 2012]. Retrieved from the Internet:&#x3c; URL: http://etd.ohiolink.edu/send-pdf.cgi/GUPTA%020ASHIMA.pdf?ucin1037976189&#x3e;. 122 pages.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
</us-references-cited>
<number-of-claims>20</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>707689</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707693</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707711</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707714</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707715</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707721</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707745</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707801</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>3</number-of-drawing-sheets>
<number-of-figures>3</number-of-figures>
</figures>
<us-related-documents>
<continuation>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>11280827</doc-number>
<date>20051115</date>
</document-id>
<parent-grant-document>
<document-id>
<country>US</country>
<doc-number>7966315</doc-number>
</document-id>
</parent-grant-document>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>13110981</doc-number>
</document-id>
</child-doc>
</relation>
</continuation>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20110225205</doc-number>
<kind>A1</kind>
<date>20110915</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Okamoto</last-name>
<first-name>Russell</first-name>
<address>
<city>Beaverton</city>
<state>OR</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Passmore</last-name>
<first-name>Greg</first-name>
<address>
<city>Beaverton</city>
<state>OR</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Okamoto</last-name>
<first-name>Russell</first-name>
<address>
<city>Beaverton</city>
<state>OR</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Passmore</last-name>
<first-name>Greg</first-name>
<address>
<city>Beaverton</city>
<state>OR</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Fish &#x26; Richardson P.C.</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>GoPivotal, Inc.</orgname>
<role>02</role>
<address>
<city>San Mateo</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Richardson</last-name>
<first-name>James E</first-name>
<department>2167</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A database query optimization method is provided for database queries that include predicates, the queries being directed to at least one database table having data in rows and columns. The method includes associating a lineage bit set with each row of the database table, the lineage bit set providing a binary predicate state indication whether each predicate is met or are not met by data in the row. A dependency bit set is established to provide a binary indication of the predicates that are included in each query. Queries are applied against the database table by a logical operation between the lineage bit set and the dependency bit set. A database query optimization data structure includes a lineage bit set associated with each row in the database table. The lineage bit set provides a binary predicate state indication whether each predicate is met or are not met by data in the row. The data structure further includes a dependency bit set that provides a binary indication of the predicates included in each query.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="192.87mm" wi="183.90mm" file="US08626745-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="217.17mm" wi="183.56mm" file="US08626745-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="139.70mm" wi="166.03mm" file="US08626745-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="219.79mm" wi="176.28mm" file="US08626745-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">This application is a continuation of U.S. patent application Ser. No. 11/280,827 filed Nov. 15, 2005 and entitled &#x201c;Multi-Query Optimization,&#x201d; the contents of which are hereby incorporated by reference herein.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">FIELD OF INVENTION</heading>
<p id="p-0003" num="0002">The present invention relates to optimization of database queries having multiple predicates and, in particular, to a multi-query optimization that utilizes a binary abstraction of predicates to improve query execution.</p>
<heading id="h-0003" level="1">BACKGROUND AND SUMMARY OF THE INVENTION</heading>
<p id="p-0004" num="0003">Database systems store, retrieve, and process information. A user retrieves information from the database by providing a query that is written in a query language such as SQL. The query specifies the information to be retrieved and the manner in which it is to be manipulated or evaluated. To process the query, the database system typically converts the query into a relational expression that describes algebraically the result specified by the query. The relational expression is then used to produce an execution plan, which describes particular steps to be taken by a computer in order to produce the sought result.</p>
<p id="p-0005" num="0004">Formerly, the data in a database was treated as being static with different queries being applied to retrieve portions of the data. More recently, a stream processing or continuous querying model treats the queries as being generally static with the data of the database being dynamically added or updated. The stream processing or continuous querying model accommodates complex queries that are typically formed from common query components or sub-expressions. The common sub-expressions of these complex queries may be used in many different queries.</p>
<p id="p-0006" num="0005">In the stream processing or continuous querying model, queries are executed instantaneously as data in the database changes or is added. In this context, the importance of utilizing common sub-expressions for query evaluation is paramount, since the processing work done to evaluate a single sub-expression can be shared by multiple queries. Optimizing sets of queries that share common sub-expressions is referred to as multi-query optimization. Query optimization takes a parsed representation of a SQL query as input and is responsible for generating an efficient execution plan for the given SQL query.</p>
<p id="p-0007" num="0006">A query in the Structured Query Language (SQL) format includes a selection of rows from one or more columns in a specified table according to a specified condition or predicate. For example, a database table &#x201c;R&#x201d; may include a column A, with alphabetic values x, y, x, n, etc. in successive rows, and a column B with numeric values 55, 30, 19, 60, etc., in successive rows, respectively, so that values x and 55 are in a common row, values y and 30 are in a common row, and so forth. Table R could include many other columns as well, which could be designated C, D, E, etc.</p>
<p id="p-0008" num="0007">An SQL query (e.g., referred to as Q(alpha)) may specify, for example, a selection of rows from column A and column B, in Table R, according to the predicate that the numeric values in column B are greater than 50. Another SQL query (e.g., referred to as Q(beta)) may specify, for example, a selection of rows from column A, column B, and column C in Table R, according to the predicate that the numeric values in column B are greater than 75. Queries Q(alpha) and Q(beta) could be just two of many (e.g., hundreds or thousands) of query sub-expressions that are applicable to the database.</p>
<p id="p-0009" num="0008">In conventional multi-query optimization, query sub-expressions with common predicates, such as queries Q(alpha) and Q(beta), are grouped together to form a group filter or predicate index. Queries Q(alpha) and Q(beta) have common predicates in that both relates to the same variable (i.e., values in column B) and both employ the same operand (i.e., the &#x201c;greater than&#x201d; comparison), but different constants (i.e., 50 and 75). The grouping of such queries forms a tree structure for the &#x201c;B&#x3e;&#x201d; predicates in which the nodes in the tree are the different constants of the different predicates.</p>
<p id="p-0010" num="0009">In this example, the constant value 50 of Q(alpha) forms a first left node of the tree structure, and the constant value 75 of Q(beta) forms a first right node of the tree structure. Successive queries with common predicates are added to the tree structure such that constants with a value greater than a node branch to the right from the node and constants with a value less than a node branch to the left from the node. Once the predicate index is formed, new data can be readily compared against all the common predicate queries according to where the new data fits in the tree structure.</p>
<p id="p-0011" num="0010">A limitation of such conventional multi-query optimization; however, is that changed data must be compared against all the predicate indices for the table, even if the data changes affect only one column. As a consequence, data changes result in large amounts of query evaluation that require extensive computational resources even when some of the query evaluations are unrelated to the changed data.</p>
<p id="p-0012" num="0011">Accordingly, the present invention provides multi-query optimization that remembers the outcomes of previous predicate query evaluations to efficiently handle the case where data is changed. In this way, only changes to affected data columns need to be reconciled when continuous query evaluation is performed. In one implementation, the invention includes a database query optimization method for database queries that include predicates, the queries being directed to at least one database table having data in rows and columns. The method includes associating a lineage bit set with each row of the database table, the lineage bit set providing a binary predicate state indication whether each predicate is met or are not met by data in the row. A dependency bit set is established to provide a binary indication of the predicates that are included in each query. Queries are applied against the database table by a logical operation between the lineage bit set and the dependency bit set.</p>
<p id="p-0013" num="0012">Another aspect of the invention includes a database query optimization data structure, which includes a lineage bit set associated with each row in the database table. The lineage bit set provides a binary predicate state indication whether each predicate is met or are not met by data in the row. The data structure further includes a dependency bit set that provides a binary indication of the predicates included in each query.</p>
<p id="p-0014" num="0013">A benefit of the lineage bit set is that it preserves the state of previous predicate evaluations. The history of what query predicates a data row currently satisfies is maintained by the bits of the lineage bit set. This is particularly advantageous for handling data updates because query evaluation can be limited to only a subset of involved predicates. When a data row changes, only those predicates associated with modified data columns need to be evaluated. The shared predicate registry can be used to map modified data columns to such involved predicates, so only the identified predicates need to be evaluated for the changed data row. The state of the other, non-involved predicates identified by a query's dependency bit set are preserved in the row's lineage bit set and can be efficiently combined with the involved predicates.</p>
<p id="p-0015" num="0014">Additional objects and advantages of the present invention will be apparent from the detailed description of the preferred embodiment thereof, which proceeds with reference to the accompanying drawings.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 1</figref> is a diagram of a simplified diagram of a database.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 2</figref> is a flow diagram of a multi-query optimization method according to the present invention.</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 3</figref> is a flow diagram of a multi-query optimization method <b>80</b> that is applied when data in a database table is updated.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 1</figref> is a simplified diagram of a database <b>10</b> with a table <b>12</b> having columns <b>14</b> (designated A, B, C, D, etc.) and rows <b>16</b>. Table <b>12</b> has a designation (e.g., Table R). In this example, column A includes successive alphabetic values X, Y, Z, N, M, and column B includes successive numeric values 25, 10, 2, 60, 70. Columns C, D, etc. may include other numeric or alphabetic values, as well. For example, column C may contain successive numeric values 90, 17, 35, etc., and column D may contain successive alphabetic values (e.g., names), such as Tom, Steve, John, etc. Database <b>10</b> would typically include plural tables, but only one is shown for purposes of illustration.</p>
<p id="p-0020" num="0019">Database table <b>12</b> includes an additional column <b>18</b> that contains a lineage bit set <b>20</b> for each row in the table <b>12</b>, according to the present invention. As described below in greater detail, the lineage bit set <b>20</b> for each row <b>16</b> is a data structure that specifies the query predicates or sub-expressions that are met or satisfied by the data in that row <b>16</b>. The query predicates or sub-expressions arise from queries that are associated with database <b>10</b>. Column <b>18</b> may be referred to herein as lineage bit set column <b>18</b>.</p>
<p id="p-0021" num="0020">All predicates for queries applied to a table are numbered in sequence and are designated by corresponding bits in lineage bit set <b>20</b>. For N-number of queries employing M-number of unique predicates, lineage bit set <b>20</b> will include M-number of binary bits, with each bit indicating whether the corresponding predicate is met by data in that row. In one implementation, a value 1 indicates that the corresponding predicate is true or met for the row, and a value 0 indicates that the corresponding predicate is not true or met for the row.</p>
<p id="p-0022" num="0021">For example, a first query Q1 may specify, for example, a selection of rows from column A and column B, in Table R, according to the predicate that the numeric values in column B are greater than 5 and the predicate that the numeric values in column C are greater than 80 and the predicate that the alphabetic values in column D equal &#x201c;Tom.&#x201d; Query Q1 may be tabulated as follows: [0021] Select: Col. A, Col. B [0022] From: Table R [0023] Where: B&#x3e;5 and [0024] C&#x3e;80, and [0025] D=Tom</p>
<p id="p-0023" num="0022">In this illustration, the predicates B&#x3e;5, C&#x3e;80, and D=Tom may be designated as predicates P0, P1, and P2, respectively.</p>
<p id="p-0024" num="0023">As another example, a second query Q2 may specify, for example, a selection of rows from column A, column B, and column C in Table R, according to the predicate that the numeric values in column B are greater than 5 and the predicate that the alphabetic values in column D equal &#x201c;Steve.&#x201d; Query Q2 may be tabulated as follows: [0028] Select: Col. A, Col. B, Col. C [0029] From: Table R [0030] Where: B&#x3e;5 and [0031] D=Steve</p>
<p id="p-0025" num="0024">In this illustration, the predicate B&#x3e;5 has already been designated as predicate P0. The predicate D=Steve is designated as predicate P3 as the next successive predicate to be designated from the queries applied to Table R.</p>
<p id="p-0026" num="0025">With reference to queries Q1 and Q2, for example, the lineage bit sets <b>20</b> for each row in Table R include 4 bits that correspond to the 4 predicates P0-P3 associated with the queries. In the example of <figref idref="DRAWINGS">FIG. 1</figref>, lineage bit set <b>20</b> for the first row of table R is 1110, which indicates that predicates P0-P2 are met by the data of the first row and that the predicate P3 is not met. Likewise, lineage bit set <b>20</b> for the second row of table R is 1001, which indicates that predicates P0 and P3 are met by the data of the first row and that the predicates P1 and P2 are not met. It will be appreciated that lineage bit sets <b>20</b> will typically have many more than 4 bits because a typical database <b>10</b> will typically have up to hundreds or thousands of associated queries.</p>
<p id="p-0027" num="0026">Database <b>10</b> includes a shared predicate registry <b>30</b> having a predicate registry data structure <b>36</b> that includes a predicate definition <b>32</b> and a corresponding predicate index <b>34</b>. <figref idref="DRAWINGS">FIG. 1</figref> illustrates the exemplary predicates B&#x3e;5, C&#x3e;80, D=Tom, D=Steve as predicate definitions <b>32</b> in association with their corresponding indices 0-3, respectively. Additional predicates from other queries associated with Table R are added to shared predicate registry <b>30</b> with successively increasing indices. Each lineage bit set <b>20</b> in lineage bit set column <b>18</b> includes a bit for each predicate definition <b>32</b> in registry <b>30</b>. It will be appreciated, therefore, that each lineage bit set will have a number of bits corresponding to the highest value in predicate index <b>34</b>, plus 1, to account for index <b>34</b> beginning with the value zero.</p>
<p id="p-0028" num="0027">Database <b>10</b> also includes a query registry <b>40</b> having a query registry data structure <b>46</b> that includes a query definition <b>42</b> and a corresponding query index <b>44</b>. Each query definition <b>42</b> includes a set of dependency bit sets <b>48</b> with bits that correspond to the predicates that are applied by the query. There is a dependency bit set <b>48</b> for each query and each table to which the query is applied. Each dependency bit set <b>48</b> is associated with a database table and includes the same number of bits as are in the lineage bit set <b>20</b> stored within each row of the database table. The difference is that the bits in the dependency bit set <b>48</b> correspond to predicates that that are used in the query, while the lineage bit set <b>20</b> corresponds to the data in a row that meet the predicates.</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 1</figref> illustrates that query Q1, which is identified by index 1, has the dependency bit set <b>1110</b> indicating that predicates P0-P2 are used by query Q1, and that predicate P3 is not. Query Q2, which is identified by index 2, has the dependency bit set <b>1001</b> indicating that predicates P0 and P3 are used by query Q2, and that predicates P1 and P2 are not.</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 2</figref> is a flow diagram of a multi-query optimization method <b>50</b> that forms and utilizes the lineage bit sets <b>18</b> to improve optimization of multiple queries for a database. Multi-query optimization method <b>50</b> is computer-implemented in accordance with corresponding software instructions that are stored on a computer-readable medium.</p>
<p id="p-0031" num="0030">Step <b>52</b> indicates that a database has associated with it queries with predicates specified for potentially a plurality of database tables.</p>
<p id="p-0032" num="0031">Step <b>54</b> indicates that a shared predicate registry <b>30</b> and a query registry <b>40</b> are built from the predicates of the queries associated with the database tables. Query registry <b>40</b> includes query definitions <b>42</b> with a dependency bit sets <b>46</b> that have bits corresponding to the predicates that are applied by the query.</p>
<p id="p-0033" num="0032">Step <b>56</b> indicates a lineage bit set <b>20</b> is associated with each row of a database table indicating which of the predicates in the shared predicate registry are met or satisfied by the data in the row.</p>
<p id="p-0034" num="0033">Step <b>58</b> a selected one of the queries is applied to the database table to determine which rows in the database table meet or satisfy the selected query. With each lineage bit set <b>20</b> represented as LIN and the dependency bit set <b>48</b> for the selected query represented as DEP, the selected query may be applied to each row by the logical AND operation:</p>
<p id="p-0035" num="0034">LIN AND DEP</p>
<p id="p-0036" num="0035">The predicates of the selected query are met or satisfied whenever:</p>
<p id="p-0037" num="0036">LIN AND DEP=DEP.</p>
<p id="p-0038" num="0037">The predicates of the selected query are not met or satisfied, and the query conditions are not met, whenever the AND operation does not equal DEP.</p>
<p id="p-0039" num="0038">Step <b>60</b> indicates that a query result is returned according to whether or not the AND operation equals DEP.</p>
<p id="p-0040" num="0039">Computer execution of an AND operation between two bit sets is very fast and efficient. The present invention provides, therefore, a very fast and efficient mechanism for executing arbitrary numbers of queries against a database of arbitrary size. In particular, the lineage bit set <b>20</b> and the dependency bit set <b>48</b> provide binary abstraction of predicates that allow large numbers of queries to be applied to arbitrary amounts of data with an efficiency that is greatly improved over conventional multi-query optimization techniques.</p>
<p id="p-0041" num="0040">A benefit of the lineage bit set is that it preserves the state of previous predicate evaluations. In other words, the history of what query predicates a data row currently satisfies is maintained by the bits of the lineage bit set. This is particularly advantageous for handling data updates because query evaluation can be limited to only a subset of involved predicates. When a data row changes, only those predicates associated with modified data columns need to be evaluated. The shared predicate registry can be used to map modified data columns to such involved predicates, so only the identified predicates need to be evaluated for the changed data row. The state of the other, non-involved predicates identified by a query's dependency bit set are preserved in the row's lineage bit set and can be efficiently combined with the involved predicates.</p>
<p id="p-0042" num="0041">The lineage bit set also has a corresponding integer (i.e., the last predicate analyzed integer) that indicates the highest ordered predicate that was analyzed for a given row. Since new predicates may be dynamically added in real-time, each row must keep track of the newest predicate against which the row has been analyzed. New predicates are assigned a new ID when they are registered in the shared predicate registry <b>30</b>. When a tuple is analyzed, its last predicate analyzed integer is compared to the highest ordered predicate in the shared predicate registry <b>30</b>. If there is any difference, the new predicates are also considered failed for the new tuple, and must be analyzed. After this analysis, the tuple's last predicate analyzed integer is set to the new highest ordered predicate ID.</p>
<p id="p-0043" num="0042">If the last predicate analyzed integer were not tracked, then all rows would have to be completely re-analyzed each time any predicate was added, rather than just analyzing the new and change-dependent predicates. This technique, therefore, enables predicates to be flexibly added at runtime without incurring processing spikes and query evaluation delays.</p>
<p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. 3</figref> is a flow diagram of a multi-query optimization method <b>80</b> as applied when data in a database table is updated (i.e., changed or added). The improved execution of queries provided by the present invention also provides improved execution of queries when data in a table is changed or added (collectively, updated). The following description is directed to data that is changed in an existing database entry.</p>
<p id="p-0045" num="0044">Step <b>82</b> indicates that each row in the database table has an associated initial lineage bit set <b>18</b> (LIN). For example, the initial lineage bit set may be <b>1110</b>, such as lineage bit set <b>20</b> for the first row of table R in <figref idref="DRAWINGS">FIG. 1</figref>. Each predicate represented by a bit in the lineage bit set <b>18</b> (LIN) corresponds to data in one column of the row.</p>
<p id="p-0046" num="0045">Step <b>84</b> indicates data in one or more columns of a row in the database table is changed.</p>
<p id="p-0047" num="0046">Step <b>86</b> indicates that the initial lineage bit set <b>18</b> (LIN) for the row is re-designated as the initial lineage bit set (initLIN).</p>
<p id="p-0048" num="0047">Step <b>88</b> indicates that each bit in the initial lineage bit set (initLIN) corresponding to a column with changed data is set to indicate that the predicate is not met or satisfied (e.g. set to 0). For example, with a data change that affects only column B, the initial lineage bit set (initLIN) for the first row of table R in <figref idref="DRAWINGS">FIG. 1</figref> would be set from <b>1110</b> to <b>0110</b>, wherein the first bit is the only bit of a predicate that corresponds to column B.</p>
<p id="p-0049" num="0048">Step <b>90</b> indicates that the predicates for the column or columns with changed data are analyzed against the data in those columns to determine whether those predicates are met or satisfied.</p>
<p id="p-0050" num="0049">Step <b>92</b> indicates that a working lineage bit set (workLIN) is established from the initial lineage bit set (initLIN), with updates reflecting the analysis of the predicates for the column or columns with changed data against the data in those columns. For example, analysis of the predicate corresponding to the first bit against the new data in column B will result in the first bit remaining 0 if the predicate is not met, or being changed to 1 if the predicate is met.</p>
<p id="p-0051" num="0050">Step <b>94</b> indicates that queries with predicates for the column or columns with changed data are identified and the dependency bit set DEP for each such query DEP is applied to the working lineage bit set (workLIN) by the logical AND operation:</p>
<p id="p-0052" num="0051">workLIN AND DEP</p>
<p id="p-0053" num="0052">The predicates of each query are met or satisfied whenever:</p>
<p id="p-0054" num="0053">workLIN AND DEP=DEP.</p>
<p id="p-0055" num="0054">Step <b>96</b> indicates that the dependency bit set DEP for each query DEP is applied to the initial lineage bit set (initLIN) by the logical AND operation: [0063] initLIN AND DEP.</p>
<p id="p-0056" num="0055">Having access to the pre-analysis initial lineage bitset, as well as the manipulated working bitset, allows for some optimizations with regard to processing the outcome of the analysis. Given the two bitsets and the dependency bitset for a given query, it is possible to tell if the changes to the row result in a new match, an update to an existing match, a no longer match, or a still doesn't match condition. This insight allows certain changes to be ignored, for example, if a row is changed such that it still doesn't match a given query, it can be ignored completely. This allows for a reduction in computation as well as the opportunity to provide enriched predicate state transition information to subsequent processing logic.</p>
<p id="p-0057" num="0056">Having described and illustrated the principles of our invention with reference to an illustrated embodiment, it will be recognized that the illustrated embodiment can be modified in arrangement and detail without departing from such principles. It should be understood that the programs, processes, or methods described herein are not related or limited to any particular type of computer apparatus, unless indicated otherwise. Various types of general purpose or specialized computer apparatus may be used with or perform operations in accordance with the teachings described herein. Elements of the illustrated embodiment shown in software may be implemented in hardware and vice versa.</p>
<p id="p-0058" num="0057">In view of the many possible embodiments to which the principles of our invention may be applied, it should be recognized that the detailed embodiments are illustrative only and should not be taken as limiting the scope of our invention. Rather, we claim as our invention all such embodiments as may come within the scope and spirit of the following claims and equivalents thereto.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>I claim:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for updating a database table having multiple rows, the method comprising:
<claim-text>maintaining predicates of received database queries in a predicate registry, wherein each predicate is associated with a different index value in the predicate registry, the predicates having an order in which a more recent predicate is ordered higher than a less recent predicate;</claim-text>
<claim-text>for each row of the database table, maintaining a lineage bit set and a last-predicate-analyzed indicator, wherein:
<claim-text>the lineage bit set includes multiple bit positions, each bit position in the lineage bit set corresponding to a query predicate,</claim-text>
<claim-text>a bit value stored at each bit position indicates whether the corresponding predicate is satisfied by the row, and</claim-text>
<claim-text>the last-predicate-analyzed indicator identifies a most recent predicate used in a most recent evaluation of the lineage bit set of the row; and</claim-text>
</claim-text>
<claim-text>receiving an update to an entry in the database table, wherein the entry corresponds to a first row of the database table and, in response to receiving the update:
<claim-text>updating one or more bit positions in the lineage bit set of the first row that have previously been evaluated and require re-evaluation as a result of the received update;</claim-text>
<claim-text>determining that the last-predicate-analyzed indicator of the first row identifies a predicate that is different from a currently most recent predicate in the predicate registry; and then</claim-text>
<claim-text>evaluating one or more new predicates that entered the predicate registry to update one or more new bit positions in the lineage bit set of the first row that correspond to the one or more new predicates, wherein each new predicate is a predicate that is ordered higher than the predicate identified by the last-predicate-analyzed indicator of the first row.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising saving a state of the lineage bit set of the first row of the database table corresponding to the update.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising comparing the saved state of the lineage bit set of the first row of the database table with a state of the lineage bit set after the updating operations to determine whether any past query results need to be updated.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein each last-predicate-analyzed indicator is an integer.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein evaluating the one or more new predicates in the predicate registry comprises:
<claim-text>updating the lineage bit set of the first row to reflect an updated evaluation of all the predicates in the predicate registry.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, comprising:
<claim-text>for a received database query, maintaining a dependency bit set having multiple bit positions, wherein each bit position in the dependency bit set corresponds to a query predicate, and wherein a bit value for each bit position in the dependency bit set indicates whether the corresponding predicate is part of in the received query; and</claim-text>
<claim-text>determining whether a row satisfies the received database query by comparing the dependency bit set with the lineage bit set.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising, after evaluating the one or more new predicates, updating the last-predicate-analyzed indicator of the first row to identify a new most recent predicate.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. A non-transitory computer-readable storage medium including instructions for updating a database table having multiple rows, the instructions, when executed on a processor, operable to cause the processor to perform operations comprising:
<claim-text>maintaining predicates of received database queries in a predicate registry, wherein each predicate is associated with a different index value in the predicate registry, the predicates having an order in which a more recent predicate is ordered higher than a less recent predicate;</claim-text>
<claim-text>for each row of the database table, maintaining a lineage bit set and a last-predicate-analyzed indicator, wherein:
<claim-text>the lineage bit set includes multiple bit positions, each bit position in the lineage bit set corresponding to a query predicate,</claim-text>
<claim-text>a bit value stored at each bit position indicates whether the corresponding predicate is satisfied by a the row, and</claim-text>
<claim-text>the last-predicate-analyzed indicator identifies a most recent predicate used in a most recent evaluation of the lineage bit set of the row; and</claim-text>
</claim-text>
<claim-text>receiving an update to an entry in the database table, wherein the entry corresponds to a first row of the database table and, in response to receiving the update:
<claim-text>updating one or more bit positions in the lineage bit set of the first row that have previously been evaluated and require re-evaluation as a result of the received update;</claim-text>
<claim-text>determining that the last-predicate-analyzed indicator of the first row identifies a predicate that is different from a currently most recent predicate in the predicate registry; and then</claim-text>
<claim-text>evaluating one or more new predicates that entered the predicate registry to update one or more new bit positions in the lineage bit set of the first row that correspond to the one or more new predicates, wherein each new predicate is a predicate that is ordered higher than the predicate identified by the last-predicate-analyzed indicator of the first row.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The non-transitory computer-readable storage medium of <claim-ref idref="CLM-00008">claim 8</claim-ref>, the operations including saving a state of the lineage bit set of the first row of the database table corresponding to the update.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The non-transitory computer-readable storage medium of <claim-ref idref="CLM-00009">claim 9</claim-ref>, the operations including comparing the saved state of the lineage bit set of the first row of the database table with a state of the lineage bit set after the updating operations to determine whether any past query results need to be updated.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The non-transitory computer-readable storage medium of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein each last-predicate-analyzed indicator is an integer.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The non-transitory computer-readable storage medium of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein evaluating the one or more new predicates in the predicate registry comprises:
<claim-text>updating the lineage bit set of the first row to reflect an updated evaluation of all the predicates in the predicate registry.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The non-transitory computer-readable storage medium of <claim-ref idref="CLM-00008">claim 8</claim-ref>, the operations comprising:
<claim-text>for a received database query, maintaining a dependency bit set having multiple bit positions, wherein each bit position in the dependency bit set corresponds to a query predicate, and wherein a bit value for each bit position in the dependency bit set indicates whether the corresponding predicate is part of in the received query; and</claim-text>
<claim-text>determining whether a row satisfies the received database query by comparing the dependency bit set with the lineage bit set.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The non-transitory computer-readable storage medium of <claim-ref idref="CLM-00008">claim 8</claim-ref>, the operations further including, after evaluating the one or more new predicates, updating the last-predicate-analyzed indicator of the first row to identify a new most recent predicate.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. A database system configured to update a database table having multiple rows, the database system comprising:
<claim-text>a data store; and</claim-text>
<claim-text>a processor configured to perform operations comprising:
<claim-text>maintaining predicates of received database queries in a predicate registry, wherein each predicate is associated with a different index value in the predicate registry, the predicates having an order in which a more recent predicate is ordered higher than a less recent predicate;</claim-text>
<claim-text>for each row of the database table, maintaining in the data store a lineage bit set and a last-predicate-analyzed indicator, wherein:
<claim-text>the lineage bit set includes multiple bit positions, each bit position in the lineage bit set corresponding to a query predicate,</claim-text>
<claim-text>a bit value stored at each bit position indicates whether the corresponding predicate is satisfied by a value in the row, and</claim-text>
</claim-text>
<claim-text>the last-predicate-analyzed indicator identifies a most recent predicate used in a most recent evaluation of the lineage bit set of the row;</claim-text>
<claim-text>receiving an update to an entry in the database table, wherein the entry corresponds to a first row of the database table</claim-text>
<claim-text>updating one or more bit positions in the lineage bit set of the first row that have previously been evaluated and require re-evaluation as a result of the received update;</claim-text>
<claim-text>determining that the last-predicate-analyzed indicator of the first row identifies a predicate that is different from a currently most recent predicate in the predicate registry; and then</claim-text>
<claim-text>evaluating one or more new predicates that entered the predicate registry to update one or more new bit positions in the lineage bit set of the first row that correspond to the one or more new predicates, wherein each new predicate is a predicate that is ordered higher than the predicate identified by the last-predicate-analyzed indicator of the first row.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The database system of <claim-ref idref="CLM-00015">claim 15</claim-ref>, the operations comprising saving a state of the lineage bit set of the first row of the database table corresponding to the update.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The database system of <claim-ref idref="CLM-00016">claim 16</claim-ref>, the operations comprising comparing the saved state of the lineage bit set of the first row of the database table with a state of the lineage bit set after the updating operations to determine whether any past query results need to be updated.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The database system of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein each last-predicate-analyzed indicator is an integer.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The database system of <claim-ref idref="CLM-00015">claim 15</claim-ref>, the operations comprising:
<claim-text>for a received database query, maintaining a dependency bit set having multiple bit positions, wherein each bit position in the dependency bit set corresponds to a query predicate, and wherein a bit value for each bit position in the dependency bit set indicates whether the corresponding predicate is part of in the received query; and</claim-text>
<claim-text>determining whether a row satisfies the received database query by comparing the dependency bit set with the lineage bit set.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The database system of <claim-ref idref="CLM-00015">claim 15</claim-ref>, the operations comprising, after evaluating the one or more new predicates, updating the of the last-predicate-analyzed indicator of the first row to identify a new most recent predicate. </claim-text>
</claim>
</claims>
</us-patent-grant>
