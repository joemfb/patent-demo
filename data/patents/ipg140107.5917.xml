<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627026-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627026</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13257677</doc-number>
<date>20110819</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<us-term-of-grant>
<us-term-extension>120</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>13</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>13</main-group>
<subgroup>28</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>711162</main-classification>
<further-classification>711E12103</further-classification>
<further-classification>707692</further-classification>
</classification-national>
<invention-title id="d2e53">Storage apparatus and additional data writing method</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6928526</doc-number>
<kind>B1</kind>
<name>Zhu et al.</name>
<date>20050800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711154</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>7155460</doc-number>
<kind>B2</kind>
<name>McGovern et al.</name>
<date>20061200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>2007/0083568</doc-number>
<kind>A1</kind>
<name>McGovern et al.</name>
<date>20070400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2010/0082672</doc-number>
<kind>A1</kind>
<name>Kottomtharayil et al.</name>
<date>20100400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>JP</country>
<doc-number>4310338</doc-number>
<kind>B2</kind>
<date>20090800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00006">
<othercit>Andrew S. Tenenbaum, et al., Modern Operating Systems: Design and Implementation, Section 3.4.7 Simulating LRU in Software, Third Edition, Prentice Hall, 2006.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00007">
<othercit>Chuanyi Liu et al, &#x201c;Semantic Data De-duplication for archival storage systems&#x201d;, Computer Systems Architecture Conference, 2008. ACSAC 2008. 13th Asia-Pacific, IEEE, Piscataway, NJ, USA, Aug. 4, 2008, pp. 1-9.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>18</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>711162</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711E12103</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>707692</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>17</number-of-drawing-sheets>
<number-of-figures>18</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20130046944</doc-number>
<kind>A1</kind>
<date>20130221</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Domyo</last-name>
<first-name>Seiichi</first-name>
<address>
<city>Tokyo</city>
<country>JP</country>
</address>
</addressbook>
<residence>
<country>JP</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Sakuraba</last-name>
<first-name>Taketoshi</first-name>
<address>
<city>Sagamihara</city>
<country>JP</country>
</address>
</addressbook>
<residence>
<country>JP</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Arikawa</last-name>
<first-name>Hidehisa</first-name>
<address>
<city>Isehara</city>
<country>JP</country>
</address>
</addressbook>
<residence>
<country>JP</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Domyo</last-name>
<first-name>Seiichi</first-name>
<address>
<city>Tokyo</city>
<country>JP</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Sakuraba</last-name>
<first-name>Taketoshi</first-name>
<address>
<city>Sagamihara</city>
<country>JP</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Arikawa</last-name>
<first-name>Hidehisa</first-name>
<address>
<city>Isehara</city>
<country>JP</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Volpe and Koenig, P.C.</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Hitachi, Ltd.</orgname>
<role>03</role>
<address>
<city>Tokyo</city>
<country>JP</country>
</address>
</addressbook>
</assignee>
<assignee>
<addressbook>
<orgname>Hitachi Computer Peripherals Co., Ltd.</orgname>
<role>03</role>
<address>
<city>Kanagawa-ken</city>
<country>JP</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Dudek, Jr.</last-name>
<first-name>Edward</first-name>
<department>2186</department>
</primary-examiner>
</examiners>
<pct-or-regional-filing-data>
<document-id>
<country>WO</country>
<doc-number>PCT/JP2011/004637</doc-number>
<kind>00</kind>
<date>20110819</date>
</document-id>
<us-371c124-date>
<date>20110920</date>
</us-371c124-date>
</pct-or-regional-filing-data>
<pct-or-regional-publishing-data>
<document-id>
<country>WO</country>
<doc-number>WO2013/027231</doc-number>
<kind>A </kind>
<date>20130228</date>
</document-id>
</pct-or-regional-publishing-data>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Deduplicated backup data of a plurality of generations are aggregated and stored.</p>
<p id="p-0002" num="0000">A storage apparatus is connected via a network to a host system making a content write request and includes a storage unit providing one or more containers composed of a specified storage area, and a back up unit storing the content in the container in accordance with a backup request from the host system; and wherein the backup unit cuts out the content into one or more chunks, detects a duplicate chunk, which is a duplicate of a chunk stored in the container, from the cutout chunks, and additionally writes the chunk, other than the duplicate chunk, to the container where the duplicate chunk is stored.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="211.92mm" wi="160.10mm" file="US08627026-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="230.38mm" wi="158.83mm" file="US08627026-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="233.76mm" wi="168.99mm" file="US08627026-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="225.89mm" wi="164.51mm" file="US08627026-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="220.81mm" wi="157.14mm" file="US08627026-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="223.60mm" wi="181.95mm" file="US08627026-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="232.66mm" wi="156.04mm" file="US08627026-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="116.08mm" wi="152.06mm" file="US08627026-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="202.78mm" wi="162.22mm" file="US08627026-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="228.18mm" wi="173.48mm" file="US08627026-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="233.17mm" wi="159.43mm" file="US08627026-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="158.83mm" wi="163.91mm" file="US08627026-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="232.07mm" wi="174.58mm" file="US08627026-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="226.48mm" wi="163.32mm" file="US08627026-20140107-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="157.73mm" wi="177.97mm" file="US08627026-20140107-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="160.02mm" wi="158.83mm" file="US08627026-20140107-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00016" num="00016">
<img id="EMI-D00016" he="244.52mm" wi="154.86mm" file="US08627026-20140107-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00017" num="00017">
<img id="EMI-D00017" he="219.12mm" wi="170.69mm" file="US08627026-20140107-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">TECHNICAL FIELD</heading>
<p id="p-0003" num="0001">The present invention relates to a storage apparatus and an additional data writing method and is suited for use in a storage apparatus and additional data writing method for aggregating and storing backup data of different generations.</p>
<heading id="h-0002" level="1">BACKGROUND ART</heading>
<p id="p-0004" num="0002">A storage apparatus connected to a host computer via a network is equipped with, for example, a plurality of hard disk drives (HDD) as storage devices for storing data. When storing data in the storage devices, the amount of data is reduced and then stored in order to reduce costs of storage media. Examples of a method for reducing the amount of data include file compression processing and deduplication processing. The file compression processing reduces a data capacity by condensing data segments with the same content in one file. On the other hand, the deduplication processing reduces a total capacity of data in a file system or a storage system by condensing data segments with the same content detected in not only one file, but also in files.</p>
<p id="p-0005" num="0003">A data segment that is a deduplication processing unit will be hereinafter referred to as a chunk. Also, logically gathered data that is a unit to be stored in a storage device will be hereinafter referred to as content. Examples of the content can include normal files as well as files such as archive files, backup files, or virtual volume files in which normal files are aggregated. Furthermore, chunks on which the deduplication processing has been executed are stored on a data block basis in the storage devices, wherein a plurality of chunks are gathered in data block units and each data block is called a container.</p>
<p id="p-0006" num="0004">A specified number or capacity of chunks is set to a container in advance; chunks are gathered until the container becomes full; and once the container becomes full, the chunks are written on a container basis to the storage devices. Then, a container index table indicating which backup data is stored in which container is created in association with each container. For example, if backup data of a plurality of generations are deduplicated and stored in the storage devices, different containers are prepared for different backup generations depending on backup timing and the backup data of each generation is stored in each of the different containers (for example, see Patent Literature 1).</p>
<heading id="h-0003" level="1">CITATION LIST</heading>
<heading id="h-0004" level="1">Patent Literature</heading>
<p id="p-0007" num="0000">
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0005">PTL 1: U.S. Pat. No. 6,928,526</li>
</ul>
</p>
<heading id="h-0005" level="1">Non Patent Literature</heading>
<p id="p-0008" num="0000">
<ul id="ul0002" list-style="none">
    <li id="ul0002-0001" num="0006">NPL 1: Andrew S. Tanenbaum and Albert S. Woodhull, Operating Systems: Design and Implementation, Third Edition, Prentice Hall, 2006. 3.4.7 Simulationg LRU in Software</li>
</ul>
</p>
<heading id="h-0006" level="1">SUMMARY OF INVENTION</heading>
<heading id="h-0007" level="1">Technical Problem</heading>
<p id="p-0009" num="0007">If the backup data of a plurality of generations are stored in respectively different containers as described above, chunks belonging to deduplicated backup data are highly likely to be distributed and stored in the plurality of containers. In this case, the number of containers to which reference is made at the time of data restoration increases, which results in a problem of degradation of restoration performance. Furthermore, when backing up data, data deduplication processing is executed by referring to a container index table(s); and if the chunks are distributed and stored in the plurality of containers, the deduplication processing is executed by referring to a plurality of container index tables, which results in a problem of degradation of backup performance.</p>
<p id="p-0010" num="0008">The present invention was devised in consideration of the above-described circumstances and aims at suggesting a storage apparatus and additional data writing method capable of aggregating and storing deduplicated backup data of a plurality of generations.</p>
<heading id="h-0008" level="1">Solution to Problem</heading>
<p id="p-0011" num="0009">In order to solve the above-described problems, a storage apparatus connected via a network to a host system making a content write request is provided according to the present invention, wherein the storage apparatus includes a storage unit providing one or more containers composed of a specified storage area, and a back up unit storing the content in the container in accordance with a backup request from the host system; and wherein the backup unit cuts out the content into one or more chunks, detects a duplicate chunk, which is a duplicate of a chunk stored in the container, from the cutout chunks, and additionally writes the chunk, other than the duplicate chunk, to the container where the duplicate chunk is stored.</p>
<p id="p-0012" num="0010">When storing the content in the container in accordance with the backup request from the host system according to the above-described configuration, whether a chunk cut out from the content is a duplicate chunk or not is detected and the chunk, other than the duplicate chunk, included in the content is additionally written to the container where the duplicate chunk is stored. As a result, the plurality of chunks constituting the content can be aggregated and stored in one container, thereby enhancing backup performance and restoration performance of the storage apparatus.</p>
<heading id="h-0009" level="1">Advantageous Effects of Invention</heading>
<p id="p-0013" num="0011">According to the present invention, the deduplicated backup data of a plurality of generations can be aggregated and stored, thereby enhancing backup performance and restoration performance</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0010" level="1">BRIEF DESCRIPTION OF DRAWINGS</heading>
<p id="p-0014" num="0012"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram showing the configuration of a storage apparatus according to a first embodiment of the present invention.</p>
<p id="p-0015" num="0013"><figref idref="DRAWINGS">FIG. 2</figref> is a conceptual diagram explaining conventional backup processing and restoration processing.</p>
<p id="p-0016" num="0014"><figref idref="DRAWINGS">FIG. 3</figref> is a conceptual diagram explaining backup processing according to the first embodiment.</p>
<p id="p-0017" num="0015"><figref idref="DRAWINGS">FIG. 4A</figref> is a chart showing the structure of a container index table according to the first embodiment.</p>
<p id="p-0018" num="0016"><figref idref="DRAWINGS">FIG. 4B</figref> is a chart showing the structure of a content index table according to the first embodiment.</p>
<p id="p-0019" num="0017"><figref idref="DRAWINGS">FIG. 5</figref> is a flowchart illustrating a processing sequence for backup processing according to the first embodiment.</p>
<p id="p-0020" num="0018"><figref idref="DRAWINGS">FIG. 6</figref> is a chart showing the structure of a measurement table according to the first embodiment.</p>
<p id="p-0021" num="0019"><figref idref="DRAWINGS">FIG. 7</figref> is a flowchart illustrating a processing sequence for container selection processing according to the first embodiment.</p>
<p id="p-0022" num="0020"><figref idref="DRAWINGS">FIG. 8</figref> is a flowchart illustrating a processing sequence for restoration processing according to the first embodiment.</p>
<p id="p-0023" num="0021"><figref idref="DRAWINGS">FIG. 9</figref> is a conceptual diagram explaining backup processing according to a second embodiment of the present invention.</p>
<p id="p-0024" num="0022"><figref idref="DRAWINGS">FIG. 10</figref> is a chart showing the structure of a measurement table according to the second embodiment.</p>
<p id="p-0025" num="0023"><figref idref="DRAWINGS">FIG. 11</figref> is a flowchart illustrating a processing sequence for container selection processing according to the second embodiment.</p>
<p id="p-0026" num="0024"><figref idref="DRAWINGS">FIG. 12</figref> is a conceptual diagram explaining backup processing according to a third embodiment of the present invention.</p>
<p id="p-0027" num="0025"><figref idref="DRAWINGS">FIG. 13</figref> is a chart showing the structure of a measurement table according to the third embodiment.</p>
<p id="p-0028" num="0026"><figref idref="DRAWINGS">FIG. 14</figref> is a flowchart illustrating a processing sequence for container selection processing according to the third embodiment.</p>
<p id="p-0029" num="0027"><figref idref="DRAWINGS">FIG. 15</figref> is a conceptual diagram explaining backup processing according to the third embodiment of the present invention.</p>
<p id="p-0030" num="0028"><figref idref="DRAWINGS">FIG. 16</figref> is a chart showing the structure of a measurement table according to the third embodiment.</p>
<p id="p-0031" num="0029"><figref idref="DRAWINGS">FIG. 17</figref> is a flowchart illustrating a processing sequence for container selection processing according to the third embodiment.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0011" level="1">DESCRIPTION OF EMBODIMENTS</heading>
<p id="p-0032" num="0030">An embodiment of the present invention will be described below in detail with reference to the attached drawings.</p>
<p id="p-0033" num="0031">(1) First Embodiment</p>
<p id="p-0034" num="0032">(1-1) Outline of this Embodiment</p>
<p id="p-0035" num="0033">Firstly, the outline of this embodiment will be explained. A storage apparatus connected to a host computer via a network is equipped with, for example, a plurality of hard disk drives (HDD) as storage devices for storing data. When storing data in the storage devices, the amount of data is reduced and then stored in order to reduce costs of storage media. Examples of a method for reducing the amount of data include file compression processing and deduplication processing. The file compression processing reduces a data capacity by condensing data segments with the same content in one file. On the other hand, the deduplication processing reduces a total capacity of data in a file system or a storage system by condensing data segments with the same content detected in not only one file, but also in files.</p>
<p id="p-0036" num="0034">A data segment that is a deduplication processing unit will be hereinafter referred to as a chunk. Also, logically gathered data that is a unit to be stored in a storage device will be hereinafter referred to as content. Examples of the content can include normal files as well as files such as archive files, backup files, or virtual volume files in which normal files are aggregated. Furthermore, chunks on which the deduplication processing has been executed are stored on a data block basis in the storage devices, wherein a plurality of chunks are gathered in data block units and each data block is called a container.</p>
<p id="p-0037" num="0035">Regarding chunk-based deduplication processing, whether or not a chunk with the same content is already stored in the hard disk drive is judged before storing an arbitrary chunk in the hard disk drive. If it is determined as a result of the judgment that the chunk is not a duplicate, the chunk is stored directly in the hard disk drive. On the other hand, if it is determined as a result of the judgment that the chunk is a duplicate, such chunk (hereinafter referred to as the duplicate chunk) itself will not be stored in the hard disk drive, but link information indicating a storage location of the chunk will be stored in the hard disk drive. In this way, duplicate chunks are eliminated when storing chunks, by repeatedly executing the duplication judgment of the chunks. Therefore, it is possible to control the usage of the hard disk drives and increase the speed of the backup processing.</p>
<p id="p-0038" num="0036">The aforementioned container is a unit for accumulating a plurality of chunks in a memory for the storage apparatus wherein the unit is to be stored in the hard disk drives. Furthermore, a container index table for managing the locations of the chunks in a container is created in each container. The container index table stores offset (position in the container) of the relevant chunk and the size of the chunk. The container index table is also used for the chunk duplication judgment.</p>
<p id="p-0039" num="0037">Generally, the size of a chunk is several kilobytes. So, when executing the duplication judgment processing, processing for sequentially comparing chunks from the top of the chunks requires long processing time and costs much. So, the execution of the duplication judgment processing in a short time and at low cost is made possible by using a message digest of the chunks. The message digest is a technique to output a digest with a fixed length with respect to data input with an arbitrary length. The output result of the message digest will be referred to as a fingerprint (FP) and explained below. The fingerprint can be obtained by using a hash function; and, for example, a function such as the SHA 256, whose result will be a random number with an extremely high probability, and regarding which data of the chunk is highly likely to be uniquely determined by a hash value relative to that data of the chunk, is used.</p>
<p id="p-0040" num="0038">In this embodiment, the fingerprint of each chunk is stored in the aforementioned container index table and the fingerprints of the chunks are compared at the time of the duplication judgment processing. Accordingly, the higher speed and lower cost of the duplication judgment processing can be implemented as compared to a case where the chunks are compared on a bit basis.</p>
<p id="p-0041" num="0039">Furthermore, write-once storage devices are used in order to guarantee data integrity and realize highly reliable backups. The write-once storage device is a storage device capable of writing data only once, but reading data many times. Since data written to the write-once storage device once cannot be deleted or modified, the write-once storage device is suited for, for example, archival use for preservation of evidence. For example, optical disk devices can be an example of such storage devices. Generally, magnetic disk devices are not write-once storage devices because they can update written data. However, the magnetic disk devices can be used as the write-once storage devices by allowing only additional data writing, that is, prohibiting overwriting of data by contriving the configuration of a file system and a device driver. The most ideal form of this embodiment can be applied mainly to write-once-type hard disk drives suited for data backups.</p>
<p id="p-0042" num="0040">A specified number or capacity of chunks is set to the aforementioned container in advance; chunks are gathered until the container becomes full; and once the container becomes full, the chunks are written on a container basis to the storage devices. In other words, in a case of the write-once-type hard disk drives, the chunks are written to the container until the container becomes full. Then, the container index table showing which backup data is stored in which container is created corresponding to each container. For example, if backup data of a plurality of generations are deduplicated and stored in the storage devices, different containers are prepared for different backup generations depending on backup timing and the backup data of each generation is additionally written to each of the different containers.</p>
<p id="p-0043" num="0041">If the backup data of a plurality of generations are stored in respectively different containers as described above, chunks belonging to deduplicated backup data are highly likely to be distributed and stored in the plurality of containers. In this case, the number of containers to which reference is made at the time of data restoration increases, which results in a problem of degradation of restoration performance. Furthermore, when backing up data, data deduplication processing is executed by referring to a container index table(s); and if the chunks are distributed and stored in the plurality of containers, the deduplication processing is executed by referring to a plurality of container index tables, which results in a problem of degradation of backup performance.</p>
<p id="p-0044" num="0042">So, when deduplicating and storing the backup data of a plurality of generations in the storage devices, the backup data of the plurality of generations having the same content are aggregated and stored in one container according to this embodiment. When additionally writing the backup data to a write-once-type container, the above-described aggregation and storage of the backup data can be realized by comparing data stored in the existing container with the backup target data. For example, if the backup target data is backup data having the same content as the content stored in the existing container, the backup data is additionally written to that container. On the other hand, if the backup target data is not backup data having the content stored in the existing container, a new container is created and the backup data is additionally written to that container. As a result, the deduplicated backup data of the plurality of generations can be aggregated and stored.</p>
<p id="p-0045" num="0043">(1-2) Structure of Storage Apparatus</p>
<p id="p-0046" num="0044">Next, a hardware structure of the storage apparatus <b>100</b> will be explained. Referring to <figref idref="DRAWINGS">FIG. 1</figref>, the storage apparatus <b>100</b> is connected to a host system such as a backup server (not shown) via a network <b>174</b>. The network <b>174</b> may be, for example, a LAN (Local Area Network), the Internet, public lines, or private lines.</p>
<p id="p-0047" num="0045">Furthermore, the storage apparatus <b>100</b> is connected to an administrator terminal <b>172</b> via a network. The administrator terminal <b>172</b> is a computer device equipped with information processing resources such as a CPU and a memory and records logs of, for example, operation results and failure occurrence as it issues instruction to start or stop the storage apparatus <b>100</b> in accordance with input by, for example, an operator and monitors the operation of the storage apparatus <b>100</b>. The administrator terminal <b>172</b> also specifies system settings regarding backup processing and restoration processing in the storage apparatus <b>100</b>. An example of the administrator terminal <b>172</b> can be a personal computer composed of, for example, a display, a keyboard, a processor, and storage devices.</p>
<p id="p-0048" num="0046">The storage apparatus <b>100</b> is mainly constituted from a processor <b>102</b>, a memory <b>104</b>, a disk <b>106</b>, and a network interface <b>108</b>.</p>
<p id="p-0049" num="0047">The processor <b>102</b> functions as an arithmetic processing unit and controls the operation of the storage apparatus <b>100</b> in accordance with, for example, programs and operation parameters stored in the memory <b>104</b>.</p>
<p id="p-0050" num="0048">The memory <b>104</b> stores an operating system <b>154</b>, various programs operating in cooperation with the operating system <b>154</b>, a backup program <b>150</b>, a restoration program <b>152</b>, and various tables.</p>
<p id="p-0051" num="0049">The backup program <b>150</b> stores backup target data, which are provided via the network, in the disk <b>106</b> by using container index tables <b>110</b>, a measurement table <b>160</b>, and a write buffer <b>142</b>.</p>
<p id="p-0052" num="0050">Although there are a plurality of container index tables <b>110</b>, a container index table <b>110</b> used by the backup program <b>150</b> will be explained as a container index table <b>112</b> and a container index table <b>110</b> used by the restoration program <b>152</b> will be explained as a container index table <b>114</b>. The container index table <b>110</b> is a table for managing chunk storage locations on a container basis. The structure of the container index table <b>110</b> will be explained later in detail.</p>
<p id="p-0053" num="0051">The container index table <b>110</b> is created for each container. When the backup program <b>150</b> executes the duplication judgment processing, it refers to the fingerprints in at least one or more container index tables <b>110</b>. So, it is necessary to load data of the container index tables into the memory <b>104</b>. However, since the memory <b>104</b> is limited, it is difficult to load data of all the container index tables <b>110</b> into the memory <b>104</b>. Therefore, the limited resources of the memory <b>104</b> are utilized by means of rollin of the container index table <b>110</b> from the disk <b>106</b> to the memory <b>104</b> and roll-out of the container index table from the memory <b>104</b> to the disk <b>106</b>.</p>
<p id="p-0054" num="0052">In this embodiment, the roll-in/roll-out of the memory <b>104</b> is performed by an LRU (Least Recently Used) method. By the LRU method, data in the memory <b>104</b> to which reference has not been made for the longest period of time is rolled out and data in the disk <b>106</b> is rolled in. This is based on the characteristics of data to which reference has not been made for the longest period of time, that is, such data is least likely to be a target of reference next time. Since the roll-in/roll-out control technique of the memory <b>104</b> requires transparent access to the memory <b>104</b> and the disk <b>106</b>, it is provided by the operating system <b>154</b> or the processor <b>102</b> and called a virtual memory management technique. Page replacement processing in virtual memory is executed by using three kinds of bits, that is, a reference bit (r bit), an update bit (c bit), and a valid/invalid bit (v bit). These bits are updated every time a chunk included in the content arrives.</p>
<p id="p-0055" num="0053">In this embodiment, such virtual memory management technique is realized by using the container index tables.</p>
<p id="p-0056" num="0054">For example, if a duplicate chunk is included in the content, the reference bit (r bit) of a container storing that chunk is set to &#x201c;1.&#x201d; Moreover, when writing a chunk included in the content to the disk <b>106</b>, the update bit (c bit) of a container storing that chunk is set to &#x201c;1.&#x201d; Furthermore, when rolling in the relevant container index table, the v bit is set to &#x201c;1&#x201d;; and when rolling out the relevant container index table, the v bit is set to &#x201c;0.&#x201d;</p>
<p id="p-0057" num="0055">Furthermore, one of methods for implementing the LRU method is an aging method (for example, see Non Patent Literature 1). The aging method uses a plurality of reference bits (r bits). Regarding the reference bits (r bits) using a plurality of bits, a bit value is shifted to the right at every specified time interval. Particularly, when reference is made, the bit value is shifted to the right and then the most significant bit is set to 1. Such shift processing makes it possible to easily realize weighting explained below. For example, if reference time is in the past, the weighting is reduced; and as the reference time is closer to the present, the weighting is increased. For example, the reference bits obtained with respect to certain data five times at a specified time interval are as follows:</p>
<p id="p-0058" num="0056">1<sup>st </sup>time: 1</p>
<p id="p-0059" num="0057">2<sup>nd </sup>time: 0</p>
<p id="p-0060" num="0058">3<sup>rd </sup>time: 1</p>
<p id="p-0061" num="0059">4<sup>th </sup>time: 0</p>
<p id="p-0062" num="0060">5<sup>th </sup>time: 0</p>
<p id="p-0063" num="0061">If the above reference bits are weighted and expressed with an 8-bit counter, the following values are obtained.</p>
<p id="p-0064" num="0062">An initial value is 00000000.</p>
<p id="p-0065" num="0063">1<sup>st </sup>time: 10000000</p>
<p id="p-0066" num="0064">2<sup>nd </sup>time: 01000000</p>
<p id="p-0067" num="0065">3<sup>rd </sup>time: 10100000</p>
<p id="p-0068" num="0066">4<sup>th </sup>time: 01010000</p>
<p id="p-0069" num="0067">5<sup>th </sup>time: 00101000</p>
<p id="p-0070" num="0068">As the reference bit (r bit) is expressed with the 8-bit counter as described above, data to which reference was made in the past becomes a small value and data regarding which reference time is closer to the present becomes a larger value.</p>
<p id="p-0071" num="0069">The measurement table <b>160</b> is a table for managing additional write locations of chunks in a container, managing roll-in/roll-out of the container index tables <b>110</b>, and manages whether a duplicate chunk(s) exists or not as well as the number of duplicate chunks on a container basis. The management table about the roll-in/roll-out of the container index tables <b>110</b> and the management table about the duplicate chunks may be either one table or separate tables. In this embodiment, the management table about the roll-in/roll-out and the management table about the duplicate chunks are managed by one table. The structure of the measurement table <b>160</b> will be explained later in detail.</p>
<p id="p-0072" num="0070">The restoration program <b>152</b> reads backup data stored in the disk <b>106</b> by using a content index table <b>182</b>, the container index table <b>114</b>, and a read cache <b>144</b>.</p>
<p id="p-0073" num="0071">The content index table <b>182</b> is a table for managing chunk storage locations on a content basis. The structure of the content index table <b>182</b> will be explained later in detail.</p>
<p id="p-0074" num="0072">The disk <b>106</b> is composed of, for example, hard disk drives and stores a container index table DB <b>120</b>, a content index table DB <b>180</b>, and a plurality of containers (containers <b>130</b>, <b>132</b>, <b>134</b> in <figref idref="DRAWINGS">FIG. 1</figref>). The container index table DB <b>120</b> stores a plurality of container index tables and the content index table DB <b>180</b> stores a plurality of content index tables. Furthermore, the container <b>130</b> and others store backup data on which the deduplication processing has been executed by the backup program <b>150</b>.</p>
<p id="p-0075" num="0073">(1-3) Outline of Backup Processing and Restoration Processing</p>
<p id="p-0076" num="0074">Before explaining backup processing and restoration processing according to this embodiment, conventional backup processing and restoration processing will be explained. As shown in <figref idref="DRAWINGS">FIG. 2</figref>, the backup program <b>1450</b> backs up content f<b>1</b> (<b>1460</b>), content f<b>2</b> (<b>1470</b>), and content f<b>3</b> (<b>1480</b>) which have sequentially arrived as backup target data. The content f<b>1</b> includes chunk a, the content f<b>2</b> includes the chunk a and chunk b, and the content f<b>3</b> includes chunk c in addition to the chunk a and the chunk b as shown in <figref idref="DRAWINGS">FIG. 2</figref>. Since the deduplication processing is executed on the content f<b>1</b> to f<b>3</b> by the backup program <b>1450</b>, the chunk a, the chunk b, and the chunk c are stored in the containers <b>1430</b> and others.</p>
<p id="p-0077" num="0075">For example, it is assumed that an interval between the arrival of the content and the arrival of another content is large and there is a large interval between a backup of the content f<b>1</b> and a backup of the content f<b>2</b>. In this case, container CF (<b>1430</b>) becomes filled with chunks of another backup target after storing the chunk a of the content f<b>1</b> in the container CF (<b>1430</b>) and before storing the chunk b of the content f<b>2</b> in the container CF (<b>1430</b>), so that the chunk b will be stored in container CG (<b>1432</b>) which is different from the container where the chunk a is stored. Similarly, the chunk c of the content f<b>3</b> will be stored in container CH (<b>1434</b>) which is different from the containers where the chunk a and the chunk b are stored. Furthermore, container index tables TF (<b>1410</b>) and others are created corresponding to their relevant containers.</p>
<p id="p-0078" num="0076">If the backup data of three generations having the same content are distributed and stored in three containers as described above, it is necessary to refer to the three containers when restoring the data. Also, when backing up the data, the data deduplication processing is executed by referring to the container index tables <b>1410</b> and others; and it is necessary to execute the deduplication processing by referring to the three container index tables <b>1410</b> and others corresponding to the three containers. In this embodiment, backup data of a plurality of generations having the same content are aggregated and stored in one container, so that the deduplication processing is executed by referring to one container when restoring the data, or referring to one container index table when baking up the data.</p>
<p id="p-0079" num="0077">(1-3-2) Details of Backup Processing</p>
<p id="p-0080" num="0078">Next, the details of the backup processing according to this embodiment will be explained with reference to <figref idref="DRAWINGS">FIG. 3</figref>. Similarly to the case shown in <figref idref="DRAWINGS">FIG. 2</figref>, the backup program <b>150</b> backs up content f<b>1</b> (<b>260</b>), content f<b>2</b> (<b>270</b>), and content f<b>3</b> (<b>280</b>) which have sequentially arrived as backup target data.</p>
<p id="p-0081" num="0079">In this embodiment, container CF (<b>230</b>) is equipped with a basic area <b>232</b> and an extended area <b>234</b> as shown in <figref idref="DRAWINGS">FIG. 3</figref>. Regarding the container index table TF (<b>110</b>), a table corresponding to the basic area and the extended area of the container CF (<b>130</b>) is prepared in the same manner. The container index table TF (<b>110</b>) stores information about, for example, fingerprints, offset, and lengths of chunks stored in the container CF.</p>
<p id="p-0082" num="0080">For example, at the time of program activation, the backup program <b>150</b> specifies the size of the basic area and extended area of the container index table <b>110</b> and the size of the basic area and extended area of the container <b>130</b>. The size may be specified as, for example, byte size of the disk storage capacity. Also, the size of the basic area and extended area may be specified as the number of chunks. For example, the number of chunks as the basic area of the container index table <b>110</b> is specified as 600 chunks, the number of chunks as the extended area of the container index table <b>110</b> is specified as 400 chunks, the number of chunks as the basic area of the container <b>130</b> is specified as 600 chunks, and the number of chunks as the extended area of the container <b>130</b> is specified as 400 chunks. These numbers of chunks are specified according to input by the operator, using commands or similar via the administrator terminal <b>172</b>. If no specification is made via the administrator terminal <b>172</b>, the above-described size may be stored as initial values in, for example, initial files in advance and the initial values may be read at the time of activation of the backup program <b>150</b>.</p>
<p id="p-0083" num="0081">The backup program <b>150</b> creates a new container CF (<b>230</b>) for storing the content f<b>1</b> and stores the chunk a in a basic area <b>232</b> of the container CF (<b>230</b>). The backup program <b>150</b> secures an extended area <b>234</b> of the container CF in order to store backup data of the same content as that of the content f<b>1</b>.</p>
<p id="p-0084" num="0082">When backing up the content f<b>2</b>, the chunk b other than the chunk a which is a duplicate, from among the chunk a and the chunk b, is stored in the extended area of the container CF (<b>230</b>). Similarly, when backing up the content f<b>3</b>, the chunk c other than the chunk a and the chunk b which are duplicates, from among the chunk a, the chunk b, and the chunk c, are stored in the extended area of the container CF (<b>230</b>). Then, management information of the chunk a, the chunk b, and the chunk c is stored respectively in the container index table TF (<b>210</b>).</p>
<p id="p-0085" num="0083">Therefore, when restoring the content f<b>3</b> including the chunk a, the chunk b, and the chunk c, the restoration program <b>152</b> can read the content f<b>3</b> by referring to only the container CF (<b>230</b>). Furthermore, when backing up the same content as that of the content f<b>1</b> to f<b>3</b>, the restoration program <b>152</b> can execute the deduplication processing by referring to only the container index table TF.</p>
<p id="p-0086" num="0084">Next, the structure of the container index table <b>110</b> will be explained with reference to <figref idref="DRAWINGS">FIG. 4A</figref>. The container index table <b>110</b> is a table created on a container basis and is a table for managing chunks stored in the relevant container. The container index table <b>110</b> is constituted from a fingerprint column <b>322</b>, a container offset column <b>324</b>, and a chunk length column <b>326</b>. The fingerprint column <b>322</b> stores a fingerprint of the relevant chunk. The container offset column <b>324</b> stores the offset of the relevant chunk in the container. The chunk length column <b>326</b> stores information indicating the length of the relevant chunk. In other words, the management information of each chunk is stored in each line of the container index table <b>110</b>. For example, the container index table <b>110</b> in <figref idref="DRAWINGS">FIG. 4A</figref> shows a state after the arrival of the content f<b>3</b> shown in <figref idref="DRAWINGS">FIG. 3</figref> and stores management information <b>222</b> of the chunk a, management information <b>224</b> of the chunk b, and management information <b>226</b> of the chunk c.</p>
<p id="p-0087" num="0085">Furthermore, a plurality of container index tables are managed by a list <b>310</b>. Regarding the list <b>310</b>, a container ID <b>314</b> for identifying the relevant container is associated with a fingerprint <b>312</b> of the relevant chunk. The container ID <b>314</b> is also used as pointer information enabling reference to the container index table <b>110</b>. In this embodiment, the container ID (CF) and its corresponding container index table (TF) use a common identifier called uuid (Universally Unique Identifier). For example, three files, that is, a container, a container index table, and a content index table exist in the disk <b>106</b> and are located under three directories, respectively.</p>
<p id="p-0088" num="0086">Container/uuid-Cf a main body of the container
<ul id="ul0003" list-style="none">
    <li id="ul0003-0001" num="0087">ChunkIndex/uuid-Cf a container index table database (a file storing the table TF)</li>
    <li id="ul0003-0002" num="0088">Contents/uuid-Cf a content index table database
<br/>
For example, if the content ID is CF, it is possible to refer to the chunk a, the chunk b, and the chunk c of the container CF by tracing the container index table TF.
</li>
</ul>
</p>
<p id="p-0089" num="0089">Next, the structure of the content index table <b>182</b> will be explained with reference to <figref idref="DRAWINGS">FIG. 4B</figref>. The content index table <b>182</b> is a table created on a content basis and is a table for managing chunks included in the relevant content. The content index table <b>182</b> is constituted from a content ID column <b>361</b>, a fingerprint column <b>362</b>, a container ID column <b>364</b>, a content offset column <b>366</b>, and a chunk length column <b>368</b>. The content ID column <b>361</b> stores information for identifying the relevant content. The fingerprint column <b>362</b> stores a fingerprint of the relevant chunk. The container ID column <b>364</b> stores identification information of a container where the relevant chunk is stored. The content offset column <b>366</b> stores information showing the position of the relevant chunk in the content. The chunk length column <b>368</b> stores information showing the chunk length.</p>
<p id="p-0090" num="0090">For example, the content index table <b>182</b> (Sf<b>3</b>) in <figref idref="DRAWINGS">FIG. 4B</figref> stores information of the content f<b>3</b> shown in <figref idref="DRAWINGS">FIG. 3</figref>. Specifically speaking, the content f<b>3</b> includes the chunk a, the chunk b, and the chunk c and the content can be reconstructed according to the offset and chunk length of each chunk. Also, since each chunk is associated with the content ID, in which container each chunk is stored can be found.</p>
<p id="p-0091" num="0091">The chunk offset (<b>366</b>) and the chunk length (<b>368</b>) constituting the content index table <b>182</b> indicate a logical location of the relevant chunk in the content. Furthermore, the chunk offset (<b>324</b>) and the chunk length (<b>326</b>) constituting the aforementioned container index table <b>110</b> indicate a physical location of the relevant chunk in the disk <b>106</b>. When executing the restoration processing, reference is made to the content index table <b>182</b>, the container ID of each chunk is obtained, and the container index table <b>110</b> is searched based on that container ID. Then, the physical location of each chunk is obtained based on the information stored in the container index table <b>110</b> and those chunks are read from the disk <b>106</b>, and then the content is reconstructed according to the logical location of the content index table <b>182</b>.</p>
<p id="p-0092" num="0092">Next, the backup processing executed by the backup program <b>150</b> will be explained. As shown in <figref idref="DRAWINGS">FIG. 5</figref>, the backup program <b>150</b> decomposes the content, which is a backup target, into chunks Si (i=1, 2, n) (S<b>101</b>).</p>
<p id="p-0093" num="0093">Then, the backup program <b>150</b> creates the management information of the chunk Si (S<b>102</b>). The management information of the chunk is information about the fingerprint of the chunk, the position (offset) of the chunk in the content, and the length of the chunk.</p>
<p id="p-0094" num="0094">Subsequently, the backup program <b>150</b> initializes counter i used for loop processing (i=0) (S<b>103</b>) and executes the duplication judgment on the chunk Si (S<b>104</b>). Specifically speaking, the backup program <b>150</b> judges whether or not a fingerprint identical to the fingerprint of the chunk obtained by decomposition in step S<b>101</b> is included in the list <b>310</b> shown in <figref idref="DRAWINGS">FIG. 4A</figref>. If the fingerprint of the chunk matches with the fingerprint in the list <b>310</b>, the backup program <b>150</b> determines that duplication exists; and if the fingerprint of the chunk does not match with the fingerprint in the list <b>310</b>, the backup program <b>150</b> determines that duplication does not exist.</p>
<p id="p-0095" num="0095">It is desirable that the list <b>310</b> be read to the memory <b>104</b> at the time of activation of the backup program <b>150</b> and be resident in the memory <b>104</b>. However, if the number of entries (lines) in the list <b>310</b> is large and all the entries of the list <b>310</b> are read to and kept in the memory <b>104</b>, the memory capacity of the memory <b>104</b> will be overstrained. Therefore, only the entries necessary for the duplication judgment processing are read to the memory <b>104</b> as cache, so that the number of times of input to, and/or output from, the disk <b>106</b> can be reduced without overstraining the memory capacity of the memory <b>104</b>.</p>
<p id="p-0096" num="0096">In this embodiment, only the necessary entries in the list <b>310</b> can be read to the memory <b>104</b> as cache by executing the duplication judgment processing by using both the list <b>310</b> and the container index table <b>110</b>. For example, it is assumed that the content f<b>1</b> to f<b>3</b> shown in <figref idref="DRAWINGS">FIG. 3</figref> are aggregated in the container CF. If it is confirmed that the chunk a included in the content f<b>3</b> is stored in the container CF, it is possible to search the chunk b and the chunk c other than the chunk a by limiting a search range to the range of the container index table TF corresponding to the container CF. If the chunk b or the chunk c, other than the chunk a, cannot be found in the range of the container index table TF, it is possible to determine at high speed that these chunks are not duplicate chunks. In this way, reference is made to the container index table RF as the cache for the duplication judgment processing. This is a particularly effective means when the number of entries in the list <b>310</b> is extremely large as compared to the number of entries in the container index table TF.</p>
<p id="p-0097" num="0097">Then, if it is determined as a result of the duplication judgment processing in S<b>104</b> that the chunk Si is a duplicate chunk (S<b>105</b>), the backup program <b>150</b> adds 1 to the counter I and repeats the duplication judgment processing in step S<b>104</b> on the next chunk. On the other hand, if it is determined that the chunk Si is not a duplicate chunk (S<b>105</b>), the backup program <b>150</b> executes the processing in step S<b>107</b>.</p>
<p id="p-0098" num="0098">If it is determined in step S<b>105</b> that the chunk Si is not a duplicate chunk, the backup program <b>150</b> judges whether at least one of chunks S<b>1</b> through Si&#x2212;1 on which the duplication judgment processing was executed in the past is a duplicate chunk or not (S<b>107</b>).</p>
<p id="p-0099" num="0099">If it is determined in step S<b>107</b> that at least one of chunks Si through Si&#x2212;1 is a duplicate chunk, the backup program <b>150</b> selects a container including the relevant duplicate chunk (<b>108</b>). The container selection processing in step S<b>108</b> will be explained later in detail.</p>
<p id="p-0100" num="0100">Next, the backup program <b>150</b> judges whether container C including the relevant duplicate chunk was selected successfully in step S<b>108</b> (S<b>109</b>). If the container C was selected successfully in step S<b>109</b>, the backup program <b>150</b> writes the chunk Si to the extended area of the selected container C (S<b>110</b>). Then, the backup program writes management information msi of the chunk Si, which was written in step S<b>110</b>, to the extended area of the container index table T corresponding to the container C (S<b>111</b>). For example, when the content f<b>2</b> shown in <figref idref="DRAWINGS">FIG. 3</figref> arrives or when the content f<b>3</b> arrives, the container CF including the duplicate chunk a or b is selected and the processing in step S<b>108</b> to step S<b>111</b> is executed.</p>
<p id="p-0101" num="0101">If it is determined in step S<b>107</b> that no duplicate chunk exists, the backup program <b>150</b> judges whether the basic area of the present container is full or not (S<b>112</b>). The basic area of the present container means the basic area of a container most recently used by the backup program <b>150</b>.</p>
<p id="p-0102" num="0102">If it is determined in step S<b>112</b> that the basic area of the container is full, the backup program <b>150</b> creates a new container C and its corresponding container index table T (S<b>113</b>). If it is determined in step S<b>112</b> that the basic area of the container is not full, the backup program <b>150</b> proceeds to processing in step S<b>114</b>.</p>
<p id="p-0103" num="0103">Then, the backup program <b>150</b> writes the chunk Si to the basic area of the container C (S<b>114</b>) and writes the management information msi, such as the fingerprint, of the container C to the basic area of the container index table T corresponding to the container C (S<b>115</b>). For example, if the content f<b>1</b> shown in <figref idref="DRAWINGS">FIG. 3</figref> arrives, the processing from step S<b>112</b> to step S<b>115</b> is executed.</p>
<p id="p-0104" num="0104">Now, the specific structure of the measurement table <b>160</b> used during the backup processing will be explained. As shown in <figref idref="DRAWINGS">FIG. 6</figref>, the measurement table <b>160</b> manages the valid/invalid bit (v bit), the reference bit (r bit), and the update bit (c bit).</p>
<p id="p-0105" num="0105">A case where chunks included in the content f<b>1</b> to f<b>3</b> shown in <figref idref="DRAWINGS">FIG. 3</figref> have arrived at the storage apparatus <b>100</b> will be explained as an example. When the chunk arrives, the measurement table <b>160</b> is updated sequentially.</p>
<p id="p-0106" num="0106">Firstly, when the chunk a (<b>262</b>) of the content f<b>1</b> (<b>260</b>) shown in <figref idref="DRAWINGS">FIG. 3</figref> arrives, the update bit (c bit) is set to 1 because the chunk a is not a duplicate chunk. Then, the management information of the chunk a is written to the basic area (<b>212</b>) of the container index table TF (<b>210</b>). Subsequently, the chunk a is written to the basic area <b>232</b> of the container CF (<b>230</b>).</p>
<p id="p-0107" num="0107">Next, when the chunk a (<b>272</b>) of the content f<b>2</b> (<b>270</b>) arrives, the reference bit (r bit) is set to 1 because the chunk a is a duplicate chunk. Subsequently, when the chunk b (<b>274</b>) of the content f<b>2</b> (<b>270</b>) arrives, the update bit (c bit) is set to 1 because the chunk b is not a duplicate chunk. Then, the management information of the chunk b is written to the extended area (<b>214</b>) of the container index table TF (<b>210</b>). Subsequently, the chunk b (<b>244</b>) is written to the extended area <b>234</b> of the container CF (<b>230</b>).</p>
<p id="p-0108" num="0108">Next, when the chunk a (<b>282</b>) of the content f<b>3</b> (<b>280</b>) arrives, the reference bit (r bit) is set to 1 because the chunk a is a duplicate chunk. Then, when the chunk b (<b>284</b>) arrives, the reference bit (r bit) remains to be 1 because the chunk b is also a duplicate chunk. Subsequently, when the chunk c (<b>286</b>) arrives, the update bit (c bit) is set to 1 because the chunk c is not a duplicate chunk. Then, the management information of the chunk c is written to the extended area (<b>214</b>) of the container index table TF (<b>210</b>). Subsequently, the chunk c (<b>246</b>) is written to the extended area <b>234</b> of the container CF (<b>230</b>).</p>
<p id="p-0109" num="0109">Next, the container selection processing in step S<b>108</b> will be explained with reference to <figref idref="DRAWINGS">FIG. 7</figref>. As shown in <figref idref="DRAWINGS">FIG. 7</figref>, the backup program <b>150</b> searches for the container index table <b>110</b> for which the reference bit (r bit) in the measurement table <b>160</b> is 1 (S<b>121</b>). A case where the reference bit (r bit) in the measurement table <b>160</b> is 1 as mentioned above is a case where the corresponding chunk is a duplicate chunk. Therefore, as a result of searching for the container index table <b>110</b> corresponding to the container <b>130</b> in which the same chunk as the duplicate chunk is stored, the content having the same chunk as the duplicate chunk (for example, first-generation backup data) and the content including the duplicate chunk (for example, second-generation backup data) can be managed by using the same container <b>130</b> and the container index table <b>110</b>.</p>
<p id="p-0110" num="0110">Subsequently, the backup program <b>150</b> judges whether or not there is one container index table <b>110</b> obtained as a result of the search in step S<b>121</b> (S<b>122</b>). If it is determined in step S<b>122</b> that there is one applicable container index table <b>110</b>, the backup program <b>150</b> selects that container index table <b>110</b> (S<b>123</b>) and terminates the processing. On the other hand, if it is determined in step S<b>122</b> that the number of applicable container index table <b>110</b> is not one, that is, there are two or more applicable container index tables <b>110</b>, the backup program <b>150</b> does not select the container index table <b>110</b> (S<b>124</b>) and terminates the processing.</p>
<p id="p-0111" num="0111">Referring to <figref idref="DRAWINGS">FIG. 7</figref>, if there is one container storing a duplicate chunk, the backup program <b>150</b> selects the container index table <b>110</b> corresponding to the container which stores the relevant chunk. On the other hand, if there are two or more containers which store a duplicate chunk(s), the backup program <b>150</b> does not selects the container index table <b>110</b> and proceeds to the processing in step S<b>109</b> shown in <figref idref="DRAWINGS">FIG. 5</figref>. Specifically speaking, if there are two or more containers which store a duplicate chunk(s), the backup program <b>150</b> checks if the container <b>130</b> is full or not, and then stores the chunk in the basic area of the container <b>130</b> or creates a new container <b>130</b> and stores the chunk in that container <b>130</b> in the same manner as normal chunk write processing.</p>
<p id="p-0112" num="0112">Referring back to <figref idref="DRAWINGS">FIG. 5</figref>, the backup program <b>150</b> judges whether the duplication judgment processing and the write processing on all the chunks have terminated or not (S<b>116</b>). Specifically speaking, the backup program <b>150</b> compares the number of chunks included in the content (n) with the number of counters of the counter i.</p>
<p id="p-0113" num="0113">If it is determined in step S<b>116</b> that the duplication judgment processing and the write processing on all the chunks have terminated, the backup program <b>150</b> associates information of the content with the management information of the chunks included in the content and writes them to the content index table <b>182</b> (S<b>117</b>) and thereby terminates the content backup processing. On the other hand, if it is determined in step S<b>116</b> that the duplication judgment processing and the write processing on all the chunks have not terminated, the backup program <b>150</b> adds 1 to the counter i (S<b>106</b>) and repeats the processing in step S<b>104</b> and subsequent steps.</p>
<p id="p-0114" num="0114">(1-3-3) Details of Restoration Processing</p>
<p id="p-0115" num="0115">Next, the details of the restoration processing according to this embodiment will be explained with reference to <figref idref="DRAWINGS">FIG. 8</figref>. The restoration program <b>152</b> firstly refers to the content index table <b>182</b> and obtains information of chunks Si (Si=1, 2 and so on up to n) included in read target content (S<b>201</b>). Specifically speaking, the restoration program <b>152</b> creates a list of the chunks Si which need to be read from the content index table <b>182</b>.</p>
<p id="p-0116" num="0116">Next, the restoration program <b>152</b> sets 0 to the counter i (S<b>202</b>). Then, the restoration program <b>152</b> reads the management information of the container index table <b>140</b> (S<b>203</b>). Specifically speaking, the restoration program <b>152</b> reads the container index table <b>140</b>, to which the relevant chunk Si belongs, from the disk <b>106</b> based on the information of the chunk Si in the content index table <b>182</b> which was obtained in step S<b>201</b> and reads the management information of that chunk. The management information of the chunk means, for example, information about the fingerprint of the chunk, the position of the chunk in the container, and the length of the chunk as mentioned earlier.</p>
<p id="p-0117" num="0117">Then, the restoration program <b>152</b> reads the chunk Si stored in the container <b>130</b> corresponding to the container index table <b>140</b> based on the management information of the chunk which was read in step S<b>203</b> (S<b>204</b>).</p>
<p id="p-0118" num="0118">Subsequently, the restoration program <b>152</b> judges whether or not the read processing has terminated with respect to all the chunks included in the restoration target content (S<b>205</b>). Specifically speaking, the restoration program <b>152</b> compares the number of chunks included in the content (n) with the number of counters of the counter i.</p>
<p id="p-0119" num="0119">If it is determined in step S<b>205</b> that the read processing has terminated with respect to all the chunks, the restoration program <b>152</b> synthesizes the content from the read chunks Si (i=1, 2 and so on up to n) (S<b>207</b>) and terminates the restoration processing. Specifically speaking, the restoration program <b>152</b> synthesizes the content from the chunks Si, which were read in step S<b>204</b>, based on the offset-in-content information and the chunk length information in the content index table <b>182</b>. On the other hand, if it is determined in step S<b>205</b> that the read processing has not terminated with respect to all the chunks, the restoration program <b>152</b> adds 1 to the counter i (S<b>206</b>) and executes the processing in step S<b>203</b> and subsequent steps.</p>
<p id="p-0120" num="0120">(1-4) Advantageous Effect of this Embodiment</p>
<p id="p-0121" num="0121">When backing up the content, whether or not a chunk cut out from the content is a duplicate chunk is detected and a chunk(s) other than the duplicate chunk included in the content is additionally written to the container where the duplicate chunk is stored according to this embodiment as described above. As a result, it is possible to aggregate and store a larger number of chunks in one container with regard to a plurality of chunks constituting the content, thereby enabling enhancement of the backup performance and the restoration performance of the storage apparatus <b>100</b>.</p>
<p id="p-0122" num="0122">(2) Second Embodiment</p>
<p id="p-0123" num="0123">(2-1) Outline of this Embodiment</p>
<p id="p-0124" num="0124">Firstly, the outline of this embodiment will be explained. The first embodiment is designed so that if a duplicate chunk(s) is stored in a plurality of containers in step S<b>122</b> shown in <figref idref="DRAWINGS">FIG. 7</figref>, an additional write location of the backup target content cannot be selected and it is necessary to create a new container. However, in this embodiment, an additional write location of the backup target content can be selected even if a duplicate chunk(s) is stored in a plurality of containers.</p>
<p id="p-0125" num="0125">When the backup target content arrives, the backup program <b>150</b> measures the number of duplicate chunks in each container according to this embodiment. If the duplicate chunk(s) included in the content is stored in the plurality of containers, the backup program <b>150</b> compares the measured number of duplicate chunks in each container and selects a container with a large number of duplicate chunks as the additional content write location. As a result, it is possible to decide to which container the content should be additionally written when there are two or more selected containers in step S<b>108</b> shown in <figref idref="DRAWINGS">FIG. 6</figref> (selection of the container(s) as the additional write location(s)).</p>
<p id="p-0126" num="0126">(2-2) Configuration of Storage Apparatus</p>
<p id="p-0127" num="0127">Since the configuration of the storage apparatus <b>100</b> according to this embodiment is almost the same as that in the first embodiment, its detailed explanation has been omitted.</p>
<p id="p-0128" num="0128">For example, it is assumed as shown in <figref idref="DRAWINGS">FIG. 9</figref> that backup target content has arrived in the order of content f<b>1</b> (not shown) including chunk a, content g<b>1</b> (not shown) including chunk x, content f<b>2</b> (<b>760</b>), content g<b>2</b> (<b>770</b>), and content h (<b>780</b>). Firstly, a processing sequence for backing up the content from the content f<b>1</b> to the content g<b>2</b> will be explained.</p>
<p id="p-0129" num="0129">Assuming that the chunk a of the content f<b>1</b> is stored in a basic area <b>732</b> of the container CF and the chunk x of the content g<b>1</b> is stored in a basic area <b>742</b> of the container CG, the content f<b>2</b> (<b>760</b>) includes chunk a (<b>762</b>) and chunk b (<b>764</b>) and the chunk a (<b>762</b>) is a duplicate of the chunk a of the content f<b>1</b>, so that only the chunk b (<b>764</b>) is stored in an extended area <b>734</b> of the container CF. Furthermore, the content g<b>2</b> (<b>770</b>) includes chunk x (<b>772</b>) and chunk y (<b>774</b>) and the chunk x (<b>772</b>) is a duplicate of the chunk x of the content g<b>1</b>, so that only the chunk y (<b>774</b>) is stored in an extended area <b>744</b> of the container CG.</p>
<p id="p-0130" num="0130">Furthermore, a case where content h (<b>780</b>) including chunk a (<b>782</b>), chunk x (<b>784</b>), chunk b (<b>786</b>), and chunk u (<b>788</b>) has arrived as backup target content will be explained. Since the chunk a (<b>782</b>) and the chunk b (<b>786</b>) are duplicates of the chunk a and the chunk b stored in the container CF, they will not be backed up. Also, since the chunk x (<b>784</b>) is a duplicate of the chunk x stored in the container CG, it will not be backed up. Since the chunk u (<b>788</b>) is not a duplicate of any chunk stored in the container CF or the container CG, it is necessary to back up the chunk u (<b>788</b>).</p>
<p id="p-0131" num="0131">However, according to the first embodiment, if there are two or more containers for which the reference bit (r bit) in the measurement table <b>160</b> is 1, the container as the additional write location cannot be selected and a new container is created (see the container selection processing in <figref idref="DRAWINGS">FIG. 7</figref>). So, this embodiment is designed as described above so that if a duplicate chunk(s) included in the content is stored in a plurality of containers, the number of duplicate chunks as measured for each container (counter D) is compared and a container with a large number of duplicate chunks is selected as the additional content write location.</p>
<p id="p-0132" num="0132">Now, a container selection method using the counter D provided in a measurement table <b>162</b> used in this embodiment will be explained. According to this embodiment, the measurement table <b>162</b> in which the counter D is provided in addition to the reference bit (r bit) used in the first embodiment is utilized as shown in <figref idref="DRAWINGS">FIG. 10</figref>. This embodiment uses the reference bit (r bit) and the counter D, but may also use the aforementioned update bit (c bit) and valid/invalid bit (v bit) in combination with the reference bit (r bit) and the counter D.</p>
<p id="p-0133" num="0133"><figref idref="DRAWINGS">FIG. 10</figref> shows the measurement table <b>162</b> in a case where the chunk a (<b>782</b>), chunk x (<b>784</b>), and chunk b (<b>786</b>) included in the content h have arrived.</p>
<p id="p-0134" num="0134">Firstly, when the chunk a (<b>782</b>) of the content h arrives, the chunk a (<b>782</b>) is a duplicate of the chunk a of the container CF, so that TF for identifying a container index table corresponding to the container CF is stored in a tag <b>810</b>. Then, the reference bit (r bit) corresponding to the container index table TF is set to 1 (duplication exists) and 1 is added to the counter D.</p>
<p id="p-0135" num="0135">Next, when the chunk x (<b>784</b>) of the content h arrives, the chunk x (<b>784</b>) is a duplicate of the chunk x of the container CG, so that TG for identifying a container index table corresponding to the container CG is stored in the tag <b>810</b>. Then, the reference bit (r bit) corresponding to the container index table TG is set to 1 (duplication exists) and 1 is added to the counter D.</p>
<p id="p-0136" num="0136">Subsequently, when the chunk b (<b>786</b>) of the content h arrives, the chunk b (<b>786</b>) is a duplicate of the chunk b of the container CF, so that the reference bit (r bit) is set to 1 (duplication exists) and 1 is added to the counter D. Actually, the reference bit corresponding to the container index table TF became 1 when the chunk a (<b>782</b>) arrived, so that no change is made. Also, the counter D was set to 1 when the chunk a (<b>782</b>) arrived, so that a value (<b>2</b>) obtained by further adding 1 to the counter D is set.</p>
<p id="p-0137" num="0137">The chunk u (<b>788</b>) of the content h which arrives later is not a duplicate of either any chunk of the container CF or any chunk of the container CG, so neither the reference bit (r bit) nor the counter D will be updated. Specifically speaking, the reference bit (r bit) is set to both the container CF and the container CG, indicating that duplication exists; and the counter D of the container CF is set to 2 and the counter D of the container CG is set to 1. In this case, a container with a larger number of the counter D is selected as a storage location of the chunk u. As a result, when backing up the content h, the chunks of the content h can be aggregated and stored by selecting the container CF with a larger number of duplicate chunks.</p>
<p id="p-0138" num="0138">(2-3) Backup Processing</p>
<p id="p-0139" num="0139">Next, the backup processing executed by the backup program <b>150</b> according to this embodiment will be explained. In the following explanation, processing different from the backup processing according to the first embodiment will be explained particularly in detail and the detailed explanation of the same processing has been omitted. In this embodiment, particularly, the container selection processing in step S<b>108</b> in <figref idref="DRAWINGS">FIG. 5</figref> is extremely different from the container selection processing according to the first embodiment. The container selection processing will be explained below in detail.</p>
<p id="p-0140" num="0140">As shown in <figref idref="DRAWINGS">FIG. 11</figref>, the backup program <b>150</b> searches for the container index table <b>110</b> for which the reference bit (r bit) in the measurement table <b>162</b> is 1 (S<b>301</b>). Subsequently, the backup program <b>150</b> judges whether or not there is one container index table <b>110</b> obtained as a result of the search in step S<b>301</b> (S<b>302</b>).</p>
<p id="p-0141" num="0141">If it is determined in step S<b>302</b> that there is one applicable container index table <b>110</b>, the backup program <b>150</b> selects that container index table <b>110</b> (S<b>305</b>) and terminates the processing.</p>
<p id="p-0142" num="0142">On the other hand, if it is determined in step S<b>302</b> that the number of applicable container index table <b>110</b> is not one, the backup program <b>150</b> searches for the container index table <b>110</b> for which a maximum value of the counter D in the measurement table <b>162</b> is measured (S<b>303</b>). The counter D of the measurement table <b>162</b> indicates a total number of duplicate chunks in the container as described above. Therefore, it is possible to search for the container index table <b>110</b>, for which the maximum value of the counter D is measured, in step S<b>303</b> and identify the container index table <b>110</b> corresponding to the container with a large number of duplicate chunks.</p>
<p id="p-0143" num="0143">Subsequently, the backup program <b>150</b> judges whether or not there is one container index table <b>110</b> obtained as a result of the search in step S<b>303</b> (S<b>304</b>). If it is determined in step S<b>304</b> that there is one applicable container index table <b>110</b>, the backup program <b>150</b> selects that container index table <b>110</b> (S<b>305</b>) and terminates the processing. On the other hand, if it is determined in step S<b>304</b> that the number of applicable container index table <b>110</b> is not one, the backup program <b>150</b> does not select the container index table <b>110</b> (S<b>306</b>) and terminates the processing.</p>
<p id="p-0144" num="0144">When there is one container storing a duplicate chunk(s) during the container selection processing in <figref idref="DRAWINGS">FIG. 11</figref>, the processing for selecting the container index table <b>112</b> corresponding to the container storing the same chunk as the duplicate chunk is the same as the processing in the first embodiment. However, when there are two or more containers storing a duplicate chunk(s), the container index table <b>112</b> corresponding to a container storing a larger number of duplicate chunks is selected. As a result, when there are two or more containers storing a duplicate chunk(s), the container index table <b>112</b> corresponding to a container storing a larger number of duplicate chunks can be selected. For example, referring to <figref idref="DRAWINGS">FIG. 9</figref>, the container index table TF (<b>710</b>) and the container index table TG (<b>720</b>) correspond to the container CF (<b>730</b>) and the container CG (<b>740</b>), respectively; and, in this example, the container index table TF (<b>710</b>) is selected.</p>
<p id="p-0145" num="0145">Furthermore, in this embodiment, when there are two or more containers for which the number of duplicate chunks (counter D) is a maximum value, the backup program <b>150</b> checks if the container <b>130</b> is full or not, and then stores the chunk in the basic area of the container <b>130</b> or creates a new container <b>130</b> and stores the chunk in that container <b>130</b> in the same manner as the normal chunk write processing.</p>
<p id="p-0146" num="0146">(2-4) Advantageous Effect of this Embodiment</p>
<p id="p-0147" num="0147">If a duplicate chunk(s) included in the content is stored in a plurality of containers, the measured number of duplicate chunks is compared with respect to each container and a container with a large number of duplicate chunks is selected as an additional content write location according to this embodiment as described above. As a result, it is possible to aggregate and store a larger number of chunks in one container with regard to a plurality of chunks constituting the content, thereby enabling enhancement of the backup performance and the restoration performance of the storage apparatus <b>100</b>.</p>
<p id="p-0148" num="0148">(3) Third Embodiment</p>
<p id="p-0149" num="0149">(3-1) Outline of this Embodiment</p>
<p id="p-0150" num="0150">Firstly, the outline of this embodiment will be explained. The second embodiment is configured so that when there are two or more containers, for which the number of duplicate chunks (counter D) is a maximum value, during the container selection processing shown in <figref idref="DRAWINGS">FIG. 11</figref>, the additional write location of the backup target content cannot be selected and it is necessary to create a new container. However, according to this embodiment, a container can be selected as the additional write location of the backup target content even when there are two or more containers, for which the number of duplicate chunks is a maximum value.</p>
<p id="p-0151" num="0151">When the backup target content arrives, the backup program <b>150</b> measures the number of duplicate chunks in each container according to this embodiment in the same manner as in the second embodiment. If a duplicate chunk(s) included in the content is stored in a plurality of containers, the backup program <b>150</b> compares the measured number of duplicate chunks in each container and selects a container with a large number of duplicate chunks as an additional content write location. Furthermore, in this embodiment, if there are two or more containers with a large number of duplicate chunks (containers for which the maximum value of the counter D is measured), a container to be rolled out by the aforementioned LRU method is selected as the additional content write location.</p>
<p id="p-0152" num="0152">(3-2) Configuration of Storage Apparatus</p>
<p id="p-0153" num="0153">Since the configuration of the storage apparatus <b>100</b> according to this embodiment is almost the same as that in the first and second embodiments, its detailed explanation has been omitted.</p>
<p id="p-0154" num="0154">For example, it is assumed as shown in <figref idref="DRAWINGS">FIG. 12</figref> that backup target content has arrived in the order of content f<b>1</b> (not shown) including chunk a, content g<b>1</b> (not shown) including chunk x, content f<b>2</b> (<b>1060</b>), content g<b>2</b> (<b>1070</b>), and content h (<b>1080</b>). Firstly, a processing sequence for backing up the content from the content f<b>1</b> to the content g<b>2</b> will be explained.</p>
<p id="p-0155" num="0155">Assuming that the chunk a of the content f<b>1</b> is stored in the basic area <b>1032</b> of the container CF and the chunk x of the content g<b>1</b> is stored in the basic area <b>1042</b> of the container CG, the content f<b>2</b> (<b>1060</b>) includes chunk a (<b>1062</b>) and chunk b (<b>1064</b>) and the chunk a (<b>1062</b>) is a duplicate of the chunk a of the content f<b>1</b>, so that only the chunk b (<b>1064</b>) is stored in the extended area <b>1034</b> of the container CF. Furthermore, the content g<b>2</b> (<b>1070</b>) includes chunk x (<b>1072</b>) and chunk y (<b>1074</b>) and the chunk x (<b>1072</b>) is a duplicate of the chunk x of the content g<b>1</b>, so that only the chunk y (<b>1074</b>) is stored in the extended area <b>1044</b> of the container CG.</p>
<p id="p-0156" num="0156">Furthermore, a case where content h (<b>1080</b>) including chunk x (<b>1082</b>), chunk a (<b>1084</b>), chunk y (<b>1086</b>), chunk b (<b>1088</b>), and chunk u (<b>1090</b>) has arrived as backup target content will be explained. Since the chunk a (<b>1084</b>) and the chunk b (<b>1088</b>) are duplicates of the chunk a and the chunk b stored in the container CF, they will not be backed up. Also, since the chunk x (<b>1082</b>) and the chunk y (<b>1086</b>) are duplicates of the chunk x and the chunk y stored in the container CG, they will not be backed up. Since the chunk u (<b>1090</b>) is not a duplicate of any chunk stored in the container CF or the container CG, it is necessary to back up the chunk u (<b>1090</b>).</p>
<p id="p-0157" num="0157">However, in the second embodiment, when there are two or more containers, for which the maximum value of the counter D in the measurement table <b>162</b> is measured, a container as the additional write location cannot be selected and a new container is created (see the container selection processing in <figref idref="DRAWINGS">FIG. 11</figref>). So, in this embodiment, when there are two or more containers with a large number of duplicate chunks included in the content (containers for which the maximum value of the counter D is measured), a container to be rolled out by the aforementioned LRU method is selected as the additional content write location. Which container should be rolled out can be determined according to the order in which the chunks of the content arrive.</p>
<p id="p-0158" num="0158">Now, the container selection method using the measurement table <b>164</b> employed in this embodiment will be explained. As shown in <figref idref="DRAWINGS">FIG. 13</figref>, the measurement table <b>164</b> in which the reference bit (r bit) and the counter D are provided are used in this embodiment in the same manner as in the second embodiment. Furthermore, in this embodiment, 8-bit reference bits (r bits) (r<b>1</b> bit to r<b>8</b> bit) are provided and a container to be rolled out is selected according to the 8-bit reference bits. Specifically speaking, a container regarding which values of the 8-bit reference bits (r bits) indicate a small value can be determined by the aging method, one of methods for implementing the LRU method, to be a container to which reference was made most frequently in the past, and which should be rolled out first.</p>
<p id="p-0159" num="0159">For example, <figref idref="DRAWINGS">FIG. 13</figref> shows the measurement table <b>164</b> when the chunk x (<b>1082</b>), the chunk a (<b>1084</b>), and the chunk b (<b>1088</b>) included in the content h have arrived.</p>
<p id="p-0160" num="0160">Firstly, when the chunk x (<b>1082</b>) of the content h arrives, the chunk x (<b>1082</b>) is a duplicate of the chunk x of the container CG, so that TG for identifying a container index table corresponding to the container CG is stored in a tag <b>1110</b>. Then, the reference bit, r<b>1</b> bit, corresponding to the container index table TG is set to 1 (duplication exists) and 1 is added to the counter D.</p>
<p id="p-0161" num="0161">Next, when the chunk a (<b>1084</b>) of the content h arrives, the reference bit of the container index table TG which was set when the chunk x (<b>1082</b>) arrived is shifted to the right. Since the chunk a (<b>1084</b>) is a duplicate of the chunk a of the container CF, TF for identifying a container index table corresponding to the container CF is stored in the tag <b>1110</b>. Then, the reference bit, r<b>1</b> bit, corresponding to the container index table TF is set to 1 (duplication exists) and 1 is added to the counter D.</p>
<p id="p-0162" num="0162">Subsequently, when the chunk y (<b>1086</b>) of the content h arrives, the reference bit of the container index table TG, which was set when the chunk x (<b>1082</b>) arrived earlier, and the reference bit of the container index table TF, which was set when the chunk a (<b>1084</b>) arrived earlier, are shifted to the right. Since the chunk y (<b>1086</b>) is a duplicate of the chunk y of the container CG, the reference bit, r<b>1</b> bit, is set to 1 (duplication exists) and 2 is set to the counter D by adding 1.</p>
<p id="p-0163" num="0163">Subsequently, when the chunk b (<b>1088</b>) of the content h arrives, the reference bits of the container index table TF and the container index table TG are shifted to the right. Since the chunk b (<b>1088</b>) is a duplicate of the chunk b of the container CF, the reference bit, r<b>1</b> bit, is set to 1 (duplication exists) and 2 is set to the counter D by adding 1.</p>
<p id="p-0164" num="0164">Then, when the chunk u (<b>1090</b>) arrives, the reference bits of the container index table TF and the container index table TG are shifted to the right. Since the chunk u (<b>1090</b>) is not a duplicate of any chunk in the container CF or any chunk in the container CG, neither the reference bit, r1 bit, nor the counter D will be updated. Since both the counter D of the container CF and the counter D of the container CG are set to 2, a container for storing the chunk u cannot be selected based on the number of the counter D.</p>
<p id="p-0165" num="0165">So, in this embodiment, the container index table <b>110</b> corresponding to a container to which reference was made most frequently in the past can be selected by selecting the container index table <b>110</b> for which a minimum value of the 8-bit reference bits (r bits) is measured. Selecting the container index table <b>110</b> to which reference was made most frequently in the past means selecting the container index table <b>110</b> to be rolled out first. As a result, efficient backup processing can be executed by additionally writing nonduplicate data of the backup target content to the container index table <b>110</b> to be rolled out and reducing wasteful roll-in/roll-out.</p>
<p id="p-0166" num="0166">(3-3) Backup Processing</p>
<p id="p-0167" num="0167">Next, the backup processing executed by the backup program <b>150</b> according to this embodiment will be explained. In the following explanation, processing different from the backup processing according to the first and second embodiments will be explained particularly in detail and the detailed explanation of the same processing has been omitted. In this embodiment, particularly, the container selection processing in step S<b>108</b> in <figref idref="DRAWINGS">FIG. 5</figref> is extremely different from the container selection processing according to the first embodiment. The container selection processing will be explained below in detail.</p>
<p id="p-0168" num="0168">As shown in <figref idref="DRAWINGS">FIG. 14</figref>, the backup program <b>150</b> searches for the container index table <b>110</b> for which a maximum value of the counter D in the measurement table <b>164</b> is measured (S<b>401</b>). Subsequently, the backup program <b>150</b> judges whether or not there is one container index table <b>110</b> obtained as a result of the search in step S<b>401</b> (S<b>402</b>).</p>
<p id="p-0169" num="0169">If it is determined in step S<b>402</b> that there is one applicable container index table <b>110</b>, the backup program <b>150</b> selects that container index table <b>110</b> (S<b>403</b>) and terminates the processing.</p>
<p id="p-0170" num="0170">On the other hand, if it is determined in step S<b>402</b> that the number of applicable container index table <b>110</b> is not one, the backup program <b>150</b> searches for the container index table <b>110</b> for which a maximum value of the reference bit (r bit) in the measurement table <b>164</b> is measured (S<b>404</b>). In this embodiment, the reference bit (r bit) manages the order in which the chunks arrive as described above. Therefore, the container index table <b>110</b> to be rolled out first can be identified by selecting the container index table <b>110</b> corresponding to a container to which the chunk that has arrived early referred.</p>
<p id="p-0171" num="0171">Subsequently, the backup program <b>150</b> judges whether or not there is one container index table <b>110</b> obtained as a result of the search in step S<b>404</b> (S<b>406</b>). If it is determined in step S<b>406</b> that there is one applicable container index table <b>110</b>, the backup program <b>150</b> selects that container index table <b>110</b> (S<b>403</b>) and terminates the processing. On the other hand, if it is determined in step S<b>404</b> that the number of applicable container index table <b>110</b> is not one, the backup program <b>150</b> does not select the container index table <b>110</b> (S<b>407</b>) and terminates the processing.</p>
<p id="p-0172" num="0172">When there are two or more containers storing duplicate chunks during the container selection processing in <figref idref="DRAWINGS">FIG. 14</figref>, the processing for selecting the container index table <b>110</b> corresponding to a container storing a large number of duplicate chunks is the same as the processing in the second embodiment. However, when there are two or more containers for which the maximum value of the number of duplicate chunks is measured, the container index table <b>110</b> corresponding to the container <b>130</b> storing the content can be selected according to the order in which the chunks arrive, that is, according to the reference time of the container index table <b>110</b>.</p>
<p id="p-0173" num="0173">Incidentally, in a case of the configuration where the reference bit (r bit) is shifted to the right after two chunks arrive, two or more container index tables with the minimum value of the reference bit (r bit) may exist, so that the container index table <b>110</b> cannot sometimes be selected. In this case, the backup program <b>150</b> checks if the container <b>130</b> is full or not, and then stores the chunk in the basic area of the container <b>130</b> or creates a new container <b>130</b> and stores the chunk in that container <b>130</b> in the same manner as the normal chunk write processing.</p>
<p id="p-0174" num="0174">(3-4) Advantageous Effect of this Embodiment</p>
<p id="p-0175" num="0175">If a duplicate chunk(s) included in the content is stored in a plurality of containers, the measured number of duplicate chunks is compared with respect to each container and a container with a large number of duplicate chunks is selected as an additional content write location according to this embodiment as described above. Furthermore, if there are two or more containers with a large number of duplicate chunks, a container(s) to be rolled out by the aforementioned LRU method is selected as the additional content write location. As a result, it is possible to aggregate and store a larger number of chunks in one container with regard to a plurality of chunks constituting the content, thereby enabling enhancement of the backup performance and the restoration performance of the storage apparatus <b>100</b>.</p>
<p id="p-0176" num="0176">(4) Fourth Embodiment</p>
<p id="p-0177" num="0177">(4-1) Outline of this Embodiment</p>
<p id="p-0178" num="0178">Firstly, the outline of this embodiment will be explained. The difference between this embodiment and the first embodiment is that counter D for measuring the number of duplicate chunks for each container is provided instead of the three kinds of bits, that is, the reference bit (r bit), the update bit (c bit) and the valid/invalid bit (the v bit), in the measurement table <b>160</b> shown in <figref idref="DRAWINGS">FIG. 6</figref> according to this embodiment. The counter D is a counter for measuring the number of duplicate chunks for each container when chunks included in the backup target content arrive sequentially. Specifically speaking, when the backup target content has arrived, the backup program <b>150</b> measures the number of duplicate chunks for each container. If a duplicate chunk(s) included in the content is stored in a plurality of containers, the backup program <b>150</b> compares the measured number of duplicate chunks in each container and selects a container with a large number of duplicate chunks as an additional content write location. As a result, if there are two or more selected containers in step S<b>108</b> shown in <figref idref="DRAWINGS">FIG. 6</figref> (selection of container as the additional write location), in which container the content should be additionally written can be determined</p>
<p id="p-0179" num="0179">(4-2) Configuration of Storage Apparatus</p>
<p id="p-0180" num="0180">Since the configuration of the storage apparatus <b>100</b> according to this embodiment is almost the same as that in the first embodiment, its detailed explanation has been omitted.</p>
<p id="p-0181" num="0181">For example, when the content arrives in the order of content f<b>1</b>, content g<b>1</b>, and content f<b>2</b> as shown in <figref idref="DRAWINGS">FIG. 15</figref>, chunk a (<b>1562</b>) of the content f<b>1</b> is stored in a basic area (<b>1532</b>) of container CF and chunk x (<b>1572</b>) of the content g<b>1</b> is stored in a basic area (<b>1542</b>) of container CG. If an interval between the arrival of the content f<b>1</b> and the arrival of the content g<b>1</b> is short, the chunk x may possibly be stored in the basic area of the container CF. However, for ease of explanation, the following explanation will be given, assuming that the chunk x is stored in the container CG which is different from the container CF where the chunk a is stored.</p>
<p id="p-0182" num="0182">If chunk a (<b>1582</b>) of the content f<b>2</b> arrives after the arrival of chunks of the content f<b>1</b> and the content g<b>1</b>, the chunk a (<b>1582</b>) is a duplicate chunk, so that it will not be stored in the containers. Then, 1 is added to the counter D (container CF) because the content f<b>1</b> includes the chunk which is a duplicate of the chunk of the container CF. The counter D (container CF) herein used means the number of chunks which are duplicates of chunks stored in the container CF.</p>
<p id="p-0183" num="0183">Subsequently, when chunk b (<b>1584</b>) of the content f<b>2</b> arrives, the chunk b (<b>1584</b>) is not a duplicate chunk, so that it is necessary to store the chunk b (<b>1584</b>) in a container. When this happens, a container to store the chunk b is selected by referring to the counter D. Specifically speaking, when the container CF and the container CG exist, the counter D of the container CF is 1 and the counter D of the container CG is 0, so that the container CF is selected as the container to store the chunk b as a result of measurement of the maximum value of the counter D.</p>
<p id="p-0184" num="0184">When chunk a (<b>1560</b>) of the content f<b>1</b> arrives as shown in the measurement table <b>160</b> in <figref idref="DRAWINGS">FIG. 16</figref>, the chunk a (<b>1560</b>) is not a duplicate chunk, so that the counter D of the content CF is set to 0. Then, when chunk x (<b>1572</b>) of the content g<b>1</b> arrives, the chunk x (<b>1572</b>) is not a duplicate chunk, so that the counter D of the content CG is set to 0. As a matter of course, the counter D of the content CF remains to be 0. Subsequently, when chunk a (<b>1580</b>) of the content f<b>2</b> arrives, the chunk a (<b>1580</b>) is a duplicate of the chunk a (<b>1562</b>) of the content f<b>1</b>, so that it will not be stored in the container CF, but the counter D of the container CF is set to 1. Furthermore, when the chunk b (<b>1584</b>) of the content f<b>2</b> arrives, the chunk b (<b>1584</b>) is not a duplicate chunk, so that both the counter D of the container CF and the counter D of the container CG are set to 0. Then, the backup program <b>150</b> selects the container CF, for which the maximum value of the counter D is measured, and stores the chunk in the container CF.</p>
<p id="p-0185" num="0185">(4-2) Details of Backup Processing</p>
<p id="p-0186" num="0186">The details of backup processing according to this embodiment will be explained with reference to <figref idref="DRAWINGS">FIG. 17</figref>. As shown in <figref idref="DRAWINGS">FIG. 17</figref>, the backup program <b>150</b> decomposes the content, which is a backup target, into chunks Si (i=1, 2, n) (S<b>501</b>).</p>
<p id="p-0187" num="0187">Then, the backup program initializes the counter i used for loop processing and the aforementioned counter D (i=0, D=0) (S<b>502</b>) and executes the duplication judgment on the chunk Si (S<b>503</b>). Since the duplication judgment processing in step S<b>503</b> is the same as the duplication judgment processing in step S<b>104</b> in <figref idref="DRAWINGS">FIG. 5</figref>, its detained explanation has been omitted.</p>
<p id="p-0188" num="0188">If it is determined as a result of the duplication judgment processing in S<b>503</b> that the chunk Si is a duplicate chunk (S<b>504</b>), the backup program <b>150</b> adds 1 to the counter D of the container, which stores a chunk identical to the duplicate chunk (S<b>505</b>), adds 1 to the counter i, and repeats the duplication judgment processing in step S<b>503</b> on the next chunk. On the other hand, if it is determined that the chunk Si is not a duplicate chunk (S<b>504</b>), the backup program <b>150</b> executes processing in step S<b>507</b>.</p>
<p id="p-0189" num="0189">If it is determined in step S<b>504</b> that the chunk Si is not a duplicate chunk, the backup program <b>150</b> judges whether or not m pieces of chunks have accumulated in the write buffer (S<b>507</b>). The backup program <b>150</b> repeats the chunk duplication judgment processing in step S<b>504</b> until m pieces (for example, m=10) of chunks accumulate in the write buffer. Alternatively, the backup program <b>150</b> may repeats the chunk duplication judgment processing in step S<b>504</b> on all the chunks included in the content.</p>
<p id="p-0190" num="0190">If it is determined in step S<b>507</b> that m pieces of chunks have accumulated in the write buffer, the backup program <b>150</b> judges whether all values of the counter D are 0 or not (S<b>508</b>). The case where it is determined in step S<b>508</b> that all values of the counter D are 0 is a case where there is no duplicate chunk in m pieces of chunks</p>
<p id="p-0191" num="0191">If it is determined in step S<b>508</b> that all values of the counter D are 0, the backup program <b>150</b> creates a new container (CG) (S<b>512</b>) and writes the chunks in the write buffer to the container (CG) (S<b>513</b>). For example, when the content f<b>1</b> shown in <figref idref="DRAWINGS">FIG. 9</figref> arrives or when the content g<b>1</b> arrives, the processing in step S<b>512</b> and step S<b>513</b> is executed.</p>
<p id="p-0192" num="0192">On the other hand, if it is determined in step S<b>508</b> that all values of the counter D are not 0, the backup program <b>150</b> selects the container (CF) for which the maximum value of the counter D is measured (S<b>509</b>). Then, the backup program <b>150</b> judges whether data can be additionally written to the container (CF) selected in step S<b>509</b> (S<b>510</b>). If data can be additionally written to the container (CF), the backup program <b>150</b> writes the chunks in the write buffer to the container (CF) (S<b>511</b>). If it is determined in step S<b>510</b> that a new chunk cannot be additionally written to the container (CF) selected in step S<b>509</b>, the backup program <b>150</b> creates a new container (CG) (S<b>512</b>). For example, when the content f<b>2</b> shown in <figref idref="DRAWINGS">FIG. 9</figref> arrives, the processing from step S<b>509</b> to step S<b>511</b> is executed.</p>
<p id="p-0193" num="0193">Then, the backup program <b>150</b> judges whether or not the duplication judgment processing and the write processing have terminated with respect to all the chunks (S<b>514</b>). If it is determined that the duplication judgment processing and the write processing have terminated with respect to all the chunks, the backup program <b>150</b> terminates the content backup processing. On the other hand, if it is determined in step S<b>514</b> that the duplication judgment processing and the write processing have not terminated with respect to all the chunks, the backup program <b>150</b> adds 1 to the counter i (S<b>506</b>) and repeats the processing in step S<b>503</b> and subsequent steps.</p>
<p id="p-0194" num="0194">(4-3) Advantageous Effect of this Embodiment</p>
<p id="p-0195" num="0195">If a duplicate chunk(s) included in the content is stored in a plurality of containers, the measured number of duplicate chunks is compared with respect to each container and a container with a large number of duplicate chunks is selected as an additional content write location according to this embodiment as described above. As a result, it is possible to aggregate and store a larger number of chunks in one container with regard to a plurality of chunks constituting the content, thereby enabling enhancement of the backup performance and the restoration performance of the storage apparatus <b>100</b>.</p>
<p id="p-0196" num="0196">(5) Other Embodiments</p>
<p id="p-0197" num="0197">The aforementioned embodiments have described the case where the processor <b>102</b> is used as a control unit for controlling the entire processing relating to various functions according to such embodiments; however, the present invention is not limited to those embodiments, and hardware and/or software for executing the processing as such control unit may be provided separately from the processor <b>102</b>. Even if such hardware and/or software are provided, the same advantageous effects as those of the aforementioned embodiments can be obtained.</p>
<p id="p-0198" num="0198">Furthermore, for example, the respective steps of the processing by the storage apparatus <b>100</b> or other devices in this specification do not necessarily have to be processed chronologically in the order described in the relevant flowchart. In other words, the respective steps in the processing by the storage apparatus <b>100</b> or other devices may be executed in parallel even if they are different processing.</p>
<p id="p-0199" num="0199">Furthermore, hardware such as a CPU, ROM, and RAM contained in, for example, the storage apparatus <b>100</b> may be created as a computer program for fulfilling functions equal to those of each component of the aforementioned storage apparatus <b>100</b> and other devices. Furthermore, storage media in which such a computer program is stored is provided.</p>
<p id="h-0012" num="0000">Industrial Applicability</p>
<p id="p-0200" num="0200">The present invention can be applied to a wide variety of storage apparatuses for deduplicating chunks of the content and storing the chunks in containers.</p>
<p id="h-0013" num="0000">Reference Signs List</p>
<p id="p-0201" num="0201"><b>100</b> Storage apparatus</p>
<p id="p-0202" num="0202"><b>102</b> Processor</p>
<p id="p-0203" num="0203"><b>104</b> Memory</p>
<p id="p-0204" num="0204"><b>106</b> Disk</p>
<p id="p-0205" num="0205"><b>108</b> Network interface</p>
<p id="p-0206" num="0206"><b>110</b> Container index table</p>
<p id="p-0207" num="0207"><b>150</b> Backup program</p>
<p id="p-0208" num="0208"><b>152</b> Restoration program</p>
<p id="p-0209" num="0209"><b>160</b>, <b>162</b>, <b>164</b> Measurement tables</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>The invention claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A storage apparatus connected via a network to a host system issuing a content write request, the storage apparatus comprising:
<claim-text>a storage unit providing one or more containers composed of a specified storage area; and</claim-text>
<claim-text>a back up unit storing the content in the container in accordance with a backup request from the host system;</claim-text>
<claim-text>wherein the backup unit cuts out the content into one or more chunks, detects a duplicate chunk, which is a duplicate of a chunk stored in the container, from the cutout chunks, and additionally writes the chunk, other than the duplicate chunk, to the container where the duplicate chunk is stored;</claim-text>
<claim-text>wherein if the content includes a plurality of duplicate chunks and the plurality of duplicate chunks are stored in two or more containers, the backup unit stores the chunk other than the duplicate chunk in the container which stores a large number of duplicate chunks.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The storage apparatus according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the storage area of the container is constituted from a basic area and an extended area;
<claim-text>the duplicate chunk is stored in the basic area; and</claim-text>
<claim-text>the chunk other than the duplicate chunk is stored in the extended area.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The storage apparatus according to <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the storage unit stores a container index table corresponding to the basic area and the extended area of the container;
<claim-text>the container index table stores management information of the chunk stored in the container; and</claim-text>
<claim-text>the backup unit detects the duplicate chunk based on the management information of the chunk stored in the container index table.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The storage apparatus according to <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein when storing the chunk in the container, the backup unit stores the management information of the chunk in the container index table corresponding to the container.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The storage apparatus according to <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the container index table stores chunk identification information for identifying the chunk, positional information of the chunk in the container, and management information including a chunk length of the chunk.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The storage apparatus according to <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the chunk identification information for identifying the chunk is a message digest of the chunk.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The storage apparatus according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein if the content includes the plurality of duplicate chunks and the plurality of duplicate chunks are stored in the two or more containers, the backup unit detects reference timing of the duplicate chunk stored in the container with respect to each container and stores the chunk other than the duplicate chunk in the container regarding which the reference timing is early.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The storage apparatus according to <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the backup unit manages reference timing of the container index table to which reference is made when detecting the duplicate chunk; and if the content includes the plurality of duplicate chunks and the plurality of duplicate chunks are stored in the two or more containers, the backup unit detects the reference timing of the container index table corresponding to the container with respect to each container index table and selects the container index table regarding which the reference timing is early.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The storage apparatus according to <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the backup unit: manages a reference bit for referring to the container and the container index table and an update bit for updating the container and the container index table with respect to each chunk included in the content;
<claim-text>sets a flag of the reference bit if the chunk is the duplicate chunk; and</claim-text>
<claim-text>sets a flag of the update bit if the chunk is not the duplicate chunk.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. An additional data writing method using a storage apparatus connected via a network to a host system issuing a content write request, the storage apparatus including a storage unit providing one or more containers composed of a specified storage area, and a back up unit storing the content in the container in accordance with a backup request from the host system,
<claim-text>the additional data writing method comprising:</claim-text>
<claim-text>a step executed by the backup unit cutting out the content into one or more chunks;</claim-text>
<claim-text>a step executed by the backup unit detecting a duplicate chunk, which is a duplicate of a chunk stored in the container, from the cutout chunks; and</claim-text>
<claim-text>a step executed by the backup unit additionally writing the chunk, other than the duplicate chunk, to the container where the duplicate chunk is stored; and</claim-text>
<claim-text>a step executed, if the content includes a plurality of duplicate chunks and the plurality of duplicate chunks are stored in two or more containers, by the backup unit storing the chunk other than the duplicate chunk in the container which stores a large number of duplicate chunks.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The additional data writing method according to <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the storage area of the container is constituted from a basic area and an extended area;
<claim-text>the duplicate chunk is stored in the basic area; and</claim-text>
<claim-text>the chunk other than the duplicate chunk is stored in the extended area.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The additional data writing method according to <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the storage unit stores a container index table corresponding to the basic area and the extended area of the container; and
<claim-text>the container index table stores management information of the chunk stored in the container; and</claim-text>
<claim-text>wherein the additional data writing method further comprises a fourth step executed by the backup unit, in the detecting a duplicate chunk step, detecting the duplicate chunk based on the management information of the chunk stored in the container index table.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The additional data writing method according to <claim-ref idref="CLM-00012">claim 12</claim-ref>, further comprising a step executed, when storing the chunk in the container, by the backup unit storing the management information of the chunk in the container index table corresponding to the container.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The additional data writing method according to <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the container index table stores chunk identification information for identifying the chunk, positional information of the chunk in the container, and management information including a chunk length of the chunk.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The additional data writing method according to <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the chunk identification information for identifying the chunk is a message digest of the chunk.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The additional data writing method according to <claim-ref idref="CLM-00010">claim 10</claim-ref>, further comprising a step executed, if the content includes the plurality of duplicate chunks and the plurality of duplicate chunks are stored in the two or more containers, by the backup unit detecting reference timing of the duplicate chunk stored in the container with respect to each container and storing the chunk other than the duplicate chunk in the container regarding which the reference timing is early.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The additional data writing method according to <claim-ref idref="CLM-00016">claim 16</claim-ref>, further comprising a step executed by the backup unit: managing reference timing of the container index table to which reference is made when detecting the duplicate chunk; and detecting the reference timing of the container index table corresponding to the container with respect to each container index table and selecting the container index table regarding which the reference timing is early if the content includes the plurality of duplicate chunks and the plurality of duplicate chunks are stored in the two or more containers.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The additional data writing method according to <claim-ref idref="CLM-00012">claim 12</claim-ref>, further comprising a step executed by the backup unit: managing a reference bit for referring to the container and the container index table and an update bit for updating the container and the container index table with respect to each chunk included in the content;
<claim-text>setting a flag of the reference bit if the chunk is the duplicate chunk; and</claim-text>
<claim-text>setting a flag of the update bit if the chunk is not the duplicate chunk. </claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
