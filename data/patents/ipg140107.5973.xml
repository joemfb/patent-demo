<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627086-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627086</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>11577084</doc-number>
<date>20050907</date>
</document-id>
</application-reference>
<us-application-series-code>11</us-application-series-code>
<priority-claims>
<priority-claim sequence="01" kind="regional">
<country>EP</country>
<doc-number>04388069</doc-number>
<date>20041011</date>
</priority-claim>
</priority-claims>
<us-term-of-grant>
<us-term-extension>1321</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20130101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>21</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>713176</main-classification>
<further-classification>726  4</further-classification>
<further-classification>726  9</further-classification>
<further-classification>713171</further-classification>
<further-classification>713179</further-classification>
<further-classification>380251</further-classification>
<further-classification>380270</further-classification>
<further-classification>455411</further-classification>
</classification-national>
<invention-title id="d2e71">Secure loading and storing of data in a data processing device</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5893119</doc-number>
<kind>A</kind>
<name>Squibb</name>
<date>19990400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>  1  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5970143</doc-number>
<kind>A</kind>
<name>Schneier et al.</name>
<date>19991000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713181</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6026293</doc-number>
<kind>A</kind>
<name>Osborn</name>
<date>20000200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6367012</doc-number>
<kind>B1</kind>
<name>Atkinson et al.</name>
<date>20020400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713176</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>6401206</doc-number>
<kind>B1</kind>
<name>Khan et al.</name>
<date>20020600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713176</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>6694434</doc-number>
<kind>B1</kind>
<name>McGee et al.</name>
<date>20040200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713189</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>6694436</doc-number>
<kind>B1</kind>
<name>Audebert</name>
<date>20040200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>726  9</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>7116782</doc-number>
<kind>B2</kind>
<name>Jackson et al.</name>
<date>20061000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>380251</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>7124408</doc-number>
<kind>B1</kind>
<name>Parthasarathy et al.</name>
<date>20061000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717170</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>7461249</doc-number>
<kind>B1</kind>
<name>Pearson et al.</name>
<date>20081200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713156</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>7565419</doc-number>
<kind>B1</kind>
<name>Kwiatkowski et al.</name>
<date>20090700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709223</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>8156333</doc-number>
<kind>B2</kind>
<name>Schneider</name>
<date>20120400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713168</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2002/0002703</doc-number>
<kind>A1</kind>
<name>Baentsch et al.</name>
<date>20020100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>717 11</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2003/0079123</doc-number>
<kind>A1</kind>
<name>Mas Ribes</name>
<date>20030400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713156</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>2003/0105968</doc-number>
<kind>A1</kind>
<name>Cheston et al.</name>
<date>20030600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713191</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>2003/0126443</doc-number>
<kind>A1</kind>
<name>Wakao</name>
<date>20030700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713176</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00017">
<document-id>
<country>US</country>
<doc-number>2003/0172089</doc-number>
<kind>A1</kind>
<name>Douceur et al.</name>
<date>20030900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707200</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00018">
<document-id>
<country>US</country>
<doc-number>2003/0210789</doc-number>
<kind>A1</kind>
<name>Farnham et al.</name>
<date>20031100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>380270</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00019">
<document-id>
<country>US</country>
<doc-number>2004/0025010</doc-number>
<kind>A1</kind>
<name>Azema et al.</name>
<date>20040200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713156</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00020">
<document-id>
<country>US</country>
<doc-number>2004/0068652</doc-number>
<kind>A1</kind>
<name>Carpentier et al.</name>
<date>20040400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713168</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00021">
<document-id>
<country>US</country>
<doc-number>2004/0117623</doc-number>
<kind>A1</kind>
<name>Kalogridis et al.</name>
<date>20040600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713165</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00022">
<document-id>
<country>US</country>
<doc-number>2005/0021973</doc-number>
<kind>A1</kind>
<name>Chen et al.</name>
<date>20050100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713176</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00023">
<document-id>
<country>US</country>
<doc-number>2005/0079868</doc-number>
<kind>A1</kind>
<name>Shankar et al.</name>
<date>20050400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>4554351</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00024">
<document-id>
<country>US</country>
<doc-number>2005/0091545</doc-number>
<kind>A1</kind>
<name>Soppera</name>
<date>20050400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713202</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00025">
<document-id>
<country>US</country>
<doc-number>2005/0223229</doc-number>
<kind>A1</kind>
<name>Roeder et al.</name>
<date>20051000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713171</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00026">
<document-id>
<country>US</country>
<doc-number>2005/0289311</doc-number>
<kind>A1</kind>
<name>Durham et al.</name>
<date>20051200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711163</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00027">
<document-id>
<country>US</country>
<doc-number>2007/0014410</doc-number>
<kind>A1</kind>
<name>Panjwani et al.</name>
<date>20070100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>380270</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00028">
<document-id>
<country>WO</country>
<doc-number>WO 02/01351</doc-number>
<kind>A2</kind>
<date>20020100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00029">
<document-id>
<country>WO</country>
<doc-number>WO 03/100583</doc-number>
<kind>A1</kind>
<date>20031200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>19</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>713176</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>713179</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>5</number-of-drawing-sheets>
<number-of-figures>11</number-of-figures>
</figures>
<us-related-documents>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>60618037</doc-number>
<date>20041012</date>
</document-id>
</us-provisional-application>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20080133929</doc-number>
<kind>A1</kind>
<date>20080605</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Gehrmann</last-name>
<first-name>Christian</first-name>
<address>
<city>Lund</city>
<country>SE</country>
</address>
</addressbook>
<residence>
<country>SE</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Smeets</last-name>
<first-name>Bernard</first-name>
<address>
<city>Dalby</city>
<country>SE</country>
</address>
</addressbook>
<residence>
<country>SE</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Gehrmann</last-name>
<first-name>Christian</first-name>
<address>
<city>Lund</city>
<country>SE</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Smeets</last-name>
<first-name>Bernard</first-name>
<address>
<city>Dalby</city>
<country>SE</country>
</address>
</addressbook>
</inventor>
</inventors>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Telefonaktiebolaget LM Ericsson (publ)</orgname>
<role>03</role>
<address>
<city>Stockholm</city>
<country>SE</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Mehedi</last-name>
<first-name>Morshed</first-name>
<department>2438</department>
</primary-examiner>
</examiners>
<pct-or-regional-filing-data>
<document-id>
<country>WO</country>
<doc-number>PCT/EP2005/009624</doc-number>
<kind>00</kind>
<date>20050907</date>
</document-id>
<us-371c124-date>
<date>20070905</date>
</us-371c124-date>
</pct-or-regional-filing-data>
<pct-or-regional-publishing-data>
<document-id>
<country>WO</country>
<doc-number>WO2006/039967</doc-number>
<kind>A </kind>
<date>20060420</date>
</document-id>
</pct-or-regional-publishing-data>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Disclosed is a method of loading data into a data processing device. The method comprises receiving a payload data item by the data processing device; performing a cryptographic authentication process to ensure the authenticity of the payload data item; storing the authenticated received payload data item in the data processing device; and integrity protecting the stored payload data item. The cryptographic authentication process comprises calculating an audit hash value of at least the received data item. Integrity protecting further comprises calculating a reference message authentication code value of at least the audit hash value using a secret key stored in the data processing device as an input.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="179.66mm" wi="131.40mm" file="US08627086-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="256.96mm" wi="186.01mm" file="US08627086-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="243.59mm" wi="171.28mm" file="US08627086-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="253.75mm" wi="187.96mm" file="US08627086-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="261.70mm" wi="186.94mm" file="US08627086-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="222.84mm" wi="145.88mm" file="US08627086-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<p id="p-0002" num="0001">This application claims the benefit of U.S. Provsional Application No. 60/618,037, filed Oct. 12, 2004 the disclosure of which is fully incorporated herein by reference.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<p id="p-0003" num="0002">Disclosed is a method, product means, and a device for secure loading and storing of data in a data processing device.</p>
<p id="p-0004" num="0003">Embedded systems like mobile phones and other data processing devices depend on the execution of correct software that has not been manipulated in an unauthorised way. Manipulation of the software might lead to incorrect behavior of the device or even a breaking of the fundamental security features of the device. Hence, it is particularly important to protect the core software of the device. This can for example be achieved by storing the program into a protected memory. The memory can either be physically protected from illegal access or protected by cryptographic methods. In practice it is hard or expensive to produce memory with good physical protection and especially to protect the memory interfaces. Consequently, the most attractive solution is to use some type of cryptographic protection of the software stored in the memory.</p>
<p id="p-0005" num="0004">Furthermore, software even for rather small systems becomes increasingly complex, thereby increasing the risk of errors and unintended features, especially in early releases during a software life cycle. Furthermore, the functionality of early software releases is typically limited. Consequently, there is an increasing need for frequent updates of the software stored in embedded devices.</p>
<p id="p-0006" num="0005">The need for frequent updates and the desire to provide sufficient protection for the software of a data processing device create a need for security solutions that protect the software of a data processing device at storage and that allow for secure software upgrades.</p>
<p id="p-0007" num="0006">U.S. Pat. No. 6,026,293 discloses a method for preventing electronic memory tampering in an electronic device. According to this prior art method, when the electronic device is to be reprogrammed by a data transfer device, the electronic device initiates a public/private key based challenge-response authentication scheme to authenticate the data transfer device. Once authenticated, the data transfer device is permitted access to reprogram the memory. Following the reprogramming of the memory, the electronic device performs a hash calculation of the modified memory contents. The calculated hash value is sent to the data transfer device for a digital signature, and the signed hash value is returned to the electronic device for storage. The signed hash value is subsequently used for auditing the integrity of the memory content, e.g. during boot-up or periodically.</p>
<p id="p-0008" num="0007">Even though the above prior art method provides both authentication protection during the loading stage and integrity protection of the memory contents of the electronic device, it involves a rather complicated scheme of generating and signing the generated hash value, thereby causing the loading process to take a rather long time.</p>
<p id="p-0009" num="0008">Hence, it is a problem to provide a computationally more efficient security mechanism that protects the software both during the loading of the software into the device and subsequently while the software is stored in the device.</p>
<p id="p-0010" num="0009">The above and other problems are solved by a method of loading data into a data processing device, the method comprising:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0010">receiving a payload data item by the data processing device;</li>
        <li id="ul0002-0002" num="0011">performing a cryptographic authentication process to ensure the authenticity of the payload data item;</li>
        <li id="ul0002-0003" num="0012">storing the authenticated received payload data item in the data processing device; and</li>
        <li id="ul0002-0004" num="0013">integrity protecting the stored payload data item;</li>
        <li id="ul0002-0005" num="0014">wherein performing a cryptographic authentication process comprises calculating an audit hash value of at least the received data item; and wherein the integrity protecting further comprises calculating a reference message authentication code value of at least the audit hash value using a secret key stored in the data processing device as an input.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0011" num="0015">In particular, since the audit hash value calculated during the loading process is calculated from the received payload data, and the audit hash value is subsequently re-used during the calculation of the message authentication code, the number of necessary computations performed during the software loading is reduced, thereby increasing the computational efficiency of the method.</p>
<p id="p-0012" num="0016">Furthermore, since the regular integrity protection is based on a secret key stored in the data processing device, the integrity protection is independent of any external cryptographic keys and, in particular, does not depend on a public key signature mechanism. It is an advantage that symmetric key based integrity checks, i.e. integrity checks based on a message authentication code, are computationally more efficient than public key based integrity checks involving signature verification.</p>
<p id="p-0013" num="0017">The term data processing device is intended to comprise any electronic device comprising a data memory on which data can be loaded from an external source, e.g. from a data transfer system. In particular, the term data processing device is intended to comprise any electronic equipment portable radio communications equipment and other handheld or portable devices. The term portable radio communications equipment includes all equipment such as mobile telephones, pagers, communicators, electronic organisers, smart phones, personal digital assistants (PDAs), handheld computers, or the like.</p>
<p id="p-0014" num="0018">The term payload data item is intended to include any data loaded into the data processing device. In particular, the term payload data item is intended to include configuration data, program code, e.g. platform software or application software intended for execution by the device, or the like.</p>
<p id="p-0015" num="0019">The cryptographic authentication process may be any suitable cryptographic process for verifying the authenticity of the received data, i.e. to ensure that the data was in fact sent by the entity whose name it carries and that it was not forged or modified.</p>
<p id="p-0016" num="0020">In some embodiments, the cryptographic authentication process includes
<ul id="ul0003" list-style="none">
    <li id="ul0003-0001" num="0000">
    <ul id="ul0004" list-style="none">
        <li id="ul0004-0001" num="0021">receiving a reference hash value; and</li>
        <li id="ul0004-0002" num="0022">comparing the received reference hash value with the calculated audit hash value to verify the authenticity of the received payload data item.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0017" num="0023">In a further embodiment, the cryptographic authentication process includes digitally signing the data item according to a public key cryptosystem. The digital signing of software is an efficient and secure principle for the verification of software loaded into a mobile device. Successful verification of the signature guarantees that the software has been issued by a legitimate source. Furthermore, digital signatures based on public key techniques have the advantage that the public key used for verification does not need to be confidentiality protected at transfer or storage. Hence, the same public key can be installed in a large number of devices without compromising security. This allows efficient procedures for fast and secure software upgrade.</p>
<p id="p-0018" num="0024">In some embodiments, the method comprises
<ul id="ul0005" list-style="none">
    <li id="ul0005-0001" num="0000">
    <ul id="ul0006" list-style="none">
        <li id="ul0006-0001" num="0025">receiving the payload data item, a digital signature data item and a digitally signed digital certificate data item, wherein the digital certificate data item includes a first public key and wherein the digital signature data item includes a reference hash value encrypted with a first private key corresponding to the first public key;</li>
        <li id="ul0006-0002" num="0026">authenticating the digitally signed digital certificate data item against a root public key stored in the data processing device;</li>
        <li id="ul0006-0003" num="0027">authenticating the digital signature data item against the authenticated digital certificate;</li>
        <li id="ul0006-0004" num="0028">comparing the received reference hash value with the calculated audit hash value to verify the authenticity of the received payload data item.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0019" num="0029">Hence, the authenticity of the digital signature is ensured by the digital certificate, thereby further increasing the security of the loading process. It is understood that the data processing device may receive more than one digital certificate forming a certificate chain, wherein one certificate of the chain is verified by the public root key stored in the data processing device.</p>
<p id="p-0020" num="0030">In a further embodiment, the reference hash value is cryptographically authenticated; and calculating the reference message authentication code value is performed only if the reference hash value is successfully authenticated. Consequently, execution of the message authentication code procedure in the data processing device is conditioned on the receipt of an authenticated reference hash value, thereby reducing the risk of an adversary utilising the message authentication code procedure of the data processing device to calculate unauthorised message authentication code values.</p>
<p id="p-0021" num="0031">Message authentication codes (MAC) are a known mechanism for integrity protecting messages. A MAC is a function that takes a variable length input and a key to produce a fixed-length output, the so-called MAC value or tag value. MACs are typically used between two parties that share a secret key in order to validate information transmitted between these parties. In some embodiments, a MAC is calculated by applying a one-way hash function to the payload data and encrypting the result using a secret key. Examples of suitable MAC functions that can be combined with a cryptographic hash function include HMAC (Keyed-Hashing for Message Authentication), Cipher Block Chaining (CBC) MAC using for example AES or a secure one-way hash function. In the loading method described herein, a message authentication code is used to check the integrity of data stored in an unreliable or insecure medium, i.e. in this situation the MAC is used by only one party, i.e. the data processing device, when storing and retrieving the payload data item.</p>
<p id="p-0022" num="0032">Consequently, in some embodiments, the integrity protecting comprises storing the calculated reference message authentication code value in relation to the received payload data item, thereby making it available for subsequent memory audits of the payload data item by the data processing device. Hence, when auditing the memory content, the device calculates the message authentication code value of the stored payload data item using the secret key stored in the device, and compares the result with the previously stored reference MAC value. Consequently, in this embodiment, the secret key need only be known to the digital processing device. In some embodiments, the secret key is a secret data item unique to the data processing device, e.g. a secret data item known only to the data processing device.</p>
<p id="p-0023" num="0033">In another embodiment, calculating the reference message authentication code value further comprises calculating the reference message authentication code value of a combined data item derived from at least the audit hash value and a random number. It is an advantage of this embodiment, that the input to the MAC is not entirely dependant on the result of the authentication process, thereby further increasing the security of the data protection.</p>
<p id="p-0024" num="0034">When calculating the reference message authentication code value further comprises calculating the reference message authentication code value of a combined data item derived from at least the audit hash value and a version control data item, the integrity protection is efficiently combined with a version control mechanism, since a subsequent memory audit will only be successful if both the memory content and the version control information are consistent.</p>
<p id="p-0025" num="0035">In some embodiments, the version control data record is stored in a version control data structure, the version control data record including information about the received payload data item including at least the version control data item. In some embodiments, the control data structure is integrity protected.</p>
<p id="p-0026" num="0036">In some embodiments, the version control data record comprises a version counter. In some embodiments, the version control data record further comprises a back counter identifying a number of previous versions that may replace the current version of the payload data item, thereby providing a simple and efficient version control mechanism including a mechanism for controlling backward compatibility.</p>
<p id="p-0027" num="0037">In known software upgrade schemes where existing software is upgraded by a new version of the software, the software upgrade is often received as a so-called delta file or delta update. Such delta updates include differences of the new (updated) software relative to the current software, thereby reducing the size of the upgrade packet. In some delta-file techniques, the update file also includes commands to control the generation of the updated software version from the current software and the received update. Delta-file techniques as such are known in the art and described in e.g. &#x201c;Delta storage for arbitrary non-text files&#x201d;, by Christian Reichenberger, Proc. Of the 3rd International Workshop on Software Configuration Management, pp. 144-152, Norway, June 1991. It is desirable to provide an efficient security mechanism that can also be applied to delta updates. This problem is solved when receiving the payload data item comprises receiving a delta update of a previously received current data item, and generating the payload data item as an updated payload data item from the previously received current data item and the received delta update. Hence, according to this embodiment, the updated payload data item is generated and the audit hash value is calculated from the generated updated payload data item. Consequently, the audit hash value can again be re-used for the calculation of the reference message authentication code of the updated payload data that is stored in the device.</p>
<p id="p-0028" num="0038">According to a second aspect it is a problem of the above prior art system to provide an efficient and secure method of protecting the integrity of a current version of a data item stored in a data processing device in a situation where frequent upgrades of different versions of the stored data item occur.</p>
<p id="p-0029" num="0039">The above and other problems are solved by a method of protecting the integrity of a current version of a data item stored in a data processing device, the method comprising
<ul id="ul0007" list-style="none">
    <li id="ul0007-0001" num="0000">
    <ul id="ul0008" list-style="none">
        <li id="ul0008-0001" num="0040">determining a reference hash value of at least the data item;</li>
        <li id="ul0008-0002" num="0041">calculating a reference message authentication code value from the determined reference hash value using a secret key stored in the data processing device;</li>
        <li id="ul0008-0003" num="0042">storing the calculated reference message authentication code value in relation to the data item;
<br/>
characterised in
<br/>
that calculating the reference message authentication code value comprises calculating the reference message authentication code value from a combined data item derived from the determined reference hash value and at least a part of a version control data record, the version control data record including version control information about the current version of the data item.
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0030" num="0043">Consequently, by calculating the reference message authentication code from a combined data item derived from the determined reference hash value and at least a part of the version control data record, the integrity protection of the stored payload data is efficiently combined with a secure version control of the stored data.</p>
<p id="p-0031" num="0044">The reference hash value of at least the data item may be determined by calculating the hash value from the data item or by receiving the hash value together with the data item or from an authentication process in connection with the receipt of the data item as described herein.</p>
<p id="p-0032" num="0045">The term combined data item is intended to comprise any data item generated as a function of two or more data items, e.g. as a concatenation of the two or more data items where one data item is appended to the other. Hence, the combined data item derived from the determined reference hash value and at least a part of a version control data record is generated as a function of at least the reference hash value and of at least a part of a version control data record.</p>
<p id="p-0033" num="0046">In some embodiments, the version control data record is integrity protected.</p>
<p id="p-0034" num="0047">In some embodiments, the version control data record comprises a version counter; and calculating the reference message authentication code value comprises calculating a reference message authentication code value from a combined data item derived from the determined audit hash value and at least the version counter.</p>
<p id="p-0035" num="0048">In some embodiments, the version control data record further comprises a back counter identifying a number of previous versions that may replace the current version of the payload data item, thereby providing a simple and efficient version control mechanism including a mechanism for controlling backward compatibility. In some embodiments, calculating the reference message authentication code value comprises calculating a reference message authentication code value from a combined data item derived from the determined reference hash value and at least the back counter.</p>
<p id="p-0036" num="0049">In another embodiment, the version control data record further comprises the reference hash value for the current version of the data item, thereby providing a compact fingerprint of the data item.</p>
<p id="p-0037" num="0050">In some embodiments, the secret key is only known to the digital processing device. Furthermore, the secret key may be a secret data item unique to the data processing device.</p>
<p id="p-0038" num="0051">In some embodiments, the payload data is loaded by the first-mentioned method, thereby efficiently combining a secure loading and storing with a secure version control.</p>
<p id="p-0039" num="0052">In yet another embodiment, the method further comprises
<ul id="ul0009" list-style="none">
    <li id="ul0009-0001" num="0000">
    <ul id="ul0010" list-style="none">
        <li id="ul0010-0001" num="0053">receiving a delta update of a previously received current data item; and</li>
        <li id="ul0010-0002" num="0054">generating the data item as an updated data item from the previously received current data item and the received delta update.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0040" num="0055">In yet another embodiment, the method further comprises generating the version control data record; and storing the version control data record in a version control data structure, thereby making it available for a subsequent memory audit.</p>
<p id="p-0041" num="0056">Accordingly, in another aspect, a method of verifying the integrity of a current version of a data item stored in a data processing device comprises
<ul id="ul0011" list-style="none">
    <li id="ul0011-0001" num="0000">
    <ul id="ul0012" list-style="none">
        <li id="ul0012-0001" num="0057">calculating an audit hash value of the data item;</li>
        <li id="ul0012-0002" num="0058">calculating an audit message authentication code value from the calculated audit hash value using a secret key stored in the data processing device;</li>
        <li id="ul0012-0003" num="0059">comparing the calculated audit message authentication code value with a reference message authentication code value stored in relation to the data item.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0042" num="0060">According to this aspect, the method further comprises retrieving a version control data record, the version control data record including version control information about the current version of the data item; and</p>
<p id="h-0001" num="0000">calculating the audit message authentication code value comprises calculating an audit message authentication code value from a combined data item derived from the calculated audit hash value and at least a part of the version control data record.</p>
<p id="p-0043" num="0061">The present invention relates to different aspects including the methods described above and in the following, corresponding devices, and computer programs, each yielding one or more of the benefits and advantages described in connection with one of the above-mentioned methods, and each having one or more embodiments corresponding to the embodiments described in connection with one of the above-mentioned methods.</p>
<p id="p-0044" num="0062">More specifically, according to another aspect, a data processing device comprises a first processing circuit adapted to perform the method of loading data into a data processing device described above and in the following.</p>
<p id="p-0045" num="0063">In particular, it is been found that the security mechanism described herein may advantageously be applied to devices having a multi-chip architecture. In particular, when a first one of the chips accesses a memory via a second one of the chips, it is particularly important for the first chip to ensure data authenticity and integrity of the memory content.</p>
<p id="p-0046" num="0064">Consequently, in some embodiments, the data processing device further comprises storage means adapted to store the received payload data item; and a second processing circuit connected to the storage means and to the first processing circuit; wherein the second processing circuit is adapted to provide to the first processing circuit at least read access to the storage means.</p>
<p id="p-0047" num="0065">In a further embodiment, the first processing circuit comprises local storage means for storing a root public key of an asymmetric cryptographic system. In a further embodiment, the first processing circuit comprises local storage means for storing said secret key, thereby providing secure storage under the control of the first chip of the cryptographic keys used in the data authenticity and integrity mechanism.</p>
<p id="p-0048" num="0066">According to another aspect, a data processing device comprises storage means for storing a current version of a data item and a version control data record, the version control data record including version control information about the current version of the data item; and processing means adapted to perform the method of verifying the integrity of a current version of a data item described above and in the following.</p>
<p id="p-0049" num="0067">It is noted that the features of the methods described above and in the following may be implemented in software and carried out on a data processing device or other processing means caused by the execution of program code means such as computer-executable instructions. Here and in the following, the term processing means comprises any circuit and/or device suitably adapted to perform the above functions. In particular, the above term comprises general- or special-purpose programmable microprocessors, Digital Signal Processors (DSP), Application Specific Integrated Circuits (ASIC), Programmable Logic Arrays (PLA), Field Programmable Gate Arrays (FPGA), special purpose electronic circuits, etc., or a combination thereof.</p>
<p id="p-0050" num="0068">Hence, according to another aspect, a computer program comprises program code means adapted to cause a data processing device to perform the steps of the method described above and in the following, when said computer program is run on the data processing device.</p>
<p id="p-0051" num="0069">For example, the program code means may be loaded in a memory, such as a RAM (Random Access Memory), from a storage medium or from another computer via a computer network. Alternatively, the described features may be implemented by hardwired circuitry instead of software or in combination with software.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<p id="p-0052" num="0070">The above and other aspects will be apparent and elucidated from the embodiments described in the following with reference to the drawing in which:</p>
<p id="p-0053" num="0071"><figref idref="DRAWINGS">FIG. 1</figref> shows a schematic block diagram of a system for loading data into a mobile terminal;</p>
<p id="p-0054" num="0072"><figref idref="DRAWINGS">FIG. 2</figref> shows a schematic block diagram of an example of a mobile terminal with a single chip architecture;</p>
<p id="p-0055" num="0073"><figref idref="DRAWINGS">FIG. 3</figref> shows a schematic block diagram of an example of a mobile terminal with a two-chip architecture;</p>
<p id="p-0056" num="0074"><figref idref="DRAWINGS">FIG. 4</figref> shows a schematic block diagram of another example of a mobile terminal with a two-chip architecture;</p>
<p id="p-0057" num="0075"><figref idref="DRAWINGS">FIG. 5</figref> illustrates an example of a message structure used in a loading process for loading software into a mobile terminal;</p>
<p id="p-0058" num="0076"><figref idref="DRAWINGS">FIG. 6</figref> shows a flow diagram of a software loading process for a first-time load of a software version;</p>
<p id="p-0059" num="0077"><figref idref="DRAWINGS">FIG. 7</figref> illustrates the calculation of an embodiment of a message authentication code;</p>
<p id="p-0060" num="0078"><figref idref="DRAWINGS">FIG. 8</figref> illustrates the calculation of another embodiment of a message authentication code including a version control mechanism;</p>
<p id="p-0061" num="0079"><figref idref="DRAWINGS">FIG. 9</figref> shows a flow diagram of the version control process;</p>
<p id="p-0062" num="0080"><figref idref="DRAWINGS">FIG. 10</figref> illustrates an example of a version control mechanism; and</p>
<p id="p-0063" num="0081"><figref idref="DRAWINGS">FIG. 11</figref> shows a flow diagram of a software loading process for a software upgrade;</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<p id="p-0064" num="0082"><figref idref="DRAWINGS">FIG. 1</figref> shows a schematic block diagram of a system for loading data into a mobile terminal. The system comprises a loading station <b>101</b> and a mobile terminal <b>102</b>.</p>
<p id="p-0065" num="0083">The loading station may be a conventional, suitably programmed computer, e.g. a PC, comprising a suitable communications interface. In some embodiments, the loading station may generate the payload data, e.g. a software version, configuration data, and/or the like, to be loaded. In particular, the loading station may generate the digital signature and certificate to be loaded together with the payload data. In other embodiments, the loading station receives the payload data and the header information from a remote computer, e.g. a personal computer, a work station, a network server, etc. For example, the data may be received via a computer network, e.g. the Internet, a local area network, an intranet, an extranet, etc., or by any other suitable means, e.g. on a computer-readable medium such as a floppy disk, a CD ROM, etc. In this embodiment, the calculation of the signature and the generation of the certificate may be performed by the remote computer rather than the loading station. The loading station performs, in cooperation with the mobile terminal, the loading of the data into the mobile terminal.</p>
<p id="p-0066" num="0084">The mobile terminal <b>102</b> comprises a communications interface <b>104</b> comprising circuitry and/or devices suitable for enabling the mobile terminal to communicate data with the loading station via a wired or wireless communications link <b>103</b> such as a direct data link, a communications network, or the like. For example, the data may be loaded via a local short range wireless communications link, e.g. a Bluetooth connection, an infrared connection, or the like, or via a wired interface. In other embodiments, the data may be loaded into the mobile terminal via a communications network, e.g. over-the-air (OTA) via a cellular telecommunications network, e.g. GSM WCDMA, or the like.</p>
<p id="p-0067" num="0085">Consequently, examples of suitable communications units include a wired serial connection, such as an RS-232 link, a USB connection, a FireWire connection as described in the IEEE 1394 standard, or the like. Further examples include a wireless infrared interface, or an RF interface, such as the main antenna of a cellular telephone (not shown), or another antenna within the cellular telephone, such as a Bluetooth transceiver, or the like. Other examples of suitable interfaces include a cable modem, a telephone modem, an Integrated Services Digital Network (ISDN) adapter, a Digital Subscriber Line (DSL) adapter, a satellite transceiver, an Ethernet adapter, or the like.</p>
<p id="p-0068" num="0086">The mobile terminal further comprises a processing unit <b>105</b> for controlling the operation of the mobile terminal, and a memory <b>106</b>. For example, the processing unit may comprise a general- or special-purpose programmable microprocessor, a Digital Signal Processor (DSP), an Application Specific Integrated Circuit (ASIC), an Programmable Logic Array (PLA), a Field Programmable Gate Array (FPGA), etc., or a combination thereof. The memory <b>106</b> may be a flash memory, an EPROM, an EEPROM, or any other type of memory or storage device, such as a non-volatile memory.</p>
<p id="p-0069" num="0087">When data is loaded into the mobile terminal, the processing unit <b>105</b> performs the data authentication and integrity protection described herein and stores the data in the memory <b>106</b>.</p>
<p id="p-0070" num="0088">During subsequent operation of the mobile terminal, the processing unit can retrieve the loaded data from the memory <b>106</b>. For example, in the case of software, the processing unit loads the software from the memory <b>106</b> in a RAM for execution.</p>
<p id="p-0071" num="0089"><figref idref="DRAWINGS">FIG. 2</figref> shows a block diagram of an example of a mobile terminal with a single-chip architecture. The mobile terminal <b>101</b> comprises a controller <b>105</b> for controlling the operation of the mobile terminal. The controller <b>105</b> operates in conjunction with a flash program memory <b>106</b>, and a random access memory (RAM) <b>209</b>. The controller <b>105</b> includes a microprocessor <b>208</b>, an internal read-only memory (ROM) <b>207</b>, and a securely stored secret key <b>218</b>. For example, the secret key <b>218</b> may be a chip-unique key, e.g. stored in hardware e.g. using so-called e-fuse technology. Alternatively, the secret key may be stored in the ROM <b>207</b>. The ROM <b>207</b> contains boot code, hashing code, MAC code, authentication code, and a public root key. In some embodiments, the hashing code and/or the MAC code may be implemented at least partly in hardware instead or in addition to the implementation in ROM. Instruction code involved with the general operation of the cellular telephone is contained in the flash program memory <b>106</b>. The RAM memory <b>209</b> is used for operations which are part of the normal mobile terminal call processing. In some embodiments, operations involving sensitive data, hash value calculations and authentication processes are carried out in conjunction with a protected static random access memory (PSRAM) (not shown) included in the microcontroller <b>105</b>. The controller <b>105</b> communicates with the flash program memory <b>106</b> and the RAM <b>209</b> via a memory bus <b>219</b>.</p>
<p id="p-0072" num="0090"><figref idref="DRAWINGS">FIG. 3</figref> shows a schematic block diagram of an example of a mobile terminal with a two-chip architecture. In this embodiment, the controller <b>105</b> comprises two chips <b>310</b> and <b>313</b>, respectively, an external memory <b>106</b> and an internal memory <b>209</b>. The two chips each contain at least one microprocessor <b>312</b> and <b>315</b>, respectively, and a ROM <b>311</b> and <b>314</b>, respectively. The external memory <b>106</b> is any suitable kind of non-volatile memory, for example a flash memory. The internal memory <b>209</b> is a fast access memory, for example a RAM. In the embodiment of <figref idref="DRAWINGS">FIG. 3</figref>, the two chips share the internal memory <b>209</b>. Furthermore, in this embodiment, only chip <b>313</b> has direct access to the external memory <b>106</b>. Hence, when the processor <b>312</b> of chip <b>310</b> is to execute software stored in the external memory <b>106</b>, the software to be executed is loaded into the internal memory <b>209</b> via chip <b>313</b> before it can be executed. In this embodiment, both ROMs <b>311</b> and <b>314</b> comprise boot code, but only ROM <b>311</b> comprises hashing code, MAC code, authentication code, and a public root key, and only chip <b>310</b> comprises a secret key <b>318</b>. As described above, the secret key <b>318</b> may be stored in hardware e.g. using so-called e-fuse technology. Alternatively, the secret key may be stored in the ROM <b>311</b>. Furthermore, in some embodiments, the hashing code and/or the MAC code may be implemented at least partly in hardware instead or in addition to the implementation in ROM.</p>
<p id="p-0073" num="0091"><figref idref="DRAWINGS">FIG. 4</figref> shows a schematic block diagram of another example of a mobile terminal with a two-chip architecture. This embodiment is similar to the embodiment of <figref idref="DRAWINGS">FIG. 3</figref>, except that the two chips <b>310</b> and <b>313</b> of this embodiment do not share a common internal memory. Instead, each chip has its own internal memory <b>416</b> and <b>417</b>, respectively. As in the embodiment of <figref idref="DRAWINGS">FIG. 3</figref>, only chip <b>313</b> has direct access to the external memory <b>106</b>. Hence, when the processor <b>312</b> of chip <b>310</b> is to execute software stored in the external memory <b>106</b>, the software to be executed is loaded into the internal memory <b>416</b> of chip <b>310</b> via chip <b>313</b> before it can be executed.</p>
<p id="p-0074" num="0092">In alternative two-chip embodiments with shared or separate RAM (Random Access Memory), both chips may have direct access to an external non-volatile memory and directly run the software to be executed from that memory or first load it into RAM and then execute.</p>
<p id="p-0075" num="0093"><figref idref="DRAWINGS">FIG. 5</figref> illustrates an example of a message structure used in a loading process for loading software into a mobile terminal. The message <b>520</b> comprises a header section <b>521</b>, a payload section <b>522</b>, a digital certificate section <b>523</b>, and a digital signature <b>524</b>.</p>
<p id="p-0076" num="0094">The payload section <b>522</b> comprises the actual payload data to be loaded into the mobile terminal. The payload data may comprise software, such as application software, pre-loader software for organising and/or controlling the loading of other software, parts of the operating system of the mobile terminal, or the like. Alternatively or additionally, the payload data may comprise other data, e.g. configuration data for storage into the flash memory or other memories of the mobile terminal, e.g. an EPROM, an EEPROM or the like.</p>
<p id="p-0077" num="0095">The header section <b>521</b> comprises information relevant to the loading process, such as information about the payload data, e.g. version control data, information about the mobile terminal, control parameters that determine how the mobile terminal should process the data, and/or the like.</p>
<p id="p-0078" num="0096">The signature section comprises a digital signature of the payload <b>522</b>. The digital signature is calculated using a public-private key pair of an asymmetric cryptosystem, e.g. the RSA (Rivest, Shamir, and Adleman) system. The digital signature is calculated by initially calculating a one-way hash function of the payload data, i.e. of the software and/or data to be loaded into the mobile terminal. The calculated hash value is then encrypted with the private key of the public-private key pair.</p>
<p id="p-0079" num="0097">A one-way hash function is used to derive the hash value representative of the payload data <b>522</b>. The public/private key system is used to provide security for the valid hash value and authenticate the loading station or data transfer device from which the message <b>520</b> is sent.</p>
<p id="p-0080" num="0098">A one-way hash function is a function that is simple to compute in a forward direction, but difficult to compute in a reverse direction. A one-way hash function, H(M), operates on an arbitrary-length input, M, which in some embodiments is comprised of the payload data <b>522</b> or selected parts of the payload data. The hash function performed on M returns a fixed-length hash value, h=H(M).</p>
<p id="p-0081" num="0099">There are many functions that can take an arbitrary-length input and return an output of fixed length, but one-way hash functions have the following additional characteristics: given M, it is easy to compute h; given h, it is hard to compute M; and given M, it is hard to find another message, M&#x2032;, such that H(M)=H(M&#x2032;). The aim of the one-way hash is to provide a unique signature, or fingerprint of M. The output of a hash function is referred to as the hash value or a message digest.</p>
<p id="p-0082" num="0100">In embodiments of the method described herein, prior to transmission of the message <b>520</b> to the mobile terminal a secure one-way hash function is performed on the payload data <b>522</b>, or selected contents thereof, to produce a reference hash value. The reference hash value is included into the message <b>520</b> as a digital signature as further described below. Upon receipt of the message <b>520</b>, the mobile terminal calculates an audit hash value of the payload data <b>522</b> (or the selected contents thereof) and compares the audit hash value with the reference hash value received as part of the message <b>520</b>.</p>
<p id="p-0083" num="0101">A suitable one-way hash function is for example the SHA-1 function. Other examples of suitable functions include the MD5 algorithm, Snerfu, H-Hash, MD2, MD4, or the like.</p>
<p id="p-0084" num="0102">Public key algorithms use two keys, one publicly available and one privately held (secret) for tasks such encrypting and decrypting messages, message authentication, and digital signatures. When a sender encrypts a message with the private key, any recipient with a corresponding public key can be assured of the sender's authenticity, since only a sender in possession of the private key was able to encrypt the message. It is the latter scheme that is utilized to authenticate the payload data in accordance with the loading process described herein. A suitable public key algorithm is the RSA algorithm. Other suitable examples include the Fiat-Shamir (FS) algorithm, ELGAMAL, DSA, Fiege-Fiat-Shamir, or the like.</p>
<p id="p-0085" num="0103">In particular, in the loading process described herein, the calculated hash value is encrypted with the private key of the loading station (or of the generator of the payload) to produce the digital signature <b>524</b> that is included in the message <b>520</b>.</p>
<p id="p-0086" num="0104">The corresponding public key is included in a certificate that is included in the digital certificate section <b>523</b> of the message <b>520</b>. A digital certificate is a data structure used in a public key system to bind a particular, authenticated individual to a particular public key. A digital certificate is a digital representation of information which identifies a certification authority issuing it, names or identifies the individual whose public key is included, and contains the individual's public key. The digital certificate is digitally signed by the certification authority issuing it, thereby allowing the recipient to authenticate the certificate by using the certification authority's public key.</p>
<p id="p-0087" num="0105">It is understood that the digital certificate section may comprise a single digital certificate or a chain of certificates. In any case, the certificate or chain of certificates can be authenticated by the mobile terminal by means of a root public key corresponding to the single certificate or the last certificate in the certificate chain. An example of a key hierarchy in connection with the loading of software into mobile phones is described in WO 03/060673.</p>
<p id="p-0088" num="0106">It is understood that in some embodiments the payload may, for the purpose of calculating the digital signature, be split up in smaller parts, as described in e.g. WO 03/060673, or the signature may only be calculated.</p>
<p id="p-0089" num="0107">Typically it is desirable to protect the header data <b>521</b> as well as the payload data <b>522</b>. In some embodiments this is achieved by protecting the header data <b>521</b> itself by a digital signature. In other embodiments, the above encryption of the calculated hash value further comprises encryption of a hash value calculated over the header data <b>521</b>, e.g. by encrypting/signing a concatenation h(SW)|h(H) of the hash value h(SW) calculated over the software (and data) <b>522</b> and a hash value h(H) calculated over the header data <b>521</b>.</p>
<p id="p-0090" num="0108"><figref idref="DRAWINGS">FIG. 6</figref> shows a flow diagram of a software loading process for a first-time load of a software version.</p>
<p id="p-0091" num="0109">In initial step <b>601</b>, the mobile terminal receives a software data packet from a reprogramming tool over a local or a remote interface, e.g. GSM, WCDMA, etc., as described above. The packet contains the new software SW, one or more certificates C, and a digital signature S(h<sub>r</sub>) of the protected software and data, as described in connection with <figref idref="DRAWINGS">FIG. 5</figref> above. Optionally, the new software may include data, e.g. configuration data. The signature S(h<sub>r</sub>) comprises at least an encrypted hash value calculated from the software and data. The signature is calculated such that first a one-way hash h<sub>r</sub>=H(SW) of the software and data, SW, is calculated, and subsequently, at least the calculated hash value is encrypted with the private key of a public-private key pair, e.g. an RSA public-private key pair. The corresponding public key is included in a certificate that is included in the software data packet. Upon receipt of the software and data packet, the mobile terminal stores the software, data, certificate(s), and the signature in the external memory <b>106</b>. As mentioned in connection with <figref idref="DRAWINGS">FIG. 5</figref> above, in some embodiments the signature may protect not only the payload but also the header data, e.g. by encrypting a combination of a hash value calculated from the software and of a hash value calculated from the header.</p>
<p id="p-0092" num="0110">In step <b>602</b> the processor of the mobile terminal reads the newly stored software and data, SW, the certificate(s), C, and the signature, S(h<sub>r</sub>), into its internal memory.</p>
<p id="p-0093" num="0111">In step <b>603</b>, the processor calculates a one-way audit hash value h<sub>a</sub>=H(SW) of the new software and data, SW.</p>
<p id="p-0094" num="0112">In step <b>604</b>, the processor reads a root public key, PK from a memory <b>605</b>. In some embodiments, the root public key is securely stored, i.e. integrity protected. In one embodiment, the root public key is stored in the internal ROM of the processor, as described above. The processor uses the root public key PK to verify the signature S(h<sub>r</sub>) of the new software and data. If only one certificate is used, then the signature S(h<sub>r</sub>) is verified against the public key in the certificate C. The certificate C in turn is then verified against the root public key PK. If several certificates are used, the whole chain of certificates is verified. In that case, the signature of the last certificate in the chain is verified against the root public key. Hence, in step <b>604</b>, the processor verifies the public key used to sign the new software and data. If the verification succeeds the processor proceeds at step <b>606</b> with verifying the signature. Otherwise, the software loading process is aborted.</p>
<p id="p-0095" num="0113">In step <b>606</b>, the processor decrypts the digital signature S(h<sub>r</sub>) of the software and data using the public key verified in step <b>604</b>, resulting in the reference hash value h<sub>r</sub>.</p>
<p id="p-0096" num="0114">In step <b>607</b>, the decrypted signature, i.e. the reference hash value h<sub>r</sub>, is verified against the one-way audit hash value h<sub>a </sub>calculated in step <b>603</b>. If the verification succeeds, i.e. if the audit hash value h<sub>a </sub>and the reference hash value h<sub>r </sub>are equal, the processor proceeds at step <b>608</b> with calculating a reference message authentication code (MAC). Otherwise, the software loading process is aborted.</p>
<p id="p-0097" num="0115">In step <b>608</b>, the processor uses the verified one-way hash value h<sub>a </sub>(=h<sub>r</sub>) and a chip unique key, K (or a value derived from K), as input values to a MAC calculating function, resulting in a reference message authentication code value t<sub>r</sub>=MAC(h<sub>a</sub>; K). The output value of the MAC function is the reference MAC value of the new software and data. In some embodiments, the chip unique key K is stored in a secure memory that is only accessible by the processor. For example the unique key K may be burnt into the chip during the fabrication process using e.g. so-called e-fuse technology. Embodiments of the message authentication code will be described below. The processor stores the new reference MAC value t<sub>r </sub>in the external memory <b>106</b> together with the new software and data SW. Optionally, the certificate(s) and the digital signature values are removed from the external memory.</p>
<p id="p-0098" num="0116">The loading process described above is controlled by the processor of the mobile terminal. In a two-chip architecture as described in connection with <figref idref="DRAWINGS">FIGS. 3 and 4</figref>, the above steps are carried out by the chip <b>311</b> that is intended to subsequently execute the software.</p>
<p id="p-0099" num="0117">The cryptographic functions for authenticating the received data and, in particular, the MAC function, may be performed by special-purpose software that is stored, e.g. as part of the boot code, in the internal ROM of the processor that performs the above steps.</p>
<p id="p-0100" num="0118">Hence, the stored reference MAC value is now available for subsequent audits of the software and data by the processor. For example, in order to verify the integrity of the stored software, the processor calculates an audit hash value h(SW) of the stored software and data and an audit MAC value t<sub>a</sub>=MAC(h(SW); K) of the calculated audit hash value using the chip unique key K. The processor compares the calculated audit MAC value t<sub>a </sub>with the stored reference MAC value t<sub>r</sub>. If the two values are equal, the integrity of the software is verified.</p>
<p id="p-0101" num="0119">For example, such an audit may be performed during the boot process of the mobile terminal and/or each time the software is to be executed and/or periodically in predetermined time intervals, e.g. as described in U.S. Pat. No. 6,026,293.</p>
<p id="p-0102" num="0120"><figref idref="DRAWINGS">FIG. 7</figref> illustrates the calculation of an embodiment of a message authentication code (MAC). A MAC is a function that takes a variable length input, M, and a key, K, to produce a fixed-length output, t, the so-called MAC value or tag value: t=MAC(M; K). In some embodiments, the MAC is defined such that for an intruder with knowledge of M but without information about the value of K, it is computationally hard (infeasible) to find a message M&#x2032; different from M but with the same tag value. Furthermore, the MAC function may be defined such that it is hard for an intruder with knowledge of a message M but without information about the value of K to predict the correct tag value t. In the loading method described herein, a MAC is used to check the integrity of data stored in an unreliable or insecure medium, i.e. in this situation the MAC is used by only one party, i.e. the mobile terminal, when storing and retrieving the payload data. In some embodiments, the MAC function is based on a cryptographic hash function and, in particular, on the hash function H used for authenticating the received payload data as described above. This allows reuse of the hash value calculated during authentication of the received payload data when calculating the MAC value for subsequent integrity protection, thereby considerably reducing the computational effort for the computation of the MAC value and, thus, reducing the installation time.</p>
<p id="p-0103" num="0121"><figref idref="DRAWINGS">FIG. 7</figref> shows a block diagram of a MAC calculation module. The MAC calculation module comprises a MAC function calculator <b>732</b>. The MAC function calculator <b>732</b> receives h as an input, h being the verified hash value that was calculated during the preceding signature verification process <b>736</b> for the received payload, i.e. h=h<sub>a </sub>or h=h<sub>r</sub>. As a second input the MAC function <b>732</b> receives a secret key K&#x2032; that is derived from a chip unique key K. In particular, the key K&#x2032; may be generated using a pseudo random function <b>731</b>, e.g. a pseudo random function that is based on a hash function, e.g. SHA-1, from a chip unique key K and a mode identifier <b>735</b>. For example, the chip unique key K may be a random number generated during ASIC production of the chip. Deriving the key K&#x2032; from the master key K has the advantage that different keys K&#x2032; may be used for different purposes, e.g. for the protection of different types of software, of different parts of the software, etc., thereby assuring cryptographic separation and increasing the flexibility of the method. The mode identifier <b>735</b> allows the selection of different modes. For example, in a multi-chip scenario a different mode may be used for each target chip for which the software is intended. Examples of suitable MAC functions include HMAC (Keyed-Hashing for Message Authentication), Cipher Block Chaining (CBC) MAC using for example AES or a secure one-way hash function, e.g. CBC-MAC as specified in &#x201c;Handbook of Cryptology&#x201d;, by A. J. Menezes, P. C van Oorschot, S. A. Vanstone, p. 353, CRC Press, 1997, where the AES block encryption cipher is used as block cipher E. The MAC function <b>732</b> produces a corresponding tag value t as described above.</p>
<p id="p-0104" num="0122">To prevent unauthorised MAC value computations, the MAC circuitry only releases the computed MAC value t when successful signature verification preceded the computations. Hence, the MAC calculation module receives a further input <b>733</b> from the signature verification process <b>736</b> indicating whether the digital signature of the received payload data was verified successfully. Block <b>734</b> receives the tag value and the signal <b>733</b> as inputs and releases the calculated tag value only if the signal <b>733</b> indicates that the hash value h is a verified, i.e. authentic, hash value. For example, in the method of <figref idref="DRAWINGS">FIG. 6</figref>, the signal <b>733</b> is generated by step <b>607</b>.</p>
<p id="p-0105" num="0123">It is noted that the MAC computation module may be implemented as a separate MAC computation circuitry on the processor chip. Furthermore, the subsequent comparison between a computed MAC value and a reference value can be performed inside a comparison circuit attached to the MAC circuitry. Furthermore, the secret key K may be stored as part of that circuitry. Consequently, the entire MAC computation may be confined in a special-purpose circuit and, thus, does not require an exposure/release of the computed MAC outside the circuitry.</p>
<p id="p-0106" num="0124">The MAC calculation of <figref idref="DRAWINGS">FIG. 7</figref> can be further improved at very little computational cost to further include a secure version control and to break the predictability of the input h to the MAC computation. This alternative embodiment of a MAC calculation will now be described with reference to <figref idref="DRAWINGS">FIG. 8</figref> and <figref idref="DRAWINGS">FIG. 9</figref>.</p>
<p id="p-0107" num="0125"><figref idref="DRAWINGS">FIG. 8</figref> illustrates the calculation of another embodiment of a message authentication code including a version control mechanism, and <figref idref="DRAWINGS">FIG. 9</figref> shows a flow diagram of the version control process.</p>
<p id="p-0108" num="0126">According to this embodiment of a MAC circuit <b>800</b>, the MAC computation in block <b>732</b> is performed on a four-tuple (rand, h, cnt, back_cnt) <b>844</b>. The four-tuple <b>844</b> comprises a short (e.g. 64 bit) random value, rand, that assures that the input to the MAC computation is not under full control by the inputs from the signature verification process <b>736</b>. The four-tuple further comprises the verified hash value h as in the previous embodiment. Finally, the four-tuple comprises a version control counter, cnt, and a version control back counter, back_cnt, of a version control mechanism described in the following. The MAC function <b>732</b>, e.g. HMAC, CBC-MAC, or the like, further receives the secret key K&#x2032; as described in connection with <figref idref="DRAWINGS">FIG. 7</figref> and calculates a MAC value t from the four-tuple and the secret key K&#x2032;. Likewise, as described in connection with <figref idref="DRAWINGS">FIG. 7</figref>, the calculated tag value t is only released if the signature signal <b>703</b> indicates that the signature verification process has verified the hash value h.</p>
<p id="p-0109" num="0127">The four-tuple <b>844</b> is generated by a version control module <b>841</b> that maintains a version control list <b>842</b> of previously received software versions. In particular, the version control list <b>841</b> comprises a list of data records where each data record comprises a four-tuple corresponding to a previously observed hash value. The record with the most recent hash value is referred to as the top element of the list <b>842</b> which corresponds to the software that is actually installed/in use.</p>
<p id="p-0110" num="0128">The version control module <b>841</b> receives the verified hash value h and a digital signal <b>733</b> indicating that the signature was verified successfully from the signature verification process as described above. Furthermore, the version control module <b>841</b> receives from the signature verification process <b>736</b> the software version counter, cnt, and a number back_cnt. The number back_cnt indicates how many previous versions may still be installed, once a given software version has been installed. For example, back_cnt may be a number between 0 and C<sub>MAX</sub>, e.g. C<sub>MAX</sub>=15, where back_cnt=0 means that the new software does not allow that it is replaced with a previous version at all. Hence, back_cnt implements a simple but effective mechanism for controlling backwards and forward compatibility of the loaded software. In some embodiments, the values of cnt and back_cnt are received as part of the software packet that is received during the loading process, e.g. as part of the header section of the received software packet.</p>
<p id="p-0111" num="0129">Upon receipt (step <b>901</b>) of a new hash value h, a new counter cnt, a new back_cnt value, and a signal <b>733</b> from the signature verification process <b>736</b> during a loading process, the version control module <b>841</b> uses the signal <b>733</b> to verify (step <b>902</b>) whether the hash value h has been verified during the signature verification process <b>736</b>. If this is not the case, the version control module <b>841</b> blocks the value of h, i.e. the version control and MAC calculation process is aborted. If the signal <b>733</b> indicates that the hash value is authentic, the version control module <b>841</b> continues at step <b>903</b>.</p>
<p id="p-0112" num="0130">At step <b>903</b>, the version control module <b>841</b> compares the received hash value with the hash values in the version control list <b>842</b>. If the received hash value h equals one of the previous hash values h<sub>prev </sub>in the version control list <b>842</b>, the version control module <b>841</b> continues at step <b>904</b>; otherwise the process continues at step <b>906</b>.</p>
<p id="p-0113" num="0131">At step <b>904</b>, i.e. in case the received hash value h equals one of the previous hash values h<sub>prev</sub>, the process retrieves the corresponding four-tuple (rand, h, cnt, back_cnt)<sub>prev</sub>, and determines whether the counter value cnt<sub>prev </sub>of the previous version is in the allowed range as defined by the values cnt and back_cnt received from the signature verification process <b>736</b>. In some embodiments, the allowed range is defined as the range [cnt<sub>top</sub>-back_cnt, &#x221e;), where cnt<sub>top </sub>is the cnt value of the current top element of the list. For simplicity, it is assumed that there is no upper limit on the range of allowed values. However, it is understood that, in other embodiments, an upper limit may be defined.</p>
<p id="p-0114" num="0132">If cnt<sub>prev </sub>is in the allowed range, the version control module <b>841</b> generates (step <b>905</b>) a new four-tuple (rand, h, cnt, back_cnt)<sub>new </sub>with components rand<sub>new</sub>=new random value generated by the version control module <b>841</b>, h<sub>new</sub>=h, cnt<sub>new</sub>=cnt<sub>prev</sub>, back_cnt<sub>new</sub>=back_cnt<sub>prev</sub>, and the version control module replaces the previous tuple with the same h value with the new tuple, and sets the new tuple as the top element in the list.</p>
<p id="p-0115" num="0133">In case the test in step <b>903</b> reveals that h is not equal to one of the previous hash values, the new random value, hash value h, and counter are stored together with the allowed back_cnt (associated with this h) in the version control list (step <b>906</b>). In this case, the new four-tuple (rand, h, cnt, back_cnt)<sub>new </sub>is created according to: rand<sub>new</sub>=new random value, h<sub>new</sub>=h, cnt<sub>new</sub>=cnt, back_cnt<sub>new</sub>=min(back_cnt, cnt&#x2212;min_allowed_version) and the new tuple will become the top element in the list. Here, min_allowed_version is the current lowest allowed version by any tuple in the update list. After the entry has been placed on top in the update list the min_allowed_version is recomputed as cnt<sub>top</sub>-back_cnt<sub>top</sub>, i.e. from the counter cnt<sub>top </sub>and the back_cnt version of the top element (step <b>907</b>). Finally, all elements in the list are updated (step <b>908</b>) so that their back_cnt values are the largest possible values that do not give a version number that is lower than the least allowed version min_allowed_version. If the list contains an entry with a version that falls out of the allowed range, this entry will be deleted.</p>
<p id="p-0116" num="0134">In some embodiments, a MAC check value (MACLIST) is associated with the version control list to prevent unauthorized manipulation of the entries in the list, thereby further increasing the security of the method. The MACLIST value is updated only when the list has been updated, i.e. after a successful signature verification. Prior to accessing/using the version control list the current MAC check value can be checked against the MACLIST value. To prevent unauthorised MACLIST value computations, the MAC circuitry will only release the computed MAC value when a successful signature verification preceded the computations (as controlled by block <b>734</b> in <figref idref="DRAWINGS">FIGS. 7 and 8</figref>).</p>
<p id="p-0117" num="0135">Hence, the stored reference MAC value and the version control list are now available for subsequent audits of the software and data by the processor. For example, in order to verify the integrity of the stored software, the processor calculates an audit hash value h<sub>a</sub>=h(SW) of the stored software and data and generates an audit tuple (rand, h<sub>a</sub>, cnt, back_cnt) with the values rand, cnt, and back_cont retrieved from the version control list. From this, the processor calculates an audit MAC value t<sub>a</sub>=MAC((rand, h<sub>a</sub>, cnt back_cnt); K) of the calculated audit tuple using the chip unique key K. The processor compares the calculated audit MAC value t<sub>a </sub>with the stored reference MAC value t<sub>r</sub>. If the two values are equal, the integrity of the software is verified.</p>
<p id="p-0118" num="0136">As described above, such an audit may be performed during the boot process of the mobile terminal and/or each time the software is to be executed and/or periodically in predetermined time intervals.</p>
<p id="p-0119" num="0137">The above process will now be further illustrated by way of example and with reference to <figref idref="DRAWINGS">FIG. 10</figref>.</p>
<p id="p-0120" num="0138"><figref idref="DRAWINGS">FIG. 10</figref> illustrates an example of a version control mechanism where a version control list of size 3 is used, i.e. the version control list can store three tuples. In this example, it is further assumed that there is a sequence of 8 software version releases with the following values (h, cnt, back_cnt) of the hash value h, the version counter cnt and the back counter back_cnt received from the signature verification process:
<ul id="ul0013" list-style="none">
    <li id="ul0013-0001" num="0000">
    <ul id="ul0014" list-style="none">
        <li id="ul0014-0001" num="0139">Version <b>1</b>: (H1, 1, 0),</li>
        <li id="ul0014-0002" num="0140">Version <b>2</b>: (H2, 2, 1),</li>
        <li id="ul0014-0003" num="0141">Version <b>3</b>: (H3, 3, 2),</li>
        <li id="ul0014-0004" num="0142">Version <b>4</b>: (H4, 4, 3),</li>
        <li id="ul0014-0005" num="0143">Version <b>5</b>: (H5, 5, 2),</li>
        <li id="ul0014-0006" num="0144">Version <b>6</b>: (H6, 6, 3),</li>
        <li id="ul0014-0007" num="0145">Version <b>7</b>: (H7, 7, 4), and</li>
        <li id="ul0014-0008" num="0146">Version <b>8</b>: (H8, 8, 4).</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0121" num="0147">It is further assumed that the above versions have been applied in sequence except version <b>7</b> that was not applied. <figref idref="DRAWINGS">FIG. 10</figref> shows the version control list <b>1001</b> after installation of version <b>8</b>. Each row of the version control list <b>1001</b> includes the corresponding four-tuple for one of the installed versions: Row <b>1002</b>, the top element of the list, corresponds to version <b>8</b>, row <b>1003</b> corresponds to version <b>6</b>, and row <b>1004</b> corresponds to version <b>5</b>. R8, R6, and R5 are the random numbers generated by the version control module as described above. After version <b>8</b> was applied the lowest allowed version was 4 (since cnt of version <b>8</b> is 8 and back_cnt of version <b>8</b> is 4 and 8&#x2212;4=4), thus min_allowed_version=4. Accordingly, the back_cnt values of the remaining entries in the list were adjusted during the installation of version <b>8</b> to meet the limit on the lowest allowed version after version <b>8</b> has been added. In particular, the back_cnt value in row <b>1002</b> was set to 2 and the back_cnt value in row <b>1003</b> was set to 1. Prior to the update with version <b>8</b>, the lowest allowed version was 3, but this value was raised to 4 through version <b>8</b>.</p>
<p id="p-0122" num="0148"><figref idref="DRAWINGS">FIG. 10</figref> further shows the version control table <b>1011</b> after installation of version <b>7</b>. First of all, the counter value cnt of version <b>7</b> is 7, i.e. in the allowed range of the current version. The hash value H7 does not yet exist in the version control list <b>1001</b>, hence a new four-tuple <b>1007</b> with the new hash value H7 is stored as the new top element <b>1012</b> of the version control table <b>1011</b>. The previous top element is moved down in the list and corresponds to row <b>1013</b>. Version <b>6</b> is now placed in row <b>1014</b>, while version <b>5</b> is removed from the list, because in this example, there is only room for three four-tuples in the version control list. The value of back_cnt of the new top element <b>1012</b> is set to 3 in order to meet the limit of the current lowest allowed version (min_allowed_version=4).</p>
<p id="p-0123" num="0149"><figref idref="DRAWINGS">FIG. 11</figref> shows a flow diagram of a software loading process for a software upgrade. The process is similar to the process shown in <figref idref="DRAWINGS">FIG. 6</figref> for loading a software for the first time.</p>
<p id="p-0124" num="0150">In initial step <b>1101</b>, the mobile terminal receives a software upgrade data packet from a reprogramming tool over a local or a remote interface, e.g. GSM, WCDMA, etc., as described above. The packet contains the new software upgrade A, one or more certificates C, and a digital signature S(h<sub>r</sub>) of the protected software, as described in connection with <figref idref="DRAWINGS">FIG. 5</figref> above. Optionally, the software may further include data, e.g. updated configuration data. In one embodiment, the new software is loaded as a so-called delta-file including the differences of the new software relative to the current software, thereby reducing the size of the upgrade packet. Delta-file techniques are known in the art and described in e.g. &#x201c;Delta storage for arbitrary non-text files&#x201d;, by Christian Reichenberger, Proc. Of the 3rd International Workshop on Software Configuration Management, pp. 144-152, Norway, June 1991. Alternatively other upgrade file generation methods may be used or the entire new software may be received. The signature S(h<sub>r</sub>) comprises an encrypted hash value calculated from the new software. The signature is calculated such that first a one-way hash h<sub>r</sub>=H(SW) of the new software, SW, is calculated, and subsequently, the hash value is encrypted with the private key of a public-private key pair, e.g. an RSA public-private key pair. The corresponding public key is included in a certificate that is included in the software upgrade packet. Upon receipt of the software upgrade packet, the mobile terminal stores the software upgrade, certificate(s), and the signature in the external memory <b>106</b>.</p>
<p id="p-0125" num="0151">In step <b>1102</b> the processor of the mobile terminal reads the newly stored software upgrade, the certificate(s), C, and the signature, S(h<sub>r</sub>), into its internal memory.</p>
<p id="p-0126" num="0152">In step <b>1122</b>, the processor performs a version control. The mobile terminal has received a software version number of the new software version as part of the upgrade packet. The software version number of the new software image is checked against the version number of the current software stored on the external memory (protected by a MAC). If the new software version number is lower than the old software version number, the mobile terminal aborts the update process. In another embodiment, the version control process described in connection with <figref idref="DRAWINGS">FIGS. 8 and 9</figref> is performed.</p>
<p id="p-0127" num="0153">If the version control of step <b>1122</b> has succeeded, the process continues at step <b>1123</b>, where the processor generates the new software SW<sub>new </sub>from the received delta-file &#x394; and the current software version SW<sub>prev </sub>stored on the external memory (protected by a MAC).</p>
<p id="p-0128" num="0154">In step <b>1103</b>, the processor calculates a one-way audit hash value h<sub>a</sub>=H(SW<sub>new</sub>) of the new software SW<sub>new</sub>.</p>
<p id="p-0129" num="0155">In step <b>1104</b>, the processor reads a root public key, PK, from a memory <b>1105</b>. In some embodiments, the root public key is securely stored, i.e. integrity protected. In one embodiment, the root public key is stored in the internal ROM of the processor, as described above. The processor uses the root public key PK to verify the signature S(h<sub>r</sub>) of the new software. If only one certificate is used, then the signature S(h<sub>r</sub>) is verified against the public key in the certificate C. The certificate C in turn is then verified against the root public key PK. If several certificates are used, the whole chain of certificates is verified. In that case, the signature of the last certificate in the chain is verified against the root public key. Hence, in step <b>1104</b>, the processor verifies the public key used to sign the new software. If the verification succeeds, the processor proceeds at step <b>1106</b> with verifying the signature. Otherwise, the software loading process is aborted.</p>
<p id="p-0130" num="0156">In step <b>1106</b>, the processor decrypts the digital signature S(h<sub>r</sub>) of the software using the public key verified in step <b>1104</b>, resulting in the reference hash value h<sub>r</sub>.</p>
<p id="p-0131" num="0157">In step <b>1107</b>, the decrypted signature, i.e. the reference hash value h<sub>r</sub>, is verified against the one-way audit hash value h<sub>a </sub>calculated in step <b>1103</b>. If the verification succeeds, i.e. if the audit hash value h<sub>a </sub>and the reference hash value h<sub>r </sub>are equal, the processor proceeds at step <b>1108</b> with calculating a reference message authentication code (MAC). Otherwise, the software loading process is aborted.</p>
<p id="p-0132" num="0158">In step <b>1108</b>, the processor uses the verified one-way hash value h<sub>a </sub>and a chip unique key, K (or a value derived from K), as input values to a MAC calculating function, resulting in a reference message authentication code value t<sub>r</sub>=MAC(h<sub>a</sub>; K). The output value of the MAC function is the reference MAC value of the new software. In some embodiments, the chip unique key K is burnt into the chip during the fabrication process using e.g. so-called e-fuse technology. Alternatively, the key K is stored in another secure memory that is only accessible by the processor. Embodiments of the message authentication code have been described above. The processor stores the new reference MAC value t<sub>r </sub>in the external memory <b>106</b> together with the new software. The previous MAC value is deleted. Optionally, the certificate(s) and the digital signature values are removed from the external memory. The new software version SW<sub>new </sub>is stored in the external memory and the old software version is deleted.</p>
<p id="p-0133" num="0159">The loading process described above is controlled by the processor of the mobile terminal. In a two-chip architecture as described in connection with <figref idref="DRAWINGS">FIGS. 3 and 4</figref>, the above steps are carried out by the chip <b>311</b> that is intended to subsequently execute the software.</p>
<p id="p-0134" num="0160">Hence, in the above a powerful software signing mechanism for the protection of software for many different systems has been described. The mechanism is efficiently combined with a symmetric key based integrity protection mechanism for secure software storage. Once the SW has been installed in the platform, the symmetric key based mechanism is used, and advantage is taken from previously computations. Furthermore, a combined mechanism to protect and version control software is described herein.</p>
<p id="p-0135" num="0161">The provided integrity protection at storage is particular advantageous in connection with a two CPU architecture, when the non-volatile memory is connected to an untrusted CPU, and where there is a need for SW updates.</p>
<p id="p-0136" num="0162">Although some embodiments have been described and shown in detail, the invention is not restricted to them, but may also be embodied in other ways within the scope of the subject matter defined in the following claims.</p>
<p id="p-0137" num="0163">In particular, the embodiments have mainly been described with reference to a mobile terminal as an example of a data processing device. It is understood, however, that the method, product means, and device described herein may also be applied to other data processing devices.</p>
<p id="p-0138" num="0164">The method, product means, and device described herein can be implemented by means of hardware comprising several distinct elements, and by means of a suitably programmed microprocessor. In the device claims enumerating several means, several of these means can be embodied by one and the same item of hardware, e.g. a suitably programmed microprocessor, one or more digital signal processor, or the like. The mere fact that certain measures are recited in mutually different dependent claims or described in different embodiments does not indicate that a combination of these measures cannot be used to advantage.</p>
<p id="p-0139" num="0165">It should be emphasized that the term &#x201c;comprises/comprising&#x201d; when used in this specification is taken to specify the presence of stated features, integers, steps or components but does not preclude the presence or addition of one or more other features, integers, steps, components or groups thereof.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>The invention claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method of loading data into a data processing device, comprising the steps of:
<claim-text>receiving a payload data item by the data processing device;</claim-text>
<claim-text>performing a cryptographic authentication process to ensure the authenticity of the payload data item by calculating an audit hash value of at least the received data item;</claim-text>
<claim-text>storing the authenticated received payload data item in the data processing device; and</claim-text>
<claim-text>integrity protecting the stored payload data item, the integrity protecting comprising
<claim-text>calculating a reference message authentication code value of a combined data item derived from at least the audit hash value and a random number or at least the audit hash value and a version control data item, wherein
<claim-text>the calculating uses a secret key stored in the data processing device as an input.</claim-text>
</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the step of performing a cryptographic authentication process further comprises:
<claim-text>receiving a reference hash value; and</claim-text>
<claim-text>comparing the received reference hash value with the calculated audit hash value to verify the authenticity of the received payload data item.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method according to <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the step of performing a cryptographic authentication process includes digitally signing the data item according to a public key cryptosystem.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method according to <claim-ref idref="CLM-00003">claim 3</claim-ref>, further comprising the steps of:
<claim-text>receiving the payload data item, a digital signature data item and a digitally signed digital certificate data item, wherein the digital certificate data item includes a first public key and wherein the digital signature data item includes a reference hash value encrypted with a first private key corresponding to the first public key;</claim-text>
<claim-text>authenticating the digitally signed digital certificate data item against a root public key stored in the data processing device;</claim-text>
<claim-text>authenticating the digital signature data item against the authenticated digital certificate; and</claim-text>
<claim-text>comparing the received reference hash value with the calculated audit hash value to verify the authenticity of the received payload data item.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method according to <claim-ref idref="CLM-00003">claim 3</claim-ref>, further comprising the step of cryptographically authenticating the reference hash value; and wherein the step of calculating the reference message authentication code value is performed only if the reference hash value is successfully authenticated.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the step of integrity protecting further comprises storing the calculated reference message authentication code value in relation to the received payload data item.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising the step of storing a version control data record in a version control data structure, the version control data record including information about the received payload data item including at least the version control data item.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method according to <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the stored version control data record is integrity protected.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method according to <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the version control data record comprises a version counter.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method according to <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the version control data record further comprises a back counter identifying a number of previous versions that may replace the current version of the payload data item.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the secret key is a secret data item unique to the data processing device.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the secret key is a secret data item known only to the data processing device.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the step of receiving the payload data item further comprises the step of receiving a delta update of a previously received current data item, and
<claim-text>generating the payload data item as an updated payload data item from the previously received current data item and the received delta update.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. A computer program run on a data processing device, comprising:
<claim-text>program code, stored on a non-transitory computer-readable storage medium, when executed by the data processing device, executes instructions adapted to cause the data processing device to receive a payload data item by the data processing device;</claim-text>
<claim-text>program code, stored on the non-transitory computer-readable storage medium, when executed by the data processing device, executes instructions adapted to cause the data processing device to perform a cryptographic authentication process to ensure the authenticity of the payload data item by calculating an audit hash value of at least the received data item;</claim-text>
<claim-text>program code, stored on the non-transitory computer-readable storage medium, when executed by the data processing device, executes instructions adapted to cause the data processing device to store the authenticated received payload data item in the data processing device; and</claim-text>
<claim-text>program code, stored on the non-transitory computer-readable storage medium, when executed by the data processing device, executes instructions adapted to cause the data processing device to integrity protect the stored payload data item, by calculating a reference message authentication code value of a combined data item derived from at least the audit hash value and a random number or at least the audit hash value and a version data control item,</claim-text>
<claim-text>wherein calculating the reference message authentication code value uses a secret key stored in the data processing device as an input.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. A data processing device comprising
<claim-text>a first processing circuit adapted to:</claim-text>
<claim-text>receive a payload data item by the data processing device;</claim-text>
<claim-text>perform a cryptographic authentication process to ensure the authenticity of the payload data item by calculating an audit hash value of at least the received data item;</claim-text>
<claim-text>store the authenticated received payload data item in the data processing device; and</claim-text>
<claim-text>integrity protect the stored payload data item by calculating a reference message authentication code value of a combined data item derived from at least the audit hash value and a random number or at least the audit hash value and a version control data item,</claim-text>
<claim-text>wherein calculating the reference message authentication code value uses a secret key stored in the data processing device as an input.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The data processing device according to <claim-ref idref="CLM-00015">claim 15</claim-ref>, further comprising storage means adapted to store the received payload data item; and a second processing circuit connected to the storage means and to the first processing circuit; wherein the second processing circuit is adapted to provide to the first processing circuit at least read access to the storage means.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The data processing device according to <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the first processing circuit comprises local storage means for storing a root public key of an asymmetric cryptographic system.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The data processing device according to <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the first processing circuit comprises local storage means for storing said secret key.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the secret key is a chip-unique key stored in hardware.</claim-text>
</claim>
</claims>
</us-patent-grant>
