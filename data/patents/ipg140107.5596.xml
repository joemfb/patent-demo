<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08626696-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08626696</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13334442</doc-number>
<date>20111222</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<priority-claims>
<priority-claim sequence="01" kind="national">
<country>GB</country>
<doc-number>07107286.2</doc-number>
<date>20070501</date>
</priority-claim>
</priority-claims>
<us-term-of-grant>
<disclaimer>
<text>This patent is subject to a terminal disclaimer.</text>
</disclaimer>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>N</subclass>
<main-group>5</main-group>
<subgroup>02</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>706 48</main-classification>
</classification-national>
<invention-title id="d2e69">Method and system for approximate string matching</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5768423</doc-number>
<kind>A</kind>
<name>Aref et al.</name>
<date>19980600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>382228</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6401060</doc-number>
<kind>B1</kind>
<name>Critchlow et al.</name>
<date>20020600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>704  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>2004/0122836</doc-number>
<kind>A1</kind>
<name>Bennett et al.</name>
<date>20040600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707100</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2004/0193399</doc-number>
<kind>A1</kind>
<name>Potter et al.</name>
<date>20040900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>704  4</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>2005/0086267</doc-number>
<kind>A1</kind>
<name>Avadhanam et al.</name>
<date>20050400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>7071041</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2005/0091030</doc-number>
<kind>A1</kind>
<name>Jessee et al.</name>
<date>20050400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2006/0004744</doc-number>
<kind>A1</kind>
<name>Nevidomski (Alex Nevidomski) et al.</name>
<date>20060100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  4</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>WO</country>
<doc-number>2006130947</doc-number>
<kind>A1</kind>
<date>20061200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00009">
<othercit>Deorowicz et al., &#x201c;Correcting Spelling Errors by Modelling Their Causes,&#x201d; Feb. 2005, pp. 275-285, Int. J. Appl. Math. Computer Science, vol. 15, No. 2.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00010">
<othercit>Patent Cooperation Treaty (PCT), &#x201c;Notification of Transmittal of the International Search Report and the Written Opinion of the international Searching Authority, or the Declaration&#x201d; for Application No. PCT/EP2008/054013 dated Oct. 6, 2008, 10 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00011">
<othercit>Coughlan, Office Action Communication for U.S. Appl. No. 12/098,604 dated Feb. 24, 2011, 29 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00012">
<othercit>Coughlan, Office Action Communication for U.S. Appl. No. 12/098,604 dated Jun. 23, 2011, 31 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00013">
<othercit>Coughlan, Notice of Allowance and Fee(s) Due for U.S. Appl. No. 12/098,604 dated Nov. 14, 2011, 8 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>21</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>13</number-of-drawing-sheets>
<number-of-figures>14</number-of-figures>
</figures>
<us-related-documents>
<continuation>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>12098604</doc-number>
<date>20080407</date>
</document-id>
<parent-grant-document>
<document-id>
<country>US</country>
<doc-number>8140462</doc-number>
</document-id>
</parent-grant-document>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>13334442</doc-number>
</document-id>
</child-doc>
</relation>
</continuation>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20120095990</doc-number>
<kind>A1</kind>
<date>20120419</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Lambov</last-name>
<first-name>Branimir Z.</first-name>
<address>
<city>Dublin</city>
<country>IE</country>
</address>
</addressbook>
<residence>
<country>IE</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Lambov</last-name>
<first-name>Branimir Z.</first-name>
<address>
<city>Dublin</city>
<country>IE</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<last-name>Tang</last-name>
<first-name>Jeff</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<orgname>Hoffman Warnick LLC</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Chaki</last-name>
<first-name>Kakali</first-name>
<department>2122</department>
</primary-examiner>
<assistant-examiner>
<last-name>Coughlan</last-name>
<first-name>Peter</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A method and system for approximate string matching are provided for generating approximate matches whilst supporting compounding and correction rules. The method for approximate string matching of an input pattern to a trie data structure, includes traversing a trie data structure to find approximate partial and full character string matches of the input pattern. Traversing a node of the trie data structure to process a character of the string applies any applicable correction rules to the character, wherein each correction rule has an associated cost, adjusted after each character processed. The method includes accumulating costs as a string of characters is gathered, and restricting the traverse through the trie data structure according to the accumulated cost of a gathered string and potential costs of applicable correction rules.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="207.43mm" wi="174.67mm" file="US08626696-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="237.07mm" wi="121.75mm" file="US08626696-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="234.53mm" wi="185.00mm" file="US08626696-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="236.90mm" wi="155.45mm" file="US08626696-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="234.70mm" wi="136.91mm" orientation="landscape" file="US08626696-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="253.92mm" wi="171.37mm" file="US08626696-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="225.55mm" wi="146.13mm" orientation="landscape" file="US08626696-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="245.45mm" wi="172.38mm" file="US08626696-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="240.88mm" wi="129.46mm" file="US08626696-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="247.06mm" wi="134.87mm" file="US08626696-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="245.45mm" wi="89.75mm" orientation="landscape" file="US08626696-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="241.55mm" wi="81.36mm" orientation="landscape" file="US08626696-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="255.69mm" wi="163.41mm" file="US08626696-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="239.01mm" wi="153.16mm" orientation="landscape" file="US08626696-20140107-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading>
<p id="p-0002" num="0001">This application is a continuation of currently pending U.S. patent application Ser. No. 12/098,604 filed on Apr. 7, 2008. The application identified above is incorporated herein by reference in its entirety.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">FIELD OF THE INVENTION</heading>
<p id="p-0003" num="0002">This invention relates to the field of approximate string matching. In particular, it relates to approximate string matching using a trie data structure.</p>
<heading id="h-0003" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0004" num="0003">Approximate string matching is an operation often needed in scenarios such as the generation of spelling suggestions for misspelt words, approximate search in large databases in natural languages, or approximate search using other characters forming recognised patterns.</p>
<p id="p-0005" num="0004">Approximate string matching with compound word handling is often needed where words or any sort of data which can be naturally broken up into components are matched. Breaks between words or components may be missing in an input pattern requiring compound word or component support to match the input pattern to recognised words or components.</p>
<p id="p-0006" num="0005">US patent applications Nos. US 2005/091030 and US 2006/004744 describe methods of approximate string matching that can handle compound words. US 2005/091030 relies on a combination of large dictionaries of widely used compound words and semi-approximate search covering only certain types of errors.</p>
<p id="p-0007" num="0006">US 2006/004744 includes a trie-based dictionary with gloss nodes for word fragments as well as for complete words. The method includes looping the trie walker back to the root node if it reaches the gloss node of a word fragment and the current gathered suggestion is shorter than the target string. This forces the trie walker to accept word fragments along with stand-alone words. US 2006/004744 gives a complete treatment of compound words, but its efficiency is not optimal due to repeated look-ups for right hand side word part matches.</p>
<p id="p-0008" num="0007">In US 2006/004744 a method is also described in which approximate string matching in a trie-based dictionary includes correction rules in the trie data structure.</p>
<heading id="h-0004" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0009" num="0008">It is an aim of the present invention to provide an improvement to approximate string matching. The improvement aspects include the processing of correction rules, the provision of accumulated cost constraints on the matching process, and the processing of compound words.</p>
<p id="p-0010" num="0009">According to a first aspect of the present invention there is provided a method for approximate string matching of an input pattern to a trie data structure, comprising: traversing a trie data structure to find approximate partial and full character string matches of the input pattern, wherein traversing a node of the trie data structure to process a character of the string applies any applicable correction rules to the character, wherein each correction rule has an associated cost, adjusted after each character processed; accumulating costs as a string of characters is gathered; and restricting the traverse through the trie data structure according to the accumulated cost of a gathered string and potential costs of applicable correction rules.</p>
<p id="p-0011" num="0010">In one embodiment, recursive processing of branches of the trie is: fully performed if accumulated costs of a character string are below a predefined threshold; performed with restriction to characters that match characters at active positions in the input pattern, or are in applicable outstanding correction rules; or not performed if such characters are not present.</p>
<p id="p-0012" num="0011">In addition to correction rules, the method may apply elementary transitions of characters including one of an insertion, a deletion, or a replacement, each associated with a cost.</p>
<p id="p-0013" num="0012">Correction rules may be generated automatically for all possible applications of character transposition in the input pattern. Correction rules that are applicable to characters in an input pattern may be determined before starting the traverse.</p>
<p id="p-0014" num="0013">Applicable correction rules may be indexed by the character position to be processed. Indexing by the character position to be processed may include allowing for a predefined number of inserted or deleted characters in the string.</p>
<p id="p-0015" num="0014">The method may include determining candidate approximate matches and using the accumulated cost as a weighting for the candidate matches.</p>
<p id="p-0016" num="0015">The method may also include determining approximate partial matches where a length of the partial match is less than a length of the input pattern, and saving the partial matches with the accumulated cost as a starting cost for a traverse for right hand matches to the input pattern. Traverses for right hand matches of compound words may be started at the character position of the end position of the partial match. The method may include iterating through all positions for which there is a partial match and using saved accumulated costs as starting points for right hand side match traverses. Any full right hand side matches may be combined with all left hand side partial matches. Left hand side partial matches may also be combined.</p>
<p id="p-0017" num="0016">The accumulated costs for one or more partial matches may be used to compile a best case scenario for the right hand side look-up. Correction rules may be applied across points of attachments of word parts.</p>
<p id="p-0018" num="0017">Vector processing may be used to perform the corrections simultaneously for a range of displacements.</p>
<p id="p-0019" num="0018">According to a second aspect of the present invention there is provided a data structure for use in approximate string matching of an input pattern to a trie data structure, comprising: a data structure element for each applicable correction rule for a character of an input pattern, the element being indexed by a position of the character; a matrix of costs indexed by the character position, wherein the matrix of costs is updated during the traverse of the trie data structure to reflect accumulated costs of applied correction rules.</p>
<p id="p-0020" num="0019">The character position may be determined by the number of characters processed together with the displacement of inserted or deleted characters. Multiple data structure elements may be provided for a character position for multiple applicable correction rules for the character. Multiple data structure elements are stacked corresponding to the number of characters in the output of a correction rule. The stacked data elements may be reversely linked.</p>
<p id="p-0021" num="0020">The data structure may also include a matrix of saved costs for character positions of partial matches to the input pattern.</p>
<p id="p-0022" num="0021">According to a third aspect of the present invention there is provided a system for approximate string matching of an input pattern to a trie data structure, comprising: a trie data structure having nodes representing characters in a string, the trie data structure storing allowed character strings; a plurality of character correction rules to be applied to the input pattern including a transition of one or more characters in the input pattern; and means for generating a correction rule structure for applicable correction rules for an input pattern, the correction rule structure having a plurality of rule elements indexed by a position of the character.</p>
<p id="p-0023" num="0022">The system may include means for setting parameters for approximate string matching, including costs of correction rules. The system may also include means for storing accumulating costs for a gathered character string. The system may further include means for setting a maximum cost to restrict the traverse of the trie data structure. The system may include means for storing partial string matches with a saved accumulated cost.</p>
<p id="p-0024" num="0023">The system may include vector processing means to perform correction on a range of displacements simultaneously.</p>
<p id="p-0025" num="0024">Allowed character strings may be words and word parts, or recognised data components and partial data components.</p>
<p id="p-0026" num="0025">According to a fourth aspect of the present invention there is provided a computer program product stored on a computer readable storage medium, comprising computer readable program code means for performing the steps of: traversing a trie data structure to find approximate partial and full character string matches of the input pattern, wherein traversing a node of the trie data structure to process a character of the string applies any applicable correction rules to the character, wherein each correction rule has an associated cost, adjusted after each character processed; accumulating costs as a string of characters is gathered; and restricting the traverse through the trie data structure according to the accumulated cost of a gathered string and potential costs of applicable correction rules.</p>
<p id="p-0027" num="0026">The present invention complements US 2006/004744 with a fast method of approximate matching in the same environment. The method is based on Ukkonen's approximate matching algorithm, (Esko Ukkonen, &#x201c;Algorithms for approximate string matching&#x201d;, Inf. Control, 64(1-3):100-118, 1985) applied to dictionary tries (see H. Shang and T. H. Merrettal, &#x201c;Tries for approximate string matching&#x201d;, IEEE Transactions on Knowledge and Data Engineering, 8(4):540-547, 1996) generalized to handle varying operation costs, transitions, arbitrary correction rules, and word compounding.</p>
<p id="p-0028" num="0027">A method of generating approximate matches using a dictionary of words and word parts that supports compounding and correction rules is provided. The method provides a significant performance boost, avoids the common problem of recursive recurrent look-ups for word parts, properly handles the most general set of features considered in the literature, and is suitable for implementation using vector processing units and the synergistic units of the Cell Broadband Engine.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0029" num="0028">Embodiments of the present invention will now be described, by way of examples only, with reference to the accompanying drawings.</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 1</figref> is an example of a trie data structure as known in the prior art.</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram of a system in accordance with the present invention.</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIGS. 3A and 3B</figref> are schematic representations of data structures in accordance with the present invention.</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 4</figref> is a flow diagram of an overall method in accordance with the present invention.</p>
<p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. 5</figref> is a flow diagram of a method of combining compound words in accordance with an aspect of the present invention.</p>
<p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. 6</figref> is a flow diagram of a method of traversing a trie in accordance with an aspect of the present invention.</p>
<p id="p-0036" num="0035"><figref idref="DRAWINGS">FIGS. 7A and 7B</figref> are flow diagrams of methods of processing a new character in a trie traverse in accordance with an aspect of the present invention.</p>
<p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. 8</figref> is a flow diagram of a method of finding if a correction rule is applicable in accordance with an aspect of the present invention.</p>
<p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. 9</figref> is a flow diagram of a method of saving cost minima in accordance with an aspect of the present invention.</p>
<p id="p-0039" num="0038"><figref idref="DRAWINGS">FIGS. 10A and 10B</figref> are example tries used in worked examples of aspects in accordance with the present invention.</p>
<p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. 11</figref> is a block diagram of a computer system in which the present invention may be implemented.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0006" level="1">DETAILED DESCRIPTION OF THE INVENTION</heading>
<p id="p-0041" num="0040">Many applications include executable code for carrying out approximate string matching against given resources. For example, a spell checking application carries out approximate string matching of words in a document executed in an application against a resource in the form of a dictionary of words in a chosen language and suggests alternatives to an unrecognized word. As another example, a search engine may include a word recognition application which compares an input word with words in a dictionary and suggests other words which may have been intended for the search input. Approximate string matching is not limited to word analysis and can extend to database retrieval of recognized references and other applications.</p>
<p id="p-0042" num="0041">One technique for approximate string matching uses a resource in the form of a trie-based dictionary. Referring to <figref idref="DRAWINGS">FIG. 1</figref>, a trie data structure <b>100</b> is shown. The trie data structure <b>100</b> is a multi-way tree structure with a root node <b>101</b> from which child nodes extend. In turn, each child node can become a parent node with child nodes of its own. The transitions <b>102</b>, <b>103</b> in the trie data structure represent characters (for example, in an alphabet) and a string of characters is represented by following a route down the trie from the root node <b>101</b> to a leaf node. A node reached after a recognized string of character is marked as a final node <b>104</b>, shown in the figure by bold node outline.</p>
<p id="p-0043" num="0042">A trie data structure can be used to store a large dictionary of recognized string components and parts of the string components. In the most obvious case, the trie data structure stores words and parts of words. The alphabet can be defined for the given application, for example, {0,1} for binary files, {the 256 ASCII characters}, {a,b,c . . . x,y,z}, or another form of alphabet such as Unicode, which represents symbols of most world languages. The following description refers to words and word parts and to text, but it should be understood to apply equally to any recognized character string or string parts and to characters other than text characters.</p>
<p id="p-0044" num="0043">The concept of a trie data structure is that all strings with a common prefix propagate from a common node. When the strings are words in the alphabet {a,b,c . . . x,y,z}, a node usually has at most 26 child nodes&#x2014;one for each letter. The alphabet may also include punctuation characters such as an apostrophe or a hyphen in which case a node may have more child nodes. The string can be followed from the root to the leaf that ends a string. A trie-based dictionary has the advantage that the data is compressed due to the common entries for prefixes. A method of scanning a trie-based dictionary in order to recover approximate matches is called a trie walker.</p>
<p id="p-0045" num="0044">In the example shown in <figref idref="DRAWINGS">FIG. 1</figref>, a trie data structure <b>100</b> is shown with a root node <b>101</b>. The root node <b>101</b> will have a maximum number of child nodes for the characters in the alphabet plus a terminator. One path is illustrated in the trie <b>100</b> from the child node for the letter &#x201c;b&#x201d; <b>102</b>. The string &#x201c;be&#x201d; is a recognized word and therefore the node <b>104</b> is marked as final. Similarly, the following recognized words are shown in the trie <b>100</b>: &#x201c;bee&#x201d;, &#x201c;been&#x201d;, &#x201c;bean&#x201d;, &#x201c;beans&#x201d;, &#x201c;beat&#x201d;, &#x201c;beats&#x201d;, &#x201c;beaten&#x201d;, &#x201c;beater&#x201d;, &#x201c;beaters&#x201d;. Where each valid word ends in the trie <b>100</b>, the relevant node is marked as final. The final node may contain extra information about the valid dictionary entry formed by the root-to-node path string, such as flags denoting whether the string is a whole word or a word part that can be combined with other word parts to form a compound.</p>
<p id="p-0046" num="0045">A trie data structure represents a dictionary of words or recognized sequences of characters to which the approximate string matching technique compares a target string of characters which is the subject of the approximate matching. The target string is compared, one character at a time, to the transitions of a trie starting from the root node.</p>
<p id="p-0047" num="0046">In the following, the word displacement refers to a positive or negative integer which is added to the current character position to form the target position in a target string.</p>
<p id="p-0048" num="0047">A traverse refers to a recursive process of constructing a string for every root-to-node path in the trie from an empty string. The described method starts with an array of costs associated with a range of displacements. The traverse adds characters to a gathered string as it progresses through the trie. Every transition through the trie adds a character to a gathered string and is reflected in all accumulated costs. A match between the new transition and a target character is reflected by simply copying the previous cost. A mismatch is handled by applying an edit operation such as an insertion or a deletion. The process always progresses one character forward in the target string, extended with imaginary non-matching characters on either side, with the displacements forming a window of current target characters.</p>
<p id="p-0049" num="0048">Basic edit operations which may be carried out as approximations in a traverse are as follows:</p>
<p id="p-0050" num="0049">Accept a non-matching character in a gathered string and adjust the cost by adding a predefined value to the previous cost at the same displacement. This results in a substitution of a character in the gathered string compared to the target string.</p>
<p id="p-0051" num="0050">Accept a non matching character in a gathered string and adjust the cost by adding a predefined value to the previous cost at the next displacement. This results in an insertion of a character in the gathered string compared to the target string.</p>
<p id="p-0052" num="0051">Move forward in the target string by adjusting the cost through adding a predefined value to the current cost at the previous displacement. This results in a deletion of a missing character in the gathered string compared to the target string.</p>
<p id="p-0053" num="0052">For every displacement, all of the methods above are attempted, and only the lowest resulting cost is retained. When a final node is reached and the current target position for one of the displacements reaches the end of the target string, the gathered string defines a suggestion, its cost given by the cost accumulated at this displacement.</p>
<p id="p-0054" num="0053">Prior art methods include an edit distance or error value which counts the number of modifications made and an error tolerance defines how broad the search should be. In the described method this is replaced by separate cost values associated with each of the basic edit operations, and a cost maximum that defines which suggestions are accepted.</p>
<p id="p-0055" num="0054">In US 2006/004744 a method is described in which approximate string matching in a trie-based dictionary includes correction rules in the trie data structure. The contents of US 2006/004744 is incorporated herein by reference.</p>
<p id="p-0056" num="0055">The technique of using correction rules in a traverse is also used in the described method. A correction rule refers to a pair of character sequences that describe a possible substitution within the target string. For example, substitution of sequence &#x201c;ph&#x201d; to &#x201c;f&#x201d; is a correction rule reflecting a common phonetic misspelling for natural languages. A sequence-to-sequence character substitution is carried out according to the matched correction rule.</p>
<p id="p-0057" num="0056">The described method provides a technique of processing correction rules that uses processing of all applicable rules during trie traversal. The correction rule technique allows the method to:</p>
<p id="p-0058" num="0057">reflect valid applications of correction rules to accumulated costs;</p>
<p id="p-0059" num="0058">ignore irrelevant branches of the trie; and</p>
<p id="p-0060" num="0059">restrict look-ups through relevant branches of the trie when available costs do not permit the introduction of arbitrary characters.</p>
<p id="p-0061" num="0060">The technique relies on pre-processing and its performance is independent of the mode of storage of the correction rules, and also permits flexibility in the actual format of the rules at a low performance cost.</p>
<p id="p-0062" num="0061">The described method also provides a technique of approximately matching compounds, which relies on compiling &#x201c;best case&#x201d; information from partial matches. The technique performs a single trie look-up for every relevant position of the pattern and permits the application of correction rules and transitions across the points of attachment of word parts.</p>
<p id="p-0063" num="0062">Referring to <figref idref="DRAWINGS">FIG. 2</figref>, a block diagram is shown of an example embodiment of the described system <b>200</b>. An input pattern <b>201</b> in the form of a string of characters is provided to an approximate string matching procedure <b>202</b>. The procedure <b>202</b> outputs a suggestions list <b>203</b> of possible matches. Each suggestion <b>203</b> can be a stand-alone word, a compound word, or a multi-word expression.</p>
<p id="p-0064" num="0063">The procedure <b>202</b> uses associated stored components <b>210</b>. The components <b>210</b> include a specified trie <b>211</b> which is traversed by the procedure. The trie stores a dictionary of words and word parts that will be used by the algorithm. A set of text correction rules (TCR) <b>212</b> are defined which are applied by the procedure <b>202</b> during traverse of the trie <b>211</b>.</p>
<p id="p-0065" num="0064">The stored components <b>210</b> also include structures <b>220</b> for an input pattern <b>201</b>. The structures <b>220</b> include preset parameters <b>221</b>, a cost matrix <b>222</b>, a saved cost minima matrix <b>223</b>, text correction rule elements <b>224</b>, an array <b>225</b> of partial matches indexed by the end position of the partial match, and a match list <b>226</b> for matches.</p>
<p id="p-0066" num="0065">In the described example embodiment, given a pattern to be approximately matched, a dictionary trie dict of words and word parts, and a dictionary or list rules of text correction rules, the described method produces a list of all approximate matches within a preset maximum cost max_cost and maximum displacements max_ins and max_del. The costs cost_sub, cost_ins, cost_del, cost_tra of the four basic transitions (substitution, insertion, deletion and transposition) are implicit parameters of the method.</p>
<p id="p-0067" num="0066">Each correction rule is given by a pair of from and to strings, and a cost associated with the transition (a rule is written in the form &#x201c;fromto(cost)&#x201d;).</p>
<p id="p-0068" num="0067">A costing system is used to value the distance of a suggestion from the input pattern. A cost may be associated with each one of the basic transitions as well as with each correction rule. The cost is added for the transition made. For example, if there is a cost 50 for substitution and a cost 20 for insertion, the suggestion &#x201c;these&#x201d; from &#x201c;thez&#x201d; will have a cost of 70 as it includes a substitution of &#x201c;z&#x201d; with &#x201c;s&#x201d; and an insertion of an &#x201c;e&#x201d;.</p>
<p id="p-0069" num="0068">In the following description, the variables pos and j refer respectively to position (number of characters processed, ranging from 0 to length(pattern)+max_ins) and displacement (ranging from &#x2212;max_ins to +max_del). The displacement is the difference between the input position and the output position, which is used to match incoming characters to the characters in the pattern. The displacement indicates where characters should continue to be matched after a transition has been applied. For example, the string &#x201c;done&#x201d; is a match for the pattern &#x201c;doone&#x201d; with displacement 0 for the first two characters, includes a deletion, and then matches the rest with displacement 1. This means that, after the deletion, the fourth character of the pattern &#x201c;done&#x201d;, namely the &#x201c;n&#x201d;, is matched to the third character of the string &#x201c;done&#x201d;, and so on.</p>
<p id="p-0070" num="0069">The storage used in the method comprises two matrices cost and saved. The cost matrix stores accumulated costs for each pos and j. The saved matrix stores saved partial match cost minima (initially infinity) for each pos and j which is used when decompounding words or word parts. Sets of TCR elements are also stored all indexed by pos and j.</p>
<p id="p-0071" num="0070">An initial step of the method isolates the correction rules that apply to the pattern to be approximately matched, and converts them to TCR element stacks, reversely linked lists of TCR elements with the structure shown in <figref idref="DRAWINGS">FIG. 3A</figref>. The TCR element stacks have a length determined by the number of characters in the rule output. The TCR elements in a stack have the same displacement, which indicates the character position once the rule has been applied.</p>
<p id="p-0072" num="0071"><figref idref="DRAWINGS">FIG. 3A</figref> shows a cost matrix <b>222</b> and a saved matrix <b>223</b> each with fields <b>301</b>, <b>302</b> indexed by a position and displacement (pos, j) pair <b>300</b>.</p>
<p id="p-0073" num="0072">Each TCR element <b>224</b> is also associated with a (pos, j) pair <b>300</b>. Multiple TCR elements <b>224</b> are provided for each (pos, j) pair where multiple rules are applicable. For example, in <figref idref="DRAWINGS">FIG. 3A</figref>, TCR elements <b>323</b>-<b>325</b> relate to the same (pos, j) pair for different rules <b>1</b>, <b>2</b>, <b>3</b>. A number of rules may be applicable to a (pos, j) pair. When a trie is traversed and a character is met, only one of the rules is actually applied. If multiple rules can be applied for the same string (for example, &#x201c;bp&#x201d; and &#x201c;abep&#x201d;), the resulting cost is calculated and the rule with the smaller cost is used.</p>
<p id="p-0074" num="0073">TCR element <b>321</b> is in a stack with TCR element <b>323</b> as they relate to the same rule (rule <b>1</b>) for (pos, j) and (pos&#x2212;1, j).</p>
<p id="p-0075" num="0074">In the described embodiment, each TCR element <b>224</b> has the following fields <b>311</b>-<b>316</b>:</p>
<p id="p-0076" num="0075">a previous field <b>311</b> indicating if the TCR element <b>224</b> is either an initial element or is a non-initial element which links to the previous element;</p>
<p id="p-0077" num="0076">an initial_cost field <b>312</b>;</p>
<p id="p-0078" num="0077">a displacement field <b>313</b> (this field is not relevant for non-initial elements);</p>
<p id="p-0079" num="0078">a character field <b>314</b>;</p>
<p id="p-0080" num="0079">a cost field <b>315</b>; and</p>
<p id="p-0081" num="0080">a saved field <b>316</b>.</p>
<p id="p-0082" num="0081">A TCR element <b>224</b> is either an initial element or is a non-initial element which links to a previous element. An element is initial if it is the first character of the rule. Initial elements have their initial_cost value set to non-zero and have a displacement defined. Non-initial elements have a zero initial_cost and have a previous link defined. These parameters define the place from which the cost is taken with which the processing of this element is started. This is either the previous cost in the TCR stack (i.e. the value after processing all previous characters in the rule), or the accumulated cost at (pos, displacement) adjusted by initial_cost.</p>
<p id="p-0083" num="0082">The initial TCR elements are initialized by setting initial_cost field <b>312</b> to the sum of the rule's cost and a cost applied at each step in a traverse step_cost (some number significantly bigger than max_cost) multiplied by the length of the rule's to string. A non-initial element has its initial_cost field <b>312</b> as 0 and its previous field <b>311</b> has a link pointing to the previous element in the stack, the latter associated with (pos&#x2212;1, j).</p>
<p id="p-0084" num="0083">The displacement field <b>313</b> is computed as j plus the difference between the lengths of the to and from strings. For all elements in the stack, the character field <b>314</b> is set to the respective character in the to string, the cost field <b>315</b> is left undefined, and the saved cost field <b>316</b> is initialized to infinity.</p>
<p id="p-0085" num="0084"><figref idref="DRAWINGS">FIG. 3B</figref> shows a worked example of TCR elements <b>331</b>-<b>338</b> indexed by (pos, j) pairs <b>341</b>-<b>348</b>. In the worked example, the input pattern is &#x201c;patetrn&#x201d;, and the pre-processing procedure has to map the rule &#x201c;ttt (10)&#x201d; to the TCR elements <b>331</b>-<b>338</b>.</p>
<p id="p-0086" num="0085">Let step_be 1000 and max_ins=max_del=1.</p>
<p id="p-0087" num="0086">The elements are only there when a match between the rule and the pattern is made at the place defined by the (pos, j) pair. The rule &#x201c;t-&#x3e;tt&#x201d; is only applicable at the positions after a &#x201c;t&#x201d; in the pattern, i.e. 3 and 5.</p>
<p id="p-0088" num="0087">Taking into consideration the possible displacements (&#x2212;1 to 1), the list of applicable places becomes (4, &#x2212;1), (3, 0), (2, 1), (6, &#x2212;1), (5, 0), (4, 1). In (2, 1) and (4, 1) the displacement before applying the rule (the value in the rule's initial element's displacement field) is 2, which is outside the permitted range, thus these two are deleted. Additionally, the rule output is two characters long, that is why the TCR stacks are of length <b>2</b> (shown by the connecting arrows from the &#x201c;previous&#x201d; field), ending at the four places remaining</p>
<p id="p-0089" num="0088">This results in the eight TCR elements <b>331</b>-<b>338</b> shown in <figref idref="DRAWINGS">FIG. 3B</figref>, which are four TCR element stacks each of two elements.</p>
<p id="p-0090" num="0089">TCR elements (3, &#x2212;1) <b>333</b> and (4, &#x2212;1) <b>334</b> are the two elements of one stack referring to the application of the rule to the third character of the pattern, where the displacement after the application of the rule is &#x2212;1.</p>
<p id="p-0091" num="0090">Matching &#x201c;pattern&#x201d; with &#x201c;patetrn&#x201d; will apply this rule to match &#x201c;pa&#x201d; with &#x201c;pa&#x201d; at displacement 0, &#x201c;tt&#x201d; with &#x201c;t&#x201d; by the TC rule, &#x201c;e&#x201d; with &#x201c;e&#x201d; at displacement &#x2212;1, &#x201c; &#x201d; with &#x201c;t&#x201d; as a deletion, and &#x201c;rn&#x201d; with &#x201c;rn&#x201d; at displacement 0.</p>
<p id="p-0092" num="0091">In this example, TCR element <b>333</b> is for character position 3 with displacement &#x2212;1 and has the following fields:</p>
<p id="p-0093" num="0092">It is an initial element and therefore the previous field <b>311</b> is set to &#x201c;null&#x201d;.</p>
<p id="p-0094" num="0093">The initial_cost field <b>312</b> is the rule's cost (10) plus the product of the step_cost (1000) and the length of the rule's to string (2) (which gives, 10+(1000*2)=2010).</p>
<p id="p-0095" num="0094">The displacement field <b>313</b> is j plus the difference between the lengths of the to and from strings (which gives, &#x2212;1+1=0).</p>
<p id="p-0096" num="0095">The character field <b>314</b> is the rule's first character in the to string (t).</p>
<p id="p-0097" num="0096">The cost field <b>315</b> is left undefined (?).</p>
<p id="p-0098" num="0097">The saved field <b>316</b> is initialized as infinity.</p>
<p id="p-0099" num="0098">The next TCR element <b>334</b> is for character position 4 with displacement &#x2212;1 and has the following fields:</p>
<p id="p-0100" num="0099">It is a non-initial element and therefore the previous field <b>311</b> links to TCR element <b>333</b> for (pos&#x2212;1, j), namely (4&#x2212;1, &#x2212;1).</p>
<p id="p-0101" num="0100">The initial_cost field <b>312</b> is set to 0 as this element in not initial.</p>
<p id="p-0102" num="0101">The displacement field <b>313</b> is arbitrarily chosen as displacement is not relevant for non-initial elements.</p>
<p id="p-0103" num="0102">The character field <b>314</b> is the rule's second character in the to string (t).</p>
<p id="p-0104" num="0103">The cost field <b>315</b> is left undefined (?).</p>
<p id="p-0105" num="0104">The saved field <b>316</b> is initialized as infinity.</p>
<p id="p-0106" num="0105">The structures shown in <figref idref="DRAWINGS">FIGS. 3A and 3B</figref> provide a mechanism by which rules can be applied to multiple character positions with an allocated cost. In use, during a traverse of a trie, the rules are applied and the cost and cost minima are saved to the matrices <b>222</b>, <b>223</b> and to the TCR elements <b>224</b> for relevant positions.</p>
<p id="p-0107" num="0106">The purpose of the TCR stacks is to filter out all irrelevant rules, and to make it very easy to translate the applicable rules to costs when the actual characters from the trie are gathered. In case of a mismatched rule, the process simply computes an infinite cost. The TCRs are stored in stacks, because this format directly matches trie traversal: every time the procedure steps through a transition in the trie the TCR stack records the relevant information for the new node, and that information is readily available for all children to that node.</p>
<p id="p-0108" num="0107">The cost of the correction rules is given by the user, it is not evaluated by the cost it takes to transform things inside the correction rule. For example, there can be a transition rule &#x201c;ck(10)&#x201d;, and, simultaneously, a cost 45 for substitution.</p>
<p id="p-0109" num="0108">Here, the cost 10 is a parameter to the method and not computed as 45, although it takes a substitution to convert c to k. Both the rule and substitution apply to &#x201c;disc&#x201d;. What the method will use is the operation with lower cost, which in this case will be the correction rule.</p>
<p id="p-0110" num="0109">The basic edit operations insertion, deletion, substitution and transposition can also be viewed as correction rules, ones that are always available. One of the differences between this method and previous ones is the omission of transposition as a basic operation in the process itself, because it is translated to correction rules.</p>
<p id="p-0111" num="0110">The pre-processing procedure converts the transpositions possible in the pattern into correction rules (e.g. it generates rules &#x201c;peep (cost_tra)&#x201d; and &#x201c;ette (cost_tra)&#x201d; for the pattern &#x201c;pet&#x201d;) and then translates all applicable correction rules into TCR stacks. Various methods of implementing this procedure may be used, with various storage formats for the rules, and various levels of flexibility in the rules specification (such as, for example, a way to specify that &#x201c;aaa(10)&#x201d; should be a rule for any a).</p>
<p id="p-0112" num="0111">The traverse procedure finds full and partial left hand side matches for the pattern. The partial matches are stored in lists partial, and also reflected as minimum costs in the saved matrix and the saved field of TCR elements. The procedure then iterates through all positions for which there is a partial match, and uses the saved costs as starting points for right hand side match look-ups. The partial matches found are added to the respective lists. The full matches are then combined with all left hand side word parts in the current list, recursively adding other left hand side parts if needed.</p>
<p id="p-0113" num="0112">The minima saved in both the TCR elements' saved field and the saved matrix form best-case scenarios for the subsequent right hand side look-up. If a rule can be applied starting from one of the partial left hand side matches, the best cost with which it can be applied is used for the look-up. If a right hand side word part matches the rest of the characters in the rule, the saved cost will be applied. Paired with the saved accumulated cost minima, this ensures that whenever l+r has a certain cost in relation to the pattern, the cost with which r will be found in the secondary look-up will be at most as high. Hence, all right hand side matches, which could yield a low enough cost in combination with some left hand side part, will be found.</p>
<p id="p-0114" num="0113">Referring to <figref idref="DRAWINGS">FIG. 4</figref>, a flow diagram <b>400</b> shows the main method of the described example embodiment. The method is for determining suggestions <b>401</b> for an input pattern with a defined dictionary and defined rules, suggestions(pattern, dict, rules).</p>
<p id="p-0115" num="0114">In a pre-processing step <b>402</b>, TCRs are produced for possible transitions in the input pattern and the TCRs applicable to the input pattern are processed to generate TCR element lists tcrs[pos, j] for all pos and j, as shown in <figref idref="DRAWINGS">FIGS. 3A and 3B</figref>.</p>
<p id="p-0116" num="0115">Parameters are set <b>403</b> as:</p>
<p id="p-0117" num="0116">max_len=length(pattern)+max_del;</p>
<p id="p-0118" num="0117">partial=new empty list[max_len];</p>
<p id="p-0119" num="0118">for all j&#x3c;0: cost[j]=max_cost;</p>
<p id="p-0120" num="0119">cost[0]=0</p>
<p id="p-0121" num="0120">for all j&#x3e;0: cost[j]=cost[j&#x2212;1]+cost_del</p>
<p id="p-0122" num="0121">A sub-routine <b>404</b> is then carried out to traverse through the trie to find partial or full matches to the left hand side of the input pattern, match=traverse (dict.root, 1, partial). This sub-routine <b>404</b> is described below with reference to <figref idref="DRAWINGS">FIG. 6</figref>.</p>
<p id="p-0123" num="0122">Starting at pos=1 <b>405</b>, it is determined <b>406</b> if there is no partial match at the current position, partial[pos]=[ ]. If so, the method skips all processing for this position to <b>407</b>.</p>
<p id="p-0124" num="0123">Otherwise, the method looks for right hand side matches to be combined with the partial left hand side matches already found. The partial matches are stored in lists partial and the saved costs are used <b>410</b> to form the initial state for the right-hand side lookup:</p>
<p id="p-0125" num="0124">for all j:</p>
<p id="p-0126" num="0125">cost[pos, j]=saved[pos, j]; and</p>
<p id="p-0127" num="0126">for all j and all tcr in tcrs[pos, j]:</p>
<p id="p-0128" num="0127">tcr.cost=tcr.save.</p>
<p id="p-0129" num="0128">A sub-routine <b>411</b> is carried out to find matches for the right hand side of the input pattern starting from the position of the partial left hand side match, right=traverse(dict.root, pos+1, partial). Again, this sub-routine is described below with reference to <figref idref="DRAWINGS">FIG. 6</figref>.</p>
<p id="p-0130" num="0129">A sub-routine <b>412</b> is carried out to combine the right hand side matches with the left hand side matches, for all r in right: combine(pos, r, match). This combining sub-routine <b>412</b> is shown in detail in <figref idref="DRAWINGS">FIG. 5</figref>.</p>
<p id="p-0131" num="0130">After the sub-routine <b>412</b>, the loop iterates to pos=pos+1, <b>407</b> and the loop repeats for the next position of a partial left hand side match until the pos is the max_len <b>408</b> and all gathered matches in the list match are returned <b>409</b>.</p>
<p id="p-0132" num="0131">Referring to <figref idref="DRAWINGS">FIG. 5</figref>, the combination of word parts is done recursively, so that several word parts can be combined. For example, for an input pattern &#x201c;doens'tdo&#x201d; the method finds partial matches &#x201c;does&#x201d; in partial[4], &#x201c;n&#x2032;t&#x201d; in partial[8] and full match &#x201c;do&#x201d; from position 8. The combination procedure should be able to compose this into &#x201c;doesn't do&#x201d;. As an alternative, multiple word parts may be combined using the generation and traversal of a secondary trie.</p>
<p id="p-0133" num="0132"><figref idref="DRAWINGS">FIG. 5</figref> shows the sub-routine <b>412</b> of <figref idref="DRAWINGS">FIG. 4</figref> for combining right hand side matches with left hand side partial matches, combine(pos, r, match) <b>501</b>. A first word l extracted from the partial list partial[pos] <b>502</b>. It is determined <b>503</b> if the length of l equals pos. If not, the procedure is called recursively <b>504</b> to combine shorter left hand side matches with the concatenation of word parts l and r, combine(pos&#x2212;length(l), l+r, match).</p>
<p id="p-0134" num="0133">If it is determined <b>503</b> that the length(l)=pos, the cost of l+r is evaluated <b>505</b> and the combination is added to the match list.</p>
<p id="p-0135" num="0134">The method then loops to the next word <b>506</b>, l=next word. It is determined if there is a next word <b>507</b>, l=null. If there is a next word, the method loops to determine <b>503</b> if the length of the new word length(l)=pos. If there is no next word, the process ends <b>508</b>.</p>
<p id="p-0136" num="0135">Referring to <figref idref="DRAWINGS">FIG. 6</figref>, the procedure for trie traversal is shown. It traverses the node recursively; simple edit operations as well as correction rules are applied after each new character is processed.</p>
<p id="p-0137" num="0136">The recursive processing of new branches is:</p>
<p id="p-0138" num="0137">restricted to only the characters that either match characters at active positions in the pattern or are in applicable outstanding correction rules;</p>
<p id="p-0139" num="0138">dropped altogether if such characters are not present; or</p>
<p id="p-0140" num="0139">fully performed if the accumulated costs are still below the threshold (defined as max_cost&#x2212;min(cost_sub, cost_ins)).</p>
<p id="p-0141" num="0140">In detail, referring to <figref idref="DRAWINGS">FIG. 6</figref>, a traverse <b>601</b> traverse(node, pos, partial) is carried out. Matches are defined <b>602</b> as matches=[ ]. Next is defined <b>603</b> as next=nodenext transition, with c=character for transition. It is determined <b>604</b> if next=null; if so, the matches are returned <b>605</b> and the procedure ends. If next&#x2260;null, a sub-process <b>606</b> is carried out to process a new character, for all j: process transition (pos, j, c). This sub-process <b>606</b> is described below with reference to <figref idref="DRAWINGS">FIGS. 7A and 7B</figref>.</p>
<p id="p-0142" num="0141">It is then determined <b>607</b> if next is final AND cost[pos, max_pos-pos]&#x3c;max_cost. In other words, if the next node is a final node and the cost is less than the defined maximum allowed cost. If so, the word is added <b>608</b> to the matches list.</p>
<p id="p-0143" num="0142">The minimum cost is determined <b>609</b>, me=min cost[pos, j] for all j. It is then determined <b>610</b> if the position is less than the max_len. If not, the procedure loops via symbol &#x201c;1&#x201d; <b>611</b> to process the next transition <b>603</b>. Otherwise, it is determined <b>612</b> if the minimum cost is less than a predefined threshold, mc&#x3c;threshold.</p>
<p id="p-0144" num="0143">If the minimum cost is not less than the threshold max_cost&#x2212;min(cost_sub, cost_ins)), a list variable constrain (cn) is defined <b>613</b> to restrict the characters to be processed in the next node. Pattern[pos+1+j] is added <b>614</b> to cn for all j such that cost[pos, j]&#x3c;max_cost. A sub-routine <b>615</b> is carried out for all displacements in the TCR elements to add the relevant characters to the constrain set, for all j for all tcr in tcrs[pos, j]: add continuation (ter, cn). This sub-routine <b>615</b> is described with reference to <figref idref="DRAWINGS">FIG. 8</figref> below. It is then determined if cn is empty <b>616</b>, and if so, the procedure loops via symbol &#x201c;1&#x201d; <b>611</b> to process the next transition <b>603</b>.</p>
<p id="p-0145" num="0144">If it is determined <b>612</b> that the minimum cost is less than the threshold, the constrain set is set to all the characters <b>617</b>.</p>
<p id="p-0146" num="0145">If cn is not empty <b>616</b>, the procedure then determines <b>618</b> if next is a word segment. If so, a sub-routine <b>619</b> is carried out to reflect the accumulated weight in the saved costs and TRC cost minima, process part(pos). This sub-routine is described below with reference to <figref idref="DRAWINGS">FIG. 9</figref>.</p>
<p id="p-0147" num="0146">It is then determined <b>620</b> if next is final. If so, a word separator is added <b>621</b>, for all j: process transition (pos+1, j, word separator). A sub-routine <b>622</b> is then carried out to reflect the accumulated weight as a saved cost and TRC cost minima for the next position, process part (pos+1). This is the same sub-routine as <b>619</b> and described below with reference to <figref idref="DRAWINGS">FIG. 9</figref>.</p>
<p id="p-0148" num="0147">The next node is then restricted to the characters in the constrain set <b>623</b>, the sub-routine <b>624</b> continues the node traverse from the next node, and the results are added to the list of matches, matches.add (traverse(next, pos+1, partial)). The procedure then loops from symbol &#x201c;1&#x201d; <b>611</b> to process the next transition <b>603</b>.</p>
<p id="p-0149" num="0148">Referring now to <figref idref="DRAWINGS">FIGS. 7A and 7B</figref>, the sub-routine <b>606</b> of processing transitions is described. Processing a new character is done by applying the basic operations to compute new costs for all displacements, and computing new TCR element costs from the TCR stack's previous element's cost or, if the element is initial, one of the accumulated costs in the previous position. A mismatch of the expected character and the processed one sets the cost to infinity which ensures that this TCR stack will not yield a cost that may be used by the minimum operation in process transition.</p>
<p id="p-0150" num="0149">In detail, process transition (pos, j, c) is carried out <b>701</b>. The cost is defined <b>702</b> as the minimum of the costs of: the cost of the previous position with displacement j plus the cost of substitution; the cost of the previous position with displacement j+1 plus the cost of insertion; and the cost of the current position with displacement j&#x2212;1 plus the cost of deletion. Which is cost=min(cost[pos&#x2212;1, j]+cost_sub, cost[pos&#x2212;1, j+1]+cost_ins, cost[pos, j&#x2212;1]+cost_del).</p>
<p id="p-0151" num="0150">It is determined <b>703</b> if the character for transition matches the pattern at (pos, j), c=pattern[pos+j]. If so, the cost is set <b>704</b> as the minimum of the cost and the cost at the previous position, cost=min(cost, cost[pos&#x2212;1, j]).</p>
<p id="p-0152" num="0151">A sub-routine <b>705</b> is then carried out for all the TCR elements to apply the TCR costs, for all tcr in tcrs[pos, j]: cost=min(cost, process TCR (tcr,c)). This sub-routine <b>705</b> is described in <figref idref="DRAWINGS">FIG. 7B</figref>. The cost is then set in the cost matrix, cost[pos, j]=cost and the process ends <b>707</b>.</p>
<p id="p-0153" num="0152"><figref idref="DRAWINGS">FIG. 7B</figref>, shows the sub-routine <b>705</b> of process TCR (tcr, c) <b>710</b>. It is determined <b>711</b> if the TCR element's initial_cost is zero, tcr.initial_cost=0. If so, the previous cost is set to the previous TCR element's cost <b>712</b>, prev_cost=tcr.previous.cost. If not, the previous cost is set to the TCR element's initial_cost plus the cost of the previous position <b>713</b>, prev_cost=tcr.initial_cost+cost[pos&#x2212;1, tcr.displacement].</p>
<p id="p-0154" num="0153">It is then determined <b>714</b>, if the TCR element's character matches the character for transition, tcr.character=c. If so, the TCR element's cost is set to the previous cost minus the step cost <b>715</b>, tcr.cost=prev_cost&#x2212;step_cost. If not, the TCR element's cost is set to infinity <b>716</b>, tcr.cost=infinity. The TCR element's cost is returned <b>717</b>.</p>
<p id="p-0155" num="0154">Referring to <figref idref="DRAWINGS">FIG. 8</figref>, the sub-routine for finding if a TCR is still applicable is described as used at box <b>615</b> of <figref idref="DRAWINGS">FIG. 6</figref>. Add continuation for a TCR element is defined <b>801</b>. It is determined <b>802</b> if the TCR element's cost is less than infinity, tcr.cost&#x3c;infinity. If so, it is determined <b>803</b> if the TCR cost modulus of the step cost is less than the maximum cost, tcr.cost mod step_cost&#x3c;max_cost. If so, the TCR element's character is added to the set of constrain characters cn <b>804</b>. The sub-routine then ends <b>805</b>.</p>
<p id="p-0156" num="0155">Referring to <figref idref="DRAWINGS">FIG. 9</figref>, the sub-routine applied when a partial match is found, to reflect the accumulated weights the saved cost and TCR cost minima is described as used at boxes <b>619</b> and <b>622</b> of <figref idref="DRAWINGS">FIG. 6</figref>.</p>
<p id="p-0157" num="0156">Process partial match for a position is defined <b>901</b>, process part(pos). The word is added to the list partial[pos] <b>902</b>.</p>
<p id="p-0158" num="0157">The saved cost matrix is set as the minimum of the saved cost and the cost for the position and displacement <b>903</b>, for all j: saved[pos, j]=min(saved[pos, j], cost[pos, j]).</p>
<p id="p-0159" num="0158">The TCR elements' saved cost is set as the minimum of the saved cost and the cost <b>904</b>, for all j and for all tcr in tcrs[pos, j]: tcr.saved=min(tcr.saved, tcr.cost). The sub-routine then ends <b>905</b>.</p>
<heading id="h-0007" level="1">Worked EXAMPLE 1</heading>
<p id="p-0160" num="0159">Referring to <figref idref="DRAWINGS">FIG. 10A</figref>, a worked example is provided to illustrate the described method further. The worked example follows the steps through the trie structure <b>1000</b> shown in <figref idref="DRAWINGS">FIG. 10A</figref>. This example shows the working of the TCR stack mechanism. Decompounding of words is not shown in this example.</p>
<p id="p-0161" num="0160">Input pattern &#x201c;adn&#x201d;</p>
<p id="p-0162" num="0161">Input parameters:</p>
<p id="p-0163" num="0162">cost_del=35</p>
<p id="p-0164" num="0163">cost_ins=30</p>
<p id="p-0165" num="0164">cost_sub=45</p>
<p id="p-0166" num="0165">cost_tra=25</p>
<p id="p-0167" num="0166">step_cost=1000</p>
<p id="p-0168" num="0167">max_ins=max_del=1</p>
<p id="p-0169" num="0168">TC rules:</p>
<p id="p-0170" num="0169">1: a-&#x3e;u (10)</p>
<p id="p-0171" num="0170">2: d-&#x3e;s (20)</p>
<p id="p-0172" num="0171">3: d-&#x3e;dd (10)</p>
<p id="p-0173" num="0172">4: do-&#x3e;n (10)</p>
<p id="p-0174" num="0173">Additionally (transposition rules):</p>
<p id="p-0175" num="0174">5: ad-&#x3e;da (25)</p>
<p id="p-0176" num="0175">6: dn-&#x3e;nd (25)</p>
<p id="p-0177" num="0176">After matching rules with the input pattern, TCR data looks as follows. Only the relevant fields are shown. For example, the cost field is initially left undefined and therefore not shown, and the saved cost minima field applies to decompounding which is not shown in this example. Each TCR element is indexed by [pos, j, count]:</p>
<p id="p-0178" num="0177">[1, 0,0]: char d init 2025 disp 0</p>
<p id="p-0179" num="0178">[1, 0,1]: char u init 1010 disp 0</p>
<p id="p-0180" num="0179">[1, 0,2]: char d init 2010 disp 1</p>
<p id="p-0181" num="0180">[1, 1,0]: char n init 2025 disp 1</p>
<p id="p-0182" num="0181">[1, 1,1]: char s init 1020 disp 1</p>
<p id="p-0183" num="0182">[2,&#x2212;1,0]: char d init 2025 disp &#x2212;1</p>
<p id="p-0184" num="0183">[2,&#x2212;1,1]: char u init 1010 disp &#x2212;1</p>
<p id="p-0185" num="0184">[2,&#x2212;1,2]: char d init 2010 disp 0</p>
<p id="p-0186" num="0185">[2, 0,0]: char a prev [1, 0,0]</p>
<p id="p-0187" num="0186">[2, 0,1]: char n init 2025 disp 0</p>
<p id="p-0188" num="0187">[2, 0,2]: char s init 1020 disp 0</p>
<p id="p-0189" num="0188">[2, 0,3]: char d prev [1, 0,2]</p>
<p id="p-0190" num="0189">[2, 1,0]: char d prev [1, 1,0]</p>
<p id="p-0191" num="0190">[2, 1,1]: char n init 1010 disp 0</p>
<p id="p-0192" num="0191">[3,&#x2212;1,0]: char a prev [2,&#x2212;1,0]</p>
<p id="p-0193" num="0192">[3,&#x2212;1,1]: char n init 2025 disp &#x2212;1</p>
<p id="p-0194" num="0193">[3,&#x2212;1,2]: char s init 1020 disp &#x2212;1</p>
<p id="p-0195" num="0194">[3,&#x2212;1,3]: char dprev [2,&#x2212;1,2]</p>
<p id="p-0196" num="0195">[3, 0,0]: char d prev [2, 0,1]</p>
<p id="p-0197" num="0196">[3, 0,1]: char n init 1010 disp &#x2212;1</p>
<p id="p-0198" num="0197">[4,&#x2212;1,0]: char dprev [3,&#x2212;1,1]</p>
<heading id="h-0008" level="1">EXAMPLE 1A</heading>
<heading id="h-0009" level="1">max_cost=50</heading>
<p id="p-0199" num="0198">After processing at each step, only the cost field of the TCR elements is shown as this is the only field that changes.</p>
<p id="p-0200" num="0199">Step 0. Before starting, the costs are initialized as, cost for position 0,</p>
<p id="p-0201" num="0200">displacement &#x2212;1, 0, or 1:</p>
<p id="p-0202" num="0201">Cost[0]: &#x2212;1:&#x221e;0:0 1:35</p>
<p id="p-0203" num="0202">Step 1. Processing the first character &#x2018;a&#x2019; to go to State 1.</p>
<p id="p-0204" num="0203">Pos 1, gathered string: a</p>
<p id="p-0205" num="0204">Cost[1]: &#x2212;1:30 0:0 1:35</p>
<p id="p-0206" num="0205">TCR rules:</p>
<p id="p-0207" num="0206">[1,0]: [0:&#x221e;] [1:&#x221e;] [2:&#x221e;]</p>
<p id="p-0208" num="0207">[1,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0209" num="0208">&#x2212;1:30 is the result of insertion, the actual value is computed as Cost[0, 0]+cost_ins.</p>
<p id="p-0210" num="0209">0:0 is the result of a match of the character &#x2018;a&#x2019; in the pattern with &#x2018;a&#x2019; in the trie transition, computed as Cost[0, 0]+0.</p>
<p id="p-0211" num="0210">1:35 is the result of deletion, computed as Cost[1, 0]+cost_del.</p>
<p id="p-0212" num="0211">None of the TCR stack elements in this position match the character &#x2018;a&#x2019;, thus all TCR element costs are set to &#x2212;.</p>
<p id="p-0213" num="0212">Step 2. Processing second character &#x2018;n&#x2019; to go to State 2.</p>
<p id="p-0214" num="0213">Pos 2, gathered string: an</p>
<p id="p-0215" num="0214">Cost[2]: &#x2212;1:30 0:45*1:10</p>
<p id="p-0216" num="0215">TCR rules:</p>
<p id="p-0217" num="0216">[2,&#x2212;1]: [0:&#x221e;] [1:&#x221e;] [2:&#x221e;]</p>
<p id="p-0218" num="0217">[2,0]: [0:&#x221e;] [1:1025] [2:&#x221e;] [3:&#x221e;]</p>
<p id="p-0219" num="0218">[2,1]: [0:&#x221e;] [1:10]</p>
<p id="p-0220" num="0219">&#x2212;1:30 again comes as the result of an insertion applied from Cost[1, 0].</p>
<p id="p-0221" num="0220">0:45 results from substitution (since &#x2018;n&#x2019; does not match the &#x2018;d&#x2019; in the pattern) applied to Cost[1, 0].</p>
<p id="p-0222" num="0221">Rules [2,0,1] and [2,1,1] match the target character. The former results in cost 1025, computed as Cost[1,0]+2025&#x2212;step_cost. The 0 in Cost[1,0] comes from the disp field of the TCR element, 2025 from the init field. The latter results in cost 10 (Cost[1,0]+1010&#x2212;step_cost). The former is taken into account to form Cost[2,0], but since it is too big it does not influence the result. The latter is applied in Cost[2,1] which results in the value 10 for that accumulated cost.</p>
<p id="p-0223" num="0222">The &#x2018;*&#x2019; before 1:10 denotes that at this point pos+1 matches the pattern length, i.e. this is a point where a match has been found and the accumulated cost can be used as the final cost for this match. &#x2018;an(10)&#x2019; is added to the list of results.</p>
<p id="p-0224" num="0223">Step 3. Processing third character T to go to State 3.</p>
<p id="p-0225" num="0224">Pos 3, gathered string: ant</p>
<p id="p-0226" num="0225">Cost[3]: &#x2212;1:75*0:40 1:55</p>
<p id="p-0227" num="0226">TCR rules:</p>
<p id="p-0228" num="0227">[3,&#x2212;1]: [0:&#x221e;] [1:&#x221e;] [2:&#x221e;] [3:&#x221e;]</p>
<p id="p-0229" num="0228">[3,0]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0230" num="0229">&#x2018;ant(40)&#x2019; is added to the list of results. The value comes from Cost[2,1]+cost_ins.</p>
<p id="p-0231" num="0230">Step 4. Backtracking to State 2. There is nothing to modify, the values for Cost and TCRs are already computed at Step 2.</p>
<p id="p-0232" num="0231">Step 5. Processing third character &#x2018;d.&#x2019; to go to State 4.</p>
<p id="p-0233" num="0232">Pos 3, gathered string: and</p>
<p id="p-0234" num="0233">Cost[3]: &#x2212;1:30*0:25 1:55</p>
<p id="p-0235" num="0234">TCR rules:</p>
<p id="p-0236" num="0235">[3,&#x2212;1]: [0:&#x221e;] [1:&#x221e;] [2:&#x221e;] [3:&#x221e;]</p>
<p id="p-0237" num="0236">[3,0]: [0:25] [1:&#x221e;]</p>
<p id="p-0238" num="0237">The new costs and TCR element values overwrite the ones computed at Step 3 (which are no longer needed). Rule [3,0,0] is a character match, the value 25 is computed as 1025&#x2212;step_cost, where 1025 is the cost of the previous element for this TCR element, i.e. [2,0,1] whose value was computed at Step 2. The cost 25 is applied in computing Cost[3,0]. The word &#x2018;and(25)&#x2019; is added to the list of suggestions.</p>
<p id="p-0239" num="0238">This is what the full state of the suggestions search looks like after this step:</p>
<p id="p-0240" num="0239">Pos 3, gathered string: and</p>
<p id="p-0241" num="0240">Cost[0]: &#x2212;1:&#x221e;0:0 1:35</p>
<p id="p-0242" num="0241">Cost[1]: &#x2212;1:30 0:0 1:35</p>
<p id="p-0243" num="0242">Cost[2]: &#x2212;1:30 0:45*1:10</p>
<p id="p-0244" num="0243">Cost[3]: &#x2212;1:30*0:25 1:55</p>
<p id="p-0245" num="0244">TCR rules:</p>
<p id="p-0246" num="0245">[1,0]: [0:&#x221e;] [1:&#x221e;] [2:&#x221e;]</p>
<p id="p-0247" num="0246">[1,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0248" num="0247">[2,&#x2212;1]: [0:&#x221e;] [1:&#x221e;] [2:&#x221e;]</p>
<p id="p-0249" num="0248">[2,0]: [0:&#x221e;] [1:1025] [2:&#x221e;] [3:&#x221e;]</p>
<p id="p-0250" num="0249">[2,1]: [0:&#x221e;] [1:10]</p>
<p id="p-0251" num="0250">[3,&#x2212;1]: [0:&#x221e;] [1:&#x221e;] [2:&#x221e;] [3:&#x221e;]</p>
<p id="p-0252" num="0251">[3,0]: [0:25] [1:&#x221e;]</p>
<p id="p-0253" num="0252">Step 6. Backtracking to State 2. No modifications to the state, but everything computed for pos 3 is no longer relevant. I.e. the full state is now:</p>
<p id="p-0254" num="0253">Pos 2, gathered string: an</p>
<p id="p-0255" num="0254">Cost[0]: &#x2212;1:&#x221e;0:0 1:35</p>
<p id="p-0256" num="0255">Cost[1]: &#x2212;1:30 0:0 1:35</p>
<p id="p-0257" num="0256">Cost[2]: &#x2212;1:30 0:45*1:10</p>
<p id="p-0258" num="0257">TCR rules:</p>
<p id="p-0259" num="0258">[1,0]: [0:&#x221e;] [1:&#x221e;] [2:&#x221e;]</p>
<p id="p-0260" num="0259">[1,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0261" num="0260">[2,&#x2212;1]: [0:&#x221e;] [1:&#x221e;] [2:&#x221e;]</p>
<p id="p-0262" num="0261">[2,0]: [0:&#x221e;] [1:1025] [2:&#x221e;] [3:&#x221e;]</p>
<p id="p-0263" num="0262">[2,1]: [0:&#x221e;] [1:10]</p>
<p id="p-0264" num="0263">Step 7. Backtracking to State 1. No modifications to the state, but everything computed for pos 3 is no longer relevant. I.e. the full state is now:</p>
<p id="p-0265" num="0264">Pos 1, gathered string: a</p>
<p id="p-0266" num="0265">Cost[0]: &#x2212;1:&#x221e;0:0 1:35</p>
<p id="p-0267" num="0266">Cost[1]: &#x2212;1:30 0:0 1:35</p>
<p id="p-0268" num="0267">TCR rules:</p>
<p id="p-0269" num="0268">[1,0]: [0:&#x221e;] [1:&#x221e;] [2:&#x221e;]</p>
<p id="p-0270" num="0269">[1,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0271" num="0270">Step 8. Processing second character &#x2018;s&#x2019; to go to State 5.</p>
<p id="p-0272" num="0271">Pos 2, gathered string: as</p>
<p id="p-0273" num="0272">Cost[2]: &#x2212;1:30 0:20*1:55</p>
<p id="p-0274" num="0273">TCR rules:</p>
<p id="p-0275" num="0274">[2,&#x2212;1]: [0:&#x221e;] [1:&#x221e;] [2:&#x221e;]</p>
<p id="p-0276" num="0275">[2,0]: [0:&#x221e;] [1:&#x221e;] [2:20] [3:&#x221e;]</p>
<p id="p-0277" num="0276">[2,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0278" num="0277">Rule element [2,0,2] leads to the value 20 for Cost[2,0], which is also used to compute Cost[2,1], the final result for the suggestion &#x2018;as(55)&#x2019;. However, since the accumulated cost for that suggestion is bigger than max_cost, the word is not added to the suggestions list.</p>
<p id="p-0279" num="0278">Step 9. Backtracking to state 1.</p>
<p id="p-0280" num="0279">Step 10. Processing second character &#x2018;d.&#x2019; to go to State 6.</p>
<p id="p-0281" num="0280">Pos 2, gathered string: ad</p>
<p id="p-0282" num="0281">Cost[2]: &#x2212;1:30 0:0*1:35</p>
<p id="p-0283" num="0282">TCR rules:</p>
<p id="p-0284" num="0283">[2,&#x2212;1]: [0:1055] [1:&#x221e;] [2:1010]</p>
<p id="p-0285" num="0284">[2,0]: [0:&#x221e;] [1:&#x221e;] [2:&#x221e;] [3:&#x221e;]</p>
<p id="p-0286" num="0285">[2,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0287" num="0286">&#x2018;ad(35)&#x2019; is a suggestion; there are two potential TCR matches for the next step.</p>
<p id="p-0288" num="0287">Step 11. Processing third character &#x2018;s&#x2019; to go to State 7.</p>
<p id="h-0010" num="0000">Pos 3, gathered string: ads</p>
<p id="p-0289" num="0288">Cost[3]: &#x2212;1:30*0:45 1:80</p>
<p id="p-0290" num="0289">TCR rules:</p>
<p id="p-0291" num="0290">[3,&#x2212;1]: [0:&#x221e;] [1:&#x221e;] [2:50] [3:&#x221e;]</p>
<p id="p-0292" num="0291">[3,0]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0293" num="0292">Both potential TCR matches failed, &#x2018;ads(45)&#x2019; is the result of substitution.</p>
<p id="p-0294" num="0293">Step 12. Backtracking to State 6.</p>
<p id="p-0295" num="0294">Step 13. Processing second character &#x2018;d.&#x2019; to go to State 8.</p>
<p id="p-0296" num="0295">Pos 3, gathered string: add</p>
<p id="p-0297" num="0296">Cost[3]: &#x2212;1:10*0:45 1:80</p>
<p id="p-0298" num="0297">TCR rules:</p>
<p id="p-0299" num="0298">[3,&#x2212;1]: [0:&#x221e;] [1:&#x221e;] [2:&#x221e;] [3:10]</p>
<p id="p-0300" num="0299">[3,0]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0301" num="0300">One of the matches that was potential at Step 10 pays off here. 0:45 is the result of either a substitution of &#x2018;n&#x2019; with &#x2018;d&#x2019;, or TCR rule d-&#x3e;dd and a deletion.</p>
<p id="p-0302" num="0301">Step 14. Backtracking to State 6.</p>
<p id="p-0303" num="0302">Step 15. Backtracking to State 1.</p>
<p id="p-0304" num="0303">Step 16. Backtracking to State 0.</p>
<p id="p-0305" num="0304">Done</p>
<p id="p-0306" num="0305">Suggestions:</p>
<p id="p-0307" num="0306">an</p>
<p id="p-0308" num="0307">and</p>
<p id="p-0309" num="0308">ad</p>
<p id="p-0310" num="0309">ant</p>
<p id="p-0311" num="0310">ads</p>
<p id="p-0312" num="0311">add</p>
<heading id="h-0011" level="1">EXAMPLE 1B</heading>
<heading id="h-0012" level="1">max_cost=30</heading>
<p id="p-0313" num="0312">In Example 1B, since max_cost is not bigger than the smaller of cost_sub and cost_ins, even accumulated cost 0 is not below the restriction threshold, which means that only steps in the trie that have potential will be investigated.</p>
<p id="p-0314" num="0313">After Step 1, the characters are gathered that match the characters in the pattern at positions pos+j where Cost[pos j] is smaller than max_cost. Here, this is only &#x2018;d&#x2019;. The TCR elements for pos=2 are examined for ones that could yield a low enough cost. In this case they are:</p>
<p id="p-0315" num="0314">[2,&#x2212;1,2]: char d init 2010 disp 0</p>
<p id="p-0316" num="0315">[2,0,1]: char n init 2025 disp 0</p>
<p id="p-0317" num="0316">[2,0,2]: char s init 1020 disp 0</p>
<p id="p-0318" num="0317">[2,1,1]: char n init 1010 disp 0</p>
<p id="p-0319" num="0318">The rest are rejected because their Cost[1,disp] or prev.cost modulo step_cost are not smaller than our max_cost.</p>
<p id="p-0320" num="0319">The final list of possible continuations cn is [&#x2018;d&#x2019;, &#x2018;n&#x2019;, &#x2018;s&#x2019;].</p>
<p id="p-0321" num="0320">After Step 2, a suggestion is output of &#x2018;an(10)&#x2019; and again possible continuations are looked for. Only Cost[2 &#x3bc;l] is less than max_cost, but the pattern does not have a fourth character, so no matching character is added to the continuations list cn.</p>
<p id="p-0322" num="0321">The TCR elements for pos=3 are:</p>
<p id="p-0323" num="0322">[3,&#x2212;1,0]: char a prev [2,&#x2212;1,0]</p>
<p id="p-0324" num="0323">[3,&#x2212;1,1]: char n init 2025 disp &#x2212;1</p>
<p id="p-0325" num="0324">[3,&#x2212;1,2]: char s init 1020 disp &#x2212;1</p>
<p id="p-0326" num="0325">[3,&#x2212;1,3]: char d prev [2,&#x2212;1,2]</p>
<p id="p-0327" num="0326">[3,0,0]: char d prev [2,0,1]</p>
<p id="p-0328" num="0327">[3,0,1]: char n init 1010 disp &#x2212;1</p>
<p id="p-0329" num="0328">Out of them only [3,0,0] could yield a low enough cost (since the cost of [2,0,1] is 1025, i.e. 25 after one step), thus only &#x2018;d&#x2019; is added to cn.</p>
<p id="p-0330" num="0329">Finally cn=[&#x2018;d&#x2019;].</p>
<p id="p-0331" num="0330">Since &#x2018;t&#x2019; is not in cn, we do not apply Steps 3 and 4.</p>
<p id="p-0332" num="0331">After Step 5 we output &#x2018;and(25)&#x2019;. The continuations list cn=[ ] because there are no more characters in the pattern and no rules lead to low cost.</p>
<p id="p-0333" num="0332">After Step 8, Cost[2,0] is low enough to permit &#x2018;n&#x2019; to be added to the list of constrained continuations. All TCR elements for pos=3 do not have a low cost potential.</p>
<p id="p-0334" num="0333">The final cn is [&#x2018;n&#x2019;], but the trie does not provide a transition for &#x2018;n&#x2019;.</p>
<p id="p-0335" num="0334">After Step 10, Cost[2,0] is low enough, thus &#x2018;n&#x2019; is added to cn. Out of the TCR elements for pos=3 only [3,&#x2212;1,3] could lead to cost 10 after 1 more step with character &#x2018;d&#x2019;, thus &#x2018;d&#x2019; is added to cn.</p>
<p id="p-0336" num="0335">The final cn is [&#x2018;n&#x2019;, &#x2018;d&#x2019;]. Steps 11 and 12 are skipped.</p>
<p id="p-0337" num="0336">After Step 13, Cost[3, &#x2212;1] is low, thus &#x2018;n&#x2019; (character with zero-based index 3&#x2212;1=2 in &#x2018;adn&#x2019;) is added to cn. This allows &#x201c;addn&#x201d; to be found if the trie had it.</p>
<p id="p-0338" num="0337">Final suggestions list:</p>
<p id="p-0339" num="0338">an</p>
<p id="p-0340" num="0339">and</p>
<heading id="h-0013" level="1">Worked EXAMPLE 2</heading>
<p id="p-0341" num="0340">Referring to <figref idref="DRAWINGS">FIG. 10B</figref>, a worked example is provided to illustrate the decompounding method further. The worked example follows the steps through the trie structure <b>1050</b> shown in <figref idref="DRAWINGS">FIG. 10B</figref>. The trie structure <b>1050</b> shows the words: do, door, done, does, n&#x2032;t (only as the end of compound word), and nut.</p>
<p id="p-0342" num="0341">Input pattern: &#x201c;doens' tdo&#x201d;</p>
<p id="p-0343" num="0342">Same costs as in worked example 1, with max_cost=40</p>
<p id="p-0344" num="0343">TCR rules:</p>
<p id="p-0345" num="0344">&#x2032;t-&#x3e;&#x2032;t_(10) (&#x2018;_&#x2019; stands for space)</p>
<p id="p-0346" num="0345">from transposition:</p>
<p id="p-0347" num="0346">do-&#x3e;od (25) at pos 2</p>
<p id="p-0348" num="0347">oe-&#x3e;eo (25) at pos 3</p>
<p id="p-0349" num="0348">en-&#x3e;ne (25) at pos 4</p>
<p id="p-0350" num="0349">ns-&#x3e;sn (25) at pos 5</p>
<p id="p-0351" num="0350">s&#x2032;-&#x3e;&#x2032;s (25) at pos 6</p>
<p id="p-0352" num="0351">&#x2018;t-&#x3e;t&#x2019; (25) at pos 7</p>
<p id="p-0353" num="0352">td-&#x3e;dt (25) at pos 8</p>
<p id="p-0354" num="0353">do-&#x3e;od (25) at pos 9</p>
<p id="p-0355" num="0354">TCR Stacks:</p>
<p id="p-0356" num="0355">[1, 0,0]: char o init 2.25 disp 0</p>
<p id="p-0357" num="0356">[1, 1,0]: char e init 2.25 disp 1</p>
<p id="p-0358" num="0357">[2,&#x2212;1,0]: char o init 2.25 disp &#x2212;1</p>
<p id="p-0359" num="0358">[2, 0,0]: char d prev [1, 0,0]</p>
<p id="p-0360" num="0359">[2, 0,1]: char e init 2.25 disp 0</p>
<p id="p-0361" num="0360">[2, 1,0]: char o prev [1, 1,0]</p>
<p id="p-0362" num="0361">[2, 1,1]: char n init 2.25 disp 1</p>
<p id="p-0363" num="0362">[3,&#x2212;1,0]: char d prev [2,&#x2212;1,0]</p>
<p id="p-0364" num="0363">[3,&#x2212;1,1]: char e init 2.25 disp &#x2212;1</p>
<p id="p-0365" num="0364">[3, 0,0]: char o prev [2, 0,1]</p>
<p id="p-0366" num="0365">[3, 0,1]: char n init 2.25 disp 0</p>
<p id="p-0367" num="0366">[3, 1,0]: char e prev [2, 1,1]</p>
<p id="p-0368" num="0367">[3, 1,1]: char s init 2.25 disp 1</p>
<p id="p-0369" num="0368">[4,&#x2212;1,0]: char o prev [3,&#x2212;1,1]</p>
<p id="p-0370" num="0369">[4,&#x2212;1,1]: char n init 2.25 disp &#x2212;1</p>
<p id="p-0371" num="0370">[4, 0,0]: char e prev [3, 0,1]</p>
<p id="p-0372" num="0371">[4, 0,1]: char s init 2.25 disp 0</p>
<p id="p-0373" num="0372">[4, 1,0]: char n prev [3, 1,1]</p>
<p id="p-0374" num="0373">[4, 1,1]: char&#x2032;init 2.25 disp 1</p>
<p id="p-0375" num="0374">[5,&#x2212;1,0]: char e prev [4,&#x2212;1,1]</p>
<p id="p-0376" num="0375">[5,&#x2212;1,1]: char s init 2.25 disp &#x2212;1</p>
<p id="p-0377" num="0376">[5, 0,0]: char n prev [4, 0,1]</p>
<p id="p-0378" num="0377">[5, 0,1]: char&#x2032;init 2.25 disp 0</p>
<p id="p-0379" num="0378">[5, 0,2]: char&#x2032;init 3.10 disp 1</p>
<p id="p-0380" num="0379">[5, 1,0]: char s prev [4, 1,1]</p>
<p id="p-0381" num="0380">[5, 1,1]: char t init 2.25 disp 1</p>
<p id="p-0382" num="0381">[6,&#x2212;1,0]: char n prev [5,&#x2212;1,1]</p>
<p id="p-0383" num="0382">[6,&#x2212;1,1]: char&#x2032;init 2.25 disp &#x2212;1</p>
<p id="p-0384" num="0383">[6,&#x2212;1,2]: char&#x2032;init 3.10 disp 0</p>
<p id="p-0385" num="0384">[6, 0,0]: char s prey [5, 0,1]</p>
<p id="p-0386" num="0385">[6, 0,1]: char t init 2.25 disp 0</p>
<p id="p-0387" num="0386">[6, 0,2]: char t prey [5, 0,2]</p>
<p id="p-0388" num="0387">[6, 1,0]: char&#x2032;prev [5, 1,1]</p>
<p id="p-0389" num="0388">[6, 1,1]: char d init 2.25 disp 1</p>
<p id="p-0390" num="0389">[7,&#x2212;1,0]: char s prev [6,&#x2212;1,1]</p>
<p id="p-0391" num="0390">[7,&#x2212;1,1]: char t init 2.25 disp &#x2212;1</p>
<p id="p-0392" num="0391">[7,&#x2212;1,2]: char t prev [6,&#x2212;1,2]</p>
<p id="p-0393" num="0392">[7, 0,0]: char&#x2032;prev [6, 0,1]</p>
<p id="p-0394" num="0393">[7, 0,1]: char prev [6, 0,2]</p>
<p id="p-0395" num="0394">[7, 0,2]: char d init 2.25 disp 0</p>
<p id="p-0396" num="0395">[7, 1,0]: chartprev [6, 1,1]</p>
<p id="p-0397" num="0396">[7, 1,1]: char o init 2.25 disp 1</p>
<p id="p-0398" num="0397">[8,&#x2212;1,0]: char&#x2032;prev [7,&#x2212;1,1]</p>
<p id="p-0399" num="0398">[8,&#x2212;1,1]: char prev [7,&#x2212;1,2]</p>
<p id="p-0400" num="0399">[8,&#x2212;1,2]: char d init 2.25 disp &#x2212;1</p>
<p id="p-0401" num="0400">[8, 0,0]: chartprev [7, 0,2]</p>
<p id="p-0402" num="0401">[8, 0,1]: char o init 2.25 disp 0</p>
<p id="p-0403" num="0402">[8, 1,0]: char dprev [7, 1,1]</p>
<p id="p-0404" num="0403">[9,&#x2212;1,0]: char t prev [8,&#x2212;1,2]</p>
<p id="p-0405" num="0404">[9,&#x2212;1,1]: char o init 2.25 disp &#x2212;1</p>
<p id="p-0406" num="0405">[9, 0,0]: char dprev [8, 0,1]</p>
<p id="p-0407" num="0406">[10,&#x2212;1,0]: char dprev [9,&#x2212;1,1]</p>
<p id="p-0408" num="0407">First pass.</p>
<p id="p-0409" num="0408">Initialization:</p>
<p id="p-0410" num="0409">Cost[0]: &#x2212;1:&#x221e;0:0 1:35</p>
<p id="p-0411" num="0410">Going to State 1.</p>
<p id="p-0412" num="0411">Pos 1, gathered string: d</p>
<p id="p-0413" num="0412">Cost[1]: &#x2212;1:30 0:0 1:35</p>
<p id="p-0414" num="0413">TCR rules:</p>
<p id="p-0415" num="0414">[1,0]: [0:&#x221e;]</p>
<p id="p-0416" num="0415">[1,1]: [0:&#x221e;]</p>
<p id="p-0417" num="0416">No TCR matches, and no constraints since 0 is still below the threshold max_cost&#x2212;min(cost_sub, cost_ins)=10.</p>
<p id="p-0418" num="0417">Going to State 2.</p>
<p id="p-0419" num="0418">Pos 2, gathered string: do</p>
<p id="p-0420" num="0419">Cost[2]: &#x2212;1:30 0:0 1:35</p>
<p id="p-0421" num="0420">TCR rules:</p>
<p id="p-0422" num="0421">[2,&#x2212;1]: [0:1.55]</p>
<p id="p-0423" num="0422">[2,0]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0424" num="0423">[2,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0425" num="0424">Here there is a valid word part with low enough potential cost, thus the word part is saved in partial[2] and the saved minima are updated, which for Position 2 are now:</p>
<p id="p-0426" num="0425">Saved cost[2]: &#x2212;1:30 0:0 1:35</p>
<p id="p-0427" num="0426">Saved TCR rule cost:</p>
<p id="p-0428" num="0427">[2,&#x2212;1]: [0:1.55]</p>
<p id="p-0429" num="0428">[2,0]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0430" num="0429">[2,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0431" num="0430">A space also needs to be processed which gives:</p>
<p id="p-0432" num="0431">Pos 3, gathered string: do<sub>&#x2014;</sub></p>
<p id="p-0433" num="0432">Cost[3]: &#x2212;1:30 0:65 1:70</p>
<p id="p-0434" num="0433">TCR rules:</p>
<p id="p-0435" num="0434">[3,&#x2212;1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0436" num="0435">[3,0]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0437" num="0436">[3,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0438" num="0437">One of the costs is below max_cost, thus this is added to the word parts list partial[3] and the following updates are made to the saved costs:</p>
<p id="p-0439" num="0438">Saved cost[3]: &#x2212;1:30 0:65 1:70</p>
<p id="p-0440" num="0439">Saved TCR rule cost:</p>
<p id="p-0441" num="0440">[3,&#x2212;1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0442" num="0441">[3,0]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0443" num="0442">[3,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0444" num="0443">Go back to State 2 and process the letter &#x2018;o&#x2019; to State 3:</p>
<p id="p-0445" num="0444">Pos 3, gathered string: doo</p>
<p id="p-0446" num="0445">Cost[3]: &#x2212;1:30 0:45 1:70</p>
<p id="p-0447" num="0446">TCR rules:</p>
<p id="p-0448" num="0447">[3,&#x2212;1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0449" num="0448">[3,0]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0450" num="0449">[3,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0451" num="0450">The only usable continuation from here is with the letter &#x2018;e&#x2019;, which the trie does not provide, so go back to State 2 and process &#x2018;n&#x2019; to go to State 5:</p>
<p id="p-0452" num="0451">Pos 3, gathered string: don</p>
<p id="p-0453" num="0452">Cost[3]: &#x2212;1:30 0:45 1:35</p>
<p id="p-0454" num="0453">TCR rules:</p>
<p id="p-0455" num="0454">[3,&#x2212;1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0456" num="0455">[3,0]: [0:c] [1:1.25]</p>
<p id="p-0457" num="0456">[3,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0458" num="0457">From here, the process can only continue with &#x2018;e&#x2019; (due to TCR[3,0,1]) and &#x2018;s&#x2019; [due to matching next letter after Cost[3, 1]). Going to State 6.</p>
<p id="p-0459" num="0458">Pos 4, gathered string: done</p>
<p id="p-0460" num="0459">Cost[4]: &#x2212;1:30 0:25 1:60</p>
<p id="p-0461" num="0460">TCR rules:</p>
<p id="p-0462" num="0461">[4,&#x2212;1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0463" num="0462">[4,0]: [0:0.25] [1:&#x221e;]</p>
<p id="p-0464" num="0463">[4,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0465" num="0464">&#x2018;done&#x2019; is a word part match with low enough cost, thus we add it to the list partial[4] and update the saved minima for Position 4:</p>
<p id="p-0466" num="0465">Saved cost[4]: &#x2212;1:30 0:25 1:60</p>
<p id="p-0467" num="0466">Saved TCR rule cost:</p>
<p id="p-0468" num="0467">[4,&#x2212;1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0469" num="0468">[4,0]: [0:0.25] [1:&#x221e;]</p>
<p id="p-0470" num="0469">[4,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0471" num="0470">Process word separator which gives:</p>
<p id="p-0472" num="0471">Pos 5, gathered string: done</p>
<p id="p-0473" num="0472">Cost[5]: &#x2212;1:55 0:90 1:70</p>
<p id="p-0474" num="0473">TCR rules:</p>
<p id="p-0475" num="0474">[5,&#x2212;1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0476" num="0475">[5,0]: [0:&#x221e;] [1:&#x221e;] [2:&#x221e;]</p>
<p id="p-0477" num="0476">[5,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0478" num="0477">All of the costs here are higher than max_cost, including the potential TCR costs, thus do not update word parts list and saved costs.</p>
<p id="p-0479" num="0478">Go back to State 6, State 5, State 2 and process &#x2018;e&#x2019; to go to State 7.</p>
<p id="p-0480" num="0479">Pos 3, gathered string: doe</p>
<p id="p-0481" num="0480">Cost[3]: &#x2212;1:30 0:0 1:35</p>
<p id="p-0482" num="0481">TCR rules:</p>
<p id="p-0483" num="0482">[3,&#x2212;1]: [0:&#x221e;] [1:1.55]</p>
<p id="p-0484" num="0483">[3,0]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0485" num="0484">[3,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0486" num="0485">Continuing to State 8.</p>
<p id="p-0487" num="0486">Pos 4, gathered string: does</p>
<p id="p-0488" num="0487">Cost[4]: &#x2212;1:30 0:45 1:35</p>
<p id="p-0489" num="0488">TCR rules:</p>
<p id="p-0490" num="0489">[4,&#x2212;1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0491" num="0490">[4,0]: [0:&#x221e;] [1:1.25]</p>
<p id="p-0492" num="0491">[4,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0493" num="0492">Here there is a word part with low enough potential cost (Cost[4,&#x2212;1] and TCR[4,0,1] are both potentially smaller than max_cost). It is added to the list partial[4] and the saved minima are updated to:</p>
<p id="p-0494" num="0493">Saved cost[4]: &#x2212;1:30 0:25 1:35</p>
<p id="p-0495" num="0494">Saved TCR rule cost:</p>
<p id="p-0496" num="0495">[4,&#x2212;1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0497" num="0496">[4,0]: [0:0.25] [1:1.25]</p>
<p id="p-0498" num="0497">[4,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0499" num="0498">(some of these come from &#x201c;done&#x201d; and some from &#x201c;does&#x201d;). Process space and again do not get a suitable candidate:</p>
<p id="p-0500" num="0499">Pos 5, gathered string: does<sub>&#x2014;</sub></p>
<p id="p-0501" num="0500">Cost[5]: &#x2212;1:75 0:65 1:70</p>
<p id="p-0502" num="0501">TCR rules:</p>
<p id="p-0503" num="0502">[5,&#x2212;1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0504" num="0503">[5,0]: [0:&#x221e;] [1:&#x221e;] [2:&#x221e;]</p>
<p id="p-0505" num="0504">[5,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0506" num="0505">Go back to State 8, State 7, State 2, State 0, and process &#x2018;n&#x2019; to State 9.</p>
<p id="p-0507" num="0506">Pos 1, gathered string: n</p>
<p id="p-0508" num="0507">Cost[1]: &#x2212;1:30 0:45 1:70</p>
<p id="p-0509" num="0508">TCR rules:</p>
<p id="p-0510" num="0509">[1,&#x2212;1]:</p>
<p id="p-0511" num="0510">[1,0]: [0:&#x221e;]</p>
<p id="p-0512" num="0511">[1,1]: [0:&#x221e;]</p>
<p id="p-0513" num="0512">It only makes sense to continue with &#x2018;d&#x2019;, but the trie does not provide that, so go back and finish the first pass.</p>
<p id="p-0514" num="0513">The following words are in the parts lists:</p>
<p id="p-0515" num="0514">partial[2]: &#x2018;do&#x2019;</p>
<p id="p-0516" num="0515">partial[3]: &#x2018;do&#x2019;</p>
<p id="p-0517" num="0516">partial[4]: &#x2018;done&#x2019;, &#x2018;does&#x2019;</p>
<p id="p-0518" num="0517">The saved minima data looks like this:</p>
<p id="p-0519" num="0518">Saved cost[2]: &#x2212;1:30 0:0 1:35</p>
<p id="p-0520" num="0519">Saved cost[3]: &#x2212;1:30 0:65 1:70</p>
<p id="p-0521" num="0520">Saved cost[4]: &#x2212;1:30 0:25 1:35</p>
<p id="p-0522" num="0521">Saved TCR rule cost:</p>
<p id="p-0523" num="0522">[2,&#x2212;1]: [0:1.55]</p>
<p id="p-0524" num="0523">[2,0]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0525" num="0524">[2,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0526" num="0525">[3,&#x2212;1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0527" num="0526">[3,0]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0528" num="0527">[3,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0529" num="0528">[4,&#x2212;1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0530" num="0529">[4,0]: [0:0.25] [1:1.25]</p>
<p id="p-0531" num="0530">[4,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0532" num="0531">The following passes will add to this information.</p>
<p id="p-0533" num="0532">The process now needs to search again starting from the lowest position where a partial match has been found, in this case 2.</p>
<p id="p-0534" num="0533">Pass 2 starts at Position 2, State 0 with the following costs:</p>
<p id="p-0535" num="0534">Cost[2]: &#x2212;1:30 0:0 1:35</p>
<p id="p-0536" num="0535">TCR rules:</p>
<p id="p-0537" num="0536">[2,&#x2212;1]: [0:1.55]</p>
<p id="p-0538" num="0537">[2,0]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0539" num="0538">[2,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0540" num="0539">Process &#x2018;d&#x2019; to go to State 1:</p>
<p id="p-0541" num="0540">Pos 3, gathered string: d</p>
<p id="p-0542" num="0541">Cost[3]: &#x2212;1:30 0:45 1:70</p>
<p id="p-0543" num="0542">TCR rules:</p>
<p id="p-0544" num="0543">[3,&#x2212;1]: [0:0.55] [1:&#x221e;]</p>
<p id="p-0545" num="0544">[3,0]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0546" num="0545">[3,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0547" num="0546">Only &#x2018;e&#x2019; makes a useful continuation from here, but the trie does not have it. Going back to State 0, and processing &#x2018;n&#x2019; to State 9.</p>
<p id="p-0548" num="0547">Pos 3, gathered string: n</p>
<p id="p-0549" num="0548">Cost[3]: &#x2212;1:30 0:45 1:35</p>
<p id="p-0550" num="0549">TCR rules:</p>
<p id="p-0551" num="0550">[3,&#x2212;1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0552" num="0551">[3,0]: [0:&#x221e;] [1:1.25]</p>
<p id="p-0553" num="0552">[3,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0554" num="0553">Still no useable continuation, Pass 2 finishes with no results.</p>
<p id="p-0555" num="0554">Pass 3 starts at Position 3, State 0 with the following costs:</p>
<p id="p-0556" num="0555">Cost[3]: &#x2212;1:30 0:65 1:70</p>
<p id="p-0557" num="0556">TCR rules:</p>
<p id="p-0558" num="0557">[3,&#x2212;1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0559" num="0558">[3,0]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0560" num="0559">[3,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0561" num="0560">and it quickly finishes just like Pass 2:</p>
<p id="p-0562" num="0561">Pos 4, gathered string: d</p>
<p id="p-0563" num="0562">Cost[4]: &#x2212;1:75 0:100 1:70</p>
<p id="p-0564" num="0563">TCR rules:</p>
<p id="p-0565" num="0564">[4,&#x2212;1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0566" num="0565">[4,0]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0567" num="0566">[4,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0568" num="0567">Pos 4, gathered string: n</p>
<p id="p-0569" num="0568">Cost: &#x2212;1:75 0:65 1:70</p>
<p id="p-0570" num="0569">TCR rules:</p>
<p id="p-0571" num="0570">[4,&#x2212;1]: [0:&#x221e;] [1:1.55]</p>
<p id="p-0572" num="0571">[4,0]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0573" num="0572">[4,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0574" num="0573">Pass 4 starts at Position 4, State 0 with these costs:</p>
<p id="p-0575" num="0574">Cost[4]: &#x2212;1:30 0:25 1:35</p>
<p id="p-0576" num="0575">TCR rules:</p>
<p id="p-0577" num="0576">[4,&#x2212;1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0578" num="0577">[4,0]: [0:0.25] [1:1.25]</p>
<p id="p-0579" num="0578">[4,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0580" num="0579">Processing &#x2018;d&#x2019; to State 1 does not lead to anything useful:</p>
<p id="p-0581" num="0580">Pos 5, gathered string: d</p>
<p id="p-0582" num="0581">Cost[5]: &#x2212;1:55 0:65 1:70</p>
<p id="p-0583" num="0582">TCR rules:</p>
<p id="p-0584" num="0583">[5,&#x2212;1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0585" num="0584">[5,0]: [0:&#x221e;] [1:&#x221e;] [2:&#x221e;]</p>
<p id="p-0586" num="0585">[5,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0587" num="0586">But processing &#x2018;n&#x2019; does (going to State 9)</p>
<p id="p-0588" num="0587">Pos 5, gathered string: n</p>
<p id="p-0589" num="0588">Cost[5]: &#x2212;1:30 0:25 1:60</p>
<p id="p-0590" num="0589">TCR rules:</p>
<p id="p-0591" num="0590">[5,&#x2212;1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0592" num="0591">[5,0]: [0:25] [1:&#x221e;] [2:&#x221e;]</p>
<p id="p-0593" num="0592">[5,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0594" num="0593">Here the saved TCR cost for TCR[4,0,1] pays off and leads to the cost 25 for Cost[5,0]. The only useful continuations are &#x2032; and s, thus &#x2018;u&#x2019; can be skipped in the trie.</p>
<p id="p-0595" num="0594">Pos 6, gathered string: n&#x2032;</p>
<p id="p-0596" num="0595">Cost[6]: &#x2212;1:55 0:25 1:60</p>
<p id="p-0597" num="0596">TCR rules:</p>
<p id="p-0598" num="0597">[6,&#x2212;1]: [0:&#x221e;] [1:1.55] [2:2.35]</p>
<p id="p-0599" num="0598">[6,0]: [0:&#x221e;] [1:&#x221e;] [2:&#x221e;]</p>
<p id="p-0600" num="0599">[6,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0601" num="0600">The only useful continuation is &#x2018;t&#x2019; (both due to matching and TCR[6,&#x2212;1,2]).</p>
<p id="p-0602" num="0601">Pos 7, gathered string: n&#x2032;t</p>
<p id="p-0603" num="0602">Cost[7]: &#x2212;1:55 0:25 1:60</p>
<p id="p-0604" num="0603">TCR rules:</p>
<p id="p-0605" num="0604">[7,&#x2212;1]: [0:&#x221e;] [1:1.80] [2:1.35]</p>
<p id="p-0606" num="0605">[7,0]: [0:&#x221e;] [1:&#x221e;] [2:&#x221e;]</p>
<p id="p-0607" num="0606">[7,1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0608" num="0607">This is a word part, it has low potential cost, but it is marked as useable only as the end of a compound word, thus &#x2018;n&#x2032;t&#x2019; is not added to the words parts list and the saved costs for Position 7 are not updated.</p>
<p id="p-0609" num="0608">Still, there is a word part if a space is added to it, which leads to</p>
<p id="p-0610" num="0609">Pos 8, gathered string: n&#x2032;t</p>
<p id="p-0611" num="0610">Cost[8]: &#x2212;1:35 0:70*1:70</p>
<p id="p-0612" num="0611">TCR rules:</p>
<p id="p-0613" num="0612">[8,&#x2212;1]: [0:&#x221e;] [1:0.35] [2:&#x221e;]</p>
<p id="p-0614" num="0613">[8,0]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0615" num="0614">[8,1]: [0:&#x221e;]</p>
<p id="p-0616" num="0615">where the rule &#x2018;t-&#x3e;&#x2019;t (10) is applied. This is another useful word part, thus it is added to the list partial[8] and the saved costs for Position 8 are updated:</p>
<p id="p-0617" num="0616">Saved cost[8]: &#x2212;1:35 0:70*1:70</p>
<p id="p-0618" num="0617">Saved TCR rule cost:</p>
<p id="p-0619" num="0618">[8,&#x2212;1]: [0:&#x221e;] [1:0.35] [2:&#x221e;]</p>
<p id="p-0620" num="0619">[8,0]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0621" num="0620">[8,1]: [0:&#x221e;]</p>
<p id="p-0622" num="0621">After this Pass 4 quickly finishes.</p>
<p id="p-0623" num="0622">Passes 5, 6 and 7 are skipped (because there are no partial matches of that length). There was not a match for Position 8 after the initial pass either, but the procedure also allows subsequent passes to add to the partial matches, which Pass 4 did.</p>
<p id="p-0624" num="0623">Pass 8 starts at</p>
<p id="p-0625" num="0624">Cost[8]: &#x2212;1:35 0:70*1:70</p>
<p id="p-0626" num="0625">TCR rules:</p>
<p id="p-0627" num="0626">[8,&#x2212;1]: [0:&#x221e;] [1:0.35] [2:&#x221e;]</p>
<p id="p-0628" num="0627">[8,0]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0629" num="0628">[8,1]: [0:&#x221e;]</p>
<p id="p-0630" num="0629">Going to state 1:</p>
<p id="p-0631" num="0630">Pos 9, gathered string: d</p>
<p id="p-0632" num="0631">Cost[9]: &#x2212;1:35*0:70 1:70</p>
<p id="p-0633" num="0632">TCR rules:</p>
<p id="p-0634" num="0633">[9,&#x2212;1]: [0:&#x221e;] [1:&#x221e;]</p>
<p id="p-0635" num="0634">[9,0]: [0:&#x221e;]</p>
<p id="p-0636" num="0635">The only useful transition from here is &#x2018;o&#x2019; (to State 2):</p>
<p id="p-0637" num="0636">Pos 10, gathered string: do</p>
<p id="p-0638" num="0637">Cost[10]: *&#x2212;1:35 0:70 1:70</p>
<p id="p-0639" num="0638">TCR rules:</p>
<p id="p-0640" num="0639">[10,&#x2212;1]: [0:&#x221e;]</p>
<p id="p-0641" num="0640">Here there is a match of length <b>2</b> at position <b>10</b>. To create the full match, all matches in partial[10-2] are enumerated, in this case only &#x201c;n&#x2032;t_&#x201d;, which still does not lead to position 0, thus all matches in partial[10-2-4] are enumerated, &#x201c;done&#x201d; and &#x201c;does&#x201d;. The two combinations are &#x201c;donen't do&#x201d; and &#x201c;doesn't do&#x201d;. These are compared against the input pattern to evaluate their actual cost (which is at least as big as Cost[10,&#x2212;1]), which causes &#x201c;donen't do&#x201d; to be rejected.</p>
<p id="p-0642" num="0641">After this Pass 8 finishes. Pass 9 is skipped.</p>
<p id="p-0643" num="0642">The procedure finishes, and the only suggestion is doesn't do.</p>
<p id="p-0644" num="0643">Like some implementations of Ukkonen's algorithm, the look-ups performed in this method do not visit nodes in the dictionary trie repeatedly. Look-up in some branches of the trie is immediately restricted when the accumulated costs do not permit too much freedom.</p>
<p id="p-0645" num="0644">Approximate word part look-up in the dictionary trie is done only once per pattern position using the saved best-case data of all matches. This is a significant improvement to previous implementations where approximate look-ups for right hand side parts were repeated for each left hand side match, and several levels of nested word part look-ups were possible.</p>
<p id="p-0646" num="0645">Since the method treats a multitude of displacements uniformly, it is possible to use vector processing units efficiently to perform the operations on all displacements simultaneously. Due to the use of TCR stacks this vectorization is applicable to significant portions of all processing. Vector processing units such as AltiVecNMX (AltiVec is a trade mark of Freescale Semiconductor Inc.) may be used as well as the synergistic units of Cell Broadband Engine.</p>
<p id="p-0647" num="0646">A vector unit can apply the same operation to a number of arguments at the same time. For example, a vector unit may do this for 8 arguments at a time. If displacements are permitted from &#x2212;4 to 3, for all of them the method can apply e.g. &#x201c;process transition <b>701</b>&#x201d; and &#x201c;process TCR <b>710</b>&#x201d; simultaneously, giving 8 times speedup for this part of the processing, which often takes most of the processing time.</p>
<p id="p-0648" num="0647">Referring to <figref idref="DRAWINGS">FIG. 11</figref>, a computer system <b>1100</b> is shown on which the present invention may be implemented. A computer system <b>1100</b> has a central processing unit <b>1101</b> with primary storage in the form of memory <b>1102</b> (RAM and ROM). The memory <b>1102</b> stores program information and data acted on or created by the programs. The program information includes the operating system code for the computer system <b>1100</b> and application code for applications running on the computer system <b>1100</b>. Secondary storage includes optical disk storage <b>1103</b> and magnetic disk storage <b>1104</b>. Data and program information can also be stored and accessed from the secondary storage.</p>
<p id="p-0649" num="0648">The computer system <b>1100</b> includes a network connection means <b>1105</b> for interfacing the computer system <b>1100</b> to a network such as a local area network (LAN) or the Internet. The computer system <b>1100</b> may also have other external source communication means such as a fax modem or telephone connection.</p>
<p id="p-0650" num="0649">The central processing unit <b>1101</b> includes inputs in the form of, as examples, a keyboard <b>1106</b>, a mouse <b>1107</b>, voice input <b>1108</b>, and a scanner <b>1109</b> for inputting text, images, graphics or the like. Outputs from the central processing unit <b>1100</b> may include a display means <b>1110</b>, a printer <b>1111</b>, sound output <b>1112</b>, video output <b>1113</b>, etc.</p>
<p id="p-0651" num="0650">In a distributed system, a computer system <b>1100</b> as shown in <figref idref="DRAWINGS">FIG. 11</figref> may be connected via a network connection <b>1105</b> to a server on which applications may be run remotely from the central processing unit <b>1101</b> which is then referred to as a client system.</p>
<p id="p-0652" num="0651">Applications which may run on the computer systems from a storage means or via a network connection may include word processing programs, Internet access programs including search engines for searching the World Wide Web, other text indexing and retrieving programs for databases, machine translation programs for translating foreign language documents, optical character recognition programs for recognizing characters from scanned documents, etc.</p>
<p id="p-0653" num="0652">The invention can take the form of an entirely hardware embodiment, an entirely software embodiment or an embodiment containing both hardware and software elements. In a preferred embodiment, the invention is implemented in software, which includes but is not limited to firmware, resident software, microcode, etc.</p>
<p id="p-0654" num="0653">The invention can take the form of a computer program product accessible from a computer-usable or computer-readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description, a computer usable or computer readable medium can be any apparatus that can contain, store, communicate, propagate, or transport the program for use by or in connection with the instruction execution system, apparatus or device.</p>
<p id="p-0655" num="0654">The medium can be an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system (or apparatus or device) or a propagation medium. Examples of a computer-readable medium include a semiconductor or solid state memory, magnetic tape, a removable computer diskette, a random access memory (RAM), a read only memory (ROM), a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory (CD-ROM), compact disk read/write (CD-R/W), and DVD.</p>
<p id="p-0656" num="0655">Improvements and modifications can be made to the foregoing without departing from the scope of the present invention.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>The invention claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for approximate string matching of an input pattern to a trie data structure, comprising:
<claim-text>associating a unique cost value with each of a plurality of correction rules;</claim-text>
<claim-text>traversing, using a computer device, a trie data structure to find approximate partial and full character string matches of the input pattern, comprising, for each character traversed as a string of characters is gathered through the trie data structure:
<claim-text>applying any applicable correction rules to the character;</claim-text>
<claim-text>accumulating the unique cost associated with the any applicable correction rules to an accumulated cost; and</claim-text>
<claim-text>in case that both the accumulated cost and potential costs of applicable correction rules for a gathered string exceed a predetermined threshold, restricting the traverse through the trie data structure; and</claim-text>
</claim-text>
<claim-text>selecting a match based on the accumulated cost of resulting strings.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. A method as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein recursive processing of branches of the trie is:
<claim-text>fully performed if accumulated costs of a character string are below a predefined threshold;</claim-text>
<claim-text>performed with restriction to characters that match characters at active positions in the input pattern, or are in applicable outstanding correction rules; or</claim-text>
<claim-text>not performed if such characters are not present.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. A method as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein in addition to correction rules the method applies elementary transitions of characters including one of an insertion, a deletion, or a replacement, each associated with a cost.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. A method as claimed in <claim-ref idref="CLM-00001">claims 1</claim-ref>, wherein correction rules are generated automatically for all possible applications of character transposition in the input pattern.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. A method as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising including determining correction rules that are applicable to characters in an input pattern, before starting the traverse.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. A method as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising determining candidate approximate matches and using the accumulated cost as a weighting for the candidate matches.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. A method as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, including determining approximate partial matches where a length of the partial match is less than a length of the input pattern, and saving the partial matches with the accumulated cost as a starting cost for a traverse for right hand matches to the input pattern.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. A method as claimed in <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein traverses for right hand matches of compound words are started at the character position of an end position of the partial match.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. A method as claimed in <claim-ref idref="CLM-00007">claim 7</claim-ref> further comprising iterating through all positions for which there is a partial match and using saved accumulated costs as starting points for right hand side match traverses.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. A method as claimed in <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein any full right hand side matches are combined with all left hand side partial matches.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. A method as claimed in <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein left hand side partial matches are combined.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. A method as claimed in <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein accumulated costs for one or more partial matches are used to compile a best case scenario for the right hand side look-up.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. A method as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein correction rules are applied across points of attachments of word parts.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. A method as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein vector processing is used to perform the corrections simultaneously for a range of displacements.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. A system for approximate string matching of an input pattern to a trie data structure, comprising at least one computer device, comprising:
<claim-text>a trie data structure having nodes representing characters in a string, the trie data structure storing allowed character strings; and</claim-text>
<claim-text>a plurality of character correction rules to be applied to the input pattern including a transition of one or more characters in the input pattern, each of the plurality of character correction rules having a unique cost associated therewith;</claim-text>
<claim-text>wherein the computer device traverses the trie data structure including, for each character traversed as a string of characters is gathered through the trie data structure:
<claim-text>applying any applicable correction rules to the character;</claim-text>
<claim-text>accumulating the unique cost associated with the any applicable correction rules to an accumulated cost; and</claim-text>
<claim-text>in case that both the accumulated cost and potential costs of applicable correction rules for a gathered string exceed a predetermined threshold, restricting the traverse through the trie data structure.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. A system as claimed in <claim-ref idref="CLM-00015">claim 15</claim-ref>, the computer device further storing accumulating costs for a gathered character string that is gathered through the trie data structure.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. A system as claimed in <claim-ref idref="CLM-00015">claim 15</claim-ref>, the computer device further setting a maximum cost to restrict the traverse of the trie data structure.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. A system as claimed in <claim-ref idref="CLM-00015">claims 15</claim-ref>, the computer device further storing partial string matches with a saved accumulated cost.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. A system as claimed in <claim-ref idref="CLM-00015">claim 15</claim-ref>, the computer device further performing correction on a range of displacements simultaneously.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. A system as claimed in <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein allowed character strings are words and word parts, or recognised data components and partial data components.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. A computer program product stored on a computer readable storage device, comprising computer readable storage device for performing the steps of:
<claim-text>associating a unique cost value with each of a plurality of correction rules;</claim-text>
<claim-text>traversing, using a computer device, a trie data structure to find approximate partial and full character string matches of the input pattern, comprising, for each character traversed as a string of characters is gathered through the trie data structure:
<claim-text>applying any applicable correction rules to the character;</claim-text>
<claim-text>accumulating the unique cost associated with the any applicable correction rules to an accumulated cost; and</claim-text>
<claim-text>in case that both the accumulated cost and potential costs of applicable correction rules for a gathered string exceed a predetermined threshold, restricting the traverse through the trie data structure; and</claim-text>
</claim-text>
<claim-text>selecting a match based on the accumulated cost of resulting strings.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
