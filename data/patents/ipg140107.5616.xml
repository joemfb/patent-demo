<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08626717-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08626717</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13465381</doc-number>
<date>20120507</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<priority-claims>
<priority-claim sequence="01" kind="national">
<country>DE</country>
<doc-number>09167456.4</doc-number>
<date>20090807</date>
</priority-claim>
</priority-claims>
<us-term-of-grant>
<disclaimer>
<text>This patent is subject to a terminal disclaimer.</text>
</disclaimer>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>30</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>707660</main-classification>
<further-classification>707661</further-classification>
<further-classification>707752</further-classification>
</classification-national>
<invention-title id="d2e69">Database backup and restore with integrated index reorganization</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5204958</doc-number>
<kind>A</kind>
<name>Cheng et al.</name>
<date>19930400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5222235</doc-number>
<kind>A</kind>
<name>Hintz et al.</name>
<date>19930600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>5408654</doc-number>
<kind>A</kind>
<name>Barry</name>
<date>19950400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>5517641</doc-number>
<kind>A</kind>
<name>Barry et al.</name>
<date>19960500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>5758357</doc-number>
<kind>A</kind>
<name>Barry et al.</name>
<date>19980500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>5887274</doc-number>
<kind>A</kind>
<name>Barry et al.</name>
<date>19990300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>6381605</doc-number>
<kind>B1</kind>
<name>Kothuri et al.</name>
<date>20020400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>6591269</doc-number>
<kind>B1</kind>
<name>Ponnekanti</name>
<date>20030700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>6694323</doc-number>
<kind>B2</kind>
<name>Bumbulis</name>
<date>20040200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>7372857</doc-number>
<kind>B1</kind>
<name>Kappler et al.</name>
<date>20080500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>7599949</doc-number>
<kind>B1</kind>
<name>Plasek et al.</name>
<date>20091000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>7966298</doc-number>
<kind>B2</kind>
<name>Bruso et al.</name>
<date>20110600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2003/0204513</doc-number>
<kind>A1</kind>
<name>Bumbulis</name>
<date>20031000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2008/0235298</doc-number>
<kind>A1</kind>
<name>Lin et al.</name>
<date>20080900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>2009/0276430</doc-number>
<kind>A1</kind>
<name>Bruso et al.</name>
<date>20091100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  8</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>2011/0035359</doc-number>
<kind>A1</kind>
<name>Bendakovsky et al.</name>
<date>20110200</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00017">
<othercit>U.S. Appl. No. 12/789,274.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00018">
<othercit>&#x201c;B+ tree&#x201d;, http://en.wikipedia.org/wiki/B%2B<sub>&#x2014;</sub>tree, printed May 27, 2010, 4 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00019">
<othercit>&#x201c;R-tree&#x201d;, http://en.wikipedia.org/wiki/R-tree, printed May 27, 2010, 3 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>17</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>None</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>13</number-of-drawing-sheets>
<number-of-figures>13</number-of-figures>
</figures>
<us-related-documents>
<continuation>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>12789274</doc-number>
<date>20100527</date>
</document-id>
<parent-grant-document>
<document-id>
<country>US</country>
<doc-number>8200633</doc-number>
</document-id>
</parent-grant-document>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>13465381</doc-number>
</document-id>
</child-doc>
</relation>
</continuation>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20120221523</doc-number>
<kind>A1</kind>
<date>20120830</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Bendakovsky</last-name>
<first-name>Amit</first-name>
<address>
<city>Neu-Isenburg</city>
<country>DE</country>
</address>
</addressbook>
<residence>
<country>DE</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Hrle</last-name>
<first-name>Namik</first-name>
<address>
<city>Boeblingen</city>
<country>DE</country>
</address>
</addressbook>
<residence>
<country>DE</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Ritter</last-name>
<first-name>Thomas</first-name>
<address>
<city>Herrenberg</city>
<country>DE</country>
</address>
</addressbook>
<residence>
<country>DE</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Bendakovsky</last-name>
<first-name>Amit</first-name>
<address>
<city>Neu-Isenburg</city>
<country>DE</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Hrle</last-name>
<first-name>Namik</first-name>
<address>
<city>Boeblingen</city>
<country>DE</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Ritter</last-name>
<first-name>Thomas</first-name>
<address>
<city>Herrenberg</city>
<country>DE</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<last-name>Lammes</last-name>
<first-name>Francis</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Walder, Jr.</last-name>
<first-name>Stephen J.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="03" rep-type="attorney">
<addressbook>
<last-name>Flynn</last-name>
<first-name>John D.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Hoang</last-name>
<first-name>Son T</first-name>
<department>2169</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A mechanism is provided for reorganizing a source index tree of a database table resulting in a target index tree of the database table is provided. A backup process reads source leaf pages of the source index tree in a logical order defined by a sequence of index keys. The logical order can be different from a physical order of the source leaf pages defined by a sequence of respective storage locations. The backup process constructs target leaf pages of the target index tree maintaining the logical order. A restore process constructs target non-leaf pages of the target index tree based on the distribution of the index keys among the constructed leaf pages and stores the target leaf and non-leaf pages.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="227.25mm" wi="186.86mm" file="US08626717-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="239.10mm" wi="131.91mm" file="US08626717-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="252.48mm" wi="165.86mm" file="US08626717-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="252.48mm" wi="184.49mm" file="US08626717-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="249.51mm" wi="185.25mm" file="US08626717-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="239.78mm" wi="188.30mm" file="US08626717-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="247.31mm" wi="151.64mm" file="US08626717-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="191.26mm" wi="186.01mm" file="US08626717-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="242.82mm" wi="186.01mm" file="US08626717-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="250.19mm" wi="171.37mm" file="US08626717-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="238.34mm" wi="169.59mm" file="US08626717-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="251.80mm" wi="163.58mm" file="US08626717-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="231.56mm" wi="165.86mm" file="US08626717-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="189.06mm" wi="176.53mm" file="US08626717-20140107-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND</heading>
<p id="p-0002" num="0001">The present invention relates to a method for reorganizing a source index tree of a database table resulting in a target index tree.</p>
<p id="p-0003" num="0002">A database index is a data structure used in database systems. One of many purposes of a database index is an acceleration of operations on a database table. The database index is a sorted list of the contents of one or more table columns of the database table, where each element of the list is associated with a pointer to a respective table row of the database table. While a database index saves time in the reading of data matching some criterion, it costs additional time to update the database index when table data are inserted, modified, or deleted.</p>
<p id="p-0004" num="0003">Database indices can be stored in various forms of data structures. The most common data structure for a database index is a B+ tree. This index tree keeps data sorted in a way that allows searches, insertions, and deletions of index tree records at a short time. The B+ tree stores index records, each of which is identified by an index key (K) and a reference to one of the table rows of the database table. The index key is constructed from the contents of the one or more table columns the database index is referring to. Each of the table rows is identified by a respective row identifier (RID) or pointer (P).</p>
<p id="p-0005" num="0004">In many database systems, database indices can be stored at storage locations, which are, for example, called indexspaces, that are separate from storage locations for database tables, which are, for example, called tablespaces.</p>
<p id="p-0006" num="0005">The tree structure of the B+ tree comprises internal nodes, which are non-leaf nodes of the tree structure, and external nodes, which are leaf nodes of the tree structure. In contrast to the non-leaf nodes, the leaf nodes do not have any child nodes. The non-leaf nodes are parent nodes of the leaf nodes.</p>
<p id="p-0007" num="0006">The internal nodes of the B+ tree have a variable number of child nodes within a pre-defined child number range, that is, from a minimum child number to a maximum child number. The order b of the B+ tree measures the capacity of child nodes for each parent node, that is, defines the maximum possible number of child nodes. The minimum number of child nodes is typically defined to be half of the order b, that is, b/2, rounded up to the nearest integer.</p>
<p id="p-0008" num="0007">The external nodes of the B+ tree store sets of the index records, where the sets have pre-defined record number ranges, that is, from a minimum record number to a maximum record number. The internal nodes of the B+ tree, however, do not store index records. The index records have a logical sort order that is defined by a sequence of the identifying index keys. The logical sequence of index records also defines a logical order of the leaf pages of the index tree.</p>
<p id="p-0009" num="0008">All the internal and external nodes of the B+ tree have respective parent nodes except for the root node, which is at the top level of the index tree.</p>
<p id="p-0010" num="0009">The internal nodes store respective ordered sets of pointer-key-pairs (p<sub>i</sub>, k<sub>i</sub>). The pointer p<sub>i </sub>refers to a subtree of a child node, which has index records with key values that are less or equal than the key k<sub>i </sub>and greater than the key k<sub>i&#x2212;1 </sub>of a preceding pointer-key-pair (p<sub>i&#x2212;1</sub>, k<sub>i&#x2212;1</sub>).</p>
<p id="p-0011" num="0010">The number of nodes along an index tree branch descending from the root node to a leaf node defines a height h of the index tree. A B+ tree is kept balanced by requiring that all leaf nodes have the same index tree height h.</p>
<p id="p-0012" num="0011">If a storage system has a block or page size of B bytes, and each of the pointer-key-pairs to be stored in the non-leaf nodes has a size of k, the most efficient B+ tree has a maximum child number of b&#x3c;(B/k) for the non-leaf nodes. In this case, the physical storage size of one of the non-leaf nodes does not exceed the block or page size of the storage system. In the same way, a maximum number of index records can be calculated for the leaf nodes that is most efficient for a given block or page size. In the remainder of the description, the term &#x201c;page&#x201d; is used to describe a segment of storage space that holds information represented by one node of the index tree. The sequence of physical storage locations for respective leaf pages defines a physical order of the leaf pages.</p>
<p id="p-0013" num="0012">When a table row is added or removed from a database table that is associated with a database index, a corresponding index record must be respectively added or removed from the database index. In the case of the B+ tree, all insertions and deletions of index records happen in the leaf nodes.</p>
<p id="p-0014" num="0013">When a specific index record is to be inserted into a specific leaf page and the number of index records of the specific leaf page exceeds the pre-defined maximum record number, the specific leaf page can be subject to a split operation. In this case, a database management component of a database management system (DBMS) determines an unused storage location for a leaf page based on a space map page and allocates the free storage location to a new leaf page. In the database storage, the allocated storage location should be as close to the storage location of the specific leaf page as possible. Typically, half of the index tree records of the specific leaf page are moved to the new leaf page. A new pointer is added to the parent non-leaf page of the specific leaf page, where the new pointer refers so the new leaf page.</p>
<p id="p-0015" num="0014">When an index record is deleted from a specific leaf page and the number of index records of the specific leaf page falls below a pre-defined minimum record number, the specific leaf page can be subject to a join operation. A join operation joins index records of two leaf pages that are adjacent in the logical sequence of leaf pages. The two leaf pages do not need no have adjacent physical storage locations. The join operation of the two leaf pages is only possible if their total number of index records fails below the maximum record number. After the join operation, one of the pointers referring to the two leaf pages is deleted from the respective parent non-leaf page and one or more key values of one or more parent non-leaf pages are adapted no key values of the joined leaf page.</p>
<p id="p-0016" num="0015">The insertion and deletion of child pointers from the non-leaf pages can cause split and join operations of the non-leaf pages in the same way as described for index records of the leaf pages. The root node of the index tree, however, plays a special role: When more child nodes are to be added to the root node than a pre-defined maximum child number, the root node is split into two non-leaf nodes and a new root node is created for the index tree, where the two split non-leaf nodes become child nodes of the new root node. In this case, the height of the index tree is increased by one. When child nodes are removed from the root node and the root node only has one child node left, the root node is deleted and the child node becomes a new root node of the index tree. In this case, the height of the index tree is decreased by one.</p>
<p id="p-0017" num="0016">B+ trees can waste some storage space since leaf and non-leaf nodes are not always entirely full, that is, respectively have less than the pre-defined maximum number of records and child nodes.</p>
<p id="p-0018" num="0017">Join and split operations can cause a fragmentation of the leaf pages. Due to the split operations, the logical order of the leaf pages will become different from the physical order of the leaf pages. The join operations will leave unused storage locations after deleting leaf pages. The fragmentation of the leaf pages can significantly reduce the performance of the database index. When a database index has been perfectly reorganized and only a few split and join operations have fragmented the database index, subsequent leaf pages in the logical order are mostly neighbours in physical storage or at least not too far away from one another. To keep a database index defragmented as far as possible, the database management component tries to avoid split and join operations.</p>
<p id="p-0019" num="0018">The database management component accesses leaf pages of the index tree by reading chunks of leaf pages and writing them to a cache. The leaf pages of one chunk are subsequent in the physical order, but not necessarily subsequent in the logical order. The more the leaf pages are fragmented, the more chunks of leaf pages must be read by the database management component to get a logical sequence of leaf pages. Thus, the increasing fragmentation of the leaf pages reduces the performance of the database system.</p>
<p id="p-0020" num="0019">To improve the performance of the database system, a so-called reorganization can eliminate a difference between the physical order and the logical order of the leaf pages of the database index. Prior art database systems are simply rebuilding the index tree based on current information found in one or more columns of the database table. The database management component scans the database table in a physical order of the table rows. This is also called a full table scan. For each of the table rows, a respective index record is created. If the total set of created index records is small, the index records can be sorted in the memory of the database system. If the total set of index records is too large to perform the sort operation in the memory, smaller subsets of index records can be separated and sorted in the memory. The sorted subsets can be temporarily stored in permanent storage and merged into a sorted total set of index records in the memory. The reorganization is called online, when the new database index is rebuilt in a shadow object, while concurrent transactions are accessing the old database index. Once the rebuild of the new database index has been completed, the database management component will re-read database logs to update the new database index incrementally. The updated new database index will replace the original version. Storage space used by the original database index will be released after the online reorganization.</p>
<p id="p-0021" num="0020">The leaf pages of the B+ tree are linked to one another in a linked list according to the logical order of the leaf pages. Each of the leaf pages has a pointer to a preceding leaf page and a pointer to a succeeding leaf page of the linked list of leaf nodes. The first and last leaf page of the linked list only have one pointer to the respective adjacent leaf page. These pointers make range queries simpler and more efficient. The links to adjacent leaf pages allow quickly traversing the list of leaf pages in the logical order without reading pointer information from the parent non-leaf pages.</p>
<p id="p-0022" num="0021">A database backup and restore creates a backup image, in the literature also named as backup copy, of a source database system, which is used to rebuild a target database system. The backup and restore of a database system may be also denoted as a database copy. The backup image of one database system can be represented by one or more files or datasets. Database tables and indices may be subdivided to different files or datasets. Reasons for a database backup and restore are data protection against loss and a setup of a system environment with multiple almost identical database systems that may be used as development, quality assurance and production systems. A different, for example, more powerful, hardware can also account for a database backup and restore.</p>
<p id="p-0023" num="0022">Operating system components are used for transferring the backup image from the source to the target database system. In prior art, a reorganization of the database indices is performed after the restore of the target database system because the physical order of the database indices is maintained. As described above, a reorganization involves a rebuild of the database index trees, which can take a long time.</p>
<heading id="h-0002" level="1">BRIEF SUMMARY</heading>
<p id="p-0024" num="0023">In one illustrative embodiment, a method, in a data processing system, is provided for reorganizing a source index tree of a database table resulting in a target index tree of the database table. The illustrative embodiment performs a backup of the source index tree from respective source storage locations. In the illustrative embodiment, the source index tree comprises source leaf pages and source non-leaf pages. In the illustrative embodiment, the source leaf pages comprise index records specifying respective index keys and respective table row identifiers of the database table, a source logical order defined by a sequence of the respective index keys of the index records, and a source physical order defined by a sequence of the respective source storage locations. In the illustrative embodiment, the source physical order of the source leaf pages being possibly different from the source logical order of the source leaf pages. In performing the backup of the source index tree from the source storage locations the illustrative embodiment: determines a sequence of the source storage locations according to the source logical order of the source leaf pages, reads the source leaf pages from the source storage locations according to the determined sequence of the source storage locations, and constructs target leaf pages of the target index tree, the target leaf pages having copies of the index records and a target logical order defined by the sequence of the index keys of the copies of the index records. The illustrative embodiment then performs a restore of the target index tree at target storage locations. In performing the restore of the target index tree at target storage locations the illustrative embodiment: writes the constructed target leaf pages to the respective target storage locations defining a target physical order of the target leaf pages, the target physical order corresponding to the target logical order of the target leaf pages, constructs target non-leaf pages of the target index tree based on the distribution of the index keys among the constructed leaf pages, and writes the constructed target non-leaf pages to the respective target storage locations.</p>
<p id="p-0025" num="0024">In other illustrative embodiments, a computer program product comprising a computer useable or readable medium having a computer readable program is provided. The computer readable program, when executed on a computing device, causes the computing device to perform various ones, and combinations of, the operations outlined above with regard to the method illustrative embodiment.</p>
<p id="p-0026" num="0025">In yet another illustrative embodiment, a system/apparatus is provided. The system/apparatus may comprise one or more processors and a memory coupled to the one or more processors. The memory may comprise instructions which, when executed by the one or more processors, cause the one or more processors to perform various ones, and combinations of, the operations outlined above with regard to the method illustrative embodiment.</p>
<p id="p-0027" num="0026">These and other features and advantages of the present invention will be described in, or will become apparent to those of ordinary skill in the art in view of, the following detailed description of the example embodiments of the present invention.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS</heading>
<p id="p-0028" num="0027">The subject matter which is regarded as the present invention is particularly pointed out and distinctly claimed in the claims at the conclusion of the specification. The foregoing and other objects, features, and advantages of the present invention are apparent from the following detailed description taken in conjunction with the accompanying drawings, in which:</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 1</figref><i>a </i>illustrates a block diagram of an offline database copy according to an embodiment of the present invention;</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 1</figref><i>b </i>illustrates a block diagram of an online database copy according to an embodiment of the present invention;</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIGS. 2</figref><i>a </i>illustrates a block diagram of reorganizing database index leaf pages according to an embodiment of the present invention;</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 2</figref><i>b </i>illustrates a block diagram of merging index logs and leaf pages according to an embodiment of the present invention;</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 2</figref><i>c </i>illustrates a block diagram of a cache for leaf pages according to an embodiment of the present invention;</p>
<p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. 3</figref><i>a</i>-<i>b </i>illustrate flow charts of performing an offline database backup and restore according to an embodiment of the present invention;</p>
<p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. 3</figref><i>c</i>-<i>d </i>and <b>3</b><i>f</i>-<i>g </i>illustrate flow charts of performing an online database backup and restore according to an embodiment of the present invention;</p>
<p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. 3</figref><i>e </i>illustrates a flow chart of performing a backup of leaf pages according to an embodiment of the present invention; and</p>
<p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. 4</figref> illustrates a table of duration samples for database backup and restore according to an embodiment of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. 1</figref><i>a </i>illustrates a block diagram of an offline database backup and restore with integrated index tree reorganization. A source database system (<b>101</b>) comprises database tables (<b>103</b>) and database indices (<b>104</b>), where each database index is associated with a respective database table. The database index has a structure of a B+ index tree. The database index has leaf pages (<b>104</b>: <b>1</b>, <b>3</b>, <b>2</b>, <b>4</b>) and non-leaf pages (<b>104</b>: R, A, B), where the top-level non-leaf page is called root page (<b>104</b>: R). The leaf pages have a logical order, that is, <b>1</b>, <b>2</b>, <b>3</b>, and <b>4</b>, according to a sequence of index keys in the leaf pages. The leaf pages also have a physical order, that is, <b>1</b>, <b>3</b>, <b>2</b>, <b>4</b>, according to a sequence of physical storage locations at which she leaf pages are stored. An offline database backup (<b>105</b>) creates a table backup image (<b>106</b>) from the database tables as known in the prior art. The backup (<b>107</b>) of database indices to an index backup image is different from prior art in that only constructed leaf pages (<b>108</b>: <b>1</b>&#x2032;, <b>2</b>&#x2032;, <b>3</b>&#x2032;, <b>4</b>&#x2032;) are stored in the index backup image (<b>108</b>) in a logical order (<b>1</b>&#x2032;, <b>2</b>&#x2032;, <b>3</b>&#x2032;, <b>4</b>&#x2032;) according to the sequence of index keys. The non-leaf pages of the source index tree, however, are not written to the index backup image. The database tables (<b>110</b>) of the target database system (<b>102</b>) are restored (<b>109</b>) based on the table backup image (<b>106</b>) as known in prior art. The restore (<b>111</b>) of the database indices (<b>112</b>) of the target database system from the index backup image (<b>108</b>) is different from prior art in that only the constructed leaf pages (<b>112</b>: <b>1</b>&#x2032;, <b>2</b>&#x2032;, <b>3</b>&#x2032;, <b>4</b>&#x2032;) are restored and the non-leaf pages (<b>112</b>: A&#x2032;, B&#x2032;, R&#x2032;) are re-built in the target database system, preferably while restoring the leaf pages.</p>
<p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. 1</figref><i>b </i>illustrates a block diagram of an online database backup and restore with integrated index tree reorganization. The source database system (<b>121</b>) comprises database tables (<b>123</b>) and database indices (<b>124</b>) as described in <figref idref="DRAWINGS">FIG. 1</figref><i>a</i>. In contrast to the offline database backup and restore, the database system is executing database transactions that are recorded in transaction logs (<b>125</b>) during a backup (<b>126</b>) of the table pages to a table backup image (<b>127</b>) and during a backup (<b>128</b>) of the leaf pages to an index backup image (<b>129</b>). When the table backup (<b>126</b>) and the index backup (<b>128</b>) have completed, the online database backup and restore also backups (<b>130</b>) the transaction logs (<b>131</b>). During the online database backup, the source database can additionally extract (<b>132</b>) index change records from the transaction logs (<b>125</b>) and write them to index logs (<b>133</b>). <figref idref="DRAWINGS">FIG. 2</figref><i>b </i>describes the construction of the index logs. Based on the table backup image (<b>127</b>) and the transaction logs (<b>131</b>), the target database tables (<b>134</b>) are restored (<b>135</b>,<b>136</b>) in the target database system (<b>122</b>) as known in prior art. The restore (<b>137</b>) of the index leaf pages to the target database system is different from the offline database backup and restore in that the index change records are sorted and preferably compacted. The sorted index change records are finally merged with the leaf pages of the index backup image (<b>137</b>) to restore the leaf pages (<b>138</b>: <b>1</b>&#x2032;, <b>2</b>&#x2032;, <b>3</b>&#x2032;, <b>4</b>&#x2032;). The non-leaf pages (<b>138</b>: A&#x2032;, B&#x2032;, R&#x2032;) are re-built in the target database system, preferably while restoring the leaf pages.</p>
<p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. 2</figref><i>a </i>illustrates a block diagram of reorganizing leaf pages of a database index (<b>201</b>) in the source database system. The database index comprises leaf pages (<b>211</b>, <b>212</b>, <b>213</b>, <b>214</b>) and their parent non-leaf pages (<b>218</b>, <b>219</b>). The database index is associated with one database table. Each of the leaf pages comprises a set of index records. Each of the index records is identified by a respective index key value K&#x3c;n&#x3e; and specifies a pointer P&#x3c;n&#x3e; to one of the table rows of the associated database table. In the source database of the present example, each of the leaf pages has storage space for three index records, but the database management component only stores at most two index records in the leaf pages. In most prior art database systems, a block or page storage parameter may be used to specify how much storage space should be left in an index page for further updates. For example, a value of the parameter PCTFREE=10 leaves 10 percent of block storage space for future updates. This free storage space would not be used for insert operations. The PCTFREE parameter is typically pre-determined when a definition of a database index or database indexspace is created or updated. The leaf pages have a logical order (<b>211</b>, <b>212</b>, <b>213</b>, <b>214</b>) according to the sequence of the index keys (K<b>1</b>, K<b>2</b>, . . . , K<b>7</b>). To traverse the logical sequence of leaf pages quickly, that is, subsequently read the leaf pages, each leaf page has a pointer to a preceding leaf page and a pointer to a succeeding leaf page. For example, the leaf page (<b>213</b>) has a pointer (<b>217</b>) to the succeeding leaf page (<b>214</b>) and a pointer (<b>216</b>) to the preceding leaf page (<b>212</b>) in the logical order. The first leaf page (<b>211</b>) has only one pointer (<b>215</b>) to the succeeding leaf page (<b>212</b>). And the last leaf page (<b>214</b>) has one pointer (<b>217</b>) to the preceding leaf page (<b>213</b>). Each of the leaf pages has a respective parent non-leaf page. For example, the leaf page (<b>211</b>) has the parent non-leaf page (<b>218</b>). The non-leaf pages of the source database system are not relevant for the preferred embodiment. The physical order of the leaf pages (<b>211</b>, <b>213</b>, <b>212</b>, <b>211</b>) is different from the logical order. While traversing the leaf pages (<b>211</b>, <b>212</b>, <b>213</b>, <b>214</b>) during a backup of the database index tree in the logical order, the source database system reads index records ((K<b>1</b>, P<b>1</b>), (K<b>2</b>, P<b>2</b>), (K<b>3</b>, P<b>3</b>), . . . (K<b>7</b>, P<b>7</b>)) from the leaf pages of the source system, constructs and writes leaf pages (<b>221</b>, <b>222</b>, <b>223</b>) to an index backup image (<b>202</b>), distributes the read index records among the constructed leaf pages, and writes the distributed index records to the leaf pages in the logical order. The preferred embodiment allows that the constructed leaf pages can have a different size or a different maximum record number than the leaf pages of the source database system. For example, each of the constructed leaf pages (<b>221</b>, <b>222</b>, <b>223</b>) has storage space for four index records. The leaf pages in the target system have a pre-determined maximum record number of three index records. During the restore of the leaf pages from an index backup image, the target database system directly copies the constructed leaf pages (<b>221</b>, <b>222</b>, <b>223</b>) to respective storage locations (<b>231</b>, <b>232</b>, <b>233</b>) of the target database system (<b>203</b>). Subsequent leaf pages are linked by pointers (<b>234</b>, <b>235</b>). Preferably, while restoring the leaf pages, the target database system is constructing non-leaf pages with alternating pointers and key values. The pointers (PA, PB, PC) of parent non-leaf page (<b>236</b>) refer to respective storage locations of child pages (<b>231</b>, <b>232</b>, <b>233</b>). The key values (K<b>3</b>, K<b>6</b>, K<b>9</b>) are the greatest key values of the respective leaf pages (<b>231</b>, <b>232</b>, <b>233</b>).</p>
<p id="p-0041" num="0040"><figref idref="DRAWINGS">FIG. 2</figref><i>b </i>illustrates a block diagram of merging index logs and index leaf pages during an online database backup and restore. While the source database system is backing up table pages and leaf pages, the source database system is performing database transactions and changing the contents of the database tables and implicitly the contents of the database indices. Hence, the backup image does not represent a definite state of the source database system. The transaction logs are recording changes of the database tables and indices. The transaction logs allow applying these changes in the target database system after the database restore. The method of the preferred embodiment extracts (<b>242</b>) index change records (<b>261</b>, <b>262</b>, . . . , <b>267</b>) from the transaction logs (<b>241</b>) and stores the extracted index change records in index logs (<b>243</b>). Each of the index change records specifies a respective timestamp, T&#x3c;n&#x3e;, a respective index key value, K&#x3c;n&#x3e;, and a respective operation. The operation specifies whether the index record has been deleted (DEL) or inserted (INS) into the source database system. In the case of an insert operation, index change records further specify a pointer, P&#x3c;n&#x3e;, to one of the table rows. In the present example, inserted index records (<b>263</b>, <b>264</b>, <b>265</b>, <b>266</b>) are identified by respective new key values. The plus signs indicate that the respective key values are successor key values in the logical order. In the index change record (<b>264</b>), the key value K<b>7</b>+ is the successor of the key value K<b>7</b> and the predecessor of the key value K<b>8</b>. The pointer P<b>7</b>+ refers to an inserted table row. Deleted index records (<b>261</b>, <b>262</b>, <b>267</b>) are identified by respective key values. For example, the index change record (<b>261</b>) deletes the index record with the key value K<b>5</b> and the pointer P<b>5</b>. The pointer P<b>5</b> refers to a deleted table row. When a table row is updated, the index log comprises two index change records. For example, when the table row identified by the pointer P<b>3</b> is updated, two index change records (<b>262</b>, <b>263</b>) are inserted into the index log: a first index change record (<b>262</b>) because the key value K<b>3</b> is deleted from the database index and a second index chance record (<b>263</b>) because the key value K<b>1</b>+ is inserted into the database index. The timestamp T&#x3c;n&#x3e; information in the index change records is important if a key value occurs multiple times. Then, only the operation associated with the last timestamp T&#x3c;last&#x3e; is relevant. For example, the key value K<b>4</b>+ has been inserted (<b>265</b>) at timestamp T<b>5</b> and deleted (<b>267</b>) at timestamp T<b>7</b>. In this case, the first index change record (<b>265</b>) can be ignored. When a delete operation follows an insert operation for the same key value, even both index change records (<b>265</b>, <b>267</b>) can be ignored. Index change records that are not relevant can be removed from the index log, which results in a compacted index log. The database manger further sorts (<b>244</b>) the index change records in the order of the key values and stores the sorted and compacted index change records in sorted index logs (<b>245</b>). <figref idref="DRAWINGS">FIG. 2</figref><i>a </i>has described the backup (<b>247</b>) of the leaf pages (<b>273</b>, <b>274</b>, <b>275</b>) from the source database system (<b>246</b>) to an index backup image (<b>248</b>). In an online database backup and restore, the sequence of index change records (<b>245</b>) and the sequence of leaf pages (<b>248</b>) are merged (<b>249</b>, <b>250</b>) into a new sequence of merged index leaf pages (<b>251</b>) as respective leaf pages (<b>276</b>, <b>277</b>, <b>278</b>), which are stored at the respective storage locations of the target database system. The merging step comprises reading information from two sources in an alternating manner: firstly, index records ((K<b>1</b>, P<b>1</b>), (K<b>2</b>, P<b>2</b>), . . . , (K<b>8</b>, P<b>8</b>)) from the index backup image (<b>248</b>) and, secondly, index change records (<b>268</b>, . . . , <b>272</b>) from the sorted index logs (<b>245</b>). The merging step further comprises comparing the key values of records from both data sources: When the index record from the index backup image has the lower key value, the index record is inserted into a leaf page of the target database system. When the index change record from the sorted index log has a lower or equal key value, the database management component performs the operation of the index change record. In the case of a delete operation, the index change record is ignored and an index record that has the same key value is not inserted in the target leaf page. In the case of an insert operation, the index change record is inserted into the target leaf page. For example, the index change records (<b>268</b>, <b>271</b>, <b>272</b>) insert the index records (K<b>1</b>+, P<b>3</b>), (K<b>7</b>+, P<b>7</b>+), and (K<b>8</b>+, P<b>8</b>+) into the respective leaf pages (<b>276</b>, <b>278</b>). The index change records (<b>269</b>, <b>270</b>) remove the respective key values K<b>3</b> and K<b>5</b> from the leaf pages (<b>273</b>, <b>274</b>) of the index backup image (<b>248</b>).</p>
<p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. 2</figref><i>c </i>illustrates a block diagram of reading leaf pages from the source database system and writing them to a cache. The leaf pages of the source database system are typically stored on external storage devices, for example, on hard disks. Since the database indices are very large, the database management component cannot read all the leaf pages of the index tree and writes them to transient memory. In the memory, the database management component can quickly follow the pointers and traverse the leaf pages in the logical order. When the database management component read the leaf pages from hard disks and wrote them to memory one by one, the reading of index records would become very inefficient because the hard disks may need too many random read access operations. When leaf pages that are subsequent in the logical order are mostly adjacent on the storage devices or only a few storage locations apart, the cache can significantly help to reduce the number of read access operations to the hard disks. When the source database system requests to read a specific leaf page, the database management component checks if the specific leaf page exists in the cache. If the specific leaf page cannot be read from the cache, the database management component reads a chunk of leaf pages including the specific leaf page from the storage device and writes the read chunk to the cache. Then, the database management component reads the specific leaf page from the cache. When all leaf pages of a chunk have been read from the cache, the respective storage locations in the cache are released. In the example of <figref idref="DRAWINGS">FIG. 2</figref><i>c</i>, each chunk has a size of three index leaf pages. The index leaf pages <b>1</b>, . . . , <b>7</b>) are subdivided into three chunks A (<b>281</b>), B (<b>282</b>), and C (<b>283</b>) on one of the hard disks. The time bar (<b>288</b>) indicates a temporal sequence of read operations. In response to a read request for a leaf page (<b>1</b>), the chunk A (<b>281</b>) is read from the hard disk and kept (<b>284</b>) in the cache. The index leaf pages (<b>2</b>) and (<b>3</b>) can be directly read from the cache. After all leaf pages (<b>1</b>, <b>2</b>, <b>3</b>) of chunk A have been accessed in the cache, the respective storage locations can be released. In response to a read request for the leaf page (<b>4</b>), the chunk B (<b>282</b>) is read from the hard disk and kept (<b>285</b>) in the cache. At next, only the leaf page (<b>4</b>) is inserted into the backup image (<b>287</b>). When the leaf page (<b>5</b>) is requested, the chunk C (<b>283</b>) is read from the hard disk and kept (<b>286</b>) in the cache while the cache is still keeping the chunk B (<b>285</b>). After the leaf pages (<b>6</b>) and (<b>7</b>) have been written to the index backup image (<b>287</b>), the storage locations of the chunks B and C can respectively be released from the cache.</p>
<p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. 3</figref><i>a </i>illustrates a flow chart of performing the offline database backup from the source database system. For the offline database backup, the source database system is set (<b>301</b>) to the offline state. This means that the source database system is not executing database transactions and the contents of database tables and indices do not change while performing the database backup. After a backup entry point (<b>302</b>), the source database management component can run the following backup processes: a backup (<b>303</b>) of table pages to a table backup image and a backup (<b>304</b>) of leaf pages to an index backup image. The processes (<b>303</b>, <b>304</b>) can be executed in parallel. The source database management component can further start separate system processes for different groups of database tables and groups of database indices. In some database systems, for example, sets of database tables are assigned to respective tablespaces and sets or database indices are assigned to respective indexspaces. At a backup exit point (<b>305</b>), all backup processes must be finished. Then, the source database system can be set (<b>306</b>) to the online state. The table and index backup images can be copied (<b>307</b>) to the target system that hosts the target database system.</p>
<p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. 3</figref><i>b </i>illustrates a flow chart of a database restore of a target database system from an offline index backup image. The offline index backup image has been created by an offline database backup. For the database restore, an empty target database system is set (<b>311</b>) to the offline state. After a restore entry point (<b>312</b>), the target database management component runs the following processes: a restore (<b>313</b>) of table pages from the table backup image, a restore (<b>314</b>) of leaf pages from the index backup image, and a rebuild (<b>315</b>) of non-leaf pages from the restored index leaf pages. The processes (<b>313</b>, <b>314</b>, <b>315</b>) can be executed in parallel. The rebuild process (<b>315</b>) can be preferably started as a child process of the parent process restoring (<b>314</b>) the leaf pages. The target database management component can further start separate system processes for different groups of database tables and database indices. The sub-steps of restoring (<b>314</b>) the leaf pages from an offline index backup image are described in <figref idref="DRAWINGS">FIG. 3</figref><i>e</i>. After all restore (<b>313</b>, <b>314</b>) and rebuild (<b>315</b>) processes have finished at a restore exit point (<b>316</b>), the target database system can be set (<b>317</b>) to the online state.</p>
<p id="p-0045" num="0044"><figref idref="DRAWINGS">FIG. 3</figref><i>c </i>illustrates a flow chart of an online database backup from the source database system. For the online database backup, the source database management component sets (<b>321</b>) the source database system to the online state and records a start sync point in the transaction logs. In contrast to the offline database backup, the source database system is still executing database transactions and the contents of database tables and indices are changing while performing the database backup. The database system is recording (<b>325</b>) these changes in the transaction logs. After a backup entry point (<b>322</b>), the source database management component can run the following processes: a backup (<b>323</b>) of table pages to a table backup image and a backup (<b>324</b>) of leaf pages to an index backup image. The processes (<b>323</b>, <b>324</b>) can be executed in parallel. Further processes can extract (<b>326</b>) index changes from the transaction logs after the start sync point (<b>322</b>) and write index change records to index logs. These extract (<b>326</b>) processes can preferably run as child processes of the parent processes writing (<b>325</b>) the transaction logs. The source database management component can further start separate system processes for different groups of database tables and groups of database indices and different transaction logs. At a backup exit point (<b>327</b>), all backup processes (<b>323</b>, <b>324</b>) must have finished. The source database management component records (<b>328</b>) a stop sync point in the transaction logs and stops writing the index logs. The table backup image, the index backup image, the transaction logs and possibly the index logs can be copied (<b>328</b>) to the target system that hosts the target database system.</p>
<p id="p-0046" num="0045"><figref idref="DRAWINGS">FIG. 3</figref><i>d </i>illustrates a flow chart of a database restore of a target database system from an online index backup image. The online index backup image has been created by an online database backup. For the database restore, an empty target database system is set (<b>331</b>) to the offline state. After a restore entry point (<b>332</b>), the target database management component can run the following processes: a restore (<b>333</b>) of table pages from the table backup image, a restore (<b>336</b>) of leaf pages from the index backup image, and a rebuild (<b>337</b>) of non-leaf pages from the restored leaf pages. The processes (<b>333</b>, <b>336</b>, <b>337</b>) can be executed in parallel. As known in the prior art, the table pages must be completely restored (<b>333</b>) from the table backup image before the table page changes are applied (<b>335</b>) from the transaction logs. In contrast to the database restore in an offline database backup and restore, the restore (<b>336</b>) of the leaf pages requires the following preparation step: The target database management component reads (<b>334</b>) index change records from the index logs, sorts the index change records by the key values, compacts the index change records based on the recorded timestamps, and writes the sorted index change records to sorted index logs. For details, see the description of <figref idref="DRAWINGS">FIG. 2</figref><i>b</i>. The sorting step (<b>334</b>) must be completed for all index logs and transaction logs from the source database system before restoring (<b>336</b>) the leaf pages in the target system. This restore step (<b>336</b>) merges the leaf pages from the index backup image and the index change records from the sorted index logs. The rebuild (<b>337</b>) processes can preferably be started as child processes of the parent processes restoring (<b>336</b>) the leaf pages. The target database management component can further start separate system processes for restoring different groups of database tables and database indices. The sub-steps of restoring the leaf pages from an online index backup image are described in <figref idref="DRAWINGS">FIG. 3</figref><i>f </i>and <figref idref="DRAWINGS">FIG. 3</figref><i>g</i>. After all restore processes (<b>333</b>, <b>335</b>, <b>336</b>) and all rebuild processes (<b>337</b>) have finished at a restore exit point (<b>338</b>), the target database system can be set (<b>339</b>) to the online state.</p>
<p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. 3</figref><i>e </i>illustrates the sub-steps of backing up the leaf pages. These sub-steps refer to both the leaf pages backup step (<b>304</b>) for the offline case shown in <figref idref="DRAWINGS">FIG. 3</figref><i>a </i>and the leaf pages backup step (<b>324</b>) for the online case shown in <figref idref="DRAWINGS">FIG. 3</figref><i>c</i>. The following steps are executed by the source database management component, which is also called database management component. The database management component selects (<b>341</b>) the next database index from the source database. The database management component checks (<b>342</b>) if it can still read leaf pages from the selected database index. If the answer is &#x201c;yes&#x201d; (<b>342</b>, &#x201c;yes&#x201d;), the database management component reads (<b>343</b>) the index records of the next leaf page of the selected database index. The database management component checks (<b>344</b>) if the reading step (<b>343</b>) has returned more index records than the maximum record number for the target database system. In the negative case (<b>344</b>, &#x201c;no&#x201d;), the database management component tries to read (<b>343</b>) the index records of the next leaf page of the database index. In the positive case (<b>344</b>, &#x201c;yes&#x201d;), the database management component checks (<b>345</b>) if any index records can be written to the index backup image, which is usually true (<b>345</b>, &#x201c;yes&#x201d;). The database management component constructs (<b>346</b>) a new leaf page and inserts the read index records into the constructed leaf page up to the maximum record number for the target database system. The database management component finally writes the leaf page with the inserted index records to the index backup image. When no more index records of the database index can be written (<b>345</b>, &#x201c;no&#x201d;) to the index backup image, the database management component checks (<b>347</b>) if the source database system has more indices and possibly selects (<b>341</b>) the next database index for the index backup.</p>
<p id="p-0048" num="0047"><figref idref="DRAWINGS">FIG. 3</figref><i>f </i>illustrates the detailed sub-steps restoring (<b>336</b>) the leaf pages from an index backup image of an online database backup as shown in <figref idref="DRAWINGS">FIG. 3</figref><i>d</i>. The following steps are executed by the target database management component, which is also called database management component. The database management component selects (<b>351</b>) the next database index from she index backup image. The database management component checks (<b>352</b>) if it can still read leaf pages of the selected database index. If the answer is &#x201c;yes&#x201d; (<b>352</b>, &#x201c;yes&#x201d;), the database management component selects (<b>353</b>) index records from the next leaf page and from the sorted index logs. The details of the selecting step (<b>353</b>) are described in <figref idref="DRAWINGS">FIG. 3</figref><i>g </i>and <figref idref="DRAWINGS">FIG. 2</figref><i>b</i>. The database management component checks (<b>354</b>) if the selecting step (<b>353</b>) has returned more index records than the maximum record number for the target database system. In the negative case (<b>354</b>, &#x201c;no&#x201d;), the database management component tries (<b>353</b>) to read the next leaf page of the database index. In the positive case (<b>354</b>, &#x201c;yes&#x201d;), the database management component checks (<b>355</b>) if any index records can be written to the target database system, which is usually true (<b>355</b>, &#x201c;yes&#x201d;). The database management component constructs (<b>356</b>) a new leaf page and inserts the selected index records into the constructed leaf page up to the maximum record number for the target database system. The database management component finally writes the constructed leaf page with the inserted index records to the target database system. The database management component checks (<b>354</b>) again if the number of selected index records that have not yet been written to the leaf pages exceeds the maximum record number. When the database management component cannot read (<b>352</b>, &#x201c;no&#x201d;) any more leaf pages from the selected database index, that is, after the last leaf page, the database management component checks (<b>355</b>) if any records can be written to the target database and inserts (<b>356</b>) the remaining index records into the constructed leaf pages that are stored in the target database system. When no more index records of the database index can be written (<b>355</b>, &#x201c;no&#x201d;) to the target database, the database management component checks (<b>357</b>) if the index backup image has more database indices and possibly selects (<b>351</b>) the next database index for restoring the leaf pages.</p>
<p id="p-0049" num="0048"><figref idref="DRAWINGS">FIG. 3</figref><i>g </i>illustrates the sub-steps selecting (<b>353</b>) the index records from the next leaf page of the index backup image and from the sorted index logs as described in <figref idref="DRAWINGS">FIG. 3</figref><i>f</i>. This selecting step (<b>353</b>) uses two control variables &#x201c;Read IR&#x201d; and &#x201c;Read ICR&#x201d;. The variable &#x201c;Read IR&#x201d; indicates if the next index record (IR) has already been read from the index backup image. The variable &#x201c;Read ICR&#x201d; indicates if the next index change record (ICR) has already been read from the sorted index log. In <figref idref="DRAWINGS">FIG. 3</figref><i>f</i>, the database management component initializes (<b>341</b>) the variable &#x201c;Read ICR&#x201d; and sets it to the value &#x201c;no&#x201d; before reading the first leaf page of a database index. In <figref idref="DRAWINGS">FIG. 3</figref><i>g</i>, the database management component initializes (<b>361</b>) the variable &#x201c;Read IR&#x201d; and sets it to the value &#x201c;no&#x201d; before reading the first index record of a leaf page. The database management component checks (<b>362</b>) the variable &#x201c;Read IR&#x201d;. When the database management component has not yet read (<b>362</b>, &#x201c;no&#x201d;) the next index record (IR) of the leaf page (LP), the database management component further checks (<b>363</b>) if it can still read index records of the leaf page. In the positive case (<b>363</b>, &#x201c;yes&#x201d;), the database management component reads (<b>364</b>) the next index record from the leaf page and sets the control variable &#x201c;Read IR&#x201d; to &#x201c;yes&#x201d;. The database management component checks (<b>365</b>) the variable &#x201c;Read ICR&#x201d;. When the database management component has not yet read (<b>365</b>, &#x201c;no&#x201d;) the next index change record (ICR) from the sorted index log (SIL), the database management component further checks (<b>366</b>) if it can still read index change records for the selected database index. In the positive case (<b>366</b>, &#x201c;yes&#x201d;), the database management component reads (<b>367</b>) the next index change record from the sorted index log and sets the control variable &#x201c;Read ICR&#x201d; to &#x201c;yes&#x201d;. When the control variable &#x201c;Read IR&#x201d; already has (<b>362</b>, &#x201c;yes&#x201d;) the value &#x201c;yes&#x201d;, the database management component directly checks (<b>365</b>) the control variable &#x201c;Read ICR&#x201d;. When no more index records can be read (<b>363</b>, &#x201c;no&#x201d;) from the leaf page, the selecting step (<b>353</b>) has finished. It can happen that the database management component cannot read (<b>366</b>, &#x201c;no&#x201d;) the next index change record for the selected database index because no more index changes have been extracted from the transaction logs for the selected database index. In this case (<b>366</b>, &#x201c;no&#x201d;), the database management component selects (<b>370</b>) the next read index record to be inserted into a constructed leaf page. If a next index change record (ICR) and a next index record (IR) have been read (&#x201c;Read IR&#x201d;=&#x201c;yes&#x201d; and &#x201c;Read ICR&#x201d;=&#x201c;yes&#x201d;), the database management component compares (<b>368</b>) the key values of the read index record from the leaf page and the read index change record from the sorted index log. If the key value of the index record (IR) is less than (<b>368</b>, left branch) the key value of the index change record (ICR), the index record is selected (<b>370</b>) to be inserted into the constructed leaf page. The control variable &#x201c;Read IR&#x201d; is set (<b>369</b>) to &#x201c;no&#x201d; to enable reading the next index record (IR). If the key values of the index record and of the index change record are equal (<b>368</b>, bottom branch), the database management component sets (<b>371</b>) both control variables &#x201c;Read IR&#x201d; and &#x201c;Read ICR&#x201d; to &#x201c;no&#x201d; to enable reading both the next index record (IR) and the next index change record (ICR). If the key value of the index change record (ICR) is less than (<b>368</b>, right branch) the key value of the index record (IR), the database management component only sets (<b>372</b>) the control variable &#x201c;Read ICR&#x201d; to &#x201c;no&#x201d;. In both cases, when the key value of the index change record (ICR) is less than or equal (<b>368</b>, right and bottom branches) to the key value of the index record (IR), the database management component checks (<b>373</b>) if the operation of the index change record (ICR) is an insert operation. In the positive case (<b>373</b>, &#x201c;yes&#x201d;), the database management component selects (<b>374</b>) the index change record to be inserted into the constructed leaf page. In the negative case (<b>373</b>, &#x201c;no&#x201d;), the database management component ignores the key value of the index change record and tries to read (<b>362</b>) the next required key values.</p>
<p id="p-0050" num="0049"><figref idref="DRAWINGS">FIG. 4</figref> illustrates a table (<b>400</b>) of database backup and restore duration samples with separate and with integrated database index reorganization. A model calculation of execution times (<b>401</b>) is based on a B+ index tree and a single processor system. The following numbers specify the B+ index tree: b is the order of the index tree, h is the height of the index tree, and m is the total number of index records in the leaf nodes. The order b of the index tree is typically the number of child nodes of a parent node and the number of index records in a leaf node. The height h of the index tree can be estimated by the formula, h=log<sub>b </sub>m. The number of non-leaf pages is proportional to the total number m of index records in the leaf pages, but usually much smaller than the number m, if the order b of the index tree, for example, 100 to 300, is much larger than one. The rebuild of the non-leaf pages is typically executed in child processes of parent processes that write the leaf pages to the target database. The time for this rebuild can be neglected in comparison with the time required for sequentially reading or writing the leaf pages. In a prior art database backup and restore (<b>402</b>, left), the duration of a prior backup step (<b>405</b>) for a database index tree is estimated to be of the order O[m]. A prior art restore step (<b>406</b>) for a database index restores all leaf pages and non-leaf pages to the target database system. The prior art backup (<b>405</b>) and restore (<b>406</b>) of the index pages can be omitted. Afterwards, a reorganization of the restored database index sorts all index keys and writes back the reorganized database index to the target database system. The time needed for this sort step significantly grows with the number of index records, which can be estimated by the formula O[m log (m)]. According to the preferred embodiment (<b>402</b>, right), the backup (<b>407</b>) and the restore (<b>408</b>) for a database index spend most of the time in sequentially reading and writing the leaf pages. The estimated durations for both the backup and the restore are of the order O[m]. The model calculation assumes that one operational step takes about 1 microsecond, a page has a size of 32 KB, and an average record has a size of 100 Bytes. The table of <figref idref="DRAWINGS">FIG. 4</figref> shows the estimated duration (<b>401</b>) for database backup and restore operations (<b>403</b>) for database indices with different numbers of index records (<b>404</b>). The example durations have been calculated for a small size database index (<b>409</b>) with 10<sup>4 </sup>index records, a medium size database index (<b>410</b>) with 10<sup>6 </sup>index records, a large database index (<b>411</b>) with 10<sup>9 </sup>index records, and a huge size database index (<b>412</b>) with 10<sup>12 </sup>index records. Depending on the database size, the model calculation results in durations between 0.01 seconds and 12 days for the backup step (<b>407</b>) and the restore step (<b>408</b>) according to the preferred embodiment and for the backup step (<b>405</b>) according to prior art. Due to the sorting step, the prior art restore step (<b>406</b>) with subsequent reorganization of the database index in the target database system needs significantly more time. The model calculation estimates durations between 0.05 seconds and even 5 months. The model calculation shows that the preferred embodiment can vastly reduce the duration of the database backup and restore compared to prior art when the database restore step integrates a reorganization of the database indices.</p>
<p id="p-0051" num="0050">The online database backup and restore with integrated index reorganization can alternatively perform a few steps at different times:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0051">1. The extract step (<b>326</b>) of the index logs from the transaction logs as shown in <figref idref="DRAWINGS">FIG. 3</figref><i>c </i>could also be performed independently after the online database backup described in <figref idref="DRAWINGS">FIG. 3</figref><i>c </i>and before the corresponding online database restore as described in <figref idref="DRAWINGS">FIG. 3</figref><i>d. </i></li>
        <li id="ul0002-0002" num="0052">2. The extract step (<b>326</b>) as depicted in <figref idref="DRAWINGS">FIG. 3</figref><i>c </i>could also be included in the step (<b>334</b>) of the database restore shown in <figref idref="DRAWINGS">FIG. 3</figref><i>d </i>before sorting the extracted index records.</li>
        <li id="ul0002-0003" num="0053">3. The sorting step (<b>334</b>) as shown in <figref idref="DRAWINGS">FIG. 3</figref><i>d </i>could also be performed independently before the online database restore, but not before setting (<b>328</b>) the stop sync point in the source database system at the end of the online database backup as described in <figref idref="DRAWINGS">FIG. 3</figref><i>c. </i></li>
        <li id="ul0002-0004" num="0054">4. The restore step (<b>336</b>) as shown in <figref idref="DRAWINGS">FIG. 3</figref><i>d </i>comprises merging the index records from the leaf pages and the sorted index change records. The merged index records can alternatively be written to copy storage locations before writing the constructed target leaf pages to target storage locations of the target database system.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0052" num="0055">Instead of extracting index change records from transaction logs and writing them to index logs and writing the sorted index change records to sorted index logs, the source and target database management components could also write the extracted and sorted index change records to temporary data structures of their local file systems.</p>
<p id="p-0053" num="0056">In a first alternative embodiment, the backup and restore steps are not performed by respective source and target database management components, but by only one database management component. The database management component firstly performs the backup steps and secondly the restore steps. Preferably, the backup steps may comprise writing the constructed target leaf pages to respective copy storage locations. And the restore steps may comprise reading the target leaf pages from the respective copy storage locations. The copy storage locations may reside temporarily on a copy storage device, which is separate from the source and target storage devices.</p>
<p id="p-0054" num="0057">In a second alternative embodiment, the method is not restricted to B+ trees, but can be applied to other index tree structures where only a subset of index pages contains index records of the database index. Examples for other index tree structures are so-called R-trees, which have data structures similar to B-trees, but are used for spatial access methods, that is, for indexing multi-dimensional information. The data structure splits space with hierarchically nested and possibly overlapping, minimum bounding rectangles (MBRs). Each node of an R-tree has a variable number of entries. Each entry within a non-leaf node stores two pieces of data: a pointer to a child node and a bounding box of all entries within this child node. The leaf nodes store entries that may have a corresponding structure to the entries of the non-leaf nodes. These leaf entries, however, refer to table rows instead of child nodes.</p>
<p id="p-0055" num="0058">As will be appreciated by one skilled in the art, aspects of the present invention may be embodied as a system, method or computer program product. Accordingly, aspects of the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a &#x201c;circuit,&#x201d; &#x201c;module&#x201d; or &#x201c;system.&#x201d; Furthermore, aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium(s) having computer readable program code embodied thereon.</p>
<p id="p-0056" num="0059">Any combination of one or more computer readable medium(s) may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be, for example, but not limited for an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, or device, or any suitable combination of the foregoing. More specific examples (a non-exhaustive list) of the computer readable storage medium would include the following: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), an optical fiber, a portable compact disc read-only memory (CD-ROM), an optical storage device, a magnetic storage device, or any suitable combination of the foregoing. In the context of this document, a computer readable storage medium may be any tangible medium that can contain, or store a program for use by or in connection with an instruction execution system, apparatus, or device.</p>
<p id="p-0057" num="0060">A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein, for example, in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms, including, but not limited to, electro-magnetic, optical, or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate, propagate, or transport a program for use by or in connection with an instruction execution system, apparatus, or device.</p>
<p id="p-0058" num="0061">Program code embodied on a computer readable medium may be transmitted using any appropriate medium, including but not limited to wireless, wireline, optical fiber cable, RF, etc., or any suitable combination of the foregoing.</p>
<p id="p-0059" num="0062">Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages, including an object oriented programming language such as Java, Smalltalk, C++ or the like and conventional procedural programming languages, such as the &#x201c;C&#x201d; programming language or similar programming languages. The program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).</p>
<p id="p-0060" num="0063">Aspects of the present invention are described below with reference to flowchart illustrations and/or block diagrams of methods, apparatus (systems) and computer program products according to embodiments of the invention. It will be understood That each block of the flowchart illustrations and/or block diagrams, and combinations of blocks in the flowchart illustrations and/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or the programmable data processing apparatus, create means for implementing the functions/acts specified in the flowchart and/or block diagram block or blocks.</p>
<p id="p-0061" num="0064">These computer program instructions may also be stored in a computer readable medium that can direct a computer, other programmable data processing apparatus, or other devices so function in a particular manner, such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function/act specified in the flowchart and/or block diagram block or blocks.</p>
<p id="p-0062" num="0065">The computer program instructions may also be loaded onto a computer, other programmable data processing apparatus, or other devices to cause a series of operational steps to be performed on the computer, other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions/acts specified in the flowchart and/or block diagram block or blocks.</p>
<p id="p-0063" num="0066">The flowchart and block diagrams in the Figures illustrate the architecture, functionality, and operation of possible implementations of systems, methods and computer program products according to various embodiments of she present invention. In this regard, each block in the flowchart or block diagrams may represent a module, segment, or portion of code, which comprises one or more executable instructions for implementing the specified logical function(s). It should also be noted that, in some alternative implementations, the functions noted in the block may occur out of the order noted in the figures. For example, two blocks shown in succession may, in fact, be executed substantially concurrently, or the blocks may sometimes be executed in the reverse order, depending upon the functionality involved. It will also be noted that each block of the block diagrams and/or flowchart illustration, and combinations of blocks in the block diagrams and/or flowchart illustration, can be implemented by special purpose hardware-based systems that perform the specified functions or acts, or combinations of special purpose hardware and computer instructions.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>The invention claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method utilizing at least a computer for reorganizing a source index tree of a database table resulting in a target index tree of the database table, the method comprising:
<claim-text>performing a backup of the source index tree from respective source storage locations, wherein the source index tree comprises source leaf pages and source non-leaf pages, wherein the source leaf pages comprise index records specifying respective index keys and respective table row identifiers of the database table, a source logical order defined by a sequence of the respective index keys of the index records, and a source physical order defined by a sequence of the respective source storage locations, wherein the source physical order of the source leaf pages being possibly different from the source logical order of the source leaf pages, and wherein the performing the backup of the source index tree from the respective source storage locations comprises:
<claim-text>determining the sequence of the respective source storage locations according to the source logical order of the source leaf pages,</claim-text>
<claim-text>reading the source leaf pages from the respective source storage locations according to the determined sequence of the respective source storage locations, wherein the reading the source leaf pages further comprises:
<claim-text>receiving a read request for reading a specific source leaf page from a specific source storage location;</claim-text>
<claim-text>reading a chunk of source leaf pages from the respective source storage locations in response to the read request, the specific source leaf page being a member of the chunk of source leaf pages;</claim-text>
<claim-text>writing the read chunk of source leaf pages to cache storage locations according to the source physical order of the read source leaf pages;</claim-text>
<claim-text>determining a sequence of the cache storage locations according to the source logical order of the source leaf pages; and</claim-text>
<claim-text>reading the source leaf pages from the cache storage locations according to the determined sequence of the cache storage locations, and</claim-text>
<claim-text>constructing target leaf pages of the target index tree, the target leaf pages having copies of the index records and a target logical order defined by a sequence of the index keys of the copies of the index records; and</claim-text>
</claim-text>
<claim-text>performing a restore of the target index tree at respective target storage locations, wherein performing the restore of the target index tree at the respective target storage locations comprises:
<claim-text>writing the constructed target leaf pages to the respective target storage locations defining a target physical order of the target leaf pages, the target physical order corresponding to the target logical order of the target leaf pages,</claim-text>
<claim-text>constructing target non-leaf pages of the target index tree based on distribution of the index keys among the constructed target leaf pages, and</claim-text>
<claim-text>writing the constructed target non-leaf pages to the respective target storage locations.</claim-text>
</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein a source database management component performs the backup step and a target database management component performs the restore step, and wherein the method further comprises:
<claim-text>writing the constructed target leaf pages to respective copy storage locations by the source database management component; and</claim-text>
<claim-text>reading the constructed target leaf pages from the respective copy storage locations by the target database management component.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein a database management component performs the backup step and the restore step.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein constructing the target leaf pages further comprises:
<claim-text>reading the index records from the read source leaf pages;</claim-text>
<claim-text>distributing the read index records among multiple sets of sorted index records, the sets having pre-defined maximum numbers of index records, and thereby maintaining a sequence of the respective index keys of the distributed index records;</claim-text>
<claim-text>constructing respective target leaf pages having a pre-defined size; and</claim-text>
<claim-text>inserting the sets of sorted index records into the respective constructed target leaf pages.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein constructing the target leaf pages further comprises:
<claim-text>copying the source leaf pages to respective target leaf pages, and thereby maintaining a distribution of the index records.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein each source or target leaf page comprises at least one of the following: a reference to a respective predecessor leaf page and a reference to a respective successor leaf page, and wherein the predecessor leaf page, the leaf page, and the successor leaf page are defined by the logical order of the source or target leaf pages respectively, and the references to predecessor and successor leaf pages are associated with respective storage locations.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein, while a first operating system process is writing the constructed target leaf pages, a second operating system process is constructing and writing the target non-leaf pages according to the distribution of the index records among the written target leaf pages.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. A computer program product for reorganizing a source index tree of a database table resulting in a target index tree of the database table, the computer program product comprising a non-transitory computer readable storage medium having computer readable program code embodied thereon, wherein the computer readable program code, when executed on a computing device, causes the computing device to:
<claim-text>perform a backup of the source index tree from respective source storage locations, wherein the source index tree comprises source leaf pages and source non-leaf pages, wherein the source leaf pages comprise index records specifying respective index keys and respective table row identifiers of the database table, a source logical order defined by a sequence of the respective index keys of the index records, and a source physical order defined by a sequence of the respective source storage locations, wherein the source physical order of the source leaf pages being possibly different from the source logical order of the source leaf pages, and wherein the computer readable program code to perform the backup of the source index tree from the source storage locations further causes the computing device to:
<claim-text>determine the sequence of the respective source storage locations according to the source logical order of the source leaf pages,</claim-text>
<claim-text>read the source leaf pages from the respective source storage locations according to the determined sequence of the respective source storage locations, wherein the computer readable program code to read the source leaf pages further causes the computing device to:
<claim-text>receive a read request for reading a specific source leaf page from a specific source storage location;</claim-text>
<claim-text>read a chunk of source leaf pages from the respective source storage locations in response to the read request, the specific source leaf page being a member of the chunk of source leaf pages;</claim-text>
<claim-text>write the read chunk of source leaf pages to cache storage locations according to the source physical order of the read source leaf pages;</claim-text>
<claim-text>determine a sequence of the cache storage locations according to the source logical order of the source leaf pages; and</claim-text>
<claim-text>read the source leaf pages from the cache storage locations according to the determined sequence of the cache storage locations, and</claim-text>
<claim-text>construct target leaf pages of the target index tree, the target leaf pages having copies of the index records and a target logical order defined by a sequence of the index keys of the copies of the index records; and</claim-text>
</claim-text>
<claim-text>perform a restore of the target index tree at respective target storage locations, wherein the computer readable program code to perform the restore of the target index tree at target locations further causes the computing device to:
<claim-text>write the constructed target leaf pages to the respective target storage locations defining a target physical order of the target leaf pages, the target physical order corresponding to the target logical order of the target leaf pages,</claim-text>
<claim-text>construct target non-leaf pages of the target index tree based on distribution of the index keys among the constructed target leaf pages, and</claim-text>
<claim-text>write the constructed target non-leaf pages to the respective target storage locations.</claim-text>
</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The computer program product of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the computer readable program code further causes the computing device to:
<claim-text>write the constructed target leaf pages to respective copy storage locations by the source database management component; and</claim-text>
<claim-text>read the constructed target leaf pages from the respective copy storage locations by the target database management component.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The computer program product of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the computer readable program code to construct the target leaf pages further causes the computing device to:
<claim-text>read the index records from the read source leaf pages;</claim-text>
<claim-text>distribute the read index records among multiple sets of sorted index records, the sets having pre-defined maximum numbers of index records, and thereby maintaining a sequence of the respective index keys of the distributed index records;</claim-text>
<claim-text>construct respective target leaf pages having a pre-defined size; and</claim-text>
<claim-text>insert the sets of sorted index records into the respective constructed target leaf pages.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The computer program product of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the computer readable program code to construct the target leaf pages further causes the computing device to:
<claim-text>copy the source leaf pages to respective target leaf pages, and thereby maintaining a distribution of the index records.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The computer program product of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein each source or target leaf page comprises at least one of the following: a reference to a respective predecessor leaf page and a reference to a respective successor leaf page, and wherein the predecessor leaf page, the leaf page, and the successor leaf page are defined by the logical order of the source or target leaf pages respectively, and the references to predecessor and successor leaf pages are associated with respective storage locations.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. An apparatus for reorganizing a source index tree of a database table resulting in a target index tree of the database table, the apparatus comprising:
<claim-text>a computer processor; and</claim-text>
<claim-text>a computer memory coupled to the computer processor, wherein the computer memory comprises instructions which, when executed by the computer processor, cause the computer processor to:
<claim-text>perform a backup of the source index tree from respective source storage locations, wherein the source index tree comprises source leaf pages and source non-leaf pages, wherein the source leaf pages comprise index records specifying respective index keys and respective table row identifiers of the database table, a source logical order defined by a sequence of the respective index keys of the index records, and a source physical order defined by a sequence of the respective source storage locations, wherein the source physical order of the source leaf pages being possibly different from the source logical order of the source leaf pages, and wherein the instructions to perform the backup of the source index tree from the source storage locations further causes the computer processor to:
<claim-text>determine the sequence of the respective source storage locations according to the source logical order of the source leaf pages,</claim-text>
<claim-text>read the source leaf pages from the respective source storage locations according to the determined sequence of the respective source storage locations, wherein the instructions to read the source leaf pages further causes the computer processor to:
<claim-text>receive a read request for reading a specific source leaf page from a specific source storage location;</claim-text>
<claim-text>read a chunk of source leaf pages from the respective source storage locations in response to the read request, the specific source leaf page being a member of the chunk of source leaf pages;</claim-text>
<claim-text>write the read chunk of source leaf pages to cache storage locations according to the source physical order of the read source leaf pages;</claim-text>
<claim-text>determine a sequence of the cache storage locations according to the source logical order of the source leaf pages; and</claim-text>
<claim-text>read the source leaf pages from the cache storage locations according to the determined sequence of the cache storage locations, and</claim-text>
<claim-text>construct target leaf pages of the target index tree, the target leaf pages having copies of the index records and a target logical order defined by a sequence of the index keys of the copies of the index records; and</claim-text>
</claim-text>
<claim-text>perform a restore of the target index tree at respective target storage locations, wherein the instructions to perform the restore of the target index tree at target locations further causes the computer processor to:
<claim-text>write the constructed target leaf pages to the respective target storage locations defining a target physical order of the target leaf pages, the target physical order corresponding to the target logical order of the target leaf pages,</claim-text>
<claim-text>construct target non-leaf pages of the target index tree based on distribution of the index keys among the constructed target leaf pages, and</claim-text>
<claim-text>write the constructed target non-leaf pages to the respective target storage locations.</claim-text>
</claim-text>
</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The apparatus of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the instructions further cause the computer processor to:
<claim-text>write the constructed target leaf pages to respective copy storage locations by the source database management component; and</claim-text>
<claim-text>read the constructed target leaf pages from the respective copy storage locations by the target database management component.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The apparatus of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the instructions to construct the target leaf pages further cause the computer processor to:
<claim-text>read the index records from the read source leaf pages;</claim-text>
<claim-text>distribute the read index records among multiple sets of sorted index records, the sets having pre-defined maximum numbers of index records, and thereby maintaining a sequence of the respective index keys of the distributed index records;</claim-text>
<claim-text>construct respective target leaf pages having a pre-defined size; and</claim-text>
<claim-text>insert the sets of sorted index records into the respective constructed target leaf pages.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The apparatus of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the instructions to construct the target leaf pages further cause the computer processor to:
<claim-text>copy the source leaf pages to the respective target leaf pages, and thereby maintaining a distribution of the index records.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The apparatus of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein each source or target leaf page comprises at least one of the following: a reference to a respective predecessor leaf page and a reference to a respective successor leaf page, and wherein the predecessor leaf page, the leaf page, and the successor leaf page are defined by the logical order of the source or target leaf pages respectively, and the references to predecessor and successor leaf pages are associated with respective storage locations. </claim-text>
</claim>
</claims>
</us-patent-grant>
