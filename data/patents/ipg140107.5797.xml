<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08626904-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08626904</doc-number>
<kind>B1</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13044453</doc-number>
<date>20110309</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<us-term-of-grant>
<us-term-extension>272</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>15</main-group>
<subgroup>173</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>709224</main-classification>
<further-classification>714  1</further-classification>
<further-classification>714 48</further-classification>
<further-classification>718100</further-classification>
</classification-national>
<invention-title id="d2e53">Detecting and reporting livelocks in a computer</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5835766</doc-number>
<kind>A</kind>
<name>Iba et al.</name>
<date>19981100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718104</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5845117</doc-number>
<kind>A</kind>
<name>Fujita</name>
<date>19981200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718107</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6542921</doc-number>
<kind>B1</kind>
<name>Sager</name>
<date>20030400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718108</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>7062681</doc-number>
<kind>B2</kind>
<name>Larsson et al.</name>
<date>20060600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714 39</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>7249179</doc-number>
<kind>B1</kind>
<name>Romero et al.</name>
<date>20070700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709226</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>7516362</doc-number>
<kind>B2</kind>
<name>Connelly et al.</name>
<date>20090400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714 26</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>8108878</doc-number>
<kind>B1</kind>
<name>Pulsipher</name>
<date>20120100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718106</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>8250131</doc-number>
<kind>B1</kind>
<name>Pulsipher</name>
<date>20120800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709201</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>8412406</doc-number>
<kind>B2</kind>
<name>Johnson et al.</name>
<date>20130400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>701 331</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2004/0172385</doc-number>
<kind>A1</kind>
<name>Dayal</name>
<date>20040900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707  3</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2007/0033281</doc-number>
<kind>A1</kind>
<name>Hwang et al.</name>
<date>20070200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709224</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2008/0065873</doc-number>
<kind>A1</kind>
<name>Hall et al.</name>
<date>20080300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712245</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2008/0313445</doc-number>
<kind>A1</kind>
<name>Altman et al.</name>
<date>20081200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712239</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2009/0198969</doc-number>
<kind>A1</kind>
<name>Nystad et al.</name>
<date>20090800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712216</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>2009/0300644</doc-number>
<kind>A1</kind>
<name>Lee et al.</name>
<date>20091200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718106</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>2011/0066908</doc-number>
<kind>A1</kind>
<name>Bartz et al.</name>
<date>20110300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714746</main-classification></classification-national>
</us-citation>
<us-citation>
<nplcit num="00017">
<othercit>Ho, A. et al., &#x201c;On Deadlock, Livelock, and Forward Progress,&#x201d; Technical Report, No. 633, University of Cambridge, May 2005, [Online] Retrieved from the Internet&#x3c;URL:http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-633.pdf&#x3e;.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00018">
<othercit>Li, T. et al., &#x201c;Spin Detection Hardware for Improved Management of Multithreaded Systems,&#x201d; IEEE Transactions on Parallel and Distributed Systems, Jun. 2006, pp. 508-521, vol. 17, No. 6, [Online] Retrieved from the Internet&#x3c;URL:http://www.cs.duke.edu/&#x2dc;alvy/papers/tpds06<sub>&#x2014;</sub>spinning.pdf&#x3e;.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>20</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>709224</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714  1</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714 48</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>718100</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>4</number-of-drawing-sheets>
<number-of-figures>4</number-of-figures>
</figures>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Olliff</last-name>
<first-name>Michael Anthony</first-name>
<address>
<city>Canyon Country</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Olliff</last-name>
<first-name>Michael Anthony</first-name>
<address>
<city>Canyon Country</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Fenwick &#x26; West LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Symantec Corporation</orgname>
<role>02</role>
<address>
<city>Mountain View</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Doan</last-name>
<first-name>Duyen</first-name>
<department>2452</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Tasks executing on a computer can livelock. To detect a livelocked task, the amount of computing resources consumed by the task is sampled to determine whether the task is consuming an inordinate amount of resources. In addition, the task is examined to determine whether it is making tangible progress. This examination can include inspecting registers of a processor executing the task. If the task is livelocked, state data describing the livelock event is collected. The state data can include a memory dump describing the state of the livelocked task and data describing other tasks executing on the computer. A livelock report including the collected state data is generated and transmitted to a server.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="180.51mm" wi="158.07mm" file="US08626904-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="199.98mm" wi="163.75mm" file="US08626904-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="242.82mm" wi="187.11mm" file="US08626904-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="178.56mm" wi="172.30mm" file="US08626904-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="189.15mm" wi="87.63mm" file="US08626904-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND</heading>
<p id="p-0002" num="0001">1. Field of Art</p>
<p id="p-0003" num="0002">The present invention generally relates to the field of computer performance monitoring and more specifically to detecting and reporting livelock events.</p>
<p id="p-0004" num="0003">2. Background of the Invention</p>
<p id="p-0005" num="0004">Modern computers can execute multiple applications simultaneously. While the computer has limited computing resources, the operating system allocates these resources among the executing applications so that each can perform its associated functions. For example, the computer may simultaneously execute a web browser, a messaging application, and a media player, all while a security application scans for malicious software in the background.</p>
<p id="p-0006" num="0005">Occasionally, an application will enter a &#x201c;livelock&#x201d; state characterized by using a high amount of processor or other computer resources while providing no tangible progress. For example, the media player might inexplicably use 99% of available processor resources while failing to respond to user input or playing any media. The livelock condition degrades the performance of the computer. Not only does the livelocked application fail to make tangible progress, but the other applications executing on the computer may receive fewer resources and their performance can degrade as well. Accordingly, livelocks can be very frustrating to computer users.</p>
<p id="p-0007" num="0006">Application developers strive to avoid livelocks in their products. However, livelocks still occur due at least in part to the wide variety of computing environments in which applications can run. An application that behaves properly on one type of computer hardware and operating system may livelock occasionally on other hardware and/or software. Thus, even if the developers receive anecdotal evidence that their applications are livelocking, the livelock events generally are not reproducible due to environmental, configuration, or data-related factors that are specific to the computing environments in which the livelocks occurred. Therefore, the developers are unable to determine why their applications livelock and find it difficult to improve this aspect of their products.</p>
<heading id="h-0002" level="1">SUMMARY</heading>
<p id="p-0008" num="0007">The above and other issues are addressed by a method, computer-readable storage medium storing executable computer program modules, and a computer system that perform livelock detection on a computer. An embodiment of the method comprises detecting a livelock event involving a task executing on the computer and, responsive to detecting a livelock event, collecting state data describing the detected livelock event. Additionally, the method generates a livelock report including the collected state data and transmits the report to a server.</p>
<p id="p-0009" num="0008">An embodiment of the computer-readable storage medium stores executable computer program instructions for reporting a livelock event occurring on a computer, the instructions performing steps comprising detecting a livelock event involving a task executing on the computer and, responsive to detecting a livelock event, collecting state data describing the detected livelock event. Additionally, the steps comprise generating a livelock report including the collected state data and transmitting the report to a server.</p>
<p id="p-0010" num="0009">An embodiment of the computer system for reporting a livelock event comprises a non-transitory computer-readable storage medium storing executable computer program instructions for performing steps comprising detecting a livelock event involving a task executing on the computer and, responsive to detecting a livelock event, collecting state data describing the detected livelock event. Additionally, the steps comprise generating a livelock report including the collected state data and transmitting the report to a server. The computer system further comprises a processor for executing the computer program instructions.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF DRAWINGS</heading>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 1</figref> is a high-level block diagram illustrating an environment for reporting livelock events according to one embodiment.</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 2</figref> is a high-level block diagram illustrating an example of a computer for use as a client and/or server according to one embodiment.</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 3</figref> is a high-level block diagram illustrating a detailed view of the reporting module of a client according to one embodiment.</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 4</figref> is a flowchart illustrating a method for reporting a livelock event performed by the reporting module according to one embodiment.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0015" num="0014">The Figures (FIGS.) and the following description describe certain embodiments by way of illustration only. One skilled in the art will readily recognize from the following description that alternative embodiments of the structures and methods illustrated herein may be employed without departing from the principles described herein. Reference will now be made to several embodiments, examples of which are illustrated in the accompanying figures.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 1</figref> is a high-level block diagram illustrating an environment <b>100</b> for reporting livelock events according to one embodiment. As shown, the environment <b>100</b> includes a network <b>125</b> connecting multiple clients <b>105</b> to a server <b>135</b>. While only three clients <b>105</b> and one server <b>135</b> are shown in <figref idref="DRAWINGS">FIG. 1</figref> for clarity, embodiments can have many clients <b>105</b> and multiple servers <b>135</b>. <figref idref="DRAWINGS">FIG. 1</figref> and the other figures use like reference numerals to identify like elements. A letter after a reference numeral, such as &#x201c;<b>105</b><i>a</i>,&#x201d; indicates that the text refers specifically to the element having that particular reference numeral. A reference numeral in the text without a following letter, such as &#x201c;<b>105</b>,&#x201d; refers to any or all of the elements in the figures bearing that reference numeral (e.g. &#x201c;<b>105</b>&#x201d; in the text refers to reference numerals &#x201c;<b>105</b><i>a</i>,&#x201d; &#x201c;<b>105</b><i>b</i>,&#x201d; and/or &#x201c;<b>105</b><i>c</i>&#x201d; in the figures).</p>
<p id="p-0017" num="0016">The client <b>105</b> is a computer or other electronic device used by one or more users to execute applications for performing various activities. For example, the client <b>105</b> can be a desktop, notebook, or tablet computer, a mobile telephone, or television set-top box. The applications executed by the client <b>105</b> may include web browsers, word processers, media players, spreadsheets, image processors, security software, etc.</p>
<p id="p-0018" num="0017">Occasionally, one or more of the applications executed by the client <b>105</b> may enter a livelock state. The livelock is characterized by the application consuming an inordinate amount of computing resources without showing any tangible progress. For example, a livelocked application may consume 99% of available processor resources without producing any tangible results. The application may also become non-responsive to user input during the livelock, although this is not necessarily the case.</p>
<p id="p-0019" num="0018">As shown in <figref idref="DRAWINGS">FIG. 1</figref>, the client includes a livelock reporting module <b>115</b> (the &#x201c;reporting module&#x201d;) for detecting when an application enters a livelock state. Upon detecting such a livelock event, the reporting module <b>115</b> collects associated data describing the event, including data describing the state of the computer and the livelocked application, and transmits a livelock report containing the data to the server <b>135</b>. In some embodiments the reporting module <b>115</b> is incorporated into an operating system executing on the client <b>105</b> while in other embodiments the reporting module <b>115</b> is a standalone application or part of another product.</p>
<p id="p-0020" num="0019">The server <b>135</b> receives livelock reports from the reporting modules <b>115</b> of the clients <b>105</b>. The server <b>135</b> aggregates and/or processes the data in the reports to provide information for identifying the causes of the livelocks. For example, the server <b>135</b> may store the reports in a relational or other type of database. The server <b>135</b> may then analyze the stored reports to identify the causes of the livelocks. For example, the server <b>135</b> can perform regression analysis using variables such as the livelocked application, computer hardware, applications executing when the livelocks occurred, data being processed when the livelocks occurred, and/or other variables described in the reports from the clients <b>105</b>.</p>
<p id="p-0021" num="0020">Application developers may use the results of the analysis to improve their applications and reduce the frequency of the livelock events. For example, the developer of an application can use the analysis performed by the server <b>135</b> to identify a bug or other fault in the application and update the application to resolve the issue. The update can be distributed to the clients <b>105</b> using the server <b>135</b> or via other distribution channels.</p>
<p id="p-0022" num="0021">The network <b>125</b> represents the communication pathway between clients <b>105</b> and server <b>135</b>. In one embodiment, the network <b>125</b> uses standard communications technologies and/or protocols and can include the Internet. Thus, the network <b>125</b> can include links using technologies such as Ethernet, 802.11, worldwide interoperability for microwave access (WiMAX), 2G/3G/4G mobile communications protocols, digital subscriber line (DSL), asynchronous transfer mode (ATM), InfiniBand, PCI Express Advanced Switching, etc. Similarly, the networking protocols used on the network <b>125</b> can include multiprotocol label switching (MPLS), the transmission control protocol/Internet protocol (TCP/IP), the User Datagram Protocol (UDP), the hypertext transport protocol (HTTP), the simple mail transfer protocol (SMTP), the file transfer protocol (FTP), etc. The data exchanged over the network <b>125</b> can be represented using technologies and/or formats including the hypertext markup language (HTML), the extensible markup language (XML), JavaScript, VBScript, FLASH, the portable document format (PDF), etc. In addition, all or some of links can be encrypted using conventional encryption technologies such as secure sockets layer (SSL), transport layer security (TLS), virtual private networks (VPNs), Internet Protocol security (IPsec), etc. In another embodiment, the entities on the network <b>125</b> can use custom and/or dedicated data communications technologies instead of, or in addition to, the ones described above.</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 2</figref> is a high-level block diagram illustrating an example of a computer <b>200</b> for use as a client <b>105</b> and/or server <b>135</b> according to one embodiment. Illustrated are at least one processor <b>202</b> (CPU) coupled to a chipset <b>204</b>. The chipset <b>204</b> includes a memory controller hub <b>250</b> and an input/output (I/O) controller hub <b>255</b>. A memory <b>206</b> and a graphics adapter <b>213</b> are coupled to the memory controller hub <b>250</b>, and a display device <b>218</b> is coupled to the graphics adapter <b>213</b>. A storage device <b>208</b>, keyboard <b>210</b>, pointing device <b>214</b>, and network adapter <b>216</b> are coupled to the I/O controller hub <b>255</b>. Other embodiments of the computer <b>200</b> have different architectures. For example, the memory <b>206</b> is directly coupled to the processor <b>202</b> in some embodiments.</p>
<p id="p-0024" num="0023">The storage device <b>208</b> is a non-transitory computer-readable storage medium such as a hard drive, compact disk read-only memory (CD-ROM), DVD, or a solid-state memory device. The memory <b>206</b> holds instructions and data used by the processor <b>202</b>. The pointing device <b>214</b> is used in combination with the keyboard <b>210</b> to input data into the computer system <b>200</b>. The graphics adapter <b>213</b> displays images and other information on the display device <b>218</b>. In some embodiments, the display device <b>218</b> includes a touch screen capability for receiving user input and selections. The network adapter <b>216</b> couples the computer system <b>200</b> to the network <b>125</b>. Some embodiments of the computer <b>200</b> have different and/or other components than those shown in <figref idref="DRAWINGS">FIG. 2</figref>. For example, the server <b>135</b> may be formed of multiple blade servers and lack a display device, keyboard, and other components.</p>
<p id="p-0025" num="0024">As used herein, the term &#x201c;module&#x201d; refers to computer program instructions and other logic used to provide the specified functionality. Thus, a module can be implemented in hardware, firmware, and/or software. In one embodiment, program modules formed of executable computer program instructions are stored on the storage device <b>208</b>, loaded into the memory <b>206</b>, and executed by the processor <b>202</b> as one or more processes. A process, in turn, is formed of one or more threads of execution. This description also uses the term &#x201c;task&#x201d; to refer to the execution of a process and/or thread by the processor <b>202</b>.</p>
<p id="p-0026" num="0025">The modules executed by the computer <b>200</b> include modules implementing the operating system and modules implementing applications. The operating system acts as an intermediary between the applications and the computer hardware. In addition, the operating system provides a variety of interfaces, including application programming interfaces (APIs) that modules can use to obtain state information about the computer <b>200</b>.</p>
<p id="p-0027" num="0026">The state information describes the configuration of the computer <b>200</b>. The state information may describe, for example, the hardware configuration of the computer <b>200</b>, tasks being executed by the computer, contents of the memory <b>208</b>, values stored in registers of the processor <b>202</b>, processor <b>202</b> time (&#x201c;CPU time&#x201d;) consumed by one or more tasks, the elapsed real time execution of one or more tasks, a task owner (e.g. program module, system or user), and/or other data associated with the execution of a task or operation of the computer <b>200</b>. The state information changes over time as the computer <b>200</b> processes data.</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 3</figref> is a high-level block diagram illustrating a detailed view of the reporting module <b>115</b> of a client <b>105</b> according to one embodiment. As shown in <figref idref="DRAWINGS">FIG. 3</figref> the reporting module <b>115</b> itself includes multiple modules. In the embodiment shown in <figref idref="DRAWINGS">FIG. 3</figref>, the reporting module <b>115</b> includes a detection module <b>305</b>, a data collection module <b>315</b>, a report generation module <b>320</b>, and a data storage module <b>325</b>. In some embodiments, the functions are distributed among the modules in a different manner than described herein. In addition, other embodiments have additional and/or other modules.</p>
<p id="p-0029" num="0028">The detection module <b>305</b> detects livelock events. As mentioned above, a livelock event is characterized by a task of a process or thread consuming an inordinate amount of computing resources without making tangible progress. To detect livelocks, an embodiment of the detection module <b>305</b> uses one or more APIs provided by the operating system to obtain state information about the client <b>105</b>. The detection module <b>305</b> analyzes the state information to determine whether tasks executing on the client <b>105</b> are in a livelock state. Depending upon the embodiment, the detection module <b>305</b> may be configured to determine whether any tasks on the client <b>105</b> are livelocked, or whether any of a specified subset of tasks on the client are livelocked. Furthermore, embodiments of the detection module <b>305</b> can use techniques other than interfacing with the operating system to determine whether a task is livelocked.</p>
<p id="p-0030" num="0029">In one embodiment, the detection module <b>305</b> determines whether a task is livelocked by periodically inspecting the task to determine whether it is using an inordinate amount of computing resources. For example, the detection module <b>305</b> can interface with the operating system to periodically obtain data about (i.e., sample) the resources being consumed by the task at that instant. If the task is consuming an inordinate amount of resources across a set of sequential samples describing the resource consumption over a length of time, the detection module <b>305</b> queues the task for additional inspection. The level of resource utilization considered &#x201c;inordinate&#x201d; is established using one or more pre-specified thresholds and/or via other techniques. In one embodiment, an &#x201c;inordinate&#x201d; amount is most or all of a resource.</p>
<p id="p-0031" num="0030">For example, in one embodiment the detection module <b>305</b> determines whether a task is consuming an inordinate amount of CPU time. The detection module <b>305</b> periodically interfaces with the operating system to sample the CPU time consumed by the task. If the task exceeds a threshold amount of CPU time (e.g., 95% of available time from one core of the processor <b>202</b>), for a threshold number of sequential samples (e.g., 10 samples and/or 30 seconds worth of samples), the detection module <b>305</b> places the task in a queue of tasks to be inspected.</p>
<p id="p-0032" num="0031">Different embodiments of the detection module <b>305</b> sample the operating system to determine utilization of other computing resources, and use different thresholds for different resources and/or tasks. Thus, the detection module <b>305</b> can use different thresholds for a task known to be a heavy resource consumer than it uses for a task known to be a light resource consumer. In addition, the detection module <b>305</b> can use different thresholds for different resources to determine whether to queue the task for additional inspection.</p>
<p id="p-0033" num="0032">The detection module <b>305</b> inspects queued tasks to determine whether the tasks are making tangible progress. The detection module <b>305</b> determines whether a task is making progress over the time window of detailed inspection. In this context, &#x201c;making progress&#x201d; means working toward a goal, be it analyzing a file for malicious software, playing a video, or saving a file to the storage device <b>208</b>.</p>
<p id="p-0034" num="0033">The detection module <b>305</b> can use a variety of techniques to determine whether a task is making tangible progress. In one embodiment, the task queued for inspection is associated with a process, and the detection module <b>305</b> identifies the busiest thread or threads of the process as part of the inspection. The detection module <b>305</b> inspects the register contexts associated with the one or more busiest threads to determine whether the threads are making progress.</p>
<p id="p-0035" num="0034">In one embodiment, this inspection is performed by sampling the register contents of the thread periodically, and grouping the state of the instruction pointer (i.e., the address of the code in memory the processor <b>202</b> is executing) with the state of the data registers. The detection module <b>305</b> analyzes the register contents over the multiple samples for evidence that the thread is livelocked.</p>
<p id="p-0036" num="0035">For example, for a given thread, the detection module <b>305</b> may determine whether the contents of multiple registers associated with the thread are changing over time. Generally, the contents of the instruction pointer and data registers should change over time as the processor <b>202</b> processes data for the thread. Hence, static register contents are evidence that the thread is not making progress and is therefore livelocked.</p>
<p id="p-0037" num="0036">Similarly, the detection module <b>305</b> may determine whether the contents of only one data register are changing over time as the processor <b>202</b> processes data for the thread. This situation often indicates that the thread is using the changing register as a counter. However, if the register is constantly counting but the contents of the other data registers do not change, then the single changing register is evidence that the thread execution is stuck in a counting state and therefore the thread is livelocked.</p>
<p id="p-0038" num="0037">The detection module <b>305</b> may also determine whether the contents of the registers are changing in a cyclical pattern, or in a small set of patterns. Typically, register contents will not follow repeating patterns while the processor <b>202</b> processes data for the thread. Repeating patterns are evidence is that the thread execution is stuck in a loop and therefore the thread is livelocked. Other embodiments of the detection module <b>305</b> can use other techniques to examine the thread and associated registers for evidence that the thread is livelocked.</p>
<p id="p-0039" num="0038">The detection module <b>305</b> analyzes the information described above to determine whether a task is livelocked. For example, if the detection module <b>305</b> identifies a process as consuming an inordinate amount of CPU time, and further analysis of the process shows that the register contents of one of its threads changes in a repeating pattern, the detection module <b>305</b> declares the process and thread livelocked. Depending upon the embodiment, the detection module <b>305</b> may combine or weight different types of evidence differently when making the livelock determination. Likewise, other embodiments can use different and/or additional techniques to determine whether a task is livelocked.</p>
<p id="p-0040" num="0039">Furthermore, one embodiment of the detection module <b>305</b> uses one or more techniques to mitigate possible false-positive detections of livelocked tasks. In one embodiment, if resource utilization (e.g., processor <b>202</b> utilization or CPU time) falls below the livelock threshold at any time during the inspection, the detection module <b>305</b> concludes that the task has escaped livelock. Therefore, the detection module <b>305</b> discards its current inspection of the task and begins inspecting anew.</p>
<p id="p-0041" num="0040">In addition, an embodiment of the detection module <b>305</b> incorporates the &#x201c;idleness&#x201d; of the user of the client <b>105</b> when determine whether a task is livelocked. The detection module <b>305</b> can use a variety of metrics to determine whether the user is presently using the client <b>105</b>, such as whether mouse and/or keyboard input has been received within a specified time interval. If the user is not present (i.e., is idle), the livelock of a task is less noticeable. Accordingly, an embodiment of the detection module <b>305</b> aborts livelock detection while the user is idle. Another embodiment of the detection module <b>305</b> uses different detection thresholds depending upon whether the user is idle. For example, the detection module <b>305</b> can use a threshold that specifies a high rate of resource utilization over a greater number of sampling intervals if the user is idle than the number of sampling intervals used if a user is not idle.</p>
<p id="p-0042" num="0041">The detection module <b>305</b> can also incorporate the amount of computing resources available at the client <b>105</b> when determining whether a task is livelocked. For example, if the client <b>105</b> includes a single-core processor and/or is performing many tasks simultaneously, these conditions might cause the operating system to report misleading resource utilization information. If the client <b>105</b> has only a single core processor, the operating system might report that a task is utilizing an inordinate amount of CPU time even though the task is functioning normally. In such circumstances, an embodiment of the detection module <b>305</b> adjusts by raising the utilization threshold and/or lowering the utilization rate reported by the operating system.</p>
<p id="p-0043" num="0042">The data collection module <b>315</b> collects data describing a detected livelock event. In general, the data collection module <b>315</b> collects data that can be used by an application developer to determine the cause of an application's livelock. The specific types of collected data can vary in different embodiments. The data collection module <b>315</b> collects the data by interfacing with the operating system and/or via other techniques. In addition, some of the collected data may be gathered by the detection module <b>305</b> in the course of detecting the livelock event.</p>
<p id="p-0044" num="0043">In one embodiment, the data collection module <b>315</b> collects a memory dump describing the state of the livelocked task. The memory dump contains the state of the working memory of the task when the livelock is detected. Thus, it can include the contents of the address space allocated to a process having a livelocked thread. In addition, the memory dump collected by the data collection module <b>315</b> may also include the thread times showing the amount of processor resources consumed by the threads of the process. The memory dump may also include handle information describing file handles open at the time of the livelock.</p>
<p id="p-0045" num="0044">The data collection module <b>315</b> may also collect logs from one or more applications executing on the client <b>105</b> when the livelock is detected. Many applications maintain logs describing the operations performed by the applications. These logs are useful for determining the cause of a livelock event because they may indicate the specific operation during which the livelock occurred. The data collection module <b>315</b> may collect only the log of the application that had the livelocked task or collect logs from multiple different applications executing on the client <b>105</b>.</p>
<p id="p-0046" num="0045">An embodiment of the data collection module <b>315</b> further collects data describing other tasks executing on the client <b>105</b> when the livelock is detected. These data may include a list of running processes and performance data for those processes. For example, the data collection module <b>315</b> can collect data describing the processor and/or memory resources consumed by each of the other running processes.</p>
<p id="p-0047" num="0046">The data collection module <b>315</b> may also collect identification data that can be used to uniquely identify the livelock event. These data can include a unique identifier (ID) of the client <b>105</b>. This ID can be assigned by the reporting module <b>115</b> or by another module on the client <b>105</b>. In one embodiment, the ID is anonymous and allows livelock events from the client <b>105</b> to be identified without revealing other information about the client and/or user. The data for identifying the livelock event can also include an identifier of a non-operating system module on the stack of the livelocked thread, the name of the process in which the module on the stack is running (i.e., the process associated with the address space in which the module on the stack is running), and the most common module offset detected on the stack of the module on the stack of the livelocked thread. The data collection module <b>315</b> can gather this stack information by, e.g., using stack-walking APIs provided by the operating system.</p>
<p id="p-0048" num="0047">The report generation module <b>320</b> generates and transmits livelock reports to the server <b>135</b> via the network <b>125</b>. A livelock report describes a livelock event detected at the client <b>105</b>. The livelock report for an event includes all or some of the data collected by the data collection module <b>315</b> for that event. The report generation module <b>320</b> may transmit the report to the server <b>135</b> upon detection of the event, or at other times such as when the client <b>105</b> is idle.</p>
<p id="p-0049" num="0048">In one embodiment, the report generation module <b>320</b> generates an ID for the report using the identification data collected by the data collection module <b>315</b>. This ID may be based on a hash of the identification data. The report generation module <b>320</b> may generate the hash using locality-sensitive hashing techniques so that hashes based on similar identification data are similar. Thus, reports from similar livelock events from different clients <b>105</b> will have similar IDs. This similarity allows an analyst at the server <b>135</b> to group livelock reports based on similarity, which may assist in determining the causes of the livelock events.</p>
<p id="p-0050" num="0049">The data storage module <b>325</b> stores data used by the reporting module <b>115</b> during its operation. The stored data can include sample data, thresholds, and inspection data obtained and used by the detection module <b>305</b> to detect livelock events. The stored data can also include data describing the livelock events and identification data collected by the data collection module <b>315</b>, as well as reports generated by the report generation module <b>320</b>. The data storage module <b>325</b> may include a relational or other form of database to enable efficient storage and retrieval of the data. In one embodiment the data storage module <b>325</b> stores the data on the storage device <b>208</b> of the client <b>105</b>.</p>
<p id="p-0051" num="0050"><figref idref="DRAWINGS">FIG. 4</figref> is a flowchart illustrating a method for reporting a livelock event performed by the reporting module <b>115</b> according to one embodiment. Other embodiments can perform the steps of the method in different orders and can include different and/or additional steps. In addition, some or all of the steps can be performed by entities other than the reporting module <b>115</b>.</p>
<p id="p-0052" num="0051">The reporting module <b>115</b> detects <b>405</b> a livelock event by analyzing state information about the client <b>105</b> to identify a task executing on the client that is livelocked. This analysis involves periodically inspecting the task to determine whether it is using an inordinate amount of computing resources. The reporting module <b>115</b> also determines whether the task is making tangible progress by, e.g., inspecting register contents associated with the task.</p>
<p id="p-0053" num="0052">If a livelock event is detected, the reporting module <b>115</b> collects <b>415</b> data describing the livelock event. These data include, e.g., a memory dump describing the state of the livelocked task, logs from one or more applications executing on the client <b>105</b>, and data describing other tasks executing on the client. The reporting module <b>115</b> also collects <b>415</b> identification data for uniquely identifying the livelock event. The reporting module <b>115</b> generates <b>425</b> a livelock report describing the livelock event. In one embodiment, the generated report is identified using a hash generated from the identification data for the livelock event. The reporting module <b>115</b> transmits <b>435</b> the livelock report to the server <b>135</b>.</p>
<p id="p-0054" num="0053">The above description is included to illustrate the operation of certain embodiments and is not meant to limit the scope of the invention. The scope of the invention is to be limited only by the following claims. From the above discussion, many variations will be apparent to one skilled in the relevant art that would yet be encompassed by the spirit and scope of the invention.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>The invention claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A computer-implemented method of reporting a livelock event occurring on a computer, comprising:
<claim-text>specifying a threshold amount of a computing resource used to determine whether a task executing on the computer is livelocked in response to past computing resource consumption by the task, wherein different threshold amounts of the computing resource are specified for different tasks;</claim-text>
<claim-text>in response to resource consumption by the task exceeding the threshold amount of the computing resource, detecting a livelock event involving the task executing on the computer by performing at least one inspection from a set of inspections of registers of a processor executing the task to determine that the task is not making tangible progress, the set of inspections consisting of:
<claim-text>determining whether contents of multiple ones of the registers are changing over time;</claim-text>
<claim-text>determining whether the registers indicate that the task is stuck in a counting state; and</claim-text>
<claim-text>determining whether the register contents are changing in a cyclical pattern;</claim-text>
</claim-text>
<claim-text>collecting state data describing the detected livelock event;</claim-text>
<claim-text>generating a livelock report including the collected state data; and</claim-text>
<claim-text>transmitting the livelock report to a server.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein detecting the livelock event involving the task executing on the computer comprises:
<claim-text>detecting that the task is not making tangible progress according to at least one inspection while resource consumption by the task exceeds the threshold amount of the computing resource.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein detecting the livelock event involving the task executing on the computer comprises:
<claim-text>periodically sampling to determine an amount of the computing resource being consumed by the task to produce sequential samples; and</claim-text>
<claim-text>performing the at least one inspection in response to determining whether the task consumes more than the threshold amount of the computing resource in each of a threshold number of sequential samples.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, further comprising:
<claim-text>determining whether a user of the computer is idle; and</claim-text>
<claim-text>varying the threshold number of sequential samples responsive to whether the user of the computer is idle.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein collecting state data describing the detected livelock event comprises collecting one or more from the set consisting of:
<claim-text>a memory dump describing a state of the livelocked task;</claim-text>
<claim-text>logs from one or more applications executing on the computer when the livelock is detected; and</claim-text>
<claim-text>data describing other tasks executing on the computer when the livelock is detected.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein generating a livelock report comprises:
<claim-text>collecting identification data uniquely identifying the livelock event; and</claim-text>
<claim-text>generating a hash of the identification data, the hash generated such that similar livelock events have similar hashes.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. A non-transitory computer-readable storage medium storing executable computer program instructions for reporting a livelock event occurring on a computer, the instructions performing steps comprising:
<claim-text>specifying a threshold amount of a computing resource used to determine whether a task executing on the computer is livelocked in response to past computing resource consumption by the task, wherein different threshold amounts of the computing resource are specified for different tasks;</claim-text>
<claim-text>in response to resource consumption by the task exceeding the threshold amount of the computing resource, detecting a livelock event involving the task executing on the computer by performing at least one inspection from a set of inspections on registers of a processor executing the task to determine that the task is not making tangible progress, the set of inspections consisting of:
<claim-text>determining whether contents of multiple ones of the registers are changing over time;</claim-text>
<claim-text>determining whether the registers indicate that the task is stuck in a counting state; and</claim-text>
<claim-text>determining whether the register contents are changing in a cyclical pattern;</claim-text>
</claim-text>
<claim-text>collecting state data describing the detected livelock event;</claim-text>
<claim-text>generating a livelock report including the collected state data; and</claim-text>
<claim-text>transmitting the livelock report to a server.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The storage medium of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein detecting the livelock event involving the task executing on the computer comprises:
<claim-text>detecting that the task is not making tangible progress according to at least one inspection while resource consumption of the task exceeds the threshold amount of the computing resource.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The storage medium of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein detecting the livelock event involving the task executing on the computer comprises:
<claim-text>periodically sampling to determine an amount of the computing resource being consumed by the task to produce sequential samples; and</claim-text>
<claim-text>performing the at least one inspection in response to determining whether the task consumes more than the threshold amount of the computing resource in each of a threshold number of sequential samples.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The storage medium of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein collecting state data describing the detected livelock event comprises collecting one or more from the set consisting of:
<claim-text>a memory dump describing a state of the livelocked task;</claim-text>
<claim-text>logs from one or more applications executing on the computer when the livelock is detected; and</claim-text>
<claim-text>data describing other tasks executing on the computer when the livelock is detected.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The storage medium of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein generating a livelock report comprises:
<claim-text>collecting identification data uniquely identifying the livelock event; and generating a hash of the identification data, the hash generated such that similar livelock events have similar hashes.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. A computer system for reporting a livelock event, the computer system comprising:
<claim-text>a non-transitory computer-readable storage medium storing executable computer program instructions for performing steps comprising:</claim-text>
<claim-text>specifying a threshold amount of a computing resource used to determine whether a task executing on the computer is livelocked in response to past computing resource consumption by the task, wherein different threshold amounts of the computing resource are specified for different tasks;</claim-text>
<claim-text>in response to resource consumption by the task exceeding the threshold amount of the computing resource, detecting a livelock event involving the task executing on the computer by performing at least one inspection from a set of inspections on registers of a processor executing the task to determine that the task is not making tangible progress, the set of inspections consisting of:
<claim-text>determining whether contents of multiple ones of the registers are changing over time;</claim-text>
<claim-text>determining whether the registers indicate that the task is stuck in a counting state; and</claim-text>
<claim-text>determining whether the register contents are changing in a cyclical pattern;</claim-text>
</claim-text>
<claim-text>collecting state data describing the detected livelock event;</claim-text>
<claim-text>generating a livelock report including the collected state data;</claim-text>
<claim-text>transmitting the livelock report to a server; and</claim-text>
<claim-text>a processor for executing the computer program instructions.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The computer system of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein detecting the livelock event involving the task executing on the computer comprises:
<claim-text>detecting that the task is not making tangible progress according to at least one inspection while resource consumption of the task exceeds the threshold amount of the computing resource.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The computer system of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein detecting the livelock event involving the task executing on the computer comprises:
<claim-text>periodically sampling to determine an amount of the computing resource being consumed by the task to produce sequential samples; and</claim-text>
<claim-text>performing the at least one inspection in response to determining whether the task consumes more than the threshold amount of the computing resource in each of a threshold number of sequential samples.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>determining whether a user of the computer is idle in response to whether a monitored input is received within a specified time interval; and</claim-text>
<claim-text>specifying the threshold amount of computing resource used to determine whether the task executing on the computer is livelocked in response to whether the user of the computer is idle.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:
<claim-text>determining a number of tasks being performed simultaneously by the processor; and</claim-text>
<claim-text>specifying the threshold amount of computing resource used to determine whether the task executing on the computer is livelocked in response to the number of tasks being performed simultaneously by the processor.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The storage medium of <claim-ref idref="CLM-00007">claim 7</claim-ref>, further comprising:
<claim-text>determining whether a user of the computer is idle in response to whether a monitored input is received within a specified time interval; and</claim-text>
<claim-text>specifying the threshold amount of computing resource used to determine whether the task executing on the computer is livelocked in response to whether the user of the computer is idle.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The storage medium of <claim-ref idref="CLM-00007">claim 7</claim-ref>, further comprising:
<claim-text>determining a number of tasks being performed simultaneously by the processor; and</claim-text>
<claim-text>specifying the threshold amount of computing resource used to determine whether the task executing on the computer is livelocked in response to the number of tasks being performed simultaneously by the processor.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The computer system of <claim-ref idref="CLM-00012">claim 12</claim-ref>, further comprising:
<claim-text>determining whether a user of the computer is idle in response to whether a monitored input is received within a specified time interval; and</claim-text>
<claim-text>specifying the threshold amount of computing resource used to determine whether the task executing on the computer is livelocked in response to whether the user of the computer is idle.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The computer system of <claim-ref idref="CLM-00012">claim 12</claim-ref>, further comprising:
<claim-text>determining a number of tasks being performed simultaneously by the processor; and</claim-text>
<claim-text>specifying the threshold amount of computing resource used to determine whether the task executing on the computer is livelocked in response to the number of tasks being performed simultaneously by the processor. </claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
