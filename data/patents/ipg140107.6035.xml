<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627158-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627158</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13314657</doc-number>
<date>20111208</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<us-term-of-grant>
<us-term-extension>105</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>11</class>
<subclass>C</subclass>
<main-group>29</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>714723</main-classification>
<further-classification>714718</further-classification>
</classification-national>
<invention-title id="d2e53">Flash array built in self test engine with trace array and flash metric reporting</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6058047</doc-number>
<kind>A</kind>
<name>Kikuchi</name>
<date>20000500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>36518533</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6560740</doc-number>
<kind>B1</kind>
<name>Zuraski, Jr. et al.</name>
<date>20030500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6831865</doc-number>
<kind>B2</kind>
<name>Chang et al.</name>
<date>20041200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>36518533</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>7137027</doc-number>
<kind>B2</kind>
<name>Shiota et al.</name>
<date>20061100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714  51</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>7167399</doc-number>
<kind>B2</kind>
<name>Wooldridge</name>
<date>20070100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>36518529</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>7277011</doc-number>
<kind>B2</kind>
<name>Estakhri</name>
<date>20071000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>340540</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>7302625</doc-number>
<kind>B1</kind>
<name>Payakapan et al.</name>
<date>20071100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>7421636</doc-number>
<kind>B2</kind>
<name>Kang et al.</name>
<date>20080900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>7603603</doc-number>
<kind>B2</kind>
<name>Dubey</name>
<date>20091000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>7607055</doc-number>
<kind>B2</kind>
<name>Jung et al.</name>
<date>20091000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>7865761</doc-number>
<kind>B1</kind>
<name>Chilton</name>
<date>20110100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714  2</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2004/0049724</doc-number>
<kind>A1</kind>
<name>Bill et al.</name>
<date>20040300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2010/0017664</doc-number>
<kind>A1</kind>
<name>Jang</name>
<date>20100100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2011/0072302</doc-number>
<kind>A1</kind>
<name>Sartore</name>
<date>20110300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714  632</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>EP</country>
<doc-number>1826580</doc-number>
<kind>A1</kind>
<date>20070800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>WO</country>
<doc-number>WO2004010437</doc-number>
<kind>A1</kind>
<date>20040100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>20</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>714718</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714723</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714763</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>36518533</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>8</number-of-drawing-sheets>
<number-of-figures>8</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20130151914</doc-number>
<kind>A1</kind>
<date>20130613</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Cadigan</last-name>
<first-name>David D.</first-name>
<address>
<city>Brewster</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Griffin</last-name>
<first-name>Thomas J.</first-name>
<address>
<city>Salt Point</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Shetty</last-name>
<first-name>Archana</first-name>
<address>
<city>Bangalore</city>
<country>IN</country>
</address>
</addressbook>
<residence>
<country>IN</country>
</residence>
</us-applicant>
<us-applicant sequence="004" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Tressler</last-name>
<first-name>Gary A.</first-name>
<address>
<city>Sandy Hook</city>
<state>CT</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="005" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Vanstee</last-name>
<first-name>Dustin J.</first-name>
<address>
<city>Poughkeepsie</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Cadigan</last-name>
<first-name>David D.</first-name>
<address>
<city>Brewster</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Griffin</last-name>
<first-name>Thomas J.</first-name>
<address>
<city>Salt Point</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Shetty</last-name>
<first-name>Archana</first-name>
<address>
<city>Bangalore</city>
<country>IN</country>
</address>
</addressbook>
</inventor>
<inventor sequence="004" designation="us-only">
<addressbook>
<last-name>Tressler</last-name>
<first-name>Gary A.</first-name>
<address>
<city>Sandy Hook</city>
<state>CT</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="005" designation="us-only">
<addressbook>
<last-name>Vanstee</last-name>
<first-name>Dustin J.</first-name>
<address>
<city>Poughkeepsie</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Cantor Colburn LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Kinnaman, Jr.</last-name>
<first-name>William A.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Kerveros</last-name>
<first-name>James C</first-name>
<department>2117</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A mechanism is provided for a flash array test engine. The flash array test engine includes a circuit. The circuit is configured to generate test workloads in a test mode for testing a flash device array, where each of the test workloads includes specific addresses, data, and command patterns to be sent to the flash device array. The circuit is configured to accelerate wear in the flash device array, via the test workloads, at an accelerated rate relative to general system workloads that are not part of the test mode. The circuit is configured to vary a range of conditions for the flash device array to determine whether each of the conditions passes or fails and to store failure data and corresponding failure data address information for the flash device array.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="178.99mm" wi="235.12mm" file="US08627158-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="239.18mm" wi="183.56mm" orientation="landscape" file="US08627158-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="217.17mm" wi="181.86mm" orientation="landscape" file="US08627158-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="225.38mm" wi="191.77mm" orientation="landscape" file="US08627158-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="241.81mm" wi="191.77mm" orientation="landscape" file="US08627158-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="215.82mm" wi="193.72mm" orientation="landscape" file="US08627158-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="206.59mm" wi="185.50mm" orientation="landscape" file="US08627158-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="211.84mm" wi="184.83mm" orientation="landscape" file="US08627158-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="195.07mm" wi="160.44mm" orientation="landscape" file="US08627158-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND</heading>
<p id="p-0002" num="0001">Exemplary embodiments relate to flash memory devices, and more specifically, to performing built in self test of an array of flash memory cells.</p>
<p id="p-0003" num="0002">Flash memory is a nonvolatile computer storage chip that can be electrically erased and reprogrammed. It was developed from EEPROM (electrically erasable programmable read only memory) and must be erased in fairly large blocks before these can be rewritten with new data. The high density NAND (not and) type must also be programmed and read in (smaller) blocks, or pages, while the NOR (not or) type allows a single machine word (byte) to be written and/or read independently.</p>
<p id="p-0004" num="0003">The NAND type of flash memory is primarily used in memory cards, USB (universal serial bus) flash drives, solid state drives (SSD), and similar products, for general storage and transfer of data. The NOR type, which allows true random access and therefore direct code execution, is used as a replacement for the older EPROM and as an alternative to certain kinds of read only memory (ROM) applications.</p>
<p id="p-0005" num="0004">Flash memory is a memory chip that maintains stored information without requiring a power source. It is often used in portable electronics, like MP3 players, and in removable storage devices. Flash memory differs from regular EEPROM in that EEPROM erases its content one byte at a time. This makes it slow to update. Flash memory can erase its data in entire blocks, making it a desired technology for applications that require frequent updating of large amounts of data as in the case of a memory stick.</p>
<p id="p-0006" num="0005">Inside the flash memory (chip), information is stored in cells. A floating gate (FG) protects the data written in each cell. Tunneling electrons pass through a low conductivity material to change the electronic charge of the gate in &#x201c;a flash,&#x201d; clearing the cell of its contents so that it can be rewritten. This is how flash memory gets its name.</p>
<p id="p-0007" num="0006">Flash memory stores information in an array of memory cells made from floating gate transistors. In traditional single-level cell (SLC) devices, each cell stores only one bit of information. Some newer flash memory, known as multi-level cell (MLC) devices, can store more than one bit per cell by choosing between multiple levels of electrical charge to apply to the floating gates of its cells.</p>
<p id="p-0008" num="0007">The floating gate of a floating gate transistor may be conductive (typically polysilicon in most kinds of flash memory) or non-conductive. In flash memory, each memory cell resembles a standard MOSFET (metal oxide semiconductor field effect transistor), except the transistor has two gates instead of one. On top is the control gate (CG), as in other MOS transistors, but below this there is a floating gate insulated all around by an oxide layer. The floating gate is interposed between the control gate and the MOSFET channel. Because the floating gate is electrically isolated by its insulating layer, any electrons placed on it are trapped there, and under normal conditions, will not discharge for many years. When the floating gate holds a charge, it screens (partially cancels) the electric field from the control gate, which modifies the threshold voltage (VT) of the cell. During read-out, a voltage intermediate between the possible threshold voltages is applied to the control gate, and the MOSFET channel will become conducting or remain insulating, depending on the threshold voltage of the cell, which is in turn controlled by charge on the floating gate. The current flow through the MOSFET channel is sensed and forms a binary code, reproducing the stored data. In a multilevel cell device, which stores more than one bit per cell, the amount of current flow is sensed (rather than simply its presence or absence), in order to determine more precisely the level of charge on the floating gate.</p>
<heading id="h-0002" level="1">BRIEF SUMMARY</heading>
<p id="p-0009" num="0008">According to exemplary embodiments, a flash array test engine is provided. The flash array test engine includes a circuit. The circuit is configured to generate test workloads in a test mode for testing a flash device array, where each of the test workloads includes specific addresses, data, and command patterns to be sent to the flash device array. The circuit is configured to accelerate wear in the flash device array, via the test workloads, at an accelerated rate relative to general system workloads that are not part of the test mode. The circuit is configured to vary a range of conditions for the flash device array to determine whether each of the conditions passes or fails and to store failure data and corresponding failure data address information for the flash device array.</p>
<p id="p-0010" num="0009">According to an exemplary embodiment, a method for a flash array test engine circuit is provided. The method includes generating test workloads in a test mode for testing a flash device array, where each of the test workloads includes specific addresses, data, and command patterns to be sent to the flash device array. The method includes accelerating wear in the flash device array, via the test workloads, at an accelerated rate relative to general system workloads that are not part of the test mode. The method includes varying a range of conditions for the flash device array to determine whether each of the conditions passes or fails, and storing failure data and corresponding failure data address information for the flash device array.</p>
<p id="p-0011" num="0010">According to an exemplary embodiment, a computer program product for a flash array test engine circuit is provided. The computer program product includes a computer readable storage medium having computer readable program code embodied therewith. The computer readable program code is configured for generating test workloads in a test mode for testing a flash device array, where each of the test workloads includes specific addresses, data, and command patterns to be sent to the flash device array. The computer readable program code is configured for accelerating wear in the flash device array, via the test workloads, at an accelerated rate relative to general system workloads that are not part of the test mode. The computer readable program code is configured for varying a range of conditions for the flash device array to determine whether each of the conditions passes or fails, and storing failure data and corresponding failure data address information for the flash device array.</p>
<p id="p-0012" num="0011">Additional features are realized through the techniques of the present disclosure. Other systems, methods, apparatus, and/or computer program products according to other embodiments are described in detail herein and are considered a part of the claimed invention. For a better understanding of exemplary embodiments and features, refer to the description and to the drawings.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS</heading>
<p id="p-0013" num="0012">The subject matter which is regarded as the invention is particularly pointed out and distinctly claimed in the claims at the conclusion of the specification. The foregoing and other features of the present disclosure are apparent from the following detailed description taken in conjunction with the accompanying drawings in which:</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram of a system illustrating a controller chip integrated flash array test engine that can be utilized to analyze a flash device array for reliability metrics and for debug purposes according to an exemplary embodiment.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram illustrating an example command primitive that can incorporate a higher level command syntax according to an exemplary embodiment.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 3</figref> is a flow chart illustrating a higher level diagnostic sequence for program disturbance effect evaluation according to an exemplary embodiment.</p>
<p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. 4</figref> is a block diagram of a system illustrating a controller chip according to an exemplary embodiment.</p>
<p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. 5</figref> is a flow chart illustrating details of a flash array metric tracking module according to an exemplary embodiment.</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 6</figref> illustrates a chart of captured data by a trace array logic module, a flash array metric tracking module, and/or by a combined circuit/module of both according to an exemplary embodiment.</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 7</figref> illustrates a flow chart of a process executed by one or more circuits implementing a flash array built in test engine according to an exemplary embodiment.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 8</figref> illustrates an example of a computer having capabilities/elements, which may be included in exemplary embodiments.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0022" num="0021">Exemplary embodiments are configured to provide a design that integrates into existing flash controller architectures and can be used during special test modes. Exemplary embodiments provide a controller chip (e.g., integrated circuit chip) with a flash array built in self test (FA-BIST) engine for testing an array of flash memory devices as shown in <figref idref="DRAWINGS">FIGS. 1 and 4</figref>. Typically, the flash array built in self test (FA-BIST) engine may be configured and invoked under debug conditions (e.g., during a test mode).</p>
<p id="p-0023" num="0022">Integrating flash memory devices into a solid state drive (SSD) and/or into an existing flash (controller) design may have reliability and functional challenges. For example, in exemplary embodiments, the controller chip of the flash memory devices is configured to understand and account for the existing raw bit error rate in the flash memory devices on a per block basis, and understand/account for when the implemented error code correction (ECC) scheme (of the flash memory devices being tested) will fail, because the controller chip is configured with the same ECC scheme.</p>
<p id="p-0024" num="0023">For example, exemplary embodiments can leverage the FA-BIST engine to test different targeted blocks and collect information about raw bit error rates, and to evaluate flash vendor endurance claims and specifications after program erase (PE) cycling and data retention testing. Also, the FA-BIST engine can be programmed to test flash memory devices in a solid state drive under controlled parameters similar to (or the same as) vendor specifications.</p>
<p id="p-0025" num="0024">The FA-BIST engine on the controller chip is configured to accelerate flash memory device wearing. For example, hardware assisted flash memory device wearing can speed up the rate of device wear using the FA-BIST engine. However, if general mainline control is used (without the FA-BIST engine of exemplary embodiments), this same wear on the memory cells of the flash memory device can typically take years to accomplish. This is because the FA-BIST engine is configured to continuously read, write, erase, etc., the same block or page in the flash memory device (without passing through a flash mainline management controller as shown in <figref idref="DRAWINGS">FIGS. 1 and 4</figref>). However, any read, write, and erase commands from a host system (computer) passes through the flash mainline management controller and are spread across available memory of the flash memory device.</p>
<p id="p-0026" num="0025">The FA-BIST engine is configured to test physical block(s) of memory in the flash memory devices and understand/recognize failure mechanisms (such as bad blocks due to stuck faults, too high of a bit error rate (BER), etc.), to utilize trace array failure logging to understand/recognize modes of failure, to specify a specific addressing and data pattern to a block of physical memory, and to be utilized for general debugging of the flash memory devices.</p>
<p id="p-0027" num="0026">All previous activity (testing/functional) to a memory cell affects its current cell behavior, and the FA-BIST engine is configured to monitor activity (including normal activity) over time independent of the flash device operation mode (e.g., independent of operating in a test mode). Integrated flash metric collection hardware (e.g., trace array logic and/or flash array metric tracking modules) monitors flash device usage statistics during the life of the flash device array.</p>
<p id="p-0028" num="0027">The FA-BIST engine on the controller chip can integrate external changing variables to create SSD stress to failure maps (also referred to as SSD level shmoos). The FA-BIST engine can be configured with the capability of measuring timing margins of synchronous signals in a system (e.g., in the array of flash memory devices) that has a bit error rate greater than 0, and measuring voltage and temperature to produce voltage versus temperature graphs for the flash memory devices.</p>
<p id="p-0029" num="0028">Now turning to the figures, <figref idref="DRAWINGS">FIG. 1</figref> is a block diagram of a system <b>100</b> of a controller chip integrated flash array built in test engine (FA-BIST) that can be utilized to analyze a flash device array for reliability metrics and for debug purposes according to an exemplary embodiment.</p>
<p id="p-0030" num="0029">The system <b>100</b> illustrates include a host computer <b>5</b> operatively connected to and/or coupled to a controller chip <b>105</b> via a mainline bus <b>7</b>. The controller chip <b>105</b> is configured to control reading and writing to a flash device array <b>110</b> (also referred to as a flash device). Also, the controller chip <b>105</b> is configured to analyze the flash device array <b>110</b> via a trace array logic module <b>25</b>, flash array metric tracking module <b>30</b>, FA-BIST address generator module <b>35</b>, FA-BIST command sequencer module <b>40</b>, FA-BIST data generator module <b>45</b>, and FA-BIST data comparator <b>50</b>, all of which comprise the FA-BIST engine <b>55</b>. The modules/circuits <b>25</b>, <b>30</b>, <b>35</b>, <b>40</b>, <b>45</b>, and <b>50</b> of the FA-BIST engine <b>55</b> can be implemented as hardware such as but not limited to an application specific integrated circuit (ASIC), a field programmable gate array (FPGA), etc., as software executing on hardware, and/or as a combination of both. The controller chip <b>105</b> may be implemented in (a circuit of) a processor chip, in a computer (such as the computer <b>5</b>), and/or as a stand-alone chip.</p>
<p id="p-0031" num="0030">The flash device array <b>110</b> is configured to store data and read data from an array of (flash) memory devices <b>120</b>. There may be 1 through M memory devices <b>120</b> in an array of (flash) memory device sites <b>115</b>, with N representing a last memory device <b>120</b>. There may be 1 through N memory device sites <b>115</b>, with N representing a last memory device site <b>115</b>. As understood by one skilled in the art, each memory device <b>120</b> may correspond to one or more memory cells for storing data. The memory cells can be made up of transistors configured to store data.</p>
<p id="p-0032" num="0031">During normal operation mode (i.e., not in test mode), the computer <b>5</b> can send read and write commands over the mainline bus <b>7</b> to a host protocol translator <b>10</b>. The host protocol translator <b>10</b> is a command interface input and output (I/O) that receives the mainline command from the computer <b>5</b> and translates the mainline command into actions which may be a read and store/write command on the flash device array <b>110</b>. A flash mainline management controller <b>15</b> receives the mainline command (read and write commands) from the host protocol translator <b>10</b> and provides the mainline command to flash (I/O) ports <b>20</b> to perform the respective read command and write command on (e.g., intentionally spread across) various memory devices <b>120</b> on the flash device array <b>110</b>. The mainline bus <b>7</b> is connected from the computer <b>5</b>, via elements <b>10</b>, <b>15</b>, and <b>20</b> to the flash device array <b>110</b>. The FA-BIST engine <b>55</b> is configured to capture various data during the normal operation mode by snooping on the mainline bus <b>7</b>, which is discussed further herein.</p>
<p id="p-0033" num="0032">The controller chip <b>105</b> may be initiated by the computer <b>5</b> to execute test mode (and/or debug mode). For example, the controller chip <b>105</b> may receive a test command from the computer <b>5</b> on the mainline bus <b>7</b>. During test mode, the FA-BIST engine <b>55</b> is configured to analyze the memory devices <b>120</b> of the flash device array <b>110</b>.</p>
<p id="p-0034" num="0033">The address generator <b>35</b> is configured to specify the flash array address boundaries for testing of the flash device array <b>110</b>, and the flash array addresses and/or boundaries are input to the command sequencer <b>40</b>. The data pattern generator <b>45</b> is configured to create fixed data patterns and/or pseudo random data patterns for testing the flash device array <b>110</b>, and input the fixed/pseudo random data patterns to the command sequencer <b>40</b>. The fixed data patterns and/or pseudo random data patterns are an arranged collection of data to be written to (and/or erased from) the flash device array <b>110</b>.</p>
<p id="p-0035" num="0034">The command sequencer <b>40</b> receives input from the address generator <b>35</b> and the data pattern generator <b>45</b>. The command sequencer <b>40</b> is configured to generate the erase, program, and read commands (i.e., command primitives) to the flash device array <b>110</b> with proper command timings. The command timings can be according to an algorithm and/or can be deterministic.</p>
<p id="p-0036" num="0035">The data comparator (circuit) <b>50</b> is configured to execute different flash comparison schemes (such as ECC mode, RAW mode, random data mode, etc.,) to determine if the data pattern read out of flash device array <b>110</b> (device under test (DUT)) failed or passed. ECC mode means that when data is read back, the extra check bits encoded are used to verify the integrity of the data. In RAW mode, the data integrity is checked based on using expected data patterns. For example, RAW mode would be a fixed data mode where the data read back is a deterministic value every time. Another example is random data mode using a pseudo random number generator to create a predictable sequence of data patterns. The data comparator <b>50</b> receives the command from the command sequencer <b>40</b> along with the input data pattern and receives the output data pattern that comes from the flash device array <b>110</b>. The input and output data patterns should be the same. The data comparator <b>50</b> is configured to compare the input data pattern and the output data pattern, execute any error code correction (which is designed to be the same as the vendor applied ECC for the flash device array <b>110</b>) on the output data pattern if necessary, and output comparison data to the flash array metric tracking module <b>30</b>.</p>
<p id="p-0037" num="0036">The flash array metric tracking module <b>30</b> (which is a per block data collection unit and/or counter) is configured to collect/snoop (store) data from the mainline bus <b>7</b> and to collect data from the data comparator <b>50</b> on a per command, block, page, and/or ECC sector basis. Also, the flash array metric tracking module <b>30</b> is configured to perform per command based tracking and fail bits per sector tracking as further discussed in a table below. The flash array metric tracking module <b>30</b> is configured to be utilized in both mainline operation (i.e., normal operation) and FA-BIST engine <b>55</b> operations to track flash array metrics of the flash device array <b>110</b>. The output comparison data and mainline operation data collected by flash array metric tracking module <b>30</b> may include cycling data, bit error rate (BER) data, frequency of access data, and utilization data, all corresponding to the flash device array <b>110</b>.</p>
<p id="p-0038" num="0037">The trace array logic (module) <b>25</b> is configured to collect data from the mainline bus <b>7</b> going to and from the flash device array <b>110</b>. Trace array logic <b>25</b> is configured with FA-BIST logging capability, and is configured to capture command traces during real time operation (i.e., normal/mainline operation) of the flash device array <b>110</b>, e.g., when the computer <b>5</b> sends read and write commands to the flash device array <b>110</b>. Also, trace array logic module <b>25</b> is configured to collect failure logs that contain memory address (location) and data payload of failed read commands from the flash device array <b>110</b>. The trace array logic module <b>25</b> also includes a command replay mechanism, which uses information from the trace array to replay a sequence of commands that were directed to the flash device array <b>110</b>.</p>
<p id="p-0039" num="0038">Further, details of the operation of the FA-BIST engine <b>55</b> are provided below. Assume that the FA-BIST engine <b>55</b> has been initiated by a user of the control chip <b>105</b>, that the FA-BIST engine <b>55</b> is running a periodic test of the flash device array <b>110</b>, the FA-BIST engine <b>55</b> has been initiated by a user of the computer <b>5</b>, and/or the FA-BIST engine <b>55</b> is turned on (initiated, e.g., for snooping).</p>
<p id="p-0040" num="0039">The address generator <b>35</b> is configured to generate a stream of addresses associated with a command primitive in the command sequencer <b>40</b> and inputs the stream of addresses to the command sequencer <b>40</b>. Each address stream requires configuration registers (e.g., registers <b>42</b> in the command sequencer <b>40</b>) to set up an address range and/or set of address ranges. Each address range (of the command sequencer <b>40</b>) is a logical address space that can be physically mapped (to individual cells (including blocks or pages) in each of the individual memory devices <b>120</b> in the flash device array <b>110</b>) to span all the way from a single page/block (within a single memory device <b>120</b>) to multiple memory devices <b>120</b>. Additional configuration for each address range is used (by the command sequencer <b>40</b>) to describe the type of address generation such as deterministic (i.e. fixed pattern, sequential, etc.) and/or pseudo random.</p>
<p id="p-0041" num="0040">The data pattern generator <b>45</b> is configured to create a stream of data patterns associated with a command primitive in the command sequencer <b>40</b>. The command primitives requiring data to be driven to the flash device array <b>110</b>, usually program (write) operations and/or a sequence of program operations, would use the data pattern generator <b>45</b> for this purpose. Each data stream from the data pattern generator <b>45</b> has a configuration that describes a data pattern and/or set of data patterns. Inherent to each data pattern configuration is the type of data generation, e.g., deterministic data pattern or pseudo random data pattern. Deterministic data pattern definitions can be derived from a fixed pattern generator (implemented by the data pattern generator <b>45</b>) and/or consist of patterns stored in a piece of buffer memory on the controller chip <b>105</b> and/or on the flash device array <b>110</b>. The buffer memory can be volatile random access memory (RAM) (that, e.g., can be coupled to the data pattern generator <b>45</b> on the controller chip <b>45</b> such as buffer memory <b>47</b>) and/or some section of the flash device array <b>110</b> (flash media) itself (such as buffer memory <b>48</b>). The random data pattern definition will leverage a random data generator (e.g., implemented by the data pattern generator <b>45</b>) so that pseudo random data can be deterministically generated.</p>
<p id="p-0042" num="0041">The command sequencer <b>40</b> may be the central engine for the FA-BIST engine <b>55</b> (function). The command sequencer <b>40</b> generates and/or operates on a command set primitive that can be as simple as a single flash device command and/or as complex as a concatenation of multiple flash commands to the flash device array <b>110</b>. Buffer memory <b>47</b> and/or <b>48</b> may be utilized to define the set of program (write) and/or read operations to be executed in a single command set primitive. Associated with each program and/or read operation in the command set primitive is an address range and/or address generation stream (via the address generator <b>35</b>), and, if desired, an associated data pattern generation/comparison stream (for later comparison by the data comparator <b>50</b>).</p>
<p id="p-0043" num="0042">The command sequencer <b>40</b> is coupled to the flash interface specifications and resolves the elements of the command set primitive into flash commands. For complex command primitives, command sequencing by the command sequencer <b>40</b> can consist of modes that control the number of program-erase (PE) (i.e., writing and erasing) cycles to an address range, and/or the number of read cycles to an address range. A complex command primitive can incorporate a higher level command syntax as shown in <figref idref="DRAWINGS">FIG. 2</figref> that exercises a higher level diagnostic sequence such as the example shown in <figref idref="DRAWINGS">FIG. 3</figref> for program disturbance effect evaluation.</p>
<p id="p-0044" num="0043">The command sequencer <b>40</b> transmits the command primitive to request a read command, erase command, and/or write command, or other flash support command (for the designated address range) to the flash device array <b>110</b> on the mainline bus <b>7</b> via the flash (I/O) ports <b>20</b>.</p>
<p id="p-0045" num="0044">The data pattern comparator <b>50</b> is configured to take as input a stream of data associated with a command primitive from the command sequencer <b>40</b>. The command primitives requiring data to be read from the flash device array <b>110</b>, usually read operations and/or a sequence of read operations, would use the data comparator <b>50</b> for validation of these operations (e.g., read operations) that should be performed by the flash device array <b>110</b>. The data comparator <b>50</b> is configured to use the fixed pattern generator and/or buffer memory <b>47</b>, <b>48</b> (associated with the appropriate deterministic program operation(s)) for deterministic data comparison and/or use the random data pattern generator (associated with the appropriate random data program operation(s)) for pseudo random data comparison. The data comparator <b>50</b> is configured to also apply different error correcting schemes to determine pass/fail thresholds for the different levels of correctability.</p>
<p id="p-0046" num="0045">Now turning to <figref idref="DRAWINGS">FIG. 2</figref>, a block diagram illustrates an example command set primitive <b>200</b> that can incorporate a higher level command syntax according to an exemplary embodiment. The command set primitive <b>200</b> shown in <figref idref="DRAWINGS">FIG. 2</figref> may be generated by the command sequencer <b>40</b>.</p>
<p id="p-0047" num="0046">The command set primitive <b>200</b> may include the command set <b>205</b> to be executed such as an ordered list of read command, erase command, write command, etc., by the flash device array <b>110</b>, and the channels <b>210</b>. Each command set <b>205</b> will be executed for the address specified in the command primitive <b>200</b>. Channels are another physical addressing descriptor. For example, a typical solid state drive (SSD) can have 16 flash sites, with 8 high stacks of flash devices (e.g., flash memory devices <b>120</b>) at each site. In this description, the channel is the bus that connects the controller to one of the flash sites (e.g., flash memory device sites <b>115</b>).</p>
<p id="p-0048" num="0047">The command set primitive <b>200</b> may also include memory device identification <b>215</b> which can be defined to individually correspond/associate to the one or more memory devices <b>120</b> at one or more memory device sites <b>115</b>. The command set primitive <b>200</b> also identifies the particular block(s) under test (BUT) <b>220</b> within each individually identified memory device <b>120</b> of the flash device array <b>110</b> (for which the command <b>205</b> is to be executed). The command set primitive <b>200</b> may identify the (exact) page(s) under test (PUT) <b>225</b> for which the command set <b>205</b> is to be executed in the flash device array <b>110</b>.</p>
<p id="p-0049" num="0048">The command set primitive <b>200</b> may also specify the data source (dataSrc) <b>230</b> for any data to be written (stored) to the identified memory device <b>215</b> (i.e., memory device <b>120</b>), block <b>220</b>, and page <b>225</b>. The data source <b>230</b> may be stored in the data generator <b>45</b> and/or external to the FA-BIST engine <b>55</b>.</p>
<p id="p-0050" num="0049">The command set primitive <b>200</b> is one instance of a set of commands sent to a single address. A test will consist of the list of command primitives <b>200</b>, merged with the address generator output. For example, if the address generator logical start address <b>290</b> is set to 0, and the logical end address <b>291</b> is set to 99, then there will be 100 sequential addresses generated. These addresses will go through the logical to physical mapping logic <b>292</b> to create the physical address defined in the command primitive <b>200</b>. For each address generated, the command set primitive <b>200</b> will be executed. The command sequencer <b>40</b> can (repeatedly) generate command set primitives <b>200</b> for address 0 through address N, where N represents a last address.</p>
<p id="p-0051" num="0050">Higher level tests as described in <figref idref="DRAWINGS">FIG. 3</figref> can be built from multiple test invocations of the FA-BIST engine <b>55</b>. <figref idref="DRAWINGS">FIG. 3</figref> highlights how a program disturbance (disturb) can be implemented using two (2) test invocations of the FA-BIST engine <b>55</b> along with loop counts and decrement and increment operations that are tracked by computer firmware.</p>
<p id="p-0052" num="0051"><figref idref="DRAWINGS">FIG. 3</figref> is a flow chart <b>300</b> illustrating a higher level diagnostic sequence for program disturbance effect evaluation (executed by the command sequencer <b>40</b> and the data comparator <b>50</b>) according to an exemplary embodiment. The data comparator <b>50</b> may communicate back and forth with the command sequencer <b>40</b> to execute the diagnostic sequence of <figref idref="DRAWINGS">FIG. 3</figref>, such that the correct (updated) command set primitive (as illustrated in <figref idref="DRAWINGS">FIG. 2</figref>) is sent to the flash device array <b>110</b>.</p>
<p id="p-0053" num="0052">A precondition (e.g., an erase command, a program (write) command, etc.) for the block under test (BUT) is identified/set at block <b>305</b>. The page under test (PUT) is identified/set at block <b>310</b>. Loop 1 is decremented at block <b>315</b>. It is determined whether Loop 1=0 at block <b>320</b>. If no, the flow proceeds to block <b>310</b>. If yes, the flow proceeds to read the block under test at block <b>325</b>. Loop 2 is decremented at block <b>330</b>. It is determined whether Loop 2=0, and if no, the flow proceeds to block <b>325</b>. If yes, the page under test (PUT) is set to (the previous) page under test+increment 1 at block <b>340</b>. Loop 3 is decremented at block <b>345</b>. It is determined whether Loop 3=0 at block <b>350</b>, and if no, the flow proceeds to block <b>305</b>. If yes, the flow ends.</p>
<p id="p-0054" num="0053">Loop 1=number of times to program the page set in the program disturbance test. The loop count is a variable that can be set in firmware and tracked to a threshold that will determine when test #1 is complete.</p>
<p id="p-0055" num="0054">Loop 2=read loops portion of test #2. The read loop is used to determine if any previously programmed bits in test #1 were disturbed. The number of bits in error will be recorded.</p>
<p id="p-0056" num="0055">Loop 3=controls next page to disturbance. Generally this test would only test one page at a time; therefore, the start and end address range for test #1 is of size equal to one page. Loop 3 variable will be maintained in firmware.</p>
<p id="p-0057" num="0056">By re-running this test and varying the Loop #1 count, it is possible to characterize the number of programs required to disturb adjacent cells.</p>
<p id="p-0058" num="0057">Further, regarding test #1, test #1 is comprised of blocks <b>305</b> and <b>310</b>. An example embodiment of this test using the command address data block in <figref idref="DRAWINGS">FIG. 2</figref> would be as follows. The start address <b>290</b> would equal 0, and the end address <b>291</b> would equal 128 decimal as an example. The logical to physical mapping logic <b>292</b> would be configured to map the least significant bit to the least significant page address bit and so on. Assume for this example that there are 128 pages per block. Since erase commands can only occur on block boundaries, an example constraint is that only if the page address equals zero would the erase command be sent. The command set <b>205</b> would be erase and program for 128 pages. Only one erase would be sent at the beginning of the test due to the previously mentioned constraint, and then 28 page programs to each page would be issued. For the program PUT (block <b>310</b>), the address space would then be reconfigured to start and end at the same page, and the command set would only consist of the page program. This test would be executed Loop1 times.</p>
<p id="p-0059" num="0058">Test #2 would then use the initial address settings configured for the precondition BUT (block <b>305</b>) test, and the command set <b>205</b> would be programmed to a single page read command. The test would be executed and the data would be read out of the flash physical location (memory device <b>120</b>) and compared to an expected pattern if in RAW mode, or the number of failing bits would be calculated by ECC in ECC data mode. Test #2 will be executed Loop2 times. The first time will attempt to detect any page program disturb sensitivity, and the subsequent times will start to measure read disturb sensitivity.</p>
<p id="p-0060" num="0059"><figref idref="DRAWINGS">FIG. 4</figref> illustrates a block diagram of a system <b>400</b> for another exemplary embodiment. Each element in the system <b>400</b> operates as discussed above for system <b>100</b> except as noted below. In system <b>400</b>, multiple copies of the FA-BIST structure such as the command sequencer <b>40</b>, the address generator <b>35</b>, the data pattern generator <b>45</b>, and the data comparator <b>50</b> can be instantiated so that multiple workloads can be driven to the flash device array <b>110</b>. This requires the addition of another design element, which is a workload scheduler <b>460</b>. The workload scheduler <b>460</b> is configured to take the outputs of the multiple FA-BIST structures and schedule the workloads according to a predefined configurable resource allocation mix. The workload scheduler <b>460</b> allows the FA-BIST engine <b>455</b> to represent different composite read and write workload operations typical in flash array applications (e.g., required by the computer <b>5</b>). The multiple command sequencers <b>40</b>, multiple address generators <b>35</b>, multiple data pattern generators <b>45</b>, and multiple data comparators <b>50</b> are illustrated as command sequencers <b>40</b><i>a</i>-<i>n</i>, address generators <b>35</b><i>a</i>-<i>n</i>, data pattern generators <b>45</b><i>a</i>-<i>n</i>, and data comparators <b>50</b><i>a</i>-<i>n</i>, where n is the last element. The description above for command sequencer <b>40</b>, the address generator <b>35</b>, the data pattern generator <b>45</b>, and the data comparator <b>50</b> (in <figref idref="DRAWINGS">FIG. 1</figref>) applies respectively to command sequencers <b>40</b><i>a</i>-<i>n</i>, address generators <b>35</b><i>a</i>-<i>n</i>, data pattern generators <b>45</b><i>a</i>-<i>n</i>, and data comparators <b>50</b><i>a</i>-<i>n </i>(in <figref idref="DRAWINGS">FIG. 4</figref>). Also, description for the FA-BIST engine <b>55</b> can also apply to the FA-BIST engine <b>455</b>.</p>
<p id="p-0061" num="0060">Now turning to <figref idref="DRAWINGS">FIG. 5</figref>, further details of the flash array metric tracking (module/circuit) <b>30</b> are provided according to an exemplary embodiment. <figref idref="DRAWINGS">FIG. 5</figref> is a flow chart <b>500</b> illustrating a solid state drive (SSD) event and metric recording executed by the flash array metric tracking module <b>30</b>.</p>
<p id="p-0062" num="0061">The flow chart <b>500</b> begins with the flash array metric tracking module <b>30</b> waiting for new command event having an event type at block <b>505</b>. The flash array metric tracking module <b>30</b> (metric recorder) is typically in a state awaiting new command events to arrive from the mainline bus <b>7</b> and/or from the data comparator <b>50</b>. A command event can be determined as one of two types of events at block <b>510</b>.</p>
<p id="p-0063" num="0062">The first type of event is an outbound command to the flash device array <b>110</b> such as a page program, block erase, write, etc. The second type of event is a read data event (in which data is read out from the flash device array <b>110</b>), and the read data event is sent to the flash array metric tracking module <b>30</b> via the data comparator <b>50</b>. The data corresponding to the read data event that is sent to the flash array metric tracking module <b>30</b> is the number of failing bits determined by the data comparator <b>50</b>. The frequency of a read (data) event will be based on the page size of the flash device array <b>110</b> and the number of ECC sectors in the (flash) page of the flash device array <b>110</b>. An ECC sector is defined by the flash vendor (i.e., maker or manufacturer of the flash device array <b>110</b>) at time of manufacturing, and the ECC sector is typically comprised of the actual data payload and the ECC bytes (B) required to protect the actual data payload. The ECC sector size is the total bytes in the page size divided by a power of 2. For example, a page comprised of 8192B (of actual data)+512B of ECC=8704B, which can be subdivided into 16 ECC sectors each containing 544B (each). After an ECC sector is read from the flash device array <b>110</b>, the data comparator <b>50</b> generates and sends a read event to the flash array metric tracking module <b>30</b> (metric tracker) containing the number of failing bits for the (particular) ECC sector read.</p>
<p id="p-0064" num="0063">When the flash array metric tracking module <b>30</b> determines that the event type is an outbound command, the flash array metric tracking module <b>30</b> determines whether the outbound command is a read command at block <b>515</b>.</p>
<p id="p-0065" num="0064">If the outbound command is not a read command, the flash array metric tracking module <b>30</b> increments a corresponding counter and timer based on the command type at block <b>520</b>. There will be a corresponding counter for each command type decoded for the flash device array <b>110</b>. For example, typical commands (determined by the flash array metric tracking module <b>30</b>) may be page read, page program, and block erase; however the description applies to all the command types that are decoded by the flash array metric tracking module <b>30</b>. For each command type, there will be a corresponding counter (in the flash array metric tracking module <b>30</b>), and an associated timer keeping track of the previous time (event) the command type was received. The data stored (by the flash array metric tracking module <b>30</b>) will be counts for each command type, and the inter-arrival time statistics for each command type. Inter-arrival time statistics is the collection of time elapsed between each of the same command types, such as a first, second, third, and so forth of the same command type arriving at the flash array metric tracking module <b>30</b>. The inter-arrival statistics (of the flash array metric tracking module <b>30</b>) will measure minimum, maximum, and average inter-arrival times based on (i.e., for each) command type respectively. If it is the first time the command type is sensed by the flash array metric tracking module <b>30</b> (metric recorder), then inter-arrival statistics will not be calculated (because there is no second event for this command type), but the timer will be set to the current time and the corresponding counter will be incremented for this particular command type.</p>
<p id="p-0066" num="0065">When the flash array metric tracking module <b>30</b> determines that the outbound command is a read command, the flash array metric tracking module <b>30</b> is configured to store the read command address into (its) read command queue and set an address counter to the number of sectors/pages in this particular read command at block <b>525</b>. The page read command and page read variants require an extra processing step (by the flash array metric tracking module <b>30</b>) as they are requesting data from the flash device, and the raw bit error rate (RBER) data will need to be monitored and associated with the corresponding ECC sectors from the page read (by the flash array metric tracking module <b>30</b>). For each page read, the flash array metric tracking module <b>30</b> will record/store the address (from which the read occurred in the flash device array <b>110</b>) and a (ECC) sector counter will be set to a value of the number of ECC sectors/page which is a known constant prior to the start of metric recording. All read accesses will be treated as in order execution, which means that if three page reads are executed, the data for the first read will be returned (to the flash array metric tracking module <b>30</b>) before the data for the second read and so on.</p>
<p id="p-0067" num="0066">When the flash array metric tracking module <b>30</b> determines that a read data event occurs, the data sent (in the read data event) from the data comparator <b>50</b> will be a count of the number of failing bits per ECC sector. Upon receipt of this information (i.e., for this read data event) two actions occur. First, the flash array metric tracking module <b>30</b> obtains the associated read address from the read command address queue by looking at the oldest entry in the table at block <b>530</b>. The read command (address) queue in the flash array metric tracking module <b>30</b> contains the table.</p>
<p id="p-0068" num="0067">Second, using this read address, the flash array metric tracking module <b>30</b> will index into the proper memory location based on this read address and decrement the corresponding ECC sector counter at block <b>535</b>. Optionally, if the ECC sector counter=0, the address will be removed from the read command address queue at block <b>540</b>. Finally, the number of failing bits is stored (for this particular memory address location) by the flash array metric tracking module <b>30</b>, and the flow returns to block <b>505</b>.</p>
<p id="p-0069" num="0068">The data of the failing bits (RBER statistics) will be recorded in a block index based array on the flash array metric tracking module <b>30</b>. In the block index based array, based on the particular block (page) accessed, the failing bits counter on the flash array metric tracking module <b>30</b> will be incremented by the number of failing bits for the ECC sector and the total bits (counter) will be incremented by the number of bits in an ECC sector (this is known before the test starts). Also, an ECC sector histogram will be updated by the flash array metric tracking module <b>30</b>, and the flash array metric tracking module <b>30</b> will increment the counter (bin) corresponding to the number of failing bits in the (particular) sector. These different recording/storage methods executed by the flash array metric tracking module <b>30</b> allow for understanding sector failure rate information across the entire set of memory devices <b>120</b> and also allow for block level understanding of raw bit error rates (RBER) for specific physical addresses within each individual memory device <b>120</b>.</p>
<p id="p-0070" num="0069">The following is an implementation example for the flash array metric tracking module <b>30</b> using a 256 GB drive (e.g., flash device array <b>110</b>) with 16 flash devices sites (e.g., memory device sites <b>115</b>). It is understood that this example is for explanation purposes and is not meant to be limiting.</p>
<p id="p-0071" num="0070">Each memory site is composed of a 4 high stack of 32 GB monolithic die chips. Each 32 GB chip has 4096 Blocks. Total # of blocks/SSD=2^12(blocks/per chip)*2^2(chips/site)*2^4 (sites/SSD)=2^18 blocks/SSD=256 K unique blocks.</p>
<p id="p-0072" num="0071">Using this approach, either an internal memory (of the controller chip <b>105</b>, such as memory <b>32</b> in the flash array metric tracking module <b>30</b>) and/or a portion of the flash device array <b>110</b> (such as the memory <b>48</b>) can retain/store test information (discussed above for <figref idref="DRAWINGS">FIG. 5</figref>). This implementation will be useful for tracking in system use (such as regular read and write commands from the computer <b>5</b> (during normal operation) and corresponding input/output to and from the flash device array <b>110</b>) and FA-BIST usage by the FA-BIST engine <b>55</b>, <b>455</b> (when test analysis is run in test mode). As one option, an internal memory (on the controller chip <b>105</b>, such as memory <b>32</b>) will store a fixed number of records in a buffer; when the buffer gets near its threshold, the records can be stored in the flash device array <b>110</b> as meta data at a location that is controlled and protected (only) by (the FA-BIST engine <b>55</b>, <b>455</b> of) the controller chip <b>105</b>, such as memory <b>48</b>. This is useful in scenarios where the significant drive runtime has occurred in the field and data can be extracted for analysis. This mechanism will aggregate all known runtime information from either the FA-BIST engine <b>55</b>, <b>455</b> and/or from general flash device array usage and track wearing.</p>
<p id="p-0073" num="0072">Some of the example metrics tracked (i.e., recorded/stored) by the flash array metric tracking module <b>30</b> are shown in Tables 1, 2, and 3.</p>
<p id="p-0074" num="0073">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 1</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Command Based Metrics:</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry>command count [commandType] - increments by 1 based on receipt of</entry>
</row>
<row>
<entry>command</entry>
</row>
<row>
<entry>inter-arrival time average [commandType] - uses timer to calculate</entry>
</row>
<row>
<entry>inter-arrival time average</entry>
</row>
<row>
<entry>inter-arrival time min [commandType]</entry>
</row>
<row>
<entry>inter-arrival time max [commandType]</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0075" num="0074">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 2</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>Address Based Metrics</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="70pt" align="left"/>
<colspec colname="1" colwidth="147pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>total bits read [block]</entry>
</row>
<row>
<entry/>
<entry>total bits failed [block]</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0076" num="0075">
<tables id="TABLE-US-00003" num="00003">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="center"/>
<thead>
<row>
<entry namest="1" nameend="1" rowsep="1">TABLE 3</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
<row>
<entry>ECC Sector Based Metrics (histogram data)</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="84pt" align="left"/>
<colspec colname="1" colwidth="133pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>0 bit fail count</entry>
</row>
<row>
<entry/>
<entry>1 bit fail count</entry>
</row>
<row>
<entry/>
<entry>. . .</entry>
</row>
<row>
<entry/>
<entry>. . .</entry>
</row>
<row>
<entry/>
<entry>N bit fail count</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0077" num="0076">The total amount of storage required will equal the sum of the memory required to track the commandType, block data, and ECC sector data.</p>
<p id="p-0078" num="0077">Now, further description of the flash trace array logic (module/circuit) <b>25</b> is provided below. The trace array logic <b>25</b> may be a block of logic designed to capture in-band commands between two or more other blocks of logic in order to enhance debug capability. The general functionality may be similar to that of a protocol analyzer, but is a tool that is built directly into each controller (such as the controller chip <b>105</b>), allowing real-time debug regardless of the location of the device under test (DUT), such as the flash device array <b>110</b>. Operators can access and use the trace array logic <b>25</b> on any system such as the system <b>100</b>, <b>400</b> that they have debug access to. Various functionality of the trace array logic <b>25</b> is discussed below.</p>
<p id="p-0079" num="0078">Access to the trace array logic <b>25</b>: Access to the trace array logic <b>25</b> is controlled through the flash controller debug port <b>27</b>. This allows for full configuration of the trace array functions based on the test and conditions at hand.</p>
<p id="p-0080" num="0079">SATA/SAS (In-band) Command Logging: SATA is serial advanced technology attachment, and SAS is serial attached small computer system interface. The trace array logic <b>25</b> also contains the logic to monitor the high-speed interface between the controller chip <b>105</b> and the system (e.g., the host computer <b>5</b>). This allows for debug of commands coming into the controller chip <b>105</b> and allows for debug of the translation (e.g., by the host protocol translator <b>10</b>) of the command within the controller chip <b>105</b>. For example, one might configure the trace array logic <b>25</b> to trace a write on the SAS interface and its corresponding program-erase on the flash bus side (that connects to the flash device array <b>110</b>).</p>
<p id="p-0081" num="0080">Trace Storage:</p>
<p id="p-0082" num="0081">The trace array logic <b>25</b> sequentially stores the desired command stream within its own finite logic array and can be configured to stop when full and/or wrap until triggered or stopped. If required, one can also configure the trace array logic <b>25</b> to also store data directly on the flash device array <b>110</b> (e.g., in memory <b>48</b>).</p>
<p id="p-0083" num="0082">Command Capture:</p>
<p id="p-0084" num="0083">The trace array logic <b>25</b> is designed to capture commands that are being sent to the flash device array <b>110</b> both directly from the computer <b>5</b> on the mainline bus <b>7</b> (of the controller chip <b>105</b>) and the flash array built-in self test engine (FA-BIST engine <b>55</b>, <b>455</b>). Operators have the ability to configure the way they prefer to save commands, the desired commands to be saved, and a trigger point to start and stop the command capture. The command capture of the trace array logic <b>25</b> is an excellent debug tool as it can be used to verify that the computer <b>5</b> (host system) and controller chip <b>105</b> are behaving as expected and can also capture the stream of commands (from the computer <b>5</b>) leading up to any failure and/or unexpected event.</p>
<p id="p-0085" num="0084">Data Capture:</p>
<p id="p-0086" num="0085">In addition to capturing commands, the trace array logic <b>25</b> is configured to also capture the data stream associated with the commands being sent to the flash device array <b>110</b>. For example, the payload of a write command (from e.g., the computer <b>5</b> and/or the command sequencer <b>40</b>) can be saved along with the actual command. This allows the operator to review both the commands and the data on the mainline bus <b>7</b> when desired.</p>
<p id="p-0087" num="0086">Trace Array Trigger:</p>
<p id="p-0088" num="0087">The trace array logic <b>25</b> can be configured to start and stop its captures (of data and commands) based on an operator defined command, a computer <b>5</b> (host system) interrupt, and/or a controller chip <b>105</b> interrupt. Although the default behavior of the trace array logic <b>25</b> is to capture all commands until stopped by an operator, it is sometimes desirable to instead start and stop the command capture based on a (particular type of) command that is observed on the mainline (command) bus <b>7</b>. For example, the operator can configure the trace array logic <b>25</b> to start recording (i.e., storing) when the trace array logic <b>25</b> observes a write command and stop recording when the trace array logic <b>25</b> observes a read command. Another example is that the trace array logic <b>25</b> may be configured to stop recording on an interrupt from the controller chip <b>105</b>. When the controller chip <b>105</b> throws an interrupt on a data integrity error, the trace array logic <b>25</b> stops recording, which allows the operator to review the commands and data on the mainline bus <b>7</b> leading up to that event (e.g., the data integrity error).</p>
<p id="p-0089" num="0088">Command Playback:</p>
<p id="p-0090" num="0089">As stated above, the trace array logic <b>25</b> is configured with the ability to play back a series of captured commands (e.g., on a display screen of the computer <b>5</b>). This command playback function can be used to repeatedly send (by the command sequencer <b>40</b>) the same stream of commands to the flash device array <b>110</b> and look for differences in results by having the trace array logic <b>25</b> playback the desired commands. For example, the command playback of the captured commands can also be used to replay a set of commands leading up to an observed event, be it expected or not.</p>
<p id="p-0091" num="0090">Event and Statistic Recording:</p>
<p id="p-0092" num="0091">The trace array logic <b>25</b> is configured with the capability of recording a number of important metrics from runtime (e.g., the normal operation of the computer <b>5</b> interfacing with the flash device array <b>110</b>) and/or from the FA-BIST engine <b>55</b>, <b>455</b>. These metrics include the FA-BIST engine runtime, current RBER (raw BER), maximum RBER, minimum RBER, read count (i.e., number of read commands), program-erase count (i.e., number or program erase commands), last access time, average access time, dwell time, simultaneous active die, and/or write amplification. Some of these functions may require additional data manipulation, and/or may be implemented in conjunction with the flash array metric tracking module <b>30</b>. Note that although the trace array logic <b>25</b> and flash array metric tracking module <b>30</b> are shown as separate elements, their respective functions and operations may be integrated (combined) into a single circuit or module and/or integrated into one or more circuits or modules in an implementation.</p>
<p id="p-0093" num="0092">Garbage Collection Trace:</p>
<p id="p-0094" num="0093">As part of the general controller logic functions, the trace array logic <b>25</b> is configured to log the flash garbage collection procedures (of the controller chip <b>105</b>). The flash garbage collection procedures are when the controller chip <b>105</b> (e.g., the flash mainline management controller <b>15</b>) does some cleanup of various blocks (of the flash device array <b>110</b>) in order to run more efficiently. In order to verify flash garbage collection procedures by the controller chip <b>105</b>, the trace array logic <b>25</b> is utilized to log the set of (garbage collection) commands that are internally tagged as being used for garbage collection.</p>
<p id="p-0095" num="0094"><figref idref="DRAWINGS">FIG. 6</figref> illustrates a chart <b>600</b> of captured data by the trace array logic <b>25</b>, by the flash array metric tracking module <b>30</b>, and/or by a combined circuit/module of both (the trace array logic <b>25</b> and the flash array metric tracking module <b>30</b>) according to an exemplary embodiment. It is understood that the chart <b>600</b> is not meant to be exhaustive.</p>
<p id="p-0096" num="0095">The chart <b>600</b> illustrates data captured from the flash device array <b>110</b>, the FA-BIST engine <b>55</b>, <b>455</b>, and the mainline system <b>605</b>. The mainline system <b>605</b> represents the elements that may typically be present without FA-BIST engine <b>55</b>, <b>455</b>, and the mainline system <b>605</b> may include the computer <b>5</b> (host system), the host protocol translator <b>10</b>, the flash mainline management controller <b>15</b>, the flash (I/O) ports <b>20</b>, and/or the flash device array <b>110</b>.</p>
<p id="p-0097" num="0096">Data captured from the flash device array <b>110</b> may include write amplification, dwell time, simultaneous active die, flash device array initialization/die state, program-erase (PE) data, read count, RBER (raw bit error rate) (current and minimum/maximum), and/or access time (average and maximum). Dwell time is the time interval between block erase accesses to a specific physical address in the memory device <b>120</b> of the flash device array <b>110</b>.</p>
<p id="p-0098" num="0097">Data captured from the FA-BIST engine <b>55</b>, <b>455</b> may include command capture, data capture, and FA-BIST runtime. Data captured from the mainline system <b>605</b> may include in-band commands and data to controller logic of the flash mainline management controller <b>15</b>, mapping of in-band commands and data to the flash device array <b>110</b>, general commands and data out to flash device array <b>110</b>, and garbage collection data.</p>
<p id="p-0099" num="0098"><figref idref="DRAWINGS">FIG. 7</figref> illustrates a flow chart of a process executed by one or more circuits implementing the flash array built in test engine <b>55</b>, <b>455</b> (on the controller chip <b>105</b>) according to an exemplary embodiment.</p>
<p id="p-0100" num="0099">Test workloads are generated (by the command sequencer <b>40</b>) in a test mode for testing the flash device array <b>110</b>, where each of the test workloads may include specific addresses (of blocks in a memory device <b>102</b> and/or of memory devices <b>120</b>), data, and command patterns to be sent to the flash device array at block <b>705</b>. Wear in the flash device array <b>110</b> is accelerated, via the test workloads, at an accelerated rate relative to general system workloads that are not part of the test mode at block <b>710</b>, because the command sequencer <b>40</b> can repeatedly write and erase each individual block and/or each individual memory device <b>120</b> without going through the flash mainline management controller <b>15</b>.</p>
<p id="p-0101" num="0100">A range of conditions are varied for the flash device array <b>110</b> to determine whether each of the conditions passes or fails at block <b>715</b>. In one case, the operator may adjust conditions in the flash device array <b>110</b> and/or in another case, the command sequencer <b>40</b> may sends commands to the flash device array to adjust the conditions. Failure data and corresponding failure data address information (of each block and/or memory device <b>120</b>) are stored (e.g., in buffer memory <b>47</b>, in memory <b>32</b>, and/or in the buffer memory <b>48</b> of the flash device array <b>110</b>) for the flash device array <b>110</b> at block <b>720</b>.</p>
<p id="p-0102" num="0101">The test workloads generated in the test mode are configured to: test specific page program and block erase loops on the flash device array <b>110</b>, to test specific read interval loops on the flash device array <b>110</b>, and to test programmable physical device interval time for evaluating dwell time effect on bit error rate for the flash device array <b>110</b>.</p>
<p id="p-0103" num="0102">Varying the range of conditions for the flash device array <b>110</b> includes the flash array built in test engine circuit <b>55</b>, <b>455</b> varying one variable at a time out of a plurality of variables while not changing the other variables. Each of variables that gets selectively varied (one at a time) may include a timing knob, voltage of the flash device array <b>110</b>, and/or temperature of the flash device array <b>110</b>, while the other variables remain constant.</p>
<p id="p-0104" num="0103">Additionally, the flash array metric tracking circuit <b>30</b> may be executed, and for each of the (individual) memory devices <b>120</b> in the flash device array <b>110</b>, the flash array metric tracking circuit <b>30</b> is configured to track usage data, frequency of access, and bit error rates. Also, the flash array tracking metric circuit <b>30</b> is configured to snoop the mainline bus <b>7</b> to and from the flash device array <b>110</b> and to snoop paths (i.e., all paths connecting to the mainline bus <b>7</b> from elements/modules/circuits <b>25</b>, <b>30</b>, <b>40</b>, and <b>50</b>) from the flash array built in test engine <b>55</b>, <b>455</b> to the flash device array <b>110</b>, in order to track bit error rate data independent of an operation mode (independent of whether in the test mode and normal operation). The flash array tracking metric circuit <b>30</b> is configured to capture data when running during the test mode and when running during the mainline mode (normal operation). The mainline mode corresponds to the general system workloads generated by a host system (e.g., computer <b>5</b>) for normal operation in which the general system workloads are not part of the test mode. The flash array tracking metric circuit <b>30</b> is configured to display failure analysis captured during runtime in response to a flash error in the flash device array <b>110</b>.</p>
<p id="p-0105" num="0104">The flash trace array logic <b>25</b> is configured to execute in-band command logging; trace storage for command capture; data capture based on a trace array logic trigger; command playback; event and statistic recording; and/or garbage collection trace.</p>
<p id="p-0106" num="0105"><figref idref="DRAWINGS">FIG. 8</figref> illustrates an example of a computer <b>800</b> having capabilities, which may be included in exemplary embodiments. Various methods, procedures, modules, flow diagrams, tools, application, circuits, elements, and techniques discussed herein may also incorporate and/or utilize the capabilities of the computer <b>800</b>. Moreover, capabilities of the computer <b>800</b> may be utilized to implement features of exemplary embodiments discussed herein. One or more of the capabilities of the computer <b>800</b> may utilized implement, connect to, and/or support any element discussed herein (as understood by one skilled in the art) such as but not limited to the computer <b>5</b> (host system), the FA-BIST engine <b>55</b>, <b>455</b>, the modules/circuits <b>25</b>, <b>27</b>, <b>30</b>, <b>35</b>, <b>40</b>, <b>45</b>, <b>47</b>, <b>50</b>, the controller chip <b>105</b>, and/or the flash device array <b>110</b>.</p>
<p id="p-0107" num="0106">Generally, in terms of hardware architecture, the computer <b>800</b> may include one or more processors <b>810</b>, computer readable storage memory <b>820</b>, and one or more input and/or output (I/O) devices <b>870</b> that are communicatively coupled via a local interface (not shown). The local interface can be, for example but not limited to, one or more buses or other wired or wireless connections, as is known in the art. The local interface may have additional elements, such as controllers, buffers (caches), drivers, repeaters, and receivers, to enable communications. Further, the local interface may include address, control, and/or data connections to enable appropriate communications among the aforementioned components.</p>
<p id="p-0108" num="0107">The processor <b>810</b> is a hardware device for executing software that can be stored in the memory <b>820</b>. The processor <b>810</b> can be virtually any custom made or commercially available processor, a central processing unit (CPU), a data signal processor (DSP), or an auxiliary processor among several processors associated with the computer <b>800</b>, and the processor <b>810</b> may be a semiconductor based microprocessor (in the form of a microchip) or a macroprocessor.</p>
<p id="p-0109" num="0108">The computer readable memory <b>820</b> can include any one or combination of volatile memory elements (e.g., random access memory (RAM), such as dynamic random access memory (DRAM), static random access memory (SRAM), etc.) and nonvolatile memory elements (e.g., ROM, erasable programmable read only memory (EPROM), electronically erasable programmable read only memory (EEPROM), programmable read only memory (PROM), tape, compact disc read only memory (CD-ROM), disk, diskette, cartridge, cassette or the like, etc.). Moreover, the memory <b>820</b> may incorporate electronic, magnetic, optical, and/or other types of storage media. Note that the memory <b>820</b> can have a distributed architecture, where various components are situated remote from one another, but can be accessed by the processor <b>810</b>.</p>
<p id="p-0110" num="0109">The software in the computer readable memory <b>820</b> may include one or more separate programs, each of which comprises an ordered listing of executable instructions for implementing logical functions. The software in the memory <b>820</b> includes a suitable operating system (O/S) <b>850</b>, compiler <b>840</b>, source code <b>830</b>, and one or more applications <b>860</b> of the exemplary embodiments. As illustrated, the application <b>860</b> comprises numerous functional components for implementing the features, processes, methods, functions, and operations of the exemplary embodiments. The application <b>860</b> of the computer <b>800</b> may represent numerous applications, agents, software components, modules, interfaces, controllers, etc., as discussed herein but the application <b>860</b> is not meant to be a limitation.</p>
<p id="p-0111" num="0110">The operating system <b>850</b> may control the execution of other computer programs, and provides scheduling, input-output control, file and data management, memory management, and communication control and related services.</p>
<p id="p-0112" num="0111">The application(s) <b>860</b> may employ a service-oriented architecture, which may be a collection of services that communicate with each. Also, the service-oriented architecture allows two or more services to coordinate and/or perform activities (e.g., on behalf of one another). Each interaction between services can be self-contained and loosely coupled, so that each interaction is independent of any other interaction.</p>
<p id="p-0113" num="0112">Further, the application <b>860</b> may be a source program, executable program (object code), script, or any other entity comprising a set of instructions to be performed. When a source program, then the program is usually translated via a compiler (such as the compiler <b>840</b>), assembler, interpreter, or the like, which may or may not be included within the memory <b>820</b>, so as to operate properly in connection with the O/S <b>850</b>. Furthermore, the application <b>860</b> can be written as (a) an object oriented programming language, which has classes of data and methods, or (b) a procedure programming language, which has routines, subroutines, and/or functions.</p>
<p id="p-0114" num="0113">The I/O devices <b>870</b> may include input devices (or peripherals) such as, for example but not limited to, a mouse, keyboard, scanner, microphone, camera, etc. Furthermore, the I/O devices <b>870</b> may also include output devices (or peripherals), for example but not limited to, a printer, display, etc. Finally, the I/O devices <b>870</b> may further include devices that communicate both inputs and outputs, for instance but not limited to, a NIC or modulator/demodulator (for accessing remote devices, other files, devices, systems, or a network), a radio frequency (RF) or other transceiver, a telephonic interface, a bridge, a router, etc. The I/O devices <b>870</b> also include components for communicating over various networks, such as the Internet or an intranet. The I/O devices <b>870</b> may be connected to and/or communicate with the processor <b>810</b> utilizing Bluetooth connections and cables (via, e.g., Universal Serial Bus (USB) ports, serial ports, parallel ports, FireWire, HDMI (High-Definition Multimedia Interface), etc.).</p>
<p id="p-0115" num="0114">When the computer <b>800</b> is in operation, the processor <b>810</b> is configured to execute software stored within the memory <b>820</b>, to communicate data to and from the memory <b>820</b>, and to generally control operations of the computer <b>800</b> pursuant to the software. The application <b>860</b> and the O/S <b>850</b> are read, in whole or in part, by the processor <b>810</b>, perhaps buffered within the processor <b>810</b>, and then executed.</p>
<p id="p-0116" num="0115">When the application <b>860</b> is implemented in software it should be noted that the application <b>860</b> can be stored on virtually any computer readable storage medium for use by or in connection with any computer related system or method. In the context of this document, a computer readable storage medium may be an electronic, magnetic, optical, or other physical device or means that can contain or store a computer program for use by or in connection with a computer related system or method.</p>
<p id="p-0117" num="0116">The application <b>860</b> can be embodied in any computer-readable medium <b>820</b> for use by or in connection with an instruction execution system, apparatus, server, or device, such as a computer-based system, processor-containing system, or other system that can fetch the instructions from the instruction execution system, apparatus, or device and execute the instructions. In the context of this document, a &#x201c;computer-readable storage medium&#x201d; can be any means that can store, read, write, communicate, or transport the program for use by or in connection with the instruction execution system, apparatus, or device. The computer readable medium can be, for example but not limited to, an electronic, magnetic, optical, or semiconductor system, apparatus, or device.</p>
<p id="p-0118" num="0117">More specific examples (a nonexhaustive list) of the computer-readable medium <b>820</b> would include the following: an electrical connection (electronic) having one or more wires, a portable computer diskette (magnetic or optical), a random access memory (RAM) (electronic), a read-only memory (ROM) (electronic), an erasable programmable read-only memory (EPROM, EEPROM, or Flash memory) (electronic), an optical fiber (optical), and a portable compact disc memory (CDROM, CD R/W) (optical). Note that the computer-readable medium could even be paper or another suitable medium, upon which the program is printed or punched, as the program can be electronically captured, via for instance optical scanning of the paper or other medium, then compiled, interpreted or otherwise processed in a suitable manner if necessary, and then stored in a computer memory.</p>
<p id="p-0119" num="0118">In exemplary embodiments, where the application <b>860</b> is implemented in hardware, the application <b>860</b> can be implemented with any one or a combination of the following technologies, which are each well known in the art: a discrete logic circuit(s) having logic gates for implementing logic functions upon data signals, an application specific integrated circuit (ASIC) having appropriate combinational logic gates, a programmable gate array(s) (PGA), a field programmable gate array (FPGA), etc.</p>
<p id="p-0120" num="0119">It is understood that the computer <b>800</b> includes non-limiting examples of software and hardware components that may be included in various devices, servers, and systems discussed herein, and it is understood that additional software and hardware components may be included in the various devices and systems discussed in exemplary embodiments.</p>
<p id="p-0121" num="0120">As will be appreciated by one skilled in the art, aspects of the present invention may be embodied as a system, method or computer program product. Accordingly, aspects of the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a &#x201c;circuit,&#x201d; &#x201c;module&#x201d; or &#x201c;system.&#x201d; Furthermore, aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium(s) having computer readable program code embodied thereon.</p>
<p id="p-0122" num="0121">Any combination of one or more computer readable medium(s) may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be, for example, but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, or device, or any suitable combination of the foregoing. More specific examples (a non-exhaustive list) of the computer readable storage medium would include the following: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), an optical fiber, a portable compact disc read-only memory (CD-ROM), an optical storage device, a magnetic storage device, or any suitable combination of the foregoing. In the context of this document, a computer readable storage medium may be any tangible medium that can contain, or store a program for use by or in connection with an instruction execution system, apparatus, or device.</p>
<p id="p-0123" num="0122">A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein, for example, in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms, including, but not limited to, electro-magnetic, optical, or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate, propagate, or transport a program for use by or in connection with an instruction execution system, apparatus, or device.</p>
<p id="p-0124" num="0123">Program code embodied on a computer readable medium may be transmitted using any appropriate medium, including but not limited to wireless, wireline, optical fiber cable, RF, etc., or any suitable combination of the foregoing.</p>
<p id="p-0125" num="0124">Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages, including an object oriented programming language such as Java, Smalltalk, C++ or the like and conventional procedural programming languages, such as the &#x201c;C&#x201d; programming language or similar programming languages. The program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).</p>
<p id="p-0126" num="0125">Aspects of the present invention are described herein with reference to flowchart illustrations and/or block diagrams of methods, apparatus (systems) and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and/or block diagrams, and combinations of blocks in the flowchart illustrations and/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions/acts specified in the flowchart and/or block diagram block or blocks.</p>
<p id="p-0127" num="0126">These computer program instructions may also be stored in a computer readable medium that can direct a computer, other programmable data processing apparatus, or other devices to function in a particular manner, such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function/act specified in the flowchart and/or block diagram block or blocks.</p>
<p id="p-0128" num="0127">The computer program instructions may also be loaded onto a computer, other programmable data processing apparatus, or other devices to cause a series of operational steps to be performed on the computer, other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions/acts specified in the flowchart and/or block diagram block or blocks.</p>
<p id="p-0129" num="0128">The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein, the singular forms &#x201c;a&#x201d;, &#x201c;an&#x201d; and &#x201c;the&#x201d; are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms &#x201c;comprises&#x201d; and/or &#x201c;comprising,&#x201d; when used in this specification, specify the presence of stated features, integers, steps, operations, elements, and/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, element components, and/or groups thereof.</p>
<p id="p-0130" num="0129">The corresponding structures, materials, acts, and equivalents of all means or step plus function elements in the claims below are intended to include any structure, material, or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description, but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated</p>
<p id="p-0131" num="0130">The flow diagrams depicted herein are just one example. There may be many variations to this diagram or the steps (or operations) described therein without departing from the spirit of the invention. For instance, the steps may be performed in a differing order or steps may be added, deleted or modified. All of these variations are considered a part of the claimed invention.</p>
<p id="p-0132" num="0131">While the exemplary embodiments of the invention have been described, it will be understood that those skilled in the art, both now and in the future, may make various improvements and enhancements which fall within the scope of the claims which follow. These claims should be construed to maintain the proper protection for the invention first described.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A flash array test engine, comprising:
<claim-text>a circuit, the circuit being configured to:
<claim-text>generate test workloads in a test mode for testing a flash device array, each of the test workloads comprising specific addresses, data, and command patterns to be sent to the flash device array;</claim-text>
<claim-text>accelerate wearing in the flash device array, via the test workloads, during the test mode, wherein the accelerate wearing in the flash device array comprises continuously executing commands of at least one of reading, writing, and erasing a same memory block of the flash device array and not spreading the commands to other available memory blocks in the flash device array;</claim-text>
<claim-text>vary a range of conditions for the flash device array to determine whether each of the conditions passes or fails; and</claim-text>
<claim-text>store failure data and corresponding failure data address information for the flash device array.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The flash device array of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the test workloads generated in the test mode are configured to: test specific page program and block erase loops on the flash device array, to test specific read interval loops on the flash device array, and to test programmable physical device interval time for evaluating dwell time effect on bit error rate for the flash device array.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The flash device array of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein varying the range of conditions for the flash device array comprises the circuit varying one variable at a time out of a plurality of variables while not changing others; and
<claim-text>wherein the one variable comprises a timing knob, voltage, and temperature of the flash device array.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The flash array test engine of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising a flash array metric tracking circuit;
<claim-text>wherein, for memory devices in the flash device array, the flash array metric tracking circuit is configured to track usage data, frequency of access, and bit error rates.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The flash array test engine of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the flash array tracking metric circuit is configured to snoop a mainline bus to and from the flash device array and to snoop paths from the flash array test engine to the flash device array, in order to track bit error rate data independent of an operation mode.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The flash array test engine of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the flash array tracking metric circuit is configured to capture data when running during the test mode and when running during a mainline mode;
<claim-text>wherein the mainline mode corresponds to the general system workloads generated by a host system for normal operation in which the general system workloads are not part of the test mode; and</claim-text>
<claim-text>wherein the flash array tracking metric circuit is configured to display failure analysis captured during runtime in response to a flash error in the flash device array.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The flash array test engine of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising flash trace array logic configured to execute at least one of: in-band command logging; trace storage for command capture; data capture based on a trace array logic trigger; command playback; event and statistic recording; and garbage collection trace.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. A method for implementing a flash array test engine circuit, comprising:
<claim-text>generating test workloads in a test mode for testing a flash device array, each of the test workloads comprising specific addresses, data, and command patterns to be sent to the flash device array;</claim-text>
<claim-text>accelerating wearing in the flash device array, via the test workloads, during the test mode, wherein the accelerating wearing in the flash device array comprises continuously executing commands of at least one of reading, writing, and erasing a same memory block of the flash device array and not spreading the commands to other available memory blocks in the flash device array;</claim-text>
<claim-text>varying a range of conditions for the flash device array to determine whether each of the conditions passes or fails; and</claim-text>
<claim-text>storing failure data and corresponding failure data address information for the flash device array.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the test workloads generated in the test mode are configured to: test specific page program and block erase loops on the flash device array, to test specific read interval loops on the flash device array, and to test programmable physical device interval time for evaluating dwell time effect on bit error rate for the flash device array.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein varying the range of conditions for the flash device array comprises the flash array test engine circuit varying one variable at a time out of a plurality of variables while not changing others; and
<claim-text>wherein the one variable comprises at least one of a timing knob, voltage, and temperature of the flash device array.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, further comprising executing a flash array metric tracking circuit;
<claim-text>wherein, for memory devices in the flash device array, the flash array metric tracking circuit is configured to track usage data, frequency of access, and bit error rates.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the flash array tracking metric circuit is configured to snoop a mainline bus to and from the flash device array and to snoop paths from the flash array test engine circuit to the flash device array, in order to track bit error rate data independent of an operation mode.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the flash array tracking metric circuit is configured to capture data when running during the test mode and when running during a mainline mode;
<claim-text>wherein the mainline mode corresponds to the general system workloads generated by a host system for normal operation in which the general system workloads are not part of the test mode; and</claim-text>
<claim-text>wherein the flash array tracking metric circuit is configured to display failure analysis captured during runtime in response to a flash error in the flash device array.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, further comprising executing flash trace array logic configured to execute: in-band command logging; trace storage for command capture; data capture based on a trace array logic trigger; command playback; event and statistic recording; and garbage collection trace.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. A computer program product comprising a computer readable storage medium having computer readable instructions stored thereon that, when executed by a computer, implement a method for implementing a flash array test engine circuit, the method comprising:
<claim-text>generating test workloads in a test mode for testing a flash device array, each of the test workloads comprising specific addresses, data, and command patterns to be sent to the flash device array;</claim-text>
<claim-text>accelerating wearing in the flash device array, via the test workloads, during the test mode, wherein the accelerating wearing in the flash device array comprises continuously executing commands of at least one of reading, writing, and erasing a same memory block of the flash device array and not spreading the commands to other available memory blocks in the flash device array;</claim-text>
<claim-text>varying a range of conditions for the flash device array to determine whether each of the conditions passes or fails; and</claim-text>
<claim-text>storing failure data and corresponding failure data address information for the flash device array.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The computer program product of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the test workloads generated in the test mode are configured to: test specific page program and block erase loops on the flash device array, to test specific read interval loops on the flash device array, and to test programmable physical device interval time for evaluating dwell time effect on bit error rate for the flash device array.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The computer program product of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein varying the range of conditions for the flash device array comprises the flash array test engine circuit varying one variable at a time out of a plurality of variables while not changing others; and
<claim-text>wherein the one variable comprises a timing knob, voltage, and temperature of the flash device array.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The computer program product of <claim-ref idref="CLM-00015">claim 15</claim-ref>, further comprising computer readable instructions for executing a flash array metric tracking circuit;
<claim-text>wherein, for memory devices in the flash device array, the flash array metric tracking circuit is configured to track usage data, frequency of access, and bit error rates.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The computer program product of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the flash array tracking metric circuit is configured to snoop a mainline bus to and from the flash device array and to snoop paths from the flash array test engine circuit to the flash device array, in order to track bit error rate data independent of an operation mode.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The computer program product of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the flash array tracking metric circuit is configured to capture data when running during the test mode and when running during a mainline mode;
<claim-text>wherein the mainline mode corresponds to the general system workloads generated by a host system for normal operation in which the general system workloads are not part of the test mode; and</claim-text>
<claim-text>wherein the flash array tracking metric circuit is configured to display failure analysis captured during runtime in response to a flash error in the flash device array. </claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
