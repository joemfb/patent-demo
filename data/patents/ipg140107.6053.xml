<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627176-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627176</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>12956342</doc-number>
<date>20101130</date>
</document-id>
</application-reference>
<us-application-series-code>12</us-application-series-code>
<us-term-of-grant>
<us-term-extension>307</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>H</section>
<class>03</class>
<subclass>M</subclass>
<main-group>13</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>714763</main-classification>
</classification-national>
<invention-title id="d2e53">Systematic mitigation of memory errors</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5457696</doc-number>
<kind>A</kind>
<name>Mori</name>
<date>19951000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714720</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6353910</doc-number>
<kind>B1</kind>
<name>Carnevale et al.</name>
<date>20020300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>7346755</doc-number>
<kind>B2</kind>
<name>Pomaranski et al.</name>
<date>20080300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>7523274</doc-number>
<kind>B2</kind>
<name>Ryu et al.</name>
<date>20090400</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>7559000</doc-number>
<kind>B2</kind>
<name>Sato</name>
<date>20090700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714738</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>7571295</doc-number>
<kind>B2</kind>
<name>Sakarda et al.</name>
<date>20090800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>7581078</doc-number>
<kind>B2</kind>
<name>Ware</name>
<date>20090800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>7685376</doc-number>
<kind>B2</kind>
<name>Zimmer et al.</name>
<date>20100300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>7770079</doc-number>
<kind>B2</kind>
<name>Radke et al.</name>
<date>20100800</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2002/0133742</doc-number>
<kind>A1</kind>
<name>Hsu et al.</name>
<date>20020900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2004/0117688</doc-number>
<kind>A1</kind>
<name>Vainsencher et al.</name>
<date>20040600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2009/0144624</doc-number>
<kind>A1</kind>
<name>Barnes, Jr.</name>
<date>20090600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2009/0164742</doc-number>
<kind>A1</kind>
<name>Wach et al.</name>
<date>20090600</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>US</country>
<doc-number>2009/0259806</doc-number>
<kind>A1</kind>
<name>Kilzer et al.</name>
<date>20091000</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00015">
<document-id>
<country>US</country>
<doc-number>2010/0070686</doc-number>
<kind>A1</kind>
<name>Mergler et al.</name>
<date>20100300</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00016">
<document-id>
<country>US</country>
<doc-number>2012/0117304</doc-number>
<kind>A1</kind>
<name>Worthington et al.</name>
<date>20120500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00017">
<othercit>Avissar, O. et al., &#x201c;Heterogeneous Memory Management for Embedded Systems,&#x201d; CASES '01, Atlanta, GA, Nov. 16-17, 2001, 10 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00018">
<othercit>Bivens, A. et al.,j &#x201c;Architectural Design for Next Generation Heterogeneous Memory Systems,&#x201d; IEEE, downloaded Aug. 10, 2010, 4 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00019">
<othercit>Dhiman, G., et al., &#x201c;PDRAM: A Hybrid PRAM and DRAM Main Memory System,&#x201d; DAC '09, San Franciso, CA, Jul. 26-31, 2009, 6 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00020">
<othercit>Qureshi, M.K. et al., &#x201c;Enhancing Lifetime and Security of PCM-Based Main Memory with Start-Gap Wear Leveling,&#x201d; MICRO '09, New York, NY, Dec. 12-16, 2009, 10 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00021">
<othercit>ABTS et al., &#x201c;Architectural Support for Mitigating DRAM Soft Errors in Large-Scale Supercomputers,&#x201d; University of Minnesota Institute of Technology, Dept. Elec. &#x26; Computer Eng., Colloquium Mar. 8, 2007, downloaded Nov. 30, 2010.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00022">
<othercit>Calin et al., &#x201c;Upset-Tolerant CMOS SRAM Using Current Monitoring: Prototype and Test Experiments,&#x201d; Proceedings International Test Conference, Oct. 21-25, 1995, Washington, D.C., USA, Paper 2.4, pp. 45-53.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00023">
<othercit>&#x201c;Check for RAM Error or Defect in Windows 7 and Vista with Windows Memory Diagnostic,&#x201d; published Oct. 1, 2009.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00024">
<othercit>&#x201c;How to Scan Windows 7 for Memory Errors,&#x201d; Dec. 7, 2009.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00025">
<othercit>Marsden, A., Memtest86.com&#x2014;Memory Diagnostic, last updated Jan. 3, 2009.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00026">
<othercit>Saha, Goutam Kumar, &#x201c;A Low-Cost Testing for Transient Faults,&#x201d; <i>Ubiquity </i>7(2), Jan. 17-23, 2006.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00027">
<othercit>&#x201c;Windows Memory Diagnostic,&#x201d; published 2008.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00028">
<othercit>&#x201c;Windows Hardware Error Architecture Predictive Failure Analysis,&#x201d; Microsoft Corp., May 5, 2010.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00029">
<othercit>Non-Final Office Action from U.S. Appl. No. 12/940,780, mailed Dec. 20, 2012, 16 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00030">
<othercit>Final Office Action from U.S. Appl. No. 12/940,780, mailed Jun. 20, 2013, 19 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00031">
<othercit>Non-Final Office Action from U.S. Appl. No. 12/940,780, mailed Sep. 14, 2013, 20 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>20</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>714  613</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714 30</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714 48</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714718</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714733-734</main-classification>
<additional-info>unstructured</additional-info>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714763</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>5</number-of-drawing-sheets>
<number-of-figures>5</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20120137167</doc-number>
<kind>A1</kind>
<date>20120531</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Leischner</last-name>
<first-name>Garrett</first-name>
<address>
<city>Seattle</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Lagattuta</last-name>
<first-name>Andrew J.</first-name>
<address>
<city>Redmond</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Eason</last-name>
<first-name>Matthew Jeremiah</first-name>
<address>
<city>Woodinville</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="004" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Wang</last-name>
<first-name>Landy</first-name>
<address>
<city>Kirkland</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="005" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Douceur</last-name>
<first-name>John R.</first-name>
<address>
<city>Bellevue</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="006" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Sridharan</last-name>
<first-name>Baskar</first-name>
<address>
<city>Sammamish</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="007" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Nightingale</last-name>
<first-name>Edmund B.</first-name>
<address>
<city>Redmond</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Leischner</last-name>
<first-name>Garrett</first-name>
<address>
<city>Seattle</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Lagattuta</last-name>
<first-name>Andrew J.</first-name>
<address>
<city>Redmond</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Eason</last-name>
<first-name>Matthew Jeremiah</first-name>
<address>
<city>Woodinville</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="004" designation="us-only">
<addressbook>
<last-name>Wang</last-name>
<first-name>Landy</first-name>
<address>
<city>Kirkland</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="005" designation="us-only">
<addressbook>
<last-name>Douceur</last-name>
<first-name>John R.</first-name>
<address>
<city>Bellevue</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="006" designation="us-only">
<addressbook>
<last-name>Sridharan</last-name>
<first-name>Baskar</first-name>
<address>
<city>Sammamish</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="007" designation="us-only">
<addressbook>
<last-name>Nightingale</last-name>
<first-name>Edmund B.</first-name>
<address>
<city>Redmond</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Chin IP, PLLC</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Chin</last-name>
<first-name>Davin</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Microsoft Corporation</orgname>
<role>02</role>
<address>
<city>Redmond</city>
<state>WA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Chase</last-name>
<first-name>Shelly A</first-name>
<department>2112</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A system and method for mitigating memory errors in a computer system. Faulty memory is identified and tested by a memory manager of an operating system. The memory manager may perform diagnostic tests while the operating system is executing on the computer system. Regions of memory that are being used by software components of the computer system may also be tested. The memory manager maintains a stored information about faulty memory regions. Regions are added to the stored information when they are determined to be faulty by a diagnostic test tool. Memory regions are allocated to software components by the memory manager after checking the stored information about faulty memory regions. This ensures a faulty memory region is never allocated to a software component of the computer system.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="146.73mm" wi="113.71mm" file="US08627176-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="260.94mm" wi="187.37mm" orientation="landscape" file="US08627176-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="264.33mm" wi="182.54mm" orientation="landscape" file="US08627176-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="158.75mm" wi="113.28mm" file="US08627176-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="211.16mm" wi="137.58mm" file="US08627176-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="208.45mm" wi="151.21mm" file="US08627176-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND</heading>
<p id="p-0002" num="0001">The reliability of a computer system is only as good as the underlying hardware of the system. Faults in the Random Access Memory (RAM) of a computer system, whether the faults are permanent or transient, often manifest themselves in the form of software instability and crashes. When applications or the Operating System (OS) of the computer system crash, the user may assume the cause is software related and therefore blame the software developer for the instability of their computer system. This not only hurts the reputation of the software developer in the marketplace, but it also requires the company to provide customer service to help users resolve problems that arise from RAM failures.</p>
<p id="p-0003" num="0002">Aside from the harm to the software developer caused by faults in RAM, there is the possibility that a fault could result in corruption of the user's data or other undesired and unforeseen consequences.</p>
<p id="p-0004" num="0003">To reduce memory errors, it is known to perform diagnostic tests on RAM at start-up. These tests are performed before the operating system is executing because they alter the contents of the memory, which would interfere with an executing operating system or other software components. For this purpose, some memory chips include circuitry to perform built-in self test (BIST) and can provide information identifying faulty pages in the memory to a memory manager in the operating system. Alternatively, some operating systems have incorporated memory tests such that the operating system itself can identify faulty pages in memory. The memory manager can then maintain stored information about faulty pages in the memory. When an application requests that memory to be allocated to it, pages that have been identified as faulty are not allocated.</p>
<p id="p-0005" num="0004">It is also possible for memory tests to be implemented as application programs. These implementations generally don't have as much access to the memory and system resources as memory tests that are integrated into the OS&#x2014;especially the kernel of the OS.</p>
<p id="p-0006" num="0005">Some computer systems use memory that can correct errors through the use of error correcting coding (ECC). Each ECC has a strength that indicates a number of bit errors in a unit of data read from memory that can be corrected by the code. When more errors than can be corrected occur in a unit of memory, then the errors cannot be corrected. Though, the ECC may nonetheless reveal that an error occurred, such that additional faulty pages may be identified as the operating system is running.</p>
<heading id="h-0002" level="1">SUMMARY</heading>
<p id="p-0007" num="0006">Described herein are techniques for mitigating apparent software errors caused by faulty RAM in a computer system. Errors may be detected through a scan of regions of the memory or may be detected in response to a condition encountered by a software component executing on the computing system. In this way, memory errors may be detected while the OS is executing, without the use of memory equipped with ECC.</p>
<p id="p-0008" num="0007">The OS may identify and test a region of RAM. If a region identified for testing has been allocated, the OS may move data out of that region such that the region may be subjected to a scan test. If the test determines that the region of RAM is faulty, then it may be added to stored information about faulty regions, which is maintained by the memory manager of the OS. When allocating memory regions to software components, the memory manager may exclude regions of memory that are indicated as faulty according to the stored information.</p>
<p id="p-0009" num="0008">Dynamic identification of faulty RAM regions, in some embodiments, may be triggered by an event received from a software component, such as an exception or other indicator of an error. The trigger may indicate a specific region of RAM as potentially faulty or it may simply indicate that an error occurred generally. In response to an error of a type likely associated with a memory fault, the operating system may add an identified region to the stored information about faulty regions that are not allocated. If no specific RAM region is indicated by the trigger event, then the operating system may initiate testing of portions of RAM to dynamically identify faulty regions and add them to the stored information.</p>
<p id="p-0010" num="0009">The foregoing is a non-limiting summary of the invention, which is defined by the attached claims.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF DRAWINGS</heading>
<p id="p-0011" num="0010">The accompanying drawings are not intended to be drawn to scale. In the drawings, each identical or nearly identical component that is illustrated in various figures is represented by a like numeral. For purposes of clarity, not every component may be labeled in every drawing. In the drawings:</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram of an exemplary environment in which embodiments of the invention may operate;</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram showing several software components of a computing system of some embodiments of the present invention;</p>
<p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. 3</figref> is a flow chart of an exemplary process of mitigating memory errors.</p>
<p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. 4</figref> is a flow chart of an exemplary process of performing a diagnostic test.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 5</figref> is a flow chart of an exemplary process of scanning a memory region.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0017" num="0016">The inventors have recognized and appreciated that mitigating memory errors in a computer system may increase reliability and stability. The system and method presented herein can mitigate these errors while the operating system (OS) is currently being executed by a processor of the computer system.</p>
<p id="p-0018" num="0017">The technique also does not require special hardware, such as error-correcting code (ECC) memory. Embodiments of the invention may be implemented in software operating on general purpose hardware. For example, techniques as described herein may be implemented by modifying a portion of the operating system that is sometimes called a memory manager.</p>
<p id="p-0019" num="0018">In some embodiments, the memory manager interfaces with the RAM of a computer system. The memory manager allocates RAM to software components that request memory resources. To ensure that a software component does not allocate RAM that is faulty, the OS may maintain stored information about RAM regions that have previously been found to cause errors.</p>
<p id="p-0020" num="0019">In some embodiments, the stored information about faulty RAM regions is created by the memory manager of the OS. Multiple sources of information may be used to create the stored information. One source of information may be from testing. The memory manager may perform a diagnostic test of RAM regions to determine which regions are faulty. Once a region is found to be faulty, it may be added to the stored information about faulty RAM regions that is maintained by the memory manager.</p>
<p id="p-0021" num="0020">In some embodiments, the memory manager can identify the RAM regions on which to run the diagnostic test. It may identify a particular RAM region to scan, a collection of RAM regions or the entirety of available RAM regions. Regions to test may be identified in any suitable way. In some embodiments, regions may be randomly selected for testing or may be scheduled in accordance with a predetermined pattern.</p>
<p id="p-0022" num="0021">In some embodiments, the memory manager may receive a trigger event in response to which it performs the diagnostic test. The trigger event may be a user of the computer system manually initiating a scan. Alternatively, the trigger event could be from a software component that encountered an error.</p>
<p id="p-0023" num="0022">Regardless of the source of the trigger, the memory manager may initiate a memory test to identify or confirm a faulty region. Though, in some scenarios, a software component indicating an error may be able to determine which RAM region caused the error. If so, then the this information may be included in the trigger event sent to the memory manager. The memory manager may selectively run the diagnostic test on the identified RAM region. Though, embodiments are possible in which a region is indicated as faulty, based on such an indication of an error, without any further testing.</p>
<p id="p-0024" num="0023">Any suitable mechanism may be deployed as the diagnostic test. In some embodiments the diagnostic test comprises scanning the RAM regions to be tested and determining whether the regions are faulty. The scan may comprise writing a pattern of bits to the region being tested and, after the bits have been written, reading the pattern that is stored in the RAM region. The written pattern and the read pattern are then compared. If the pattern has changed, this indicates that there is an error being within the RAM.</p>
<p id="p-0025" num="0024">The pattern of bits used to scan the RAM region may be any combination of bits, including patterns as are known in the art. For example, it could be all ones or all zeros. Alternatively, the pattern may alternate between one and zero. Also, a random pattern of zeros and ones may be used to scan the RAM region or a pattern in which a single bit of each word is set to a one, and the bit that is set to a one may change in each of multiple successive write cycles.</p>
<p id="p-0026" num="0025">In some embodiments, the regions that are identified to be tested may be currently allocated to a software component. It is possible for the memory manager to scan this RAM region. The memory manager can swap the contents of the RAM region that needs to be tested with an available region of RAM. This may be accomplished by allocating a free RAM region to the software component, transferring the contents of the RAM region that needs to be tested to the newly allocated RAM region and releasing the region to be tested such that it is no longer allocated to the software component.</p>
<p id="p-0027" num="0026">Techniques as are known in the art may be used for making this swap. For example, a memory manager may assign virtual addresses for use by software components. The memory manager, or other components of the computer system, may apply a mapping to translate these virtual addresses into physical addresses for RAM chips. To free a first region of physical memory for testing, the memory manager may copy the data from the first region to a second region of physical memory. The memory manager may then alter the mapping so that the virtual addresses used by a component point to the second region of physical memory.</p>
<p id="p-0028" num="0027">The stored information about faulty RAM regions may be stored in several different ways. In one embodiment, the permanent information about faulty RAM regions may be stored somewhere accessible by the boot manager. When the computer boots, the stored information can be used by the boot manager while initializing the OS such that the faulty RAM indicated as faulty is never made available to the OS, making it appear to the OS that the faulty RAM regions do not even exist.</p>
<p id="p-0029" num="0028">A different embodiment may store information about faulty RAM in volatile memory, such as the RAM itself. In this embodiment, the stored information will be deleted and reset every time the computer system powers off. Resetting the stored information may be advantageous for storing an identification of RAM regions in a system that may be subject to transient faults. If the memory manager cannot determine whether the RAM region is permanently faulty or cannot determine with a sufficiently high confidence that a RAM region is faulty at all, it may quarantine that RAM region by including that region among the stored information about faulty regions until a reboot occurs and resets the stored information.</p>
<p id="p-0030" num="0029">Alternatively or additionally, the information about faulty RAM may be stored in a persistent memory structure such that the stored information is persistently maintained through a computer system reboot. This type of faulty RAM region information is useful for recording regions of RAM that have been determined by the memory manager to be permanently faulty and not worth using in the future.</p>
<p id="p-0031" num="0030">Though, it should be appreciated that other techniques may be used to address the possibility of transient faults and indications of faulty regions with a low confidence that the RAM regions have faults. For example, the stored information about faulty regions may be retained in persistent storage, but may incorporate information indicating a frequency of a fault occurring in a particular region or a confidence level associated with a determination that a region is faulty.</p>
<p id="p-0032" num="0031">As a specific example, if a software error occurs of the type that could be caused by a faulty memory region, that region may be added to stored information with an indication that such a fault was detected once or that such a fault has a low confidence value. Such an indication may not preclude the memory region from being allocated to another software component. However, if that same fault recurs, the confidence level of the fault may be increased, such that the region is not allocated again. Conversely, if the same fault does not recur over some period, the region may be removed from the stored information entirely.</p>
<p id="p-0033" num="0032">Other techniques may be used in managing the stored information about faulty regions. Even regions indicated as permanently faulty may be retested periodically and possibly removed from the stored information if they retest without error or retest a sufficient number of times without error. As another example, if changes in a hardware configuration of a computer system are detected, such as may indicate a replacement of the memory chips, the stored information may be reset, regions associated with replaced RAM chips may be removed from the stored information or regions may be retested.</p>
<p id="p-0034" num="0033">Any embodiment of stored information about faulty RAM may be edited by a user of the computer system. This will allow the user to manually add or remove RAM regions from the stored information. This can be important if the user changes or adds new hardware components to the computer system. For example, if the user removes an old RAM chip and installs a new one, the user should reset the stored information about faulty RAM regions, otherwise the computer system may unintentionally prevent non-faulty RAM regions of the new RAM chip from being allocated to software components.</p>
<p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. 1</figref> illustrates an example of a suitable computing system environment <b>100</b> on which the invention may be implemented. The computing system environment <b>100</b> is only one example of a suitable computing environment and is not intended to suggest any limitation as to the scope of use or functionality of the invention. Neither should the computing environment <b>100</b> be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary operating environment <b>100</b>.</p>
<p id="p-0036" num="0035">The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.</p>
<p id="p-0037" num="0036">The computing environment may execute computer-executable instructions, such as program modules. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.</p>
<p id="p-0038" num="0037">With reference to <figref idref="DRAWINGS">FIG. 1</figref>, an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer <b>110</b>. Computer <b>110</b> is an example of a computer device that may systematically mitigate memory errors. Components of computer <b>110</b> may include, but are not limited to, a processing unit <b>120</b>, a system memory <b>130</b>, and a system bus <b>121</b> that couples various system components including the system memory to the processing unit <b>120</b>. The system bus <b>121</b> may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus also known as Mezzanine bus.</p>
<p id="p-0039" num="0038">Computer <b>110</b> typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer <b>110</b> and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by computer <b>110</b>. Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term &#x201c;modulated data signal&#x201d; means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.</p>
<p id="p-0040" num="0039">The system memory <b>130</b> includes computer storage media in the form of volatile and/or nonvolatile memory such as read only memory (ROM) <b>131</b> and random access memory (RAM) <b>132</b>. A basic input/output system <b>133</b> (BIOS), containing the basic routines that help to transfer information between elements within computer <b>110</b>, such as during start-up, is typically stored in ROM <b>131</b>. RAM <b>132</b> typically contains data and/or program modules that are immediately accessible to and/or presently being operated on by processing unit <b>120</b>. By way of example, and not limitation, <figref idref="DRAWINGS">FIG. 1</figref> illustrates operating system <b>134</b>, application programs <b>135</b>, other program modules <b>136</b>, and program data <b>137</b>.</p>
<p id="p-0041" num="0040">The computer <b>110</b> may also include other removable/non-removable, volatile/nonvolatile computer storage media. By way of example only, <figref idref="DRAWINGS">FIG. 1</figref> illustrates a hard disk drive <b>140</b> that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive <b>151</b> that reads from or writes to a removable, nonvolatile magnetic disk <b>152</b>, and an optical disk drive <b>155</b> that reads from or writes to a removable, nonvolatile optical disk <b>156</b> such as a CD ROM or other optical media. Other removable/non-removable, volatile/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive <b>141</b> is typically connected to the system bus <b>121</b> through an non-removable memory interface such as interface <b>140</b>, and magnetic disk drive <b>151</b> and optical disk drive <b>155</b> are typically connected to the system bus <b>121</b> by a removable memory interface, such as interface <b>150</b>.</p>
<p id="p-0042" num="0041">The drives and their associated computer storage media discussed above and illustrated in <figref idref="DRAWINGS">FIG. 1</figref>, provide storage of computer readable instructions, data structures, program modules and other data for the computer <b>110</b>. In <figref idref="DRAWINGS">FIG. 1</figref>, for example, hard disk drive <b>141</b> is illustrated as storing operating system <b>144</b>, application programs <b>145</b>, other program modules <b>146</b>, and program data <b>147</b>. Note that these components can either be the same as or different from operating system <b>134</b>, application programs <b>135</b>, other program modules <b>136</b>, and program data <b>137</b>. Operating system <b>144</b>, application programs <b>145</b>, other program modules <b>146</b>, and program data <b>147</b> are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer <b>110</b> through input devices such as a keyboard <b>162</b> and pointing device <b>161</b>, commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit <b>120</b> through a user input interface <b>160</b> that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor <b>191</b> or other type of display device is also connected to the system bus <b>121</b> via an interface, such as a video interface <b>190</b>. In addition to the monitor, computers may also include other peripheral output devices such as speakers <b>197</b> and printer <b>196</b>, which may be connected through a output peripheral interface <b>195</b>.</p>
<p id="p-0043" num="0042">The computer <b>110</b> may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer <b>180</b>. The remote computer <b>180</b> may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer <b>110</b>, although only a memory storage device <b>181</b> has been illustrated in <figref idref="DRAWINGS">FIG. 1</figref>. The logical connections depicted in <figref idref="DRAWINGS">FIG. 1</figref> include a local area network (LAN) <b>171</b> and a wide area network (WAN) <b>173</b>, but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.</p>
<p id="p-0044" num="0043">When used in a LAN networking environment, the computer <b>110</b> is connected to the LAN <b>171</b> through a network interface or adapter <b>170</b>. When used in a WAN networking environment, the computer <b>110</b> typically includes a modem <b>172</b> or other means for establishing communications over the WAN <b>173</b>, such as the Internet. The modem <b>172</b>, which may be internal or external, may be connected to the system bus <b>121</b> via the user input interface <b>160</b>, or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer <b>110</b>, or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation, <figref idref="DRAWINGS">FIG. 1</figref> illustrates remote application programs <b>185</b> as residing on memory device <b>181</b>. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.</p>
<p id="p-0045" num="0044"><figref idref="DRAWINGS">FIG. 2</figref> illustrates some of the software components that are used in embodiments of the present invention. These software components of computer system <b>200</b> are generally stored in RAM <b>132</b>, non-removable non-volatile memory <b>141</b>, or a combination thereof.</p>
<p id="p-0046" num="0045">The Operating System (OS) <b>210</b> is software that is generally used to control the hardware of the computer system <b>200</b>. The OS ensures that all the pieces of the computer system work together in a coherent manner. The component of the OS that handles core functionalities of the hardware is referred to as the kernel <b>212</b>. The OS <b>210</b> may be implemented using techniques as are known in the art.</p>
<p id="p-0047" num="0046">The computer system <b>200</b> executes application programs <b>230</b>, <b>232</b> and <b>234</b>. Application programs interface with the hardware of the computer system <b>200</b> through the OS <b>210</b>. Requests from application programs <b>230</b> to utilize hardware, such as RAM <b>132</b> or the processing unit <b>120</b>, are all handled by the OS <b>210</b>.</p>
<p id="p-0048" num="0047">The boot manager <b>240</b> is another component of computer system <b>200</b>. When the computer system is initially turned on, there is no OS in RAM <b>132</b> for the processing unit <b>120</b> to execute. The stored OS <b>144</b> must be loaded from non-volatile memory <b>141</b> to RAM <b>132</b> where the OS <b>134</b> can be executed by processing unit <b>120</b>. This is the job of boot manager <b>240</b>, which is preferably stored in ROM <b>131</b>. The boot manager <b>240</b> may comprise BIOS <b>133</b>. The boot manager <b>240</b> may be implemented using techniques as are known in the art.</p>
<p id="p-0049" num="0048">OS <b>210</b> includes a memory manager <b>220</b>, which may be part of the kernel <b>212</b>, but is shown separately in example computer system <b>200</b> of <figref idref="DRAWINGS">FIG. 2</figref>. The memory manager <b>220</b> provides all software components on the computer system <b>200</b> access to the RAM <b>132</b>, whether the software components belong to the OS <b>210</b> or an application program <b>230</b>. The memory manager <b>220</b> uses RAM allocator <b>226</b> to allocate memory to software components and mediates requests from multiple components that simultaneously request RAM. RAM allocator <b>226</b> may be implemented using techniques as are known in the art, except that RAM allocator <b>226</b> does not allocate memory regions indicated as faulty.</p>
<p id="p-0050" num="0049">The memory manager <b>220</b> generally breaks the RAM <b>132</b> into multiple regions, which are allocated to applications. The specific meaning of a region may depend on the implementation of an operating system and possibly the underlying RAM hardware. Examples of regions are pages, segments or blocks. RAM is not allocated to applications <b>230</b> in single bit units. Rather, it is allocated in regions&#x2014;meaning the smallest unit of memory that may be allocated by the memory manager <b>220</b> to an application <b>230</b> is a single region. The size of RAM regions varies depending on the specifics of the computer system <b>200</b>, but an example size of a RAM region may be 4096 bytes.</p>
<p id="p-0051" num="0050">Example computer system <b>200</b> shows the diagnostic test tool <b>222</b> and the faulty memory storage tool <b>224</b> as part of memory manager <b>220</b>. It should be understood that the invention is not limited to this particular embodiment. The diagnostic test tool <b>222</b> and/or the faulty memory storage tool <b>224</b> may be included in some other part of the OS <b>210</b>. Further, they may not be part of the OS at all, but rather an application program such as application <b>232</b>, that is installed and executed on computer system <b>200</b> independent from the OS <b>210</b>.</p>
<p id="p-0052" num="0051">There are several advantages to embodiments where the memory manager <b>220</b> is part of the kernel <b>212</b>, For example, the memory manager <b>220</b> may have access to more memory regions, such as regions in use by the kernel itself, allowing for a more comprehensive system. Also, by including the memory manager <b>220</b> in the kernel <b>212</b> the diagnostic test tool can be run transparently and noninvasively such that a user of the computer system <b>200</b> is unaware that a diagnostic test is being performed. Though this embodiment has advantages, the present invention is not limited to this particular embodiment.</p>
<p id="p-0053" num="0052">As stated in the above, RAM <b>132</b> may become faulty. The computer system <b>200</b> would be more stable and reliable if faulty regions of RAM <b>132</b> were never allocated to software components. Embodiments of the present invention mitigate RAM errors using method <b>300</b> detailed in <figref idref="DRAWINGS">FIG. 3</figref> that avoids allocation of faulty regions.</p>
<p id="p-0054" num="0053">The technique begins at act <b>302</b> by running the OS <b>210</b> on processing unit <b>120</b>. The OS is initiated using the boot manager <b>240</b>. Running the OS <b>210</b> means that the memory manager <b>220</b> will also be running and managing the RAM <b>132</b>.</p>
<p id="p-0055" num="0054">In some embodiments, the memory manager <b>220</b> may receive an indicator of an error from a software component at act <b>303</b>. The software component may be application program <b>234</b> or a component of the OS <b>210</b>. The error indicator is optional and is not a limitation of all embodiments of the present invention.</p>
<p id="p-0056" num="0055">The error indicator is received by the memory manager <b>220</b> when an error has occurred in the software component. In some embodiments the error indicator is only sent when the error is related to memory failure. If the software component that encountered an error is able to ascertain the RAM region that caused the error then that information may be included in the error indicator sent to the memory manager <b>220</b>.</p>
<p id="p-0057" num="0056">At act <b>304</b>, the memory manager <b>220</b> identifies a region of RAM to test. This identification of a RAM region may be triggered in many different ways. In one embodiment, a user of computer system <b>200</b> may manually initiate a scan of all RAM regions to test the RAM for faults. Alternatively or additionally, the memory manager <b>220</b> receives a trigger event from a software component. Trigger events from software components indicate that an error occurred in the software program while executing. Certain errors are indicative of a memory failure and it is possible, in some instances, for the OS <b>210</b> to identify the particular RAM region that caused the error. If the RAM region is identifiable, then the identity of the failed RAM region may be passed to the memory manager <b>220</b>. At this point the memory manager can choose to test only the failed RAM region, a selected group of RAM regions or all RAM regions.</p>
<p id="p-0058" num="0057">In a further embodiment, a trigger event may be received based on a set schedule. For example, the OS may arrange for full memory scans at scheduled intervals. Scans may also be scheduled at times when the computer system <b>200</b> is not actively being used.</p>
<p id="p-0059" num="0058">Once at least one RAM region has been identified for testing, the memory manager <b>220</b> checks whether the RAM region is currently in use by a software component at act <b>306</b>. If the RAM is free, then the memory manager <b>220</b> will proceed to perform a diagnostic test on the RAM region at act <b>308</b>. If the RAM region is currently in use, then the memory manager will perform a series of actions (<b>310</b>, <b>312</b> and <b>314</b>) to free the RAM region so that it may be tested. The details of these acts are described in detail below.</p>
<p id="p-0060" num="0059">At step <b>308</b>, the diagnostic test tool <b>222</b> performs the actual diagnostic test on the identified RAM region. The diagnostic test determines whether the RAM region is faulty. If it is not faulty, then decision block <b>318</b> returns to running the OS at act <b>302</b>. If the RAM region is determined to be faulty, then the decision block <b>318</b> continues to act <b>320</b> where the faulty RAM region is added to the stored information about faulty RAM regions that is maintained by memory manager <b>220</b>. The information about faulty RAM regions may be stored in faulty memory storage tool <b>224</b>. This stored information may be represented in various forms. In one embodiment, this information may be structured as a list of faulty RAM regions. As another example, this information may be represented by using a flag associated with each RAM region, wherein a particular value of the flag indicates that the RAM region is faulty. Many techniques are known in the art for associating descriptive information with objects, and any of these techniques can be readily employed by the faulty memory storage tool <b>224</b>.</p>
<p id="p-0061" num="0060">Once act <b>320</b> is complete and future memory errors have thus been mitigated, the computer system <b>200</b> returns to running the OS at act <b>302</b>. At this point the entire process may be repeated the next time the memory manager <b>220</b> identifies a region of RAM to be tested.</p>
<p id="p-0062" num="0061">The above discussion described a sequence of events that may occur when it is determined at decision block <b>306</b> that the region of RAM to be tested was not in use by a software component. If it is determined that the region of RAM is in use by a software component at decision block <b>306</b>, then the method continues to act <b>310</b>. At act <b>310</b>, RAM allocator <b>226</b> allocates a free region of RAM to the software component that is using the RAM region to be tested. The data that is stored in the RAM region to be tested is then transferred to the new free region of RAM at act <b>312</b>. Once the data transfer is complete, the memory manager <b>220</b> releases the RAM region to be tested at act <b>314</b>. Here, &#x201c;release&#x201d; may mean that the data stored in the RAM is no longer used by the software component. It may also mean that the region is no longer allocated to the software component that was previously using it.</p>
<p id="p-0063" num="0062">Once the RAM region to be tested is no longer in use by any software component of the computer system <b>200</b>, it continues to act <b>308</b>. At this point, the method continues in the same manner as described above in the instance that the RAM region was not in use by a software component.</p>
<p id="p-0064" num="0063">Any suitable mechanism may be used to perform the diagnostic test at act <b>308</b> of method <b>300</b>. <figref idref="DRAWINGS">FIG. 4</figref> describes one particular embodiment of the diagnostic test. The test begins at act <b>402</b>. The diagnostic test tool <b>222</b> is initiated by the memory manager <b>220</b> after the RAM region to be tested has been identified and it is not being used by any software component of the computer system <b>200</b>. At act <b>404</b>, the diagnostic test tool <b>224</b> performs a scan of the region being tested. After the scan, act <b>406</b> determines whether the RAM region is faulty based on the results of the scan. The diagnostic test ends at act <b>408</b> and method <b>300</b> will continue to decision block <b>318</b>.</p>
<p id="p-0065" num="0064">The scan that is performed by the diagnostic test tool <b>222</b> at step <b>404</b> of the diagnostic test <b>308</b> may be performed in any number of ways that will suitably test the RAM regions for faults. An example embodiment of this scan <b>404</b> is shown in <figref idref="DRAWINGS">FIG. 5</figref>. The scan of the RAM region is started in act <b>502</b> after the diagnostic test tool <b>222</b> begins the diagnostic scan. At act <b>504</b>, the diagnostic test tool <b>222</b> writes at least one pattern of ones and zeros to the region of RAM being tested. The pattern can be anything: all zeros, all ones, alternating ones/zeros, a random pattern or some other pattern. Once the pattern has been written to the RAM region in act <b>504</b>, the diagnostic test tool <b>222</b> reads the same RAM region at act <b>506</b>. The written pattern and the read pattern are compared at step <b>508</b>. If the patterns differ, it may be concluded that some portion of the RAM region caused the error and is potentially faulty. The act of scanning <b>404</b> terminates at act <b>510</b> and the diagnostic test of act <b>308</b> continues to act <b>406</b>.</p>
<p id="p-0066" num="0065">Having thus described several aspects of at least one embodiment of this invention, it is to be appreciated that various alterations, modifications, and improvements will readily occur to those skilled in the art. Such alterations, modifications, and improvements are intended to be part of this disclosure, and are intended to be within the spirit and scope of the invention. Accordingly, the foregoing description and drawings are by way of example only.</p>
<p id="p-0067" num="0066">The above-described embodiments of the present invention can be implemented in any of numerous ways. For example, the embodiments may be implemented using hardware, software or a combination thereof. When implemented in software, the software code can be executed on any suitable processor or collection of processors, whether provided in a single computer or distributed among multiple computers. Such processors may be implemented as integrated circuits, with one or more processors in an integrated circuit component. Though, a processor may be implemented using circuitry in any suitable format.</p>
<p id="p-0068" num="0067">Further, it should be appreciated that a computer may be embodied in any of a number of forms, such as a rack-mounted computer, a desktop computer, a laptop computer, or a tablet computer. Additionally, a computer may be embedded in a device not generally regarded as a computer but with suitable processing capabilities, including a Personal Digital Assistant (PDA), a smart phone or any other suitable portable or fixed electronic device.</p>
<p id="p-0069" num="0068">Also, a computer may have one or more input and output devices. These devices can be used, among other things, to present a user interface. Examples of output devices that can be used to provide a user interface include printers or display screens for visual presentation of output and speakers or other sound generating devices for audible presentation of output. Examples of input devices that can be used for a user interface include keyboards, and pointing devices, such as mice, touch pads, and digitizing tablets. As another example, a computer may receive input information through speech recognition or in other audible format.</p>
<p id="p-0070" num="0069">Such computers may be interconnected by one or more networks in any suitable form, including as a local area network or a wide area network, such as an enterprise network or the Internet. Such networks may be based on any suitable technology and may operate according to any suitable protocol and may include wireless networks, wired networks or fiber optic networks.</p>
<p id="p-0071" num="0070">Also, the various methods or processes outlined herein may be coded as software that is executable on one or more processors that employ any one of a variety of operating systems or platforms. Additionally, such software may be written using any of a number of suitable programming languages and/or programming or scripting tools, and also may be compiled as executable machine language code or intermediate code that is executed on a framework or virtual machine.</p>
<p id="p-0072" num="0071">In this respect, the invention may be embodied as a computer readable medium (or multiple computer readable media) (e.g., a computer memory, one or more floppy discs, compact discs (CD), optical discs, digital video disks (DVD), magnetic tapes, flash memories, circuit configurations in Field Programmable Gate Arrays or other semiconductor devices, or other non-transitory, tangible computer storage medium) encoded with one or more programs that, when executed on one or more computers or other processors, perform methods that implement the various embodiments of the invention discussed above. The computer readable medium or media can be transportable, such that the program or programs stored thereon can be loaded onto one or more different computers or other processors to implement various aspects of the present invention as discussed above. As used herein, the term &#x201c;non-transitory computer-readable storage medium&#x201d; encompasses only a computer-readable medium that can be considered to be a manufacture (i.e., article of manufacture) or a machine.</p>
<p id="p-0073" num="0072">The terms &#x201c;program&#x201d; or &#x201c;software&#x201d; are used herein in a generic sense to refer to any type of computer code or set of computer-executable instructions that can be employed to program a computer or other processor to implement various aspects of the present invention as discussed above. Additionally, it should be appreciated that according to one aspect of this embodiment, one or more computer programs that when executed perform methods of the present invention need not reside on a single computer or processor, but may be distributed in a modular fashion amongst a number of different computers or processors to implement various aspects of the present invention.</p>
<p id="p-0074" num="0073">Computer-executable instructions may be in many forms, such as program modules, executed by one or more computers or other devices. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments.</p>
<p id="p-0075" num="0074">Also, data structures may be stored in computer-readable media in any suitable form. For simplicity of illustration, data structures may be shown to have fields that are related through location in the data structure. Such relationships may likewise be achieved by assigning storage for the fields with locations in a computer-readable medium that conveys relationship between the fields. However, any suitable mechanism may be used to establish a relationship between information in fields of a data structure, including through the use of pointers, tags or other mechanisms that establish relationship between data elements.</p>
<p id="p-0076" num="0075">Various aspects of the present invention may be used alone, in combination, or in a variety of arrangements not specifically discussed in the embodiments described in the foregoing and is therefore not limited in its application to the details and arrangement of components set forth in the foregoing description or illustrated in the drawings. For example, aspects described in one embodiment may be combined in any manner with aspects described in other embodiments.</p>
<p id="p-0077" num="0076">Also, the invention may be embodied as a method, of which an example has been provided. The acts performed as part of the method may be ordered in any suitable way. Accordingly, embodiments may be constructed in which acts are performed in an order different than illustrated, which may include performing some acts simultaneously, even though shown as sequential acts in illustrative embodiments.</p>
<p id="p-0078" num="0077">Use of ordinal terms such as &#x201c;first,&#x201d; &#x201c;second,&#x201d; &#x201c;third,&#x201d; etc., in the claims to modify a claim element does not by itself connote any priority, precedence, or order of one claim element over another or the temporal order in which acts of a method are performed, but are used merely as labels to distinguish one claim element having a certain name from another element having a same name (but for use of the ordinal term) to distinguish the claim elements.</p>
<p id="p-0079" num="0078">Also, the phraseology and terminology used herein is for the purpose of description and should not be regarded as limiting. The use of &#x201c;including,&#x201d; &#x201c;comprising,&#x201d; or &#x201c;having,&#x201d; &#x201c;containing,&#x201d; &#x201c;involving,&#x201d; and variations thereof herein, is meant to encompass the items listed thereafter and equivalents thereof as well as additional items.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method for mitigating one or more failures in a memory of a computer system, the memory comprising a plurality of regions, the method comprising:
<claim-text>running an Operating System (OS), wherein the OS uses at least a portion of the memory;</claim-text>
<claim-text>identifying at least a first region of the memory to be tested;</claim-text>
<claim-text>performing a diagnostic test of at least the first region, wherein the diagnostic test comprises:
<claim-text>scanning at least the first region;</claim-text>
<claim-text>determining that the first region is faulty;</claim-text>
</claim-text>
<claim-text>maintaining stored information about faulty memory regions;</claim-text>
<claim-text>in response to determining that the first region is faulty, adding an indication that the first region is faulty to the stored information about faulty memory regions; and</claim-text>
<claim-text>allocating one or more regions of the memory to one or more software components running on the computer system, the allocating comprising checking the stored information about faulty memory regions and excluding memory regions indicated as faulty according to the stored information.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein identifying at least the first region of the memory to be tested comprises receiving a trigger event from a first software component, the trigger event indicating that a fault occurred in the first region of the memory.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the first software component is an application program.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the first software component is the OS.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein:
<claim-text>the first region of the memory stores data for a first software component of the one or more software components running on the computer system,</claim-text>
<claim-text>the method further comprising:
<claim-text>allocating a second region of the memory for use by the first software component;</claim-text>
<claim-text>transferring the data stored in the first region of the memory to the second region of the memory; and</claim-text>
<claim-text>releasing the first region of the memory from the first software component.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising resetting the stored information about faulty regions as part of a reboot of the computer system.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising maintaining the stored information about faulty regions through a reboot of the computer system.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein:
<claim-text>scanning at least the first region comprises:
<claim-text>writing a first pattern to the first region of the memory;</claim-text>
<claim-text>reading a second pattern from the first region of the memory; and</claim-text>
<claim-text>comparing the first and second patterns; and wherein</claim-text>
</claim-text>
<claim-text>the determination that the first region is faulty is based on the first pattern being different from the second pattern.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. A system for mitigating one or more failures in a memory of a computing device, the system comprising:
<claim-text>a processor; and</claim-text>
<claim-text>an Operating System (OS) running on the processor, the OS comprising a memory manager comprising:
<claim-text>a faulty memory storage tool programmed to store information about faulty memory regions;</claim-text>
<claim-text>a memory allocator programmed to allocate one or more memory regions to one or more software components running on the computing device, wherein the one or more regions for allocation excludes regions included in the stored information about faulty memory regions; and</claim-text>
<claim-text>a diagnostic test tool programmed to scan at least a first region of the memory and determining whether the first region of the memory is faulty;</claim-text>
</claim-text>
<claim-text>wherein the faulty memory storage tool is further programmed to add an indication that the first region has been determined to be faulty to the stored information about faulty memory regions in response to the first region being determined to be faulty by the diagnostic test tool.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The system of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the memory manager is further programmed to receive at least one trigger event from a first software component.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The system of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the memory stores data for a first software component running on the processor and the memory allocator is further programmed to:
<claim-text>allocate a second region of the memory for use by the first software component;</claim-text>
<claim-text>transfer the data stored in the first region of the memory to the second region of the memory; and</claim-text>
<claim-text>reallocate the first region of the memory from the first software component.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The system of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the faulty memory storage tool is further programmed to reset the stored information about faulty memory regions as part of a reboot of the system.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the faulty memory storage tool is further programmed to maintain the stored information about faulty memory regions through a reboot of the system.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the diagnostic test tool is further programmed to:
<claim-text>write a first pattern to the first region of the memory;</claim-text>
<claim-text>read a second pattern from the first region of the memory;</claim-text>
<claim-text>compare the first and second patterns; and</claim-text>
<claim-text>determine whether the first pattern is different from the second pattern.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. At least one computer-readable memory having computer-executable instructions stored therein, that when executed by a processor of a computer system having an Operating System (OS) and a system memory, the OS allocating regions of the system memory for use by the OS and by one or more applications, and the OS including a memory manager, perform operations comprising:
<claim-text>while the OS is executing, encountering an error condition associated with execution of a software component, the error condition indicative of a likely failure within a first memory region of the system memory;</claim-text>
<claim-text>the memory manager receiving an indication of the error condition associated with execution of the software component;</claim-text>
<claim-text>in response to the received indication of the error condition, detecting a failure within the first memory region;</claim-text>
<claim-text>adding an indication that the first region has been determined to be faulty to a stored list of faulty memory regions; and</claim-text>
<claim-text>using the stored list of faulty memory regions to allocate at least a second memory region of the system memory for use by one or more software components, wherein the second memory region is not indicated as faulty according to the stored list of faulty memory regions.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The at least one computer-readable memory of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein detecting a failure within the first memory region comprises:
<claim-text>scanning at least the first memory region to test whether the first region is faulty, the scanning comprising:
<claim-text>writing a first pattern to the first memory region;</claim-text>
<claim-text>reading a second pattern from the first memory region; and</claim-text>
<claim-text>determining that the first pattern is different from the second pattern; and</claim-text>
</claim-text>
<claim-text>determining that the first memory region is faulty in response to determining that the first pattern is different from the second pattern.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The at least one computer-readable memory of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein scanning at least the first memory region comprises scanning only the first memory region.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The at least one computer-readable memory of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the operations further comprise:
<claim-text>determining that the first region is currently storing data for a first software component;</claim-text>
<claim-text>allocating a third memory region of the system memory;</claim-text>
<claim-text>copying the data stored in the first memory region to the third memory region; and</claim-text>
<claim-text>freeing the first memory region.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The at least one computer-readable memory of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the stored list of faulty memory regions is deleted as part of a reboot of the computer system.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The at least one computer-readable memory of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the stored list of faulty memory regions is stored such that the list does not change when the OS shuts down.</claim-text>
</claim>
</claims>
</us-patent-grant>
