<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627315-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627315</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>10555336</doc-number>
<date>20041231</date>
</document-id>
</application-reference>
<us-application-series-code>10</us-application-series-code>
<us-term-of-grant>
<us-term-extension>2121</us-term-extension>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>9</main-group>
<subgroup>46</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>13</main-group>
<subgroup>00</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>15</main-group>
<subgroup>173</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>718100</main-classification>
<further-classification>718104</further-classification>
<further-classification>719324</further-classification>
<further-classification>709224</further-classification>
<further-classification>709226</further-classification>
</classification-national>
<invention-title id="d2e53">Apparatus and method for cooperative guest firmware</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>6081890</doc-number>
<kind>A</kind>
<name>Datta</name>
<date>20000600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>7281124</doc-number>
<kind>B2</kind>
<name>Rothman et al.</name>
<date>20071000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>7302514</doc-number>
<kind>B2</kind>
<name>Ouriel et al.</name>
<date>20071100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711  6</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2002/0143842</doc-number>
<kind>A1</kind>
<name>Cota-Robles et al.</name>
<date>20021000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>2003/0217250</doc-number>
<kind>A1</kind>
<name>Bennett et al.</name>
<date>20031100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>712224</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2004/0268107</doc-number>
<kind>A1</kind>
<name>Zimmer et al.</name>
<date>20041200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2004/0268347</doc-number>
<kind>A1</kind>
<name>Knauerhase et al.</name>
<date>20041200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2005/0091365</doc-number>
<kind>A1</kind>
<name>Lowell et al.</name>
<date>20050400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709224</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2005/0091652</doc-number>
<kind>A1</kind>
<name>Ross et al.</name>
<date>20050400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>718  1</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>WO</country>
<doc-number>WO 2004/061659</doc-number>
<date>20040700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00011">
<othercit>Goldberg, R., &#x201c;Survey of Virtual Machine Research&#x201d;, IEEE Computer Magazine 7(6), pp. 34-45, 1974.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00012">
<othercit>International Preliminary Report on Patentability for PCT/CN2004/001588, issued Jul. 12, 2007.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>9</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>718  1</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>5</number-of-drawing-sheets>
<number-of-figures>5</number-of-figures>
</figures>
<us-related-documents>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20070011486</doc-number>
<kind>A1</kind>
<date>20070111</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Li</last-name>
<first-name>Shaofan</first-name>
<address>
<city>Shanghai</city>
<country>CN</country>
</address>
</addressbook>
<residence>
<country>CN</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Haoyu</last-name>
<first-name>Gao</first-name>
<address>
<city>Shanghai</city>
<country>CN</country>
</address>
</addressbook>
<residence>
<country>CN</country>
</residence>
</us-applicant>
<us-applicant sequence="003" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Cheung</last-name>
<first-name>William</first-name>
<address>
<city>San Jose</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="004" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Yu</last-name>
<first-name>Ke</first-name>
<address>
<city>Shanghai</city>
<country>CN</country>
</address>
</addressbook>
<residence>
<country>CN</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Li</last-name>
<first-name>Shaofan</first-name>
<address>
<city>Shanghai</city>
<country>CN</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Haoyu</last-name>
<first-name>Gao</first-name>
<address>
<city>Shanghai</city>
<country>CN</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Cheung</last-name>
<first-name>William</first-name>
<address>
<city>San Jose</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="004" designation="us-only">
<addressbook>
<last-name>Yu</last-name>
<first-name>Ke</first-name>
<address>
<city>Shanghai</city>
<country>CN</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Blakely, Sokoloff, Taylor &#x26; Zafman LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Intel Corporation</orgname>
<role>02</role>
<address>
<city>Santa Clara</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>An</last-name>
<first-name>Meng</first-name>
<department>2195</department>
</primary-examiner>
<assistant-examiner>
<last-name>Arcos</last-name>
<first-name>Caroline H</first-name>
</assistant-examiner>
</examiners>
<pct-or-regional-filing-data>
<document-id>
<country>WO</country>
<doc-number>PCT/CN2004/001588</doc-number>
<kind>00</kind>
<date>20041231</date>
</document-id>
<us-371c124-date>
<date>20051031</date>
</us-371c124-date>
</pct-or-regional-filing-data>
<pct-or-regional-publishing-data>
<document-id>
<country>WO</country>
<doc-number>WO2006/069493</doc-number>
<kind>A </kind>
<date>20060706</date>
</document-id>
</pct-or-regional-publishing-data>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A method and apparatus for cooperative guest firmware are described. In one embodiment, the method includes the launch of a virtual machine (VM) including a guest operating system (OS) and guest firmware. Prior to launching the VM, a data structure is generated in memory and is associated with the guest firmware to provide a virtualization policy provided by the VM as well as processor and platform configuration information to the guest firmware. In one embodiment, the guest firmware uses the data structure to access static information regarding the virtualization policy, as well as the processor and platform configuration information in response to requests from the guest OS. However, when the guest OS requires a host platform service, a virtual machine monitor (VMM) services the guest firmware requests for host platform services. Other embodiments are described and claimed.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="190.50mm" wi="209.63mm" file="US08627315-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="187.03mm" wi="162.81mm" file="US08627315-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="177.80mm" wi="141.14mm" file="US08627315-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="215.90mm" wi="136.40mm" file="US08627315-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="215.90mm" wi="208.96mm" file="US08627315-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="172.64mm" wi="160.78mm" orientation="landscape" file="US08627315-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<p id="p-0002" num="0001">The present patent application is a non-provisional application of International Application No. PCT/CN2004/001588, filed Dec. 31, 2004.</p>
<heading id="h-0001" level="1">FIELD</heading>
<p id="p-0003" num="0002">One or more embodiments relate generally to the field of computer system design. More particularly, one or more of the embodiments relate to a method and apparatus for cooperative guest firmware.</p>
<heading id="h-0002" level="1">BACKGROUND</heading>
<p id="p-0004" num="0003">A virtual machine architecture logically partitions a physical machine, such that the underlying hardware of the machine is time-shared and appears as one or more independently operating virtual machines (VMs). A virtual machine monitor (VMM) creates the VM and runs on a computer to facilitate for other software the abstraction of one or more VMs. Each VM may function as a self-contained platform, running its own operating system (OS) and application software. The software running in a VM is collectively referred to herein as &#x201c;guest software.&#x201d;</p>
<p id="p-0005" num="0004">The guest software expects to operate as if it were running on a dedicated computer rather than in a VM. That is, the guest software expects to control various events and have access to hardware resources on the computer (e.g., physical machine). The hardware resources of the physical machine may include one or more processors, resources resident on the processors (e.g., control registers, caches and others), memory (instructions residing in memory, e.g., descriptor tables), and other resources (e.g., input/output devices) that reside in the physical machine. The events may include interrupts, exceptions, platform events (e.g., initialization) (INIT) or system management interrupts (SMIs), and the like.</p>
<p id="p-0006" num="0005">Hence, a VMM presents to other software (&#x201c;guest software,&#x201d; &#x201c;guests&#x201d; or simply &#x201c;guest&#x201d;) the abstraction of one or more VMs. The VMM can provide the same or different abstractions to the various guests. Each guest expects the full facilities of the hardware platform presented in the VM to be available for its use. For example, the guest expects to have access to all registers, caches, structures, I/O devices, memory and the like according to the architecture of the processor and platform presented in the VM. Further, each guest expects to handle various events, such as exceptions, interrupts and platform events (e.g., initialization) (INIT) and system management interrupts (SMIs).</p>
<p id="p-0007" num="0006">Some of these resources and events are privileged because they are managed by the VMM to ensure proper operation of VMs and to protect the VMM and other VMs. For the privileged resources and events, the VMM facilitates functionality desired by guest software, while retaining ultimate control over these resources and events. The act of facilitating the functionality for the guest software may include a wide variety of activities on the part of the VMM. The activities of the VMM, as well as its characteristics, do not limit the scope of various embodiments described herein.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0008" num="0007">The various embodiments of the present invention are illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings and in which:</p>
<p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram illustrating a computer system including a firmware interface between operating system software and platform hardware, in accordance with one embodiment.</p>
<p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram illustrating cooperative guest firmware, in accordance with one embodiment.</p>
<p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. 3</figref> is a block diagram illustrating a handoff block (HOB) data structure to enable cooperative guest firmware, as shown in <figref idref="DRAWINGS">FIG. 2</figref>, in accordance with one embodiment.</p>
<p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. 4</figref> is a flowchart illustrating a method for cooperative guest firmware, in accordance with one embodiment.</p>
<p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. 5</figref> is a block diagram illustrating a system to provide cooperative guest firmware, in accordance with one embodiment.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION</heading>
<p id="p-0014" num="0013">In the following description, numerous specific details such as logic implementations, sizes and names of signals and buses, types and interrelationships of system components, and logic partitioning/integration choices are set forth to provide a more thorough understanding. It will be appreciated, however, by one skilled in the art that the invention may be practiced without such specific details. In other instances, control structures and gate level circuits have not been shown in detail to avoid obscuring the invention. Those of ordinary skill in the art, with the included descriptions, will be able to implement appropriate logic circuits without undue experimentation.</p>
<p id="p-0015" num="0014">In the following description, certain terminology is used to describe features of the invention. For example, the term &#x201c;logic&#x201d; is representative of hardware and/or software configured to perform one or more functions. For instance, examples of &#x201c;hardware&#x201d; include, but are not limited or restricted to, an integrated circuit, a finite state machine or even combinatorial logic. The integrated circuit may take the form of a processor such as a microprocessor, application specific integrated circuit, a digital signal processor, a micro-controller, or the like.</p>
<p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram illustrating a computer system including firmware <b>140</b> to provide an interface between operating system software <b>130</b> and platform hardware <b>101</b>. As described herein, firmware refers to processor routines that are stored in non-volatile memory structures, such as read only memories (ROMs), flash memories, and the like. These memory structures preserve the code stored in them even when power is shut off. Even though firmware is stored in non-volatile memory, firmware may be copied or shadowed to volatile memory. Firmware traditionally provides the necessary instructions or routines that control a computer system when it is powered up from a shut down state, before volatile memory structures have been tested and configured. Firmware routines may also be used to reinitialize and reconfigure the computer system following various events and to handle certain platform events, such as system interrupts.</p>
<p id="p-0017" num="0016">As shown in <figref idref="DRAWINGS">FIG. 1</figref>, firmware <b>140</b> includes three major components: extensible firmware interface (EFI) <b>142</b> to provide OS software <b>130</b> access to the firmware components. Representatively, the firmware components include system abstraction layer (SAL) <b>144</b> and processor abstraction layer (PAL) <b>146</b>. As described herein, EFI <b>142</b>, SAL <b>144</b> and PAL <b>146</b> are collectively referred to herein as &#x201c;host firmware.&#x201d; In one embodiment, operating system software <b>130</b> interacts with host firm-ware, specifically PAL <b>144</b> and SAL <b>146</b> via EFI interface <b>142</b>, to provide an environment in which applications can be executed by the CPU. SAL <b>144</b> is a firmware layer that isolates an operating system and other higher level software from implementation differences in the platform. PAL <b>146</b> provides a consistent software interface to access the processor resources across different processor implementations and encapsulates all processor model-specific hardware.</p>
<p id="p-0018" num="0017">As shown in <figref idref="DRAWINGS">FIG. 2</figref>, A virtual machine architecture logically partitions a physical machine, such that the underlying hardware of the machine is time-shared and appears as one or more independently operating virtual machines (VMs). A virtual machine monitor (VMM) creates the VM and runs on a computer to facilitate, for other software, the abstraction of one or more VMs. Each VM may function as a self-contained platform, running its own operating system (OS) and application software. The software running in a VM is collectively referred to herein as &#x201c;guest software.&#x201d;</p>
<p id="p-0019" num="0018">Referring again to <figref idref="DRAWINGS">FIG. 1</figref>, SAL <b>144</b> is a platform specific firmware component that may be provided, for example, by OEMs and system software vendors. SAL <b>144</b> is similar to a basic input/output system (BIOS). During boot-up of the computer system <b>100</b>, SAL <b>144</b> interacts with the OS <b>130</b> (stored on a booted device, such as a hard disk drive, for example) to load portions of operating system <b>130</b> into memory (of the computer system). In the boot-up of the computer system <b>100</b>, SAL <b>144</b> is responsible for performing platform tests, initialization and loading the first level of the operating system loader. As part of this process, VMM <b>210</b> is loaded and is responsible for creating and deploying VM <b>220</b> including cooperative guest firmware, in accordance with one embodiment.</p>
<p id="p-0020" num="0019">In one embodiment, as shown in <figref idref="DRAWINGS">FIG. 2</figref>, in addition to loading guest OS within VM <b>220</b>, VMM <b>210</b> also loads guest firmware <b>240</b> within VM <b>220</b>. In one embodiment, guest firmware <b>240</b> includes EFI <b>242</b>, SAL <b>244</b> and PAL <b>246</b>, which are collectively referred to herein as &#x201c;guest firmware.&#x201d; In a conventional environment, an OS needs to call various firmware services. Accordingly, in the embodiment illustrated in <figref idref="DRAWINGS">FIG. 2</figref>, guest firmware <b>240</b> is provided inside VM <b>220</b> to directly service all guest OS firmware needs. In one embodiment, cooperative guest firmware within VMM provides better processor and platform virtualization. As described herein, virtualization or virtualization policy refers to a decision as to which services are performed by guest firmware, which services are performed by the host firmware <b>140</b> and the host platform <b>101</b>.</p>
<p id="p-0021" num="0020">In one embodiment, to achieve cooperation between the guest firmware <b>240</b> and VMM <b>210</b>, handoff block (HOB) data structure <b>250</b> is provided to convey the VMM virtualization strategy and VM configuration information to guest firmware <b>240</b>. In one embodiment, when VMM <b>210</b> creates VM <b>220</b>, VMM <b>210</b> defines processor and platform configuration information for VM <b>220</b>. For example, the processor and platform configuration information may include, for example, the virtual processor abstraction (e.g., physical address bits supported and number of translation lookahead buffer (TLB) translation registers), the platform physical memory size, etc. In one embodiment, VMM <b>210</b> defines this processor and platform configuration information and creates HOB data structure <b>250</b> to provide the static information to guest firmware <b>240</b>.</p>
<p id="p-0022" num="0021">In one embodiment, following creation of HOB data structure <b>250</b> in memory, VMM <b>210</b> passes HOB data structure <b>250</b> to guest firmware <b>240</b> upon creation of VM <b>220</b>. In one embodiment, guest firmware <b>240</b> digests the HOB information and operates accordingly. Representatively, HOB data structure <b>250</b> provides a static interface between guest firmware <b>240</b> and VMM <b>210</b>. In one embodiment, in response to a firmware service request issued by guest OS <b>230</b>, guest firmware <b>240</b> may query HOB data structure <b>250</b> to determine whether the request is for configuration information and provides such configuration information to guest OS <b>230</b> rather than having to trap to VMM <b>210</b> to access the processor and platform information.</p>
<p id="p-0023" num="0022">Although HOB data structure <b>250</b> can provide static information, in some cases, this apparatus is unable to satisfy cooperation requirements between guest firmware <b>240</b> and VMM <b>210</b>. For example, guest firmware <b>240</b> may need certain host software provided services (e.g., cache flush) because guest firmware <b>240</b> is running inside VM <b>220</b>, guest firmware <b>240</b> cannot call the host, itself. However, the VMM <b>210</b>, which is running at a highest privilege level is capable of initiating or servicing such requests. Accordingly, in one embodiment, a dynamic cooperation interface is provided between guest firmware <b>240</b> and VMM <b>210</b> to allow guest firmware <b>240</b> to dynamically initiate service requests to VMM <b>210</b>.</p>
<p id="p-0024" num="0023">In one embodiment, a handshake protocol for communication between guest firmware <b>240</b> and VMM <b>210</b> is provided using two possible synchronous mechanisms. Although two synchronous mechanisms are described, those skilled in the art should recognize that other techniques for communicating with VMM <b>210</b> and enabling VMM <b>210</b> to intercept services requests from guest firmware are possible while remaining within the scope of the described embodiments. In one embodiment, to dynamically initiate service requests to VMM <b>210</b>, guest firmware <b>240</b> may initiate a break instruction, which provides a mechanism for the guest firmware <b>240</b> to trap into a break vector in host mode of the VMM.</p>
<p id="p-0025" num="0024">In one embodiment, VMM <b>210</b> and guest firmware decide as part of the processor virtualization or initial platform configuration upon break intermediate values chosen from an architecturally reserved range. Accordingly, in response to detection of a break instruction, VMM <b>210</b> can check the break intermediate values to identify if the software break is a guest request for firmware runtime services. In an alternative embodiment, an instruction is provided that can change the processor virtualization mode between a guest and host mode without taking any interruption. Accordingly, in one embodiment, guest firmware <b>240</b> can use this instruction to implement mechanism to transition to host mode efficiently without VMM interception.</p>
<p id="p-0026" num="0025">Representatively, the above-described features can be used to implement guest EFI <b>242</b>, guest PAL <b>246</b> and guest SAL <b>244</b>. For example, in one embodiment, PAL procedures to provide processor information; e.g., PAL_VM_SUMMARY or PAL_CACHE_INFO, guest PAL <b>246</b> can use the static cooperation method by retrieving processor information directly from HOB data structure <b>250</b> in response to requests issued by guest OS <b>230</b>. Conversely, other PAL procedures that need VMM access to host PAL <b>146</b> during runtime (See, <figref idref="DRAWINGS">FIG. 1</figref>), such as, for example, PAL_HALT_LIGHT in which the VMM must wait until all virtual processors are within the same logical processor before putting the logical processor into a halt state.</p>
<p id="p-0027" num="0026">Accordingly, in one embodiment, guest PAL <b>246</b>, in response to such a host firmware runtime service request, requires initiation of the service request to host platform via VMM <b>210</b>. As described herein, such procedures are referred to as &#x201c;host firmware runtime services&#x201d; which require VMM interception to initiate such requests. Accordingly, requests for host firmware runtime services may be detected by guest firmware <b>240</b> and communicated to VMM <b>210</b>, which is responsible for servicing such request. Other various informational procedures, as well as non-informational procedures may be provided by guest SAL <b>244</b> and guest EFI <b>242</b>, but are not described herein to avoid obscuring embodiments of the invention. However, those skilled in the art should recognize that such additional features may be provided by guest EFI <b>242</b>, guest PAL <b>246</b> and guest SAL <b>244</b> while remaining within the scope of the embodiments described.</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 3</figref> illustrates HOB data structure <b>250</b>, in accordance with one embodiment. In one embodiment, HOB data structure <b>250</b> is a software data structure used to store various VM configuration and virtualization policy information. In one embodiment, as shown in <figref idref="DRAWINGS">FIG. 3</figref>, the HOB structure <b>250</b> is a contiguous memory region with many contiguous HOB entries. In one embodiment, the leading HOB entry <b>251</b> specifies a length of the HOB structure <b>250</b>. In one embodiment, all HOB entries have a type field, as well as a length field, to identify the HOB entry's length. In one embodiment, a 16-byte globally unique identifier (GUID) is used to uniquely identify each type.</p>
<p id="p-0029" num="0028">In one embodiment, each HOB entry will have a data field, but the format inside the data field is HOB type specific. Representatively, HOB data structure <b>250</b> includes leading HOB <b>251</b> followed by memory configuration HOB <b>252</b>. In one embodiment, memory configuration HOB provides the amount of physical memory that has been configured for the VM. HOB data structure <b>250</b> further includes virtual processor addressing HOB <b>253</b>. In one embodiment, HOB entry <b>253</b> defines the maximum physical address line, virtual address line and other like virtual processor addressing. The next HOB entry <b>254</b> may include a virtual processor TLB HOB, which defines the maximum translation register number, region ID line, etc. A next entry <b>254</b> may define a processor or virtual processor cache HOB. As illustrated, a final HOB <b>256</b>, a VMM policy HOB <b>256</b> will define the virtualization policy.</p>
<p id="p-0030" num="0029">In one embodiment, the virtualization policy, as described herein, defines which guest firmware functions may be handled by the guest firmware and which functions shall fall to the host firmware as requested by VMM <b>210</b>. Accordingly, as described, functions that may be performed by the guest firmware <b>240</b> will be described within HOB entry <b>226</b>. Accordingly, upon receipt of HOB entry <b>226</b>, the guest firmware <b>240</b> may be configured as indicated. Although described with the various HOB entries illustrated in <figref idref="DRAWINGS">FIG. 3</figref>, those skilled in the art should recognize that the various entries do not provide an exhaustive list of all possible entries within HOB <b>250</b> and may be added to or modified, as desired by the various configuration, while remaining within the scope of the described embodiments.</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 4</figref> is a flowchart illustrating a method <b>300</b> for providing cooperative guest firmware, in accordance with one embodiment. At process block <b>310</b>, the VMM initially creates the HOB data structure to contain the VM configuration information and a virtualization policy. Following such creation, at process block <b>320</b>, the VMM will launch the VM to include at least guest firmware, as well as the guest OS. Once launched, the guest firmware will determine whether a guest firmware service is called by the guest OS. In response to such a service request, the guest firmware will search the HOBs for requested information.</p>
<p id="p-0032" num="0031">Accordingly, if static information regarding the processor and platform configuration information is requested by the guest operating system, at process block <b>342</b>, such information is found within the HOB and at process block <b>344</b>, the guest firmware behaves according to the information in the HOB and returns control to the caller. However, if the request is a request for host firmware runtime services, at process block <b>350</b>, the guest firmware initiate a service request to VMM. At process block <b>360</b>, the VMM determines whether a request is received from the guest firmware. Once received, the VMM authenticates the guest firmware service request to verify that the service request is authentic. Once authenticated, at process block <b>380</b>, the VMM services the guest firmware request.</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 5</figref> is a block diagram illustrating a computer system <b>400</b> in which the cooperative guest firmware, as described in the embodiments herein, may be implemented. Initially, the guest firmware <b>240</b>, the guest OS <b>230</b>, the VMM <b>210</b> and other like components are stored within the hard disk or disk memory <b>474</b>, as shown in the computer system <b>400</b> of <figref idref="DRAWINGS">FIG. 5</figref>. Likewise, the host firmware, including EFI <b>142</b>, PAL <b>146</b> and SAL <b>144</b>, are initially stored in non-volatile memory <b>480</b>. Accordingly, the guest firmware <b>240</b> is initially stored on hard disk <b>474</b>. In operation, the VMM <b>210</b> will load the guest firmware <b>240</b> from the hard disk <b>474</b> and copy the guest firmware <b>240</b> into a well-defined location, such as a predetermined VMM block of memory.</p>
<p id="p-0034" num="0033">In one embodiment, a region of memory is reserved for the guest firmware. In one embodiment, the reserved range may be a 16 megabyte (MB) region to contain the guest firmware image and other configuration data. Representatively, the VMM <b>210</b> will prepare VM configuration in an HOB data format to include the physical memory size, address space, PAL information, SAL information, EFI information and the like and place the VM configuration in the VM block. The VMM will then copy the guest firmware image from the host hard disk into the defined area in the VMM block. In one embodiment, the firmware will provide a mapping of the guest firmware image and various components into a predetermined guest physical address space.</p>
<p id="p-0035" num="0034">Representatively, computer system <b>400</b> may be, for example, a personal computer system. Computer system <b>400</b> may include one or more processors (e.g., processor <b>460</b>), a memory controller <b>465</b>, an input/output (I/O) controller <b>470</b>, and one or more BIOS memories (e.g., BIOS memory <b>480</b>). In one embodiment, processor <b>460</b>, memory controller <b>465</b>, I/O controller <b>470</b> and BIOS memory <b>480</b> may reside on a motherboard <b>461</b>. In an alternative embodiment, one or more of processor <b>460</b>, memory controller <b>465</b>, I/O controller <b>470</b> and BIOS memory <b>480</b> may reside on other types of component boards, for example, a daughter board.</p>
<p id="p-0036" num="0035">The memory controller <b>465</b> controls operations between processor <b>460</b> and a memory device <b>464</b>, for example, computer-readable storage medium, such as a random access memory (RAM). The I/O controller <b>470</b> may control operations between processor <b>460</b> and one or more input/output (I/O) devices <b>475</b>, for examples, a keyboard and a mouse over a low pin count (LPC) bus <b>471</b>. The I/O controller <b>470</b> may also control operations between processor <b>460</b> and peripheral devices, for example, a drive <b>474</b> coupled to I/O controller via an integrated drive electronics (IDE) interface <b>477</b>. Additional buses may also be coupled to I/O controller <b>470</b> for controlling other devices, for examples, a peripheral component interconnect (PCI) bus <b>472</b>, or follow on bus (e.g., PCIx, PCI Express) and a universal serial bus (USB) <b>476</b>. In one embodiment, the memory controller <b>465</b> and the I/O controller <b>470</b> may be integrated into a single component.</p>
<p id="p-0037" num="0036">In the embodiment illustrated, a driver controller <b>473</b> may be coupled to PCI bus <b>472</b> and may control operations of hard disk drive <b>474</b>. In one embodiment, guest firmware <b>240</b>, including guest EFI <b>242</b>, guest SAL <b>244</b>, guest PAL <b>246</b>, guest OS <b>230</b> and VMM <b>210</b>, may be stored on the hard disk drive <b>474</b>. In this manner, the hard disk drive may serve as the boot-up device including, for example, a loader program to load the various host components as well as the VMM <b>210</b> to load the VM as well as the various guest components, including guest firmware and a guest OS within the VMM.</p>
<p id="p-0038" num="0037">BIOS memory <b>480</b> may be coupled to I/O controller <b>470</b> via bus <b>466</b>. BIOS memory <b>480</b> is a non-volatile programmable memory, for example, a flash memory that retains the contents of data stored within it even after power is no longer supplied. Alternatively, BIOS memory <b>480</b> may be other types of programmable memory devices, for examples, a programmable read only memory (PROM) and an erasable programmable read only memory (EPROM) or other like computer-readable storage mediums. Computer system <b>400</b> may also include other BIOS memories in addition to BIOS memory <b>480</b>.</p>
<p id="p-0039" num="0038">Accordingly, as shown in <figref idref="DRAWINGS">FIG. 5</figref>, BIOS memory <b>480</b> may include host platform firmware for initializing the computer system following system reset. As described herein, the host firmware includes EFI <b>142</b>, SAL <b>144</b> and PAL <b>146</b>. Accordingly, as described herein the guest firmware <b>240</b> is loaded during boot-up of computer system <b>400</b> to provide a host platform. Following the boot-up, the host platform will load a VMM, which is responsible for loading the guest firmware <b>240</b>, guest software and other like components from hard disk <b>474</b>.</p>
<heading id="h-0005" level="1">ALTERNATE EMBODIMENTS</heading>
<p id="p-0040" num="0039">It will be appreciated that, for other embodiments, a different system configuration may be used. For example, while the system <b>400</b> includes a single CPU <b>460</b>, for other embodiments, a multiprocessor system (where one or more processors may be similar in configuration and operation to the CPU <b>460</b> described above) may benefit from the cooperative guest firmware of various embodiments. Further different type of system or different type of computer system such as, for example, a server, a workstation, a desktop computer system, a gaming system, an embedded computer system, a blade server, etc., may be used for other embodiments.</p>
<p id="p-0041" num="0040">Having disclosed embodiments and the best mode, modifications and variations may be made to the disclosed embodiments while remaining within the scope of the embodiments as defined by the following claims.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method comprising:
<claim-text>launching a virtual machine (VM), on a host platform computer, using a virtual machine monitor (VMM) running on the host platform computer, the VM to have at least a guest operating system (OS) and a guest firmware;</claim-text>
<claim-text>providing a static interface and a dynamic interface for a communication between the guest firmware and the VMM, the static interface to provide information including configuration information of the host platform computer to the guest firmware, the dynamic interface to allow the guest firmware to dynamically issue service requests to the VMM to access host platform computer services;</claim-text>
<claim-text>generating a data structure, upon launching the VM, in a memory associated with the guest firmware, the data structure to act as the static interface to provide the configuration information, including processor and platform configuration information, to the guest firmware, by:
<claim-text>defining the processor and platform configuration information for the VM;</claim-text>
<claim-text>defining a virtualization policy for the VM;</claim-text>
<claim-text>creating the data structure in the memory according to the virtualization policy, and the processor and platform configuration information; and</claim-text>
<claim-text>passing the data structure to the guest firmware upon creation of the VM by passing a memory reference to the guest firmware within the VM to enable the guest firmware to access the configuration information and the virtualization policy within the data structure;</claim-text>
</claim-text>
<claim-text>receiving a request from the guest firmware for the host platform computer services via the dynamic interface; and</claim-text>
<claim-text>in response to receiving the request for the host platform computer services, the VMM:
<claim-text>changing a processor virtualization mode from a guest mode to a host mode without interruption of the VMM, the host mode providing an access to the host platform computer services;</claim-text>
<claim-text>requesting, in the host mode, the host platform computer services from the host platform computer; and</claim-text>
<claim-text>servicing the request from the guest firmware for the host platform computer services.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein servicing the guest firmware requests further comprises:
<claim-text>receiving the guest firmware requests from one of a guest extensible firmware interface (EFI) firmware module, a guest processor abstraction layer (PAL) firmware module and a guest system abstraction layer (SAL) firmware module in the guest firmware; and</claim-text>
<claim-text>requesting a host firmware runtime service from one of a host EFI firmware module, a host PAL firmware module and a host SAL firmware module in a host firmware.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. An article of manufacture having a non-transitory computer-readable storage medium including associated instructions, wherein the instructions, when executed, on a machine comprising at least one component performing:
<claim-text>generating a data structure in memory including configuration information of a virtual machine (VM) and a virtualization policy, by:
<claim-text>defining the processor and platform configuration information for the VM;</claim-text>
<claim-text>defining a virtualization policy for the VM;</claim-text>
<claim-text>creating the data structure in the memory according to the virtualization policy, and the processor and platform configuration information; and</claim-text>
<claim-text>passing the data structure to the guest firmware upon creation of the VM;</claim-text>
</claim-text>
<claim-text>passing a memory reference to a guest firmware within the VM to enable the guest firmware to access the configuration information and the virtualization policy within the data structure;</claim-text>
<claim-text>launching the VM, on a host platform computer, using a virtual machine monitor (VMM) running on the host platform computer, the VM to have at least a guest operating system (OS) and the guest firmware;</claim-text>
<claim-text>providing a static interface and a dynamic interface for a communication between the guest firmware and the VMM, wherein the data structure acts as the static interface to provide information including configuration information of the host platform computer to the guest firmware, the dynamic interface to allow the guest firmware to dynamically issue service requests to the VMM to access host platform computer services;</claim-text>
<claim-text>receiving a request from the guest firmware for the host platform computer services via the dynamic interface; and</claim-text>
<claim-text>in response to receiving the request for the host platform computer services,
<claim-text>changing a processor virtualization mode from a guest mode to a host mode without interruption of the VMM, the host mode providing an access to the host platform computer services,</claim-text>
<claim-text>requesting, in the host mode, the host platform computer services from the host platform computer, and</claim-text>
<claim-text>servicing the request from the guest firmware for the host platform computer services.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The article of manufacture of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein servicing the request further comprises:
<claim-text>receiving the request from one of a guest extensible firmware interface (EFI) firmware module, a guest processor abstraction layer (PAL) firmware module and a guest system abstraction layer (SAL) firmware module in the guest firmware; and</claim-text>
<claim-text>requesting a host firmware runtime service from one of a host EFI firmware module, a host PAL firmware module and a host SAL firmware module in a host firmware.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The article of manufacture of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein servicing the request further comprises:
<claim-text>detecting the request received from the guest firmware;</claim-text>
<claim-text>authenticating the request as a guest firmware service request; and</claim-text>
<claim-text>servicing the request for host firmware runtime services.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. A system comprising:
<claim-text>a host platform computer;</claim-text>
<claim-text>a virtual machine monitor (VMM) running on the host platform computer;</claim-text>
<claim-text>a virtual machine (VM) launched on the host platform computer by the VMM, the VM having at least a guest operating system (OS) and a guest firmware, wherein the guest firmware communicating with the VMM via a static interface, a dynamic interface or a combination of both;</claim-text>
<claim-text>the static interface to provide information including configuration information of the host platform computer to the guest firmware;</claim-text>
<claim-text>the dynamic interface to allow the guest firmware to dynamically issue service requests to the VMM to access host platform computer services;</claim-text>
<claim-text>the guest firmware to search a data structure received from the VMM according to a guest firmware service request received from the guest OS for configuration information and to initiate a service request, via the dynamic interface, to the VMM if the guest firmware service request is for a host firmware runtime service;</claim-text>
<claim-text>the data structure generated in a memory associated with the guest firmware, wherein the data structure acts as the static interface to provide the configuration information, including processor and platform configuration information, to the guest firmware by:</claim-text>
<claim-text>defining the processor and platform configuration information for the VM;
<claim-text>defining a virtualization policy for the VM;</claim-text>
<claim-text>creating the data structure in the memory according to the virtualization policy, and the processor and platform configuration information; and</claim-text>
<claim-text>passing the data structure to the guest firmware upon creation of the VM by passing a memory reference to the guest firmware within the VM to enable the guest firmware to access the configuration information and the virtualization policy within the data structure;</claim-text>
</claim-text>
<claim-text>wherein the guest firmware is to issue an instruction to change a processor instruction state from a guest mode to a host mode to request, in the host mode, the host firmware runtime service from the host platform computer, the host mode providing an access to the host firmware runtime service.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The system of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the VMM is to generate the data structure in memory associated with the guest firmware to provide a virtualization policy, processor and platform information to the guest firmware, and wherein the guest firmware is to use the data structure to respond to requests received from the guest OS for static configuration information and to service the guest firmware service request for the host firmware service.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The system of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the guest firmware is to issue a break instruction to the VMM, the break instruction including a value to indicate the guest firmware service request for the host firmware runtime service.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The system of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the guest firmware is further to analyze the virtualization policy to identify guest firmware functions to be performed by the guest firmware, and to analyze the virtualization policy to identify host firmware functions to be performed by host firmware.</claim-text>
</claim>
</claims>
</us-patent-grant>
