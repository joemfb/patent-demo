<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08626483-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08626483</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13271117</doc-number>
<date>20111011</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<us-term-of-grant>
<disclaimer>
<text>This patent is subject to a terminal disclaimer.</text>
</disclaimer>
</us-term-of-grant>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>17</main-group>
<subgroup>50</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>1</main-group>
<subgroup>04</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>703 19</main-classification>
<further-classification>713375</further-classification>
</classification-national>
<invention-title id="d2e51">Efficient clock models and their use in simulation</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>4899273</doc-number>
<kind>A</kind>
<name>Omoda et al.</name>
<date>19900200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>703 14</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>6014512</doc-number>
<kind>A</kind>
<name>Mohamed et al.</name>
<date>20000100</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6058492</doc-number>
<kind>A</kind>
<name>Sample et al.</name>
<date>20000500</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6152612</doc-number>
<kind>A</kind>
<name>Liao et al.</name>
<date>20001100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>703 23</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>6292765</doc-number>
<kind>B1</kind>
<name>Ho et al.</name>
<date>20010900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>6625572</doc-number>
<kind>B1</kind>
<name>Zemlyak et al.</name>
<date>20030900</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>6789219</doc-number>
<kind>B2</kind>
<name>Hapke et al.</name>
<date>20040900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714732</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>6996747</doc-number>
<kind>B2</kind>
<name>Swoboda et al.</name>
<date>20060200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714 30</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>7483825</doc-number>
<kind>B2</kind>
<name>Van Huben et al.</name>
<date>20090100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>703 16</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>8311781</doc-number>
<kind>B2</kind>
<name>Greenberg et al.</name>
<date>20121100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>703  2</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2002/0069027</doc-number>
<kind>A1</kind>
<name>Hapke</name>
<date>20020600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>702117</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00012">
<document-id>
<country>US</country>
<doc-number>2003/0171908</doc-number>
<kind>A1</kind>
<name>Schilp et al.</name>
<date>20030900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>703 16</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00013">
<document-id>
<country>US</country>
<doc-number>2004/0130558</doc-number>
<kind>A1</kind>
<name>MacInnis et al.</name>
<date>20040700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>345629</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00014">
<document-id>
<country>KR</country>
<doc-number>1998-0032143</doc-number>
<kind>A</kind>
<date>19980700</date>
</document-id>
</patcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00015">
<othercit>Liao et al., &#x201c;An efficient implementation of reactivity for modeling hardware in the Scenic design environment&#x201d;, '97, Proceedings of the 34th annual DAC, pp. 70-75.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
<us-citation>
<nplcit num="00016">
<othercit>PCT International Search Report and Written Opinion, PCT Application No. PCT/US2006/006542, Jul. 21, 2006, 7 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
<us-citation>
<nplcit num="00017">
<othercit>PCT International Preliminary Report on Patentability, PCT Application No. PCT/US2006/006542, Sep. 11, 2007, 5 pages.</othercit>
</nplcit>
<category>cited by applicant</category>
</us-citation>
</us-references-cited>
<number-of-claims>17</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>703 19</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>713375</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>709248</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>5</number-of-drawing-sheets>
<number-of-figures>5</number-of-figures>
</figures>
<us-related-documents>
<continuation>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>11069616</doc-number>
<date>20050228</date>
</document-id>
<parent-grant-document>
<document-id>
<country>US</country>
<doc-number>8036873</doc-number>
</document-id>
</parent-grant-document>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>13271117</doc-number>
</document-id>
</child-doc>
</relation>
</continuation>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20120101798</doc-number>
<kind>A1</kind>
<date>20120426</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Vermeersch</last-name>
<first-name>Dirk</first-name>
<address>
<city>San Jose</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
<us-applicant sequence="002" app-type="applicant" designation="us-only">
<addressbook>
<last-name>Rompay</last-name>
<first-name>Karl Van</first-name>
<address>
<city>Nieuwpoort</city>
<country>BE</country>
</address>
</addressbook>
<residence>
<country>BE</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Vermeersch</last-name>
<first-name>Dirk</first-name>
<address>
<city>San Jose</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Rompay</last-name>
<first-name>Karl Van</first-name>
<address>
<city>Nieuwpoort</city>
<country>BE</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Fenwick &#x26; West LLP</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Synopsys, Inc.</orgname>
<role>02</role>
<address>
<city>Mountain View</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Shah</last-name>
<first-name>Kamini S</first-name>
<department>2123</department>
</primary-examiner>
<assistant-examiner>
<last-name>Ochoa</last-name>
<first-name>Juan</first-name>
</assistant-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Methods simulating a system of devices are described. A model that simulates the system is executed. The system model includes a plurality of modules. A clock object for a module can be disabled when it is not needed or not being used.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="213.44mm" wi="165.78mm" file="US08626483-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="222.67mm" wi="183.30mm" orientation="landscape" file="US08626483-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="225.55mm" wi="186.52mm" file="US08626483-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="195.07mm" wi="141.48mm" file="US08626483-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="234.53mm" wi="198.63mm" file="US08626483-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="235.20mm" wi="176.87mm" file="US08626483-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">RELATED U.S. APPLICATION</heading>
<p id="p-0002" num="0001">This application is a continuation of U.S. patent application Ser. No. 11/069,616, filed Feb. 28, 2005, entitled &#x201c;Efficient Clock Models and Their Use in Simulation,&#x201d; by D. Vermeersch et al., now U.S. Pat. No. 8,036,873, incorporated by reference in its entirety.</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0003" num="0002">1. Field of the Invention</p>
<p id="p-0004" num="0003">Embodiments in accordance with the present invention generally pertain to electronic design automation. In particular, embodiments in accordance with the present invention pertain to simulation models used for system-level modeling.</p>
<p id="p-0005" num="0004">2. Related Art</p>
<p id="p-0006" num="0005">A system on a chip (SOC) may be relatively large and complex, incorporating multiple processors as well as other devices that support display, memory and keypad capabilities. System-level models are used to simulate systems such as SOCs during the design process (e.g., before they are implemented in hardware). Using system-level simulation, software that will run on systems such as SOCs can be designed and tested in parallel with the hardware design.</p>
<p id="p-0007" num="0006">The computational complexity of system-level simulation models means that the simulation runs slower relative to the speed of execution of an actual hardware platform. Increasing the speed of simulation is one of the goals of model designers.</p>
<p id="p-0008" num="0007">In simulation, clocks are normally modeled as modules that update a signal based on the clock's properties (e.g., period and duty cycle). This can mean that a clock model will generate an event for the falling edge and rising edge of the clock being modeled. For example, in SystemC coding:</p>
<p id="p-0009" num="0008">
<tables id="TABLE-US-00001" num="00001">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>void clock_gen( ) {</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="70pt" align="left"/>
<colspec colname="1" colwidth="147pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>While (true) {</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="84pt" align="left"/>
<colspec colname="1" colwidth="133pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>clk = true;</entry>
</row>
<row>
<entry/>
<entry>wait(negedge_time);</entry>
</row>
<row>
<entry/>
<entry>clk = false;</entry>
</row>
<row>
<entry/>
<entry>wait(posedge_time);</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="70pt" align="left"/>
<colspec colname="1" colwidth="147pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>}</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>}</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0010" num="0009">According to the above, the simulation kernel will have activity for every event. Even if the clock is the only module in the system, the maximum simulation speed (in cycles per second) is limited by how fast the kernel can schedule and run the clock process.</p>
<p id="p-0011" num="0010">Higher performance modeling can be achieved by not using a clock object and letting the simulation advance in steps larger than one clock tick. That is, instead of running the simulation at every clock cycle or edge, larger time steps can be used. For example:</p>
<p id="p-0012" num="0011">
<tables id="TABLE-US-00002" num="00002">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<thead>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry>void process( ) {//process sensitive to some start of transaction</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="56pt" align="left"/>
<colspec colname="1" colwidth="161pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>event</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="217pt" align="left"/>
<tbody valign="top">
<row>
<entry>...</entry>
</row>
<row>
<entry>// wait for one clock</entry>
</row>
<row>
<entry>wait(10,SC_NS); //no clock port, wait based on time (10 nanoseconds)</entry>
</row>
<row>
<entry>...</entry>
</row>
<row>
<entry>}</entry>
</row>
<row>
<entry namest="1" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0013" num="0012">While larger time steps can accelerate execution of the simulation, this is balanced by a loss of accuracy. Developers of new products (software or hardware) are interested in seeing simulation results that are as realistic as can be reasonably expected, and so a loss of accuracy may not be tolerable. To achieve the desired accuracy, some devices in a system such as an SOC may be simulated using smaller time steps. Consequently, the simulation will proceed more slowly, because the speed of the system simulation will be limited by the slowest of the device simulations.</p>
<heading id="h-0003" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0014" num="0013">Accordingly, a method and/or system for improving the performance of system-level simulation models would be advantageous. In particular, a simulation that can be performed more quickly and with more accuracy than conventionally possible would be advantageous. Embodiments in accordance with the present invention provide this and other advantages.</p>
<p id="p-0015" num="0014">Embodiments in accordance with the present invention pertain to a system-level simulation model that includes clock objects that can be disabled when they are not being used during simulation. More specifically, a clock object is built that automatically turns itself off or on based on whether any of the simulation processes is sensitive to the clock object. In one embodiment, a clock object can determine from the simulation whether it should be enabled or disabled. Alternatively, a user can indicate whether certain simulation processes are sensitive to a clock and for how long.</p>
<p id="p-0016" num="0015">According to embodiments of the present invention, a first device model in a system of devices can be simulated using time steps of one length (e.g., larger time steps), and a second device model in that system can be simulated using time steps of another (e.g., shorter) length. The second device model may be used to simulate a new hardware device, or to simulate execution of a new software application on a particular device&#x2014;generally speaking, the second device model is used when greater simulation accuracy is desired for a particular device in a system of devices. During times that the second device model is active during simulation, the system-level model executes using shorter time steps, but during times that the second device model is not active during simulation, the clock object for the second device model is disabled and the system-level model executes using larger time steps. Thus, higher accuracy can be achieved using the second device model, but overall performance of the system-level model is only affected when the second device model is active. Thus, the simulation model can be executed more quickly and with greater accuracy than conventional models.</p>
<p id="p-0017" num="0016">There are other advantages associated with embodiments in accordance with the present invention. For example, the design of timer models is facilitated, and modeling with the present invention clock objects is a modeling style readily adoptable by designers. These and other objects and advantages of the present invention will be recognized by one skilled in the art after having read the following detailed description, which are illustrated in the various drawing figures.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0018" num="0017">The accompanying drawings, which are incorporated in and form a part of this specification, illustrate embodiments of the invention and, together with the description, serve to explain the principles of the invention:</p>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram of a device upon which embodiments of the present invention can be implemented.</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram of a simulation model according to one embodiment of the present invention.</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 3</figref> is a block diagram of a clock object used in a simulation model according to one embodiment of the present invention.</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 4</figref> is a state diagram of a clock object according to one embodiment of the present invention.</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 5</figref> is a flowchart of a computer-implemented method for simulating a system of devices according to one embodiment of the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0005" level="1">DETAILED DESCRIPTION OF THE INVENTION</heading>
<p id="p-0024" num="0023">In the following detailed description of the present invention, numerous specific details are set forth in order to provide a thorough understanding of the present invention. However, it will be recognized by one skilled in the art that the present invention may be practiced without these specific details or with equivalents thereof. In other instances, well-known methods, procedures, components, and circuits have not been described in detail as not to unnecessarily obscure aspects of the present invention.</p>
<p id="p-0025" num="0024">Some portions of the detailed descriptions, which follow, are presented in terms of procedures, steps, logic blocks, processing, and other symbolic representations of operations on data bits that can be performed on computer memory. These descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. A procedure, computer executed step, logic block, process, etc., is here, and generally, conceived to be a self-consistent sequence of steps or instructions leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated in a computer system. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.</p>
<p id="p-0026" num="0025">It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussions, it is appreciated that throughout the present invention, discussions utilizing terms such as &#x201c;executing&#x201d; or &#x201c;disabling&#x201d; or &#x201c;enabling&#x201d; or &#x201c;monitoring&#x201d; or &#x201c;receiving&#x201d; or &#x201c;maintaining&#x201d; or the like, refer to the actions and processes of a computer system (e.g., flowchart <b>500</b> of <figref idref="DRAWINGS">FIG. 5</figref>), or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission or display devices.</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 1</figref> is a block diagram of a device <b>100</b> upon which embodiments of the present invention can be implemented. In general, device <b>100</b> comprises bus <b>110</b> for communicating information, processor <b>101</b> coupled with bus <b>110</b> for processing information and instructions, random access (volatile) memory <b>102</b> coupled with bus <b>110</b> for storing information and instructions for processor <b>101</b>, read-only (non-volatile) memory <b>103</b> coupled with bus <b>110</b> for storing static information and instructions for processor <b>101</b>, data storage device <b>104</b> such as a magnetic or optical disk and disk drive coupled with bus <b>110</b> for storing information and instructions, an optional user output device such as display device <b>105</b> coupled to bus <b>110</b> for displaying information to the computer user, an optional user input device such as alphanumeric input device <b>106</b> including alphanumeric and function keys coupled to bus <b>110</b> for communicating information and command selections to processor <b>101</b>, and an optional user input device such as cursor control device <b>107</b> coupled to bus <b>110</b> for communicating user input information and command selections to processor <b>101</b>.</p>
<p id="p-0028" num="0027">Display device <b>105</b> utilized with device <b>100</b> may be a liquid crystal device, cathode ray tube, or other display device suitable for creating graphic images and alphanumeric characters recognizable to the user. Cursor control device <b>107</b> allows a user to dynamically signal the two-dimensional movement of a visible symbol (pointer) on a display screen of display device <b>105</b>.</p>
<p id="p-0029" num="0028">Embodiments in accordance with the present invention are described primarily in the context of SystemC. However, features of the present invention are well suited for use in simulation models based on a hardware description language (HDL) such as VeriLog or Very High Speed Integrated Circuit (VHSIC) Hardware Description Language (VHDL).</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 2</figref> is a block diagram of a simulation model <b>200</b> according to one embodiment of the present invention. In the example of <figref idref="DRAWINGS">FIG. 2</figref>, the model <b>200</b> includes class libraries <b>202</b>, a simulation kernel <b>204</b> and a number of user modules <b>206</b><i>a</i>, <b>206</b><i>b</i>, . . . , <b>206</b><i>n</i>. A system-level simulation model can include elements in addition to those shown in <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0031" num="0030">In the present embodiment, modeling constructs in model <b>200</b> are provided as C++ class libraries <b>202</b>. Simulation kernel <b>204</b> is, in one example, computer-implemented code that models the passing of time and calls processes to calculate their outputs whenever their inputs change.</p>
<p id="p-0032" num="0031">In one embodiment, simulation model <b>200</b> is a system-level design tool. System-level modeling includes modeling of systems above the RTL (Register Transfer Level) of abstraction, including systems that may be implemented in hardware or software or some combination of hardware and software. System-level design tools are used for modeling relatively large and complex systems such as systems on chips (SOCs). To model such systems, simulation model <b>200</b> utilizes a structural design hierarchy that is built using &#x201c;modules&#x201d; (e.g., user modules <b>206</b><i>a</i>, <b>206</b><i>b</i>, . . . , <b>206</b><i>n</i>). In essence, modules <b>206</b><i>a</i>, <b>206</b><i>b</i>, . . . , <b>206</b><i>n </i>allow pieces of a design to be worked on separately. One user module may represent a central processing unit (CPU), another may represent a digital signal processor (DSP), yet another may represent a peripheral device (e.g., a keyboard, a memory device, a display device, etc.), and so on.</p>
<p id="p-0033" num="0032">Modules <b>206</b><i>a</i>, <b>206</b><i>b</i>, . . . , <b>206</b><i>n </i>may contain &#x201c;processes&#x201d; and instances of other modules. Data is communicated between modules using &#x201c;ports&#x201d; and &#x201c;channels.&#x201d;</p>
<p id="p-0034" num="0033">A process is, in one example, an independent thread of control which resumes execution when some set of &#x201c;events&#x201d; occur or some signals change, and then suspends execution after performing some action. In one embodiment, a &#x201c;wait( )&#x201d; call is used to achieve this suspension. A wait( ) call suspends execution of a thread. The argument or arguments passed to the wait( ) call determine when execution of the thread is resumed.</p>
<p id="p-0035" num="0034">A port is an object through which a module can access a channel's interface. A channel is an object that serves as a container for communication and synchronization. Processes are contained in the modules <b>206</b><i>a</i>, <b>206</b><i>b</i>, . . . , <b>206</b><i>n </i>and access external channels through the ports of a module. Channels implement one or more &#x201c;interfaces.&#x201d; An interface specifies a set of access methods to be implemented within a channel.</p>
<p id="p-0036" num="0035">An &#x201c;event&#x201d; is a low-level synchronization primitive that is used to construct other forms of synchronization. A process can be &#x201c;sensitive&#x201d; to a set of events. The &#x201c;sensitivity&#x201d; of a process defines when the process will be resumed or activated; sensitivity is analogous to an activating condition. When a specified event (or events) is triggered, an associated process is resumed or activated.</p>
<p id="p-0037" num="0036">In one embodiment, sensitivity may be &#x201c;static&#x201d; or &#x201c;dynamic.&#x201d; Prior to the start of the simulation, statically sensitive processes are made sensitive to a fixed set of signals, which cannot be changed once simulation has started. Static sensitivity is supported with a &#x201c;sensitivity list&#x201d; for each process in a module.</p>
<p id="p-0038" num="0037">The sensitivity (activating condition) of a dynamically sensitive process can be altered during simulation. In one embodiment, the arguments of the wait( ) call are used to specify the events and signals to which a process is dynamically sensitive. As a process executes, using a wait( ) call, the process can dynamically select the set of events that will cause the process to resume after it has been suspended. Alternatively, instead of waiting on an event or events, a process can wait for a specified amount of time.</p>
<p id="p-0039" num="0038">A process with static sensitivity can become dynamically sensitive using a wait( ) call with arguments. A process that is dynamically sensitive can become statically sensitive using a wait( ) call without arguments.</p>
<p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. 3</figref> is a block diagram of a clock object used in a simulation model <b>25</b> according to one embodiment of the present invention. In the example of <figref idref="DRAWINGS">FIG. 3</figref>, a first clock object <b>302</b> is associated with user module <b>206</b><i>a </i>and a second clock object <b>304</b> is associated with user module <b>206</b><i>b</i>. Although in the example of <figref idref="DRAWINGS">FIG. 3</figref> there is one clock object per module, the present invention is not so limited. For example, a single clock object can be associated with more than one module.</p>
<p id="p-0041" num="0040">According to embodiments of the present invention, the clock objects <b>302</b> and <b>304</b> can be enabled and disabled depending on whether any processes in the respective user modules are sensitive to it. For example, user module <b>206</b><i>b </i>may be associated with a device (e.g., a peripheral device) for which a greater degree of accuracy is desired during simulation. Accordingly, clock object <b>304</b> (associated with user module <b>206</b><i>b</i>) will have a longer clock period than clock object <b>302</b>. That is, clock object <b>304</b> will advance fewer clock cycles at a time than clock object <b>302</b>. Put yet another way, clock object <b>304</b> implements shorter time steps during simulation than does clock object <b>302</b>. When at least one process of user module <b>206</b><i>b </i>is sensitive to clock object <b>304</b>, then clock object <b>15</b> <b>304</b> is enabled so that the device associated with user module <b>206</b><i>b </i>is simulated with the desired level of accuracy. When no processes of user module <b>206</b><i>b </i>are sensitive to clock object <b>304</b>, then clock object <b>304</b> can be disabled. Accordingly, the simulation model can execute more quickly. That is, the speed of the simulation is limited by clock object <b>304</b> when that clock object is enabled.</p>
<p id="p-0042" num="0041">In one embodiment, a wait( ) call is used to indicate whether or not a process is sensitive to a clock object. In a wait(clk) call associated with a thread, a clock signal is one of the arguments that determines when that thread can resume execution. According to one embodiment of the present invention, using a wait(clk) call, a clock object becomes aware that a process is sensitive to the clock object. The absence of such a wait call serves to automatically inform the clock object that the process is not (or is no longer) sensitive to the clock object.</p>
<p id="p-0043" num="0042">For example, assume that, for simulation purposes, user module <b>206</b><i>a </i>is associated with a CPU and clock object <b>302</b> advances 100 cycles at time, while user module <b>206</b><i>b </i>is associated with a peripheral device and clock object <b>304</b> advances 10 cycles at a time. While clock object <b>304</b> is enabled, the simulation advances 10 cycles at a time, but while clock object <b>304</b> is disabled, the simulation advances 100 cycles at a time. By disabling clock object <b>304</b> when it is not needed, the simulation can be advanced more quickly. When clock object <b>304</b> is enabled, the simulation advances more slowly, but with greater accuracy.</p>
<p id="p-0044" num="0043">Continuing with the example above, a model of a CPU can be expressed as follows:</p>
<p id="p-0045" num="0044">
<tables id="TABLE-US-00003" num="00003">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>void process( ){</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>while (true){</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>//process as many cycles as possible until, for example, a</entry>
</row>
<row>
<entry/>
<entry>&#x2002;maximum time or shared memory access is reached</entry>
</row>
<row>
<entry/>
<entry>...</entry>
</row>
<row>
<entry/>
<entry>//block for the number of cycles consumed</entry>
</row>
<row>
<entry/>
<entry>wait(n)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>}</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="14pt" align="left"/>
<colspec colname="1" colwidth="203pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>}</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0046" num="0045">A model of a peripheral (addressed by the CPU) can be expressed as follows:</p>
<p id="p-0047" num="0046">
<tables id="TABLE-US-00004" num="00004">
<table frame="none" colsep="0" rowsep="0">
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<thead>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
<entry>void process( ){//sensitive to a clock gate controlled by</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="84pt" align="left"/>
<colspec colname="1" colwidth="133pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>transaction start/finish</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="42pt" align="left"/>
<colspec colname="1" colwidth="175pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>//perform a calculation</entry>
</row>
<row>
<entry/>
<entry>wait(10);//allow 10 cycles for the calculation</entry>
</row>
<row>
<entry/>
<entry>//disable the clock</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="2">
<colspec colname="offset" colwidth="28pt" align="left"/>
<colspec colname="1" colwidth="189pt" align="left"/>
<tbody valign="top">
<row>
<entry/>
<entry>}</entry>
</row>
<row>
<entry/>
<entry namest="offset" nameend="1" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0048" num="0047">In the example above, the simulation kernel <b>204</b> will advance &#x201c;n&#x201d; cycles (n&#x2266;100). If the number of cycles is not limited because a maximum time or shared memory access is reached, for example, then simulation kernel <b>204</b> can advance the entire 100 cycles. If the peripheral gets accessed, then simulation kernel <b>204</b> will advance 10 cycles at a time.</p>
<p id="p-0049" num="0048"><figref idref="DRAWINGS">FIG. 4</figref> is a state diagram of a clock object according to one embodiment of the present invention. In <figref idref="DRAWINGS">FIG. 4</figref>, the &#x201c;optimized&#x201d; state refers to the state in which the clock with the shortest clock period (e.g., clock object <b>304</b> in the example of <figref idref="DRAWINGS">FIG. 3</figref>) is disabled.</p>
<p id="p-0050" num="0049">According to an embodiment of the present invention, a clock object is built with the following functions: enable( ); disable( ); and reset (int n cycles). The enable function is used to enable a clock (and its derived, or children, clocks). The disable function is used to disable a clock. The reset function is equivalent to disable and enable, but after n cycles.</p>
<p id="p-0051" num="0050">According to the embodiment of <figref idref="DRAWINGS">FIG. 4</figref>, a count is made of the number of times the clock is enabled or disabled. Thus, for example, if a clock is disabled two times consecutively, then the clock needs to be enabled two times consecutively before the clock can be enabled.</p>
<p id="p-0052" num="0051">Typically, there are three events associated with a clock: a positive edge (e.g., false to true), a negative edge (e.g., true to false), and a value-changed event. In one embodiment, a clock object will monitor the processes sensitive to those events. The clock object will automatically disable itself when no processes are sensitive to it, and will automatically enable itself if one or more processes are sensitive to it.</p>
<p id="p-0053" num="0052">As mentioned above, in one embodiment, there are two types of sensitivity: static and dynamic. A clock can be associated with both statically-sensitive and dynamically-sensitive processes at the same time. For static sensitivity, the clock object keeps track of how many processes are sensitive to it. In one embodiment, a counter is implemented for statically-sensitive processes that are sensitive to the clock. When a clock-sensitive process is changed from static sensitivity to dynamic sensitivity, the count is decremented; and when a process is changed from dynamic sensitivity to static sensitivity, the count is incremented. When the count is zero, the clock can be disabled if there are no dynamically-sensitive processes associated with the clock.</p>
<p id="p-0054" num="0053">For dynamic sensitivity, the clock object maintains flags for two events: positive edge, and negative edge. That is, for dynamic sensitivity, there is no need for a counter. In one embodiment, a flag for positive edge dynamic sensitivity is set when a process becomes dynamically sensitive to a positive edge event (or to a value-changed event), and a flag for negative edge dynamic sensitivity is set when a process becomes dynamically sensitive to a negative edge event (or to a value-changed event). For dynamic sensitivity, the flags are cleared when the respective event is triggered. For example, the flag for positive edge-sensitive dynamic processes is cleared when a positive edge event of the clock triggers, and the flag for negative edge-sensitive processes is cleared when a negative edge event of the clock triggers.</p>
<p id="p-0055" num="0054"><figref idref="DRAWINGS">FIG. 5</figref> is a flowchart of a computer-implemented method for simulating a system of devices according to one embodiment of the present invention. Although specific steps are disclosed in flowchart <b>500</b>, such steps are exemplary. That is, embodiments of the present invention are well suited to performing various other steps or variations of the steps recited in flowchart <b>500</b>. It is appreciated that the steps in flowchart <b>500</b> may be performed in an order different than presented, and that not all of the steps in flowchart <b>500</b> may be performed. Flowchart <b>500</b> includes processes of the present invention which, in one embodiment, are carried out by a processor under the control of computer-readable and computer-executable instructions. The computer-readable and computer-executable instructions reside, for example, in data storage features such as computer usable volatile memory <b>102</b>, computer usable non-volatile memory <b>103</b>, and/or data storage device <b>104</b> of <figref idref="DRAWINGS">FIG. 1</figref>. The computer-readable and computer-executable instructions are used to control or operate in conjunction with, for example, processor <b>101</b> of <figref idref="DRAWINGS">FIG. 1</figref>.</p>
<p id="p-0056" num="0055">In step <b>510</b> of <figref idref="DRAWINGS">FIG. 5</figref>, in one embodiment, a system model that simulates a system (e.g., model <b>200</b> of <figref idref="DRAWINGS">FIG. 2</figref>) is executed. In one such embodiment, the system model includes a number of modules (e.g., modules <b>206</b><i>a</i>, <b>206</b><i>b</i>, . . . , <b>206</b><i>n </i>of <figref idref="DRAWINGS">FIG. 2</figref>).</p>
<p id="p-0057" num="0056">In step <b>520</b> of <figref idref="DRAWINGS">FIG. 5</figref>, in one embodiment, a clock object for a module that is inactive in the executing simulation is disabled when the clock object is not needed by or being used in an executing simulation.</p>
<p id="p-0058" num="0057">In one embodiment, in step <b>530</b>, processes in a module that are sensitive to the clock object are monitored, and the clock object is disabled when no processes are sensitive to the clock object (e.g., no processes are waiting for a clock event from the clock object).</p>
<p id="p-0059" num="0058">In one embodiment, the system model is compliant with, or substantially compliant with, SystemC (e.g., SystemC 2.0, or a version of SystemC having a higher version number) and as such includes both statically-sensitive processes and dynamically-sensitive processes. In such an embodiment, in step <b>540</b>, a count of statically-sensitive processes is maintained, and the clock object is disabled when the count is zero and when no dynamically-sensitive processes are associated with the clock object.</p>
<p id="p-0060" num="0059">In one embodiment, in step <b>550</b>, a wait( ) call is used to provide an indication that a process in the simulation that is sensitive to the clock object is no longer sensitive to the clock object. That is, a wait(clk) call provides an indication that a process in the module is waiting for a clock event from the clock object; the absence of such a wait call indicates that no processes are sensitive to the clock object.</p>
<p id="p-0061" num="0060">If the disabled clock is a clock that, in the real world, operates at a higher frequency and thus slows simulation speed, then the simulation model can execute more quickly while maintaining the desired level of accuracy for the active modules of the simulation model.</p>
<p id="p-0062" num="0061">In step <b>560</b>, if the user module associated with the disabled clock becomes active, the disabled clock can be enabled. More specifically, if a process that is sensitive to the clock object is waiting for a clock event from the clock object, then the clock object can be enabled.</p>
<p id="p-0063" num="0062">In summary, embodiments in accordance with the present invention can improve the performance of system-level simulation models. A clock that, in the real world, operates at higher frequencies (and thus slows the speed of simulation) can be used when greater accuracy is desired for a particular user module. When that user module is not active, that clock can be disabled, so that the simulation of other user modules can be accomplished in larger time steps. Thus, embodiments in accordance with the present invention balance both speed and accuracy, providing accuracy when desired or needed, and providing speed when permitted.</p>
<p id="p-0064" num="0063">Embodiments of the present invention are thus described. While the present invention has been described in particular embodiments, it should be appreciated that the present invention should not be construed as limited by such embodiments, but rather construed according to the below claims.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A computer-implemented method comprising:
<claim-text>executing a simulation model comprising a first software module, and a second software module, the second software module configured to run using a second software clock, and the first software module configured to run using a first software clock or the second software clock, the first software clock advancing a simulation at a faster rate relative to the second software clock;</claim-text>
<claim-text>during the simulation, either:
<claim-text>driving both the first software module and the second software module with the second software clock in response to the first software module being active and the second software module being active; or</claim-text>
<claim-text>driving the second software module with the second software clock in response to the first software module being inactive and the second software module being active; and</claim-text>
</claim-text>
<claim-text>disabling the second software clock and using the first software clock to drive the first software module in response to the first software module being active and the second software module being inactive.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising monitoring processes in the simulation that are sensitive to the second software clock, the second software clock disabled when no processes are sensitive to the second software clock.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising receiving an indication that a process in the simulation that is sensitive to the second software clock is no longer sensitive to the second software clock.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising enabling the second software clock object for the second software module in response to the second software module becoming active.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising receiving an indication that a process in the simulation is waiting for a clock event from the second software clock.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the simulation model is constructed in a language compliant with SystemC and comprises statically-sensitive processes and dynamically-sensitive processes, wherein the method further comprises:
<claim-text>maintaining a count of statically-sensitive processes; and</claim-text>
<claim-text>disabling the second software clock when the count is zero and no dynamically-sensitive processes are sensitive to the second software clock.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. A non-transitory computer readable medium configured to store instructions, the instructions when executed by a processor cause the processor to:
<claim-text>execute a simulation model comprising a first software module and a second software module, the second software module configured to run using a second software clock, and the first software module configured to run using a first software clock or the second software clock, the first software clock advancing a simulation at a faster rate relative to the second software clock;</claim-text>
<claim-text>during the simulation, either:
<claim-text>drive both the first software module and the second software module with the second software clock in response to the first software module being active and the second software module being active; or</claim-text>
<claim-text>drive the second software module with the second software clock in response to the first software module being inactive and the second software module being active; and</claim-text>
</claim-text>
<claim-text>disable the second software clock and use the first software clock to drive the first software module in response to the first software module being active and the second software module being inactive.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The non-transitory computer readable medium of <claim-ref idref="CLM-00007">claim 7</claim-ref> further comprising instructions that cause the processor to monitor processes in the simulation that are sensitive to the second software clock, the second software clock disabled when no processes are sensitive to the second software clock.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The non-transitory computer readable medium of <claim-ref idref="CLM-00007">claim 7</claim-ref> further comprising instructions that cause the processor to receive an indication that a process in the simulation that is sensitive to the second software clock is no longer sensitive to the second software clock object.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The non-transitory computer readable medium of <claim-ref idref="CLM-00007">claim 7</claim-ref> further comprising instructions that cause the processor to enable the second software clock for the second software module in response to the second software module becoming active.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The non-transitory computer readable medium of <claim-ref idref="CLM-00007">claim 7</claim-ref> further comprising instructions that cause the processor to receive an indication that a process in the simulation is waiting for a clock event from the second software clock.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The non-transitory computer readable medium of <claim-ref idref="CLM-00007">claim 7</claim-ref> wherein the simulation model is constructed in a language compliant with SystemC and comprises statically-sensitive processes and dynamically-sensitive processes, and further comprising instructions that cause the processor to:
<claim-text>maintain a count of statically-sensitive processes; and</claim-text>
<claim-text>disable the second software clock when the count is zero and no dynamically-sensitive processes are sensitive to the second software clock.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. A computer system comprising:
<claim-text>a processor; and</claim-text>
<claim-text>a non-transitory computer readable medium configured to store instructions, the instructions when executed by the processor cause the processor to:
<claim-text>execute a simulation model comprising a first software module and a second software module, the second software module configured to run using a second software clock, and the first software module configured to run using a first software clock or the second software clock, the first software clock advancing a simulation at a faster rate relative to the second software clock;</claim-text>
<claim-text>during the simulation, either:
<claim-text>drive both the first software module and the second software module with the second software clock in response to the first software module being active and the second software module being active; or</claim-text>
<claim-text>drive the second software module with the second software clock in response to the first software module being inactive and the second software module being active; and</claim-text>
</claim-text>
<claim-text>disable the second software clock and use the first software clock to drive the first software module in response to the first software module being active and the second software module being inactive.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The computer system of <claim-ref idref="CLM-00013">claim 13</claim-ref> wherein the non-transitory computer readable medium further comprises instructions that cause the processor to monitor processes in the simulation that are sensitive to the second software clock, the second software clock disabled when no processes are sensitive to the second software clock.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The computer system of <claim-ref idref="CLM-00013">claim 13</claim-ref> wherein the non-transitory computer readable medium further comprises instructions that cause the processor to receive an indication that a process in the simulation that is sensitive to the second software clock is no longer sensitive to the second software clock.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The computer system of <claim-ref idref="CLM-00013">claim 13</claim-ref> wherein the non-transitory computer readable medium further comprises instructions that cause the processor to receive an indication that a process in the simulation is waiting for a clock event from the second software clock.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The computer system of <claim-ref idref="CLM-00013">claim 13</claim-ref> wherein the simulation model comprises statically-sensitive processes and dynamically-sensitive processes, wherein the non-transitory computer readable medium further comprises instructions that cause the processor to maintain a count of statically-sensitive processes, and wherein the second software clock is disabled when the count is zero and no dynamically-sensitive processes are sensitive to the second software clock. </claim-text>
</claim>
</claims>
</us-patent-grant>
