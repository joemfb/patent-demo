<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v44-2013-05-16.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v4.4 2013-05-16" file="US08627177-20140107.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20131224" date-publ="20140107">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>08627177</doc-number>
<kind>B2</kind>
<date>20140107</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>13897567</doc-number>
<date>20130520</date>
</document-id>
</application-reference>
<us-application-series-code>13</us-application-series-code>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>11</class>
<subclass>C</subclass>
<main-group>29</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>11</main-group>
<subgroup>00</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>06</class>
<subclass>F</subclass>
<main-group>13</main-group>
<subgroup>00</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>11</class>
<subclass>C</subclass>
<main-group>11</main-group>
<subgroup>34</subgroup>
<symbol-position>L</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20140107</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>714763</main-classification>
<further-classification>714769</further-classification>
<further-classification>714770</further-classification>
<further-classification>714773</further-classification>
<further-classification>714  624</further-classification>
<further-classification>714  611</further-classification>
<further-classification>714 472</further-classification>
<further-classification>711100</further-classification>
<further-classification>711101</further-classification>
<further-classification>711111</further-classification>
<further-classification>711114</further-classification>
<further-classification>365184</further-classification>
<further-classification>365200</further-classification>
</classification-national>
<invention-title id="d2e43">Retrieving data from a dispersed storage network in accordance with a retrieval threshold</invention-title>
<us-references-cited>
<us-citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>8291277</doc-number>
<kind>B2</kind>
<name>Markison et al.</name>
<date>20121000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714748</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>8448044</doc-number>
<kind>B2</kind>
<name>Dhuse et al.</name>
<date>20130500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714763</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>2006/0156059</doc-number>
<kind>A1</kind>
<name>Kitamura</name>
<date>20060700</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714  6</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>2009/0094250</doc-number>
<kind>A1</kind>
<name>Dhuse et al.</name>
<date>20090400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707 10</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>2009/0094251</doc-number>
<kind>A1</kind>
<name>Gladwin et al.</name>
<date>20090400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>707 10</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>2009/0094318</doc-number>
<kind>A1</kind>
<name>Gladwin et al.</name>
<date>20090400</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709203</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>2010/0146191</doc-number>
<kind>A1</kind>
<name>Katz</name>
<date>20100600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711103</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>2011/0029809</doc-number>
<kind>A1</kind>
<name>Dhuse et al.</name>
<date>20110200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714  6</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>2011/0072210</doc-number>
<kind>A1</kind>
<name>Dhuse</name>
<date>20110300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>711114</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2011/0072321</doc-number>
<kind>A1</kind>
<name>Dhuse</name>
<date>20110300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>714 55</main-classification></classification-national>
</us-citation>
<us-citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2012/0054500</doc-number>
<kind>A1</kind>
<name>Dhuse et al.</name>
<date>20120300</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713189</main-classification></classification-national>
</us-citation>
<us-citation>
<nplcit num="00012">
<othercit>Shamir; How to Share a Secret; Communications of the ACM; vol. 22, No. 11; Nov. 1979; pp. 612-613.</othercit>
</nplcit>
<category>cited by examiner</category>
</us-citation>
</us-references-cited>
<number-of-claims>8</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<us-field-of-classification-search>
<classification-national>
<country>US</country>
<main-classification>714763</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714769</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714770</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714773</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714  624</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714  611</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>714 472</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711100</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711101</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711111</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>711114</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>365184</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>365200</main-classification>
</classification-national>
</us-field-of-classification-search>
<figures>
<number-of-drawing-sheets>19</number-of-drawing-sheets>
<number-of-figures>27</number-of-figures>
</figures>
<us-related-documents>
<continuation>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>13097357</doc-number>
<date>20110429</date>
</document-id>
<parent-grant-document>
<document-id>
<country>US</country>
<doc-number>8448044</doc-number>
<date>20130521</date>
</document-id>
</parent-grant-document>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>13897567</doc-number>
</document-id>
</child-doc>
</relation>
</continuation>
<us-provisional-application>
<document-id>
<country>US</country>
<doc-number>61346173</doc-number>
<date>20100519</date>
</document-id>
</us-provisional-application>
<related-publication>
<document-id>
<country>US</country>
<doc-number>20130254624</doc-number>
<kind>A1</kind>
<date>20130926</date>
</document-id>
</related-publication>
</us-related-documents>
<us-parties>
<us-applicants>
<us-applicant sequence="001" app-type="applicant" designation="us-only" applicant-authority-category="assignee">
<addressbook>
<orgname>Cleversafe, Inc.</orgname>
<address>
<city>Chicago</city>
<state>IL</state>
<country>US</country>
</address>
</addressbook>
<residence>
<country>US</country>
</residence>
</us-applicant>
</us-applicants>
<inventors>
<inventor sequence="001" designation="us-only">
<addressbook>
<last-name>Dhuse</last-name>
<first-name>Greg</first-name>
<address>
<city>Chicago</city>
<state>IL</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="002" designation="us-only">
<addressbook>
<last-name>Volvovski</last-name>
<first-name>Ilya</first-name>
<address>
<city>Chicago</city>
<state>IL</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="003" designation="us-only">
<addressbook>
<last-name>Baptist</last-name>
<first-name>Andrew</first-name>
<address>
<city>Mt. Pleasant</city>
<state>WI</state>
<country>US</country>
</address>
</addressbook>
</inventor>
<inventor sequence="004" designation="us-only">
<addressbook>
<last-name>Vas</last-name>
<first-name>Sebastien</first-name>
<address>
<city>Saint Maur des Fosses</city>
<country>FR</country>
</address>
</addressbook>
</inventor>
<inventor sequence="005" designation="us-only">
<addressbook>
<last-name>Mark</last-name>
<first-name>Zachary J.</first-name>
<address>
<city>Chicago</city>
<state>CA</state>
<country>US</country>
</address>
</addressbook>
</inventor>
</inventors>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>Garlick &#x26; Markison</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>Markison</last-name>
<first-name>Timothy W.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</us-parties>
<assignees>
<assignee>
<addressbook>
<orgname>Cleversafe, Inc.</orgname>
<role>02</role>
<address>
<city>Chicago</city>
<state>IL</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Tabone, Jr.</last-name>
<first-name>John J</first-name>
<department>2117</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">A method begins with a processing module determining a retrieval threshold for retrieving a set of encoded data slices from a dispersed storage network (DSN). The set of encoded data slices represents data encoded using a dispersed storage error encoding function having a number of encoded data slices in the set of encoded data slices equal to or greater than a decode threshold and the retrieval threshold is equal to or greater than the decode threshold. The method continues with the processing module issuing data retrieval requests to the DSN for the set of encoded data slices and receiving encoded data slices of the set of encoded data slices to produce received encoded data slices. The method continues with the processing module decoding the received encoded data slices to recapture the data when a number of received encoded data slices compares favorably to the retrieval threshold.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="181.61mm" wi="218.19mm" file="US08627177-20140107-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="236.81mm" wi="188.38mm" orientation="landscape" file="US08627177-20140107-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="216.32mm" wi="174.58mm" orientation="landscape" file="US08627177-20140107-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="234.02mm" wi="189.31mm" orientation="landscape" file="US08627177-20140107-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="240.11mm" wi="185.76mm" orientation="landscape" file="US08627177-20140107-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="219.71mm" wi="175.68mm" orientation="landscape" file="US08627177-20140107-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="234.02mm" wi="179.92mm" orientation="landscape" file="US08627177-20140107-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="239.27mm" wi="135.38mm" orientation="landscape" file="US08627177-20140107-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="97.87mm" wi="172.30mm" orientation="landscape" file="US08627177-20140107-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="226.48mm" wi="187.88mm" orientation="landscape" file="US08627177-20140107-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="207.60mm" wi="170.69mm" orientation="landscape" file="US08627177-20140107-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="217.17mm" wi="182.96mm" orientation="landscape" file="US08627177-20140107-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="117.43mm" wi="177.21mm" orientation="landscape" file="US08627177-20140107-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="189.57mm" wi="178.31mm" orientation="landscape" file="US08627177-20140107-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="193.80mm" wi="167.30mm" orientation="landscape" file="US08627177-20140107-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="241.89mm" wi="185.84mm" orientation="landscape" file="US08627177-20140107-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00016" num="00016">
<img id="EMI-D00016" he="130.89mm" wi="176.19mm" orientation="landscape" file="US08627177-20140107-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00017" num="00017">
<img id="EMI-D00017" he="247.14mm" wi="187.28mm" orientation="landscape" file="US08627177-20140107-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00018" num="00018">
<img id="EMI-D00018" he="194.48mm" wi="189.31mm" orientation="landscape" file="US08627177-20140107-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00019" num="00019">
<img id="EMI-D00019" he="85.77mm" wi="124.46mm" orientation="landscape" file="US08627177-20140107-D00019.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?RELAPP description="Other Patent Relations" end="lead"?>
<heading id="h-0001" level="1">CROSS REFERENCE TO RELATED PATENTS</heading>
<p id="p-0002" num="0001">The present U.S. Utility Patent Application claims priority pursuant to 35 U.S.C. &#xa7;120, as a continuation, to the following U.S. Utility Patent Application, which is hereby incorporated herein by reference in its entirety and made part of the present U.S. Utility Patent Application for all purposes:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0002">1. U.S. Utility application Ser. No. 13/097,357 entitled &#x201c;RETRIEVING DATA FROM A DISPERSED STORAGE NETWORK IN ACCORDANCE WITH A RETRIEVAL THRESHOLD,&#x201d; filed Apr. 29, 2011, now U.S. Pat. No. 8,448,044, which claims priority pursuant to 35 U.S.C. &#xa7;119(e) to the following U.S. Provisional Patent Application:
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0003">a. U.S. Provisional Application Ser. No. 61/346,173, entitled &#x201c;DISPERSED STORAGE NETWORK MEMORY DEVICE UTILIZATION,&#x201d; filed May 19, 2010.</li>
    </ul>
    </li>
</ul>
</p>
<?RELAPP description="Other Patent Relations" end="tail"?>
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0002" level="1">STATEMENT REGARDING FEDERALLY SPONSORED RESEARCH OR DEVELOPMENT</heading>
<p id="p-0003" num="0004">Not Applicable</p>
<heading id="h-0003" level="1">INCORPORATION-BY-REFERENCE OF MATERIAL SUBMITTED ON A COMPACT DISC</heading>
<p id="p-0004" num="0005">Not Applicable</p>
<heading id="h-0004" level="1">BACKGROUND OF THE INVENTION</heading>
<p id="p-0005" num="0006">1. Technical Field of the Invention</p>
<p id="p-0006" num="0007">This invention relates generally to computing systems and more particularly to data storage solutions within such computing systems.</p>
<p id="p-0007" num="0008">2. Description of Related Art</p>
<p id="p-0008" num="0009">Computers are known to communicate, process, and store data. Such computers range from wireless smart phones to data centers that support millions of web searches, stock trades, or on-line purchases every day. In general, a computing system generates data and/or manipulates data from one form into another. For instance, an image sensor of the computing system generates raw picture data and, using an image compression program (e.g., JPEG, MPEG, etc.), the computing system manipulates the raw picture data into a standardized compressed image.</p>
<p id="p-0009" num="0010">With continued advances in processing speed and communication speed, computers are capable of processing real time multimedia data for applications ranging from simple voice communications to streaming high definition video. As such, general-purpose information appliances are replacing purpose-built communications devices (e.g., a telephone). For example, smart phones can support telephony communications but they are also capable of text messaging and accessing the internet to perform functions including email, web browsing, remote applications access, and media communications (e.g., telephony voice, image transfer, music files, video files, real time video streaming. etc.).</p>
<p id="p-0010" num="0011">Each type of computer is constructed and operates in accordance with one or more communication, processing, and storage standards. As a result of standardization and with advances in technology, more and more information content is being converted into digital formats. For example, more digital cameras are now being sold than film cameras, thus producing more digital pictures. As another example, web-based programming is becoming an alternative to over the air television broadcasts and/or cable broadcasts. As further examples, papers, books, video entertainment, home video, etc. are now being stored digitally, which increases the demand on the storage function of computers.</p>
<p id="p-0011" num="0012">A typical computer storage system includes one or more memory devices aligned with the needs of the various operational aspects of the computer's processing and communication functions. Generally, the immediacy of access dictates what type of memory device is used. For example, random access memory (RAM) memory can be accessed in any random order with a constant response time, thus it is typically used for cache memory and main memory. By contrast, memory device technologies that require physical movement such as magnetic disks, tapes, and optical discs, have a variable response time as the physical movement can take longer than the data transfer, thus they are typically used for secondary memory (e.g., hard drive, backup memory, etc.).</p>
<p id="p-0012" num="0013">A computer's storage system will be compliant with one or more computer storage standards that include, but are not limited to, network file system (NFS), flash file system (FFS), disk file system (DFS), small computer system interface (SCSI), internet small computer system interface (iSCSI), file transfer protocol (FTP), and web-based distributed authoring and versioning (WebDAV). These standards specify the data storage format (e.g., files, data objects, data blocks, directories, etc.) and interfacing between the computer's processing function and its storage system, which is a primary function of the computer's memory controller.</p>
<p id="p-0013" num="0014">Despite the standardization of the computer and its storage system, memory devices fail; especially commercial grade memory devices that utilize technologies incorporating physical movement (e.g., a disc drive). For example, it is fairly common for a disc drive to routinely suffer from bit level corruption and to completely fail after three years of use. One solution is to a higher-grade disc drive, which adds significant cost to a computer.</p>
<p id="p-0014" num="0015">Another solution is to utilize multiple levels of redundant disc drives to replicate the data into two or more copies. One such redundant drive approach is called redundant array of independent discs (RAID). In a RAID device, a RAID controller adds parity data to the original data before storing it across the array. The parity data is calculated from the original data such that the failure of a disc will not result in the loss of the original data. For example, RAID 5 uses three discs to protect data from the failure of a single disc. The parity data, and associated redundancy overhead data, reduces the storage capacity of three independent discs by one third (e.g., n&#x2212;1=capacity). RAID 6 can recover from a loss of two discs and requires a minimum of four discs with a storage capacity of n&#x2212;2.</p>
<p id="p-0015" num="0016">While RAID addresses the memory device failure issue, it is not without its own failures issues that affect its effectiveness, efficiency and security. For instance, as more discs are added to the array, the probability of a disc failure increases, which increases the demand for maintenance. For example, when a disc fails, it needs to be manually replaced before another disc fails and the data stored in the RAID device is lost. To reduce the risk of data loss, data on a RAID device is typically copied on to one or more other RAID devices. While this addresses the loss of data issue, it raises a security issue since multiple copies of data are available, which increases the chances of unauthorized access. Further, as the amount of data being stored grows, the overhead of RAID devices becomes a non-trivial efficiency issue.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWING(S)</heading>
<p id="p-0016" num="0017"><figref idref="DRAWINGS">FIG. 1</figref> is a schematic block diagram of an embodiment of a computing system in accordance with the invention;</p>
<p id="p-0017" num="0018"><figref idref="DRAWINGS">FIG. 2</figref> is a schematic block diagram of an embodiment of a computing core in accordance with the invention;</p>
<p id="p-0018" num="0019"><figref idref="DRAWINGS">FIG. 3</figref> is a schematic block diagram of an embodiment of a distributed storage processing unit in accordance with the invention;</p>
<p id="p-0019" num="0020"><figref idref="DRAWINGS">FIG. 4</figref> is a schematic block diagram of an embodiment of a grid module in accordance with the invention;</p>
<p id="p-0020" num="0021"><figref idref="DRAWINGS">FIG. 5</figref> is a diagram of an example embodiment of error coded data slice creation in accordance with the invention;</p>
<p id="p-0021" num="0022"><figref idref="DRAWINGS">FIG. 6</figref> is a flowchart illustrating an example of managing a memory device in accordance with invention;</p>
<p id="p-0022" num="0023"><figref idref="DRAWINGS">FIG. 7</figref> A is a flowchart illustrating an example of authorizing an access request in accordance with the invention;</p>
<p id="p-0023" num="0024"><figref idref="DRAWINGS">FIG. 7</figref> B is a diagram illustrating an example of an authorization table in accordance with the invention;</p>
<p id="p-0024" num="0025"><figref idref="DRAWINGS">FIG. 8</figref> A is a diagram illustrating an example of a memory utilization map sequence in accordance with invention;</p>
<p id="p-0025" num="0026"><figref idref="DRAWINGS">FIG. 8</figref> B is a flowchart illustrating an example of balancing memory utilization in accordance with the invention;</p>
<p id="p-0026" num="0027"><figref idref="DRAWINGS">FIG. 9</figref> A is a flowchart illustrating an example of managing memory usage in accordance with the invention;</p>
<p id="p-0027" num="0028"><figref idref="DRAWINGS">FIG. 9</figref> B is a flowchart illustrating another example of managing memory usage in accordance with the invention;</p>
<p id="p-0028" num="0029"><figref idref="DRAWINGS">FIG. 9</figref> C is a flowchart illustrating another example of managing memory usage in accordance with invention;</p>
<p id="p-0029" num="0030"><figref idref="DRAWINGS">FIG. 10</figref> A is a diagram illustrating an example of a user role table in accordance with invention;</p>
<p id="p-0030" num="0031"><figref idref="DRAWINGS">FIG. 10</figref> B is a diagram illustrating an example of a role permissions table in accordance with the invention;</p>
<p id="p-0031" num="0032"><figref idref="DRAWINGS">FIG. 10</figref> C is a flowchart illustrating another example of authorizing an access request in accordance with the invention;</p>
<p id="p-0032" num="0033"><figref idref="DRAWINGS">FIG. 11</figref> is a flowchart illustrating an example of retrieving data in accordance with invention;</p>
<p id="p-0033" num="0034"><figref idref="DRAWINGS">FIG. 12</figref> is a flowchart illustrating an example of synchronizing a revision of stored data in accordance with the invention;</p>
<p id="p-0034" num="0035"><figref idref="DRAWINGS">FIG. 13</figref> A is a diagram illustrating another example of a memory utilization map in accordance with invention;</p>
<p id="p-0035" num="0036"><figref idref="DRAWINGS">FIG. 13</figref> B is a flowchart illustrating another example of balancing memory utilization in accordance with the invention;</p>
<p id="p-0036" num="0037"><figref idref="DRAWINGS">FIG. 14</figref> A is a flowchart illustrating an example of identifying a failed memory device in accordance with invention;</p>
<p id="p-0037" num="0038"><figref idref="DRAWINGS">FIG. 14</figref> B is a flowchart illustrating an example of processing a memory access request in accordance with invention;</p>
<p id="p-0038" num="0039"><figref idref="DRAWINGS">FIG. 15</figref> is another schematic block diagram of an embodiment of a computing system in accordance with the invention;</p>
<p id="p-0039" num="0040"><figref idref="DRAWINGS">FIG. 16</figref> is a flowchart illustrating an example of storing data in accordance with the invention;</p>
<p id="p-0040" num="0041"><figref idref="DRAWINGS">FIG. 17</figref> is another schematic block diagram of an embodiment of a computing system in accordance with the invention;</p>
<p id="p-0041" num="0042"><figref idref="DRAWINGS">FIG. 18</figref> is a flowchart illustrating another example of retrieving data in accordance with the invention; and</p>
<p id="p-0042" num="0043"><figref idref="DRAWINGS">FIG. 19</figref> is a flowchart illustrating an example of generating a passkey in accordance with invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0006" level="1">DETAILED DESCRIPTION OF THE INVENTION</heading>
<p id="p-0043" num="0044"><figref idref="DRAWINGS">FIG. 1</figref> is a schematic block diagram of a computing system <b>10</b> that includes one or more of a first type of user devices <b>12</b>, one or more of a second type of user devices <b>14</b>, at least one distributed storage (DS) processing unit <b>16</b>, at least one DS managing unit <b>18</b>, at least one storage integrity processing unit <b>20</b>, and a distributed storage network (DSN) memory <b>22</b> coupled via a network <b>24</b>. The network <b>24</b> may include one or more wireless and/or wire lined communication systems; one or more private intranet systems and/or public internet systems; and/or one or more local area networks (LAN) and/or wide area networks (WAN).</p>
<p id="p-0044" num="0045">The DSN memory <b>22</b> includes a plurality of distributed storage (DS) units <b>36</b> for storing data of the system. Each of the DS units <b>36</b> includes a processing module and memory and may be located at a geographically different site than the other DS units (e.g., one in Chicago, one in Milwaukee, etc.). The processing module may be a single processing device or a plurality of processing devices. Such a processing device may be a microprocessor, micro-controller, digital signal processor, microcomputer, central processing unit, field programmable gate array, programmable logic device, state machine, logic circuitry, analog circuitry, digital circuitry, and/or any device that manipulates signals (analog and/or digital) based on hard coding of the circuitry and/or operational instructions. The processing module may have an associated memory and/or memory element, which may be a single memory device, a plurality of memory devices, and/or embedded circuitry of the processing module. Such a memory device may be a read-only memory, random access memory, volatile memory, non-volatile memory, static memory, dynamic memory, flash memory, cache memory, and/or any device that stores digital information. Note that if the processing module includes more than one processing device, the processing devices may be centrally located (e.g., directly coupled together via a wired and/or wireless bus structure) or may be distributedly located (e.g., cloud computing via indirect coupling via a local area network and/or a wide area network). Further note that when the processing module implements one or more of its functions via a state machine, analog circuitry, digital circuitry, and/or logic circuitry, the memory and/or memory element storing the corresponding operational instructions may be embedded within, or external to, the circuitry comprising the state machine, analog circuitry, digital circuitry, and/or logic circuitry. Still further note that, the memory element stores, and the processing module executes, hard coded and/or operational instructions corresponding to at least some of the steps and/or functions illustrated in <figref idref="DRAWINGS">FIGS. 1-19</figref>.</p>
<p id="p-0045" num="0046">Each of the user devices <b>12</b>-<b>14</b>, the DS processing unit <b>16</b>, the DS managing unit <b>18</b>, and the storage integrity processing unit <b>20</b> may be a portable computing device (e.g., a social networking device, a gaming device, a cell phone, a smart phone, a personal digital assistant, a digital music player, a digital video player, a laptop computer, a handheld computer, a video game controller, and/or any other portable device that includes a computing core) and/or a fixed computing device (e.g., a personal computer, a computer server, a cable set-top box, a satellite receiver, a television set, a printer, a fax machine, home entertainment equipment, a video game console, and/or any type of home or office computing equipment). Such a portable or fixed computing device includes a computing core <b>26</b> and one or more interfaces <b>30</b>, <b>32</b>, and/or <b>33</b>. An embodiment of the computing core <b>26</b> will be described with reference to <figref idref="DRAWINGS">FIG. 2</figref>.</p>
<p id="p-0046" num="0047">With respect to the interfaces, each of the interfaces <b>30</b>, <b>32</b>, and <b>33</b> includes software and/or hardware to support one or more communication links via the network <b>24</b> and/or directly. For example, interfaces <b>30</b> support a communication link (wired, wireless, direct, via a LAN, via the network <b>24</b>, etc.) between the first type of user device <b>14</b> and the DS processing unit <b>16</b>. As another example, DSN interface <b>32</b> supports a plurality of communication links via the network <b>24</b> between the DSN memory <b>22</b> and the DS processing unit <b>16</b>, the first type of user device <b>12</b>, and/or the storage integrity processing unit <b>20</b>. As yet another example, interface <b>33</b> supports a communication link between the DS managing unit <b>18</b> and any one of the other devices and/or units <b>12</b>, <b>14</b>, <b>16</b>, <b>20</b>, and/or <b>22</b> via the network <b>24</b>.</p>
<p id="p-0047" num="0048">In general and with respect to data storage, the system <b>10</b> supports three primary functions: distributed network data storage management, distributed data storage and retrieval, and data storage integrity verification. In accordance with these three primary functions, data can be distributedly stored in a plurality of physically different locations and subsequently retrieved in a reliable and secure manner regardless of failures of individual storage devices, failures of network equipment, the duration of storage, the amount of data being stored, attempts at hacking the data, etc.</p>
<p id="p-0048" num="0049">The DS managing unit <b>18</b> performs distributed network data storage management functions, which include establishing distributed data storage parameters, performing network operations, performing network administration, and/or performing network maintenance. The DS managing unit <b>18</b> establishes the distributed data storage parameters (e.g., allocation of virtual DSN memory space, distributed storage parameters, security parameters, billing information, user profile information, etc.) for one or more of the user devices <b>12</b>-<b>14</b> (e.g., established for individual devices, established for a user group of devices, established for public access by the user devices, etc.). For example, the DS managing unit <b>18</b> coordinates the creation of a vault (e.g., a virtual memory block) within the DSN memory <b>22</b> for a user device (for a group of devices, or for public access). The DS managing unit <b>18</b> also determines the distributed data storage parameters for the vault. In particular, the DS managing unit <b>18</b> determines a number of slices (e.g., the number that a data segment of a data file and/or data block is partitioned into for distributed storage) and a read threshold value (e.g., the minimum number of slices required to reconstruct the data segment).</p>
<p id="p-0049" num="0050">As another example, the DS managing module <b>18</b> creates and stores, locally or within the DSN memory <b>22</b>, user profile information. The user profile information includes one or more of authentication information, permissions, and/or the security parameters. The security parameters may include one or more of encryption/decryption scheme, one or more encryption keys, key generation scheme, and data encoding/decoding scheme.</p>
<p id="p-0050" num="0051">As yet another example, the DS managing unit <b>18</b> creates billing information for a particular user, user group, vault access, public vault access, etc. For instance, the DS managing unit <b>18</b> tracks the number of times user accesses a private vault and/or public vaults, which can be used to generate a per-access bill. In another instance, the DS managing unit <b>18</b> tracks the amount of data stored and/or retrieved by a user device and/or a user group, which can be used to generate a per-data-amount bill.</p>
<p id="p-0051" num="0052">The DS managing unit <b>18</b> also performs network operations, network administration, and/or network maintenance. As at least part of performing the network operations and/or administration, the DS managing unit <b>18</b> monitors performance of the devices and/or units of the system <b>10</b> for potential failures, determines the devices and/or unit's activation status, determines the devices' and/or units' loading, and any other system level operation that affects the performance level of the system <b>10</b>. For example, the DS managing unit <b>18</b> receives and aggregates network management alarms, alerts, errors, status information, performance information, and messages from the devices <b>12</b>-<b>14</b> and/or the units <b>16</b>, <b>20</b>, <b>22</b>. For example, the DS managing unit <b>18</b> receives a simple network management protocol (SNMP) message regarding the status of the DS processing unit <b>16</b>.</p>
<p id="p-0052" num="0053">The DS managing unit <b>18</b> performs the network maintenance by identifying equipment within the system <b>10</b> that needs replacing, upgrading, repairing, and/or expanding. For example, the DS managing unit <b>18</b> determines that the DSN memory <b>22</b> needs more DS units <b>36</b> or that one or more of the DS units <b>36</b> needs updating.</p>
<p id="p-0053" num="0054">The second primary function (i.e., distributed data storage and retrieval) begins and ends with a user device <b>12</b>-<b>14</b>. For instance, if a second type of user device <b>14</b> has a data file <b>38</b> and/or data block <b>40</b> to store in the DSN memory <b>22</b>, it send the data file <b>38</b> and/or data block <b>40</b> to the DS processing unit <b>16</b> via its interface <b>30</b>. As will be described in greater detail with reference to <figref idref="DRAWINGS">FIG. 2</figref>, the interface <b>30</b> functions to mimic a conventional operating system (OS) file system interface (e.g., network file system (NFS), flash file system (FFS), disk file system (DFS), file transfer protocol (FTP), web-based distributed authoring and versioning (WebDAV), etc.) and/or a block memory interface (e.g., small computer system interface (SCSI), internet small computer system interface (iSCSI), etc.). In addition, the interface <b>30</b> may attach a user identification code (ID) to the data file <b>38</b> and/or data block <b>40</b>.</p>
<p id="p-0054" num="0055">The DS processing unit <b>16</b> receives the data file <b>38</b> and/or data block <b>40</b> via its interface <b>30</b> and performs a distributed storage (DS) process <b>34</b> thereon (e.g., an error coding dispersal storage function). The DS processing <b>34</b> begins by partitioning the data file <b>38</b> and/or data block <b>40</b> into one or more data segments, which is represented as Y data segments. For example, the DS processing <b>34</b> may partition the data file <b>38</b> and/or data block <b>40</b> into a fixed byte size segment (e.g., 2<sup>1 </sup>to 2<sup>n </sup>bytes, where n=&#x3e;2) or a variable byte size (e.g., change byte size from segment to segment, or from groups of segments to groups of segments, etc.).</p>
<p id="p-0055" num="0056">For each of the Y data segments, the DS processing <b>34</b> error encodes (e.g., forward error correction (FEC), information dispersal algorithm, or error correction coding) and slices (or slices then error encodes) the data segment into a plurality of error coded (EC) data slices <b>42</b>-<b>48</b>, which is represented as X slices per data segment. The number of slices (X) per segment, which corresponds to a number of pillars n, is set in accordance with the distributed data storage parameters and the error coding scheme. For example, if a Reed-Solomon (or other FEC scheme) is used in an n/k system, then a data segment is divided into n slices, where k number of slices is needed to reconstruct the original data (i.e., k is the threshold). As a few specific examples, the n/k factor may be 5/3; 6/4; 8/6; 8/5; 16/10.</p>
<p id="p-0056" num="0057">For each slice <b>42</b>-<b>48</b>, the DS processing unit <b>16</b> creates a unique slice name and appends it to the corresponding slice <b>42</b>-<b>48</b>. The slice name includes universal DSN memory addressing routing information (e.g., virtual memory addresses in the DSN memory <b>22</b>) and user-specific information (e.g., user ID, file name, data block identifier, etc.).</p>
<p id="p-0057" num="0058">The DS processing unit <b>16</b> transmits the plurality of EC slices <b>42</b>-<b>48</b> to a plurality of DS units <b>36</b> of the DSN memory <b>22</b> via the DSN interface <b>32</b> and the network <b>24</b>. The DSN interface <b>32</b> formats each of the slices for transmission via the network <b>24</b>. For example, the DSN interface <b>32</b> may utilize an internet protocol (e.g., TCP/IP, etc.) to packetize the slices <b>42</b>-<b>48</b> for transmission via the network <b>24</b>.</p>
<p id="p-0058" num="0059">The number of DS units <b>36</b> receiving the slices <b>42</b>-<b>48</b> is dependent on the distributed data storage parameters established by the DS managing unit <b>18</b>. For example, the DS managing unit <b>18</b> may indicate that each slice is to be stored in a different DS unit <b>36</b>. As another example, the DS managing unit <b>18</b> may indicate that like slice numbers of different data segments are to be stored in the same DS unit <b>36</b>. For example, the first slice of each of the data segments is to be stored in a first DS unit <b>36</b>, the second slice of each of the data segments is to be stored in a second DS unit <b>36</b>, etc. In this manner, the data is encoded and distributedly stored at physically diverse locations to improved data storage integrity and security. Further examples of encoding the data segments will be provided with reference to one or more of <figref idref="DRAWINGS">FIGS. 2-19</figref>.</p>
<p id="p-0059" num="0060">Each DS unit <b>36</b> that receives a slice <b>42</b>-<b>48</b> for storage translates the virtual DSN memory address of the slice into a local physical address for storage. Accordingly, each DS unit <b>36</b> maintains a virtual to physical memory mapping to assist in the storage and retrieval of data.</p>
<p id="p-0060" num="0061">The first type of user device <b>12</b> performs a similar function to store data in the DSN memory <b>22</b> with the exception that it includes the DS processing. As such, the device <b>12</b> encodes and slices the data file and/or data block it has to store. The device then transmits the slices <b>11</b> to the DSN memory via its DSN interface <b>32</b> and the network <b>24</b>.</p>
<p id="p-0061" num="0062">For a second type of user device <b>14</b> to retrieve a data file or data block from memory, it issues a read command via its interface <b>30</b> to the DS processing unit <b>16</b>. The DS processing unit <b>16</b> performs the DS processing <b>34</b> to identify the DS units <b>36</b> storing the slices of the data file and/or data block based on the read command. The DS processing unit <b>16</b> may also communicate with the DS managing unit <b>18</b> to verify that the user device <b>14</b> is authorized to access the requested data.</p>
<p id="p-0062" num="0063">Assuming that the user device is authorized to access the requested data, the DS processing unit <b>16</b> issues slice read commands to at least a threshold number of the DS units <b>36</b> storing the requested data (e.g., to at least 10 DS units for a 16/10 error coding scheme). Each of the DS units <b>36</b> receiving the slice read command, verifies the command, accesses its virtual to physical memory mapping, retrieves the requested slice, or slices, and transmits it to the DS processing unit <b>16</b>.</p>
<p id="p-0063" num="0064">Once the DS processing unit <b>16</b> has received a read threshold number of slices for a data segment, it performs an error decoding function and de-slicing to reconstruct the data segment. When Y number of data segments has been reconstructed, the DS processing unit <b>16</b> provides the data file <b>38</b> and/or data block <b>40</b> to the user device <b>14</b>. Note that the first type of user device <b>12</b> performs a similar process to retrieve a data file and/or data block.</p>
<p id="p-0064" num="0065">The storage integrity processing unit <b>20</b> performs the third primary function of data storage integrity verification. In general, the storage integrity processing unit <b>20</b> periodically retrieves slices <b>45</b>, and/or slice names, of a data file or data block of a user device to verify that one or more slices have not been corrupted or lost (e.g., the DS unit failed). The retrieval process mimics the read process previously described.</p>
<p id="p-0065" num="0066">If the storage integrity processing unit <b>20</b> determines that one or more slices is corrupted or lost, it rebuilds the corrupted or lost slice(s) in accordance with the error coding scheme. The storage integrity processing unit <b>20</b> stores the rebuild slice, or slices, in the appropriate DS unit(s) <b>36</b> in a manner that mimics the write process previously described.</p>
<p id="p-0066" num="0067"><figref idref="DRAWINGS">FIG. 2</figref> is a schematic block diagram of an embodiment of a computing core <b>26</b> that includes a processing module <b>50</b>, a memory controller <b>52</b>, main memory <b>54</b>, a video graphics processing unit <b>55</b>, an input/output (IO) controller <b>56</b>, a peripheral component interconnect (PCI) interface <b>58</b>, at least one IO device interface module <b>62</b>, a read only memory (ROM) basic input output system (BIOS) <b>64</b>, and one or more memory interface modules. The memory interface module(s) includes one or more of a universal serial bus (USB) interface module <b>66</b>, a host bus adapter (HBA) interface module <b>68</b>, a network interface module <b>70</b>, a flash interface module <b>72</b>, a hard drive interface module <b>74</b>, and a DSN interface module <b>76</b>. Note the DSN interface module <b>76</b> and/or the network interface module <b>70</b> may function as the interface <b>30</b> of the user device <b>14</b> of <figref idref="DRAWINGS">FIG. 1</figref>. Further note that the IO device interface module <b>62</b> and/or the memory interface modules may be collectively or individually referred to as IO ports.</p>
<p id="p-0067" num="0068">The processing module <b>50</b> may be a single processing device or a plurality of processing devices. Such a processing device may be a microprocessor, micro-controller, digital signal processor, microcomputer, central processing unit, field programmable gate array, programmable logic device, state machine, logic circuitry, analog circuitry, digital circuitry, and/or any device that manipulates signals (analog and/or digital) based on hard coding of the circuitry and/or operational instructions. The processing module <b>50</b> may have an associated memory and/or memory element, which may be a single memory device, a plurality of memory devices, and/or embedded circuitry of the processing module <b>50</b>. Such a memory device may be a read-only memory, random access memory, volatile memory, non-volatile memory, static memory, dynamic memory, flash memory, cache memory, and/or any device that stores digital information. Note that if the processing module <b>50</b> includes more than one processing device, the processing devices may be centrally located (e.g., directly coupled together via a wired and/or wireless bus structure) or may be distributedly located (e.g., cloud computing via indirect coupling via a local area network and/or a wide area network). Further note that when the processing module <b>50</b> implements one or more of its functions via a state machine, analog circuitry, digital circuitry, and/or logic circuitry, the memory and/or memory element storing the corresponding operational instructions may be embedded within, or external to, the circuitry comprising the state machine, analog circuitry, digital circuitry, and/or logic circuitry. Still further note that, the memory element stores, and the processing module <b>50</b> executes, hard coded and/or operational instructions corresponding to at least some of the steps and/or functions illustrated in <figref idref="DRAWINGS">FIGS. 1-19</figref>.</p>
<p id="p-0068" num="0069"><figref idref="DRAWINGS">FIG. 3</figref> is a schematic block diagram of an embodiment of a dispersed storage (DS) processing module <b>34</b> of user device <b>12</b> and/or of the DS processing unit <b>16</b>. The DS processing module <b>34</b> includes a gateway module <b>78</b>, an access module <b>80</b>, a grid module <b>82</b>, and a storage module <b>84</b>. The DS processing module <b>34</b> may also include an interface <b>30</b> and the DSnet interface <b>32</b> or the interfaces <b>68</b> and/or <b>70</b> may be part of user <b>12</b> or of the DS processing unit <b>14</b>. The DS processing module <b>34</b> may further include a bypass/feedback path between the storage module <b>84</b> to the gateway module <b>78</b>. Note that the modules <b>78</b>-<b>84</b> of the DS processing module <b>34</b> may be in a single unit or distributed across multiple units.</p>
<p id="p-0069" num="0070">In an example of storing data, the gateway module <b>78</b> receives an incoming data object that includes a user ID field <b>86</b>, an object name field <b>88</b>, and the data field <b>40</b> and may also receive corresponding information that includes a process identifier (e.g., an internal process/application ID), metadata, a file system directory, a block number, a transaction message, a user device identity (ID), a data object identifier, a source name, and/or user information. The gateway module <b>78</b> authenticates the user associated with the data object by verifying the user ID <b>86</b> with the managing unit <b>18</b> and/or another authenticating unit.</p>
<p id="p-0070" num="0071">When the user is authenticated, the gateway module <b>78</b> obtains user information from the management unit <b>18</b>, the user device, and/or the other authenticating unit. The user information includes a vault identifier, operational parameters, and user attributes (e.g., user data, billing information, etc.). A vault identifier identifies a vault, which is a virtual memory space that maps to a set of DS storage units <b>36</b>. For example, vault <b>1</b> (i.e., user <b>1</b>'s DSN memory space) includes eight DS storage units (X=8 wide) and vault <b>2</b> (i.e., user <b>2</b>'s DSN memory space) includes sixteen DS storage units (X=16 wide). The operational parameters may include an error coding algorithm, the width n (number of pillars X or slices per segment for this vault), a read threshold T, a write threshold, an encryption algorithm, a slicing parameter, a compression algorithm, an integrity check method, caching settings, parallelism settings, and/or other parameters that may be used to access the DSN memory layer.</p>
<p id="p-0071" num="0072">The gateway module <b>78</b> uses the user information to assign a source name <b>35</b> to the data. For instance, the gateway module <b>60</b> determines the source name <b>35</b> of the data object <b>40</b> based on the vault identifier and the data object. For example, the source name may contain a file identifier (ID), a vault generation number, a reserved field, and a vault identifier (ID). As another example, the gateway module <b>78</b> may generate the file ID based on a hash function of the data object <b>40</b>. Note that the gateway module <b>78</b> may also perform message conversion, protocol conversion, electrical conversion, optical conversion, access control, user identification, user information retrieval, traffic monitoring, statistics generation, configuration, management, and/or source name determination.</p>
<p id="p-0072" num="0073">The access module <b>80</b> receives the data object <b>40</b> and creates a series of data segments <b>1</b> through Y <b>90</b>-<b>92</b> in accordance with a data storage protocol (e.g., file storage system, a block storage system, and/or an aggregated block storage system). The number of segments Y may be chosen or randomly assigned based on a selected segment size and the size of the data object. For example, if the number of segments is chosen to be a fixed number, then the size of the segments varies as a function of the size of the data object. For instance, if the data object is an image file of 4,194,304 eight bit bytes (e.g., 33,554,432 bits) and the number of segments Y=131,072, then each segment is 256 bits or 32 bytes. As another example, if segment sized is fixed, then the number of segments Y varies based on the size of data object. For instance, if the data object is an image file of 4,194,304 bytes and the fixed size of each segment is 4,096 bytes, the then number of segments Y=1,024. Note that each segment is associated with the same source name.</p>
<p id="p-0073" num="0074">The grid module <b>82</b> receives the data segments and may manipulate (e.g., compression, encryption, cyclic redundancy check (CRC), etc.) each of the data segments before performing an error coding function of the error coding dispersal storage function to produce a pre-manipulated data segment. After manipulating a data segment, if applicable, the grid module <b>82</b> error encodes (e.g., Reed-Solomon, Convolution encoding, Trellis encoding, etc.) the data segment or manipulated data segment into X error coded data slices <b>42</b>-<b>44</b>.</p>
<p id="p-0074" num="0075">The value X, or the number of pillars (e.g., X=16), is chosen as a parameter of the error coding dispersal storage function. Other parameters of the error coding dispersal function include a read threshold T, a write threshold W, etc. The read threshold (e.g., T=10, when X=16) corresponds to the minimum number of error-free error coded data slices required to reconstruct the data segment. In other words, the DS processing module <b>34</b> can compensate for X&#x2212;T (e.g., 16&#x2212;10=6) missing error coded data slices per data segment. The write threshold W corresponds to a minimum number of DS storage units that acknowledge proper storage of their respective data slices before the DS processing module indicates proper storage of the encoded data segment. Note that the write threshold is greater than or equal to the read threshold for a given number of pillars (X).</p>
<p id="p-0075" num="0076">For each data slice of a data segment, the grid module <b>82</b> generates a unique slice name <b>37</b> and attaches it thereto. The slice name <b>37</b> includes a universal routing information field and a vault specific field and may be 48 bytes (e.g., 24 bytes for each of the universal routing information field and the vault specific field). As illustrated, the universal routing information field includes a slice index, a vault ID, a vault generation, and a reserved field. The slice index is based on the pillar number and the vault ID and, as such, is unique for each pillar (e.g., slices of the same pillar for the same vault for any segment will share the same slice index). The vault specific field includes a data name, which includes a file ID and a segment number (e.g., a sequential numbering of data segments <b>1</b>-Y of a simple data object or a data block number).</p>
<p id="p-0076" num="0077">Prior to outputting the error coded data slices of a data segment, the grid module may perform post-slice manipulation on the slices. If enabled, the manipulation includes slice level compression, encryption, CRC, addressing, tagging, and/or other manipulation to improve the effectiveness of the computing system.</p>
<p id="p-0077" num="0078">When the error coded data slices of a data segment are ready to be outputted, the grid module <b>82</b> determines which of the DS storage units <b>36</b> will store the EC data slices based on a dispersed storage memory mapping associated with the user's vault and/or DS storage unit attributes. The DS storage unit attributes may include availability, self-selection, performance history, link speed, link latency, ownership, available DSN memory, domain, cost, a prioritization scheme, a centralized selection message from another source, a lookup table, data ownership, and/or any other factor to optimize the operation of the computing system. Note that the number of DS storage units <b>36</b> is equal to or greater than the number of pillars (e.g., X) so that no more than one error coded data slice of the same data segment is stored on the same DS storage unit <b>36</b>. Further note that EC data slices of the same pillar number but of different segments (e.g., EC data slice <b>1</b> of data segment <b>1</b> and EC data slice <b>1</b> of data segment <b>2</b>) may be stored on the same or different DS storage units <b>36</b>.</p>
<p id="p-0078" num="0079">The storage module <b>84</b> performs an integrity check on the outbound encoded data slices and, when successful, identifies a plurality of DS storage units based on information provided by the grid module <b>82</b>. The storage module <b>84</b> then outputs the encoded data slices <b>1</b> through X of each segment <b>1</b> through Y to the DS storage units <b>36</b>. Each of the DS storage units <b>36</b> stores its EC data slice(s) and maintains a local virtual DSN address to physical location table to convert the virtual DSN address of the EC data slice(s) into physical storage addresses.</p>
<p id="p-0079" num="0080">In an example of a read operation, the user device <b>12</b> and/or <b>14</b> sends a read request to the DS processing unit <b>14</b>, which authenticates the request. When the request is authentic, the DS processing unit <b>14</b> sends a read message to each of the DS storage units <b>36</b> storing slices of the data object being read. The slices are received via the DSnet interface <b>32</b> and processed by the storage module <b>84</b>, which performs a parity check and provides the slices to the grid module <b>82</b> when the parity check was successful. The grid module <b>82</b> decodes the slices in accordance with the error coding dispersal storage function to reconstruct the data segment. The access module <b>80</b> reconstructs the data object from the data segments and the gateway module <b>78</b> formats the data object for transmission to the user device.</p>
<p id="p-0080" num="0081"><figref idref="DRAWINGS">FIG. 4</figref> is a schematic block diagram of an embodiment of a grid module <b>82</b> that includes a control unit <b>73</b>, a pre-slice manipulator <b>75</b>, an encoder <b>77</b>, a slicer <b>79</b>, a post-slice manipulator <b>81</b>, a pre-slice de-manipulator <b>83</b>, a decoder <b>85</b>, a de-slicer <b>87</b>, and/or a post-slice de-manipulator <b>89</b>. Note that the control unit <b>73</b> may be partially or completely external to the grid module <b>82</b>. For example, the control unit <b>73</b> may be part of the computing core at a remote location, part of a user device, part of the DS managing unit <b>18</b>, or distributed amongst one or more DS storage units.</p>
<p id="p-0081" num="0082">In an example of write operation, the pre-slice manipulator <b>75</b> receives a data segment <b>90</b>-<b>92</b> and a write instruction from an authorized user device. The pre-slice manipulator <b>75</b> determines if pre-manipulation of the data segment <b>90</b>-<b>92</b> is required and, if so, what type. The pre-slice manipulator <b>75</b> may make the determination independently or based on instructions from the control unit <b>73</b>, where the determination is based on a computing system-wide predetermination, a table lookup, vault parameters associated with the user identification, the type of data, security requirements, available DSN memory, performance requirements, and/or other metadata.</p>
<p id="p-0082" num="0083">Once a positive determination is made, the pre-slice manipulator <b>75</b> manipulates the data segment <b>90</b>-<b>92</b> in accordance with the type of manipulation. For example, the type of manipulation may be compression (e.g., Lempel-Ziv-Welch, Huffman, Golomb, fractal, wavelet, etc.), signatures (e.g., Digital Signature Algorithm (DSA), Elliptic Curve DSA, Secure Hash Algorithm, etc.), watermarking, tagging, encryption (e.g., Data Encryption Standard, Advanced Encryption Standard, etc.), adding metadata (e.g., time/date stamping, user information, file type, etc.), cyclic redundancy check (e.g., CRC32), and/or other data manipulations to produce the pre-manipulated data segment.</p>
<p id="p-0083" num="0084">The encoder <b>77</b> encodes the pre-manipulated data segment <b>92</b> using a forward error correction (FEC) encoder (and/or other type of erasure coding and/or error coding) to produce an encoded data segment <b>94</b>. The encoder <b>77</b> determines which forward error correction algorithm to use based on a predetermination associated with the user's vault, a time based algorithm, user direction, DS managing unit direction, control unit direction, as a function of the data type, as a function of the data segment <b>92</b> metadata, and/or any other factor to determine algorithm type. The forward error correction algorithm may be Golay, Multidimensional parity, Reed-Solomon, Hamming, Bose Ray Chauduri Hocquenghem (BCH), Cauchy-Reed-Solomon, or any other FEC encoder. Note that the encoder <b>77</b> may use a different encoding algorithm for each data segment <b>92</b>, the same encoding algorithm for the data segments <b>92</b> of a data object, or a combination thereof.</p>
<p id="p-0084" num="0085">The encoded data segment <b>94</b> is of greater size than the data segment <b>92</b> by the overhead rate of the encoding algorithm by a factor of X/T, where X is the width or number of slices, and T is the read threshold. In this regard, the corresponding decoding process can accommodate at most X&#x2212;T missing EC data slices and still recreate the data segment <b>92</b>. For example, if X=16 and T=10, then the data segment <b>92</b> will be recoverable as long as 10 or more EC data slices per segment are not corrupted.</p>
<p id="p-0085" num="0086">The slicer <b>79</b> transforms the encoded data segment <b>94</b> into EC data slices in accordance with the slicing parameter from the vault for this user and/or data segment <b>92</b>. For example, if the slicing parameter is X=16, then the slicer <b>79</b> slices each encoded data segment <b>94</b> into 16 encoded slices.</p>
<p id="p-0086" num="0087">The post-slice manipulator <b>81</b> performs, if enabled, post-manipulation on the encoded slices to produce the EC data slices. If enabled, the post-slice manipulator <b>81</b> determines the type of post-manipulation, which may be based on a computing system-wide predetermination, parameters in the vault for this user, a table lookup, the user identification, the type of data, security requirements, available DSN memory, performance requirements, control unit directed, and/or other metadata. Note that the type of post-slice manipulation may include slice level compression, signatures, encryption, CRC, addressing, watermarking, tagging, adding metadata, and/or other manipulation to improve the effectiveness of the computing system.</p>
<p id="p-0087" num="0088">In an example of a read operation, the post-slice de-manipulator <b>89</b> receives at least a read threshold number of EC data slices and performs the inverse function of the post-slice manipulator <b>81</b> to produce a plurality of encoded slices. The de-slicer <b>87</b> de-slices the encoded slices to produce an encoded data segment <b>94</b>. The decoder <b>85</b> performs the inverse function of the encoder <b>77</b> to recapture the data segment <b>90</b>-<b>92</b>. The pre-slice de-manipulator <b>83</b> performs the inverse function of the pre-slice manipulator <b>75</b> to recapture the data segment <b>90</b>-<b>92</b>.</p>
<p id="p-0088" num="0089"><figref idref="DRAWINGS">FIG. 5</figref> is a diagram of an example of slicing an encoded data segment <b>94</b> by the slicer <b>79</b>. In this example, the encoded data segment <b>94</b> includes thirty-two bits, but may include more or less bits. The slicer <b>79</b> disperses the bits of the encoded data segment <b>94</b> across the EC data slices in a pattern as shown. As such, each EC data slice does not include consecutive bits of the data segment <b>94</b> reducing the impact of consecutive bit failures on data recovery. For example, if EC data slice <b>2</b> (which includes bits <b>1</b>, <b>5</b>, <b>9</b>, <b>13</b>, <b>17</b>, <b>25</b>, and <b>29</b>) is unavailable (e.g., lost, inaccessible, or corrupted), the data segment can be reconstructed from the other EC data slices (e.g., 1, 3 and 4 for a read threshold of 3 and a width of 4).</p>
<p id="p-0089" num="0090"><figref idref="DRAWINGS">FIG. 6</figref> is a flowchart illustrating an example of managing a memory device. The method begins with step <b>102</b> where a processing module determines whether a memory device of a dispersed storage (DS) unit is unavailable to produce an unavailable memory device. Such a determination may be based on one or more of a query, an indicator that the memory device has been physically removed, an error message, a plurality of error messages, a power indicator, a command, a message, and a failure indicator.</p>
<p id="p-0090" num="0091">When the memory device is unavailable, the method continues at step <b>104</b> where the processing module determines a methodology regarding DS encoded data stored in the unavailable memory device based on one or more dispersed storage network (DSN) conditions to produce a determined methodology. Such one or more DSN conditions includes at least one of a decode threshold and pillar width ratio, a number of DS units in a vault that are unavailable, network traffic, and a priority level of the DS encoded data. Such a methodology includes waiting for the unavailable memory device to become available again (e.g., repaired) and rebuilding the DS encoded data after a time period to produce rebuilt DS encoded data and storing the rebuilt DS encoded data in one or more other available memory devices (e.g., a hot-standby memory device and/or a plurality of portions of a plurality of other memory devices of the available memory devices). The method continues to step <b>106</b> when the determined methodology includes waiting for the memory device to become available. The method branches to step <b>110</b> when the determined methodology includes a rebuilding component.</p>
<p id="p-0091" num="0092">The method continues at step <b>106</b> where the processing module waits for the memory device to become available by determining whether the unavailable memory device is now available when the determined methodology includes waiting for the memory device to become available. The method repeats to step <b>106</b> when the processing module determines that the unavailable memory device is not available. The method continues to step <b>108</b> when the processing module determines that the unavailable memory is now available. The method continues at step <b>108</b> where the processing module changes the status of the memory device from unavailable to available when the unavailable memory device becomes available.</p>
<p id="p-0092" num="0093">The method continues at step <b>110</b> where the processing module establishes a time period based on the one or more DSN conditions when the determined methodology includes the rebuilding component and determines whether the time period expires. For example, the processing module establishes the time period to be two days in accordance with the determined methodology, including avoiding utilizing network bandwidth to rebuild the DS encoded data. The method repeats to step <b>110</b> when the processing module determines that the time period has not expired. The method continues to step <b>112</b> when the processing module determines the time period has expired.</p>
<p id="p-0093" num="0094">The method continues at step <b>112</b> where the processing module determines a memory type to utilize by determining whether a DS unit includes a hot-standby memory device. Such a determination may be based on one or more of a query, a message, a registry, a list, a lookup, a command, and a request. When the DS unit includes the hot-standby memory device, the processing module determines, in accordance with the determined methodology, whether to use the hot-standby memory device, wherein available memory of the DS unit includes the hot-standby memory device. The method branches to step <b>118</b> when the processing module determines to utilize available memory (e.g., other than the hot-standby memory device). The method continues to step <b>114</b> when the processing module determines to utilize the hot-standby memory device.</p>
<p id="p-0094" num="0095">The method continues at step <b>114</b> where the processing module reassigns a slice name range associated with the unavailable memory device to the hot-standby memory device prior to the storing rebuilt DS encoded data when the hot-standby memory device is to be used. Such reassigning of the slice name range includes updating the slice name range in a memory device table from the unavailable memory device to the hot-standby memory device.</p>
<p id="p-0095" num="0096">The method continues at step <b>116</b> where the processing module initiates, in accordance with the determined methodology, a rebuilding function to rebuild the DS encoded data to produce rebuilt DS encoded data and storing the rebuilt DS encoded data within the hot-standby memory device of the DS unit. Such a rebuilding function may include at least one of executing the rebuilding function to rebuild the DS encoded data and requesting execution of the rebuilding function to rebuild the DS encoded data (e.g., sending a rebuilding request message to at least one of a storage integrity processing unit, a DS processing unit, and a DS unit).</p>
<p id="p-0096" num="0097">The method continues to step <b>118</b> where the processing module reassigns the slice name range associated with the unavailable memory device to the available memory of the DS unit prior to the storing the rebuilt DS encoded data when the available memory is to be used. Such reassigning of the slice name range includes at least one of updating the slice name range in the memory device table from the unavailable memory device to the available memory of the DS unit and when the available memory of the DS unit includes a plurality of memory devices, partitioning the slice name range into a plurality of slice name range partitions and assigning one of the plurality of slice name range partitions to one of the plurality of memory devices and updating a status indicator of the unavailable memory (e.g., changing a status from assigned to an assigned). Such partitioning of the slice name ranges may be based on one or more of slice name address range indicators for the plurality of memory devices, available capacity indicators for the plurality of memory devices, a slice redistribution policy, a slice storage requirement, a performance indicator, a security indicator, a priority indicator, and an estimation of performance.</p>
<p id="p-0097" num="0098">The method continues at step <b>120</b> where the processing module initiates the rebuilding function and stores the rebuilt DS encoded data within available memory of the DS unit. The method continues at step <b>122</b> where the processing module determines whether to transfer the rebuilt DS encoded data from the available memory of the DS unit to an additional memory of the DS unit. Such additional memory of the DS unit may include at least one of refurbished memory and new memory. Such a determination may be based on one or more of a memory capacity indicator associated with the additional memory, a performance indicator associated with the additional memory, a message, a request, and a command. For example, the processing module determines to transfer the rebuilt DS encoded data from the available memory to the additional memory when a new memory is detected and a capacity indicator associated with the new memory compares favorably to an amount of rebuilt DS encoded data. The method repeats back to step <b>122</b> when the processing module determines to not transfer the rebuilt DS encoded data. The method continues to step <b>124</b> when the processing module determines to transfer the rebuilt DS encoded data.</p>
<p id="p-0098" num="0099">The method continues at step <b>124</b> where the processing module reassigns a slice name range associated with the available memory of the DS unit to the additional memory when the rebuilt DS encoded data is to be transferred from the available memory of the DS unit to the additional memory. The method continues at step <b>126</b> where the processing module transfers the rebuilt DS encoded data from the available memory of the DS unit to the additional memory. In addition, the processing module may delete the rebuilt DS encoded data from the available memory when the rebuilt DS encoded data is successfully stored in the additional memory.</p>
<p id="p-0099" num="0100"><figref idref="DRAWINGS">FIG. 7</figref> A is a flowchart illustrating an example of authorizing an access request. The method begins with step <b>136</b> where a processing module receives an access request. Such an access request may include one or more of a user identifier (ID), an access type (e.g., read, write, delete, list, list range, check, etc.), a user password, a user realm indicator, a command, a data object name, a data object, a virtual dispersed storage network (DSN) address, a performance indicator, a priority indicator, a security indicator, access request requirements, a vault ID, a DSN system element access request, a DSN resource request, a vault access request, and a record access request. The processing module may receive the access request from one or more of a user device, the dispersed storage (DS) processing unit, a storage integrity processing unit, a DS managing unit, and a DS unit.</p>
<p id="p-0100" num="0101">The method continues at step <b>138</b> where the processing module determines the realm. Such a realm indicates an affiliation of one or more user devices/users. For example, the realm indicates a group associated with a particular organization (e.g., a company, a team, a family, a work group, a social group, a community, a geographic region, etc.). Such a determination of the realm may be based on one or more of user information, realm information, an authorization table lookup, a received realm indicator, a user ID, a user password, a vault lookup, a table lookup, and any other information from the access request.</p>
<p id="p-0101" num="0102">The method continues at step <b>140</b> where the processing module determines an authorization service. Such an authorization service indicates an identity and/or address to provide subsequent authorization of the access request. For example, the processing module identifies the authorization service to include a third-party, which may or may not be part of the DSN computing system. Such a third-party may provide authorization information (e.g., if a user or group is allowed to perform a particular type of DSN computing system access). Such a determination of the authorization service may be based on one or more of information associated with the realm, an authorization table lookup, a vault lookup, a user ID, a user password, and information received in the access request.</p>
<p id="p-0102" num="0103">The method continues at step <b>142</b> where the processing module generates an authorization request and sends the authorization request to the authorization service. Such an authorization request may include one or more of the user ID, a user password, user information, the user realm information, a command, the data object name, a virtual DSN address, and a DS processing module ID. The method continues at step <b>144</b> where the processing module receives an authorization request response from the authorization service. The method continues at step <b>146</b> where the processing module determines whether the request is authorized based on the authorization request response. The method ends at step <b>148</b> where the processing module sends a reject message when the processing module determines that the request is not authorized. The processing module may send the reject message to the requester and/or the DS managing unit. The method continues to step <b>150</b> when the processing module determines that the request is authorized. The method continues at step <b>150</b> where the processing module processes the access request (e.g., processes a command including store, retrieve, delete, list, etc.).</p>
<p id="p-0103" num="0104"><figref idref="DRAWINGS">FIG. 7</figref> B is a diagram illustrating an example of an authorization table <b>152</b>. Such an authorization table <b>152</b> may be utilized by a processing module to determine an authorization service based on user information as discussed with reference to the method of <figref idref="DRAWINGS">FIG. 7</figref> A. Such an authorization table <b>152</b> may be stored in one or more of a dispersed storage (DS) unit, a DS managing unit, a storage integrity processing unit, a user device, and a DS processing unit. In an example, the DS managing unit generates the authorization table <b>152</b> and sends the information of the authorization table <b>152</b> to the DS unit for storage and ongoing use to authorize access requests.</p>
<p id="p-0104" num="0105">Such an authorization table and <b>52</b> includes a user information field <b>154</b>, a realm field <b>156</b>, and an authorization service field <b>158</b>. The user information field <b>154</b> includes identities of one or more users and/or user devices associated, wherein each user is associated with a particular realm. For example, an e-mail address may be utilized to uniquely identify a user and/or user device. The realm field <b>156</b> includes group identities associated with the one or more users. For example, a realm entry identifies a domain of an e-mail address such that a shared affiliation is a common e-mail domain (e.g., a company, an organization, etc.). The authorization service field <b>158</b> includes an identity and address of an associated authorization service corresponding to a realm. For example, an entry of the authorization service field <b>158</b> indicates an Internet address that may be utilized to send an authorization request to and receive a corresponding authorization request response.</p>
<p id="p-0105" num="0106">In an example of operation, an e-mail address of joew@cleversafe.com is utilized to index into the authorization table <b>152</b> by matching e-mail address to an entry of the user information field <b>154</b>. An associated realm of cleversafe.com is extracted from the realm field <b>156</b> based on a corresponding e-mail address entry matched to an entry of the associated realm. Next, an authorization service address of ldaps.cleversafe.com is extracted from the authorization service field <b>158</b> based on the corresponding e-mail address entry matched to an entry of the associated authorization service. An access request authorization message is sent to the ldaps.cleversafe.com address to determine whether an associated access request is authorized.</p>
<p id="p-0106" num="0107"><figref idref="DRAWINGS">FIG. 8</figref> A is a diagram illustrating an example of a memory utilization map sequence that includes a sequence of memory utilization map states <b>162</b>-<b>166</b>. Each memory utilization map state of the memory utilization map states <b>162</b>-<b>166</b> represents a memory utilization level <b>160</b> (e.g., 0, 1, 2, 3, 4 terabytes (TB)) of a plurality of memory devices <b>1</b>-<b>4</b> corresponding to a state of memory utilization of the sequence of memory utilization map states <b>162</b>-<b>166</b>. Such memory devices <b>1</b>-<b>4</b> include memory devices (e.g., Flash memory, random access memory, magnetic disk drive memory, etc.) within one of a common dispersed storage (DS) unit and two or more DS units. For example, memory devices <b>1</b>-<b>4</b> are implemented in DS unit <b>1</b>. In another example, memory devices <b>1</b>-<b>2</b> are implemented in DS unit <b>1</b> and memory devices <b>3</b>-<b>4</b> are implemented in DS unit <b>2</b>. As yet another example, memory device <b>1</b> is implemented in DS unit <b>1</b>, memory device <b>2</b> is implemented in DS unit <b>2</b>, memory device <b>3</b> is implemented in DS unit <b>3</b>, and memory device <b>4</b> is implemented in DS unit <b>4</b>.</p>
<p id="p-0107" num="0108">Encoded data slices corresponding to a slice name range <b>161</b> (e.g., <b>125</b>-<b>185</b>) are stored in the memory devices <b>1</b>-<b>4</b> in accordance with slice name ranges associated with each memory device of the memory devices <b>1</b>-<b>4</b>. Such a slice name range <b>161</b> includes (m&#x2212;1) address boundaries to form the slice name ranges associated with each memory device of the memory devices <b>1</b>-<b>4</b>, wherein m=a number of memory devices <b>1</b>-<b>4</b>. For instance, 3 address boundaries form the slice name ranges associated with each memory device when there are 4 memory devices. Such address boundaries may be determined based on one or more of a memory balancing function, a memory balancing goal, an impact threshold, a memory utilization map state, previous address boundaries, a number of memory devices, a memory utilization level of each of the memory devices <b>1</b>-<b>4</b> (e.g., the utilization level rises as more encoded data slices are stored), and the slice name range <b>125</b>-<b>185</b>.</p>
<p id="p-0108" num="0109">Such a sequence of memory utilization map states <b>162</b>-<b>166</b> may correspond to an initial state <b>162</b>, a balanced state <b>166</b>, and one or more intermediate states <b>163</b>-<b>165</b>. Such an initial state <b>162</b> represents a memory utilization map state when memory devices <b>1</b>-<b>4</b> are initially assigned to the slice name range <b>161</b> (e.g., memory devices <b>1</b>-<b>4</b> are unutilized and assigned). Such a balanced state <b>166</b> represents a memory utilization map state when memory devices <b>1</b>-<b>4</b> are utilized and balanced as a result of applying the memory balancing function. Such intermediate states <b>163</b>-<b>165</b> includes an unbalanced state <b>163</b> and may include one or more intermediate steps (e.g., step 1 state <b>164</b>, step 2 state <b>165</b>) in application of the memory balancing function to transition the memory devices <b>1</b>-<b>4</b> from the unbalanced state <b>163</b> to the balanced state <b>166</b>). Such an unbalanced state <b>163</b> represents a memory utilization map state when memory devices <b>1</b>-<b>4</b> are utilized and unbalanced as a result of storing encoded data slices in accordance with address boundaries associated with the initial state <b>162</b>.</p>
<p id="p-0109" num="0110">Such a memory balancing function results in a memory utilization level of each memory device of the memory devices <b>1</b>-<b>4</b> being substantially the same (e.g., balanced state <b>166</b>). Such a memory balancing function may be applied to the memory devices <b>1</b>-<b>4</b> by modifying the address boundaries associated with the address range <b>161</b> to produce modified slice name ranges of at least two the memory devices <b>1</b>-<b>4</b> and transferring encoded data slices from one memory device to another memory device in accordance with the modified slice name ranges. The memory balancing function may be applied in one or more steps to transition from the unbalanced state <b>163</b> to the memory state <b>166</b>.</p>
<p id="p-0110" num="0111">In an example of operation, address boundaries of 140, 155, and 170 form slice name ranges for each memory device of memory devices <b>1</b>-<b>4</b>, when the memory devices <b>1</b>-<b>4</b> are assigned in the initial state <b>162</b>. For instance, encoded data slices corresponding to a slice name range of 125-140 are stored in memory device <b>1</b>, encoded data slices corresponding to a slice name range of 140-155 are stored in memory device <b>2</b>, encoded data slices corresponding to a slice name range of 155-170 are stored in memory device <b>3</b>, and encoded data slices corresponding to a slice name range of 170-185 are stored in memory device <b>4</b>. Encoded data slices are stored in the memory devices <b>1</b>-<b>4</b> in accordance with the slice name ranges of each of the memory devices <b>1</b>-<b>4</b>. For instance, 4 TB of encoded data slices are stored in memory device <b>1</b>, 2 TB of encoded data slices are stored in memory device <b>2</b>, 1 TB of encoded data slices are stored in memory device <b>3</b>, and 3 TB of encoded data slices are stored in memory device <b>4</b> when the memory utilization map produces the unbalanced state <b>163</b>.</p>
<p id="p-0111" num="0112">In the example of operation continued, the memory balancing function is applied such that an address boundary between memory device <b>3</b> and memory device <b>4</b> is modified from 170 to 175 to produce a modified slice name range of 155-175 for memory device <b>3</b> and a modified slice name range of 175-185 for memory device <b>4</b>. Encoded data slices associated with slice name addresses <b>170</b>-<b>175</b> are transferred from memory device <b>4</b> to memory device <b>3</b> such that memory device <b>3</b> and memory device <b>4</b> are each associated with a utilization level of 2 TB. Such an encoded data slice transfer and modified slice name ranges results in step 1 state <b>164</b>.</p>
<p id="p-0112" num="0113">Continuing with the example of operation, the memory balancing function is applied such that an address boundary between memory device <b>1</b> and memory device <b>2</b> is modified from 140 to 135 to produce a modified slice name range of 125-135 for memory device <b>1</b> and a modified slice name range of 135-155 for memory device <b>2</b>. Encoded data slices associated with slice name addresses <b>135</b>-<b>140</b> are transferred from memory device <b>1</b> to memory device <b>2</b> such that memory device <b>1</b> and memory device <b>2</b> are each associated with a utilization level of 3 TB. Such an encoded data slice transfer and modified slice name ranges results in step 2 state <b>165</b>. Next, the memory balancing function is further applied and may include more steps resulting in more intermediate states to reach the balanced state <b>166</b> where each memory device is associated with a utilization level of 2.5 TB.</p>
<p id="p-0113" num="0114">In another example of operation, the memory balancing function is applied to the memory devices in the unbalanced state <b>163</b> to move directly to the balanced state <b>166</b> (e.g., without moving through one or more intermediate states <b>164</b>-<b>165</b>). The method of operation of the balancing function is discussed in greater detail with reference to <figref idref="DRAWINGS">FIG. 8</figref> B.</p>
<p id="p-0114" num="0115"><figref idref="DRAWINGS">FIG. 8</figref> B is a flowchart illustrating an example of balancing memory utilization. The method begins with step <b>168</b> where processing module identifies a memory loading mismatch between two or more memory devices of a plurality of memory devices of a dispersed storage (DS) unit, wherein each of the plurality of memory devices is assigned a range of slice names to provide a plurality of assigned ranges of slice names. For example, processing module identifies a memory loading mismatch between a first memory device and a second memory device of the DS unit, wherein the first memory device is assigned a first range of slice names and the second memory device is assigned a second range of slice names.</p>
<p id="p-0115" num="0116">Such identifying of the memory loading mismatch includes at least one of determining a utilized amount of storage for each of the plurality of memory devices (e.g., based on one or more of a query, a list, a ping, a message, a command, an error message, and a lookup), determining an unutilized amount of storage for each of the plurality of memory devices, determining a utilization percentage of storage capacity for each of the plurality of memory devices, determining an unutilized percentage of storage capacity for each of the plurality of memory devices, and determining a storage balancing factor for a group of encoded data slices associated with at least one of a priority indicator, a security indicator, a performance indicator, a user identifier, and a vault identifier. Alternatively, or addition to, such identifying of the memory loading mismatch includes at least one of determining a utilized amount of storage for each of the first and second memory devices, determining an unutilized amount of storage for each of the first and second memory devices, determining a utilization percentage of storage capacity for each of the first and second memory devices, and determining an unutilized percentage of storage capacity for each of the first and second memory devices when the memory loading mismatch is to be identified between the first memory device and the second memory device.</p>
<p id="p-0116" num="0117">The method continues at step <b>170</b> where the processing module determines an estimated impact to reduce the memory loading mismatch. Such determining of the estimated impact comprises at least one of determining a financial impact based on one or more of a cost level and a revenue gain/loss level, determining a processing resource impact based on one or more of a memory capacity extension time period, a balancing execution time period, a performance level, a wide area network bandwidth utilization level to execute load balancing, and a local area network bandwidth utilization level to execute the load balancing, determining an accessibility impact based on one or more of a wide area network bandwidth availability level, a local area network bandwidth availability level, a memory unavailability time period, and balancing execution time, and determining a user impact based on one or more of a security level, a priority level, an associated user identifier (ID), and an associated vault ID.</p>
<p id="p-0117" num="0118">The method continues at step <b>172</b> where the processing module determines whether the estimated impact compares favorably to an impact threshold. For example, the processing module determines that the estimated impact compares favorably to the impact threshold when the balancing execution time is less than the impact threshold. As another example, the processing module determines that the estimated impact compares favorably to the impact threshold when the revenue gain is greater than the impact threshold. The method repeats back to step <b>168</b> when the processing module determines that the estimated impact compares unfavorably to the impact threshold. The method continues to step <b>174</b> when the processing module determines that the estimated impact compares favorably to the impact threshold.</p>
<p id="p-0118" num="0119">The method continues at step <b>174</b> where the processing module modifies at least two of the plurality of assigned ranges of slices names to produce a modified plurality of assigned ranges of slice names for the plurality of memory devices based on the memory loading mismatch when the estimated impact compares favorably to an impact threshold. For example, processing module modifies the first and second ranges of slices names to produce a first modified range of slice names for the first memory device and a second modified range of slice names for the second memory device based on the memory loading mismatch.</p>
<p id="p-0119" num="0120">Such modifying of the at least two of the plurality of assigned ranges of slices names includes de-assigning a first range of slice names from a first memory device of the at least two memory devices and a second range of slice names from a second memory device of the at least two memory devices to create an unassigned range of slice names and partitioning the unassigned range of slices names to approximately balance (e.g., same utilization level) loading of the first and second memory devices to produce the modified plurality of assigned ranges of slice names. For example, the processing module modifies the first and second ranges of slice names to include de-assigning the first and second ranges of slice names from the first and second memory devices to create the unassigned range of slice names and partitioning the unassigned range of slices names to approximately balance loading of the first and second memory devices to produce first and second modified ranges of slice names.</p>
<p id="p-0120" num="0121">The method continues at step <b>176</b> where the processing module transfers one or more encoded data slices between two or more memory devices of the plurality of memory devices in accordance with the modified plurality of assigned ranges of slice names. Alternatively, or in addition to, the processing module transfers one or more encoded data slices between the first and second memory devices in accordance with the first and second modified ranges of slice names.</p>
<p id="p-0121" num="0122"><figref idref="DRAWINGS">FIG. 9</figref> A is a flowchart illustrating an example of managing memory usage. The method begins with step <b>178</b> where a processing module receives usage information for a vault. Such usage information pertains to one or more users and/or user devices associated with the vault and may include one or more of a utilization storage volume, a utilization percentage of allocated storage, a utilization percentage of all storage, and a utilization comparison to at least one other vault. The processing module may receive the usage information from one or more of a dispersed storage (DS) unit, a user device, a storage integrity processing unit, a DS processing unit, and a DS managing unit. The processing module receives the usage information based on one or more of a response to a query, as an unsolicited message, from time to time, subsequent to a dispersed storage network (DSN) memory access, and a command from a DS managing unit. For example, the processing module sends a query to DS units <b>1</b>-<b>5</b> and receives the utilization storage volume usage information for vault <b>102</b> from DS units <b>1</b>-<b>5</b> of a DS unit storage set assigned to vault <b>102</b>.</p>
<p id="p-0122" num="0123">The method continues at step <b>180</b> where the processing module aggregates the usage information to produce aggregated usage information based on one or more of user device identifier (ID), a user ID, a vault ID, a predefined group, a realm, a geography, a DS unit storage set, and a DS unit. For example, the processing module aggregates the usage information from DS units <b>1</b>-<b>5</b> for vault <b>102</b> to produce aggregated usage information corresponding to vault <b>102</b>.</p>
<p id="p-0123" num="0124">The method continues at step <b>182</b> where the processing module sends at least one of the usage information and the aggregated usage information to one or more of a user device, a DS processing unit, a storage integrity processing unit, a DS unit, and a DS managing unit. For example, the processing module sends aggregated usage information to user device <b>457</b> when user device <b>457</b> is affiliated with vault <b>102</b>. The method continues at step <b>184</b> where the processing module determines whether the aggregated usage information for user device <b>457</b> compares favorably to a hard quota. Such a hard quota may specify a usage information value such that action is required (e.g., preventing incremental storage usage). The processing module may obtain the hard quota based on one or more of a vault lookup, a hard quota list, a predetermination, DSN memory usage information, a dynamic value based in part on overall DSN memory usage information, an error message, and a command. For example, the comparison is favorable when the aggregated usage information (e.g., 2 terabytes) is less than the hard quota (e.g., 5 terabytes). The method repeats back to step <b>178</b> when the processing module determines that the usage information compares favorably to the hard quota. The method continues to step <b>186</b> when the processing module determines that the usage information compares unfavorably to the hard quota.</p>
<p id="p-0124" num="0125">The method continues with step <b>186</b> where the processing module disables write permissions for the corresponding vault. Such disabling of write permissions curtails further usage of the DSN memory storage facilities. Such disabling of the write permissions may be executed by one or more of a registry update, a user vault update, a table update, sending a message to the DS managing unit, and sending a message to the user device. The method continues at step <b>188</b> where the processing module sends a write permissions message to one or more DS units affiliated with the vault. Such write permissions message may include one or more of a vault ID, one or more user device IDs, one or more user IDs, a message indicating that the write permissions are disabled for the vault ID, aggregated usage information, and usage information.</p>
<p id="p-0125" num="0126">Alternatively, or in addition to, processing module may from time to time re-determine if the usage information compares favorably to the hard quota. Next, the processing module enables the write permissions for the vault when the comparison is favorable. For example, encoded data slices corresponding to the vault are deleted enabling the comparison to be favorable when the hard quota is substantially the same as a previous hard quota. In another example, a value associated with the hard quota is raised enabling the comparison to be favorable.</p>
<p id="p-0126" num="0127"><figref idref="DRAWINGS">FIG. 9</figref> B is a flowchart illustrating another example of managing memory usage. The method begins with step <b>190</b> where a processing module determines to store data. For example, the processing module determines to store a data object. As another example, the processing module determines to store an encoded data slice. Such a determination to store data may be based on one or more of a user input, a storage algorithm, an application output, a message, a predetermination, and a command.</p>
<p id="p-0127" num="0128">The method continues at step <b>192</b> where the processing module determines usage information. Such a determination may be based on one or more of retrieving locally stored usage information, retrieval from a dispersed storage (DS) processing unit, retrieval from a DS managing unit, a query, a message, and command. For example, the processing module saves usage information locally (e.g., within a user device). For instance, the processing module retrieves locally stored usage information to determine that the user device has stored 1.5 terabytes of data so far in a dispersed storage network (DSN) memory.</p>
<p id="p-0128" num="0129">The method continues at step <b>194</b> where the processing module determines whether the usage information compares favorably to a soft quota. Such a soft quota may specify a usage information value such that action is required (e.g., preventing incremental storage usage). The processing module may obtain the soft quota based on one or more of a vault lookup, a soft quota list, a predetermination, DSN memory usage information, a dynamic value based in part on overall DSN memory usage information, an error message, and a command. For example, the processing module determines that the usage information compares unfavorably to the soft quota when the usage information includes 1.5 terabytes of storage utilization and the soft quota is 1.0 terabytes.</p>
<p id="p-0129" num="0130">The method branches to step <b>198</b> when the processing module determines that the usage information compares favorably to the soft quota. The method ends at step <b>196</b> where the processing module rejects the store operation when the processing module determines that the usage information compares unfavorably to the soft quota. Such rejecting of the store operation includes one or more of sending a message to a requester, sending a message to a DS managing unit, sending a message to a DS processing unit, and preventing further store operations until the comparison is favorable. The method continues at step <b>198</b> where the processing module sends data to store when the processing module determines that the usage information compares favorably to the soft quota. For example, the processing module sends the data object to a DS processing unit for storage in a DSN memory.</p>
<p id="p-0130" num="0131"><figref idref="DRAWINGS">FIG. 9</figref> C is a flowchart illustrating another example of managing memory usage. The method begins with step <b>200</b> where a processing module receives a write slice request (e.g., a request to store a slice). Such a write slice request may include one or more of a vault identifier (ID), a user ID, a source name, a slice name, a write command, a priority indicator, a performance indicator, a security indicator, and an encoded data slice. The processing module may receive the write slice request from one or more of a user device, a dispersed storage (DS) processing unit, a storage integrity processing unit, a DS managing unit and another DS unit.</p>
<p id="p-0131" num="0132">The method continues at step <b>202</b> where the processing module determines whether an associated vault of the write slice request is allowed write permissions. Such a determination may be based on one or more of a received vault ID, a write permissions table lookup utilizing the vault ID as an index, a user ID, a source name, a slice name, an encoded data slice, a priority indicator, a performance indicator, a security indicator, a message, a query, and a command. For example, the processing module determines the write permission is not allowed based on the write permissions table lookup for vault <b>102</b> when a write slice request is associated with the vault <b>102</b>. The method branches to step <b>206</b> when the processing module determines that the vault is allowed write permissions. The method continues to step <b>204</b> when the processing module determines that the vault is not allowed write permissions.</p>
<p id="p-0132" num="0133">The method continues at step <b>204</b> where the processing module rejects the write slice request when the processing module determines that the write permission is not allowed. Such rejecting of the write slice request includes one or more of sending a message to a requester, sending a message to a DS managing unit, sending a message to a DS processing unit, and preventing further processing of write slice requests for this vault. The method continues at step <b>206</b> where the processing module processes the write slice request (e.g., storing an associated encoded data slice in memory) when the processing module determines that the vault is allowed write permissions.</p>
<p id="p-0133" num="0134"><figref idref="DRAWINGS">FIG. 10</figref> A is a diagram illustrating an example of a user role table <b>208</b> that may be utilized to stratify dispersed storage network (DSN) system users into roles for authorization purposes. Such a user role table <b>208</b> includes a user field <b>210</b> and a role field <b>212</b>. The user field <b>210</b> and the role field <b>212</b> may include any number of entries. Such an entry of the user field <b>210</b> may be associated with two or more different entries of the role field <b>212</b>. Such an entry of the role field <b>212</b> may be associated with two or more different entries of the user field <b>210</b>. Such entries of the user field <b>210</b> include identifiers to identify one or more of a user, a user device, a dispersed storage (DS) processing module, a storage integrity processing unit, a DS managing unit, and a DS unit. Such entries of the role field <b>212</b> include level identifiers to identify predetermined authorized roles with respect to operation of the DSN system.</p>
<p id="p-0134" num="0135">The user role table <b>208</b> may be utilized by one or more of a user device, a DS processing unit, a storage integrity processing unit, a DS managing unit, and a DS unit to determine a role of a user with respect to the DSN system. For example, a processing module of a DS processing unit may receive a request from user <b>831</b> to access contents of a vault. The processing module determines the role of user <b>831</b> to be a vault user based on a lookup of the user role table <b>208</b> utilizing user <b>831</b> as an index.</p>
<p id="p-0135" num="0136"><figref idref="DRAWINGS">FIG. 10</figref> B is a diagram illustrating an example of a role permissions table <b>214</b> that may be utilized to determine permissions for authorization purposes. Such a role permissions table <b>214</b> includes a role field <b>212</b> and a permissions field <b>216</b>. The role field is as previously described with reference to <figref idref="DRAWINGS">FIG. 10</figref> A, wherein an entry of the role field <b>212</b> is associated with an entry of the permissions field <b>216</b>. Such a permissions field <b>216</b> includes any number of permissions entries, wherein each permissions entry indicates permitted activities associated with a corresponding role entry of the role field <b>212</b>. Such a permissions entry of the permissions entries may be associated with two or more different entries of the role field <b>212</b>.</p>
<p id="p-0136" num="0137">Such a permissions entry of the permissions field <b>216</b> indicates permitted activities for a corresponding role entry of the role field <b>212</b>. Alternatively, or in addition to, the permissions entry of the permissions field <b>216</b> indicates non-permitted activities for the corresponding role entry of the role field <b>212</b>. For example, the role permissions table <b>214</b> indicates that a super user role does not have permissions to write to or read from a vault but does have permissions to execute any other operations except for writing and reading to and from a vault. As another example, the role permissions table <b>214</b> indicates that a system administrator role as permissions to read and write from any vault, perform account management operations (e.g., activating users, activating vaults, billing, usage summary generation), but does not have permissions to perform any security operations (e.g., change security parameters such as which user has access to what data, security policies, network element activation, permissions). As yet another example, the role permissions table <b>214</b> indicates that a security officer role has permissions to perform security account manager operations. As a further example, the role permissions table <b>214</b> indicates that an operator role has permissions to execute performance monitoring functions (e.g., an operator of the DSN system may monitor the performance and utilization of the DSN system including encoded data slice retrieval monitoring, activity monitoring, throughput, failures, resource utilization, network use, central processing unit use, device load etc.). As yet a further example, the role permissions table <b>214</b> indicates that a vault user role has permissions to read from and/or write to a vault with no other allowed permissions. The method of utilization of the user role table <b>208</b> and the role permissions table <b>214</b> is discussed in greater detail with reference to <figref idref="DRAWINGS">FIG. 10</figref> C.</p>
<p id="p-0137" num="0138"><figref idref="DRAWINGS">FIG. 10</figref> C is a flowchart illustrating another example of authorizing an access request, which includes some of steps to <b>7</b> A. The method begins with step <b>136</b> of <figref idref="DRAWINGS">FIG. 7</figref> A where a processing module receives an access request. The method continues at step <b>220</b> where the processing module determines a user identifier (ID) associated with the access request. Such a determination may be based on one or more of a received user identifier (ID), a vault ID, information contained in the request, a vault lookup, a table lookup, a predetermination, a message, a message, and a command.</p>
<p id="p-0138" num="0139">The method continues at step <b>222</b> where the processing module determines a role associated with the user ID. Such a determination may be based on one or more of the user ID, a user role table lookup, information received, a request, a message, a query, a vault lookup, a predetermination, and command. For example, the processing module determines the role to be a security officer when the processing module utilizes a received user ID of 236 as an index to lookup the role in the user role table.</p>
<p id="p-0139" num="0140">The method continues at step <b>224</b> where the processing module determines permissions associated with the role. Such a determination may be based on one or more of the user ID, a vault ID, information contained in the request, the role, a role permissions table lookup, a query, a vault lookup, a table lookup, a predetermination, and a command. For example, the processing module determines the permissions to include security account manager functions when the processing module utilizes the security officer role as an index to lookup the permissions in the role permissions table lookup.</p>
<p id="p-0140" num="0141">The method continues at step <b>226</b> where the processing module determines whether the user ID is allowed to perform access request actions associated with the access request. Such a determination may be based on a comparison of the request to the permissions. For example, the processing module determines that the user is allowed when the processing compares a security record access request to the determined security account manager permissions. As another example, the processing module determines that the user is not allowed when the processing compares a security record access request to a determined vault write request. The method branches to step <b>230</b> when the processing module determines that the user ID is allowed. The method continues to step <b>228</b> when the processing module determines that the user ID is not allowed.</p>
<p id="p-0141" num="0142">The method continues at step <b>228</b> where the processing module rejects the request when the processing module determines that the user is not allowed. Such rejecting of the request includes sending a reject message to one or more of a user device, a DS managing unit, a DS processing unit, a storage integrity processing unit, and a DS unit. Such a reject message includes access request information based on the access request and a reject status indicator. The method continues at step <b>230</b> where the processing module processes the access request (e.g., allowing access to DSN system resources) when the processing module determines that the user ID is allowed.</p>
<p id="p-0142" num="0143"><figref idref="DRAWINGS">FIG. 11</figref> is a flowchart illustrating an example of retrieving data. The method begins with step <b>232</b> where processing module receives a retrieve data message from a requester to retrieve data (e.g., a user device, a dispersed storage (DS) processing module, a storage integrity processing unit, a DS managing unit, and a DS unit). Such a retrieve data message may include one or more of a user identifier (ID), a user device ID, a request code, a date ID, a data object name, a data file name, a source name, a data type indicator, a data object hash, a vault ID, a data size indicator, a performance indicator, a priority indicator, a security indicator, a storage requirement, a consistency requirement, and a retrieval threshold requirement.</p>
<p id="p-0143" num="0144">The method continues at step <b>234</b> where the processing module determines DS unit storage set of a dispersed storage network (DSN), wherein the DS unit storage set stores a plurality of sets of encoded data slices corresponding to the data. Such a determination may be based on one or more of information received in the retrieve data message, metadata associated with the data, a message, a predetermination, and a virtual DSN address to physical location table lookup. For example, the processing module determines at least one set of slice names associated with the data based on the user ID, the vault ID, and the data ID. Next, the processing module looks up identifiers associated with the DS unit storage set in the virtual DSN address to physical location table based on the at least one set of slice names.</p>
<p id="p-0144" num="0145">At step <b>234</b>, the processing module determines error coding dispersal storage function parameters. Such parameters of the error coding dispersal storage function parameters includes a pillar width, a write threshold, a consistency threshold, a special threshold, a read threshold, a preliminary retrieval threshold, a retrieval threshold, a read threshold, and a decode threshold. Such a determination may be based on one or more of information received in the retrieve data message, the DS unit storage set, a vault lookup, a command, a message, and a predetermination. A set of encoded slices may include two or more groups of encoded data slices, wherein each group of the one or more groups of encoded data slices is associated with a decode threshold number of the encode data slices of a common revision level when the pillar width is at least twice the decode threshold.</p>
<p id="p-0145" num="0146">The processing module may retrieve and decode the two or more groups of encoded data slices to produce two or more different data segments associated with a set of encoded data. For example, the processing module retrieves and decodes a first group of encoded data slices of the set of encoded data slices from DS units <b>1</b>-<b>5</b> to produce a first data segment and retrieves and decodes a second group of encoded data slices of the set of encoded data slices from DS units <b>6</b>-<b>10</b> to produce a second data segment when the pillar width n=10 and the decode threshold k=5. In an instance, the first data segment and the second data segment are substantially the same when the first group of encoded data slices and the second group of encoded data slices are associated with a common revision level. In another instance, the first data segment and the second data segment are not substantially the same when the first group of encoded data slices are associated with a first revision level and the second group of encoded data slices are associated with a second revision level that is different than the first revision level.</p>
<p id="p-0146" num="0147">The method continues at step <b>236</b> where the processing module determines a retrieval threshold for retrieving a set of encoded data slices from DSN, wherein the set of encoded data slices represents data (e.g., a data segment) encoded using a dispersed storage error encoding function having a pillar width of &#x201c;n&#x201d;, a decode threshold of &#x201c;k&#x201d;, and an encoding ratio of n&#x2212;k&#x3e;k and wherein the retrieval threshold is in accordance with the encoding ratio. Such determining of the retrieval threshold includes determining whether at least a write threshold number of the set of encoded data slices have a desired revision level. Such a desired revision level includes at least one of a most recent revision level, a predetermined revision level, a requested revision level, and a revision level associated with one or more recent favorable write commit response messages. For example, the processing module determines that at least a write threshold number of the set of encoded data slices have a most recent revision level of 457 when one or more recent favorable write commit response messages indicate the at least the write threshold number of encoded data slices associated with revision level 457 were successfully stored in the DS unit storage set.</p>
<p id="p-0147" num="0148">At step <b>236</b>, the processing module establishes the retrieval threshold based on the pillar width, the write threshold, and a first constant when the at least the write threshold number of the set of encoded data slices have the desired revision level. For example, the processing module determines the retrieval threshold in accordance with the formula retrieval threshold=n&#x2212;WT+1. For instance, the processing module establishes the retrieval threshold to be 16 when the pillar width is 30, the write threshold is 15, and the first constant is 1. Such establishing of the retrieval threshold may provide a system improvement by eliminating the possibility that another group of a write threshold number of encoded data slices exists in the DS unit storage set, wherein the another group of the read threshold number of encoded data slices are associated with a common revision level and are unavailable (e.g., DS unit off-line, a network failure).</p>
<p id="p-0148" num="0149">At step <b>236</b>, the processing module establishes the retrieval threshold based on the pillar width, the decode threshold, and a second constant when the at least the write threshold number of the set of encoded data slices does not have the desired revision level. For example, the processing module determines the retrieval threshold in accordance with the formula retrieval threshold=n&#x2212;k+1. For instance, the processing module establishes the retrieval threshold to be 21 when the pillar width is 30, the decode threshold is 10, and the second constant is 1. Such establishing of the retrieval threshold may provide a system improvement by eliminating the possibility that another group of encoded data slices exists in the DS unit storage set, wherein the another group of encoded data slices are associated with a common revision level and are unavailable (e.g., DS unit off-line, a network failure).</p>
<p id="p-0149" num="0150">The method continues at step <b>238</b> where the processing module selects DS units for retrieval from the DS unit storage set to produce selected DS units. Such a selection may be based on one or more the DS unit storage set, the error coding dispersal storage function parameters, the retrieval threshold, DS unit performance history, a number of encoded data slices retrieved so far, a comparison of the encoded data slices retrieved so far to the retrieval threshold, retrieval requirements, DS units that are known to have successfully stored a most recent revision, DS unit attributes, DS unit status, DS unit availability, estimated DS unit performance, estimated DS units reliability, estimated DS unit availability, and DS unit cost.</p>
<p id="p-0150" num="0151">The method continues at step <b>240</b> where the processing module issues data retrieval requests to the DSN (e.g., to the selected DS units) for the set of encoded data slices. The method continues at step <b>242</b> where the processing module receives encoded data slices of the set of encoded data slices to produce received encoded data slices. The method continues at step <b>244</b> where the processing module determines whether a number of received encoded data slices compares favorably to the retrieval threshold. For example, the processing module determines that the number of received encoded data slices compares favorably to the retrieval threshold when the number of encoded data slices is greater than or equal to the retrieval threshold. As another example, the processing module determines that the number of received encoded data slices compares favorably to the retrieval threshold by determining whether at least a decode threshold number of the received encoded data slices have a revision number corresponding to a desired revision level. In such a scenario, the processing module indicates a favorable comparison when the at least the decode threshold number of the received encoded data slices have the revision number corresponding to the desired revision level.</p>
<p id="p-0151" num="0152">The method repeats back to step <b>238</b> when the processing module determines that the number of received encoded data slices does not compare favorably to the retrieval threshold. In such a scenario, the processing module may select different DS units of the DSN for retrieval to try again. The method continues to step <b>246</b> to decode the received encoded data slices to recapture the data when the number of received encoded data slices compares favorably to the retrieval threshold.</p>
<p id="p-0152" num="0153">The method continues at step <b>246</b> where the processing module determines whether at least a decode threshold number of the received encoded data slices have a revision number corresponding to a desired revision level. The method branches to step <b>252</b> when the processing module determines that the at least the decode threshold number of received encoded data slices does have the revision number corresponding to the desired revision level. The method continues to step <b>250</b> when the processing module determines that the at least the decode threshold number of received encoded data slices do not have the revision number corresponding to the desired revision level.</p>
<p id="p-0153" num="0154">The method continues at step <b>250</b> where the processing determines whether the at least the decode threshold number of the received encoded data slices have a revision number corresponding to a second desired revision level (e.g., when a second exists and prefer a second over the first) when the at least the decode threshold number of the received encoded data slices does not have the revision number corresponding to the desired revision level. The method branches to step <b>254</b> when the processing module determines that the at least the decode threshold number of received encoded data slices does not have the revision number corresponding to the second desired revision level. The method continues to step <b>252</b> when the processing module determines that the at least the decode threshold number of received encoded data slices does have the revision number corresponding to the second desired revision level. The method continues at step <b>252</b> where the processing module indicates a favorable comparison and decodes the received encoded data slices to recapture the data.</p>
<p id="p-0154" num="0155">The method continues at step <b>254</b> where the processing module determines whether at least one encoded data slice of the set of encoded data slices is unreceived (e.g., not included in the received encoded data slices) and accessible (e.g., retrievable). Such determining includes determining a deficiency number of encoded data slices based on a difference between the decode threshold number and a number of the received encoded data slices that have the revision number corresponding to the desired revision level, determining whether at least the deficiency number of encoded data slices is unreceived and is accessible and indicating that the at least one encoded data slice of the set of encoded data slices is unreceived and accessible when the at least the deficiency number of encoded data slices is unreceived and is accessible, and indicating that the at least one encoded data slice of the set of encoded data slices is not unreceived or is not accessible when the at least the deficiency number of encoded data slices is not unreceived or is not accessible.</p>
<p id="p-0155" num="0156">The method branches to step <b>258</b> when the processing module determines that the at least one encoded data slices is unreceived and accessible. The method continues to step <b>256</b> when the processing module determines that the at least one encoded data slices is not unreceived or is not accessible. The method continues at step <b>256</b> where the processing module sends an error message (e.g., to the requester, to a DS managing unit). Alternatively, the method repeats back to step <b>238</b> to try again (e.g., waiting for the at least one encoded data slices to become accessible).</p>
<p id="p-0156" num="0157">The method continues at step <b>258</b> where the processing module reissues the data retrieval requests to the DSN for the at least one encoded data slice and receives one or more of the at least one encoded data slice to produce additionally received encoded data slices when the at least one encoded data slice of the set of encoded data slices is unreceived and accessible. The method continues at step <b>260</b> where the processing module decodes the received encoded data slices to recapture the data when a number of the received encoded data slices and the additionally received encoded data slices compares favorably to the retrieval threshold (e.g., have a decode threshold number of encoded data slices).</p>
<p id="p-0157" num="0158">Alternatively, the processing module may utilize a consistency threshold (e.g., retrieval threshold=n&#x2212;k+1) when accessing encoded data slices to be deleted. In such a scenario, there will be less than a write threshold number of encoded data slices remaining in the DS unit storage set. Alternatively, the processing module may utilize the consistency threshold when accessing encoded data slices to produce a rebuilt encoded data slice subsequent to re-creating a corresponding data segment. In such a scenario, the rebuilt encoded data slice is re-created from the DS unit storage set such that less than a write threshold number of encoded data slices are remaining in the DS unit storage set (e.g., implying that a latest visible revision may be utilized to produce the rebuilt encoded data slice). The method to produce a rebuilt encoded data slice associated an encoding ratio of n&#x2212;k&#x3e;k is discussed in greater detail with reference to <figref idref="DRAWINGS">FIG. 12</figref>.</p>
<p id="p-0158" num="0159"><figref idref="DRAWINGS">FIG. 12</figref> is a flowchart illustrating an example of synchronizing a revision of stored data. Such synchronizing may include rebuilding an encoded data slice and/or deleting an un-required encoded data slice when the encoded data slice or the un-required encoded data slice are included in a set of encoded data slices where a pillar width n is at least twice a read threshold k. In such a scenario, the a processing module may decode a data segment to enable rebuilding of the encoded data slice from at least two groups of encoded data slices of a set of encoded data slices. For example, the processing module may dispersed storage error decode encoded data slices retrieved from dispersed storage (DS) units <b>1</b>-<b>5</b> or from DS units <b>6</b>-<b>10</b> to produce the data segment when the pillar width n=10 and the read threshold k=5. Such a data segment may be stored as two or more revisions when the pillar width n is at least twice the read threshold k and when an error occurred in a storage sequence (e.g., a decode threshold number of offline DS units miss the storage of a newer revision of the data segment).</p>
<p id="p-0159" num="0160">The method begins with step <b>261</b> where a processing module determines revisions with at least a decode threshold number of encoded data slices. Such determining of the revisions includes retrieving encoded data slices and corresponding revision information from as many pillars as possible for a data segment that is stored in a DS unit storage set. Such determining of the revisions may occur when a DS unit is reactivated after being off-line and/or when a time period has elapsed since a previous determination of revisions.</p>
<p id="p-0160" num="0161">The method continues at step <b>262</b> where the processing module identifies a revision with less than a decode threshold number of encoded data slices. The processing module may not be able to reconstruct the data segment corresponding to the revision when all of the encoded data slices were retrieved (e.g., a decode threshold number is not available). The processing module may be able to reconstruct the data segment corresponding to the revision when a number of unretrieved encoded data slices is greater than or equal to a number of encoded data slices required to decode the data segment (e.g., a difference between the decode threshold and a number of encoded data slices received so far of the same revision).</p>
<p id="p-0161" num="0162">The method continues at step <b>263</b> where the processing module determines whether the revision with less than a decode threshold number of encoded data slices is older than a revision with a decode threshold number of encoded data slices. A storage capacity efficiency enhancement may be realized when slices of older revisions are deleted when slices of newer revisions exist that can be utilized to reconstruct a data segment. The method branches to step <b>266</b> when the processing module determines that the revision with less than a decode threshold number of encoded data slices is older than the revision with a decode threshold number of encoded data slices. The method continues to step <b>264</b> when the processing module determines that the revision with less than a decode threshold number of encoded data slices is not older than the revision with a decode threshold number of encoded data slices. In such a scenario, it may be possible to reconstruct a data segment associated with a newer revision if the decode threshold number of encoded data slices can be retrieved for the newer version (e.g., a decode threshold number of total as compared to what may have been received so far).</p>
<p id="p-0162" num="0163">The method continues at step <b>264</b> where the processing module determines whether it is possible for the revision with less than a threshold number of pillars to have a threshold number of pillars. Such a determination may be based on comparing a difference between the pillar width and a number of encoded data slices received so far to a difference between the decode threshold and a number of encoded data slices received for the revision with less than a decode threshold number of pillars. The method repeats back to step <b>262</b> when the processing module determines that it is possible for the revision with less than a decode threshold number of pillars to have the decode threshold number of encoded data slices. The method continues to step <b>266</b> when the processing module determines that it is not possible for the revision with less than a decode threshold number of encoded data slices to have a decode threshold number of encoded data slices.</p>
<p id="p-0163" num="0164">The method continues at step <b>266</b> where the processing module deletes encoded data slices associated with the revision with less than the decode threshold number of encoded data slices since it is not possible for the revision to have the decode threshold number of encoded data slices and/or the revision is older than a revision that it is available now. Such deletion includes sending a delete command with corresponding slice names to DS units to delete the slices of the revision with less than the decode threshold number of encoded data slices.</p>
<p id="p-0164" num="0165">The method continues at step <b>268</b> where the processing module facilitates rebuilding a latest revision with a decode threshold number of encoded data slices. Such facilitating includes sending a rebuild message to a storage integrity processing unit that includes slice names associated with the latest revision requiring rebuilding and rebuilding all encoded data slices associated with the data segment to the latest revision by retrieving a decode threshold number of encoded data slices associated with the latest revision, dispersed storage error decoding the threshold number of encoded data slices to produce a set of encoded data slices, and sending the set of encoded data slices to the DS unit storage set for storage therein.</p>
<p id="p-0165" num="0166"><figref idref="DRAWINGS">FIG. 13</figref> A is a diagram illustrating another example of a memory utilization map where a memory utilization of a memory device <b>1</b> is compared to a memory utilization of a memory device <b>2</b> for both an unbalanced state and a balanced state after a memory balancing function has been executed as described in greater detail with reference to <figref idref="DRAWINGS">FIG. 13</figref> B. In an implementation example, memory device <b>1</b> and memory device <b>2</b> are be implemented in a common dispersed storage (DS) unit. In another implementation example, memory device <b>1</b> and memory device <b>2</b> are implemented in two different DS units. The shaded area of the memory device utilization figure indicates a proportion of utilization relative to the capacity of the memory device. A memory mapping of unbalanced memory devices <b>270</b> indicates that memory device <b>2</b> is utilizing more of the capacity of memory device <b>2</b> as compared to the utilization of memory device <b>1</b> when the memory utilization is unbalanced.</p>
<p id="p-0166" num="0167">The memory devices <b>1</b> and <b>2</b> may each be assigned to a slice address range corresponding to encoded data slices to be stored in the memory device (e.g., a slice name range). For example, memory device <b>1</b> is assigned to an address range of 125-136 and memory device <b>2</b> is assigned to an address range of 137-185 when the memory devices are unbalanced. In an example of operation, memory device <b>1</b> and memory device <b>2</b> are implemented in DS unit <b>5</b> wherein the DS unit <b>5</b> is utilized to store encoded data slices. DS unit <b>5</b> has stored more bytes of encoded data slices in memory device <b>2</b> as compared to bytes of encoded data slices stored in memory device <b>1</b> when the memory devices are unbalanced. In such a scenario, DS unit <b>5</b> may determine to execute a memory balancing function to balance the utilization of memory device <b>1</b> and memory device <b>2</b>.</p>
<p id="p-0167" num="0168">The memory utilization of memory device <b>1</b> and memory device <b>2</b> is balanced (e.g., approximately the same utilization) following the execution of the memory balancing function. Such a memory balancing function may result in the transfer of encoded data slices from memory device <b>2</b> to memory device <b>1</b> and the address range may be modified such that memory device <b>1</b> is assigned to an address range of 125-142 and memory device <b>2</b> is assigned to an address range of 143-185 when the memory devices are balanced as in the memory mapping of bounced memory devices <b>272</b>. In such a scenario, some of the slice addresses were reassigned from an over utilized memory device to an underutilized memory device. The method of the memory balancing function is discussed in greater detail with reference to <figref idref="DRAWINGS">FIG. 13</figref> B.</p>
<p id="p-0168" num="0169"><figref idref="DRAWINGS">FIG. 13</figref> B is a flowchart illustrating another example of balancing memory utilization. The method begins with step <b>274</b> where a processing module determines memory devices to consider balancing. Such memory devices may include one or more of a single memory device, an array of memory devices, a dispersed storage (DS) unit that includes a plurality of memory devices, a plurality of DS units within a dispersed storage network (DSN) memory, and a plurality of DSN memories. Such a determination may be based on one or more of where a balancing process left off last time, a query, an error message, a command, a predetermination, and a list.</p>
<p id="p-0169" num="0170">The method continues at step <b>276</b> where the processing module determines utilization of the memory devices. Such utilization may indicate one or more of an amount of storage used, an amount of storage utilized as a percentage of a capacity of the memory device, an amount of storage utilized by a category (e.g., based on a priority indicator, a security indicator, a performance indicator, a user identifier (ID), a vault ID, an affiliated group, etc.), and an amount of unused available capacity. Such a utilization determination may be based on one or more of a query, and memory analysis, a list, a ping, a message, a command, an error message, and lookup.</p>
<p id="p-0170" num="0171">The method continues at step <b>280</b> where the processing module determines whether to balance the utilization of the memory devices. Such a determination may be based on one or more of the memory devices, the utilization of the memory device, a difference in utilization of memory devices, a utilization difference threshold, a comparison of the difference in utilization of memory devices to the utilization difference threshold, an estimated impact to balance utilization of the memory devices, and one or more different groupings of two or more memory devices. For example, the processing module determines to balance when a difference in utilization of the memory devices is greater than a utilization difference threshold. The method branches to step <b>282</b> when the processing module determines to balance the utilization of the memory devices. The method repeats back to step <b>274</b> when the processing module determines not to balance the utilization of the memory devices. Note that the processing module may recursively determine different groupings of memory devices to determine a combination to balance (e.g., memories 1/2, memories 2/3, memories 1/3, etc.).</p>
<p id="p-0171" num="0172">The method continues at step <b>282</b> where the processing module determines how to balance utilization of the memory devices. For example, the processing module may determine to move the slice name address boundary that splits an address range between the two or more memory devices and/or transfer encoded data slices from a memory device with a higher utilization to a memory device with a lower utilization followed by updating a virtual DSN address to physical location table. Such a determination may be based on one or more of the utilization of the memory devices, a capacity of the memory devices, an address range of assignments, size of the stored data slices, an estimation of a number of encoded data slices to transfer based on a size of the encoded slices to equalize memory device utilization, a predetermination, a lookup, a message, and a command.</p>
<p id="p-0172" num="0173">The method continues at step <b>284</b> where the processing module transfers encoded data slices from a first memory device to a second memory device wherein the first memory device is more utilized in the second memory device. In addition, the processing module may delete or overwrite the encoded slices transferred from the first memory device when the processing module has confirmed that the encoded data slices were successfully transferred to the second memory device.</p>
<p id="p-0173" num="0174">The method continues at step <b>286</b> where the processing module re-assigns slice address range assignments of the first memory device and the second memory device. Such reassigning includes assigning a portion of slice name address ranges previously utilized by the first memory device to be assigned to slice name address ranges of the second memory device. The processing module may repeat the method producing a cascade effect after moving a first block of slices from the first memory device to the second memory device. For example, the second memory element may appear over utilized by comparison to a third memory element after transferring encoded data slices from memory device <b>1</b> to memory device <b>2</b>.</p>
<p id="p-0174" num="0175"><figref idref="DRAWINGS">FIG. 14</figref> A is a flowchart illustrating an example of identifying a failed memory device. The method begins with step <b>288</b> where a processing module detects a failed memory device. Such a determination may be based on one or more of a query, an error message, a failed transaction indicator, a memory device removal indicator, a message, and a command. The method continues at step <b>290</b> where the processing module determines a dispersed storage network (DSN) address range associated with the failed memory device. Such a determination may be based on one or more of a virtual DSN address to physical location table lookup, a query, a message, and a command. The method continues at step <b>292</b> where the processing module sends the DSN address range of the failed memory device to one or more of a dispersed storage (DS) processing unit, a DS managing unit, a storage integrity processing unit, a user device, and a DS unit. Such sending of the DSN address range may invoke a memory device access restriction method as described in greater detail with reference to <figref idref="DRAWINGS">FIG. 14</figref> B.</p>
<p id="p-0175" num="0176"><figref idref="DRAWINGS">FIG. 14</figref> B is a flowchart illustrating an example of processing a memory access request. The method begins with step <b>294</b> where a processing module receives a dispersed storage network (DSN) memory access request. Such a request may include one or more of a user identifier (ID), a data object name, a priority indicator, a security indicator, a performance indicator, access requirements, metadata, and an access command. Note that the access command may include one of but not limited to a store command, a retrieve command, a delete command, and a list command.</p>
<p id="p-0176" num="0177">The method continues at step <b>296</b> where the processing module determines required DSN address ranges for a plurality of sets of encoded data slices corresponding to the DSN memory access request. Such a determination may be based on one or more of a data object name, a user ID, a vault ID, a vault lookup, a virtual DSN address to physical location table lookup, a source name determination, a slice name determination, a predetermination, a message, and a command. For example, the processing module determines a source name based on the data object name and a vault ID and determines a plurality of slice names corresponding to the source name. Next, the processing module determines the required DSN address ranges based on a virtual DSN address to physical location table lookup utilizing the plurality of slice names as an index.</p>
<p id="p-0177" num="0178">The method continues at step <b>298</b> where the processing module determines failed memory devices corresponding to the required DSN address ranges. Such a determination may be based on one or more of a failed address range list, a received DSN address range of a failed memory device, the required DSN address range, a query, a message, and a command. For example, the processing module receives one or more messages indicating a DSN address range of one or more failed memory devices. The processing module aggregates the messages into a failed address range list and utilizes the list to determine the failed memory devices of the required DSN address ranges by comparing the addresses of a list to the required DSN address ranges.</p>
<p id="p-0178" num="0179">The method continues at step <b>300</b> where the processing module determines whether too many memory devices have failed of the required DSN address ranges by comparing a number of failed memory devices of the required DSN address ranges to a failure threshold. For example, the processing module determines that too many memory devices have failed of the required DSN address ranges when the number of failed memory devices of the required DSN address ranges is greater than the failure threshold. The method branches to step <b>304</b> when the processing module determines that too many memory devices have not failed. The method continues to step <b>302</b> when the processing module determines that too many memory devices have failed. The method continues at step <b>302</b> where the processing module rejects the request. Such rejecting includes sending a reject message to a requester and/or to a dispersed storage (DS) managing unit.</p>
<p id="p-0179" num="0180">The method continues at step <b>304</b> where the processing module processes the DSN memory access request when the processing module determines that too many memory devices have not failed. Such a method may provide computing system network utilization efficiency improvement since data slice retrievals will not be attempted when there are too many memory device failures.</p>
<p id="p-0180" num="0181"><figref idref="DRAWINGS">FIG. 15</figref> is another schematic block diagram of an embodiment of a computing system that includes a user device <b>12</b>, at least one dispersed storage (DS) processing unit <b>16</b> of a plurality of DS processing units <b>1</b>-N, and at least one dispersed storage network (DSN) memory <b>22</b> of a plurality of DSN memories <b>1</b>-N. For example, as illustrated, the computing system may include N DS processing units <b>1</b>-N and N DSN memories <b>1</b>-N. As another example, the computing system may include one DS processing unit and N DSN memories. As yet another example, the computing system may include N DS processing units <b>1</b>-N and one DSN memory. Each DS processing unit <b>1</b>-N may be implemented utilizing an authentication server.</p>
<p id="p-0181" num="0182">Such a user device <b>12</b> includes a credential package <b>306</b>, a share encoder <b>308</b>, a plurality of random number generators (RNG) <b>1</b>-N, a plurality of key generators <b>1</b>-N, and a plurality of encryptors <b>1</b>-N. Such a credential package <b>306</b> may include a credential <b>310</b> and a credential hash digest <b>312</b>. Such a credential <b>310</b> may include sensitive data including one or more of a private key, a public key, a signed certificate, confidential user information, a password, and any sensitive confidential information. Such a credential hash digest <b>312</b> may be generated by utilizing a hash function on the credential <b>310</b>. Such a credential hash digest <b>312</b> may be utilized in a subsequent integrity verification step to verify that the credential <b>310</b> has not been tampered with.</p>
<p id="p-0182" num="0183">Such a share encoder <b>308</b> encodes the credential package <b>306</b> to produce encoded shares <b>1</b>-N in accordance with a share encoding function (e.g., Shamir secret sharing algorithm). Such encryptors <b>1</b>-N encrypt the encoded shares <b>1</b>-N in accordance with an encryption algorithm utilizing keys <b>1</b>-N to produce encrypted shares <b>1</b>-N. Generation of the keys <b>1</b>-N is discussed in greater detail below. Such an encryption algorithm may be in accordance with dispersed storage error coding parameters associated with the user device <b>12</b>. For example, each of the encryptors <b>1</b>-N utilize a common encryption algorithm in accordance with the dispersed storage error coding parameters. As another example, at least two encryptors of the encryptors <b>1</b>-N utilize different encryption algorithms in accordance with the dispersed storage error coding parameters.</p>
<p id="p-0183" num="0184">The encryptors <b>1</b>-N output the encrypted shares <b>1</b>-N to the DS processing units <b>1</b>-N. The DS processing units <b>1</b>-N dispersed storage error encodes each encrypted share of the encrypted shares <b>1</b>-N to produce N groups of encoded share slices in accordance with the error coding dispersal storage function parameters, wherein each group of encoded share slices includes one or more sets of encoded data slices. The DS processing units <b>1</b>-N send the N groups of encoded share slices to the DSN memories <b>1</b>-N for storage therein. Alternatively, the functionality of the DS processing unit (e.g., DS processing <b>34</b>) may be included in the user device <b>12</b> such that the user device <b>12</b> dispersed storage error encodes the encrypted shares <b>1</b>-N to produce the N groups of encoded share slices. Next, the user device <b>12</b> sends the N groups of encoded share slices to the DSN memories <b>1</b>-N for storage therein. Alternatively, the encryptors <b>1</b>-N output the encrypted shares <b>1</b>-N to one or more of the DSN memories <b>1</b>-N for storage therein (e.g., without producing N groups of encoded share slices). Alternatively, the DS processing units <b>1</b>-N send the encrypted shares <b>1</b>-N to the one or more of the DSN memories <b>1</b>-N for storage therein.</p>
<p id="p-0184" num="0185">Such random number generators <b>1</b>-N generate a plurality of random numbers e<sub>1</sub>-e<sub>N</sub>. For example, random numbers e<sub>1</sub>-e<sub>N </sub>are each a same number of bits as a number of bits of p, where p is determined by security parameters (e.g., of the dispersed storage error coding parameters). The random number generators <b>1</b>-N output the plurality of random numbers e<sub>1</sub>-e<sub>N </sub>to the DS processing units <b>1</b>-N. The DS processing units <b>1</b>-N dispersed storage error encodes each random number of the plurality of random numbers in accordance with the dispersed storage error coding parameters to produce N groups of encoded random number slices, wherein each group of encoded random number slices includes at least one set of random number slices. Next, the DS processing units <b>1</b> send the groups of encoded random number slices to the DSN memories <b>1</b>-N for storage therein. Alternatively, the user device <b>12</b> dispersed storage error encodes the plurality of random numbers to produce the N groups of encoded random number slices. Next, the user device <b>12</b> sends the N groups of encoded random number slices to the DSN memories <b>1</b>-N for storage therein. Alternatively, the user device <b>12</b> sends the plurality of random numbers e<sub>1</sub>-e<sub>N </sub>to the one or more of the DSN memories <b>1</b>-N for storage therein.</p>
<p id="p-0185" num="0186">Such key generators <b>1</b>-N generate the keys <b>1</b>-N based on one or more of the plurality of random numbers e<sub>1</sub>-e<sub>N</sub>, the security parameters, and a common password <b>314</b>. Such a common password may be utilized from time to time by a user of the user device <b>12</b> to gain access to services, information, and/or functions provided by the user device. Such a common password may be obtained by one or more of receiving a user input, a retrieval, received from a flash memory device, and receiving the message. For example, the user device <b>12</b> receives a user input of ten alphanumeric characters via a user interface input.</p>
<p id="p-0186" num="0187">Such generation of the keys <b>1</b>-N based on the security parameters produces each key of the keys <b>1</b>-N such that each key includes a same number of bits as a number of bits of p. For example, the key generators <b>1</b>-N generate the keys <b>1</b>-N by transforming an expansion of the common password utilizing a mask generating function (MGF) and the plurality of random numbers in accordance with an expression key x=((MGF(common password))<sup>2</sup>)<sup>e</sup><sub>x </sub>modulo p. For instance, key generator <b>1</b> generates key <b>1</b>=((MGF(password))<sup>2</sup>)<sup>e</sup><sub>1 </sub>modulo p. Such a MGF produces a deterministic pattern of bits of any desired length based on an input. For instance, the generator <b>1</b> calculates key <b>1</b>=13 when MGF (common password)=4, e<sub>1</sub>=10, and p=23, as (4<sup>2</sup>)<sup>10 </sup>mod 23=13. Alternatively, or in addition to, the key may be further processed to provide a key of a desired length in relation to an encryption algorithm. For example, the key output of the algorithm is hashed to produce a hashed key and a desired number of bits (e.g., 256, 192, 128 bits) of the hashed key are utilized as a key for the encryption algorithm.</p>
<p id="p-0187" num="0188">The common password <b>314</b> and a decode threshold number of pairs of stored random numbers and encrypted shares are required to reproduce the credential package. Note that a security improvement is provided by the system when the pairs of stored random numbers and encrypted shares are stored on substantially different authentication servers and/or via two or more DS processing units and two or more DSN memories since a likelihood of a successful attack to gain access to the pairs of stored random numbers and encrypted shares is reduced. The reproduction of the credential package is discussed in greater detail with reference to <figref idref="DRAWINGS">FIGS. 17-19</figref>. The method of operation to store the credential package is discussed in greater detail with reference to <figref idref="DRAWINGS">FIG. 16</figref>.</p>
<p id="p-0188" num="0189"><figref idref="DRAWINGS">FIG. 16</figref> is a flowchart illustrating an example of storing data. The method begins with step <b>316</b> where a processing module determines security parameters to be utilized in the storing of sensitive data (e.g., a credential package). Such security parameters may include one or more of a share number N, a value of security algorithm constant p (e.g., a prime number), a value of security algorithm constant q (e.g., a prime number), shared secret algorithm parameters, an encryption algorithm indicator, a key generator function indicator, a key size, a random number generator function, a random number size, a hash function type indicator, a security package structure indicator, and any other parameter to specify the operation of the storing of the sensitive data. Such a determination of the security parameters may be based on one or more of security requirements, a security status indicator, a user identifier (ID), a vault ID, a list, a table lookup, a predetermination, a message, and a command. For example, the processing module determines the security parameters based on a table lookup corresponding to a user ID affiliated with a user device.</p>
<p id="p-0189" num="0190">The method continues at step <b>318</b> where the processing module generates the sensitive data in accordance with the security parameters. For example, the processing module generates the sensitive data to include a credential and a credential hash digest. For example, the processing module generates a hash digest of a private key and bundles the hash digest with the private key to create a credential package as the sensitive data.</p>
<p id="p-0190" num="0191">The method continues at step <b>320</b> where the processing module applies a share encoding function on the data (e.g., the credential package) to produce a plurality of encoded shares. Such a share encoding function includes at least one of a dispersed storage error encoding function and a secret sharing function. Such a secret sharing function includes at least one of Shamir's secret sharing scheme, Blakely's scheme, and a Chinese Remainder Theorem scheme. For example, the processing module produces encoded shares <b>1</b>-<b>16</b> in accordance with shared secret algorithm parameters when N=16 and the share encoding function includes the secret sharing function. As another example, the processing module dispersed storage error encodes the data in accordance with dispersed storage error coding parameters to produce encoded shares <b>1</b>-N when the share encoding function includes the dispersed storage error coding function.</p>
<p id="p-0191" num="0192">The method continues at step <b>322</b> where the processing module obtains a common password. Such obtaining may be based on one or more of a user input, a dispersed storage (DS) managing unit input, a query, a prompt, a retrieval from a memory storage device, an algorithm, a lookup, a message, and a command. For example, the processing module obtains a 10 character common password via an input user interface.</p>
<p id="p-0192" num="0193">The method continues at step <b>324</b> where the processing module generates a corresponding plurality of random numbers for the plurality of encoded shares. Such generating of the corresponding plurality of random numbers includes obtaining (e.g., generate, receive in a message, retrieve from a random number generator) a plurality of base random numbers and expanding each base random number of the plurality of base random numbers based on the security parameters to produce the corresponding plurality of random numbers. For example, processing module expands the base set of random numbers such that each random number of the corresponding plurality of random numbers is 1,024 bits in length (e.g., p is 1,024 bits in length).</p>
<p id="p-0193" num="0194">The method continues at step <b>326</b> where the processing module generates an encryption key for each encoded share of the plurality of encoded shares based on the common password and a corresponding one of the corresponding plurality of random numbers. Such generating of the encryption key includes transforming the common password utilizing a mask generating function, the security parameters, and the corresponding one of the corresponding plurality of random numbers. For example, the processing module generates a key x based on the common password and the corresponding random number e<sub>x </sub>in accordance with the expression key x=((MGF(common password))<sup>2</sup>)<sup>e</sup><sub>x </sub>modulo p.</p>
<p id="p-0194" num="0195">The method continues at step <b>328</b> where the processing module encrypts the encoded share utilizing the encryption key to produce an encrypted share. Such encryption may be based on one or more of the security parameters, the dispersed storage error coding parameters, a user identifier (ID), a vault ID, a vault lookup, security requirements, a security status indicator, a message, and a command.</p>
<p id="p-0195" num="0196">The method continues at step <b>330</b> where the processing module determines if all N of the encoded shares <b>1</b>-N have been encrypted. Such a determination may be based on comparing a number of encrypted shares produced so far to the value of N. The method repeats back to step <b>326</b> when the processing module determines that all N encrypted shares have not been produced. The method continues to step <b>332</b> when the processing module determines that all N encrypted shares have been produced.</p>
<p id="p-0196" num="0197">The method continues at step <b>332</b> where the processing module facilitates storage of the corresponding plurality of random numbers and each of the encrypted shares. Such facilitating includes at least one of sending the encrypted share and the corresponding one of the corresponding plurality of random numbers to a dispersed storage (DS) processing unit, dispersed storage error encoding the encrypted share to produce a plurality of encoded share slices and outputting the plurality of encoded share slices for storage (e.g., send to a dispersed storage network memory), and dispersed storage error encoding the corresponding one of the corresponding plurality of random numbers to produce a plurality of encoded random number slices and outputting the plurality of encoded random number slices for storage (e.g., send to a dispersed storage network memory).</p>
<p id="p-0197" num="0198"><figref idref="DRAWINGS">FIG. 17</figref> is another schematic block diagram of an embodiment of a computing system that includes a user device <b>12</b>, at least one dispersed storage (DS) processing unit <b>16</b> of a plurality of DS processing units <b>1</b>-N, and at least one dispersed storage network (DSN) memory <b>22</b> of a plurality of DSN memories <b>1</b>-N. For example, as illustrated, the computing system may include N DS processing units <b>1</b>-N and N DSN memories <b>1</b>-N. As another example, the computing system may include one DS processing unit and N DSN memories. As yet another example, the computing system may include N DS processing units <b>1</b>-N and one DSN memory. Each DS processing unit <b>1</b>-N may be implemented utilizing one or more of a DS processing unit <b>16</b> of <figref idref="DRAWINGS">FIG. 1</figref>, a web server, a DS unit, and an authentication server.</p>
<p id="p-0198" num="0199">Such a user device <b>12</b> includes a credential package <b>306</b>, a share decoder <b>336</b>, a plurality of random number generators (RNG) <b>1</b>-N, a plurality of blinded password generators <b>1</b>-N, a plurality of value generators <b>1</b>-N, a plurality of key regenerators <b>1</b>-N, and a plurality of decryptors <b>1</b>-N. Such a credential package <b>306</b> may include a credential <b>310</b> and a credential hash digest <b>312</b>. Such a DS processing unit of the DS processing units <b>1</b>-N includes a DS processing module and a passkey generator. For example, DS processing units <b>1</b>-N each include a DS processing module of DS processing modules <b>1</b>-N and a passkey generator of passkey generators <b>1</b>-N. Alternatively, the user device <b>12</b> includes the functionality of the DS processing units <b>1</b>-N.</p>
<p id="p-0199" num="0200">Such random number generators <b>1</b>-N generate blinded random numbers b<sub>1</sub>-b<sub>N</sub>. For example, each random number generator of the random number generators <b>1</b>-N generates a blinded random number of the blinded random numbers b<sub>1</sub>-b<sub>N </sub>such that each blinded random number includes a same number of bits as a number of bits of p, wherein p is extracted from dispersed storage error coding parameters and/or security parameters. The random number generators <b>1</b>-N send the blinded random numbers b<sub>1</sub>-b<sub>N </sub>to the blinded password generators <b>1</b>-N and to the value generators <b>1</b>-N.</p>
<p id="p-0200" num="0201">Such blinded password generators <b>1</b>-N generate blinded passwords <b>1</b>-N (e.g., bpass <b>1</b>-N) based on the blinded random numbers b<sub>1</sub>-b<sub>N</sub>, a common password <b>314</b>, and security parameters. Such generation includes transforming an expansion of the common password utilizing a mask generating function (MGF) and a corresponding one of the blinded random numbers b<sub>1</sub>-b<sub>N </sub>in accordance with the expression bpass x=((MGF(common password))<sup>2</sup>)<sup>b</sup><sub>x </sub>modulo p. For example, bpass <b>1</b>=((MGF(common password))<sup>2</sup>)<sup>b</sup><sub>1 </sub>modulo p. In an instance, the blinded password generator <b>1</b> calculates bpass <b>1</b>=18 when MGF(common password)=4, b<sub>1</sub>=7, and p=23, since (4<sup>2</sup>)<sup>7 </sup>mod 23=18. The blinded password generators <b>1</b>-N send the blinded passwords <b>1</b>-N to the passkey generators <b>1</b>-N.</p>
<p id="p-0201" num="0202">Such value generators <b>1</b>-N generate values v<sub>1</sub>-v<sub>N </sub>based on the blinded passwords b<sub>1</sub>-b<sub>N </sub>and the value of a security parameter constant q of the security parameters in accordance with the expression b*v modulo q=1. Such a security parameter constant q may be based on the value of p in accordance with the expression q=(p&#x2212;1)/2. For instance, q=11 when p=23. In an example of generating a value, value generator <b>1</b> generates a value v1=8 when b<sub>1</sub>=7 and q=11 (e.g., 7*8=56; 56 modulo 11=1). The value generators <b>1</b>-N send the values v<sub>1</sub>-v<sub>N </sub>to the key regenerators <b>1</b>-N.</p>
<p id="p-0202" num="0203">Such passkey generators <b>1</b>-N may retrieve stored random number values of e<sub>1</sub>-e<sub>N </sub>from the DS processing modules <b>1</b>-N in response to receiving a retrieve credential package request from the user device <b>12</b>. For example, a DS processing module of the DS processing modules <b>1</b>-N retrieves at least a dispersal decode threshold number of encoded stored random number slices from one or more DSN memories <b>1</b>-N, dispersed storage error decodes the at least the dispersal decode threshold number of encoded stored random number slices to produce a stored random number of the stored random numbers e<sub>1</sub>-e<sub>N</sub>, and sends the stored random number to a corresponding passkey generator of the passkey generators <b>1</b>-N.</p>
<p id="p-0203" num="0204">Such passkey generators <b>1</b>-N generate passkeys <b>1</b>-N based on the stored random numbers e<sub>1</sub>-e<sub>N </sub>and the blinded passwords <b>1</b>-N in accordance with the expression passkey x=(bpass x)<sup>e</sup><sub>x </sub>modulo p. For instance, passkey generator <b>1</b> generates a passkey <b>1</b>=9 when bpass <b>1</b>=18, e<sub>1</sub>=10, and p=23 (e.g., since (18)<sup>10 </sup>modulo 23=9). The passkey generators <b>1</b>-N send the passkeys <b>1</b>-N to the key regenerators <b>1</b>-N. Such key regenerators <b>1</b>-N regenerate keys <b>1</b>-N based on the passkeys <b>1</b>-N and the values v<sub>1</sub>-v<sub>N </sub>in accordance with the expression key x=(passkey x)<sup>v</sup><sub>x </sub>modulo p. For instance, key regenerator <b>1</b> regenerates key <b>1</b> such that key <b>1</b>=13 when passkey <b>1</b>=9, v1=8, and p=23 (e.g., since (9)<sup>8 </sup>modulo 23=13). The key regenerators <b>1</b>-N send keys <b>1</b>-N to the decryptors <b>1</b>-N.</p>
<p id="p-0204" num="0205">Such a DS processing module of the DS processing modules <b>1</b>-N retrieves (e.g., from one or more of the DSN memories <b>1</b>-N) and dispersed storage error decodes at least a dispersal decode threshold number of encoded encrypted share slices to produce an encrypted share of encrypted shares <b>1</b>-N in response to a retrieval request received from the user device <b>12</b>. The DS processing modules <b>1</b>-N send the encrypted shares <b>1</b>-N to the decryptors <b>1</b>-N. The decryptors <b>1</b>-N decrypt the encrypted shares <b>1</b>-N utilizing keys <b>1</b>-N in accordance with a decryption algorithm to produce shares <b>1</b>-N. Such a decryption algorithm may be in accordance with the dispersed storage error coding parameters and/or the security parameters. For example, each of the decryptors <b>1</b>-N utilize a common decryption algorithm in accordance with security parameters. As another example, at least two of the decryptors <b>1</b>-N utilize a different decryption algorithm in accordance with the security parameters. The decryptors <b>1</b>-N send the shares <b>1</b>-N to the share decoder <b>336</b>.</p>
<p id="p-0205" num="0206">Such a secret share decoder <b>336</b> decodes the shares <b>1</b>-N to reproduce the credential package <b>306</b>. Such decoding may include at least one of dispersed storage error decoding the shares <b>1</b>-N to reproduce the data and decoding the set of shares utilizing a secret sharing function to reproduce the data. For example, the share decoder <b>336</b> decodes the set of shares utilizing a Shamir secret sharing algorithm. The method to retrieve such a securely stored credential package is discussed in greater detail with reference to <figref idref="DRAWINGS">FIGS. 18-19</figref>.</p>
<p id="p-0206" num="0207"><figref idref="DRAWINGS">FIG. 18</figref> is a flowchart illustrating another example of retrieving data that include similar steps of <figref idref="DRAWINGS">FIG. 16</figref>. The method begins with steps <b>316</b> and <b>322</b> of <figref idref="DRAWINGS">FIG. 16</figref> where a processing module determines security parameters and obtains a common password. The method continues at step <b>342</b> where the processing module generates a set of blinded random numbers. Such generating includes obtaining a set of base random numbers (e.g., generate, receive in a message, retrieve from a random number generator) and expanding each base random number of the set of base random numbers based on security parameters to produce the set of blinded random numbers. For example, the processing module generates a set of base random numbers and expands each base random number of the set of base random numbers in accordance with a security constant p of the security parameters to produce a set of blinded random numbers such that each blinded random number includes a same number of bits as a number of bits of p.</p>
<p id="p-0207" num="0208">The method continues at step <b>344</b> where the processing module generates a set of blinded passwords based on a common password and the set of blinded random numbers.</p>
<p id="p-0208" num="0209">Such generating of the set of blinded passwords includes, for each blinded random number of the set of blinded random numbers, transforming the common password utilizing a mask generating function and the blinded random number to produce a blinded password of the set of blinded passwords. For example, the processing module generates a blinded password x of the set of blinded passwords based on the common password and a corresponding blinded random number b<sub>x </sub>in accordance with the expression blinded password x=((MGF(common password))<sup>2</sup>)<sup>b</sup><sub>x </sub>modulo p.</p>
<p id="p-0209" num="0210">The method continues at step <b>346</b> where the processing module transforms the blinded random number utilizing a modulo function based on the security parameters to produce a value of a set of values for each blinded random number of the set of blinded random numbers. For example, the processing module generates a value v<sub>x </sub>of the set of values based on a blinded random number b<sub>x </sub>in accordance with the expression b*v modulo q=1, wherein q is a security constant of the security perimeters such that q=(p&#x2212;1)/2. For instance, v=b^(q&#x2212;2) mod q, when q is prime (e.g., 8=7^9 mod 11, 8*7 mod 11=1).</p>
<p id="p-0210" num="0211">The method continues at step <b>348</b> where the processing module sends a passkey x request that includes the blinded password x to a dispersed storage (DS) processing module x (e.g., of a DS processing unit, a DS unit, a web server, an authentication server). The method continues at step <b>350</b> where the processing module receives a passkey x from the DS processing module x in response to the passkey x request. The method of operation of the DS processing module x is discussed in greater detail with reference to <figref idref="DRAWINGS">FIG. 19</figref>. Alternatively, the processing module functions in accordance with the method of the DS processing module x to produce the passkey x.</p>
<p id="p-0211" num="0212">The method continues at step <b>352</b> where the processing module determines whether the set of passkeys has been produced, wherein the set of passkeys includes at least a share function decode threshold number of passkeys. The method repeats back to step <b>346</b> will processing module determines that the set of passkeys has not been produced. The method continues to step <b>354</b> when the processing module determines that the set of passkeys has been produced.</p>
<p id="p-0212" num="0213">The method continues at step <b>354</b> where the processing module generates a set of decryption keys based on the set of values (e.g., generated based on the set of blinded random numbers) and the set of passkeys. Such generating includes transforming each passkey of the set of passkeys utilizing a modulo function based on security parameters and a corresponding value of the set of values to produce a decryption key of the set of decryption keys. For example, the processing module generates key x based on the value v<sub>x </sub>and passkey x in accordance with the expression key x=(passkey x)<sup>v</sup><sub>x </sub>modulo p.</p>
<p id="p-0213" num="0214">The method continues at step <b>356</b> where the processing module retrieves at least a decode threshold number of encrypted shares to produce a set of encrypted shares, wherein the set of encrypted shares corresponds to the set of stored random numbers. Such retrieving includes at least one of outputting at least one encrypted share retrieval request message to at least one DS processing to retrieve the at least the decode threshold number of encrypted shares from a dispersed storage network (DSN) memory and for each encrypted share of the set of encrypted shares, retrieving a set of encoded encrypted share slices from the DSN memory and dispersed storage error decoding the set of encoded encrypted share slices to produce the encrypted share.</p>
<p id="p-0214" num="0215">The method continues at step <b>358</b> where the processing module decrypts each encrypted share of the set of encrypted shares utilizing a corresponding decryption key of the set of decryption keys to produce a set of shares. Such decrypting may be in accordance with a decryption algorithm based on one or more of the security parameters, error coding dispersal storage function parameters, a user identifier (ID), a vault ID, a vault lookup, security requirements, a security status indicator, a message, and a command.</p>
<p id="p-0215" num="0216">The method continues at step <b>360</b> where the processing module decodes the set of shares to reproduce data. Such decoding includes at least one of dispersed storage error decoding the set of shares to produce the data and decoding the set of shares utilizing a secret sharing function to produce the data (e.g., a credential package).</p>
<p id="p-0216" num="0217">The method continues at step <b>362</b> where the processing module validates the data when the data is a credential package. Such validating includes comparing a calculated hash of a credential of the credential package to a credential hash digest of the credential package. For example, the processing module determines that the credential package is valid when the comparison indicates that the calculated hash of the credential is substantially the same as the credential hash digest.</p>
<p id="p-0217" num="0218"><figref idref="DRAWINGS">FIG. 19</figref> is a flowchart illustrating an example of generating a passkey. The method begins with step <b>364</b> where the processing module receives a passkey x request, wherein the request includes a blinded password x of a set of blinded passwords. Alternatively, the processing module receives the set of blinded passwords. Such a passkey x request may include a passkey x identifier, the blinded password x, a user identifier (ID), a vault ID, a source name, one or more slice names, and a random number identifier (e.g., a data object name, a block number, a source name, a directory identifier, etc.). For example, the processing module receives the passkey x request from a user device, wherein the request includes the blinded password x and a data object name affiliated with a desired random number e<sub>x</sub>.</p>
<p id="p-0218" num="0219">The method continues at step <b>366</b> where the processing module retrieves at least a decode threshold number of stored random numbers to produce a set of stored random numbers. Such retrieving includes at least one of outputting at least one stored random number retrieval request message to at least one dispersed storage (DS) processing unit to retrieve the at least the decode threshold number of stored random numbers from a dispersed storage network (DSN) memory, for each stored random number of the set of stored random numbers retrieving a set of encoded stored random number slices from the DSN memory, and dispersed storage error decoding the set of encoded stored random number slices to produce the stored random number. For example, the processing module retrieves a set of encoded stored random number slices corresponding to a received data object name affiliated with the desired random number e<sub>x </sub>and dispersed storage error decodes the set of encoded stored random number slices to produce stored random number e<sub>x</sub>.</p>
<p id="p-0219" num="0220">The method continues at step <b>368</b> where the processing module generates a set of passkeys based on the set of blinded passwords and the set of stored random numbers. Such generation includes transforming the blinded password utilizing a modulo function based on a corresponding stored random number of the set of stored random numbers and security parameters to produce a passkey of the set of passkeys for each blinded password of the set of blinded passwords and outputting the set of blinded passwords to a DS processing unit and receiving the set of passkeys. For example, the processing module generates a passkey x based on stored random number e<sub>x </sub>and blinded password x in accordance with an expression passkey x=(blinded password x)<sup>e</sup><sub>x </sub>modulo p. The method continues at step <b>370</b> where the processing module outputs the passkey x (e.g., to a requester).</p>
<p id="p-0220" num="0221">The methods described above operate in accordance with the mathematical expressions described in the methods above to enable generation of keys utilized to encrypt and decrypt shares of a credential package. The mathematical expressions may be further understood in consideration of the following mathematical proof, wherein the proof illustrates that a reproduced key (e.g., to decrypt an encrypted share) is substantially equivalent to an original key (e.g., utilized to encrypt the share).</p>
<p id="h-0007" num="0000">Proof&#x2014;Recall that:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>b*v=</i>1 mod <i>q </i>and <i>p=</i>2*<i>q+</i>1<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
Will show that:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>(<i>MGF</i>(password)^2)^(<i>b*e*v</i>) equals (<i>MGF</i>(password)^2)^<i>e</i>(modulo <i>p</i>)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
Replace MGF(password) with X:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>(<i>X^</i>2)^(<i>b*e*v</i>)=(<i>X^</i>2)^(<i>e</i>)(modulo <i>p</i>)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
Note:
<br/>
Since b*v=1 mod q, it follows that: b*v=n*q+1, for some integer n. Note that (b*v)/q=n remainder 1.
<br/>
Therefore (b*v) can be substituted with (n*q+1) in the above expression yielding:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>(<i>X^</i>2)^((<i>n*q+</i>1)*<i>e</i>) mod <i>p </i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
Since p=2*q+1, take p out of the formula, giving:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>(<i>X^</i>2)^((<i>n*q+</i>1)*<i>e</i>) mod (2<i>*q+</i>1)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
Since X^2 is raised to a power, simply take X to the power of twice the exponent:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>X^(</i>2*(<i>nq+</i>1)*<i>e</i>) mod (2<i>q+</i>1)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
Which may be written as:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>X^((</i>2<i>nq+</i>2)*<i>e</i>) mod (2<i>q+</i>1)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
Multiplying both parts by e:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>X^(</i>2<i>nqe+</i>2<i>e</i>) mod (2<i>q+</i>1)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
Split these out as so:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>X^(</i>2<i>neq</i>)*<i>X^(</i>2<i>e</i>) mod (2<i>q+</i>1)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
Re-write the first power of X:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>X^(</i>2<i>q*ne</i>)*<i>X^(</i>2<i>e</i>) mod (2<i>q+</i>1)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
Which can also be written as:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>(<i>X^(</i>2<i>q</i>))^(<i>ne</i>)*<i>X^(</i>2<i>e</i>) mod (2<i>q+</i>1)<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
Un-doing the substitution of p for 2q+1, find:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>(<i>X^</i>(<i>p&#x2212;</i>1))^(<i>ne</i>)*<i>X^(</i>2<i>e</i>) mod <i>p </i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
Fermat's Little Theorem shows that for any prime number P, and any integer X, that:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>X</i>^(<i>P&#x2212;</i>1)=1 mod <i>P</i>, therefore (<i>X</i>^(<i>p&#x2212;</i>1)) mod <i>p=</i>1 mod <i>p</i>. This yields:<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>1^(<i>ne</i>)*<i>X^(</i>2<i>e</i>) mod <i>p </i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
Which is the same as:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>1<i>*X^(</i>2<i>e</i>) mod <i>p </i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>Which is:<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>(<i>X^</i>2)^<i>e </i>mod <i>p </i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
Which is the key.
<br/>
As a numerical example:
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>p=</i>23<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>q</i>=(<i>p&#x2212;</i>1)/2=11<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>let <i>e</i>1=10<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>let [mask generating function (common password)]^2=16<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>key 1=16<i>^e</i>1 mod 23=13<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>let <i>b</i>1=7<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>b</i>pass 1=16^7 mod 23=18<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>passkey 1<i>=b</i>pass^<i>e</i>1 mod <i>p=</i>18^10 mod 23=9<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>b*v=</i>1 modulo <i>q </i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>b</i>1*<i>v</i>1=1 mod <i>q </i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>7*<i>v</i>1=1 mod 11 note: 56 mod 11=1 so <i>v</i>1=8<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>regen key 1=passkey1^<i>v</i>1 modulo <i>p </i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?>9^8 mod 23=13, which checks with the 13 calculated above for key 1.<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0221" num="0222">As may be used herein, the terms &#x201c;substantially&#x201d; and &#x201c;approximately&#x201d; provides an industry-accepted tolerance for its corresponding term and/or relativity between items. Such an industry-accepted tolerance ranges from less than one percent to fifty percent and corresponds to, but is not limited to, component values, integrated circuit process variations, temperature variations, rise and fall times, and/or thermal noise. Such relativity between items ranges from a difference of a few percent to magnitude differences. As may also be used herein, the term(s) &#x201c;operably coupled to&#x201d;, &#x201c;coupled to&#x201d;, and/or &#x201c;coupling&#x201d; includes direct coupling between items and/or indirect coupling between items via an intervening item (e.g., an item includes, but is not limited to, a component, an element, a circuit, and/or a module) where, for indirect coupling, the intervening item does not modify the information of a signal but may adjust its current level, voltage level, and/or power level. As may further be used herein, inferred coupling (i.e., where one element is coupled to another element by inference) includes direct and indirect coupling between two items in the same manner as &#x201c;coupled to&#x201d;. As may even further be used herein, the term &#x201c;operable to&#x201d; or &#x201c;operably coupled to&#x201d; indicates that an item includes one or more of power connections, input(s), output(s), etc., to perform, when activated, one or more its corresponding functions and may further include inferred coupling to one or more other items. As may still further be used herein, the term &#x201c;associated with&#x201d;, includes direct and/or indirect coupling of separate items and/or one item being embedded within another item. As may be used herein, the term &#x201c;compares favorably&#x201d;, indicates that a comparison between two or more items, signals, etc., provides a desired relationship. For example, when the desired relationship is that signal <b>1</b> has a greater magnitude than signal <b>2</b>, a favorable comparison may be achieved when the magnitude of signal <b>1</b> is greater than that of signal <b>2</b> or when the magnitude of signal <b>2</b> is less than that of signal <b>1</b>.</p>
<p id="p-0222" num="0223">While the transistors in the above described figure(s) is/are shown as field effect transistors (FETs), as one of ordinary skill in the art will appreciate, the transistors may be implemented using any type of transistor structure including, but not limited to, bipolar, metal oxide semiconductor field effect transistors (MOSFET), N-well transistors, P-well transistors, enhancement mode, depletion mode, and zero voltage threshold (VT) transistors.</p>
<p id="p-0223" num="0224">The present invention has also been described above with the aid of method steps illustrating the performance of specified functions and relationships thereof. The boundaries and sequence of these functional building blocks and method steps have been arbitrarily defined herein for convenience of description. Alternate boundaries and sequences can be defined so long as the specified functions and relationships are appropriately performed. Any such alternate boundaries or sequences are thus within the scope and spirit of the claimed invention.</p>
<p id="p-0224" num="0225">The present invention has been described, at least in part, in terms of one or more embodiments. An embodiment of the present invention is used herein to illustrate the present invention, an aspect thereof, a feature thereof, a concept thereof, and/or an example thereof. A physical embodiment of an apparatus, an article of manufacture, a machine, and/or of a process that embodies the present invention may include one or more of the aspects, features, concepts, examples, etc. described with reference to one or more of the embodiments discussed herein.</p>
<p id="p-0225" num="0226">The present invention has been described above with the aid of functional building blocks illustrating the performance of certain significant functions. The boundaries of these functional building blocks have been arbitrarily defined for convenience of description. Alternate boundaries could be defined as long as the certain significant functions are appropriately performed. Similarly, flow diagram blocks may also have been arbitrarily defined herein to illustrate certain significant functionality. To the extent used, the flow diagram block boundaries and sequence could have been defined otherwise and still perform the certain significant functionality. Such alternate definitions of both functional building blocks and flow diagram blocks and sequences are thus within the scope and spirit of the claimed invention. One of average skill in the art will also recognize that the functional building blocks, and other illustrative blocks, modules and components herein, can be implemented as illustrated or by discrete components, application specific integrated circuits, processors executing appropriate software and the like or any combination thereof.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<us-claim-statement>What is claimed is:</us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A method comprises:
<claim-text>determining a retrieval threshold for retrieving encoded data slices from a dispersed storage network (DSN), wherein a set of encoded data slices represents data encoded using a dispersed storage error encoding function, wherein the set of encoded data slices includes a first group of encoded data slices and a second group of encoded data slices, wherein the set of encoded data slices includes a pillar width of encoded data slices and the pillar width is at least twice a decode threshold, wherein each of the first and second groups of encoded data slices includes at least a decode threshold of encoded data slices, and wherein the retrieval threshold is equal to or greater than the decode threshold;</claim-text>
<claim-text>issuing data retrieval requests to the DSN for the first or the second group of encoded data slices;</claim-text>
<claim-text>receiving encoded data slices of the first or the second group of encoded data slices to produce received encoded data slices; and</claim-text>
<claim-text>when a number of received encoded data slices compares favorably to the retrieval threshold, decoding the received encoded data slices to recapture the data.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprises:
<claim-text>the first group of encoded data slices having a revision level; and</claim-text>
<claim-text>the second group of encoded data slices having the revision level.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprises:
<claim-text>the first group of encoded data slices having a first revision level; and</claim-text>
<claim-text>the second group of encoded data slices having a second revision level.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the determining the retrieval threshold comprises:
<claim-text>determining whether at least a write threshold number of the set of encoded data slices have a desired revision level;</claim-text>
<claim-text>when the at least the write threshold number of the set of encoded data slices have the desired revision level, establishing the retrieval threshold based on the pillar width, the write threshold, and a first constant; and</claim-text>
<claim-text>when the at least the write threshold number of the set of encoded data slices does not have the desired revision level, establishing the retrieval threshold based on the pillar width, the decode threshold, and a second constant.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. A computing device comprises:
<claim-text>an interface;</claim-text>
<claim-text>a memory; and</claim-text>
<claim-text>a processing module operably coupled to the memory, wherein the processing module is configured to:
<claim-text>determine a retrieval threshold for retrieving encoded data slices from a dispersed storage network (DSN), wherein a set of encoded data slices represents data encoded using a dispersed storage error encoding function, wherein the set of encoded data slices includes a first group of encoded data slices and a second group of encoded data slices, wherein the set of encoded data slices includes a pillar width of encoded data slices and the pillar width is at least twice a decode threshold, wherein each of the first and second groups of encoded data slices includes at least a decode threshold of encoded data slices, and wherein the retrieval threshold is equal to or greater than the decode threshold;</claim-text>
<claim-text>issue, via the interface, data retrieval requests to the DSN for the first or the second group of encoded data slices;</claim-text>
<claim-text>receive, via the interface, encoded data slices of the first or the second group of encoded data slices to produce received encoded data slices; and</claim-text>
<claim-text>when a number of received encoded data slices compares favorably to the retrieval threshold, decode the received encoded data slices to recapture the data.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The computing device of <claim-ref idref="CLM-00005">claim 5</claim-ref> further comprises:
<claim-text>the first group of encoded data slices having a revision level; and</claim-text>
<claim-text>the second group of encoded data slices having the revision level.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The computing device of <claim-ref idref="CLM-00005">claim 5</claim-ref> further comprises:
<claim-text>the first group of encoded data slices having a first revision level; and</claim-text>
<claim-text>the second group of encoded data slices having a second revision level.</claim-text>
</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The computing device of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the processing module is further operable to determine the retrieval threshold by:
<claim-text>determining whether at least a write threshold number of the set of encoded data slices have a desired revision level;</claim-text>
<claim-text>when the at least the write threshold number of the set of encoded data slices have the desired revision level, establishing the retrieval threshold based on the pillar width, the write threshold, and a first constant; and</claim-text>
<claim-text>when the at least the write threshold number of the set of encoded data slices does not have the desired revision level, establishing the retrieval threshold based on the pillar width, the decode threshold, and a second constant.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>
